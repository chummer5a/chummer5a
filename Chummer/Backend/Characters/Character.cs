/*  This file is part of Chummer5a.
 *
 *  Chummer5a is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  Chummer5a is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with Chummer5a.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  You can obtain the full source code for Chummer5a at
 *  https://github.com/chummer5a/chummer5a
 */

using System;
using System.Buffers;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Xml;
using System.Xml.Serialization;
using System.Xml.XPath;
using Chummer.Annotations;
using Chummer.Backend.Attributes;
using Chummer.Backend.Enums;
using Chummer.Backend.Equipment;
using Chummer.Backend.Skills;
using Chummer.Backend.Uniques;
using Chummer.Plugins;
using Microsoft.ApplicationInsights;
using Microsoft.IO;
using Newtonsoft.Json;
using NLog;

namespace Chummer
{
    /// <summary>
    /// Class that holds all of the information that makes up a complete Character.
    /// </summary>
    [DebuggerDisplay("{CharacterName} ({FileName})")]
    public sealed class Character : INotifyMultiplePropertiesChangedAsync, IHasMugshots, IHasName, IHasSource, IHasXmlDataNode, IHasLockObject, IHasCharacterObject
    {
        private static readonly TelemetryClient TelemetryClient = new TelemetryClient();
        private static readonly Lazy<Logger> s_ObjLogger = new Lazy<Logger>(LogManager.GetCurrentClassLogger);
        private static Logger Log => s_ObjLogger.Value;
        private XmlNode _oldSkillsBackup;
        private XmlNode _oldSkillGroupBackup;
        private string _strFileName = string.Empty;
        private string _strSettingsKey = GlobalSettings.DefaultCharacterSetting;
        private bool _blnIgnoreRules;
        private int _intKarma;
        private int _intTotalKarma;
        private int _intStreetCred;
        private int _intNotoriety;
        private int _intPublicAwareness;
        private int _intBurntStreetCred;
        private decimal _decNuyen;
        private decimal _decStartingNuyen;
        private decimal _decEssenceAtSpecialStart = decimal.MinValue;
        private int _intSpecial;
        private int _intTotalSpecial;
        private int _intAttributes;
        private int _intTotalAttributes;
        private int _intFreeSpells;
        private int _intCFPLimit;
        private int _intAINormalProgramLimit;
        private int _intAIAdvancedProgramLimit;
        private int _intCachedContactPoints = int.MinValue;
        private int _intCachedRedlinerBonus = int.MinValue;
        private int _intCurrentCounterspellingDice;
        private int _intCurrentLiftCarryHits;
        private int _intEdgeUsed;
        private int _intBoundSpiritLimit = int.MinValue;
        private int _intRegisteredSpriteLimit = int.MinValue;
        private decimal _decCachedBaseCarryLimit = decimal.MinValue;
        private decimal _decCachedBaseLiftLimit = decimal.MinValue;
        private decimal _decCachedTotalCarriedWeight = decimal.MinValue;
        private decimal _decCachedEncumbranceInterval = decimal.MinValue;

        // General character info.
        private string _strName = string.Empty;

        private readonly ThreadSafeList<Image> _lstMugshots;
        private int _intMainMugshotIndex = -1;
        private string _strGender = string.Empty;
        private string _strAge = string.Empty;
        private string _strEyes = string.Empty;
        private string _strHeight = string.Empty;
        private string _strWeight = string.Empty;
        private string _strSkin = string.Empty;
        private string _strHair = string.Empty;
        private string _strDescription = string.Empty;
        private string _strBackground = string.Empty;
        private string _strConcept = string.Empty;
        private string _strNotes = string.Empty;
        private string _strAlias = string.Empty;
        private string _strPlayerName = string.Empty;
        private string _strGameNotes = string.Empty;
        private string _strPrimaryArm = "Right";

        public static readonly ReadOnlyCollection<string> LimbStrings = Array.AsReadOnly(new[]
            {"skull", "torso", "arm", "leg"});

        // AI Home Node

        // Active Commlink

        // If true, the Character creation has been finalized and is maintained through Karma.
        private bool _blnCreated;

        // Build Points
        private decimal _decNuyenBP;

        // Metatype Information.
        private string _strMetatype = "Human";
        private Guid _guiMetatype = Guid.Empty;
        private string _strMetavariant = string.Empty;
        private Guid _guiMetavariant = Guid.Empty;
        private string _strMetatypeCategory = "Metahuman";
        private string _strMovement = string.Empty;
        private string _strWalk = string.Empty;
        private string _strRun = string.Empty;
        private string _strSprint = string.Empty;
        private string _strWalkAlt = string.Empty;
        private string _strRunAlt = string.Empty;
        private string _strSprintAlt = string.Empty;
        private int _intMetatypeBP;
        private string _strSource;
        private string _strPage;
        private int _intInitiativeDice = 1;

        // Special Flags.

        private bool _blnAdeptEnabled;
        private bool _blnMagicianEnabled;
        private bool _blnTechnomancerEnabled;
        private bool _blnAdvancedProgramsEnabled;
        private bool _blnCyberwareDisabled;
        private bool _blnInitiationDisabled;
        private bool _blnCritterEnabled;
        private bool _blnIsCritter;
        private bool _blnPossessed;
        private decimal _decPrototypeTranshuman;
        private bool _blnMAGEnabled;
        private bool _blnRESEnabled;
        private bool _blnDEPEnabled;
        private bool _blnGroupMember;
        private string _strGroupName = string.Empty;
        private string _strGroupNotes = string.Empty;
        private int _intInitiateGrade;
        private int _intSubmersionGrade;
        private bool _blnPsycheActive;

        // Pseudo-Attributes use for Mystic Adepts.
        private int _intMAGMagician;

        private int _intMAGAdept;

        // Magic Tradition.
        private Tradition _objTradition;

        // Condition Monitor Progress.
        private int _intPhysicalCMFilled;

        private int _intStunCMFilled;

        // Spirit Reputation
        private int _intBaseAstralReputation;

        private int _intBaseWildReputation;

        // Priority Selections.
        private string _strPriorityMetatype = "A";

        private string _strPriorityAttributes = "B";
        private string _strPrioritySpecial = "C";
        private string _strPrioritySkills = "D";
        private string _strPriorityResources = "E";
        private string _strPriorityTalent = string.Empty;
        private readonly ThreadSafeList<string> _lstPrioritySkills;

        // Lists.
        private readonly ThreadSafeObservableCollection<Improvement> _lstImprovements;
        private readonly ThreadSafeObservableCollection<MentorSpirit> _lstMentorSpirits;
        private readonly ThreadSafeObservableCollection<Contact> _lstContacts;
        private readonly ThreadSafeObservableCollection<Spirit> _lstSpirits;
        private readonly ThreadSafeObservableCollection<Spell> _lstSpells;
        private readonly ThreadSafeObservableCollection<SustainedObject> _lstSustainedObjects;
        private readonly ThreadSafeList<Focus> _lstFoci;
        private readonly ThreadSafeList<StackedFocus> _lstStackedFoci;
        private readonly ThreadSafeBindingList<Power> _lstPowers;
        private readonly ThreadSafeObservableCollection<ComplexForm> _lstComplexForms;
        private readonly ThreadSafeObservableCollection<AIProgram> _lstAIPrograms;
        private readonly ThreadSafeObservableCollection<MartialArt> _lstMartialArts;
        private readonly ThreadSafeObservableCollection<LimitModifier> _lstLimitModifiers;
        private readonly ThreadSafeObservableCollection<Armor> _lstArmor;
        private readonly ThreadSafeObservableCollection<Cyberware> _lstCyberware;
        private readonly ThreadSafeObservableCollection<Weapon> _lstWeapons;
        private readonly ThreadSafeObservableCollection<Quality> _lstQualities;
        private readonly ThreadSafeObservableCollection<Lifestyle> _lstLifestyles;
        private readonly ThreadSafeObservableCollection<Gear> _lstGear;
        private readonly ThreadSafeObservableCollection<Vehicle> _lstVehicles;
        private readonly ThreadSafeObservableCollection<Metamagic> _lstMetamagics;
        private readonly ThreadSafeObservableCollection<Art> _lstArts;
        private readonly ThreadSafeObservableCollection<Enhancement> _lstEnhancements;
        private readonly ThreadSafeObservableCollection<ExpenseLogEntry> _lstExpenseLog;
        private readonly ThreadSafeObservableCollection<CritterPower> _lstCritterPowers;
        private readonly ThreadSafeObservableCollection<InitiationGrade> _lstInitiationGrades;
        private readonly ThreadSafeObservableCollection<Location> _lstGearLocations;
        private readonly ThreadSafeObservableCollection<Location> _lstArmorLocations;
        private readonly ThreadSafeObservableCollection<Location> _lstVehicleLocations;
        private readonly ThreadSafeObservableCollection<Location> _lstWeaponLocations;
        private readonly ThreadSafeObservableCollection<string> _lstImprovementGroups;
        private readonly ThreadSafeBindingList<CalendarWeek> _lstCalendar;
        private readonly ThreadSafeObservableCollection<Drug> _lstDrugs;

        private SortedDictionary<decimal, ValueTuple<string, string>> _dicAvailabilityMap;

        //private readonly List<LifeModule> _lstLifeModules = new List<LifeModule>(10);
        private ConcurrentBag<string> _lstInternalIdsNeedingReapplyImprovements = new ConcurrentBag<string>();

        // Character Version
        private string _strVersionCreated = Utils.CurrentChummerVersion.ToString(3);

        private ValueVersion _verSavedVersion;

        public AsyncFriendlyReaderWriterLock LockObject { get; }

        public Character CharacterObject => this;

        private readonly LockingOrderedSet<Func<Character, bool>> _setDoOnSaveCompleted;
        private readonly LockingOrderedSet<Func<Character, CancellationToken, Task<bool>>> _setDoOnSaveCompletedAsync;

        /// <summary>
        /// Set of unique methods to run after a <see cref="Save"/> or <see cref="SaveAsync"/> call is otherwise finished.
        /// Input is the character in question, output is if the code resolved without errors.
        /// </summary>
        [JsonIgnore]
        [XmlIgnore]
        [IgnoreDataMember]
        public LockingOrderedSet<Func<Character, bool>> DoOnSaveCompleted
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _setDoOnSaveCompleted;
            }
        }

        /// <summary>
        /// Set of unique async methods to run after a <see cref="Save"/> or <see cref="SaveAsync"/> call is otherwise finished.
        /// Input is the character in question, output is if the code resolved without errors.
        /// </summary>
        [JsonIgnore]
        [XmlIgnore]
        [IgnoreDataMember]
        public LockingOrderedSet<Func<Character, CancellationToken, Task<bool>>> DoOnSaveCompletedAsync
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _setDoOnSaveCompletedAsync;
            }
        }

        #region Initialization, Save, Load, Print, and Reset Methods

        /// <summary>
        /// Character.
        /// </summary>
        public Character()
        {
            if (Utils.IsDesignerMode || Utils.IsRunningInVisualStudio)
                _objSettings =
                    new CharacterSettings(); // Need this because ExpenseCharts is WPF and needs a Character in design mode.
            else if (!SettingsManager.LoadedCharacterSettings.TryGetValue(GlobalSettings.DefaultCharacterSetting,
                         out _objSettings)
                     && !SettingsManager.LoadedCharacterSettings.TryGetValue(
                         GlobalSettings.DefaultCharacterSettingDefaultValue, out _objSettings))
                _objSettings = SettingsManager.LoadedCharacterSettings.First().Value;

            LockObject = new AsyncFriendlyReaderWriterLock();
            _objCachedSourceDetailLock = new AsyncFriendlyReaderWriterLock(LockObject, true);
            _objCachedEssenceLock = new AsyncFriendlyReaderWriterLock(LockObject, true);
            _objCachedPowerPointsUsedLock = new AsyncFriendlyReaderWriterLock(LockObject, true);
            _objAvailabilityMapLock = new AsyncFriendlyReaderWriterLock(LockObject, true);
            _objCachedHasAnyQualitiesWithQualityLevelsLock = new AsyncFriendlyReaderWriterLock(LockObject, true);

            _setDoOnSaveCompleted = new LockingOrderedSet<Func<Character, bool>>(LockObject);
            _setDoOnSaveCompletedAsync =
                new LockingOrderedSet<Func<Character, CancellationToken, Task<bool>>>(LockObject);

            _lstMugshots = new ThreadSafeList<Image>(3, LockObject);
            _lstPrioritySkills = new ThreadSafeList<string>(3, LockObject);
            _lstFoci = new ThreadSafeList<Focus>(3, LockObject);
            _lstStackedFoci = new ThreadSafeList<StackedFocus>(1, LockObject);
            _lstPowers = new ThreadSafeBindingList<Power>(LockObject);
            _lstCalendar = new ThreadSafeBindingList<CalendarWeek>(LockObject);
            _lstImprovements = new ThreadSafeObservableCollection<Improvement>(LockObject);
            _lstMentorSpirits = new ThreadSafeObservableCollection<MentorSpirit>(LockObject);
            _lstContacts = new ThreadSafeObservableCollection<Contact>(LockObject);
            _lstSpirits = new ThreadSafeObservableCollection<Spirit>(LockObject);
            _lstSpells = new ThreadSafeObservableCollection<Spell>(LockObject);
            _lstSustainedObjects = new ThreadSafeObservableCollection<SustainedObject>(LockObject);
            _lstComplexForms = new ThreadSafeObservableCollection<ComplexForm>(LockObject);
            _lstAIPrograms = new ThreadSafeObservableCollection<AIProgram>(LockObject);
            _lstMartialArts = new ThreadSafeObservableCollection<MartialArt>(LockObject);
            _lstLimitModifiers = new ThreadSafeObservableCollection<LimitModifier>(LockObject);
            _lstArmor = new ThreadSafeObservableCollection<Armor>(LockObject);
            _lstCyberware = new ThreadSafeObservableCollection<Cyberware>(LockObject);
            _lstWeapons = new ThreadSafeObservableCollection<Weapon>(LockObject);
            _lstQualities = new ThreadSafeObservableCollection<Quality>(LockObject);
            _lstLifestyles = new ThreadSafeObservableCollection<Lifestyle>(LockObject);
            _lstGear = new ThreadSafeObservableCollection<Gear>(LockObject);
            _lstVehicles = new ThreadSafeObservableCollection<Vehicle>(LockObject);
            _lstMetamagics = new ThreadSafeObservableCollection<Metamagic>(LockObject);
            _lstArts = new ThreadSafeObservableCollection<Art>(LockObject);
            _lstEnhancements = new ThreadSafeObservableCollection<Enhancement>(LockObject);
            _lstExpenseLog = new ThreadSafeObservableCollection<ExpenseLogEntry>(LockObject);
            _lstCritterPowers = new ThreadSafeObservableCollection<CritterPower>(LockObject);
            _lstInitiationGrades = new ThreadSafeObservableCollection<InitiationGrade>(LockObject);
            _lstGearLocations = new ThreadSafeObservableCollection<Location>(LockObject);
            _lstArmorLocations = new ThreadSafeObservableCollection<Location>(LockObject);
            _lstVehicleLocations = new ThreadSafeObservableCollection<Location>(LockObject);
            _lstWeaponLocations = new ThreadSafeObservableCollection<Location>(LockObject);
            _lstImprovementGroups = new ThreadSafeObservableCollection<string>(LockObject);
            _lstDrugs = new ThreadSafeObservableCollection<Drug>(LockObject);

            _objSettings.MultiplePropertiesChangedAsync += OptionsOnPropertyChanged;
            _objAttributeSection = new AttributeSection(this);
            _objAttributeSection.Reset(true);
            _objAttributeSection.MultiplePropertiesChangedAsync += AttributeSectionOnPropertyChanged;

            _objSkillsSection = new SkillsSection(this);
            _objSkillsSection.Reset(true);

            _lstCyberware.CollectionChangedAsync += CyberwareOnCollectionChanged;
            _lstArmor.CollectionChangedAsync += ArmorOnCollectionChanged;
            _lstWeapons.CollectionChangedAsync += WeaponsOnCollectionChanged;
            _lstGear.CollectionChangedAsync += GearOnCollectionChanged;
            _lstContacts.CollectionChangedAsync += ContactsOnCollectionChanged;
            _lstExpenseLog.CollectionChangedAsync += ExpenseLogOnCollectionChanged;
            _lstMentorSpirits.CollectionChangedAsync += MentorSpiritsOnCollectionChanged;
            _lstPowers.ListChangedAsync += PowersOnListChanged;
            _lstPowers.BeforeRemoveAsync += PowersOnBeforeRemove;
            _lstQualities.CollectionChangedAsync += QualitiesCollectionChanged;
            _lstCalendar.BeforeRemoveAsync += CalendarOnBeforeRemove;
            _lstMartialArts.CollectionChangedAsync += MartialArtsOnCollectionChanged;
            _lstMetamagics.CollectionChangedAsync += MetamagicsOnCollectionChanged;
            _lstSpells.CollectionChangedAsync += SustainableOnCollectionChanged;
            _lstComplexForms.CollectionChangedAsync += SustainableOnCollectionChanged;
            _lstCritterPowers.CollectionChangedAsync += SustainableOnCollectionChanged;
            _lstSustainedObjects.CollectionChangedAsync += SustainedObjectsOnCollectionChanged;
            _lstInitiationGrades.CollectionChangedAsync += InitiationGradesOnCollectionChanged;
            _objTradition = new Tradition(this);
        }

        private async Task CalendarOnBeforeRemove(object sender, RemovingOldEventArgs e, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            await (await (await GetCalendarAsync(token).ConfigureAwait(false)).GetValueAtAsync(e.OldIndex, token).ConfigureAwait(false)).DisposeAsync()
                    .ConfigureAwait(false);
        }

        private bool _blnClearingInitiations;

        private async Task InitiationGradesOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (_blnClearingInitiations || IsLoading || e.Action == NotifyCollectionChangedAction.Move)
                return;
            bool blnUpdateSubmersion = false;
            bool blnUpdateInitiation = false;
            switch (e.Action)
            {
                case NotifyCollectionChangedAction.Add:
                    foreach (InitiationGrade objGrade in e.NewItems)
                    {
                        if (objGrade.Technomancer)
                        {
                            blnUpdateSubmersion = true;
                            if (blnUpdateInitiation)
                                break;
                        }
                        else
                        {
                            blnUpdateInitiation = true;
                            if (blnUpdateSubmersion)
                                break;
                        }
                    }
                    break;
                case NotifyCollectionChangedAction.Remove:
                    foreach (InitiationGrade objGrade in e.OldItems)
                    {
                        if (objGrade.Technomancer)
                        {
                            blnUpdateSubmersion = true;
                            if (blnUpdateInitiation)
                                break;
                        }
                        else
                        {
                            blnUpdateInitiation = true;
                            if (blnUpdateSubmersion)
                                break;
                        }
                    }
                    break;
                case NotifyCollectionChangedAction.Replace:
                    foreach (InitiationGrade objGrade in e.OldItems)
                    {
                        if (objGrade.Technomancer)
                        {
                            blnUpdateSubmersion = true;
                            if (blnUpdateInitiation)
                                break;
                        }
                        else
                        {
                            blnUpdateInitiation = true;
                            if (blnUpdateSubmersion)
                                break;
                        }
                    }
                    if (blnUpdateInitiation && blnUpdateSubmersion)
                        break;
                    foreach (InitiationGrade objGrade in e.NewItems)
                    {
                        if (objGrade.Technomancer)
                        {
                            blnUpdateSubmersion = true;
                            if (blnUpdateInitiation)
                                break;
                        }
                        else
                        {
                            blnUpdateInitiation = true;
                            if (blnUpdateSubmersion)
                                break;
                        }
                    }
                    break;
                case NotifyCollectionChangedAction.Reset:
                    blnUpdateInitiation = true;
                    blnUpdateSubmersion = true;
                    break;
            }
            if (!blnUpdateSubmersion && !blnUpdateInitiation)
                return;
            // Need a complete recalculation because of potential issues where grades can change in between the grade getter and setter calls.
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                ThreadSafeObservableCollection<InitiationGrade> lstInitiationGrades = await GetInitiationGradesAsync(token).ConfigureAwait(false);
                // Don't do checks for update submersion/initiation in the accumulator because it's faster to just index counts than to do those checks every iteration.
                int intSubmersion = await lstInitiationGrades.CountAsync(objItem => objItem.Technomancer, token: token).ConfigureAwait(false);
                if (blnUpdateInitiation)
                {
                    int intInitiation = await lstInitiationGrades.GetCountAsync(token).ConfigureAwait(false) - intSubmersion;
                    if (blnUpdateSubmersion)
                        await SetSubmersionGradeAsync(intSubmersion, token).ConfigureAwait(false);
                    await SetInitiateGradeAsync(intInitiation, token).ConfigureAwait(false);
                }
                else
                    await SetSubmersionGradeAsync(intSubmersion, token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private async Task SustainableOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            if (SustainedCollection.Count == 0 || IsLoading)
                return;
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                switch (e.Action)
                {
                    case NotifyCollectionChangedAction.Add:
                        break;

                    case NotifyCollectionChangedAction.Remove:
                    case NotifyCollectionChangedAction.Replace:
                        foreach (IHasInternalId objItem in e.OldItems)
                        {
                            for (int i = await SustainedCollection.GetCountAsync(token).ConfigureAwait(false);
                                 i >= 0;
                                 --i)
                            {
                                SustainedObject objLoop = await SustainedCollection.GetValueAtAsync(i, token)
                                    .ConfigureAwait(false);
                                if (!ReferenceEquals(objLoop.LinkedObject, objItem))
                                    continue;
                                await SustainedCollection.RemoveAtAsync(i, token).ConfigureAwait(false);
                            }
                        }

                        break;

                    case NotifyCollectionChangedAction.Move:
                        break;

                    case NotifyCollectionChangedAction.Reset:
                        for (int i = await SustainedCollection.GetCountAsync(token).ConfigureAwait(false); i >= 0; --i)
                        {
                            SustainedObject objLoop =
                                await SustainedCollection.GetValueAtAsync(i, token).ConfigureAwait(false);
                            if (await Spells.AnyAsync(
                                    y => ReferenceEquals(y, objLoop.LinkedObject), token: token).ConfigureAwait(false)
                                || await ComplexForms.AnyAsync(
                                    y => ReferenceEquals(y, objLoop.LinkedObject), token: token).ConfigureAwait(false)
                                || await CritterPowers.AnyAsync(
                                    y => ReferenceEquals(y, objLoop.LinkedObject), token: token).ConfigureAwait(false))
                                continue;
                            await SustainedCollection.RemoveAtAsync(i, token).ConfigureAwait(false);
                        }

                        break;
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public XmlNode GetNode(bool blnReturnMetatypeOnly, string strLanguage = "", CancellationToken token = default)
        {
            return Utils.SafelyRunSynchronously(() => GetNodeCoreAsync(true, blnReturnMetatypeOnly, strLanguage, token), token);
        }

        public Task<XmlNode> GetNodeAsync(bool blnReturnMetatypeOnly, string strLanguage = "", CancellationToken token = default)
        {
            return GetNodeCoreAsync(false, blnReturnMetatypeOnly, strLanguage, token);
        }

        public Task<XmlNode> GetNodeCoreAsync(bool blnSync, string strLanguage, CancellationToken token = default)
        {
            return GetNodeCoreAsync(blnSync, false, strLanguage, token);
        }

        public async Task<XmlNode> GetNodeCoreAsync(bool blnSync, bool blnReturnMetatypeOnly, string strLanguage, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IDisposable objLocker = null;
            IAsyncDisposable objLockerAsync = null;
            if (blnSync)
                // ReSharper disable once MethodHasAsyncOverload
                objLocker = LockObject.EnterReadLock(token);
            else
                objLockerAsync = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                string strFile = (blnSync ? IsCritter : await GetIsCritterAsync(token).ConfigureAwait(false)) ? "critters.xml" : "metatypes.xml";
                XmlDocument xmlDoc = blnSync
                    // ReSharper disable once MethodHasAsyncOverload
                    ? LoadData(strFile, strLanguage, token: token)
                    : await LoadDataAsync(strFile, strLanguage, token: token).ConfigureAwait(false);
                XmlNode xmlMetatypeNode = MetatypeGuid == Guid.Empty
                    ? xmlDoc.TryGetNodeByNameOrId("/chummer/metatypes/metatype", Metatype)
                    : xmlDoc.TryGetNodeById("/chummer/metatypes/metatype", MetatypeGuid);
                if (blnReturnMetatypeOnly)
                    return xmlMetatypeNode;
                if (MetavariantGuid == Guid.Empty || string.IsNullOrEmpty(Metavariant) || xmlMetatypeNode == null)
                    return xmlMetatypeNode;
                XmlNode xmlMetavariantNode = null;
                if (MetatypeGuid != Guid.Empty)
                    xmlMetavariantNode = xmlMetatypeNode.TryGetNodeById("metavariants/metavariant", MetavariantGuid);
                if (xmlMetavariantNode == null)
                    xmlMetavariantNode = xmlMetatypeNode.TryGetNodeByNameOrId("metavariants/metavariant", Metavariant);

                return xmlMetavariantNode ?? xmlMetatypeNode;
            }
            finally
            {
                objLocker?.Dispose();
                if (objLockerAsync != null)
                    await objLockerAsync.DisposeAsync().ConfigureAwait(false);
            }
        }

        public XPathNavigator GetNodeXPath(bool blnReturnMetatypeOnly, string strLanguage = "", CancellationToken token = default)
        {
            return Utils.SafelyRunSynchronously(() => GetNodeXPathCoreAsync(true, blnReturnMetatypeOnly, strLanguage, token), token);
        }

        public Task<XPathNavigator> GetNodeXPathAsync(bool blnReturnMetatypeOnly, string strLanguage = "", CancellationToken token = default)
        {
            return GetNodeXPathCoreAsync(false, blnReturnMetatypeOnly, strLanguage, token);
        }

        public Task<XPathNavigator> GetNodeXPathCoreAsync(bool blnSync, string strLanguage, CancellationToken token = default)
        {
            return GetNodeXPathCoreAsync(blnSync, false, strLanguage, token);
        }

        public async Task<XPathNavigator> GetNodeXPathCoreAsync(bool blnSync, bool blnReturnMetatypeOnly, string strLanguage, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IDisposable objLocker = null;
            IAsyncDisposable objLockerAsync = null;
            if (blnSync)
                // ReSharper disable once MethodHasAsyncOverload
                objLocker = LockObject.EnterReadLock(token);
            else
                objLockerAsync = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                string strFile = (blnSync ? IsCritter : await GetIsCritterAsync(token).ConfigureAwait(false)) ? "critters.xml" : "metatypes.xml";
                XPathNavigator xmlDoc = blnSync
                    // ReSharper disable once MethodHasAsyncOverload
                    ? LoadDataXPath(strFile, strLanguage, token: token)
                    : await LoadDataXPathAsync(strFile, strLanguage, token: token).ConfigureAwait(false);
                XPathNavigator xmlMetatypeNode = MetatypeGuid == Guid.Empty
                    ? xmlDoc.TryGetNodeByNameOrId("/chummer/metatypes/metatype", Metatype)
                    : xmlDoc.TryGetNodeById("/chummer/metatypes/metatype", MetatypeGuid);
                if (blnReturnMetatypeOnly)
                    return xmlMetatypeNode;
                if (MetavariantGuid == Guid.Empty || string.IsNullOrEmpty(Metavariant) || xmlMetatypeNode == null)
                    return xmlMetatypeNode;
                XPathNavigator xmlMetavariantNode = null;
                if (MetavariantGuid != Guid.Empty)
                    xmlMetavariantNode = xmlMetatypeNode.TryGetNodeById("/metavariants/metavariant", MetavariantGuid);
                if (xmlMetavariantNode == null)
                    xmlMetavariantNode = xmlMetatypeNode.TryGetNodeByNameOrId("metavariants/metavariant", Metavariant);

                return xmlMetavariantNode ?? xmlMetatypeNode;
            }
            finally
            {
                objLocker?.Dispose();
                if (objLockerAsync != null)
                    await objLockerAsync.DisposeAsync().ConfigureAwait(false);
            }
        }

        public void RefreshAttributeBindings(CancellationToken token = default)
        {
            using (LockObject.EnterUpgradeableReadLock(token))
            {
                token.ThrowIfCancellationRequested();
                // First remove all existing bindings
                foreach (CharacterAttrib objAttribute in GetAllAttributesForModification(token))
                {
                    switch (objAttribute.Abbrev.ToUpperInvariant())
                    {
                        case "BOD":
                            objAttribute.MultiplePropertiesChangedAsync -= RefreshBODDependentProperties;
                            break;

                        case "AGI":
                            objAttribute.MultiplePropertiesChangedAsync -= RefreshAGIDependentProperties;
                            break;

                        case "REA":
                            objAttribute.MultiplePropertiesChangedAsync -= RefreshREADependentProperties;
                            break;

                        case "STR":
                            objAttribute.MultiplePropertiesChangedAsync -= RefreshSTRDependentProperties;
                            break;

                        case "CHA":
                            objAttribute.MultiplePropertiesChangedAsync -= RefreshCHADependentProperties;
                            break;

                        case "INT":
                            objAttribute.MultiplePropertiesChangedAsync -= RefreshINTDependentProperties;
                            break;

                        case "LOG":
                            objAttribute.MultiplePropertiesChangedAsync -= RefreshLOGDependentProperties;
                            break;

                        case "WIL":
                            objAttribute.MultiplePropertiesChangedAsync -= RefreshWILDependentProperties;
                            break;

                        case "EDG":
                            objAttribute.MultiplePropertiesChangedAsync -= RefreshEDGDependentProperties;
                            break;

                        case "MAG":
                            objAttribute.MultiplePropertiesChangedAsync -= RefreshMAGDependentProperties;
                            break;

                        case "MAGADEPT":
                            objAttribute.MultiplePropertiesChangedAsync -= RefreshMAGAdeptDependentProperties;
                            break;

                        case "RES":
                            objAttribute.MultiplePropertiesChangedAsync -= RefreshRESDependentProperties;
                            break;

                        case "DEP":
                            objAttribute.MultiplePropertiesChangedAsync -= RefreshDEPDependentProperties;
                            break;

                        case "ESS":
                            objAttribute.MultiplePropertiesChangedAsync -= RefreshESSDependentProperties;
                            break;
                    }
                }

                foreach (string strAbbrev in AttributeSection.AttributeStrings)
                {
                    CharacterAttrib objAttribute = GetAttribute(strAbbrev, true, token);
                    if (objAttribute == null)
                        continue;
                    switch (strAbbrev.ToUpperInvariant())
                    {
                        case "BOD":
                            objAttribute.MultiplePropertiesChangedAsync += RefreshBODDependentProperties;
                            break;

                        case "AGI":
                            objAttribute.MultiplePropertiesChangedAsync += RefreshAGIDependentProperties;
                            break;

                        case "REA":
                            objAttribute.MultiplePropertiesChangedAsync += RefreshREADependentProperties;
                            break;

                        case "STR":
                            objAttribute.MultiplePropertiesChangedAsync += RefreshSTRDependentProperties;
                            break;

                        case "CHA":
                            objAttribute.MultiplePropertiesChangedAsync += RefreshCHADependentProperties;
                            break;

                        case "INT":
                            objAttribute.MultiplePropertiesChangedAsync += RefreshINTDependentProperties;
                            break;

                        case "LOG":
                            objAttribute.MultiplePropertiesChangedAsync += RefreshLOGDependentProperties;
                            break;

                        case "WIL":
                            objAttribute.MultiplePropertiesChangedAsync += RefreshWILDependentProperties;
                            break;

                        case "EDG":
                            objAttribute.MultiplePropertiesChangedAsync += RefreshEDGDependentProperties;
                            break;

                        case "MAG":
                            objAttribute.MultiplePropertiesChangedAsync += RefreshMAGDependentProperties;
                            break;

                        case "MAGADEPT":
                            objAttribute.MultiplePropertiesChangedAsync += RefreshMAGAdeptDependentProperties;
                            break;

                        case "RES":
                            objAttribute.MultiplePropertiesChangedAsync += RefreshRESDependentProperties;
                            break;

                        case "DEP":
                            objAttribute.MultiplePropertiesChangedAsync += RefreshDEPDependentProperties;
                            break;

                        case "ESS":
                            objAttribute.MultiplePropertiesChangedAsync += RefreshESSDependentProperties;
                            break;
                    }
                }
            }
        }

        public async Task RefreshAttributeBindingsAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            AttributeSection objAttributeSection = await GetAttributeSectionAsync(token).ConfigureAwait(false);
            IAsyncDisposable objLocker = await objAttributeSection.LockObject.EnterUpgradeableReadLockAsync(token)
                .ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                // First remove all existing bindings
                foreach (CharacterAttrib objAttribute in await GetAllAttributesForModificationAsync(token).ConfigureAwait(false))
                {
                    token.ThrowIfCancellationRequested();
                    switch (objAttribute.Abbrev.ToUpperInvariant())
                    {
                        case "BOD":
                            objAttribute.MultiplePropertiesChangedAsync -= RefreshBODDependentProperties;
                            break;
                        case "AGI":
                            objAttribute.MultiplePropertiesChangedAsync -= RefreshAGIDependentProperties;
                            break;
                        case "REA":
                            objAttribute.MultiplePropertiesChangedAsync -= RefreshREADependentProperties;
                            break;
                        case "STR":
                            objAttribute.MultiplePropertiesChangedAsync -= RefreshSTRDependentProperties;
                            break;
                        case "CHA":
                            objAttribute.MultiplePropertiesChangedAsync -= RefreshCHADependentProperties;
                            break;
                        case "INT":
                            objAttribute.MultiplePropertiesChangedAsync -= RefreshINTDependentProperties;
                            break;
                        case "LOG":
                            objAttribute.MultiplePropertiesChangedAsync -= RefreshLOGDependentProperties;
                            break;
                        case "WIL":
                            objAttribute.MultiplePropertiesChangedAsync -= RefreshWILDependentProperties;
                            break;
                        case "EDG":
                            objAttribute.MultiplePropertiesChangedAsync -= RefreshEDGDependentProperties;
                            break;
                        case "MAG":
                            objAttribute.MultiplePropertiesChangedAsync -= RefreshMAGDependentProperties;
                            break;
                        case "MAGADEPT":
                            objAttribute.MultiplePropertiesChangedAsync -= RefreshMAGAdeptDependentProperties;
                            break;
                        case "RES":
                            objAttribute.MultiplePropertiesChangedAsync -= RefreshRESDependentProperties;
                            break;
                        case "DEP":
                            objAttribute.MultiplePropertiesChangedAsync -= RefreshDEPDependentProperties;
                            break;
                        case "ESS":
                            objAttribute.MultiplePropertiesChangedAsync -= RefreshESSDependentProperties;
                            break;
                    }
                }

                foreach (string strAbbrev in AttributeSection.AttributeStrings)
                {
                    CharacterAttrib objAttribute =
                        await GetAttributeAsync(strAbbrev, true, token).ConfigureAwait(false);
                    if (objAttribute == null)
                        continue;
                    switch (strAbbrev.ToUpperInvariant())
                    {
                        case "BOD":
                            objAttribute.MultiplePropertiesChangedAsync += RefreshBODDependentProperties;
                            break;

                        case "AGI":
                            objAttribute.MultiplePropertiesChangedAsync += RefreshAGIDependentProperties;
                            break;

                        case "REA":
                            objAttribute.MultiplePropertiesChangedAsync += RefreshREADependentProperties;
                            break;

                        case "STR":
                            objAttribute.MultiplePropertiesChangedAsync += RefreshSTRDependentProperties;
                            break;

                        case "CHA":
                            objAttribute.MultiplePropertiesChangedAsync += RefreshCHADependentProperties;
                            break;

                        case "INT":
                            objAttribute.MultiplePropertiesChangedAsync += RefreshINTDependentProperties;
                            break;

                        case "LOG":
                            objAttribute.MultiplePropertiesChangedAsync += RefreshLOGDependentProperties;
                            break;

                        case "WIL":
                            objAttribute.MultiplePropertiesChangedAsync += RefreshWILDependentProperties;
                            break;

                        case "EDG":
                            objAttribute.MultiplePropertiesChangedAsync += RefreshEDGDependentProperties;
                            break;

                        case "MAG":
                            objAttribute.MultiplePropertiesChangedAsync += RefreshMAGDependentProperties;
                            break;

                        case "MAGADEPT":
                            objAttribute.MultiplePropertiesChangedAsync += RefreshMAGAdeptDependentProperties;
                            break;

                        case "RES":
                            objAttribute.MultiplePropertiesChangedAsync += RefreshRESDependentProperties;
                            break;

                        case "DEP":
                            objAttribute.MultiplePropertiesChangedAsync += RefreshDEPDependentProperties;
                            break;

                        case "ESS":
                            objAttribute.MultiplePropertiesChangedAsync += RefreshESSDependentProperties;
                            break;
                    }
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private Task OptionsOnPropertyChanged(object sender, MultiplePropertiesChangedEventArgs e,
            CancellationToken token = default)
        {
            return OptionsOnMultiplePropertyChanged(e.PropertyNames, token);
        }

        private async Task OptionsOnMultiplePropertyChanged(IReadOnlyCollection<string> lstProperties, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                       out HashSet<string> setPropertiesToRefresh))
            {
                foreach (string strPropertyName in lstProperties)
                {
                    switch (strPropertyName)
                    {
                        case nameof(CharacterSettings.UseCalculatedPublicAwareness):
                            setPropertiesToRefresh.Add(nameof(CalculatedPublicAwareness));
                            break;

                        case nameof(CharacterSettings.SpiritForceBasedOnTotalMAG):
                            setPropertiesToRefresh.Add(nameof(MaxSpiritForce));
                            break;

                        case nameof(CharacterSettings.CyberlegMovement):
                            setPropertiesToRefresh.Add(nameof(Movement));
                            break;

                        case nameof(CharacterSettings.AllowInitiationInCreateMode):
                            setPropertiesToRefresh.Add(nameof(AddInitiationsAllowed));
                            break;

                        case nameof(CharacterSettings.MysAdeptAllowPpCareer):
                            setPropertiesToRefresh.Add(nameof(MysAdeptAllowPPCareer));
                            break;

                        case nameof(CharacterSettings.MysAdeptSecondMAGAttribute):
                            setPropertiesToRefresh.Add(nameof(UseMysticAdeptPPs));
                            setPropertiesToRefresh.Add(nameof(AllowAdeptWayPowerDiscount));
                            break;

                        case nameof(CharacterSettings.ContactPointsExpression):
                            setPropertiesToRefresh.Add(nameof(ContactPoints));
                            break;

                        case nameof(CharacterSettings.SpecialKarmaCostBasedOnShownValue):
                            setPropertiesToRefresh.Add(nameof(EssenceAtSpecialStart)); // Proxy for refreshing Essence loss improvements
                            break;

                        case nameof(CharacterSettings.NuyenFormat):
                            setPropertiesToRefresh.Add(nameof(DisplayNuyen));
                            setPropertiesToRefresh.Add(nameof(DisplayCareerNuyen));
                            break;

                        case nameof(CharacterSettings.WeightFormat):
                            setPropertiesToRefresh.Add(nameof(LiftAndCarryLimits));
                            setPropertiesToRefresh.Add(nameof(DisplayTotalCarriedWeight));
                            break;

                        case nameof(CharacterSettings.EssenceFormat):
                        case nameof(CharacterSettings.DontRoundEssenceInternally):
                        case nameof(CharacterSettings.EssenceModifierPostExpression):
                            setPropertiesToRefresh.Add(nameof(PrototypeTranshumanEssenceUsed));
                            setPropertiesToRefresh.Add(nameof(BiowareEssence));
                            setPropertiesToRefresh.Add(nameof(CyberwareEssence));
                            setPropertiesToRefresh.Add(nameof(EssenceHole));
                            break;

                        case nameof(CharacterSettings.NuyenMaximumBP):
                        case nameof(CharacterSettings.UnrestrictedNuyen):
                            setPropertiesToRefresh.Add(nameof(TotalNuyenMaximumBP));
                            break;

                        case nameof(CharacterSettings.KarmaMysticAdeptPowerPoint):
                            setPropertiesToRefresh.Add(nameof(CanAffordCareerPP));
                            break;

                        case nameof(CharacterSettings.BuildMethod):
                            setPropertiesToRefresh.Add(nameof(EffectiveBuildMethod));
                            break;

                        case nameof(CharacterSettings.AutomaticBackstory):
                            setPropertiesToRefresh.Add(nameof(EnableAutomaticStoryButton));
                            break;

                        case nameof(CharacterSettings.ChargenKarmaToNuyenExpression):
                            setPropertiesToRefresh.Add(nameof(TotalStartingNuyen));
                            break;

                        case nameof(CharacterSettings.LimbCount):
                            setPropertiesToRefresh.Add(nameof(LimbCount));
                            break;

                        case nameof(CharacterSettings.MetatypeCostsKarmaMultiplier):
                            setPropertiesToRefresh.Add(nameof(DisplayMetatypeBP));
                            break;

                        case nameof(CharacterSettings.RedlinerExcludes):
                            setPropertiesToRefresh.Add(nameof(RedlinerBonus));
                            break;

                        case nameof(CharacterSettings.NoArmorEncumbrance):
                            setPropertiesToRefresh.Add(nameof(ArmorEncumbrance));
                            break;

                        case nameof(CharacterSettings.UncappedArmorAccessoryBonuses):
                            setPropertiesToRefresh.Add(nameof(ArmorEncumbrance));
                            setPropertiesToRefresh.Add(nameof(GetArmorRatingWithImprovement));
                            break;

                        case nameof(CharacterSettings.KarmaQuality):
                        case nameof(CharacterSettings.QualityKarmaLimit):
                            setPropertiesToRefresh.Add(nameof(PositiveQualityLimitKarma));
                            setPropertiesToRefresh.Add(nameof(PositiveQualityKarma));
                            setPropertiesToRefresh.Add(nameof(NegativeQualityLimitKarma));
                            setPropertiesToRefresh.Add(nameof(NegativeQualityKarma));
                            break;

                        case nameof(CharacterSettings.ExceedPositiveQualitiesCostDoubled):
                            setPropertiesToRefresh.Add(nameof(PositiveQualityLimitKarma));
                            setPropertiesToRefresh.Add(nameof(PositiveQualityKarma));
                            break;

                        case nameof(CharacterSettings.EnemyKarmaQualityLimit):
                        case nameof(CharacterSettings.ExceedNegativeQualitiesNoBonus):
                            setPropertiesToRefresh.Add(nameof(NegativeQualityLimitKarma));
                            setPropertiesToRefresh.Add(nameof(NegativeQualityKarma));
                            break;

                        case nameof(CharacterSettings.EnableEnemyTracking):
                        case nameof(CharacterSettings.KarmaEnemy):
                            setPropertiesToRefresh.Add(nameof(EnemyKarma));
                            break;

                        case nameof(CharacterSettings.DicePenaltySustaining):
                            setPropertiesToRefresh.Add(nameof(SustainingPenalty));
                            break;

                        case nameof(CharacterSettings.KarmaSpell):
                            if (await GetFreeSpellsAsync(token).ConfigureAwait(false) > 0)
                                setPropertiesToRefresh.Add(nameof(PositiveQualityKarma));
                            break;

                        case nameof(CharacterSettings.MinInitiativeDice):
                            {
                                IAsyncDisposable objLocker2 = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
                                try
                                {
                                    token.ThrowIfCancellationRequested();
                                    XPathNavigator objNode =
                                        await this.GetNodeXPathAsync(token: token).ConfigureAwait(false);
                                    if (objNode?.SelectSingleNodeAndCacheExpression("initiativedice", token: token) == null)
                                    {
                                        _intInitiativeDice = await (await GetSettingsAsync(token).ConfigureAwait(false)).GetMinInitiativeDiceAsync(token).ConfigureAwait(false);
                                        setPropertiesToRefresh.Add(nameof(InitiativeDice));
                                    }
                                }
                                finally
                                {
                                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                                }
                                break;
                            }

                        case nameof(CharacterSettings.MaxInitiativeDice):
                            setPropertiesToRefresh.Add(nameof(InitiativeDice));
                            break;

                        case nameof(CharacterSettings.MinAstralInitiativeDice):
                        case nameof(CharacterSettings.MaxAstralInitiativeDice):
                            setPropertiesToRefresh.Add(nameof(AstralInitiativeDice));
                            break;

                        case nameof(CharacterSettings.MinColdSimInitiativeDice):
                        case nameof(CharacterSettings.MaxColdSimInitiativeDice):
                            setPropertiesToRefresh.Add(nameof(MatrixInitiativeColdDice));
                            break;

                        case nameof(CharacterSettings.MinHotSimInitiativeDice):
                            setPropertiesToRefresh.Add(nameof(MatrixInitiativeHotDice));
                            if (await GetIsAIAsync(token).ConfigureAwait(false))
                                setPropertiesToRefresh.Add(nameof(MatrixInitiativeDice));
                            break;

                        case nameof(CharacterSettings.MaxHotSimInitiativeDice):
                            setPropertiesToRefresh.Add(nameof(MatrixInitiativeHotDice));
                            break;

                        case nameof(CharacterSettings.LiftLimitExpression):
                            setPropertiesToRefresh.Add(nameof(BaseLiftLimit));
                            break;

                        case nameof(CharacterSettings.CarryLimitExpression):
                            setPropertiesToRefresh.Add(nameof(BaseCarryLimit));
                            break;

                        case nameof(CharacterSettings.EncumbranceIntervalExpression):
                            setPropertiesToRefresh.Add(nameof(EncumbranceInterval));
                            break;

                        case nameof(CharacterSettings.DoEncumbrancePenaltyPhysicalLimit):
                        case nameof(CharacterSettings.DoEncumbrancePenaltyMovementSpeed):
                        case nameof(CharacterSettings.DoEncumbrancePenaltyAgility):
                        case nameof(CharacterSettings.DoEncumbrancePenaltyReaction):
                            setPropertiesToRefresh.Add(nameof(Encumbrance));
                            break;

                        case nameof(CharacterSettings.EncumbrancePenaltyPhysicalLimit):
                            if (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetDoEncumbrancePenaltyPhysicalLimitAsync(token).ConfigureAwait(false))
                                setPropertiesToRefresh.Add(nameof(Encumbrance));
                            break;

                        case nameof(CharacterSettings.EncumbrancePenaltyMovementSpeed):
                            if (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetDoEncumbrancePenaltyMovementSpeedAsync(token).ConfigureAwait(false))
                                setPropertiesToRefresh.Add(nameof(Encumbrance));
                            break;

                        case nameof(CharacterSettings.EncumbrancePenaltyAgility):
                            if (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetDoEncumbrancePenaltyAgilityAsync(token).ConfigureAwait(false))
                                setPropertiesToRefresh.Add(nameof(Encumbrance));
                            break;

                        case nameof(CharacterSettings.EncumbrancePenaltyReaction):
                            if (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetDoEncumbrancePenaltyReactionAsync(token).ConfigureAwait(false))
                                setPropertiesToRefresh.Add(nameof(Encumbrance));
                            break;

                        case nameof(CharacterSettings.DoEncumbrancePenaltyWoundModifier):
                            setPropertiesToRefresh.Add(nameof(WoundModifier));
                            setPropertiesToRefresh.Add(nameof(Encumbrance));
                            break;

                        case nameof(CharacterSettings.EncumbrancePenaltyWoundModifier):
                            if (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetDoEncumbrancePenaltyWoundModifierAsync(token).ConfigureAwait(false))
                            {
                                setPropertiesToRefresh.Add(nameof(WoundModifier));
                                setPropertiesToRefresh.Add(nameof(Encumbrance));
                            }

                            break;
                    }
                }

                IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    if (setPropertiesToRefresh.Count > 0)
                    {
                        await OnMultiplePropertiesChangedAsync(setPropertiesToRefresh, token).ConfigureAwait(false);
                    }

                    if (_lstSettingsMultiplePropertiesChangedAsync.Count > 0)
                    {
                        MultiplePropertiesChangedEventArgs objArgs = new MultiplePropertiesChangedEventArgs(lstProperties);
                        await ParallelExtensions.ForEachAsync(_setMultiplePropertiesChangedAsync, objEvent => objEvent.Invoke(this, objArgs, token), token).ConfigureAwait(false);

                        if (SettingsPropertyChanged != null)
                        {
                            await Utils.RunOnMainThreadAsync(() =>
                            {
                                // ReSharper disable once AccessToModifiedClosure
                                SettingsMultiplePropertiesChanged?.Invoke(this, objArgs);
                            }, token).ConfigureAwait(false);
                        }
                    }
                    else if (SettingsMultiplePropertiesChanged != null)
                    {
                        MultiplePropertiesChangedEventArgs objArgs = new MultiplePropertiesChangedEventArgs(lstProperties);
                        await Utils.RunOnMainThreadAsync(() =>
                        {
                            if (SettingsMultiplePropertiesChanged != null)
                            {
                                // ReSharper disable once AccessToModifiedClosure
                                SettingsMultiplePropertiesChanged?.Invoke(this, objArgs);
                            }
                        }, token).ConfigureAwait(false);
                    }

                    if (_lstSettingsPropertyChangedAsync.Count > 0)
                    {
                        List<PropertyChangedEventArgs> lstArgsList = lstProperties
                            .Select(x => new PropertyChangedEventArgs(x)).ToList();
                        List<ValueTuple<PropertyChangedAsyncEventHandler, PropertyChangedEventArgs>> lstAsyncEventsList
                            = new List<ValueTuple<PropertyChangedAsyncEventHandler, PropertyChangedEventArgs>>(lstArgsList.Count * _setPropertyChangedAsync.Count);
                        foreach (PropertyChangedAsyncEventHandler objEvent in _setPropertyChangedAsync)
                        {
                            foreach (PropertyChangedEventArgs objArg in lstArgsList)
                            {
                                lstAsyncEventsList.Add(new ValueTuple<PropertyChangedAsyncEventHandler, PropertyChangedEventArgs>(objEvent, objArg));
                            }
                        }
                        await ParallelExtensions.ForEachAsync(lstAsyncEventsList, tupEvent => tupEvent.Item1.Invoke(this, tupEvent.Item2, token), token).ConfigureAwait(false);

                        if (SettingsPropertyChanged != null)
                        {
                            await Utils.RunOnMainThreadAsync(() =>
                            {
                                if (SettingsPropertyChanged != null)
                                {
                                    // ReSharper disable once AccessToModifiedClosure
                                    foreach (PropertyChangedEventArgs objArgs in lstArgsList)
                                    {
                                        token.ThrowIfCancellationRequested();
                                        SettingsPropertyChanged.Invoke(this, objArgs);
                                    }
                                }
                            }, token).ConfigureAwait(false);
                        }
                    }
                    else if (SettingsPropertyChanged != null)
                    {
                        await Utils.RunOnMainThreadAsync(() =>
                        {
                            if (SettingsPropertyChanged != null)
                            {
                                // ReSharper disable once AccessToModifiedClosure
                                foreach (string strPropertyName in lstProperties)
                                {
                                    token.ThrowIfCancellationRequested();
                                    SettingsPropertyChanged.Invoke(this, new PropertyChangedEventArgs(strPropertyName));
                                }
                            }
                        }, token).ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
        }

        private Task AttributeSectionOnPropertyChanged(object sender, MultiplePropertiesChangedEventArgs e, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (IsLoading || e.PropertyNames.Contains(nameof(AttributeSection.AttributeCategory)))
            {
                return this.OnMultiplePropertyChangedAsync(token, nameof(CurrentWalkingRateString),
                    nameof(CurrentRunningRateString),
                    nameof(CurrentSprintingRateString));
            }

            return Task.CompletedTask;
        }

        private Task ContactsOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (e.Action != NotifyCollectionChangedAction.Move || IsLoading)
            {
                return this.OnMultiplePropertyChangedAsync(token, nameof(NegativeQualityKarma),
                    nameof(NegativeQualityLimitKarma),
                    nameof(PositiveQualityLimitKarma),
                    nameof(PositiveQualityKarma),
                    nameof(EnemyKarma));
            }

            return Task.CompletedTask;
        }

        private async Task PowersOnBeforeRemove(object sender, RemovingOldEventArgs e,
            CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                Power objPower = await (await GetPowersAsync(token).ConfigureAwait(false))
                    .GetValueAtAsync(e.OldIndex, token).ConfigureAwait(false);
                if (await objPower.GetAdeptWayDiscountEnabledAsync(token).ConfigureAwait(false))
                    await this.OnMultiplePropertyChangedAsync(token, nameof(AnyPowerAdeptWayDiscountEnabled),
                        nameof(AllowAdeptWayPowerDiscount)).ConfigureAwait(false);
                // Do not need to dispose because deleting the power already disposes the power after removing it from the character
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private async Task PowersOnListChanged(object sender, ListChangedEventArgs e, CancellationToken token = default)
        {
            using (new FetchSafelyFromSafeObjectPool<Dictionary<INotifyMultiplePropertiesChangedAsync, HashSet<string>>>(
                       Utils.DictionaryForMultiplePropertyChangedPool,
                       out Dictionary<INotifyMultiplePropertiesChangedAsync, HashSet<string>> dicChangedProperties))
            {
                try
                {
                    token.ThrowIfCancellationRequested();
                    switch (e.ListChangedType)
                    {
                        case ListChangedType.Reset:
                            {
                                HashSet<string> setTemp = Utils.StringHashSetPool.Get();
                                setTemp.Add(nameof(PowerPointsUsed));
                                setTemp.Add(nameof(AnyPowerAdeptWayDiscountEnabled));
                                setTemp.Add(nameof(AllowAdeptWayPowerDiscount));
                                dicChangedProperties.Add(this, setTemp);
                                break;
                            }
                        case ListChangedType.ItemAdded:
                            {
                                HashSet<string> setTemp = Utils.StringHashSetPool.Get();
                                setTemp.Add(nameof(PowerPointsUsed));
                                dicChangedProperties.Add(this, setTemp);
                                IAsyncDisposable objLocker =
                                    await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
                                try
                                {
                                    token.ThrowIfCancellationRequested();
                                    Power objNewPower =
                                        await Powers.GetValueAtAsync(e.NewIndex, token).ConfigureAwait(false);
                                    if (!IsLoading)
                                    {
                                        // Needed in order to properly process named sources where
                                        // the tooltip was built before the object was added to the character
                                        await Improvements.ForEachAsync(objImprovement =>
                                        {
                                            if (objImprovement.SourceName != objNewPower.InternalId
                                                || !objImprovement.Enabled)
                                                return;
                                            foreach ((INotifyMultiplePropertiesChangedAsync objItemToUpdate,
                                                         string strPropertyToUpdate) in
                                                     objImprovement.GetRelevantPropertyChangers())
                                            {
                                                if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                        out HashSet<string> setChangedProperties))
                                                {
                                                    setChangedProperties = Utils.StringHashSetPool.Get();
                                                    dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                                }

                                                setChangedProperties.Add(strPropertyToUpdate);
                                            }
                                        }, token).ConfigureAwait(false);
                                    }

                                    if (await objNewPower.GetAdeptWayDiscountEnabledAsync(token).ConfigureAwait(false))
                                    {
                                        setTemp.Add(nameof(AnyPowerAdeptWayDiscountEnabled));
                                        setTemp.Add(nameof(AllowAdeptWayPowerDiscount));
                                    }
                                }
                                finally
                                {
                                    await objLocker.DisposeAsync().ConfigureAwait(false);
                                }

                                break;
                            }
                        case ListChangedType.ItemDeleted:
                            {
                                HashSet<string> setTemp = Utils.StringHashSetPool.Get();
                                setTemp.Add(nameof(PowerPointsUsed));
                                dicChangedProperties.Add(this, setTemp);
                                break;
                            }
                        case ListChangedType.ItemChanged:
                            {
                                if (e.PropertyDescriptor == null)
                                {
                                    break;
                                }

                                switch (e.PropertyDescriptor.Name)
                                {
                                    case nameof(Power.AdeptWayDiscountEnabled):
                                        {
                                            HashSet<string> setTemp = Utils.StringHashSetPool.Get();
                                            setTemp.Add(nameof(AnyPowerAdeptWayDiscountEnabled));
                                            setTemp.Add(nameof(AllowAdeptWayPowerDiscount));
                                            dicChangedProperties.Add(this, setTemp);
                                            break;
                                        }
                                    case nameof(Power.DiscountedAdeptWay):
                                        {
                                            HashSet<string> setTemp = Utils.StringHashSetPool.Get();
                                            setTemp.Add(nameof(PowerPointsUsed));
                                            setTemp.Add(nameof(AnyPowerAdeptWayDiscountEnabled));
                                            setTemp.Add(nameof(AllowAdeptWayPowerDiscount));
                                            dicChangedProperties.Add(this, setTemp);
                                            IAsyncDisposable objLocker =
                                                await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
                                            try
                                            {
                                                token.ThrowIfCancellationRequested();
                                                foreach (Power objPower in Powers)
                                                {
                                                    if (!dicChangedProperties.TryGetValue(objPower,
                                                            out HashSet<string> setChangedProperties))
                                                    {
                                                        setChangedProperties = Utils.StringHashSetPool.Get();
                                                        dicChangedProperties.Add(objPower, setChangedProperties);
                                                    }

                                                    setChangedProperties.Add(nameof(Power.AdeptWayDiscountEnabled));
                                                }
                                            }
                                            finally
                                            {
                                                await objLocker.DisposeAsync().ConfigureAwait(false);
                                            }

                                            break;
                                        }
                                    case nameof(Power.PowerPoints):
                                        {
                                            HashSet<string> setTemp = Utils.StringHashSetPool.Get();
                                            setTemp.Add(nameof(PowerPointsUsed));
                                            dicChangedProperties.Add(this, setTemp);
                                            break;
                                        }
                                }

                                break;
                            }
                    }

                    foreach (KeyValuePair<INotifyMultiplePropertiesChangedAsync, HashSet<string>> kvpToProcess in
                             dicChangedProperties)
                    {
                        await kvpToProcess.Key.OnMultiplePropertiesChangedAsync(kvpToProcess.Value, token).ConfigureAwait(false);
                    }
                }
                finally
                {
                    List<HashSet<string>> lstToReturn = dicChangedProperties.Values.ToList();
                    for (int i = lstToReturn.Count - 1; i >= 0; --i)
                    {
                        HashSet<string> setLoop = lstToReturn[i];
                        Utils.StringHashSetPool.Return(ref setLoop);
                    }
                }
            }
        }

        private async Task MentorSpiritsOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            if (IsLoading)
                return;
            List<MentorSpirit> lstImprovementSourcesToProcess = new List<MentorSpirit>(MentorSpirits.Count);

            switch (e.Action)
            {
                case NotifyCollectionChangedAction.Add:
                case NotifyCollectionChangedAction.Replace:
                    lstImprovementSourcesToProcess.AddRange(e.NewItems.Cast<MentorSpirit>());
                    break;

                case NotifyCollectionChangedAction.Move:
                    return;

                case NotifyCollectionChangedAction.Reset:
                    lstImprovementSourcesToProcess.AddRange(MentorSpirits);
                    break;
            }

            if (lstImprovementSourcesToProcess.Count == 0)
            {
                await OnPropertyChangedAsync(nameof(MentorSpirits), token).ConfigureAwait(false);
                return;
            }

            using (new FetchSafelyFromSafeObjectPool<Dictionary<INotifyMultiplePropertiesChangedAsync, HashSet<string>>>(
                       Utils.DictionaryForMultiplePropertyChangedPool,
                       out Dictionary<INotifyMultiplePropertiesChangedAsync, HashSet<string>> dicChangedProperties))
            {
                try
                {
                    token.ThrowIfCancellationRequested();
                    HashSet<string> setTemp = Utils.StringHashSetPool.Get();
                    setTemp.Add(nameof(MentorSpirits));
                    dicChangedProperties.Add(this, setTemp);
                    IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        foreach (MentorSpirit objNewItem in lstImprovementSourcesToProcess)
                        {
                            // Needed in order to properly process named sources where
                            // the tooltip was built before the object was added to the character
                            await Improvements.ForEachAsync(objImprovement =>
                            {
                                if (objImprovement.SourceName != objNewItem.InternalId || !objImprovement.Enabled)
                                    return;
                                foreach ((INotifyMultiplePropertiesChangedAsync objItemToUpdate,
                                             string strPropertyToUpdate) in
                                         objImprovement.GetRelevantPropertyChangers())
                                {
                                    if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                            out HashSet<string> setChangedProperties))
                                    {
                                        setChangedProperties = Utils.StringHashSetPool.Get();
                                        dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                    }

                                    setChangedProperties.Add(strPropertyToUpdate);
                                }
                            }, token).ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        await objLocker.DisposeAsync().ConfigureAwait(false);
                    }

                    foreach (KeyValuePair<INotifyMultiplePropertiesChangedAsync, HashSet<string>> kvpToUpdate in
                             dicChangedProperties)
                    {
                        await kvpToUpdate.Key.OnMultiplePropertiesChangedAsync(kvpToUpdate.Value, token).ConfigureAwait(false);
                    }
                }
                finally
                {
                    List<HashSet<string>> lstToReturn = dicChangedProperties.Values.ToList();
                    for (int i = lstToReturn.Count - 1; i >= 0; --i)
                    {
                        HashSet<string> setLoop = lstToReturn[i];
                        Utils.StringHashSetPool.Return(ref setLoop);
                    }
                }
            }
        }

        private async Task QualitiesCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            if (IsLoading)
                return;
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                ThreadSafeObservableCollection<Quality> lstQualities = await GetQualitiesAsync(token).ConfigureAwait(false);
                List<Quality> lstImprovementSourcesToProcess = new List<Quality>(await lstQualities.GetCountAsync(token).ConfigureAwait(false));

                switch (e.Action)
                {
                    case NotifyCollectionChangedAction.Add:
                    case NotifyCollectionChangedAction.Replace:
                        lstImprovementSourcesToProcess.AddRange(e.NewItems.OfType<Quality>());
                        break;

                    case NotifyCollectionChangedAction.Move:
                        return;

                    case NotifyCollectionChangedAction.Reset:
                        lstImprovementSourcesToProcess.AddRange(lstQualities);
                        break;
                }

                using (new FetchSafelyFromSafeObjectPool<Dictionary<INotifyMultiplePropertiesChangedAsync, HashSet<string>>>(
                           Utils.DictionaryForMultiplePropertyChangedPool,
                           out Dictionary<INotifyMultiplePropertiesChangedAsync, HashSet<string>> dicChangedProperties))
                {
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        HashSet<string> setTemp = Utils.StringHashSetPool.Get();
                        setTemp.Add(nameof(Qualities));
                        dicChangedProperties.Add(this, setTemp);
                        await Powers.ForEachAsync(objPower =>
                        {
                            HashSet<string> strInnerTemp = Utils.StringHashSetPool.Get();
                            strInnerTemp.Add(nameof(Power.AdeptWayDiscountEnabled));
                            dicChangedProperties.Add(objPower, strInnerTemp);
                        }, token).ConfigureAwait(false);

                        if (lstImprovementSourcesToProcess.Count > 0)
                        {
                            foreach (Quality objNewItem in lstImprovementSourcesToProcess)
                            {
                                // Needed in order to properly process named sources where
                                // the tooltip was built before the object was added to the character
                                await Improvements.ForEachAsync(objImprovement =>
                                {
                                    if (objImprovement.SourceName != objNewItem.InternalId
                                        || !objImprovement.Enabled)
                                        return;
                                    foreach ((INotifyMultiplePropertiesChangedAsync objItemToUpdate,
                                                 string strPropertyToUpdate) in
                                             objImprovement.GetRelevantPropertyChangers())
                                    {
                                        if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                out HashSet<string> setChangedProperties))
                                        {
                                            setChangedProperties = Utils.StringHashSetPool.Get();
                                            dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                        }

                                        setChangedProperties.Add(strPropertyToUpdate);
                                    }
                                }, token).ConfigureAwait(false);
                            }
                        }

                        foreach (KeyValuePair<INotifyMultiplePropertiesChangedAsync, HashSet<string>> kvpToUpdate in
                                 dicChangedProperties)
                        {
                            await kvpToUpdate.Key.OnMultiplePropertiesChangedAsync(kvpToUpdate.Value, token)
                                .ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        List<HashSet<string>> lstToReturn = dicChangedProperties.Values.ToList();
                        for (int i = lstToReturn.Count - 1; i >= 0; --i)
                        {
                            HashSet<string> setLoop = lstToReturn[i];
                            Utils.StringHashSetPool.Return(ref setLoop);
                        }
                    }
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private async Task MartialArtsOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            if (IsLoading)
                return;
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                ThreadSafeObservableCollection<MartialArt> lstMartialArts = await GetMartialArtsAsync(token).ConfigureAwait(false);
                List<MartialArt> lstImprovementSourcesToProcess = new List<MartialArt>(await lstMartialArts.GetCountAsync(token).ConfigureAwait(false));

                switch (e.Action)
                {
                    case NotifyCollectionChangedAction.Add:
                    case NotifyCollectionChangedAction.Replace:
                        lstImprovementSourcesToProcess.AddRange(e.NewItems.OfType<MartialArt>());
                        break;

                    case NotifyCollectionChangedAction.Move:
                        return;

                    case NotifyCollectionChangedAction.Reset:
                        lstImprovementSourcesToProcess.AddRange(lstMartialArts);
                        break;
                }

                if (lstImprovementSourcesToProcess.Count == 0)
                {
                    await OnPropertyChangedAsync(nameof(MartialArts), token).ConfigureAwait(false);
                    return;
                }

                using (new FetchSafelyFromSafeObjectPool<Dictionary<INotifyMultiplePropertiesChangedAsync, HashSet<string>>>(
                           Utils.DictionaryForMultiplePropertyChangedPool,
                           out Dictionary<INotifyMultiplePropertiesChangedAsync, HashSet<string>> dicChangedProperties))
                {
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        HashSet<string> setTemp = Utils.StringHashSetPool.Get();
                        setTemp.Add(nameof(MartialArts));
                        dicChangedProperties.Add(this, setTemp);
                        foreach (MartialArt objNewItem in lstImprovementSourcesToProcess)
                        {
                            // Needed in order to properly process named sources where
                            // the tooltip was built before the object was added to the character
                            await Improvements.ForEachAsync(objImprovement =>
                            {
                                if (objImprovement.SourceName != objNewItem.InternalId || !objImprovement.Enabled)
                                    return;
                                foreach ((INotifyMultiplePropertiesChangedAsync objItemToUpdate,
                                             string strPropertyToUpdate) in
                                         objImprovement.GetRelevantPropertyChangers())
                                {
                                    if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                            out HashSet<string> setChangedProperties))
                                    {
                                        setChangedProperties = Utils.StringHashSetPool.Get();
                                        dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                    }

                                    setChangedProperties.Add(strPropertyToUpdate);
                                }
                            }, token).ConfigureAwait(false);
                        }

                        foreach (KeyValuePair<INotifyMultiplePropertiesChangedAsync, HashSet<string>> kvpToUpdate in
                                 dicChangedProperties)
                        {
                            await kvpToUpdate.Key.OnMultiplePropertiesChangedAsync(kvpToUpdate.Value, token)
                                .ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        List<HashSet<string>> lstToReturn = dicChangedProperties.Values.ToList();
                        for (int i = lstToReturn.Count - 1; i >= 0; --i)
                        {
                            HashSet<string> setLoop = lstToReturn[i];
                            Utils.StringHashSetPool.Return(ref setLoop);
                        }
                    }
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private async Task MetamagicsOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            if (IsLoading)
                return;
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                ThreadSafeObservableCollection<Metamagic> lstMetamagics = await GetMetamagicsAsync(token).ConfigureAwait(false);
                List<Metamagic> lstImprovementSourcesToProcess = new List<Metamagic>(await lstMetamagics.GetCountAsync(token).ConfigureAwait(false));

                switch (e.Action)
                {
                    case NotifyCollectionChangedAction.Add:
                    case NotifyCollectionChangedAction.Replace:
                        lstImprovementSourcesToProcess.AddRange(e.NewItems.OfType<Metamagic>());
                        break;

                    case NotifyCollectionChangedAction.Move:
                        return;

                    case NotifyCollectionChangedAction.Reset:
                        lstImprovementSourcesToProcess.AddRange(lstMetamagics);
                        break;
                }

                if (lstImprovementSourcesToProcess.Count == 0)
                {
                    await OnPropertyChangedAsync(nameof(Metamagics), token).ConfigureAwait(false);
                    return;
                }

                using (new FetchSafelyFromSafeObjectPool<Dictionary<INotifyMultiplePropertiesChangedAsync, HashSet<string>>>(
                           Utils.DictionaryForMultiplePropertyChangedPool,
                           out Dictionary<INotifyMultiplePropertiesChangedAsync, HashSet<string>> dicChangedProperties))
                {
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        HashSet<string> setTemp = Utils.StringHashSetPool.Get();
                        setTemp.Add(nameof(Metamagics));
                        dicChangedProperties.Add(this, setTemp);
                        foreach (Metamagic objNewItem in lstImprovementSourcesToProcess)
                        {
                            // Needed in order to properly process named sources where
                            // the tooltip was built before the object was added to the character
                            await Improvements.ForEachAsync(objImprovement =>
                            {
                                if (objImprovement.SourceName != objNewItem.InternalId || !objImprovement.Enabled)
                                    return;
                                foreach ((INotifyMultiplePropertiesChangedAsync objItemToUpdate,
                                             string strPropertyToUpdate) in
                                         objImprovement.GetRelevantPropertyChangers())
                                {
                                    if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                            out HashSet<string> setChangedProperties))
                                    {
                                        setChangedProperties = Utils.StringHashSetPool.Get();
                                        dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                    }

                                    setChangedProperties.Add(strPropertyToUpdate);
                                }
                            }, token).ConfigureAwait(false);
                        }

                        foreach (KeyValuePair<INotifyMultiplePropertiesChangedAsync, HashSet<string>> kvpToUpdate in
                                 dicChangedProperties)
                        {
                            await kvpToUpdate.Key.OnMultiplePropertiesChangedAsync(kvpToUpdate.Value, token)
                                .ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        List<HashSet<string>> lstToReturn = dicChangedProperties.Values.ToList();
                        for (int i = lstToReturn.Count - 1; i >= 0; --i)
                        {
                            HashSet<string> setLoop = lstToReturn[i];
                            Utils.StringHashSetPool.Return(ref setLoop);
                        }
                    }
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private async Task ExpenseLogOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (e.Action == NotifyCollectionChangedAction.Move || IsLoading)
                return;
            using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                                                            out HashSet<string> setPropertiesToRefresh))
            {
                switch (e.Action)
                {
                    case NotifyCollectionChangedAction.Add:
                        foreach (ExpenseLogEntry objNewItem in e.NewItems)
                        {
                            if ((objNewItem.Amount > 0 || objNewItem.ForceCareerVisible) && !objNewItem.Refund)
                            {
                                setPropertiesToRefresh.Add(objNewItem.Type == ExpenseType.Nuyen
                                                               ? nameof(CareerNuyen)
                                                               : nameof(CareerKarma));
                            }
                        }

                        break;

                    case NotifyCollectionChangedAction.Remove:
                        foreach (ExpenseLogEntry objOldItem in e.OldItems)
                        {
                            if ((objOldItem.Amount > 0 || objOldItem.ForceCareerVisible) && !objOldItem.Refund)
                            {
                                setPropertiesToRefresh.Add(objOldItem.Type == ExpenseType.Nuyen
                                                               ? nameof(CareerNuyen)
                                                               : nameof(CareerKarma));
                            }
                        }

                        break;

                    case NotifyCollectionChangedAction.Replace:
                        foreach (ExpenseLogEntry objOldItem in e.OldItems)
                        {
                            if ((objOldItem.Amount > 0 || objOldItem.ForceCareerVisible) && !objOldItem.Refund)
                            {
                                setPropertiesToRefresh.Add(objOldItem.Type == ExpenseType.Nuyen
                                                               ? nameof(CareerNuyen)
                                                               : nameof(CareerKarma));
                            }
                        }

                        foreach (ExpenseLogEntry objNewItem in e.NewItems)
                        {
                            if ((objNewItem.Amount > 0 || objNewItem.ForceCareerVisible) && !objNewItem.Refund)
                            {
                                setPropertiesToRefresh.Add(objNewItem.Type == ExpenseType.Nuyen
                                                               ? nameof(CareerNuyen)
                                                               : nameof(CareerKarma));
                            }
                        }

                        break;

                    case NotifyCollectionChangedAction.Reset:
                        setPropertiesToRefresh.Add(nameof(CareerNuyen));
                        setPropertiesToRefresh.Add(nameof(CareerKarma));
                        break;
                }

                if (setPropertiesToRefresh.Count > 0)
                    await OnMultiplePropertiesChangedAsync(setPropertiesToRefresh, token).ConfigureAwait(false);
            }
        }

        private async Task GearOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            if (e.Action == NotifyCollectionChangedAction.Move || IsLoading)
                return;
            bool blnDoEncumbranceRefresh = false;
            using (new FetchSafelyFromSafeObjectPool<Dictionary<INotifyMultiplePropertiesChangedAsync, HashSet<string>>>(
                       Utils.DictionaryForMultiplePropertyChangedPool,
                       out Dictionary<INotifyMultiplePropertiesChangedAsync, HashSet<string>> dicChangedProperties))
            {
                try
                {
                    token.ThrowIfCancellationRequested();
                    IAsyncDisposable objLocker =
                        await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        switch (e.Action)
                        {
                            case NotifyCollectionChangedAction.Add:
                                foreach (Gear objNewItem in e.NewItems)
                                {
                                    if (objNewItem.Equipped)
                                    {
                                        blnDoEncumbranceRefresh = true;
                                    }

                                    if (IsLoading)
                                        continue;
                                    // Needed in order to properly process named sources where
                                    // the tooltip was built before the object was added to the character
                                    await Improvements.ForEachAsync(objImprovement =>
                                    {
                                        if (objImprovement.SourceName.TrimEndOnce("Wireless")
                                            == objNewItem.InternalId
                                            &&
                                            objImprovement.Enabled)
                                        {
                                            foreach ((INotifyMultiplePropertiesChangedAsync objItemToUpdate,
                                                         string strPropertyToUpdate) in
                                                     objImprovement.GetRelevantPropertyChangers())
                                            {
                                                if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                        out HashSet<string> setChangedProperties))
                                                {
                                                    setChangedProperties = Utils.StringHashSetPool.Get();
                                                    dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                                }

                                                setChangedProperties.Add(strPropertyToUpdate);
                                            }
                                        }
                                    }, token).ConfigureAwait(false);
                                }

                                break;

                            case NotifyCollectionChangedAction.Remove:
                                foreach (Gear objOldItem in e.OldItems)
                                {
                                    if (objOldItem.Equipped)
                                    {
                                        blnDoEncumbranceRefresh = true;
                                        break;
                                    }
                                }

                                break;

                            case NotifyCollectionChangedAction.Replace:
                                foreach (Gear objOldItem in e.OldItems)
                                {
                                    if (objOldItem.Equipped)
                                    {
                                        blnDoEncumbranceRefresh = true;
                                        break;
                                    }
                                }

                                foreach (Gear objNewItem in e.NewItems)
                                {
                                    if (objNewItem.Equipped)
                                    {
                                        blnDoEncumbranceRefresh = true;
                                    }

                                    if (IsLoading)
                                        continue;
                                    // Needed in order to properly process named sources where
                                    // the tooltip was built before the object was added to the character
                                    await Improvements.ForEachAsync(objImprovement =>
                                    {
                                        if (objImprovement.SourceName.TrimEndOnce("Wireless")
                                            == objNewItem.InternalId
                                            &&
                                            objImprovement.Enabled)
                                        {
                                            foreach ((INotifyMultiplePropertiesChangedAsync objItemToUpdate,
                                                         string strPropertyToUpdate) in
                                                     objImprovement.GetRelevantPropertyChangers())
                                            {
                                                if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                        out HashSet<string> setChangedProperties))
                                                {
                                                    setChangedProperties = Utils.StringHashSetPool.Get();
                                                    dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                                }

                                                setChangedProperties.Add(strPropertyToUpdate);
                                            }
                                        }
                                    }, token).ConfigureAwait(false);
                                }

                                break;

                            case NotifyCollectionChangedAction.Reset:
                                blnDoEncumbranceRefresh = true;
                                break;
                        }

                        if (blnDoEncumbranceRefresh)
                        {
                            if (!dicChangedProperties.TryGetValue(this, out HashSet<string> setChangedProperties))
                            {
                                setChangedProperties = Utils.StringHashSetPool.Get();
                                dicChangedProperties.Add(this, setChangedProperties);
                            }

                            setChangedProperties.Add(nameof(TotalCarriedWeight));
                        }

                        foreach (KeyValuePair<INotifyMultiplePropertiesChangedAsync, HashSet<string>> kvpToProcess in
                                 dicChangedProperties)
                        {
                            await kvpToProcess.Key.OnMultiplePropertiesChangedAsync(kvpToProcess.Value, token)
                                .ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        await objLocker.DisposeAsync().ConfigureAwait(false);
                    }
                }
                finally
                {
                    List<HashSet<string>> lstToReturn = dicChangedProperties.Values.ToList();
                    for (int i = lstToReturn.Count - 1; i >= 0; --i)
                    {
                        HashSet<string> setLoop = lstToReturn[i];
                        Utils.StringHashSetPool.Return(ref setLoop);
                    }
                }
            }
        }

        private async Task WeaponsOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (e.Action == NotifyCollectionChangedAction.Move || IsLoading)
                return;
            bool blnDoEncumbranceRefresh = false;
            using (new FetchSafelyFromSafeObjectPool<Dictionary<INotifyMultiplePropertiesChangedAsync, HashSet<string>>>(
                       Utils.DictionaryForMultiplePropertyChangedPool,
                       out Dictionary<INotifyMultiplePropertiesChangedAsync, HashSet<string>> dicChangedProperties))
            {
                try
                {
                    token.ThrowIfCancellationRequested();
                    IAsyncDisposable objLocker =
                        await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        switch (e.Action)
                        {
                            case NotifyCollectionChangedAction.Add:
                                foreach (Weapon objNewItem in e.NewItems)
                                {
                                    token.ThrowIfCancellationRequested();
                                    if (objNewItem.Equipped)
                                    {
                                        blnDoEncumbranceRefresh = true;
                                    }

                                    if (IsLoading)
                                        continue;
                                    // Needed in order to properly process named sources where
                                    // the tooltip was built before the object was added to the character
                                    await Improvements.ForEachAsync(objImprovement =>
                                    {
                                        if (objImprovement.SourceName.TrimEndOnce("Wireless")
                                            == objNewItem.InternalId
                                            &&
                                            objImprovement.Enabled)
                                        {
                                            foreach ((INotifyMultiplePropertiesChangedAsync objItemToUpdate,
                                                         string strPropertyToUpdate) in
                                                     objImprovement.GetRelevantPropertyChangers())
                                            {
                                                token.ThrowIfCancellationRequested();
                                                if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                        out HashSet<string> setChangedProperties))
                                                {
                                                    setChangedProperties = Utils.StringHashSetPool.Get();
                                                    dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                                }

                                                setChangedProperties.Add(strPropertyToUpdate);
                                            }
                                        }
                                    }, token).ConfigureAwait(false);
                                }

                                break;

                            case NotifyCollectionChangedAction.Remove:
                                foreach (Weapon objOldItem in e.OldItems)
                                {
                                    token.ThrowIfCancellationRequested();
                                    if (objOldItem.Equipped)
                                    {
                                        blnDoEncumbranceRefresh = true;
                                        break;
                                    }
                                }

                                break;

                            case NotifyCollectionChangedAction.Replace:
                                foreach (Weapon objOldItem in e.OldItems)
                                {
                                    token.ThrowIfCancellationRequested();
                                    if (objOldItem.Equipped)
                                    {
                                        blnDoEncumbranceRefresh = true;
                                        break;
                                    }
                                }

                                foreach (Weapon objNewItem in e.NewItems)
                                {
                                    token.ThrowIfCancellationRequested();
                                    if (objNewItem.Equipped)
                                    {
                                        blnDoEncumbranceRefresh = true;
                                    }

                                    if (IsLoading)
                                        continue;
                                    // Needed in order to properly process named sources where
                                    // the tooltip was built before the object was added to the character
                                    await Improvements.ForEachAsync(objImprovement =>
                                    {
                                        if (objImprovement.SourceName.TrimEndOnce("Wireless")
                                            == objNewItem.InternalId
                                            &&
                                            objImprovement.Enabled)
                                        {
                                            foreach ((INotifyMultiplePropertiesChangedAsync objItemToUpdate,
                                                         string strPropertyToUpdate) in
                                                     objImprovement.GetRelevantPropertyChangers())
                                            {
                                                token.ThrowIfCancellationRequested();
                                                if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                        out HashSet<string> setChangedProperties))
                                                {
                                                    setChangedProperties = Utils.StringHashSetPool.Get();
                                                    dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                                }

                                                setChangedProperties.Add(strPropertyToUpdate);
                                            }
                                        }
                                    }, token).ConfigureAwait(false);
                                }

                                break;

                            case NotifyCollectionChangedAction.Reset:
                                blnDoEncumbranceRefresh = true;
                                break;
                        }

                        if (blnDoEncumbranceRefresh)
                        {
                            if (!dicChangedProperties.TryGetValue(this, out HashSet<string> setChangedProperties))
                            {
                                setChangedProperties = Utils.StringHashSetPool.Get();
                                dicChangedProperties.Add(this, setChangedProperties);
                            }

                            setChangedProperties.Add(nameof(TotalCarriedWeight));
                        }

                        foreach (KeyValuePair<INotifyMultiplePropertiesChangedAsync, HashSet<string>> kvpToProcess in
                                 dicChangedProperties)
                        {
                            token.ThrowIfCancellationRequested();
                            await kvpToProcess.Key.OnMultiplePropertiesChangedAsync(kvpToProcess.Value, token)
                                .ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        await objLocker.DisposeAsync().ConfigureAwait(false);
                    }
                }
                finally
                {
                    List<HashSet<string>> lstToReturn = dicChangedProperties.Values.ToList();
                    for (int i = lstToReturn.Count - 1; i >= 0; --i)
                    {
                        HashSet<string> setLoop = lstToReturn[i];
                        Utils.StringHashSetPool.Return(ref setLoop);
                    }
                }
            }
        }

        private async Task ArmorOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (e.Action == NotifyCollectionChangedAction.Move || IsLoading)
                return;
            bool blnDoEquippedArmorRefresh = false;
            bool blnDoArmorEncumbranceRefresh = false;
            using (new FetchSafelyFromSafeObjectPool<Dictionary<INotifyMultiplePropertiesChangedAsync, HashSet<string>>>(
                       Utils.DictionaryForMultiplePropertyChangedPool,
                       out Dictionary<INotifyMultiplePropertiesChangedAsync, HashSet<string>> dicChangedProperties))
            {
                try
                {
                    token.ThrowIfCancellationRequested();
                    IAsyncDisposable objLocker =
                        await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        switch (e.Action)
                        {
                            case NotifyCollectionChangedAction.Add:
                                foreach (Armor objNewItem in e.NewItems)
                                {
                                    token.ThrowIfCancellationRequested();
                                    if (objNewItem.Equipped)
                                    {
                                        blnDoEquippedArmorRefresh = true;
                                        if (objNewItem.Encumbrance)
                                            blnDoArmorEncumbranceRefresh = true;
                                    }

                                    if (IsLoading)
                                        continue;
                                    // Needed in order to properly process named sources where
                                    // the tooltip was built before the object was added to the character
                                    await Improvements.ForEachAsync(objImprovement =>
                                    {
                                        if (objImprovement.SourceName.TrimEndOnce("Wireless")
                                            == objNewItem.InternalId
                                            &&
                                            objImprovement.Enabled)
                                        {
                                            foreach ((INotifyMultiplePropertiesChangedAsync objItemToUpdate,
                                                         string strPropertyToUpdate) in
                                                     objImprovement.GetRelevantPropertyChangers())
                                            {
                                                token.ThrowIfCancellationRequested();
                                                if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                        out HashSet<string> setChangedProperties))
                                                {
                                                    setChangedProperties = Utils.StringHashSetPool.Get();
                                                    dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                                }

                                                setChangedProperties.Add(strPropertyToUpdate);
                                            }
                                        }
                                    }, token).ConfigureAwait(false);
                                }

                                break;

                            case NotifyCollectionChangedAction.Remove:
                                foreach (Armor objOldItem in e.OldItems)
                                {
                                    token.ThrowIfCancellationRequested();
                                    if (objOldItem.Equipped)
                                    {
                                        blnDoEquippedArmorRefresh = true;
                                        if (objOldItem.Encumbrance)
                                        {
                                            blnDoArmorEncumbranceRefresh = true;
                                            break;
                                        }
                                    }
                                }

                                break;

                            case NotifyCollectionChangedAction.Replace:
                                foreach (Armor objOldItem in e.OldItems)
                                {
                                    token.ThrowIfCancellationRequested();
                                    if (objOldItem.Equipped)
                                    {
                                        blnDoEquippedArmorRefresh = true;
                                        if (objOldItem.Encumbrance)
                                        {
                                            blnDoArmorEncumbranceRefresh = true;
                                            break;
                                        }
                                    }
                                }

                                foreach (Armor objNewItem in e.NewItems)
                                {
                                    token.ThrowIfCancellationRequested();
                                    if (objNewItem.Equipped)
                                    {
                                        blnDoEquippedArmorRefresh = true;
                                        if (objNewItem.Encumbrance)
                                            blnDoArmorEncumbranceRefresh = true;
                                    }

                                    if (IsLoading)
                                        continue;
                                    // Needed in order to properly process named sources where
                                    // the tooltip was built before the object was added to the character
                                    await Improvements.ForEachAsync(objImprovement =>
                                    {
                                        if (objImprovement.SourceName.TrimEndOnce("Wireless")
                                            == objNewItem.InternalId
                                            &&
                                            objImprovement.Enabled)
                                        {
                                            foreach ((INotifyMultiplePropertiesChangedAsync objItemToUpdate,
                                                         string strPropertyToUpdate) in
                                                     objImprovement.GetRelevantPropertyChangers())
                                            {
                                                token.ThrowIfCancellationRequested();
                                                if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                        out HashSet<string> setChangedProperties))
                                                {
                                                    setChangedProperties = Utils.StringHashSetPool.Get();
                                                    dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                                }

                                                setChangedProperties.Add(strPropertyToUpdate);
                                            }
                                        }
                                    }, token).ConfigureAwait(false);
                                }

                                break;

                            case NotifyCollectionChangedAction.Reset:
                                blnDoEquippedArmorRefresh = true;
                                blnDoArmorEncumbranceRefresh = true;
                                break;
                        }

                        if (blnDoEquippedArmorRefresh)
                        {
                            if (!dicChangedProperties.TryGetValue(this, out HashSet<string> setChangedProperties))
                            {
                                setChangedProperties = Utils.StringHashSetPool.Get();
                                dicChangedProperties.Add(this, setChangedProperties);
                            }

                            setChangedProperties.Add(nameof(GetArmorRating));
                            setChangedProperties.Add(nameof(TotalCarriedWeight));
                        }

                        if (blnDoArmorEncumbranceRefresh)
                        {
                            if (!dicChangedProperties.TryGetValue(this, out HashSet<string> setChangedProperties))
                            {
                                setChangedProperties = Utils.StringHashSetPool.Get();
                                dicChangedProperties.Add(this, setChangedProperties);
                            }

                            setChangedProperties.Add(nameof(ArmorEncumbrance));
                        }

                        foreach (KeyValuePair<INotifyMultiplePropertiesChangedAsync, HashSet<string>> kvpToProcess in
                                 dicChangedProperties)
                        {
                            token.ThrowIfCancellationRequested();
                            await kvpToProcess.Key.OnMultiplePropertiesChangedAsync(kvpToProcess.Value, token)
                                .ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        await objLocker.DisposeAsync().ConfigureAwait(false);
                    }
                }
                finally
                {
                    List<HashSet<string>> lstToReturn = dicChangedProperties.Values.ToList();
                    for (int i = lstToReturn.Count - 1; i >= 0; --i)
                    {
                        HashSet<string> setLoop = lstToReturn[i];
                        Utils.StringHashSetPool.Return(ref setLoop);
                    }
                }
            }
        }

        private async Task CyberwareOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (e.Action == NotifyCollectionChangedAction.Move || IsLoading)
                return;
            bool blnDoEncumbranceRefresh = false;
            bool blnDoCyberlimbAttributesRefresh = false;
            using (new FetchSafelyFromSafeObjectPool<Dictionary<INotifyMultiplePropertiesChangedAsync, HashSet<string>>>(
                       Utils.DictionaryForMultiplePropertyChangedPool,
                       out Dictionary<INotifyMultiplePropertiesChangedAsync, HashSet<string>> dicChangedProperties))
            {
                try
                {
                    token.ThrowIfCancellationRequested();
                    HashSet<string> setTemp = Utils.StringHashSetPool.Get();
                    setTemp.Add(nameof(RedlinerBonus));
                    dicChangedProperties.Add(this, setTemp);
                    IAsyncDisposable objLocker =
                        await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        switch (e.Action)
                        {
                            case NotifyCollectionChangedAction.Add:
                                {
                                    CharacterSettings objSettings = await GetSettingsAsync(token).ConfigureAwait(false);
                                    foreach (Cyberware objNewItem in e.NewItems)
                                    {
                                        token.ThrowIfCancellationRequested();
                                        if (await objNewItem.GetIsModularCurrentlyEquippedAsync(token)
                                                .ConfigureAwait(false))
                                            blnDoEncumbranceRefresh = true;

                                        dicChangedProperties[this].Add(await objNewItem.GetEssencePropertyNameAsync(token).ConfigureAwait(false));
                                        if (!IsLoading)
                                        {
                                            // Needed in order to properly process named sources where
                                            // the tooltip was built before the object was added to the character
                                            await Improvements.ForEachAsync(objImprovement =>
                                            {
                                                token.ThrowIfCancellationRequested();
                                                if (objImprovement.SourceName.TrimEndOnce("Pair").TrimEndOnce("Wireless") ==
                                                    objNewItem.InternalId && objImprovement.Enabled)
                                                {
                                                    foreach ((INotifyMultiplePropertiesChangedAsync objItemToUpdate,
                                                                 string strPropertyToUpdate) in
                                                             objImprovement.GetRelevantPropertyChangers())
                                                    {
                                                        token.ThrowIfCancellationRequested();
                                                        if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                                out HashSet<string> setChangedProperties))
                                                        {
                                                            setChangedProperties = Utils.StringHashSetPool.Get();
                                                            dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                                        }

                                                        setChangedProperties.Add(strPropertyToUpdate);
                                                    }
                                                }
                                            }, token).ConfigureAwait(false);
                                        }

                                        if (!blnDoCyberlimbAttributesRefresh
                                            && !await objSettings.GetDontUseCyberlimbCalculationAsync(token)
                                                .ConfigureAwait(false) && await objNewItem.GetParentAsync(token).ConfigureAwait(false) == null
                                            && await objNewItem.GetParentVehicleAsync(token).ConfigureAwait(false) == null
                                            && await objNewItem.GetIsLimbAsync(token).ConfigureAwait(false)
                                            && !(await objSettings.GetExcludeLimbSlotAsync(token).ConfigureAwait(false)).Contains(
                                                await objNewItem.GetLimbSlotAsync(token).ConfigureAwait(false)))
                                        {
                                            blnDoCyberlimbAttributesRefresh = true;
                                        }
                                    }

                                    break;
                                }
                            case NotifyCollectionChangedAction.Remove:
                                {
                                    CharacterSettings objSettings = await GetSettingsAsync(token).ConfigureAwait(false);
                                    foreach (Cyberware objOldItem in e.OldItems)
                                    {
                                        token.ThrowIfCancellationRequested();
                                        if (await objOldItem.GetIsModularCurrentlyEquippedAsync(token)
                                                .ConfigureAwait(false))
                                            blnDoEncumbranceRefresh = true;
                                        dicChangedProperties[this].Add(await objOldItem.GetEssencePropertyNameAsync(token).ConfigureAwait(false));
                                        if (!blnDoCyberlimbAttributesRefresh
                                            && !await objSettings.GetDontUseCyberlimbCalculationAsync(token)
                                                .ConfigureAwait(false) && await objOldItem.GetParentAsync(token).ConfigureAwait(false) == null
                                            && await objOldItem.GetParentVehicleAsync(token).ConfigureAwait(false) == null
                                            && await objOldItem.GetIsLimbAsync(token).ConfigureAwait(false)
                                            && !(await objSettings.GetExcludeLimbSlotAsync(token).ConfigureAwait(false)).Contains(
                                                await objOldItem.GetLimbSlotAsync(token).ConfigureAwait(false)))
                                        {
                                            blnDoCyberlimbAttributesRefresh = true;
                                        }
                                    }

                                    break;
                                }
                            case NotifyCollectionChangedAction.Replace:
                                {
                                    CharacterSettings objSettings = await GetSettingsAsync(token).ConfigureAwait(false);
                                    if (!await objSettings.GetDontUseCyberlimbCalculationAsync(token).ConfigureAwait(false))
                                    {
                                        foreach (Cyberware objOldItem in e.OldItems)
                                        {
                                            token.ThrowIfCancellationRequested();
                                            if (await objOldItem.GetIsModularCurrentlyEquippedAsync(token)
                                                    .ConfigureAwait(false))
                                                blnDoEncumbranceRefresh = true;
                                            dicChangedProperties[this]
                                                .Add(await objOldItem.GetEssencePropertyNameAsync(token).ConfigureAwait(false));
                                            if (!blnDoCyberlimbAttributesRefresh
                                                && !await objSettings.GetDontUseCyberlimbCalculationAsync(token)
                                                    .ConfigureAwait(false) && await objOldItem.GetParentAsync(token).ConfigureAwait(false) == null
                                                && await objOldItem.GetParentVehicleAsync(token).ConfigureAwait(false) == null
                                                && await objOldItem.GetIsLimbAsync(token).ConfigureAwait(false)
                                                && !(await objSettings.GetExcludeLimbSlotAsync(token).ConfigureAwait(false)).Contains(
                                                    await objOldItem.GetLimbSlotAsync(token).ConfigureAwait(false)))
                                            {
                                                blnDoCyberlimbAttributesRefresh = true;
                                            }
                                        }

                                        foreach (Cyberware objNewItem in e.NewItems)
                                        {
                                            token.ThrowIfCancellationRequested();
                                            if (await objNewItem.GetIsModularCurrentlyEquippedAsync(token)
                                                    .ConfigureAwait(false))
                                                blnDoEncumbranceRefresh = true;
                                            dicChangedProperties[this]
                                                .Add(await objNewItem.GetEssencePropertyNameAsync(token).ConfigureAwait(false));
                                            if (!blnDoCyberlimbAttributesRefresh
                                                && !await objSettings.GetDontUseCyberlimbCalculationAsync(token)
                                                    .ConfigureAwait(false) && await objNewItem.GetParentAsync(token).ConfigureAwait(false) == null
                                                && await objNewItem.GetParentVehicleAsync(token).ConfigureAwait(false) == null
                                                && await objNewItem.GetIsLimbAsync(token).ConfigureAwait(false)
                                                && !(await objSettings.GetExcludeLimbSlotAsync(token).ConfigureAwait(false)).Contains(
                                                    await objNewItem.GetLimbSlotAsync(token).ConfigureAwait(false)))
                                            {
                                                blnDoCyberlimbAttributesRefresh = true;
                                            }
                                        }
                                    }

                                    break;
                                }
                            case NotifyCollectionChangedAction.Reset:
                                {
                                    blnDoEncumbranceRefresh = true;
                                    blnDoCyberlimbAttributesRefresh =
                                        !await (await GetSettingsAsync(token).ConfigureAwait(false)).GetDontUseCyberlimbCalculationAsync(token).ConfigureAwait(false);

                                    if (!dicChangedProperties.TryGetValue(this,
                                            out HashSet<string> setChangedProperties))
                                    {
                                        setChangedProperties = Utils.StringHashSetPool.Get();
                                        dicChangedProperties.Add(this, setChangedProperties);
                                    }

                                    setChangedProperties.Add(nameof(PrototypeTranshumanEssenceUsed));
                                    setChangedProperties.Add(nameof(BiowareEssence));
                                    setChangedProperties.Add(nameof(CyberwareEssence));
                                    setChangedProperties.Add(nameof(EssenceHole));
                                    break;
                                }
                        }

                        if (blnDoEncumbranceRefresh)
                        {
                            if (!dicChangedProperties.TryGetValue(this, out HashSet<string> setChangedProperties))
                            {
                                setChangedProperties = Utils.StringHashSetPool.Get();
                                dicChangedProperties.Add(this, setChangedProperties);
                            }

                            setChangedProperties.Add(nameof(TotalCarriedWeight));
                        }

                        if (blnDoCyberlimbAttributesRefresh)
                        {
                            foreach (string strAbbrev in Backend.Equipment.Cyberware.CyberlimbAttributeAbbrevs)
                            {
                                token.ThrowIfCancellationRequested();
                                CharacterAttrib objAttribute =
                                    await GetAttributeAsync(strAbbrev, token: token).ConfigureAwait(false);
                                if (objAttribute == null)
                                    continue;
                                if (!dicChangedProperties.TryGetValue(objAttribute,
                                        out HashSet<string> setChangedProperties))
                                {
                                    setChangedProperties = Utils.StringHashSetPool.Get();
                                    dicChangedProperties.Add(objAttribute, setChangedProperties);
                                }

                                setChangedProperties.Add(nameof(CharacterAttrib.TotalValue));
                            }
                        }

                        foreach (KeyValuePair<INotifyMultiplePropertiesChangedAsync, HashSet<string>> kvpToProcess in
                                 dicChangedProperties)
                        {
                            token.ThrowIfCancellationRequested();
                            await kvpToProcess.Key.OnMultiplePropertiesChangedAsync(kvpToProcess.Value, token)
                                .ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        await objLocker.DisposeAsync().ConfigureAwait(false);
                    }
                }
                finally
                {
                    List<HashSet<string>> lstToReturn = dicChangedProperties.Values.ToList();
                    for (int i = lstToReturn.Count - 1; i >= 0; --i)
                    {
                        HashSet<string> setLoop = lstToReturn[i];
                        Utils.StringHashSetPool.Return(ref setLoop);
                    }
                }
            }
        }

        private async Task SustainedObjectsOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (e.Action == NotifyCollectionChangedAction.Move || IsLoading)
                return;
            bool blnDoRefreshPenalties = false;
            switch (e.Action)
            {
                case NotifyCollectionChangedAction.Add:
                    blnDoRefreshPenalties =
                        await e.NewItems.OfType<SustainedObject>().AnyAsync(objItem => objItem.GetHasSustainingPenaltyAsync(token), token).ConfigureAwait(false);
                    break;

                case NotifyCollectionChangedAction.Remove:
                    blnDoRefreshPenalties =
                        await e.OldItems.OfType<SustainedObject>().AnyAsync(objItem => objItem.GetHasSustainingPenaltyAsync(token), token).ConfigureAwait(false);
                    break;

                case NotifyCollectionChangedAction.Replace:
                    blnDoRefreshPenalties =
                        await e.OldItems.OfType<SustainedObject>().AnyAsync(objItem => objItem.GetHasSustainingPenaltyAsync(token), token).ConfigureAwait(false) ||
                        await e.NewItems.OfType<SustainedObject>().AnyAsync(objItem => objItem.GetHasSustainingPenaltyAsync(token), token).ConfigureAwait(false);
                    break;

                case NotifyCollectionChangedAction.Reset:
                    blnDoRefreshPenalties = true;
                    break;
            }
            if (blnDoRefreshPenalties)
                await RefreshSustainingPenaltiesAsync(token).ConfigureAwait(false);
        }

        [HubTag]
        public AttributeSection AttributeSection
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _objAttributeSection;
            }
        }

        public async Task<AttributeSection> GetAttributeSectionAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _objAttributeSection;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        #region Create, Save, Load and Print Methods

        /// <summary>
        /// Set up a character with a metatype and new attributes to match.
        /// </summary>
        public void Create(string strSelectedMetatypeCategory, string strMetatypeId, string strMetavariantId,
            XmlNode objXmlMetatype, int intForce, XmlNode xmlQualityDocumentQualitiesNode = null,
            XmlNode xmlCritterPowerDocumentPowersNode = null, XmlNode xmlSkillsDocumentKnowledgeSkillsNode = null,
            string strSelectedPossessionMethod = "", CancellationToken token = default)
        {
            using (LockObject.EnterWriteLock(token))
            {
                if (objXmlMetatype == null)
                    throw new ArgumentNullException(nameof(objXmlMetatype));
                // Remove any Improvements the character received from their Metatype.
                ImprovementManager.RemoveImprovements(this,
                    Improvements.Where(objImprovement =>
                        objImprovement.ImproveSource == Improvement.ImprovementSource.Metatype
                        || objImprovement.ImproveSource == Improvement.ImprovementSource.Metavariant).ToList(), token: token);

                // Remove any Qualities the character received from their Metatype, then remove the Quality.
                for (int i = Qualities.Count - 1; i >= 0; --i)
                {
                    if (i >= Qualities.Count)
                        continue;
                    Quality objQuality = Qualities[i];
                    if (objQuality.OriginSource == QualitySource.Metatype ||
                        objQuality.OriginSource == QualitySource.MetatypeRemovable ||
                        objQuality.OriginSource == QualitySource.MetatypeRemovedAtChargen)
                        objQuality.DeleteQuality(token: token);
                }

                // If this is a Shapeshifter, a Metavariant must be selected. Default to Human if None is selected.
                if (strSelectedMetatypeCategory == "Shapeshifter" && strMetavariantId.IsEmptyGuid())
                    strMetavariantId =
                        objXmlMetatype.SelectSingleNodeAndCacheExpressionAsNavigator("metavariants/metavariant[name = \"Human\"]/id", token)?.Value ??
                        string.Empty;
                XmlNode objXmlMetavariant =
                    objXmlMetatype.TryGetNodeByNameOrId("metavariants/metavariant", strMetavariantId);

                // Set Metatype information.
                XmlNode charNode =
                    strSelectedMetatypeCategory == "Shapeshifter" || strMetavariantId.IsEmptyGuid()
                        ? objXmlMetatype
                        : objXmlMetavariant ?? objXmlMetatype;
                AttributeSection.Create(charNode, intForce, token: token);
                MetatypeGuid = new Guid(strMetatypeId);
                Metatype = objXmlMetatype["name"]?.InnerTextViaPool(token) ?? "Human";
                MetatypeCategory = strSelectedMetatypeCategory;
                MetavariantGuid = string.IsNullOrEmpty(strMetavariantId) ? Guid.Empty : new Guid(strMetavariantId);
                Metavariant = MetavariantGuid != Guid.Empty ? objXmlMetavariant?["name"]?.InnerTextViaPool(token) ?? string.Empty : string.Empty;
                // We only reverted to the base metatype to get the attributes.
                if (strSelectedMetatypeCategory == "Shapeshifter")
                {
                    charNode = objXmlMetavariant ?? objXmlMetatype;
                }

                Source = charNode["source"]?.InnerTextViaPool(token) ?? "SR5";
                Page = charNode["page"]?.InnerTextViaPool(token) ?? "0";
                _intMetatypeBP = 0;
                charNode.TryGetInt32FieldQuickly("karma", ref _intMetatypeBP);
                _intInitiativeDice = Settings.MinInitiativeDice;
                charNode.TryGetInt32FieldQuickly("initiativedice", ref _intInitiativeDice);

                Movement = objXmlMetatype["movement"]?.InnerTextViaPool(token) ?? string.Empty;

                // Determine if the Metatype has any bonuses.
                XmlElement xmlBonusNode = charNode["bonus"];
                if (xmlBonusNode != null)
                    ImprovementManager.CreateImprovements(this, Improvement.ImprovementSource.Metatype, strMetatypeId,
                        xmlBonusNode, 1, strMetatypeId, token: token);

                List<Weapon> lstWeapons = new List<Weapon>(1);
                // Create the Qualities that come with the Metatype.
                if (xmlQualityDocumentQualitiesNode == null)
                    xmlQualityDocumentQualitiesNode = LoadData("qualities.xml", token: token).SelectSingleNode("/chummer/qualities");
                if (xmlQualityDocumentQualitiesNode != null)
                {
                    using (XmlNodeList xmlQualityList = charNode.SelectNodes("qualities/*/quality"))
                    {
                        if (xmlQualityList != null)
                        {
                            foreach (XmlNode objXmlQualityItem in xmlQualityList)
                            {
                                string strQuality = objXmlQualityItem.InnerTextViaPool(token);
                                XmlNode objXmlQuality = xmlQualityDocumentQualitiesNode.TryGetNodeByNameOrId("quality", strQuality);
                                if (objXmlQuality != null)
                                {
                                    Quality objQuality = new Quality(this);
                                    try
                                    {
                                        token.ThrowIfCancellationRequested();
                                        string strForceValue =
                                            objXmlQualityItem.Attributes["select"]?.InnerTextViaPool(token) ?? string.Empty;
                                        QualitySource objSource =
                                            objXmlQualityItem.Attributes["removable"]?.InnerTextIsTrueString() == true
                                                ? QualitySource.MetatypeRemovable
                                                : QualitySource.Metatype;
                                        objQuality.Create(objXmlQuality, objSource, lstWeapons, strForceValue, token: token);
                                        objQuality.ContributeToLimit = false;
                                        Qualities.Add(objQuality);
                                    }
                                    catch
                                    {
                                        objQuality.DeleteQuality(token: CancellationToken.None);
                                        throw;
                                    }
                                }
                            }
                        }
                    }
                }

                //Load any critter powers the character has.
                if (xmlCritterPowerDocumentPowersNode == null)
                    xmlCritterPowerDocumentPowersNode =
                        LoadData("critterpowers.xml", token: token).SelectSingleNode("/chummer/powers");
                if (xmlCritterPowerDocumentPowersNode != null)
                {
                    foreach (XmlNode objXmlPower in charNode.SelectNodes("powers/power"))
                    {
                        string strCritterPower = objXmlPower.InnerTextViaPool(token);
                        XmlNode objXmlCritterPower = xmlCritterPowerDocumentPowersNode.TryGetNodeByNameOrId("power", strCritterPower);
                        if (objXmlCritterPower != null)
                        {
                            CritterPower objPower = new CritterPower(this);
                            string strForcedValue = objXmlPower.Attributes["select"]?.InnerTextViaPool(token) ?? string.Empty;
                            int intRating =
                                CommonFunctions.ExpressionToInt(objXmlPower.Attributes["rating"]?.InnerTextViaPool(token), intForce,
                                                                0,
                                                                0, token);

                            objPower.Create(objXmlCritterPower, intRating, strForcedValue);
                            objPower.CountTowardsLimit = false;
                            CritterPowers.Add(objPower);
                            try
                            {
                                token.ThrowIfCancellationRequested();
                                ImprovementManager.CreateImprovement(this, objPower.InternalId,
                                                                     Improvement.ImprovementSource.Metatype,
                                                                     string.Empty,
                                                                     Improvement.ImprovementType.CritterPower,
                                                                     string.Empty, token: token);
                            }
                            catch
                            {
                                ImprovementManager.Rollback(this, CancellationToken.None);
                                throw;
                            }

                            ImprovementManager.Commit(this, token);
                        }
                    }
                }

                //Load any natural weapons the character has.
                foreach (XmlNode objXmlNaturalWeapon in charNode.SelectNodes("naturalweapons/naturalweapon"))
                {
                    string strReach = objXmlNaturalWeapon["reach"]?.InnerTextViaPool(token) ?? "0";
                    string strForce = intForce.ToString(GlobalSettings.InvariantCultureInfo);
                    Weapon objWeapon = new Weapon(this);
                    try
                    {
                        objWeapon.Name = objXmlNaturalWeapon["name"].InnerTextViaPool(token);
                        objWeapon.Category = LanguageManager.GetString("Tab_Critter", GlobalSettings.DefaultLanguage, token: token);
                        objWeapon.RangeType = "Melee";
                        objWeapon.Reach = strReach.Replace("F", strForce).Replace("1D6", strForce).Replace("2D6", strForce);
                        objWeapon.Damage = objXmlNaturalWeapon["damage"]?.InnerTextViaPool(token) ?? "({STR})S";
                        objWeapon.Accuracy = objXmlNaturalWeapon["accuracy"]?.InnerTextViaPool(token) ?? "Physical";
                        objWeapon.AP = objXmlNaturalWeapon["ap"]?.InnerTextViaPool(token) ?? "0";
                        objWeapon.Mode = "0";
                        objWeapon.RC = "0";
                        objWeapon.Concealability = "0";
                        objWeapon.Avail = "0";
                        objWeapon.Cost = "0";
                        objWeapon.UseSkill = objXmlNaturalWeapon["useskill"]?.InnerTextViaPool(token) ?? string.Empty;
                        objWeapon.Source = objXmlNaturalWeapon["source"]?.InnerTextViaPool(token) ?? "SR5";
                        objWeapon.Page = objXmlNaturalWeapon["page"]?.InnerTextViaPool(token) ?? "0";
                        Weapons.Add(objWeapon);
                    }
                    catch
                    {
                        objWeapon.DeleteWeapon();
                        throw;
                    }
                }

                // Add the Unarmed Attack Weapon to the character.
                if (Weapons.All(x => x.Name != "Unarmed Attack", token))
                {
                    XmlNode objXmlWeapon = LoadData("weapons.xml", token: token)
                        .SelectSingleNode("/chummer/weapons/weapon[name = \"Unarmed Attack\"]");
                    if (objXmlWeapon != null)
                    {
                        Weapon objWeapon = new Weapon(this);
                        try
                        {
                            objWeapon.Create(objXmlWeapon, lstWeapons, token: token);
                            objWeapon.ParentID =
                                Guid.NewGuid()
                                    .ToString("D",
                                        GlobalSettings.InvariantCultureInfo); // Unarmed Attack can never be removed
                            Weapons.Add(objWeapon);
                        }
                        catch
                        {
                            objWeapon.DeleteWeapon();
                            throw;
                        }
                    }
                }

                //Set the Active Skill Ratings for the Critter.
                foreach (XmlNode xmlSkill in charNode.SelectNodes("skills/skill"))
                {
                    string strRating = xmlSkill.Attributes?["rating"]?.InnerTextViaPool(token);
                    bool bImprovementAdded = false;
                    if (!string.IsNullOrEmpty(strRating))
                    {
                        try
                        {
                            token.ThrowIfCancellationRequested();
                            ImprovementManager.CreateImprovement(this, xmlSkill.InnerTextViaPool(token),
                                                                 Improvement.ImprovementSource.Metatype, string.Empty,
                                                                 Improvement.ImprovementType.SkillLevel,
                                                                 string.Empty,
                                                                 CommonFunctions.ExpressionToInt(
                                                                     strRating, intForce, 0, 0, token), token: token);
                        }
                        catch
                        {
                            ImprovementManager.Rollback(this, CancellationToken.None);
                            throw;
                        }

                        ImprovementManager.Commit(this, token);
                        bImprovementAdded = true;
                    }

                    string strSkill = xmlSkill.InnerTextViaPool(token);
                    string strSpec = xmlSkill.Attributes?["spec"]?.InnerTextViaPool(token) ?? string.Empty;
                    Skill objSkill = SkillsSection.GetActiveSkill(strSkill, token);

                    if (objSkill == null)
                    {
                        if (ExoticSkill.IsExoticSkillName(this, strSkill, token))
                        {
                            SkillsSection.AddExoticSkill(strSkill, strSpec, token);
                            continue;
                        }

                        if (!bImprovementAdded)
                            continue;

                        //This skill does not yet exist but the datafile asks to improve it.
                        //We need to add it so it is not only improved but also shown on the skills tab.
                        SkillsSection.AddSkills(SkillsSection.FilterOption.Name, strSkill, token);
                        objSkill = SkillsSection.GetActiveSkill(strSkill, token);
                    }

                    if (objSkill != null) //More or less a safeguard only. Should not be empty at that point any longer.
                    {
                        if (string.IsNullOrEmpty(strSpec)) continue;
                        if (objSkill.Specializations.All(x => x.Name != strSpec, token))
                        {
                            SkillSpecialization objSpec = new SkillSpecialization(this, objSkill, strSpec, false, false);
                            try
                            {
                                token.ThrowIfCancellationRequested();
                                objSkill.Specializations.Add(objSpec);
                                try
                                {
                                    token.ThrowIfCancellationRequested();
                                    ImprovementManager.CreateImprovement(this, strSkill,
                                                                         Improvement.ImprovementSource.Metatype,
                                                                         string.Empty,
                                                                         Improvement.ImprovementType
                                                                             .SkillSpecialization,
                                                                         objSpec.InternalId, token: token);
                                }
                                catch
                                {
                                    ImprovementManager.Rollback(this, CancellationToken.None);
                                    throw;
                                }

                                ImprovementManager.Commit(this, token);
                            }
                            catch
                            {
                                objSpec.Dispose();
                                throw;
                            }
                        }
                    }
                }

                //Set the Skill Group Ratings for the Critter.
                foreach (XmlNode xmlSkillGroup in charNode.SelectNodes("skills/group"))
                {
                    string strRating = xmlSkillGroup.Attributes?["rating"]?.InnerTextViaPool(token);
                    if (!string.IsNullOrEmpty(strRating))
                    {
                        try
                        {
                            token.ThrowIfCancellationRequested();
                            ImprovementManager.CreateImprovement(this, xmlSkillGroup.InnerTextViaPool(token),
                                                                 Improvement.ImprovementSource.Metatype, string.Empty,
                                                                 Improvement.ImprovementType.SkillGroupLevel,
                                                                 string.Empty,
                                                                 CommonFunctions.ExpressionToInt(
                                                                     strRating, intForce, 0, 0, token), token: token);
                        }
                        catch
                        {
                            ImprovementManager.Rollback(this, CancellationToken.None);
                            throw;
                        }

                        ImprovementManager.Commit(this, token);
                    }
                }

                //Set the Knowledge Skill Ratings for the Critter.
                if (xmlSkillsDocumentKnowledgeSkillsNode == null)
                    xmlSkillsDocumentKnowledgeSkillsNode =
                        LoadData("skills.xml", token: token).SelectSingleNode("/chummer/knowledgeskills");
                if (xmlSkillsDocumentKnowledgeSkillsNode != null)
                {
                    foreach (XmlNode xmlSkill in charNode.SelectNodes("skills/knowledge"))
                    {
                        string strName = xmlSkill.InnerTextViaPool(token);
                        if (string.IsNullOrEmpty(strName))
                            continue;
                        string strRating = xmlSkill.Attributes?["rating"]?.InnerTextViaPool(token);
                        if (string.IsNullOrEmpty(strRating))
                            continue;
                        if (SkillsSection.KnowledgeSkills.All(x => x.DictionaryKey != strName, token))
                        {
                            XmlNode objXmlSkillNode =
                                xmlSkillsDocumentKnowledgeSkillsNode.TryGetNodeByNameOrId("skill", strName);
                            if (objXmlSkillNode != null)
                            {
                                Skill objUncastSkill = Skill.FromData(objXmlSkillNode, this, true);
                                try
                                {
                                    if (objUncastSkill is KnowledgeSkill objSkill)
                                        SkillsSection.KnowledgeSkills.Add(objSkill);
                                    else
                                    {
                                        Utils.BreakIfDebug();
                                        objUncastSkill?.Remove();
                                    }
                                }
                                catch
                                {
                                    objUncastSkill?.Remove();
                                    throw;
                                }
                            }
                            else
                            {
                                KnowledgeSkill objSkill = new KnowledgeSkill(this, strName, true);
                                try
                                {
                                    objSkill.Type = xmlSkill.Attributes?["category"]?.InnerTextViaPool(token);
                                    SkillsSection.KnowledgeSkills.Add(objSkill);
                                }
                                catch
                                {
                                    objSkill.Remove();
                                    throw;
                                }
                            }
                        }

                        try
                        {
                            token.ThrowIfCancellationRequested();
                            ImprovementManager.CreateImprovement(this, strName,
                                                                 Improvement.ImprovementSource.Metatype, string.Empty,
                                                                 Improvement.ImprovementType.SkillLevel, string.Empty,
                                                                 CommonFunctions.ExpressionToInt(
                                                                     strRating, intForce, 0, 0, token), token: token);
                        }
                        catch
                        {
                            ImprovementManager.Rollback(this, CancellationToken.None);
                            throw;
                        }

                        ImprovementManager.Commit(this, token);
                    }
                }

                // Add any Complex Forms the Critter comes with (typically Sprites)
                XmlDocument xmlComplexFormDocument = LoadData("complexforms.xml", token: token);
                foreach (XmlNode xmlComplexForm in charNode.SelectNodes("complexforms/complexform"))
                {
                    XmlNode xmlComplexFormData = xmlComplexFormDocument.TryGetNodeByNameOrId("/chummer/complexforms/complexform", xmlComplexForm.InnerTextViaPool(token));
                    if (xmlComplexFormData == null)
                        continue;

                    ComplexForm objComplexForm = new ComplexForm(this);
                    try
                    {
                        objComplexForm.Create(xmlComplexFormData);
                        if (objComplexForm.InternalId.IsEmptyGuid())
                        {
                            objComplexForm.Remove(false);
                            continue;
                        }
                        objComplexForm.Grade = -1;

                        ComplexForms.Add(objComplexForm);
                    }
                    catch
                    {
                        objComplexForm.Remove(false);
                        throw;
                    }

                    try
                    {
                        token.ThrowIfCancellationRequested();
                        ImprovementManager.CreateImprovement(this, objComplexForm.InternalId,
                                                             Improvement.ImprovementSource.Metatype, string.Empty,
                                                             Improvement.ImprovementType.ComplexForm,
                                                             string.Empty, token: token);
                    }
                    catch
                    {
                        ImprovementManager.Rollback(this, CancellationToken.None);
                        throw;
                    }

                    ImprovementManager.Commit(this, token);
                }

                //Load any cyberware the character has.
                XmlDocument xmlCyberwareDocument = LoadData("cyberware.xml", token: token);
                foreach (XmlNode node in charNode.SelectNodes("cyberwares/cyberware"))
                {
                    XmlNode objXmlCyberwareNode = xmlCyberwareDocument.TryGetNodeByNameOrId("chummer/cyberwares/cyberware", node.InnerTextViaPool(token));
                    if (objXmlCyberwareNode == null)
                        continue;
                    string strForcedValue = node.Attributes["select"]?.InnerTextViaPool(token) ?? string.Empty;
                    int intRating =
                        CommonFunctions.ExpressionToInt(node.Attributes["rating"]?.InnerTextViaPool(token), intForce, 0, 0, token);
                    Cyberware objWare = new Cyberware(this);
                    try
                    {
                        objWare.Create(objXmlCyberwareNode,
                            GetGradeByName(Improvement.ImprovementSource.Cyberware, "None", true, token),
                            Improvement.ImprovementSource.Metatype, intRating,
                            Weapons, Vehicles, true, true, strForcedValue, token: token);
                        Cyberware.Add(objWare);
                        try
                        {
                            token.ThrowIfCancellationRequested();
                            ImprovementManager.CreateImprovement(this, objWare.InternalId,
                                                                 Improvement.ImprovementSource.Metatype,
                                                                 string.Empty, Improvement.ImprovementType.FreeWare,
                                                                 string.Empty, token: token);
                        }
                        catch
                        {
                            ImprovementManager.Rollback(this, CancellationToken.None);
                            throw;
                        }

                        ImprovementManager.Commit(this, token);
                    }
                    catch
                    {
                        objWare.DeleteCyberware();
                        throw;
                    }
                }

                //Load any bioware the character has.
                XmlDocument xmlBiowareDocument = LoadData("bioware.xml", token: token);
                foreach (XmlNode node in charNode.SelectNodes("biowares/bioware"))
                {
                    XmlNode objXmlCyberwareNode = xmlBiowareDocument.TryGetNodeByNameOrId("chummer/biowares/bioware", node.InnerTextViaPool(token));
                    if (objXmlCyberwareNode == null)
                        continue;
                    string strForcedValue = node.Attributes["select"]?.InnerTextViaPool(token) ?? string.Empty;
                    int intRating =
                        CommonFunctions.ExpressionToInt(node.Attributes["rating"]?.InnerTextViaPool(token), intForce, 0, 0, token);
                    Cyberware objWare = new Cyberware(this);
                    try
                    {
                        objWare.Create(objXmlCyberwareNode,
                            GetGradeByName(Improvement.ImprovementSource.Bioware, "None", true, token),
                            Improvement.ImprovementSource.Metatype, intRating,
                            Weapons, Vehicles, true, true, strForcedValue, token: token);
                        Cyberware.Add(objWare);
                        try
                        {
                            token.ThrowIfCancellationRequested();
                            ImprovementManager.CreateImprovement(this, objWare.InternalId,
                                                                 Improvement.ImprovementSource.Metatype,
                                                                 string.Empty, Improvement.ImprovementType.FreeWare,
                                                                 string.Empty, token: token);
                        }
                        catch
                        {
                            ImprovementManager.Rollback(this, CancellationToken.None);
                            throw;
                        }

                        ImprovementManager.Commit(this, token);
                    }
                    catch
                    {
                        objWare.DeleteCyberware();
                        throw;
                    }
                }

                // Add any Advanced Programs the Critter comes with (typically A.I.s)
                XmlDocument xmlAIProgramDocument = LoadData("programs.xml", token: token);
                foreach (XmlNode xmlAIProgram in charNode.SelectNodes("programs/program"))
                {
                    XmlNode xmlAIProgramData = xmlAIProgramDocument.TryGetNodeByNameOrId("chummer/programs/program", xmlAIProgram.InnerTextViaPool(token));
                    if (xmlAIProgramData == null)
                        continue;

                    // Check for SelectText.
                    string strExtra = xmlAIProgram.Attributes?["select"]?.InnerTextViaPool(token) ?? string.Empty;
                    if (xmlAIProgramData.SelectSingleNodeAndCacheExpressionAsNavigator("bonus/selecttext", token) != null && !string.IsNullOrWhiteSpace(strExtra))
                    {
                        using (ThreadSafeForm<SelectText> frmPickText = ThreadSafeForm<SelectText>.Get(() => new SelectText
                        {
                            Description = string.Format(GlobalSettings.CultureInfo,
                                       LanguageManager.GetString("String_Improvement_SelectText", token: token),
                                       xmlAIProgramData["translate"]?.InnerTextViaPool(token) ?? xmlAIProgramData["name"]?.InnerTextViaPool(token))
                        }))
                        {
                            // Make sure the dialogue window was not canceled.
                            if (frmPickText.ShowDialogSafe(this, token) == DialogResult.Cancel)
                                continue;
                            strExtra = frmPickText.MyForm.SelectedValue;
                        }
                    }

                    AIProgram objAIProgram = new AIProgram(this);
                    objAIProgram.Create(xmlAIProgram, strExtra, false);
                    if (objAIProgram.InternalId.IsEmptyGuid())
                        continue;

                    AIPrograms.Add(objAIProgram);

                    try
                    {
                        token.ThrowIfCancellationRequested();
                        ImprovementManager.CreateImprovement(this, objAIProgram.InternalId,
                                                             Improvement.ImprovementSource.Metatype, string.Empty,
                                                             Improvement.ImprovementType.AIProgram,
                                                             string.Empty, token: token);
                    }
                    catch
                    {
                        ImprovementManager.Rollback(this, CancellationToken.None);
                        throw;
                    }

                    ImprovementManager.Commit(this, token);
                }

                // Add any Gear the Critter comes with (typically Programs for A.I.s)
                XmlDocument xmlGearDocument = LoadData("gear.xml", token: token);
                foreach (XmlNode xmlGear in charNode.SelectNodes("gears/gear"))
                {
                    XmlNode xmlGearData = xmlGearDocument.TryGetNodeByNameOrId(
                        "/chummer/gears/gear", xmlGear["name"].InnerTextViaPool(token),
                        "category = " + xmlGear["category"].InnerTextViaPool(token).CleanXPath());
                    if (xmlGearData == null)
                        continue;

                    int intRating = 1;
                    if (xmlGear["rating"] != null)
                        intRating = CommonFunctions.ExpressionToInt(xmlGear["rating"].InnerTextViaPool(token), intForce, 0, 0, token);
                    decimal decQty = 1.0m;
                    if (xmlGear["quantity"] != null)
                        decQty = CommonFunctions.ExpressionToDecimal(xmlGear["quantity"].InnerTextViaPool(token), intForce, token: token);
                    string strForceValue = xmlGear.Attributes?["select"]?.InnerTextViaPool(token) ?? string.Empty;

                    Gear objGear = new Gear(this);
                    try
                    {
                        objGear.Create(xmlGearData, intRating, lstWeapons, strForceValue, token: token);

                        if (objGear.InternalId.IsEmptyGuid())
                        {
                            objGear.DeleteGear();
                            continue;
                        }

                        objGear.Quantity = decQty;

                        // If a Commlink has just been added, see if the character already has one. If not, make it the active Commlink.
                        if (ActiveCommlink == null && objGear.IsCommlink)
                        {
                            objGear.SetActiveCommlink(this, true);
                        }

                        objGear.Cost = "0";
                        objGear.ParentID = Guid.NewGuid().ToString();

                        Gear.Add(objGear);

                        try
                        {
                            token.ThrowIfCancellationRequested();
                            ImprovementManager.CreateImprovement(this, objGear.InternalId,
                                                                 Improvement.ImprovementSource.Metatype,
                                                                 string.Empty, Improvement.ImprovementType.Gear,
                                                                 string.Empty, token: token);
                        }
                        catch
                        {
                            ImprovementManager.Rollback(this, CancellationToken.None);
                            throw;
                        }

                        ImprovementManager.Commit(this, token);
                    }
                    catch
                    {
                        objGear.DeleteGear();
                        throw;
                    }
                }

                // Add any created Weapons to the character.
                foreach (Weapon objWeapon in lstWeapons)
                    Weapons.Add(objWeapon);

                // Sprites can never have Physical Attributes
                if (DEPEnabled || strSelectedMetatypeCategory?.EndsWith("Sprite", StringComparison.Ordinal) == true ||
                    strSelectedMetatypeCategory?.EndsWith("Sprites", StringComparison.Ordinal) == true)
                {
                    BOD.AssignBaseKarmaLimits(0, 0, 0, 0, 0);
                    AGI.AssignBaseKarmaLimits(0, 0, 0, 0, 0);
                    REA.AssignBaseKarmaLimits(0, 0, 0, 0, 0);
                    STR.AssignBaseKarmaLimits(0, 0, 0, 0, 0);
                    MAG.AssignBaseKarmaLimits(0, 0, 0, 0, 0);
                    MAGAdept.AssignBaseKarmaLimits(0, 0, 0, 0, 0);
                }

                if (strSelectedMetatypeCategory == "Spirits")
                {
                    XmlElement xmlOptionalPowersNode = charNode["optionalpowers"];
                    if (xmlOptionalPowersNode != null && intForce >= 3)
                    {
                        using (new FetchSafelyFromSafeObjectPool<XmlDocument>(Utils.XmlDocumentPool, out XmlDocument objDummyDocument))
                        {
                            //For every 3 full points of Force a spirit has, it may gain one Optional Power.
                            for (int i = intForce; i >= 3; i -= 3)
                            {
                                XmlNode bonusNode = objDummyDocument.CreateNode(XmlNodeType.Element, "bonus", null);
                                XmlNode powerNode =
                                    objDummyDocument.ImportNode(xmlOptionalPowersNode.CloneNode(true), true);
                                bonusNode.AppendChild(powerNode);
                                objDummyDocument.AppendChild(bonusNode);
                            }

                            foreach (XmlNode bonusNode in objDummyDocument.SelectNodes("/bonus"))
                                ImprovementManager.CreateImprovements(this, Improvement.ImprovementSource.Metatype,
                                    strMetatypeId, bonusNode, 1, strMetatypeId, token: token);
                        }
                    }

                    // Remove the Critter's Materialization Power if they have it. Add the Possession or Inhabitation Power if the Possession-based Tradition checkbox is checked.
                    if (xmlCritterPowerDocumentPowersNode != null)
                    {
                        if (!string.IsNullOrEmpty(strSelectedPossessionMethod))
                        {
                            CritterPower objMaterializationPower =
                                CritterPowers.FirstOrDefault(x => x.Name == "Materialization");
                            if (objMaterializationPower != null)
                                CritterPowers.Remove(objMaterializationPower);

                            if (CritterPowers.All(x => !x.Name.Contains(strSelectedPossessionMethod), token))
                            {
                                // Add the selected Power.
                                XmlNode objXmlCritterPower =
                                    xmlCritterPowerDocumentPowersNode.TryGetNodeByNameOrId("power", strSelectedPossessionMethod);
                                if (objXmlCritterPower != null)
                                {
                                    CritterPower objPower = new CritterPower(this);
                                    try
                                    {
                                        objPower.Create(objXmlCritterPower, 0, string.Empty);
                                        objPower.CountTowardsLimit = false;
                                        CritterPowers.Add(objPower);

                                        try
                                        {
                                            token.ThrowIfCancellationRequested();
                                            ImprovementManager.CreateImprovement(this, objPower.InternalId,
                                                                                 Improvement.ImprovementSource.Metatype,
                                                                                 string.Empty,
                                                                                 Improvement.ImprovementType.CritterPower,
                                                                                 string.Empty, token: token);
                                        }
                                        catch
                                        {
                                            ImprovementManager.Rollback(this, CancellationToken.None);
                                            throw;
                                        }

                                        ImprovementManager.Commit(this, token);
                                    }
                                    catch
                                    {
                                        objPower.Remove(false);
                                        throw;
                                    }
                                }
                            }
                        }
                        else if (CritterPowers.All(x =>
                                     x.Name != "Materialization" && !x.Name.Contains("Possession") &&
                                     !x.Name.Contains("Inhabitation"), token))
                        {
                            // Add the Materialization Power.
                            XmlNode objXmlCritterPower =
                                xmlCritterPowerDocumentPowersNode.SelectSingleNode("power[name = \"Materialization\"]");
                            if (objXmlCritterPower != null)
                            {
                                CritterPower objPower = new CritterPower(this);
                                try
                                {
                                    objPower.Create(objXmlCritterPower, 0, string.Empty);
                                    objPower.CountTowardsLimit = false;
                                    CritterPowers.Add(objPower);

                                    try
                                    {
                                        token.ThrowIfCancellationRequested();
                                        ImprovementManager.CreateImprovement(this, objPower.InternalId,
                                                                             Improvement.ImprovementSource.Metatype,
                                                                             string.Empty,
                                                                             Improvement.ImprovementType.CritterPower,
                                                                             string.Empty, token: token);
                                    }
                                    catch
                                    {
                                        ImprovementManager.Rollback(this, CancellationToken.None);
                                        throw;
                                    }

                                    ImprovementManager.Commit(this, token);
                                }
                                catch
                                {
                                    objPower.Remove(false);
                                    throw;
                                }
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Set up a character with a metatype and new attributes to match.
        /// </summary>
        public async Task CreateAsync(string strSelectedMetatypeCategory, string strMetatypeId, string strMetavariantId,
            XmlNode objXmlMetatype, int intForce, XmlNode xmlQualityDocumentQualitiesNode = null,
            XmlNode xmlCritterPowerDocumentPowersNode = null, XmlNode xmlSkillsDocumentKnowledgeSkillsNode = null,
            string strSelectedPossessionMethod = "", CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                if (objXmlMetatype == null)
                    throw new ArgumentNullException(nameof(objXmlMetatype));
                // Remove any Improvements the character received from their Metatype.
                await ImprovementManager.RemoveImprovementsAsync(this,
                    await Improvements.ToListAsync(objImprovement =>
                            objImprovement.ImproveSource == Improvement.ImprovementSource.Metatype
                            || objImprovement.ImproveSource == Improvement.ImprovementSource.Metavariant, token: token)
                        .ConfigureAwait(false),
                    token: token).ConfigureAwait(false);

                // Remove any Qualities the character received from their Metatype, then remove the Quality.
                for (int i = await Qualities.GetCountAsync(token).ConfigureAwait(false) - 1; i >= 0; --i)
                {
                    if (i >= await Qualities.GetCountAsync(token).ConfigureAwait(false))
                        continue;
                    Quality objQuality = await Qualities.GetValueAtAsync(i, token).ConfigureAwait(false);
                    if (objQuality.OriginSource == QualitySource.Metatype ||
                        objQuality.OriginSource == QualitySource.MetatypeRemovable ||
                        objQuality.OriginSource == QualitySource.MetatypeRemovedAtChargen)
                        await objQuality.DeleteQualityAsync(token: token).ConfigureAwait(false);
                }

                // If this is a Shapeshifter, a Metavariant must be selected. Default to Human if None is selected.
                if (strSelectedMetatypeCategory == "Shapeshifter" && strMetavariantId.IsEmptyGuid())
                    strMetavariantId =
                        objXmlMetatype
                            .SelectSingleNodeAndCacheExpressionAsNavigator(
                                "metavariants/metavariant[name = \"Human\"]/id", token)?.Value ??
                        string.Empty;
                XmlNode objXmlMetavariant =
                    objXmlMetatype.TryGetNodeByNameOrId("metavariants/metavariant", strMetavariantId);

                // Set Metatype information.
                XmlNode charNode =
                    strSelectedMetatypeCategory == "Shapeshifter" || strMetavariantId.IsEmptyGuid()
                        ? objXmlMetatype
                        : objXmlMetavariant ?? objXmlMetatype;
                await AttributeSection.CreateAsync(charNode, intForce, token: token).ConfigureAwait(false);
                MetatypeGuid = new Guid(strMetatypeId);
                Metatype = objXmlMetatype["name"]?.InnerTextViaPool(token) ?? "Human";
                await SetMetatypeCategoryAsync(strSelectedMetatypeCategory, token).ConfigureAwait(false);
                MetavariantGuid = string.IsNullOrEmpty(strMetavariantId) ? Guid.Empty : new Guid(strMetavariantId);
                Metavariant = MetavariantGuid != Guid.Empty ? objXmlMetavariant?["name"]?.InnerTextViaPool(token) ?? string.Empty : string.Empty;
                // We only reverted to the base metatype to get the attributes.
                if (strSelectedMetatypeCategory == "Shapeshifter")
                {
                    charNode = objXmlMetavariant ?? objXmlMetatype;
                }

                Source = charNode["source"]?.InnerTextViaPool(token) ?? "SR5";
                Page = charNode["page"]?.InnerTextViaPool(token) ?? "0";
                _intMetatypeBP = 0;
                charNode.TryGetInt32FieldQuickly("karma", ref _intMetatypeBP);
                _intInitiativeDice = await (await GetSettingsAsync(token).ConfigureAwait(false)).GetMinInitiativeDiceAsync(token).ConfigureAwait(false);
                charNode.TryGetInt32FieldQuickly("initiativedice", ref _intInitiativeDice);

                Movement = objXmlMetatype["movement"]?.InnerTextViaPool(token) ?? string.Empty;

                // Determine if the Metatype has any bonuses.
                XmlElement xmlBonusNode = charNode["bonus"];
                if (xmlBonusNode != null)
                    await ImprovementManager.CreateImprovementsAsync(this, Improvement.ImprovementSource.Metatype,
                        strMetatypeId,
                        xmlBonusNode, 1, strMetatypeId, token: token).ConfigureAwait(false);

                List<Weapon> lstWeapons = new List<Weapon>(1);
                // Create the Qualities that come with the Metatype.
                if (xmlQualityDocumentQualitiesNode == null)
                    xmlQualityDocumentQualitiesNode =
                        (await LoadDataAsync("qualities.xml", token: token).ConfigureAwait(false)).SelectSingleNode(
                            "/chummer/qualities");
                if (xmlQualityDocumentQualitiesNode != null)
                {
                    using (XmlNodeList xmlQualityList = charNode.SelectNodes("qualities/*/quality"))
                    {
                        if (xmlQualityList != null)
                        {
                            foreach (XmlNode objXmlQualityItem in xmlQualityList)
                            {
                                string strQuality = objXmlQualityItem.InnerTextViaPool(token);
                                XmlNode objXmlQuality =
                                    xmlQualityDocumentQualitiesNode.TryGetNodeByNameOrId("quality", strQuality);
                                if (objXmlQuality != null)
                                {
                                    Quality objQuality = new Quality(this);
                                    try
                                    {
                                        token.ThrowIfCancellationRequested();
                                        string strForceValue =
                                            objXmlQualityItem.Attributes["select"]?.InnerTextViaPool(token) ?? string.Empty;
                                        QualitySource objSource =
                                            objXmlQualityItem.Attributes["removable"]?.InnerTextIsTrueString() == true
                                                ? QualitySource.MetatypeRemovable
                                                : QualitySource.Metatype;
                                        await objQuality.CreateAsync(objXmlQuality, objSource, lstWeapons,
                                            strForceValue,
                                            token: token).ConfigureAwait(false);
                                        await objQuality.SetContributeToLimitAsync(false, token).ConfigureAwait(false);
                                        await Qualities.AddAsync(objQuality, token).ConfigureAwait(false);
                                    }
                                    catch
                                    {
                                        await objQuality.DeleteQualityAsync(token: CancellationToken.None).ConfigureAwait(false);
                                        throw;
                                    }
                                }
                            }
                        }
                    }
                }

                //Load any critter powers the character has.
                if (xmlCritterPowerDocumentPowersNode == null)
                    xmlCritterPowerDocumentPowersNode =
                        (await LoadDataAsync("critterpowers.xml", token: token).ConfigureAwait(false)).SelectSingleNode(
                            "/chummer/powers");
                if (xmlCritterPowerDocumentPowersNode != null)
                {
                    foreach (XmlNode objXmlPower in charNode.SelectNodes("powers/power"))
                    {
                        string strCritterPower = objXmlPower.InnerTextViaPool(token);
                        XmlNode objXmlCritterPower =
                            xmlCritterPowerDocumentPowersNode.TryGetNodeByNameOrId("power", strCritterPower);
                        if (objXmlCritterPower != null)
                        {
                            CritterPower objPower = new CritterPower(this);
                            string strForcedValue = objXmlPower.Attributes["select"]?.InnerTextViaPool(token) ?? string.Empty;
                            int intRating =
                                await CommonFunctions.ExpressionToIntAsync(objXmlPower.Attributes["rating"]?.InnerTextViaPool(token),
                                    intForce,
                                    0,
                                    0, token).ConfigureAwait(false);

                            await objPower.CreateAsync(objXmlCritterPower, intRating, strForcedValue, token).ConfigureAwait(false);
                            objPower.CountTowardsLimit = false;
                            await CritterPowers.AddAsync(objPower, token).ConfigureAwait(false);
                            try
                            {
                                token.ThrowIfCancellationRequested();
                                await ImprovementManager.CreateImprovementAsync(this, objPower.InternalId,
                                    Improvement.ImprovementSource.Metatype,
                                    string.Empty,
                                    Improvement.ImprovementType.CritterPower,
                                    string.Empty, token: token).ConfigureAwait(false);
                            }
                            catch
                            {
                                await ImprovementManager.RollbackAsync(this, CancellationToken.None)
                                    .ConfigureAwait(false);
                                throw;
                            }

                            await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);
                        }
                    }
                }

                //Load any natural weapons the character has.
                foreach (XmlNode objXmlNaturalWeapon in charNode.SelectNodes("naturalweapons/naturalweapon"))
                {
                    string strReach = objXmlNaturalWeapon["reach"]?.InnerTextViaPool(token) ?? "0";
                    string strForce = intForce.ToString(GlobalSettings.InvariantCultureInfo);
                    Weapon objWeapon = new Weapon(this);
                    try
                    {
                        objWeapon.Name = objXmlNaturalWeapon["name"].InnerTextViaPool(token);
                        objWeapon.Category = await LanguageManager.GetStringAsync("Tab_Critter", GlobalSettings.DefaultLanguage,
                            token: token).ConfigureAwait(false);
                        objWeapon.RangeType = "Melee";
                        objWeapon.Reach = strReach.Replace("F", strForce).Replace("1D6", strForce).Replace("2D6", strForce);
                        objWeapon.Damage = objXmlNaturalWeapon["damage"]?.InnerTextViaPool(token) ?? "({STR})S";
                        objWeapon.Accuracy = objXmlNaturalWeapon["accuracy"]?.InnerTextViaPool(token) ?? "Physical";
                        objWeapon.AP = objXmlNaturalWeapon["ap"]?.InnerTextViaPool(token) ?? "0";
                        objWeapon.Mode = "0";
                        objWeapon.RC = "0";
                        objWeapon.Concealability = "0";
                        objWeapon.Avail = "0";
                        objWeapon.Cost = "0";
                        objWeapon.UseSkill = objXmlNaturalWeapon["useskill"]?.InnerTextViaPool(token) ?? string.Empty;
                        objWeapon.Source = objXmlNaturalWeapon["source"]?.InnerTextViaPool(token) ?? "SR5";
                        objWeapon.Page = objXmlNaturalWeapon["page"]?.InnerTextViaPool(token) ?? "0";
                        await Weapons.AddAsync(objWeapon, token).ConfigureAwait(false);
                    }
                    catch
                    {
                        await objWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                        throw;
                    }
                }

                // Add the Unarmed Attack Weapon to the character.
                if (await Weapons.AllAsync(x => x.Name != "Unarmed Attack", token).ConfigureAwait(false))
                {
                    XmlNode objXmlWeapon = (await LoadDataAsync("weapons.xml", token: token).ConfigureAwait(false))
                        .SelectSingleNode("/chummer/weapons/weapon[name = \"Unarmed Attack\"]");
                    if (objXmlWeapon != null)
                    {
                        Weapon objWeapon = new Weapon(this);
                        try
                        {
                            await objWeapon.CreateAsync(objXmlWeapon, lstWeapons, token: token).ConfigureAwait(false);
                            objWeapon.ParentID =
                                Guid.NewGuid()
                                    .ToString("D",
                                        GlobalSettings.InvariantCultureInfo); // Unarmed Attack can never be removed
                            await Weapons.AddAsync(objWeapon, token).ConfigureAwait(false);
                        }
                        catch
                        {
                            await objWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }
                    }
                }

                //Set the Active Skill Ratings for the Critter.
                foreach (XmlNode xmlSkill in charNode.SelectNodes("skills/skill"))
                {
                    string strRating = xmlSkill.Attributes?["rating"]?.InnerTextViaPool(token);
                    bool bImprovementAdded = false;
                    if (!string.IsNullOrEmpty(strRating))
                    {
                        try
                        {
                            token.ThrowIfCancellationRequested();
                            await ImprovementManager.CreateImprovementAsync(this, xmlSkill.InnerTextViaPool(token),
                                    Improvement.ImprovementSource.Metatype, string.Empty,
                                    Improvement.ImprovementType.SkillLevel,
                                    string.Empty,
                                    await CommonFunctions.ExpressionToIntAsync(
                                        strRating, intForce, 0, 0, token).ConfigureAwait(false), token: token)
                                .ConfigureAwait(false);
                        }
                        catch
                        {
                            await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }

                        await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);
                        bImprovementAdded = true;
                    }

                    string strSkill = xmlSkill.InnerTextViaPool(token);
                    string strSpec = xmlSkill.Attributes?["spec"]?.InnerTextViaPool(token) ?? string.Empty;
                    Skill objSkill = await SkillsSection.GetActiveSkillAsync(strSkill, token).ConfigureAwait(false);

                    if (objSkill == null)
                    {
                        if (await ExoticSkill.IsExoticSkillNameAsync(this, strSkill, token).ConfigureAwait(false))
                        {
                            await SkillsSection.AddExoticSkillAsync(strSkill, strSpec, token).ConfigureAwait(false);
                            continue;
                        }

                        if (!bImprovementAdded)
                            continue;

                        //This skill does not yet exist but the datafile asks to improve it.
                        //We need to add it so it is not only improved but also shown on the skills tab.
                        await SkillsSection.AddSkillsAsync(SkillsSection.FilterOption.Name, strSkill, token)
                            .ConfigureAwait(false);
                        objSkill = await SkillsSection.GetActiveSkillAsync(strSkill, token).ConfigureAwait(false);
                    }

                    if (objSkill != null) //More or less a safeguard only. Should not be empty at that point any longer.
                    {
                        if (string.IsNullOrEmpty(strSpec)) continue;
                        if (await objSkill.Specializations.AllAsync(async x => await x.GetNameAsync(token).ConfigureAwait(false) != strSpec, token)
                                .ConfigureAwait(false))
                        {
                            SkillSpecialization objSpec = new SkillSpecialization(this, objSkill, strSpec, false, false);
                            try
                            {
                                token.ThrowIfCancellationRequested();
                                await objSkill.Specializations.AddAsync(objSpec, token).ConfigureAwait(false);
                                try
                                {
                                    token.ThrowIfCancellationRequested();
                                    await ImprovementManager.CreateImprovementAsync(this, strSkill,
                                        Improvement.ImprovementSource.Metatype,
                                        string.Empty,
                                        Improvement.ImprovementType
                                            .SkillSpecialization,
                                        objSpec.InternalId, token: token).ConfigureAwait(false);
                                }
                                catch
                                {
                                    await ImprovementManager.RollbackAsync(this, CancellationToken.None)
                                        .ConfigureAwait(false);
                                    throw;
                                }

                                await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);
                            }
                            catch
                            {
                                await objSpec.DisposeAsync().ConfigureAwait(false);
                                throw;
                            }
                        }
                    }
                }

                //Set the Skill Group Ratings for the Critter.
                foreach (XmlNode xmlSkillGroup in charNode.SelectNodes("skills/group"))
                {
                    string strRating = xmlSkillGroup.Attributes?["rating"]?.InnerTextViaPool(token);
                    if (!string.IsNullOrEmpty(strRating))
                    {
                        try
                        {
                            token.ThrowIfCancellationRequested();
                            await ImprovementManager.CreateImprovementAsync(this, xmlSkillGroup.InnerTextViaPool(token),
                                    Improvement.ImprovementSource.Metatype, string.Empty,
                                    Improvement.ImprovementType.SkillGroupLevel,
                                    string.Empty,
                                    await CommonFunctions.ExpressionToIntAsync(
                                        strRating, intForce, 0, 0, token).ConfigureAwait(false), token: token)
                                .ConfigureAwait(false);
                        }
                        catch
                        {
                            await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }

                        await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);
                    }
                }

                //Set the Knowledge Skill Ratings for the Critter.
                if (xmlSkillsDocumentKnowledgeSkillsNode == null)
                    xmlSkillsDocumentKnowledgeSkillsNode =
                        (await LoadDataAsync("skills.xml", token: token).ConfigureAwait(false)).SelectSingleNode(
                            "/chummer/knowledgeskills");
                if (xmlSkillsDocumentKnowledgeSkillsNode != null)
                {
                    foreach (XmlNode xmlSkill in charNode.SelectNodes("skills/knowledge"))
                    {
                        string strName = xmlSkill.InnerTextViaPool(token);
                        if (string.IsNullOrEmpty(strName))
                            continue;
                        string strRating = xmlSkill.Attributes?["rating"]?.InnerTextViaPool(token);
                        if (string.IsNullOrEmpty(strRating))
                            continue;
                        if (await SkillsSection.KnowledgeSkills
                                .AllAsync(
                                    async x => await x.GetDictionaryKeyAsync(token).ConfigureAwait(false) != strName,
                                    token).ConfigureAwait(false))
                        {
                            XmlNode objXmlSkillNode =
                                xmlSkillsDocumentKnowledgeSkillsNode.TryGetNodeByNameOrId("skill", strName);
                            if (objXmlSkillNode != null)
                            {
                                Skill objUncastSkill = await Skill.FromDataAsync(objXmlSkillNode, this, true, token).ConfigureAwait(false);
                                try
                                {
                                    if (objUncastSkill is KnowledgeSkill objSkill)
                                        await SkillsSection.KnowledgeSkills.AddAsync(objSkill, token).ConfigureAwait(false);
                                    else
                                    {
                                        Utils.BreakIfDebug();
                                        if (objUncastSkill != null)
                                            await objUncastSkill.RemoveAsync(token).ConfigureAwait(false);
                                    }
                                }
                                catch
                                {
                                    if (objUncastSkill != null)
                                        await objUncastSkill.RemoveAsync(CancellationToken.None).ConfigureAwait(false);
                                    throw;
                                }
                            }
                            else
                            {
                                KnowledgeSkill objSkill = await KnowledgeSkill.NewAsync(this, strName, true, token)
                                    .ConfigureAwait(false);
                                try
                                {
                                    await objSkill.SetTypeAsync(xmlSkill.Attributes?["category"]?.InnerTextViaPool(token), token).ConfigureAwait(false);
                                    await SkillsSection.KnowledgeSkills.AddAsync(objSkill, token).ConfigureAwait(false);
                                }
                                catch
                                {
                                    await objSkill.RemoveAsync(CancellationToken.None).ConfigureAwait(false);
                                    throw;
                                }
                            }
                        }

                        try
                        {
                            token.ThrowIfCancellationRequested();
                            await ImprovementManager.CreateImprovementAsync(this, strName,
                                    Improvement.ImprovementSource.Metatype, string.Empty,
                                    Improvement.ImprovementType.SkillLevel, string.Empty,
                                    await CommonFunctions.ExpressionToIntAsync(
                                        strRating, intForce, 0, 0, token).ConfigureAwait(false), token: token)
                                .ConfigureAwait(false);
                        }
                        catch
                        {
                            await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }

                        await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);
                    }
                }

                // Add any Complex Forms the Critter comes with (typically Sprites)
                XmlDocument xmlComplexFormDocument =
                    await LoadDataAsync("complexforms.xml", token: token).ConfigureAwait(false);
                foreach (XmlNode xmlComplexForm in charNode.SelectNodes("complexforms/complexform"))
                {
                    XmlNode xmlComplexFormData =
                        xmlComplexFormDocument.TryGetNodeByNameOrId("/chummer/complexforms/complexform",
                            xmlComplexForm.InnerTextViaPool(token));
                    if (xmlComplexFormData == null)
                        continue;

                    ComplexForm objComplexForm = new ComplexForm(this);
                    try
                    {
                        await objComplexForm.CreateAsync(xmlComplexFormData, token: token).ConfigureAwait(false);
                        if (objComplexForm.InternalId.IsEmptyGuid())
                        {
                            await objComplexForm.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                            continue;
                        }
                        objComplexForm.Grade = -1;

                        await ComplexForms.AddAsync(objComplexForm, token).ConfigureAwait(false);
                    }
                    catch
                    {
                        await objComplexForm.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                        throw;
                    }

                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await ImprovementManager.CreateImprovementAsync(this, objComplexForm.InternalId,
                            Improvement.ImprovementSource.Metatype, string.Empty,
                            Improvement.ImprovementType.ComplexForm,
                            string.Empty, token: token).ConfigureAwait(false);
                    }
                    catch
                    {
                        await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                        throw;
                    }

                    await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);
                }

                //Load any cyberware the character has.
                XmlDocument xmlCyberwareDocument =
                    await LoadDataAsync("cyberware.xml", token: token).ConfigureAwait(false);
                foreach (XmlNode node in charNode.SelectNodes("cyberwares/cyberware"))
                {
                    XmlNode objXmlCyberwareNode =
                        xmlCyberwareDocument.TryGetNodeByNameOrId("chummer/cyberwares/cyberware", node.InnerTextViaPool(token));
                    if (objXmlCyberwareNode == null)
                        continue;
                    string strForcedValue = node.Attributes["select"]?.InnerTextViaPool(token) ?? string.Empty;
                    int intRating =
                        await CommonFunctions
                            .ExpressionToIntAsync(node.Attributes["rating"]?.InnerTextViaPool(token), intForce, 0, 0, token)
                            .ConfigureAwait(false);
                    Cyberware objWare = new Cyberware(this);
                    try
                    {
                        await objWare.CreateAsync(objXmlCyberwareNode,
                                await GetGradeByNameAsync(Improvement.ImprovementSource.Cyberware, "None", true, token).ConfigureAwait(false),
                                Improvement.ImprovementSource.Metatype,
                                intRating,
                                await GetWeaponsAsync(token).ConfigureAwait(false),
                                await GetVehiclesAsync(token).ConfigureAwait(false), true, true, strForcedValue,
                                token: token)
                            .ConfigureAwait(false);
                        await Cyberware.AddAsync(objWare, token).ConfigureAwait(false);
                        try
                        {
                            token.ThrowIfCancellationRequested();
                            await ImprovementManager.CreateImprovementAsync(this, objWare.InternalId,
                                Improvement.ImprovementSource.Metatype,
                                string.Empty, Improvement.ImprovementType.FreeWare,
                                string.Empty, token: token).ConfigureAwait(false);
                        }
                        catch
                        {
                            await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }

                        await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);
                    }
                    catch
                    {
                        await objWare.DeleteCyberwareAsync(token: CancellationToken.None).ConfigureAwait(false);
                        throw;
                    }
                }

                //Load any bioware the character has.
                XmlDocument xmlBiowareDocument = await LoadDataAsync("bioware.xml", token: token).ConfigureAwait(false);
                foreach (XmlNode node in charNode.SelectNodes("biowares/bioware"))
                {
                    XmlNode objXmlCyberwareNode =
                        xmlBiowareDocument.TryGetNodeByNameOrId("chummer/biowares/bioware", node.InnerTextViaPool(token));
                    if (objXmlCyberwareNode == null)
                        continue;
                    string strForcedValue = node.Attributes["select"]?.InnerTextViaPool(token) ?? string.Empty;
                    int intRating =
                        await CommonFunctions
                            .ExpressionToIntAsync(node.Attributes["rating"]?.InnerTextViaPool(token), intForce, 0, 0, token)
                            .ConfigureAwait(false);
                    Cyberware objWare = new Cyberware(this);
                    try
                    {
                        await objWare.CreateAsync(objXmlCyberwareNode,
                                await GetGradeByNameAsync(Improvement.ImprovementSource.Bioware, "None", true, token).ConfigureAwait(false),
                                Improvement.ImprovementSource.Metatype,
                                intRating,
                                await GetWeaponsAsync(token).ConfigureAwait(false),
                                await GetVehiclesAsync(token).ConfigureAwait(false), true, true, strForcedValue,
                                token: token)
                            .ConfigureAwait(false);
                        await Cyberware.AddAsync(objWare, token).ConfigureAwait(false);
                        try
                        {
                            token.ThrowIfCancellationRequested();
                            await ImprovementManager.CreateImprovementAsync(this, objWare.InternalId,
                                Improvement.ImprovementSource.Metatype,
                                string.Empty, Improvement.ImprovementType.FreeWare,
                                string.Empty, token: token).ConfigureAwait(false);
                        }
                        catch
                        {
                            await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }

                        await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);
                    }
                    catch
                    {
                        await objWare.DeleteCyberwareAsync(token: CancellationToken.None).ConfigureAwait(false);
                        throw;
                    }
                }

                // Add any Advanced Programs the Critter comes with (typically A.I.s)
                XmlDocument xmlAIProgramDocument =
                    await LoadDataAsync("programs.xml", token: token).ConfigureAwait(false);
                foreach (XmlNode xmlAIProgram in charNode.SelectNodes("programs/program"))
                {
                    XmlNode xmlAIProgramData =
                        xmlAIProgramDocument.TryGetNodeByNameOrId("chummer/programs/program", xmlAIProgram.InnerTextViaPool(token));
                    if (xmlAIProgramData == null)
                        continue;

                    // Check for SelectText.
                    string strExtra = xmlAIProgram.Attributes?["select"]?.InnerTextViaPool(token) ?? string.Empty;
                    if (xmlAIProgramData.SelectSingleNodeAndCacheExpressionAsNavigator("bonus/selecttext", token) !=
                        null && !string.IsNullOrWhiteSpace(strExtra))
                    {
                        string strDescription = string.Format(GlobalSettings.CultureInfo,
                            await LanguageManager.GetStringAsync("String_Improvement_SelectText", token: token)
                                .ConfigureAwait(false),
                            xmlAIProgramData["translate"]?.InnerTextViaPool(token) ??
                            xmlAIProgramData["name"]?.InnerTextViaPool(token));
                        using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(() =>
                                   new SelectText
                                   {
                                       Description = strDescription
                                   }, token).ConfigureAwait(false))
                        {
                            // Make sure the dialogue window was not canceled.
                            if (await frmPickText.ShowDialogSafeAsync(this, token).ConfigureAwait(false) ==
                                DialogResult.Cancel)
                                continue;
                            strExtra = frmPickText.MyForm.SelectedValue;
                        }
                    }

                    AIProgram objAIProgram = new AIProgram(this);
                    await objAIProgram.CreateAsync(xmlAIProgram, strExtra, false, token).ConfigureAwait(false);
                    if (objAIProgram.InternalId.IsEmptyGuid())
                        continue;

                    await AIPrograms.AddAsync(objAIProgram, token).ConfigureAwait(false);

                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await ImprovementManager.CreateImprovementAsync(this, objAIProgram.InternalId,
                            Improvement.ImprovementSource.Metatype, string.Empty,
                            Improvement.ImprovementType.AIProgram,
                            string.Empty, token: token).ConfigureAwait(false);
                    }
                    catch
                    {
                        await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                        throw;
                    }

                    await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);
                }

                // Add any Gear the Critter comes with (typically Programs for A.I.s)
                XmlDocument xmlGearDocument = await LoadDataAsync("gear.xml", token: token).ConfigureAwait(false);
                foreach (XmlNode xmlGear in charNode.SelectNodes("gears/gear"))
                {
                    XmlNode xmlGearData = xmlGearDocument.TryGetNodeByNameOrId(
                        "/chummer/gears/gear", xmlGear["name"].InnerTextViaPool(token),
                        "category = " + xmlGear["category"].InnerTextViaPool(token).CleanXPath());
                    if (xmlGearData == null)
                        continue;

                    int intRating = 1;
                    if (xmlGear["rating"] != null)
                        intRating = await CommonFunctions
                            .ExpressionToIntAsync(xmlGear["rating"].InnerTextViaPool(token), intForce, 0, 0, token)
                            .ConfigureAwait(false);
                    decimal decQty = 1.0m;
                    if (xmlGear["quantity"] != null)
                        decQty = await CommonFunctions.ExpressionToDecimalAsync(xmlGear["quantity"].InnerTextViaPool(token), intForce,
                            token: token).ConfigureAwait(false);
                    string strForceValue = xmlGear.Attributes?["select"]?.InnerTextViaPool(token) ?? string.Empty;

                    Gear objGear = new Gear(this);
                    try
                    {
                        await objGear.CreateAsync(xmlGearData, intRating, lstWeapons, strForceValue, token: token).ConfigureAwait(false);

                        if (objGear.InternalId.IsEmptyGuid())
                        {
                            await objGear.DeleteGearAsync(token: CancellationToken.None).ConfigureAwait(false);
                            continue;
                        }

                        await objGear.SetQuantityAsync(decQty, token).ConfigureAwait(false);

                        // If a Commlink has just been added, see if the character already has one. If not, make it the active Commlink.
                        if (await GetActiveCommlinkAsync(token).ConfigureAwait(false) == null &&
                            await objGear.GetIsCommlinkAsync(token).ConfigureAwait(false))
                        {
                            await objGear.SetActiveCommlinkAsync(this, true, token).ConfigureAwait(false);
                        }

                        objGear.Cost = "0";
                        objGear.ParentID = Guid.NewGuid().ToString();

                        await Gear.AddAsync(objGear, token).ConfigureAwait(false);

                        try
                        {
                            token.ThrowIfCancellationRequested();
                            await ImprovementManager.CreateImprovementAsync(this, objGear.InternalId,
                                Improvement.ImprovementSource.Metatype,
                                string.Empty, Improvement.ImprovementType.Gear,
                                string.Empty, token: token).ConfigureAwait(false);
                        }
                        catch
                        {
                            await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }

                        await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);
                    }
                    catch
                    {
                        await objGear.DeleteGearAsync(token: CancellationToken.None).ConfigureAwait(false);
                        throw;
                    }
                }

                // Add any created Weapons to the character.
                foreach (Weapon objWeapon in lstWeapons)
                    await Weapons.AddAsync(objWeapon, token).ConfigureAwait(false);

                // Sprites can never have Physical Attributes
                if (await GetDEPEnabledAsync(token).ConfigureAwait(false)
                    || strSelectedMetatypeCategory?.EndsWith("Sprite", StringComparison.Ordinal) == true
                    || strSelectedMetatypeCategory?.EndsWith("Sprites", StringComparison.Ordinal) == true)
                {
                    await (await GetAttributeAsync("BOD", true, token).ConfigureAwait(false))
                        .AssignBaseKarmaLimitsAsync(0, 0, 0, 0, 0, token).ConfigureAwait(false);
                    await (await GetAttributeAsync("AGI", true, token).ConfigureAwait(false))
                        .AssignBaseKarmaLimitsAsync(0, 0, 0, 0, 0, token).ConfigureAwait(false);
                    await (await GetAttributeAsync("REA", true, token).ConfigureAwait(false))
                        .AssignBaseKarmaLimitsAsync(0, 0, 0, 0, 0, token).ConfigureAwait(false);
                    await (await GetAttributeAsync("STR", true, token).ConfigureAwait(false))
                        .AssignBaseKarmaLimitsAsync(0, 0, 0, 0, 0, token).ConfigureAwait(false);
                    await (await GetAttributeAsync("MAG", true, token).ConfigureAwait(false))
                        .AssignBaseKarmaLimitsAsync(0, 0, 0, 0, 0, token).ConfigureAwait(false);
                    await (await GetAttributeAsync("MAGAdept", true, token).ConfigureAwait(false))
                        .AssignBaseKarmaLimitsAsync(0, 0, 0, 0, 0, token).ConfigureAwait(false);
                }

                if (strSelectedMetatypeCategory == "Spirits")
                {
                    XmlElement xmlOptionalPowersNode = charNode["optionalpowers"];
                    if (xmlOptionalPowersNode != null && intForce >= 3)
                    {
                        using (new FetchSafelyFromSafeObjectPool<XmlDocument>(Utils.XmlDocumentPool, out XmlDocument objDummyDocument))
                        {
                            //For every 3 full points of Force a spirit has, it may gain one Optional Power.
                            for (int i = intForce; i >= 3; i -= 3)
                            {
                                XmlNode bonusNode = objDummyDocument.CreateNode(XmlNodeType.Element, "bonus", null);
                                XmlNode powerNode =
                                    objDummyDocument.ImportNode(xmlOptionalPowersNode.CloneNode(true), true);
                                bonusNode.AppendChild(powerNode);
                                objDummyDocument.AppendChild(bonusNode);
                            }

                            foreach (XmlNode bonusNode in objDummyDocument.SelectNodes("/bonus"))
                                await ImprovementManager.CreateImprovementsAsync(this,
                                    Improvement.ImprovementSource.Metatype,
                                    strMetatypeId, bonusNode, 1, strMetatypeId, token: token).ConfigureAwait(false);
                        }
                    }

                    // Remove the Critter's Materialization Power if they have it. Add the Possession or Inhabitation Power if the Possession-based Tradition checkbox is checked.
                    if (xmlCritterPowerDocumentPowersNode != null)
                    {
                        if (!string.IsNullOrEmpty(strSelectedPossessionMethod))
                        {
                            CritterPower objMaterializationPower =
                                await CritterPowers.FirstOrDefaultAsync(x => x.Name == "Materialization", token: token)
                                    .ConfigureAwait(false);
                            if (objMaterializationPower != null)
                                await CritterPowers.RemoveAsync(objMaterializationPower, token).ConfigureAwait(false);

                            if (await CritterPowers.AllAsync(x => !x.Name.Contains(strSelectedPossessionMethod), token)
                                    .ConfigureAwait(false))
                            {
                                // Add the selected Power.
                                XmlNode objXmlCritterPower =
                                    xmlCritterPowerDocumentPowersNode.TryGetNodeByNameOrId("power",
                                        strSelectedPossessionMethod);
                                if (objXmlCritterPower != null)
                                {
                                    CritterPower objPower = new CritterPower(this);
                                    await objPower.CreateAsync(objXmlCritterPower, 0, string.Empty, token).ConfigureAwait(false);
                                    objPower.CountTowardsLimit = false;
                                    await CritterPowers.AddAsync(objPower, token).ConfigureAwait(false);

                                    try
                                    {
                                        token.ThrowIfCancellationRequested();
                                        await ImprovementManager.CreateImprovementAsync(this, objPower.InternalId,
                                            Improvement.ImprovementSource.Metatype,
                                            string.Empty,
                                            Improvement.ImprovementType.CritterPower,
                                            string.Empty, token: token).ConfigureAwait(false);
                                    }
                                    catch
                                    {
                                        await ImprovementManager.RollbackAsync(this, CancellationToken.None)
                                            .ConfigureAwait(false);
                                        throw;
                                    }

                                    await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);
                                }
                            }
                        }
                        else if (await CritterPowers.AllAsync(x =>
                                     x.Name != "Materialization" && !x.Name.Contains("Possession") &&
                                     !x.Name.Contains("Inhabitation"), token).ConfigureAwait(false))
                        {
                            // Add the Materialization Power.
                            XmlNode objXmlCritterPower =
                                xmlCritterPowerDocumentPowersNode.SelectSingleNode("power[name = \"Materialization\"]");
                            if (objXmlCritterPower != null)
                            {
                                CritterPower objPower = new CritterPower(this);
                                await objPower.CreateAsync(objXmlCritterPower, 0, string.Empty, token).ConfigureAwait(false);
                                objPower.CountTowardsLimit = false;
                                await CritterPowers.AddAsync(objPower, token).ConfigureAwait(false);

                                try
                                {
                                    token.ThrowIfCancellationRequested();
                                    await ImprovementManager.CreateImprovementAsync(this, objPower.InternalId,
                                        Improvement.ImprovementSource.Metatype,
                                        string.Empty,
                                        Improvement.ImprovementType.CritterPower,
                                        string.Empty, token: token).ConfigureAwait(false);
                                }
                                catch
                                {
                                    await ImprovementManager.RollbackAsync(this, CancellationToken.None)
                                        .ConfigureAwait(false);
                                    throw;
                                }

                                await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);
                            }
                        }
                    }
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Save the Character to an XML file. Returns true if successful.
        /// </summary>
        public bool Save(string strFileName = "", bool addToMRU = true, bool callOnSaveCallBack = true, LzmaHelper.ChummerCompressionPreset eOverrideCompressionLevel = LzmaHelper.ChummerCompressionPreset.None, CancellationToken token = default)
        {
            return Utils.SafelyRunSynchronously(() => SaveCoreAsync(true, strFileName, addToMRU, callOnSaveCallBack, eOverrideCompressionLevel, token), token);
        }

        /// <summary>
        /// Save the Character to an XML file. Returns true if successful.
        /// </summary>
        public Task<bool> SaveAsync(string strFileName = "", bool addToMRU = true, bool callOnSaveCallBack = true, LzmaHelper.ChummerCompressionPreset eOverrideCompressionLevel = LzmaHelper.ChummerCompressionPreset.None, CancellationToken token = default)
        {
            return SaveCoreAsync(false, strFileName, addToMRU, callOnSaveCallBack, eOverrideCompressionLevel, token);
        }

        /// <summary>
        /// Save the Character to an XML file. Returns true if successful.
        /// </summary>
        private async Task<bool> SaveCoreAsync(bool blnSync, string strFileName, bool addToMRU, bool callOnSaveCallBack, LzmaHelper.ChummerCompressionPreset eOverrideCompressionLevel = LzmaHelper.ChummerCompressionPreset.None,
                                               CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();

            if (string.IsNullOrWhiteSpace(strFileName))
            {
                strFileName = FileName;
                if (string.IsNullOrWhiteSpace(strFileName))
                {
                    return false;
                }
            }
            else if (!strFileName.EndsWith(".chum5", StringComparison.OrdinalIgnoreCase)
                     && !strFileName.EndsWith(".chum5lz", StringComparison.OrdinalIgnoreCase))
            {
                strFileName = Path.GetFileNameWithoutExtension(strFileName) + ".chum5";
                string strExistingFileName = FileName;
                token.ThrowIfCancellationRequested();
                if (!string.IsNullOrEmpty(strExistingFileName)
                    && strExistingFileName.EndsWith(".chum5lz", StringComparison.OrdinalIgnoreCase))
                    strFileName += "lz";
            }

            bool blnErrorFree = true;
            token.ThrowIfCancellationRequested();
            using (RecyclableMemoryStream objStream = new RecyclableMemoryStream(Utils.MemoryStreamManager))
            {
                token.ThrowIfCancellationRequested();
                using (XmlWriter objWriter = Utils.GetStandardXmlWriter(objStream))
                {
                    IDisposable objLocker = null;
                    IAsyncDisposable objLockerAsync = null;
                    if (blnSync)
                        // ReSharper disable once MethodHasAsyncOverload
                        objLocker = LockObject.EnterReadLock(token);
                    else
                        objLockerAsync = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        if (blnSync)
                            DoSave();
                        else
                            await DoSaveAsync().ConfigureAwait(false);

                        void DoSave()
                        {
                            // ReSharper disable AccessToDisposedClosure
                            objWriter.WriteStartDocument();

                            // <character>
                            objWriter.WriteStartElement("character");

                            // <createdversion />
                            objWriter.WriteElementString("createdversion", _strVersionCreated);
                            // <minimumappversion />
                            objWriter.WriteElementString("minimumappversion", "5.214.1");
                            // <appversion />
                            objWriter.WriteElementString("appversion",
                                Utils.CurrentChummerVersion.ToString(3));
                            // <gameedition />
                            objWriter.WriteElementString("gameedition", "SR5");

                            // <settings />
                            objWriter.WriteElementString("settings", _strSettingsKey);
                            // <settingshashcode />
                            objWriter.WriteElementString("settingshashcode",
                                Settings.GetEquatableHashCode(token)
                                    .ToString(GlobalSettings.InvariantCultureInfo));
                            // <buildmethod />
                            objWriter.WriteElementString("buildmethod", Settings.BuildMethod.ToString());

                            // <sources>
                            objWriter.WriteStartElement("sources");
                            foreach (string strBook in Settings.Books)
                            {
                                objWriter.WriteElementString("source", strBook);
                            }

                            // </sources>
                            objWriter.WriteEndElement();

                            if (Settings.EnabledCustomDataDirectoryInfos.Count > 0)
                            {
                                // <customdatadirectorynames>
                                objWriter.WriteStartElement("customdatadirectorynames");
                                foreach (string strDirectoryName in Settings.EnabledCustomDataDirectoryInfos.Select(x =>
                                             x.Name))
                                {
                                    objWriter.WriteElementString("directoryname", strDirectoryName);
                                }

                                // </customdatadirectorynames>
                                objWriter.WriteEndElement();
                            }

                            // <metatype />
                            objWriter.WriteElementString("metatype", _strMetatype);
                            // <metatypeid />
                            objWriter.WriteElementString("metatypeid",
                                _guiMetatype.ToString(
                                    "D", GlobalSettings.InvariantCultureInfo));
                            // <metatypebp />
                            objWriter.WriteElementString("metatypebp",
                                _intMetatypeBP.ToString(GlobalSettings.InvariantCultureInfo));
                            // <metavariant />
                            objWriter.WriteElementString("metavariant", _strMetavariant);
                            // <metavariantid />
                            objWriter.WriteElementString("metavariantid",
                                _guiMetavariant.ToString(
                                    "D", GlobalSettings.InvariantCultureInfo));
                            // <metatypecategory />
                            objWriter.WriteElementString("metatypecategory", _strMetatypeCategory);
                            // <movement />
                            objWriter.WriteElementString("movement", _strMovement);
                            // <walk />
                            objWriter.WriteElementString("walk", _strWalk);
                            // <run />
                            objWriter.WriteElementString("run", _strRun);
                            // <sprint />
                            objWriter.WriteElementString("sprint", _strSprint);
                            // <walk />
                            objWriter.WriteElementString("walkalt", _strWalk);
                            // <run />
                            objWriter.WriteElementString("runalt", _strRun);
                            // <sprint />
                            objWriter.WriteElementString("sprintalt", _strSprint);
                            // <initiativedice />
                            objWriter.WriteElementString("initiativedice",
                                _intInitiativeDice.ToString(
                                    GlobalSettings.InvariantCultureInfo));

                            // <prioritymetatype />
                            objWriter.WriteElementString("prioritymetatype", _strPriorityMetatype);
                            // <priorityattributes />
                            objWriter.WriteElementString("priorityattributes", _strPriorityAttributes);
                            // <priorityspecial />
                            objWriter.WriteElementString("priorityspecial", _strPrioritySpecial);
                            // <priorityskills />
                            objWriter.WriteElementString("priorityskills", _strPrioritySkills);
                            // <priorityresources />
                            objWriter.WriteElementString("priorityresources", _strPriorityResources);
                            // <priorityresources />
                            objWriter.WriteElementString("prioritytalent", _strPriorityTalent);
                            // <priorityskills >
                            objWriter.WriteStartElement("priorityskills");
                            foreach (string strSkill in _lstPrioritySkills)
                            {
                                objWriter.WriteElementString("priorityskill", strSkill);
                            }

                            // </priorityskills>
                            objWriter.WriteEndElement();

                            // <essenceatspecialstart />
                            objWriter.WriteElementString("essenceatspecialstart",
                                _decEssenceAtSpecialStart.ToString(
                                    GlobalSettings.InvariantCultureInfo));

                            // <name />
                            objWriter.WriteElementString("name", _strName);
                            SaveMugshots(objWriter, token);

                            // <gender />
                            objWriter.WriteElementString("gender", _strGender);
                            // <age />
                            objWriter.WriteElementString("age", _strAge);
                            // <eyes />
                            objWriter.WriteElementString("eyes", _strEyes);
                            // <height />
                            objWriter.WriteElementString("height", _strHeight);
                            // <weight />
                            objWriter.WriteElementString("weight", _strWeight);
                            // <skin />
                            objWriter.WriteElementString("skin", _strSkin);
                            // <hair />
                            objWriter.WriteElementString("hair", _strHair);
                            // <description />
                            objWriter.WriteElementString("description", _strDescription.CleanOfXmlInvalidUnicodeChars());
                            // <background />
                            objWriter.WriteElementString("background", _strBackground.CleanOfXmlInvalidUnicodeChars());
                            // <concept />
                            objWriter.WriteElementString("concept", _strConcept.CleanOfXmlInvalidUnicodeChars());
                            // <notes />
                            objWriter.WriteElementString("notes", _strNotes.CleanOfXmlInvalidUnicodeChars());
                            // <alias />
                            objWriter.WriteElementString("alias", _strAlias);
                            // <playername />
                            objWriter.WriteElementString("playername", _strPlayerName);
                            // <gamenotes />
                            objWriter.WriteElementString("gamenotes", _strGameNotes.CleanOfXmlInvalidUnicodeChars());
                            // <primaryarm />
                            objWriter.WriteElementString("primaryarm", _strPrimaryArm);

                            // <ignorerules />
                            if (_blnIgnoreRules)
                                objWriter.WriteElementString("ignorerules",
                                    _blnIgnoreRules.ToString(
                                        GlobalSettings.InvariantCultureInfo));
                            // <iscritter />
                            if (_blnIsCritter)
                                objWriter.WriteElementString("iscritter",
                                    _blnIsCritter.ToString(
                                        GlobalSettings.InvariantCultureInfo));
                            if (_blnPossessed)
                                objWriter.WriteElementString("possessed",
                                    _blnPossessed.ToString(
                                        GlobalSettings.InvariantCultureInfo));
                            // <karma />
                            objWriter.WriteElementString(
                                "karma", _intKarma.ToString(GlobalSettings.InvariantCultureInfo));
                            // <special />
                            objWriter.WriteElementString("special",
                                _intSpecial.ToString(GlobalSettings.InvariantCultureInfo));
                            // <totalspecial />
                            objWriter.WriteElementString("totalspecial",
                                _intTotalSpecial.ToString(
                                    GlobalSettings.InvariantCultureInfo));
                            // <totalattributes />
                            objWriter.WriteElementString("totalattributes",
                                _intTotalAttributes.ToString(
                                    GlobalSettings.InvariantCultureInfo));
                            // <edgeused />
                            objWriter.WriteElementString("edgeused",
                                _intEdgeUsed.ToString(GlobalSettings.InvariantCultureInfo));
                            // <contactpoints />
                            objWriter.WriteElementString("contactpoints",
                                ContactPoints.ToString(
                                    GlobalSettings.InvariantCultureInfo));
                            // <spelllimit />
                            objWriter.WriteElementString("spelllimit",
                                _intFreeSpells.ToString(GlobalSettings.InvariantCultureInfo));
                            // <cfplimit />
                            objWriter.WriteElementString("cfplimit",
                                _intCFPLimit.ToString(GlobalSettings.InvariantCultureInfo));
                            // <totalaiprogramlimit />
                            objWriter.WriteElementString("ainormalprogramlimit",
                                _intAINormalProgramLimit.ToString(
                                    GlobalSettings.InvariantCultureInfo));
                            // <aiadvancedprogramlimit />
                            objWriter.WriteElementString("aiadvancedprogramlimit",
                                _intAIAdvancedProgramLimit.ToString(
                                    GlobalSettings.InvariantCultureInfo));
                            // <currentcounterspellingdice />
                            objWriter.WriteElementString("currentcounterspellingdice",
                                _intCurrentCounterspellingDice.ToString(
                                    GlobalSettings.InvariantCultureInfo));
                            // <currentliftcarryhits />
                            objWriter.WriteElementString("currentliftcarryhits",
                                _intCurrentLiftCarryHits.ToString(
                                    GlobalSettings.InvariantCultureInfo));
                            // <carrylimit />
                            objWriter.WriteElementString("basecarrylimit",
                                BaseCarryLimit.ToString(
                                    GlobalSettings.InvariantCultureInfo));
                            // <liftlimit />
                            objWriter.WriteElementString("baseliftlimit",
                                BaseLiftLimit.ToString(
                                    GlobalSettings.InvariantCultureInfo));
                            // <totalcarriedweight />
                            objWriter.WriteElementString("totalcarriedweight",
                                TotalCarriedWeight.ToString(
                                    GlobalSettings.InvariantCultureInfo));
                            // <encumbranceinterval />
                            objWriter.WriteElementString("encumbranceinterval",
                                EncumbranceInterval.ToString(
                                    GlobalSettings.InvariantCultureInfo));
                            // <streetcred />
                            objWriter.WriteElementString("streetcred",
                                _intStreetCred.ToString(GlobalSettings.InvariantCultureInfo));
                            // <notoriety />
                            objWriter.WriteElementString("notoriety",
                                _intNotoriety.ToString(GlobalSettings.InvariantCultureInfo));
                            // <publicaware />
                            objWriter.WriteElementString("publicawareness",
                                _intPublicAwareness.ToString(
                                    GlobalSettings.InvariantCultureInfo));
                            // <burntstreetcred />
                            objWriter.WriteElementString("burntstreetcred",
                                _intBurntStreetCred.ToString(
                                    GlobalSettings.InvariantCultureInfo));
                            // <baseastralreputation />
                            objWriter.WriteElementString("baseastralreputation",
                                _intBaseAstralReputation.ToString(
                                    GlobalSettings.InvariantCultureInfo));
                            // <basewildreputation />
                            objWriter.WriteElementString("basewildreputation",
                                _intBaseWildReputation.ToString(
                                    GlobalSettings.InvariantCultureInfo));
                            // <created />
                            objWriter.WriteElementString("created",
                                _blnCreated.ToString(GlobalSettings.InvariantCultureInfo));
                            // <nuyen />
                            objWriter.WriteElementString(
                                "nuyen", _decNuyen.ToString(GlobalSettings.InvariantCultureInfo));
                            // <startingnuyen />
                            objWriter.WriteElementString("startingnuyen",
                                _decStartingNuyen.ToString(
                                    GlobalSettings.InvariantCultureInfo));

                            // <nuyenbp />
                            objWriter.WriteElementString("nuyenbp",
                                _decNuyenBP.ToString(GlobalSettings.InvariantCultureInfo));

                            // <adept />
                            objWriter.WriteElementString("adept",
                                _blnAdeptEnabled.ToString(
                                    GlobalSettings.InvariantCultureInfo));
                            // <magician />
                            objWriter.WriteElementString("magician",
                                _blnMagicianEnabled.ToString(
                                    GlobalSettings.InvariantCultureInfo));
                            // <technomancer />
                            objWriter.WriteElementString("technomancer",
                                _blnTechnomancerEnabled.ToString(
                                    GlobalSettings.InvariantCultureInfo));
                            // <ai />
                            objWriter.WriteElementString("ai",
                                _blnAdvancedProgramsEnabled.ToString(
                                    GlobalSettings.InvariantCultureInfo));
                            // <cyberwaredisabled />
                            objWriter.WriteElementString("cyberwaredisabled",
                                _blnCyberwareDisabled.ToString(
                                    GlobalSettings.InvariantCultureInfo));
                            // <initiationdisabled />
                            objWriter.WriteElementString("initiationdisabled",
                                _blnInitiationDisabled.ToString(
                                    GlobalSettings.InvariantCultureInfo));
                            // <critter />
                            objWriter.WriteElementString("critter",
                                _blnCritterEnabled.ToString(
                                    GlobalSettings.InvariantCultureInfo));

                            // <prototypetranshuman />
                            objWriter.WriteElementString("prototypetranshuman",
                                _decPrototypeTranshuman.ToString(
                                    GlobalSettings.InvariantCultureInfo));

                            // <attributes>
                            objWriter.WriteStartElement("attributes");
                            AttributeSection.Save(objWriter, token);
                            // </attributes>
                            objWriter.WriteEndElement();

                            // <magenabled />
                            objWriter.WriteElementString("magenabled",
                                _blnMAGEnabled.ToString(GlobalSettings.InvariantCultureInfo));
                            // <initiategrade />
                            objWriter.WriteElementString("initiategrade",
                                _intInitiateGrade.ToString(
                                    GlobalSettings.InvariantCultureInfo));
                            // <resenabled />
                            objWriter.WriteElementString("resenabled",
                                _blnRESEnabled.ToString(GlobalSettings.InvariantCultureInfo));
                            // <submersiongrade />
                            objWriter.WriteElementString("submersiongrade",
                                _intSubmersionGrade.ToString(
                                    GlobalSettings.InvariantCultureInfo));
                            // <depenabled />
                            objWriter.WriteElementString("depenabled",
                                _blnDEPEnabled.ToString(GlobalSettings.InvariantCultureInfo));
                            // <groupmember />
                            objWriter.WriteElementString("groupmember",
                                _blnGroupMember.ToString(GlobalSettings.InvariantCultureInfo));
                            // <groupname />
                            objWriter.WriteElementString("groupname", _strGroupName);
                            // <groupnotes />
                            objWriter.WriteElementString("groupnotes", _strGroupNotes);

                            // External reader friendly stuff.
                            objWriter.WriteElementString("totaless",
                                Essence(token: token)
                                    .ToString(GlobalSettings.InvariantCultureInfo));

                            // Write out the Mystic Adept MAG split info.
                            if (_blnAdeptEnabled && _blnMagicianEnabled)
                            {
                                objWriter.WriteElementString("magsplitadept",
                                    _intMAGAdept.ToString(
                                        GlobalSettings.InvariantCultureInfo));
                                objWriter.WriteElementString("magsplitmagician",
                                    _intMAGMagician.ToString(
                                        GlobalSettings.InvariantCultureInfo));
                            }

                            _objTradition?.Save(objWriter);

                            // Condition Monitor Progress.
                            // <physicalcmfilled />
                            objWriter.WriteElementString("physicalcmfilled",
                                _intPhysicalCMFilled.ToString(
                                    GlobalSettings.InvariantCultureInfo));
                            // <stuncmfilled />
                            objWriter.WriteElementString("stuncmfilled",
                                _intStunCMFilled.ToString(
                                    GlobalSettings.InvariantCultureInfo));

                            //<psyche />
                            objWriter.WriteElementString("psyche",
                                _blnPsycheActive.ToString(
                                    GlobalSettings.InvariantCultureInfo));

                            ///////////////////////////////////////////SKILLS

                            SkillsSection.Save(objWriter);

                            //Write copy of old skill groups, to not totally fuck a file if error
                            _oldSkillGroupBackup?.WriteTo(objWriter);
                            _oldSkillsBackup?.WriteTo(objWriter);

                            ///////////////////////////////////////////SKILLS

                            // <contacts>
                            objWriter.WriteStartElement("contacts");
                            _lstContacts.ForEach(x => x.Save(objWriter, token), token);
                            objWriter.WriteEndElement();

                            // <spells>
                            objWriter.WriteStartElement("spells");
                            _lstSpells.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <foci>
                            objWriter.WriteStartElement("foci");
                            _lstFoci.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <stackedfoci>
                            objWriter.WriteStartElement("stackedfoci");
                            _lstStackedFoci.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <powers>
                            objWriter.WriteStartElement("powers");
                            _lstPowers.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <spirits>
                            objWriter.WriteStartElement("spirits");
                            _lstSpirits.ForEach(x => x.Save(objWriter, token), token);
                            objWriter.WriteEndElement();

                            // <complexforms>
                            objWriter.WriteStartElement("complexforms");
                            _lstComplexForms.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <aiprograms>
                            objWriter.WriteStartElement("aiprograms");
                            _lstAIPrograms.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <martialarts>
                            objWriter.WriteStartElement("martialarts");
                            _lstMartialArts.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <limitmodifiers>
                            objWriter.WriteStartElement("limitmodifiers");
                            _lstLimitModifiers.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <armors>
                            objWriter.WriteStartElement("armors");
                            _lstArmor.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <weapons>
                            objWriter.WriteStartElement("weapons");
                            _lstWeapons.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <cyberwares>
                            objWriter.WriteStartElement("cyberwares");
                            _lstCyberware.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <qualities>
                            objWriter.WriteStartElement("qualities");
                            _lstQualities.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <lifestyles>
                            objWriter.WriteStartElement("lifestyles");
                            _lstLifestyles.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <gears>
                            objWriter.WriteStartElement("gears");
                            _lstGear.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <vehicles>
                            objWriter.WriteStartElement("vehicles");
                            _lstVehicles.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <metamagics>
                            objWriter.WriteStartElement("metamagics");
                            _lstMetamagics.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <arts>
                            objWriter.WriteStartElement("arts");
                            _lstArts.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <enhancements>
                            objWriter.WriteStartElement("enhancements");
                            _lstEnhancements.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <critterpowers>
                            objWriter.WriteStartElement("critterpowers");
                            _lstCritterPowers.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <initiationgrades>
                            objWriter.WriteStartElement("initiationgrades");
                            _lstInitiationGrades.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <improvements>
                            objWriter.WriteStartElement("improvements");
                            _lstImprovements.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <sustained>
                            objWriter.WriteStartElement("sustainedobjects");
                            _lstSustainedObjects.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <drugs>
                            objWriter.WriteStartElement("drugs");
                            _lstDrugs.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <mentorspirits>
                            objWriter.WriteStartElement("mentorspirits");
                            _lstMentorSpirits.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <expenses>
                            objWriter.WriteStartElement("expenses");
                            _lstExpenseLog.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <locations>
                            objWriter.WriteStartElement("gearlocations");
                            _lstGearLocations.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <armorlocations>
                            objWriter.WriteStartElement("armorlocations");
                            _lstArmorLocations.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <vehiclelocations>
                            objWriter.WriteStartElement("vehiclelocations");
                            _lstVehicleLocations.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <weaponlocations>
                            objWriter.WriteStartElement("weaponlocations");
                            _lstWeaponLocations.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <improvementgroups>
                            objWriter.WriteStartElement("improvementgroups");
                            _lstImprovementGroups.ForEach(
                                strGroup => objWriter.WriteElementString("improvementgroup", strGroup), token);
                            objWriter.WriteEndElement();

                            // <calendar>
                            objWriter.WriteStartElement("calendar");
                            _lstCalendar.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            //Plugins
                            IReadOnlyList<IPlugin> lstActivePlugins = Program.PluginLoader?.MyActivePlugins;
                            if (lstActivePlugins?.Count > 0)
                            {
                                // <plugins>
                                objWriter.WriteStartElement("plugins");
                                foreach (IPlugin plugin in lstActivePlugins)
                                {
                                    try
                                    {
                                        System.Reflection.AssemblyName objPluginAssemblyName =
                                            plugin.GetPluginAssembly().GetName();
                                        objWriter.WriteStartElement(objPluginAssemblyName.Name);
                                        objWriter.WriteAttributeString(
                                            "version", objPluginAssemblyName.Version.ToString());
                                        objWriter.WriteString(plugin.GetSaveToFileElement(this));
                                        objWriter.WriteEndElement();
                                    }
                                    catch (Exception e)
                                    {
                                        Log.Warn(
                                            e, "Exception while writing saveFileElement for plugin " + plugin + ": ");
                                    }
                                }

                                //</plugins>
                                objWriter.WriteEndElement();
                            }

                            //calculatedValues
                            objWriter.WriteStartElement("calculatedvalues");
                            objWriter.WriteComment(
                                "these values are not loaded and only stored here for third parties, who parse this files (to not have to calculate them themselves)");
                            objWriter.WriteElementString("physicalcm",
                                PhysicalCM.ToString(GlobalSettings.InvariantCultureInfo));
                            objWriter.WriteElementString("physicalcmthresholdoffset",
                                PhysicalCMThresholdOffset.ToString(
                                    GlobalSettings.InvariantCultureInfo));
                            objWriter.WriteElementString("physicalcmoverflow",
                                CMOverflow.ToString(GlobalSettings.InvariantCultureInfo));
                            objWriter.WriteElementString(
                                "stuncm", StunCM.ToString(GlobalSettings.InvariantCultureInfo));
                            objWriter.WriteElementString("stuncmthresholdoffset",
                                StunCMThresholdOffset.ToString(
                                    GlobalSettings.InvariantCultureInfo));
                            objWriter.WriteEndElement();
                            // </calculatedValues>

                            // </character>
                            objWriter.WriteEndElement();

                            objWriter.WriteEndDocument();
                            objWriter.Flush();
                            // ReSharper restore AccessToDisposedClosure
                        }

                        async Task DoSaveAsync()
                        {
                            await objWriter.WriteStartDocumentAsync().ConfigureAwait(false);

                            // <character>
                            await objWriter.WriteStartElementAsync("character", token: token)
                                .ConfigureAwait(false);

                            // <createdversion />
                            await objWriter
                                .WriteElementStringAsync("createdversion", _strVersionCreated, token: token)
                                .ConfigureAwait(false);
                            // <minimumappversion />
                            await objWriter.WriteElementStringAsync("minimumappversion", "5.214.1", token: token)
                                .ConfigureAwait(false);
                            // <appversion />
                            await objWriter.WriteElementStringAsync("appversion",
                                    Utils.CurrentChummerVersion.ToString(3), token: token)
                                .ConfigureAwait(false);
                            // <gameedition />
                            await objWriter.WriteElementStringAsync("gameedition", "SR5", token: token)
                                .ConfigureAwait(false);

                            // <settings />
                            await objWriter.WriteElementStringAsync("settings", _strSettingsKey, token: token)
                                .ConfigureAwait(false);
                            CharacterSettings objSettings
                                = await GetSettingsAsync(token).ConfigureAwait(false);
                            // <settingshashcode />
                            await objWriter
                                .WriteElementStringAsync("settingshashcode",
                                    (await objSettings.GetEquatableHashCodeAsync(token)
                                        .ConfigureAwait(false))
                                    .ToString(GlobalSettings.InvariantCultureInfo),
                                    token: token).ConfigureAwait(false);
                            // <buildmethod />
                            await objWriter
                                .WriteElementStringAsync("buildmethod",
                                    (await objSettings.GetBuildMethodAsync(token).ConfigureAwait(false)).ToString(),
                                    token: token).ConfigureAwait(false);

                            // <sources>
                            await objWriter.WriteStartElementAsync("sources", token: token).ConfigureAwait(false);
                            foreach (string strBook in await objSettings.GetBooksAsync(token).ConfigureAwait(false))
                            {
                                await objWriter.WriteElementStringAsync("source", strBook, token: token)
                                    .ConfigureAwait(false);
                            }

                            // </sources>
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            IReadOnlyList<CustomDataDirectoryInfo> lstInfos = await objSettings
                                .GetEnabledCustomDataDirectoryInfosAsync(token)
                                .ConfigureAwait(false);
                            if (lstInfos.Count > 0)
                            {
                                // <customdatadirectorynames>
                                await objWriter.WriteStartElementAsync("customdatadirectorynames", token: token)
                                    .ConfigureAwait(false);
                                foreach (string strDirectoryName in lstInfos.Select(x => x.Name))
                                {
                                    await objWriter
                                        .WriteElementStringAsync("directoryname", strDirectoryName, token: token)
                                        .ConfigureAwait(false);
                                }

                                // </customdatadirectorynames>
                                await objWriter.WriteEndElementAsync().ConfigureAwait(false);
                            }

                            // <metatype />
                            await objWriter.WriteElementStringAsync("metatype", _strMetatype, token: token)
                                .ConfigureAwait(false);
                            // <metatypeid />
                            await objWriter.WriteElementStringAsync("metatypeid",
                                _guiMetatype.ToString(
                                    "D", GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <metatypebp />
                            await objWriter.WriteElementStringAsync("metatypebp",
                                _intMetatypeBP.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <metavariant />
                            await objWriter.WriteElementStringAsync("metavariant", _strMetavariant, token: token)
                                .ConfigureAwait(false);
                            // <metavariantid />
                            await objWriter.WriteElementStringAsync("metavariantid",
                                _guiMetavariant.ToString(
                                    "D", GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <metatypecategory />
                            await objWriter
                                .WriteElementStringAsync("metatypecategory", _strMetatypeCategory, token: token)
                                .ConfigureAwait(false);
                            // <movement />
                            await objWriter.WriteElementStringAsync("movement", _strMovement, token: token)
                                .ConfigureAwait(false);
                            // <walk />
                            await objWriter.WriteElementStringAsync("walk", _strWalk, token: token)
                                .ConfigureAwait(false);
                            // <run />
                            await objWriter.WriteElementStringAsync("run", _strRun, token: token)
                                .ConfigureAwait(false);
                            // <sprint />
                            await objWriter.WriteElementStringAsync("sprint", _strSprint, token: token)
                                .ConfigureAwait(false);
                            // <walk />
                            await objWriter.WriteElementStringAsync("walkalt", _strWalk, token: token)
                                .ConfigureAwait(false);
                            // <run />
                            await objWriter.WriteElementStringAsync("runalt", _strRun, token: token)
                                .ConfigureAwait(false);
                            // <sprint />
                            await objWriter.WriteElementStringAsync("sprintalt", _strSprint, token: token)
                                .ConfigureAwait(false);
                            // <initiativedice />
                            await objWriter.WriteElementStringAsync("initiativedice",
                                _intInitiativeDice.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);

                            // <prioritymetatype />
                            await objWriter
                                .WriteElementStringAsync("prioritymetatype", _strPriorityMetatype, token: token)
                                .ConfigureAwait(false);
                            // <priorityattributes />
                            await objWriter
                                .WriteElementStringAsync("priorityattributes", _strPriorityAttributes,
                                    token: token).ConfigureAwait(false);
                            // <priorityspecial />
                            await objWriter
                                .WriteElementStringAsync("priorityspecial", _strPrioritySpecial, token: token)
                                .ConfigureAwait(false);
                            // <priorityskills />
                            await objWriter
                                .WriteElementStringAsync("priorityskills", _strPrioritySkills, token: token)
                                .ConfigureAwait(false);
                            // <priorityresources />
                            await objWriter
                                .WriteElementStringAsync("priorityresources", _strPriorityResources,
                                    token: token).ConfigureAwait(false);
                            // <priorityresources />
                            await objWriter
                                .WriteElementStringAsync("prioritytalent", _strPriorityTalent, token: token)
                                .ConfigureAwait(false);
                            // <priorityskills >
                            await objWriter.WriteStartElementAsync("priorityskills", token: token)
                                .ConfigureAwait(false);
                            foreach (string strSkill in _lstPrioritySkills)
                            {
                                await objWriter.WriteElementStringAsync("priorityskill", strSkill, token: token)
                                    .ConfigureAwait(false);
                            }

                            // </priorityskills>
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <essenceatspecialstart />
                            await objWriter.WriteElementStringAsync("essenceatspecialstart",
                                _decEssenceAtSpecialStart.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);

                            // <name />
                            await objWriter.WriteElementStringAsync("name", _strName, token: token)
                                .ConfigureAwait(false);
                            await SaveMugshotsAsync(objWriter, token).ConfigureAwait(false);

                            // <gender />
                            await objWriter.WriteElementStringAsync("gender", _strGender, token: token)
                                .ConfigureAwait(false);
                            // <age />
                            await objWriter.WriteElementStringAsync("age", _strAge, token: token)
                                .ConfigureAwait(false);
                            // <eyes />
                            await objWriter.WriteElementStringAsync("eyes", _strEyes, token: token)
                                .ConfigureAwait(false);
                            // <height />
                            await objWriter.WriteElementStringAsync("height", _strHeight, token: token)
                                .ConfigureAwait(false);
                            // <weight />
                            await objWriter.WriteElementStringAsync("weight", _strWeight, token: token)
                                .ConfigureAwait(false);
                            // <skin />
                            await objWriter.WriteElementStringAsync("skin", _strSkin, token: token)
                                .ConfigureAwait(false);
                            // <hair />
                            await objWriter.WriteElementStringAsync("hair", _strHair, token: token)
                                .ConfigureAwait(false);
                            // <description />
                            await objWriter.WriteElementStringAsync("description", _strDescription.CleanOfXmlInvalidUnicodeChars(), token: token)
                                .ConfigureAwait(false);
                            // <background />
                            await objWriter.WriteElementStringAsync("background", _strBackground.CleanOfXmlInvalidUnicodeChars(), token: token)
                                .ConfigureAwait(false);
                            // <concept />
                            await objWriter.WriteElementStringAsync("concept", _strConcept.CleanOfXmlInvalidUnicodeChars(), token: token)
                                .ConfigureAwait(false);
                            // <notes />
                            await objWriter
                                .WriteElementStringAsync("notes", _strNotes.CleanOfXmlInvalidUnicodeChars(),
                                    token: token).ConfigureAwait(false);
                            // <alias />
                            await objWriter.WriteElementStringAsync("alias", _strAlias, token: token)
                                .ConfigureAwait(false);
                            // <playername />
                            await objWriter.WriteElementStringAsync("playername", _strPlayerName, token: token)
                                .ConfigureAwait(false);
                            // <gamenotes />
                            await objWriter.WriteElementStringAsync("gamenotes", _strGameNotes.CleanOfXmlInvalidUnicodeChars(), token: token)
                                .ConfigureAwait(false);
                            // <primaryarm />
                            await objWriter.WriteElementStringAsync("primaryarm", _strPrimaryArm, token: token)
                                .ConfigureAwait(false);

                            // <ignorerules />
                            if (_blnIgnoreRules)
                                await objWriter.WriteElementStringAsync("ignorerules",
                                    _blnIgnoreRules.ToString(
                                        GlobalSettings.InvariantCultureInfo),
                                    token: token).ConfigureAwait(false);
                            // <iscritter />
                            if (_blnIsCritter)
                                await objWriter.WriteElementStringAsync("iscritter",
                                    _blnIsCritter.ToString(
                                        GlobalSettings.InvariantCultureInfo),
                                    token: token).ConfigureAwait(false);
                            if (_blnPossessed)
                                await objWriter.WriteElementStringAsync("possessed",
                                    _blnPossessed.ToString(
                                        GlobalSettings.InvariantCultureInfo),
                                    token: token).ConfigureAwait(false);
                            // <karma />
                            await objWriter.WriteElementStringAsync(
                                    "karma", _intKarma.ToString(GlobalSettings.InvariantCultureInfo),
                                    token: token)
                                .ConfigureAwait(false);
                            // <special />
                            await objWriter.WriteElementStringAsync("special",
                                _intSpecial.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <totalspecial />
                            await objWriter.WriteElementStringAsync("totalspecial",
                                _intTotalSpecial.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <totalattributes />
                            await objWriter.WriteElementStringAsync("totalattributes",
                                _intTotalAttributes.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <edgeused />
                            await objWriter.WriteElementStringAsync("edgeused",
                                _intEdgeUsed.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <contactpoints />
                            await objWriter.WriteElementStringAsync("contactpoints",
                                (await GetContactPointsAsync(token).ConfigureAwait(false)).ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <spelllimit />
                            await objWriter.WriteElementStringAsync("spelllimit",
                                _intFreeSpells.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <cfplimit />
                            await objWriter.WriteElementStringAsync("cfplimit",
                                _intCFPLimit.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <totalaiprogramlimit />
                            await objWriter.WriteElementStringAsync("ainormalprogramlimit",
                                _intAINormalProgramLimit.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <aiadvancedprogramlimit />
                            await objWriter.WriteElementStringAsync("aiadvancedprogramlimit",
                                _intAIAdvancedProgramLimit.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <currentcounterspellingdice />
                            await objWriter.WriteElementStringAsync("currentcounterspellingdice",
                                _intCurrentCounterspellingDice.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <currentliftcarryhits />
                            await objWriter.WriteElementStringAsync("currentliftcarryhits",
                                _intCurrentLiftCarryHits.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <carrylimit />
                            await objWriter.WriteElementStringAsync("basecarrylimit",
                                (await GetBaseCarryLimitAsync(token).ConfigureAwait(false)).ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <liftlimit />
                            await objWriter.WriteElementStringAsync("baseliftlimit",
                                (await GetBaseLiftLimitAsync(token).ConfigureAwait(false)).ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <totalcarriedweight />
                            await objWriter.WriteElementStringAsync("totalcarriedweight",
                                (await GetTotalCarriedWeightAsync(token).ConfigureAwait(false)).ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <encumbranceinterval />
                            await objWriter.WriteElementStringAsync("encumbranceinterval",
                                (await GetEncumbranceIntervalAsync(token).ConfigureAwait(false)).ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <streetcred />
                            await objWriter.WriteElementStringAsync("streetcred",
                                _intStreetCred.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <notoriety />
                            await objWriter.WriteElementStringAsync("notoriety",
                                _intNotoriety.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <publicaware />
                            await objWriter.WriteElementStringAsync("publicawareness",
                                _intPublicAwareness.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <burntstreetcred />
                            await objWriter.WriteElementStringAsync("burntstreetcred",
                                _intBurntStreetCred.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <baseastralreputation />
                            await objWriter.WriteElementStringAsync("baseastralreputation",
                                _intBaseAstralReputation.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <basewildreputation />
                            await objWriter.WriteElementStringAsync("basewildreputation",
                                _intBaseWildReputation.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <created />
                            await objWriter.WriteElementStringAsync("created",
                                _blnCreated.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <nuyen />
                            await objWriter.WriteElementStringAsync(
                                    "nuyen", _decNuyen.ToString(GlobalSettings.InvariantCultureInfo),
                                    token: token)
                                .ConfigureAwait(false);
                            // <startingnuyen />
                            await objWriter.WriteElementStringAsync("startingnuyen",
                                _decStartingNuyen.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);

                            // <nuyenbp />
                            await objWriter.WriteElementStringAsync("nuyenbp",
                                _decNuyenBP.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);

                            // <adept />
                            await objWriter.WriteElementStringAsync("adept",
                                _blnAdeptEnabled.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <magician />
                            await objWriter.WriteElementStringAsync("magician",
                                _blnMagicianEnabled.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <technomancer />
                            await objWriter.WriteElementStringAsync("technomancer",
                                _blnTechnomancerEnabled.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <ai />
                            await objWriter.WriteElementStringAsync("ai",
                                _blnAdvancedProgramsEnabled.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <cyberwaredisabled />
                            await objWriter.WriteElementStringAsync("cyberwaredisabled",
                                _blnCyberwareDisabled.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <initiationdisabled />
                            await objWriter.WriteElementStringAsync("initiationdisabled",
                                _blnInitiationDisabled.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <critter />
                            await objWriter.WriteElementStringAsync("critter",
                                _blnCritterEnabled.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);

                            // <prototypetranshuman />
                            await objWriter.WriteElementStringAsync("prototypetranshuman",
                                _decPrototypeTranshuman.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);

                            // <attributes>
                            await objWriter.WriteStartElementAsync("attributes", token: token)
                                .ConfigureAwait(false);
                            AttributeSection.Save(objWriter, token);
                            // </attributes>
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <magenabled />
                            await objWriter.WriteElementStringAsync("magenabled",
                                _blnMAGEnabled.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <initiategrade />
                            await objWriter.WriteElementStringAsync("initiategrade",
                                _intInitiateGrade.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <resenabled />
                            await objWriter.WriteElementStringAsync("resenabled",
                                _blnRESEnabled.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <submersiongrade />
                            await objWriter.WriteElementStringAsync("submersiongrade",
                                _intSubmersionGrade.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <depenabled />
                            await objWriter.WriteElementStringAsync("depenabled",
                                _blnDEPEnabled.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <groupmember />
                            await objWriter.WriteElementStringAsync("groupmember",
                                _blnGroupMember.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <groupname />
                            await objWriter.WriteElementStringAsync("groupname", _strGroupName, token: token)
                                .ConfigureAwait(false);
                            // <groupnotes />
                            await objWriter.WriteElementStringAsync("groupnotes", _strGroupNotes, token: token)
                                .ConfigureAwait(false);

                            // External reader friendly stuff.
                            await objWriter.WriteElementStringAsync("totaless",
                                (await EssenceAsync(token: token)
                                    .ConfigureAwait(false))
                                .ToString(GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);

                            // Write out the Mystic Adept MAG split info.
                            if (_blnAdeptEnabled && _blnMagicianEnabled)
                            {
                                await objWriter.WriteElementStringAsync("magsplitadept",
                                    _intMAGAdept.ToString(
                                        GlobalSettings.InvariantCultureInfo),
                                    token: token).ConfigureAwait(false);
                                await objWriter.WriteElementStringAsync("magsplitmagician",
                                    _intMAGMagician.ToString(
                                        GlobalSettings.InvariantCultureInfo),
                                    token: token).ConfigureAwait(false);
                            }

                            _objTradition?.Save(objWriter);

                            // Condition Monitor Progress.
                            // <physicalcmfilled />
                            await objWriter.WriteElementStringAsync("physicalcmfilled",
                                _intPhysicalCMFilled.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            // <stuncmfilled />
                            await objWriter.WriteElementStringAsync("stuncmfilled",
                                _intStunCMFilled.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);

                            //<psyche />
                            await objWriter.WriteElementStringAsync("psyche",
                                _blnPsycheActive.ToString(
                                    GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);

                            ///////////////////////////////////////////SKILLS

                            SkillsSection.Save(objWriter);

                            //Write copy of old skill groups, to not totally fuck a file if error
                            _oldSkillGroupBackup?.WriteTo(objWriter);
                            _oldSkillsBackup?.WriteTo(objWriter);

                            ///////////////////////////////////////////SKILLS

                            // <contacts>
                            await objWriter.WriteStartElementAsync("contacts", token: token).ConfigureAwait(false);
                            await _lstContacts.ForEachAsync(x => x.SaveAsync(objWriter, token), token)
                                .ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <spells>
                            await objWriter.WriteStartElementAsync("spells", token: token).ConfigureAwait(false);
                            await _lstSpells.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <foci>
                            await objWriter.WriteStartElementAsync("foci", token: token).ConfigureAwait(false);
                            await _lstFoci.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <stackedfoci>
                            await objWriter.WriteStartElementAsync("stackedfoci", token: token)
                                .ConfigureAwait(false);
                            await _lstStackedFoci.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <powers>
                            await objWriter.WriteStartElementAsync("powers", token: token).ConfigureAwait(false);
                            await _lstPowers.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <spirits>
                            await objWriter.WriteStartElementAsync("spirits", token: token).ConfigureAwait(false);
                            await _lstSpirits.ForEachAsync(x => x.SaveAsync(objWriter, token), token)
                                .ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <complexforms>
                            await objWriter.WriteStartElementAsync("complexforms", token: token)
                                .ConfigureAwait(false);
                            await _lstComplexForms.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <aiprograms>
                            await objWriter.WriteStartElementAsync("aiprograms", token: token)
                                .ConfigureAwait(false);
                            await _lstAIPrograms.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <martialarts>
                            await objWriter.WriteStartElementAsync("martialarts", token: token)
                                .ConfigureAwait(false);
                            await _lstMartialArts.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <limitmodifiers>
                            await objWriter.WriteStartElementAsync("limitmodifiers", token: token)
                                .ConfigureAwait(false);
                            await _lstLimitModifiers.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <armors>
                            await objWriter.WriteStartElementAsync("armors", token: token).ConfigureAwait(false);
                            await _lstArmor.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <weapons>
                            await objWriter.WriteStartElementAsync("weapons", token: token).ConfigureAwait(false);
                            await _lstWeapons.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <cyberwares>
                            await objWriter.WriteStartElementAsync("cyberwares", token: token)
                                .ConfigureAwait(false);
                            await _lstCyberware.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <qualities>
                            await objWriter.WriteStartElementAsync("qualities", token: token)
                                .ConfigureAwait(false);
                            await _lstQualities.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <lifestyles>
                            await objWriter.WriteStartElementAsync("lifestyles", token: token)
                                .ConfigureAwait(false);
                            await _lstLifestyles.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <gears>
                            await objWriter.WriteStartElementAsync("gears", token: token).ConfigureAwait(false);
                            await _lstGear.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <vehicles>
                            await objWriter.WriteStartElementAsync("vehicles", token: token).ConfigureAwait(false);
                            await _lstVehicles.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <metamagics>
                            await objWriter.WriteStartElementAsync("metamagics", token: token)
                                .ConfigureAwait(false);
                            await _lstMetamagics.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <arts>
                            await objWriter.WriteStartElementAsync("arts", token: token).ConfigureAwait(false);
                            await _lstArts.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <enhancements>
                            await objWriter.WriteStartElementAsync("enhancements", token: token)
                                .ConfigureAwait(false);
                            await _lstEnhancements.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <critterpowers>
                            await objWriter.WriteStartElementAsync("critterpowers", token: token)
                                .ConfigureAwait(false);
                            await _lstCritterPowers.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <initiationgrades>
                            await objWriter.WriteStartElementAsync("initiationgrades", token: token)
                                .ConfigureAwait(false);
                            await _lstInitiationGrades.ForEachAsync(x => x.Save(objWriter), token)
                                .ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <improvements>
                            await objWriter.WriteStartElementAsync("improvements", token: token)
                                .ConfigureAwait(false);
                            await _lstImprovements.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <sustained>
                            await objWriter.WriteStartElementAsync("sustainedobjects", token: token)
                                .ConfigureAwait(false);
                            await _lstSustainedObjects.ForEachAsync(x => x.Save(objWriter), token)
                                .ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <drugs>
                            await objWriter.WriteStartElementAsync("drugs", token: token).ConfigureAwait(false);
                            await _lstDrugs.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <mentorspirits>
                            await objWriter.WriteStartElementAsync("mentorspirits", token: token)
                                .ConfigureAwait(false);
                            await _lstMentorSpirits.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <expenses>
                            await objWriter.WriteStartElementAsync("expenses", token: token).ConfigureAwait(false);
                            await _lstExpenseLog.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <locations>
                            await objWriter.WriteStartElementAsync("gearlocations", token: token)
                                .ConfigureAwait(false);
                            await _lstGearLocations.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <armorlocations>
                            await objWriter.WriteStartElementAsync("armorlocations", token: token)
                                .ConfigureAwait(false);
                            await _lstArmorLocations.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <vehiclelocations>
                            await objWriter.WriteStartElementAsync("vehiclelocations", token: token)
                                .ConfigureAwait(false);
                            await _lstVehicleLocations.ForEachAsync(x => x.Save(objWriter), token)
                                .ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <weaponlocations>
                            await objWriter.WriteStartElementAsync("weaponlocations", token: token)
                                .ConfigureAwait(false);
                            await _lstWeaponLocations.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <improvementgroups>
                            await objWriter.WriteStartElementAsync("improvementgroups", token: token)
                                .ConfigureAwait(false);
                            await _lstImprovementGroups.ForEachAsync(
                                strGroup => objWriter.WriteElementStringAsync("improvementgroup", strGroup,
                                    token: token),
                                token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <calendar>
                            await objWriter.WriteStartElementAsync("calendar", token: token).ConfigureAwait(false);
                            await _lstCalendar.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            //Plugins
                            IReadOnlyList<IPlugin> lstActivePlugins = Program.PluginLoader != null
                                ? await Program.PluginLoader.GetMyActivePluginsAsync(token).ConfigureAwait(false)
                                : null;
                            if (lstActivePlugins?.Count > 0)
                            {
                                // <plugins>
                                await objWriter.WriteStartElementAsync("plugins", token: token)
                                    .ConfigureAwait(false);
                                foreach (IPlugin objPlugin in lstActivePlugins)
                                {
                                    try
                                    {
                                        System.Reflection.AssemblyName objPluginAssemblyName =
                                            objPlugin.GetPluginAssembly().GetName();
                                        await objWriter
                                            .WriteStartElementAsync(objPluginAssemblyName.Name, token: token)
                                            .ConfigureAwait(false);
                                        await objWriter
                                            .WriteAttributeStringAsync(
                                                "version", objPluginAssemblyName.Version.ToString(), token: token)
                                            .ConfigureAwait(false);
                                        await objWriter.WriteStringAsync(objPlugin.GetSaveToFileElement(this))
                                            .ConfigureAwait(false);
                                        await objWriter.WriteEndElementAsync().ConfigureAwait(false);
                                    }
                                    catch (Exception e) when (!(e is OperationCanceledException))
                                    {
                                        Log.Warn(
                                            e, "Exception while writing saveFileElement for plugin " + objPlugin + ": ");
                                    }
                                }

                                //</plugins>
                                await objWriter.WriteEndElementAsync().ConfigureAwait(false);
                            }

                            //calculatedValues
                            await objWriter.WriteStartElementAsync("calculatedvalues", token: token)
                                .ConfigureAwait(false);
                            await objWriter.WriteCommentAsync(
                                    "these values are not loaded and only stored here for third parties, who parse this files (to not have to calculate them themselves)")
                                .ConfigureAwait(false);
                            await objWriter.WriteElementStringAsync("physicalcm",
                                (await GetPhysicalCMAsync(token)
                                    .ConfigureAwait(false))
                                .ToString(GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            await objWriter.WriteElementStringAsync("physicalcmthresholdoffset",
                                (await GetPhysicalCMThresholdOffsetAsync(token)
                                    .ConfigureAwait(false))
                                .ToString(GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            await objWriter.WriteElementStringAsync("physicalcmoverflow",
                                (await GetCMOverflowAsync(token)
                                    .ConfigureAwait(false))
                                .ToString(GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            await objWriter
                                .WriteElementStringAsync(
                                    "stuncm",
                                    (await GetStunCMAsync(token).ConfigureAwait(false)).ToString(
                                        GlobalSettings.InvariantCultureInfo), token: token)
                                .ConfigureAwait(false);
                            await objWriter.WriteElementStringAsync("stuncmthresholdoffset",
                                (await GetStunCMThresholdOffsetAsync(token)
                                    .ConfigureAwait(false))
                                .ToString(GlobalSettings.InvariantCultureInfo),
                                token: token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);
                            // </calculatedValues>

                            // </character>
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            await objWriter.WriteEndDocumentAsync().ConfigureAwait(false);
                            await objWriter.FlushAsync().ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        if (blnSync)
                            objLocker.Dispose();
                        else
                            await objLockerAsync.DisposeAsync().ConfigureAwait(false);
                    }
                }

                objStream.Position = 0;

                // Validate that the character can save properly. If there's no error, save the file to the listed file location.
                try
                {
                    token.ThrowIfCancellationRequested();
                    using (new FetchSafelyFromSafeObjectPool<XmlDocument>(Utils.XmlDocumentPool, out XmlDocument objDoc))
                    {
                        using (XmlReader objXmlReader = XmlReader.Create(objStream, GlobalSettings.SafeXmlReaderSettings))
                            objDoc.Load(objXmlReader);
                        using (FileStream objFileStream
                               = new FileStream(strFileName, FileMode.Create, FileAccess.Write, FileShare.None))
                        {
                            if (strFileName.EndsWith(".chum5", StringComparison.OrdinalIgnoreCase))
                                objDoc.Save(objFileStream);
                            else
                            {
                                objStream.Seek(0, SeekOrigin.Begin);
                                if (blnSync)
                                    objStream.CompressToLzmaFile(
                                        objFileStream,
                                        eOverrideCompressionLevel == LzmaHelper.ChummerCompressionPreset.None
                                            ? GlobalSettings.Chum5lzCompressionLevel
                                            : eOverrideCompressionLevel);
                                else
                                    await objStream.CompressToLzmaFileAsync(
                                            objFileStream,
                                            eOverrideCompressionLevel == LzmaHelper.ChummerCompressionPreset.None
                                                ? GlobalSettings.Chum5lzCompressionLevel
                                                : eOverrideCompressionLevel,
                                            token: token)
                                        .ConfigureAwait(false);
                            }
                        }
                    }
                }
                catch (Exception e) when ((e is IOException) || (e is XmlException) || (e is UnauthorizedAccessException))
                {
                    Log.Error(e);
                    if (Utils.IsUnitTest)
                    {
                        if (!(e is UnauthorizedAccessException))
                            throw;
                    }
                    else
                    {
                        if (blnSync)
                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                            // ReSharper disable once MethodHasAsyncOverload
                            Program.ShowScrollableMessageBox(LanguageManager.GetString("Message_Save_Error_Warning",
                                token: token));
                        else
                            await Program.ShowScrollableMessageBoxAsync(await LanguageManager
                                .GetStringAsync(
                                    "Message_Save_Error_Warning", token: token)
                                .ConfigureAwait(false), token: token).ConfigureAwait(false);
                        blnErrorFree = false;
                    }
                }
            }

            if (addToMRU)
            {
                if (blnSync)
                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                    GlobalSettings.MostRecentlyUsedCharacters.Insert(0, strFileName);
                else
                    await GlobalSettings.MostRecentlyUsedCharacters.InsertAsync(0, strFileName, token).ConfigureAwait(false);
            }

            if (callOnSaveCallBack)
            {
                if (blnSync)
                {
                    // ReSharper disable once MethodHasAsyncOverload
                    using (LockObject.EnterReadLock(token))
                    {
                        if (DoOnSaveCompleted.Count == 0 && DoOnSaveCompletedAsync.Count == 0)
                            return blnErrorFree;
                    }
                }
                else
                {
                    IAsyncDisposable objLocker2 = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        if (await DoOnSaveCompleted.GetCountAsync(token).ConfigureAwait(false) == 0 &&
                            await DoOnSaveCompletedAsync.GetCountAsync(token).ConfigureAwait(false) == 0)
                            return blnErrorFree;
                    }
                    finally
                    {
                        await objLocker2.DisposeAsync().ConfigureAwait(false);
                    }
                }

                IDisposable objLocker = null;
                IAsyncDisposable objLockerAsync = null;
                if (blnSync)
                    // ReSharper disable once MethodHasAsyncOverload
                    objLocker = LockObject.EnterUpgradeableReadLock(token);
                else
                    objLockerAsync = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    // Cannot use foreach or LINQ because we need to be able to allow queued functions to add onto the queue
                    if (blnSync)
                    {
                        List<Func<bool>> lstToRun = new List<Func<bool>>(DoOnSaveCompleted.Count);
                        List<Func<Task<bool>>> lstToRunAsync = new List<Func<Task<bool>>>(DoOnSaveCompletedAsync.Count);
                        int i = 0;
                        int j = 0;
                        while (i < DoOnSaveCompleted.Count || j < DoOnSaveCompletedAsync.Count)
                        {
                            while (i < DoOnSaveCompleted.Count)
                            {
                                lstToRun.Clear();
                                for (; i < DoOnSaveCompleted.Count; ++i)
                                {
                                    Func<Character, bool> funcLoopToRun = DoOnSaveCompleted[i];
                                    if (funcLoopToRun != null)
                                        lstToRun.Add(() => funcLoopToRun(this));
                                }

                                bool[] ablnTemp = Utils.RunWithoutThreadLock(lstToRun, token);
                                if (blnErrorFree && ablnTemp.FirstMatching(false) >= 0)
                                    blnErrorFree = false;
                            }

                            while (j < DoOnSaveCompletedAsync.Count)
                            {
                                lstToRunAsync.Clear();
                                for (; j < DoOnSaveCompletedAsync.Count; ++j)
                                {
                                    Func<Character, CancellationToken, Task<bool>> funcLoopToRun
                                        = DoOnSaveCompletedAsync[j];
                                    if (funcLoopToRun != null)
                                        lstToRunAsync.Add(() => funcLoopToRun(this, token));
                                }

                                bool[] ablnTemp = Utils.RunWithoutThreadLock(lstToRunAsync, token);
                                if (blnErrorFree && ablnTemp.FirstMatching(false) >= 0)
                                    blnErrorFree = false;
                            }
                        }
                    }
                    else
                    {
                        List<Task<bool>> lstDoOnSaveCompletedAsync = new List<Task<bool>>(Utils.MaxParallelBatchSize);
                        int i = 0;
                        int j = 0;
                        while (i != await DoOnSaveCompleted.GetCountAsync(token).ConfigureAwait(false)
                               || j != await DoOnSaveCompletedAsync.GetCountAsync(token).ConfigureAwait(false))
                        {
                            lstDoOnSaveCompletedAsync.Clear();
                            while
                                (i != await DoOnSaveCompleted
                                    .GetCountAsync(token)
                                    .ConfigureAwait(
                                        false)) // Set up this way because functions can potentially add more to DoOnSaveCompleted
                            {
                                int intCounter = 0;
                                // ReSharper disable once ForCanBeConvertedToForeach
                                for (; i < await DoOnSaveCompleted.GetCountAsync(token).ConfigureAwait(false); ++i)
                                {
                                    token.ThrowIfCancellationRequested();
                                    Func<Character, bool> funcLoopToRun = await DoOnSaveCompleted
                                        .GetValueAtAsync(i, token).ConfigureAwait(false);
                                    if (funcLoopToRun != null)
                                    {
                                        lstDoOnSaveCompletedAsync.Add(
                                            Task.Run(() => funcLoopToRun.Invoke(this), token));
                                        if (++intCounter != Utils.MaxParallelBatchSize)
                                            continue;
                                        token.ThrowIfCancellationRequested();
                                        await Task.WhenAll(lstDoOnSaveCompletedAsync).ConfigureAwait(false);
                                        token.ThrowIfCancellationRequested();
                                        foreach (Task<bool> tskLoop in lstDoOnSaveCompletedAsync)
                                        {
                                            if (!await tskLoop.ConfigureAwait(false))
                                                blnErrorFree = false;
                                        }

                                        lstDoOnSaveCompletedAsync.Clear();
                                        intCounter = 0;
                                    }
                                }

                                token.ThrowIfCancellationRequested();
                                await Task.WhenAll(lstDoOnSaveCompletedAsync).ConfigureAwait(false);
                                token.ThrowIfCancellationRequested();
                                foreach (Task<bool> tskLoop in lstDoOnSaveCompletedAsync)
                                {
                                    if (!await tskLoop.ConfigureAwait(false))
                                        blnErrorFree = false;
                                }
                            }

                            lstDoOnSaveCompletedAsync.Clear();
                            while (j != await DoOnSaveCompletedAsync.GetCountAsync(token).ConfigureAwait(false))
                            {
                                int intCounter = 0;
                                // ReSharper disable once ForCanBeConvertedToForeach
                                for (; j < await DoOnSaveCompletedAsync.GetCountAsync(token).ConfigureAwait(false); ++j)
                                {
                                    Func<Character, CancellationToken, Task<bool>> funcLoopToRun
                                        = await DoOnSaveCompletedAsync.GetValueAtAsync(j, token).ConfigureAwait(false);
                                    if (funcLoopToRun != null)
                                    {
                                        lstDoOnSaveCompletedAsync.Add(
                                            funcLoopToRun.Invoke(this, token));
                                        if (++intCounter != Utils.MaxParallelBatchSize)
                                            continue;
                                        token.ThrowIfCancellationRequested();
                                        await Task.WhenAll(lstDoOnSaveCompletedAsync).ConfigureAwait(false);
                                        token.ThrowIfCancellationRequested();
                                        foreach (Task<bool> tskLoop in lstDoOnSaveCompletedAsync)
                                        {
                                            if (!await tskLoop.ConfigureAwait(false))
                                                blnErrorFree = false;
                                        }

                                        lstDoOnSaveCompletedAsync.Clear();
                                        intCounter = 0;
                                    }
                                }

                                token.ThrowIfCancellationRequested();
                                await Task.WhenAll(lstDoOnSaveCompletedAsync).ConfigureAwait(false);
                                token.ThrowIfCancellationRequested();
                                foreach (Task<bool> tskLoop in lstDoOnSaveCompletedAsync)
                                {
                                    if (!await tskLoop.ConfigureAwait(false))
                                        blnErrorFree = false;
                                }
                            }
                        }
                    }
                }
                finally
                {
                    if (blnSync)
                        objLocker.Dispose();
                    else
                        await objLockerAsync.DisposeAsync().ConfigureAwait(false);
                }
            }

            return blnErrorFree;
        }

        /// <summary>
        /// Syntactic sugar for <see cref="XmlManager.LoadXPath(string, IReadOnlyCollection{string}, string, bool, CancellationToken)"/> where we use the current enabled custom data directory list from our options file.
        /// XPathDocuments are usually faster than XmlDocuments, but are read-only and take longer to load if live custom data is enabled
        /// Returns a new XPathNavigator associated with the XPathDocument so that multiple threads each get their own navigator if they're called on the same file
        /// </summary>
        /// <param name="strFileName">Name of the XML file to load.</param>
        /// <param name="strLanguage">Language in which to load the data document.</param>
        /// <param name="blnLoadFile">Whether to force reloading content even if the file already exists.</param>
        /// <param name="token">Cancellation token to use.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public XPathNavigator LoadDataXPath(string strFileName, string strLanguage = "", bool blnLoadFile = false, CancellationToken token = default)
        {
            return Settings.LoadDataXPath(strFileName, strLanguage, blnLoadFile, token);
        }

        /// <summary>
        /// Syntactic sugar for <see cref="XmlManager.LoadXPathAsync(string, IReadOnlyCollection{string}, string, bool, CancellationToken)"/> where we use the current enabled custom data directory list from our options file.
        /// XPathDocuments are usually faster than XmlDocuments, but are read-only and take longer to load if live custom data is enabled
        /// Returns a new XPathNavigator associated with the XPathDocument so that multiple threads each get their own navigator if they're called on the same file
        /// </summary>
        /// <param name="strFileName">Name of the XML file to load.</param>
        /// <param name="strLanguage">Language in which to load the data document.</param>
        /// <param name="blnLoadFile">Whether to force reloading content even if the file already exists.</param>
        /// <param name="token">Cancellation token to use.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public async Task<XPathNavigator> LoadDataXPathAsync(string strFileName, string strLanguage = "",
            bool blnLoadFile = false, CancellationToken token = default)
        {
            return await (await GetSettingsAsync(token).ConfigureAwait(false)).LoadDataXPathAsync(strFileName, strLanguage, blnLoadFile, token).ConfigureAwait(false);
        }

        /// <summary>
        /// Syntactic sugar for <see cref="XmlManager.Load(string, IReadOnlyCollection{string}, string, bool, CancellationToken)"/> where we use the current enabled custom data directory list from our options file.
        /// </summary>
        /// <param name="strFileName">Name of the XML file to load.</param>
        /// <param name="strLanguage">Language in which to load the data document.</param>
        /// <param name="blnLoadFile">Whether to force reloading content even if the file already exists.</param>
        /// <param name="token">Cancellation token to use.</param>
        [NotNull]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public XmlDocument LoadData(string strFileName, string strLanguage = "", bool blnLoadFile = false, CancellationToken token = default)
        {
            return Settings.LoadData(strFileName, strLanguage, blnLoadFile, token);
        }

        /// <summary>
        /// Syntactic sugar for <see cref="XmlManager.LoadAsync(string, IReadOnlyCollection{string}, string, bool, CancellationToken)"/> where we use the current enabled custom data directory list from our options file.
        /// </summary>
        /// <param name="strFileName">Name of the XML file to load.</param>
        /// <param name="strLanguage">Language in which to load the data document.</param>
        /// <param name="blnLoadFile">Whether to force reloading content even if the file already exists.</param>
        /// <param name="token">Cancellation token to use.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public async Task<XmlDocument> LoadDataAsync(string strFileName, string strLanguage = "", bool blnLoadFile = false, CancellationToken token = default)
        {
            return await (await GetSettingsAsync(token).ConfigureAwait(false)).LoadDataAsync(strFileName, strLanguage, blnLoadFile, token).ConfigureAwait(false);
        }

        private int _intIsLoading;

        /// <summary>
        /// Set to true while data is being populated by the Load function
        /// </summary>
        public bool IsLoading
        {
            get => _intIsLoading > 0;
            private set
            {
                if (value)
                {
                    if (Interlocked.Increment(ref _intIsLoading) == 1)
                    {
                        OnPropertyChanged();
                    }
                }
                else if (Interlocked.Decrement(ref _intIsLoading) == 0)
                {
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Set to true while data is being populated by the Load function
        /// </summary>
        private Task SetIsLoadingAsync(bool value, CancellationToken token = default)
        {
            if (token.IsCancellationRequested)
                return Task.FromCanceled(token);
            if (value)
            {
                if (Interlocked.Increment(ref _intIsLoading) == 1)
                {
                    return OnPropertyChangedAsync(nameof(IsLoading), token);
                }
            }
            else if (Interlocked.Decrement(ref _intIsLoading) == 0)
            {
                return OnPropertyChangedAsync(nameof(IsLoading), token);
            }

            return Task.CompletedTask;
        }

        /// <summary>
        /// Add a function to the queue of methods to execute after loading has finished. Return value signals whether loading should continue after execution (True) or terminate/cancel (False).
        /// </summary>
        public bool EnqueuePostLoadMethod(Func<CancellationToken, bool> value, CancellationToken token = default)
        {
            // Only need read lock because collection is concurrent anyway
            using (LockObject.EnterReadLock(token))
            {
                return _setPostLoadMethods.TryAdd(value);
            }
        }

        /// <summary>
        /// Queue of asynchronous methods to execute after loading has finished. Return value signals whether loading should continue after execution (True) or terminate/cancel (False).
        /// </summary>
        public bool EnqueuePostLoadAsyncMethod(Func<CancellationToken, Task<bool>> value, CancellationToken token = default)
        {
            // Only need read lock because collection is concurrent anyway
            using (LockObject.EnterReadLock(token))
            {
                return _setPostLoadAsyncMethods.TryAdd(value);
            }
        }

        /// <summary>
        /// Add a function to the queue of methods to execute after loading has finished. Return value signals whether loading should continue after execution (True) or terminate/cancel (False).
        /// </summary>
        public async Task<bool> EnqueuePostLoadMethodAsync(Func<CancellationToken, bool> value, CancellationToken token = default)
        {
            // Only need read lock because collection is concurrent anyway
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _setPostLoadMethods.TryAdd(value);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Queue of asynchronous methods to execute after loading has finished. Return value signals whether loading should continue after execution (True) or terminate/cancel (False).
        /// </summary>
        public async Task<bool> EnqueuePostLoadAsyncMethodAsync(Func<CancellationToken, Task<bool>> value, CancellationToken token = default)
        {
            // Only need read lock because collection is concurrent anyway
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _setPostLoadAsyncMethods.TryAdd(value);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Load the Character from an XML file synchronously.
        /// </summary>
        /// <param name="strFileName">Name of the file to load the character from. Leave empty if the character should be loaded from FileName.</param>
        /// <param name="frmLoadingForm">Instance of frmLoading to use to update with loading progress. <see cref="LoadingBar.PerformStep(string, LoadingBar.ProgressBarTextPatterns)"/> is called <see cref="NumLoadingSections"/> times within this method, so plan accordingly.</param>
        /// <param name="showWarnings">Whether warnings about book content and other character content should be loaded.</param>
        /// <param name="token">Cancellation token to use.</param>
        public bool Load(string strFileName = "", LoadingBar frmLoadingForm = null, bool showWarnings = true, CancellationToken token = default)
        {
            return Utils.SafelyRunSynchronously(() => LoadCoreAsync(true, strFileName, frmLoadingForm, showWarnings, token), token);
        }

        /// <summary>
        /// Load the Character from an XML file asynchronously.
        /// </summary>
        /// <param name="strFileName">Name of the file to load the character from. Leave empty if the character should be loaded from FileName.</param>
        /// <param name="frmLoadingForm">Instance of frmLoading to use to update with loading progress. <see cref="LoadingBar.PerformStepAsync(string, LoadingBar.ProgressBarTextPatterns, CancellationToken)"/> is called <see cref="NumLoadingSections"/> times within this method, so plan accordingly.</param>
        /// <param name="showWarnings">Whether warnings about book content and other character content should be loaded.</param>
        /// <param name="token">Cancellation token to use.</param>
        public Task<bool> LoadAsync(string strFileName = "", LoadingBar frmLoadingForm = null, bool showWarnings = true, CancellationToken token = default)
        {
            return LoadCoreAsync(false, strFileName, frmLoadingForm, showWarnings, token);
        }

        public const int NumLoadingSections = 37;

        /// <summary>
        /// Load the Character from an XML file.
        /// Uses flag hack method design outlined here to avoid locking:
        /// https://docs.microsoft.com/en-us/archive/msdn-magazine/2015/july/async-programming-brownfield-async-development
        /// </summary>
        /// <param name="blnSync">Flag for whether method should always use synchronous code or not.</param>
        /// <param name="strFileName">Name of the file to load the character from. Leave empty if the character should be loaded from FileName.</param>
        /// <param name="frmLoadingForm">Instance of frmLoading to use to update with loading progress. <see cref="LoadingBar.PerformStep(string, LoadingBar.ProgressBarTextPatterns)"/> or <see cref="LoadingBar.PerformStepAsync(string, LoadingBar.ProgressBarTextPatterns, CancellationToken)"/> is called <see cref="NumLoadingSections"/> times within this method, so plan accordingly.</param>
        /// <param name="showWarnings">Whether warnings about book content and other character content should be loaded.</param>
        /// <param name="token">Cancellation token to use.</param>
        private async Task<bool> LoadCoreAsync(bool blnSync, string strFileName = "", LoadingBar frmLoadingForm = null,
                                               bool showWarnings = true, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (string.IsNullOrWhiteSpace(strFileName))
                strFileName = FileName;
            if (!File.Exists(strFileName) || (!strFileName.EndsWith(".chum5", StringComparison.OrdinalIgnoreCase)
                                              && !strFileName.EndsWith(".chum5lz", StringComparison.OrdinalIgnoreCase)))
                return false;

            IDisposable objLocker = null;
            IAsyncDisposable objLockerAsync = null;
            if (blnSync)
                // ReSharper disable once MethodHasAsyncOverload
                objLocker = LockObject.EnterWriteLock(token);
            else
                objLockerAsync = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (blnSync)
                    LoadAsDirty = false;
                else
                    await SetLoadAsDirtyAsync(false, token).ConfigureAwait(false);
                using (CustomActivity loadActivity = Timekeeper.StartSyncron("clsCharacter.Load", null,
                                                                             CustomActivity.OperationType
                                                                                 .DependencyOperation, strFileName))
                {
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        using (Timekeeper.StartSyncron("upload_AI_options", loadActivity))
                        {
                            UploadObjectAsMetric.UploadObject(TelemetryClient, blnSync ? Settings : await GetSettingsAsync(token).ConfigureAwait(false));
                        }

                        XmlDocument objXmlDocument = new XmlDocument { XmlResolver = null };
                        XmlNode objXmlCharacter = null;
                        XPathNavigator xmlCharacterNavigator = null;
                        Quality objLivingPersonaQuality = null;

                        if (frmLoadingForm != null)
                        {
                            if (blnSync)
                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                frmLoadingForm.PerformStep("XML");
                            else
                                await frmLoadingForm.PerformStepAsync("XML", token: token).ConfigureAwait(false);
                        }

                        using (Timekeeper.StartSyncron("load_xml", loadActivity))
                        {
                            bool blnKeepLoading = blnSync
                                ? LoadSaveFileDocument()
                                : await LoadSaveFileDocumentAsync().ConfigureAwait(false);

                            bool LoadSaveFileDocument()
                            {
                                bool blnErrorCaught = false;
                                do
                                {
                                    try
                                    {
                                        token.ThrowIfCancellationRequested();
                                        if (strFileName.EndsWith(".chum5", StringComparison.OrdinalIgnoreCase))
                                            objXmlDocument.LoadStandardPatient(strFileName, !blnErrorCaught, token: token);
                                        else if (strFileName.EndsWith(".chum5lz", StringComparison.OrdinalIgnoreCase))
                                            objXmlDocument.LoadStandardFromLzmaCompressedPatient(
                                                strFileName, !blnErrorCaught, token: token);
                                        else
                                            throw new InvalidOperationException();
                                        blnErrorCaught = false;
                                    }
                                    catch (XmlException ex)
                                    {
                                        ex = ex.Demystify();
                                        if (ex.Message.HasAnyXmlInvalidUnicodeChars())
                                        {
                                            /*If we found a known control character that's preventing the character from
                                            being loaded (Expected to be notes ingested from PDF mostly) prompt the user whether to use unsafe methods.
                                            If yes, restart the load, explicitly ignoring invalid characters.*/

                                            if (Program.ShowScrollableMessageBox(
                                                    LanguageManager.GetString("Message_InvalidTextFound", token: token),
                                                    LanguageManager.GetString(
                                                        "Message_InvalidTextFound_Title", token: token),
                                                    MessageBoxButtons.YesNo, MessageBoxIcon.Warning) ==
                                                DialogResult.No)
                                            {
                                                return false;
                                            }

                                            blnErrorCaught = true;
                                        }
                                        else
                                        {
                                            if (showWarnings)
                                            {
                                                Program.ShowScrollableMessageBox(
                                                    string.Format(GlobalSettings.CultureInfo,
                                                                  LanguageManager.GetString(
                                                                      "Message_FailedLoad", token: token),
                                                                  ex.Message),
                                                    string.Format(GlobalSettings.CultureInfo,
                                                                  LanguageManager.GetString(
                                                                      "MessageTitle_FailedLoad", token: token),
                                                                  ex.Message),
                                                    MessageBoxButtons.OK, MessageBoxIcon.Error);
                                            }

                                            return false;
                                        }
                                    }
                                } while (blnErrorCaught);

                                objXmlCharacter = objXmlDocument.SelectSingleNode("/character");
                                xmlCharacterNavigator =
                                    objXmlDocument.GetFastNavigator().SelectSingleNodeAndCacheExpression("/character", token);
                                return true;
                            }

                            async Task<bool> LoadSaveFileDocumentAsync()
                            {
                                bool blnErrorCaught = false;
                                do
                                {
                                    try
                                    {
                                        token.ThrowIfCancellationRequested();
                                        if (strFileName.EndsWith(".chum5", StringComparison.OrdinalIgnoreCase))
                                            await objXmlDocument.LoadStandardPatientAsync(
                                                strFileName, !blnErrorCaught, token: token).ConfigureAwait(false);
                                        else if (strFileName.EndsWith(".chum5lz", StringComparison.OrdinalIgnoreCase))
                                            await objXmlDocument.LoadStandardFromLzmaCompressedPatientAsync(
                                                strFileName, !blnErrorCaught, token: token).ConfigureAwait(false);
                                        else
                                            throw new InvalidOperationException();
                                        blnErrorCaught = false;
                                    }
                                    catch (XmlException ex)
                                    {
                                        ex = ex.Demystify();
                                        if (ex.Message.HasAnyXmlInvalidUnicodeChars())
                                        {
                                            /*If we found a known control character that's preventing the character from
                                            being loaded (Expected to be notes ingested from PDF mostly) prompt the user whether to use unsafe methods.
                                            If yes, restart the load, explicitly ignoring invalid characters.*/

                                            if (await Program.ShowScrollableMessageBoxAsync(
                                                    await LanguageManager
                                                        .GetStringAsync("Message_InvalidTextFound", token: token)
                                                        .ConfigureAwait(false),
                                                    await LanguageManager
                                                        .GetStringAsync(
                                                            "Message_InvalidTextFound_Title", token: token)
                                                        .ConfigureAwait(false),
                                                    MessageBoxButtons.YesNo, MessageBoxIcon.Warning, token: token).ConfigureAwait(false) ==
                                                DialogResult.No)
                                            {
                                                return false;
                                            }

                                            blnErrorCaught = true;
                                        }
                                        else
                                        {
                                            if (showWarnings)
                                            {
                                                await Program.ShowScrollableMessageBoxAsync(
                                                    string.Format(GlobalSettings.CultureInfo,
                                                        await LanguageManager
                                                            .GetStringAsync(
                                                                "Message_FailedLoad", token: token)
                                                            .ConfigureAwait(false),
                                                        ex.Message),
                                                    string.Format(GlobalSettings.CultureInfo,
                                                        await LanguageManager
                                                            .GetStringAsync(
                                                                "MessageTitle_FailedLoad", token: token)
                                                            .ConfigureAwait(false),
                                                        ex.Message),
                                                    MessageBoxButtons.OK, MessageBoxIcon.Error, token: token).ConfigureAwait(false);
                                            }

                                            return false;
                                        }
                                    }
                                } while (blnErrorCaught);

                                objXmlCharacter = objXmlDocument.SelectSingleNode("/character");
                                xmlCharacterNavigator
                                    = (await objXmlDocument.GetFastNavigatorAsync(token).ConfigureAwait(false))
                                            .SelectSingleNodeAndCacheExpression("/character", token);
                                return true;
                            }

                            if (!blnKeepLoading || objXmlCharacter == null || xmlCharacterNavigator == null)
                            {
                                return false;
                            }

                            //Timekeeper.Finish("load_xml");
                        }

                        if (blnSync)
                            IsLoading = true;
                        else
                            await SetIsLoadingAsync(true, token).ConfigureAwait(false);

                        try
                        {
                            token.ThrowIfCancellationRequested();
                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("String_Settings", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("String_Settings",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_misc", loadActivity))
                            {
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("ignorerules", ref _blnIgnoreRules);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("created", ref _blnCreated);

                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ResetCharacter(token);
                                else
                                    await ResetCharacterAsync(token).ConfigureAwait(false);

                                // Get the game edition of the file if possible and make sure it's intended to be used with this version of the application.
                                string strGameEdition = string.Empty;
                                if (xmlCharacterNavigator.TryGetStringFieldQuickly("gameedition",
                                        ref strGameEdition) &&
                                    !string.IsNullOrEmpty(strGameEdition) && strGameEdition != "SR5" &&
                                    showWarnings &&
                                    !Utils.IsUnitTest)
                                {
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        Program.ShowScrollableMessageBox(
                                            // ReSharper disable once MethodHasAsyncOverload
                                            LanguageManager.GetString(
                                                "Message_IncorrectGameVersion_SR4",
                                                token: token),
                                            // ReSharper disable once MethodHasAsyncOverload
                                            LanguageManager.GetString(
                                                "MessageTitle_IncorrectGameVersion",
                                                token: token),
                                            MessageBoxButtons.YesNo, MessageBoxIcon.Error);
                                    else
                                        await Program.ShowScrollableMessageBoxAsync(
                                            await LanguageManager.GetStringAsync(
                                                "Message_IncorrectGameVersion_SR4",
                                                token: token).ConfigureAwait(false),
                                            await LanguageManager.GetStringAsync(
                                                "MessageTitle_IncorrectGameVersion",
                                                token: token).ConfigureAwait(false),
                                            MessageBoxButtons.YesNo, MessageBoxIcon.Error,
                                            token: token).ConfigureAwait(false);
                                    return false;
                                }

                                string strVersion = string.Empty;
                                //Check to see if the character was created in a version of Chummer later than the currently installed one.
                                if (xmlCharacterNavigator.TryGetStringFieldQuickly("appversion", ref strVersion) &&
                                    !string.IsNullOrEmpty(strVersion))
                                {
                                    strVersion = strVersion.TrimStartOnce("0.");
                                    // Sweep for saves where the saved version includes a long alphanumeric string after the version (because of Application.ProductVersion weirdness)
                                    int intPlusSignIndex = strVersion.IndexOf('+');
                                    if (intPlusSignIndex >= 0)
                                        strVersion = strVersion.Substring(0, intPlusSignIndex);
                                    if (!ValueVersion.TryParse(strVersion, out _verSavedVersion))
                                    {
                                        _verSavedVersion = Utils.IsUnitTest
                                            ? new ValueVersion(int.MaxValue, int.MaxValue, int.MaxValue)
                                            : new ValueVersion();
                                    }
                                    // Check for typo in Corrupter quality and correct it
                                    else if (_verSavedVersion < new ValueVersion(5, 188, 34) && objXmlDocument.InnerXmlContentContains("Corruptor", token))
                                    {
                                        objXmlDocument.InnerXml =
                                            objXmlDocument.InnerXmlViaPool(token).Replace("Corruptor", "Corrupter");
                                        xmlCharacterNavigator =
                                            (blnSync
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                ? objXmlDocument.GetFastNavigator()
                                                : await objXmlDocument.GetFastNavigatorAsync(token)
                                                    .ConfigureAwait(false)
                                            ).SelectSingleNodeAndCacheExpression("/character", token);
                                        if (xmlCharacterNavigator == null)
                                            return false;
                                    }
                                }
#if !DEBUG
                                if (!Utils.IsUnitTest)
                                {
                                    string strMinimumVersion = string.Empty;
                                    // Check to see if a character has a minimum version set where they will not load properly on anything older
                                    if (xmlCharacterNavigator.TryGetStringFieldQuickly(
                                            "minimumappversion", ref strMinimumVersion)
                                        && !string.IsNullOrEmpty(strMinimumVersion))
                                    {
                                        strMinimumVersion = strMinimumVersion.TrimStartOnce("0.");
                                        if (Version.TryParse(strMinimumVersion, out Version objMinimumVersion)
                                            && objMinimumVersion > Utils.CurrentChummerVersion)
                                        {
                                            Program.ShowMessageBox(
                                                string.Format(GlobalSettings.CultureInfo,
                                                              blnSync
                                                                  // ReSharper disable once MethodHasAsyncOverload
                                                                  ? LanguageManager.GetString(
                                                                      "Message_OlderThanChummerSaveMinimumVersion", token: token)
                                                                  : await LanguageManager
                                                                          .GetStringAsync(
                                                                              "Message_OlderThanChummerSaveMinimumVersion",
                                                                              token: token).ConfigureAwait(false),
                                                              objMinimumVersion, Utils.CurrentChummerVersion),
                                                blnSync
                                                    // ReSharper disable once MethodHasAsyncOverload
                                                    ? LanguageManager.GetString(
                                                        "MessageTitle_OlderThanChummerSaveMinimumVersion", token: token)
                                                    : await LanguageManager
                                                            .GetStringAsync(
                                                                "MessageTitle_OlderThanChummerSaveMinimumVersion",
                                                                token: token).ConfigureAwait(false),
                                                MessageBoxButtons.OK, MessageBoxIcon.Error);
                                            return false;
                                        }
                                    }

                                    if (_verSavedVersion > Utils.CurrentChummerVersion && DialogResult.Yes
                                        != Program.ShowMessageBox(
                                            string.Format(GlobalSettings.CultureInfo,
                                                          blnSync
                                                              // ReSharper disable once MethodHasAsyncOverload
                                                              ? LanguageManager.GetString("Message_OutdatedChummerSave", token: token)
                                                              : await LanguageManager
                                                                      .GetStringAsync(
                                                                          "Message_OutdatedChummerSave", token: token)
                                                                      .ConfigureAwait(false), _verSavedVersion,
                                                          Utils.CurrentChummerVersion),
                                            blnSync
                                                // ReSharper disable once MethodHasAsyncOverload
                                                ? LanguageManager.GetString("MessageTitle_OutdatedChummerSave", token: token)
                                                : await LanguageManager
                                                        .GetStringAsync("MessageTitle_OutdatedChummerSave",
                                                                        token: token).ConfigureAwait(false),
                                            MessageBoxButtons.YesNo, MessageBoxIcon.Warning))
                                    {
                                        return false;
                                    }
                                }
#endif

                                // Get the name of the settings file in use if possible.
                                xmlCharacterNavigator.TryGetStringFieldQuickly("settings", ref _strSettingsKey);

                                int intSettingsHashCode = 0;
                                bool blnHashCodeSuccess
                                    = xmlCharacterNavigator.TryGetInt32FieldQuickly(
                                        "settingshashcode", ref intSettingsHashCode);

                                bool blnSuccess;

                                // Load the character's settings file.
                                string strDummy = string.Empty;
                                if (!xmlCharacterNavigator.TryGetStringFieldQuickly("buildmethod", ref strDummy)
                                    || !Enum.TryParse(strDummy, true, out CharacterBuildMethod eSavedBuildMethod))
                                {
                                    blnSuccess =
                                        (blnSync
                                            ? SettingsManager.LoadedCharacterSettings
                                            : await SettingsManager.GetLoadedCharacterSettingsAsync(token)
                                                .ConfigureAwait(false)).TryGetValue(GlobalSettings.DefaultCharacterSettingDefaultValue,
                                            out CharacterSettings objSettings);
                                    eSavedBuildMethod = blnSuccess
                                        ? objSettings.BuildMethod
                                        : CharacterBuildMethod.Priority;
                                }

                                blnSuccess =
                                    (blnSync
                                        ? SettingsManager.LoadedCharacterSettings
                                        : await SettingsManager.GetLoadedCharacterSettingsAsync(token)
                                            .ConfigureAwait(false)).TryGetValue(GlobalSettings.DefaultCharacterSetting,
                                        out CharacterSettings objDefaultSettings);
                                if (!blnSuccess)
                                {
                                    blnSuccess =
                                        (blnSync
                                            ? SettingsManager.LoadedCharacterSettings
                                            : await SettingsManager.GetLoadedCharacterSettingsAsync(token)
                                                .ConfigureAwait(false)).TryGetValue(GlobalSettings.DefaultCharacterSettingDefaultValue,
                                            out objDefaultSettings);
                                    if (!blnSuccess)
                                    {
                                        objDefaultSettings = blnSync
                                            ? SettingsManager.LoadedCharacterSettings.First().Value
                                            : (await SettingsManager.GetLoadedCharacterSettingsAsync(token)
                                                                    .ConfigureAwait(false)).First().Value;
                                    }
                                }

                                CharacterSettings objProspectiveSettings;
                                bool blnShowSelectBP = false;
                                using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                                           out HashSet<string> setSavedBooks))
                                {
                                    foreach (XPathNavigator xmlBook in xmlCharacterNavigator.SelectAndCacheExpression(
                                                 "sources/source", token))
                                    {
                                        if (!string.IsNullOrEmpty(xmlBook.Value))
                                            setSavedBooks.Add(xmlBook.Value);
                                    }

                                    if (setSavedBooks.Count == 0)
                                        setSavedBooks.AddRange(objDefaultSettings.Books);

                                    XPathNodeIterator xmlCustomDirectoryNames = xmlCharacterNavigator.SelectAndCacheExpression(
                                        "customdatadirectorynames/directoryname", token);
                                    List<string> lstSavedCustomDataDirectoryNames
                                        = new List<string>(xmlCustomDirectoryNames.Count);
                                    foreach (XPathNavigator xmlCustomDataDirectoryName in xmlCustomDirectoryNames)
                                    {
                                        if (!string.IsNullOrEmpty(xmlCustomDataDirectoryName.Value))
                                            lstSavedCustomDataDirectoryNames.Add(xmlCustomDataDirectoryName.Value);
                                    }

                                    decimal decLegacyMaxNuyen = objDefaultSettings.NuyenMaximumBP;
                                    xmlCharacterNavigator.TryGetDecFieldQuickly("maxnuyen", ref decLegacyMaxNuyen);
                                    int intLegacyMaxKarma = objDefaultSettings.BuildKarma;
                                    xmlCharacterNavigator.TryGetInt32FieldQuickly("maxkarma",
                                        ref intLegacyMaxKarma);

                                    // Calculate a score for a character option that roughly coincides with how suitable it is as a
                                    // replacement for the current one the character save contains Settings with a negative score
                                    // should not be considered suitable at all
                                    int CalculateCharacterSettingsMatchScore(CharacterSettings objOptionsToCheck)
                                    {
                                        int intReturn = int.MaxValue;

                                        int intBaseline = objOptionsToCheck.BuiltInOption ? 5 : 4;

                                        if (Created && eSavedBuildMethod != CharacterBuildMethod.LifeModule)
                                        {
                                            if (objOptionsToCheck.BuildMethod != eSavedBuildMethod)
                                            {
                                                if (objOptionsToCheck.BuildMethod.UsesPriorityTables() ==
                                                    eSavedBuildMethod.UsesPriorityTables())
                                                    intReturn -= 2;
                                                else
                                                    intReturn -= 4;
                                            }
                                            if (intLegacyMaxKarma != objOptionsToCheck.BuildKarma)
                                                intReturn -= Math.Min(Math.Abs(intLegacyMaxKarma - objOptionsToCheck.BuildKarma), 2);
                                            if (decLegacyMaxNuyen != objOptionsToCheck.NuyenMaximumBP)
                                                intReturn -= Math.Min(Math.Abs(decLegacyMaxNuyen - objOptionsToCheck.NuyenMaximumBP).StandardRound(), 2);
                                        }
                                        else
                                        {
                                            if (objOptionsToCheck.BuildMethod != eSavedBuildMethod)
                                            {
                                                if (objOptionsToCheck.BuildMethod.UsesPriorityTables() ==
                                                    eSavedBuildMethod.UsesPriorityTables())
                                                {
                                                    intBaseline += 2;
                                                    intReturn -= int.MaxValue / 2;
                                                }
                                                else
                                                {
                                                    intBaseline += 4;
                                                    intReturn -= int.MaxValue;
                                                }
                                            }
                                            intReturn -= ((intLegacyMaxKarma - objOptionsToCheck.BuildKarma)
                                                           .Pow(2)
                                                           + (decLegacyMaxNuyen - objOptionsToCheck.NuyenMaximumBP)
                                                           .Pow(2))
                                                          .FastSqrtAndStandardRound();
                                        }

                                        int intBaselineCustomDataCount
                                            = objOptionsToCheck.EnabledCustomDataDirectoryInfos.Count;
                                        if (intBaselineCustomDataCount == 0)
                                        {
                                            intBaselineCustomDataCount = lstSavedCustomDataDirectoryNames.Count;
                                            if (intBaselineCustomDataCount > 0)
                                            {
                                                intReturn -= intBaselineCustomDataCount.Pow(2) * intBaseline;
                                            }
                                        }
                                        else if (lstSavedCustomDataDirectoryNames.Count == 0)
                                        {
                                            intReturn -= intBaselineCustomDataCount.Pow(2) * intBaseline;
                                        }
                                        else
                                        {
                                            intBaselineCustomDataCount
                                                = Math.Max(lstSavedCustomDataDirectoryNames.Count,
                                                           intBaselineCustomDataCount);
                                            for (int i = 0;
                                                 i < objOptionsToCheck.EnabledCustomDataDirectoryInfos.Count;
                                                 ++i)
                                            {
                                                string strLoopCustomDataName =
                                                    objOptionsToCheck.EnabledCustomDataDirectoryInfos[i].Name;
                                                int intLoopIndex =
                                                    lstSavedCustomDataDirectoryNames.IndexOf(strLoopCustomDataName);
                                                if (intLoopIndex < 0)
                                                    intReturn -= intBaselineCustomDataCount * intBaseline;
                                                else
                                                    intReturn -= Math.Abs(i - intLoopIndex) * intBaseline;
                                            }

                                            int intMismatchCount = lstSavedCustomDataDirectoryNames.Count(x =>
                                                objOptionsToCheck.EnabledCustomDataDirectoryInfos.All(
                                                    y => y.Name != x));
                                            if (intMismatchCount != 0)
                                                intReturn -= intMismatchCount * intBaselineCustomDataCount *
                                                             intBaseline;
                                        }

                                        using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(
                                                   Utils.StringHashSetPool, out HashSet<string> setDummyBooks))
                                        {
                                            setDummyBooks.AddRange(setSavedBooks);
                                            int intExtraBooks = objOptionsToCheck.Books.Count(x => !setDummyBooks.Remove(x));
                                            setDummyBooks.ExceptWith(objOptionsToCheck.Books);
                                            // Missing books are weighted a lot more heavily than extra books
                                            intReturn -= (setDummyBooks.Count * (intBaselineCustomDataCount + byte.MaxValue)
                                                          + intExtraBooks) * intBaseline;
                                        }

                                        return intReturn;
                                    }
                                    // Calculate a score for a character option that roughly coincides with how suitable it is as a
                                    // replacement for the current one the character save contains Settings with a negative score
                                    // should not be considered suitable at all
                                    async Task<int> CalculateCharacterSettingsMatchScoreAsync(CharacterSettings objOptionsToCheck)
                                    {
                                        int intReturn = int.MaxValue;

                                        int intBaseline = objOptionsToCheck.BuiltInOption ? 5 : 4;

                                        if (Created && eSavedBuildMethod != CharacterBuildMethod.LifeModule)
                                        {
                                            if (objOptionsToCheck.BuildMethod != eSavedBuildMethod)
                                            {
                                                if (objOptionsToCheck.BuildMethod.UsesPriorityTables() ==
                                                    eSavedBuildMethod.UsesPriorityTables())
                                                    intReturn -= 2;
                                                else
                                                    intReturn -= 4;
                                            }
                                            if (intLegacyMaxKarma != objOptionsToCheck.BuildKarma)
                                                intReturn -= Math.Min(Math.Abs(intLegacyMaxKarma - objOptionsToCheck.BuildKarma), 2);
                                            if (decLegacyMaxNuyen != objOptionsToCheck.NuyenMaximumBP)
                                                intReturn -= Math.Min(Math.Abs(decLegacyMaxNuyen - objOptionsToCheck.NuyenMaximumBP).StandardRound(), 2);
                                        }
                                        else
                                        {
                                            if (objOptionsToCheck.BuildMethod != eSavedBuildMethod)
                                            {
                                                if (objOptionsToCheck.BuildMethod.UsesPriorityTables() ==
                                                    eSavedBuildMethod.UsesPriorityTables())
                                                {
                                                    intBaseline += 2;
                                                    intReturn -= int.MaxValue / 2;
                                                }
                                                else
                                                {
                                                    intBaseline += 4;
                                                    intReturn -= int.MaxValue;
                                                }
                                            }
                                            intReturn -= ((intLegacyMaxKarma - objOptionsToCheck.BuildKarma)
                                                           .Pow(2)
                                                           + (decLegacyMaxNuyen - objOptionsToCheck.NuyenMaximumBP)
                                                           .Pow(2))
                                                          .FastSqrtAndStandardRound();
                                        }

                                        IReadOnlyList<CustomDataDirectoryInfo> lstOtherEnabledCustomDataDirectoryInfos
                                            = await objOptionsToCheck
                                                    .GetEnabledCustomDataDirectoryInfosAsync(token)
                                                    .ConfigureAwait(false);
                                        int intBaselineCustomDataCount = lstOtherEnabledCustomDataDirectoryInfos.Count;
                                        if (intBaselineCustomDataCount == 0)
                                        {
                                            intBaselineCustomDataCount = lstSavedCustomDataDirectoryNames.Count;
                                            if (intBaselineCustomDataCount > 0)
                                            {
                                                intReturn -= intBaselineCustomDataCount.Pow(2) * intBaseline;
                                            }
                                        }
                                        else if (lstSavedCustomDataDirectoryNames.Count == 0)
                                        {
                                            intReturn -= intBaselineCustomDataCount.Pow(2) * intBaseline;
                                        }
                                        else
                                        {
                                            intBaselineCustomDataCount
                                                = Math.Max(lstSavedCustomDataDirectoryNames.Count,
                                                           intBaselineCustomDataCount);
                                            for (int i = 0;
                                                 i < lstOtherEnabledCustomDataDirectoryInfos.Count;
                                                 ++i)
                                            {
                                                string strLoopCustomDataName =
                                                    lstOtherEnabledCustomDataDirectoryInfos[i].Name;
                                                int intLoopIndex =
                                                    lstSavedCustomDataDirectoryNames.IndexOf(strLoopCustomDataName);
                                                if (intLoopIndex < 0)
                                                    intReturn -= intBaselineCustomDataCount * intBaseline;
                                                else
                                                    intReturn -= Math.Abs(i - intLoopIndex) * intBaseline;
                                            }

                                            int intMismatchCount = lstSavedCustomDataDirectoryNames.Count(x =>
                                                objOptionsToCheck.EnabledCustomDataDirectoryInfos.All(
                                                    y => y.Name != x));
                                            if (intMismatchCount != 0)
                                                intReturn -= intMismatchCount * intBaselineCustomDataCount *
                                                             intBaseline;
                                        }

                                        using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(
                                                   Utils.StringHashSetPool, out HashSet<string> setDummyBooks))
                                        {
                                            setDummyBooks.AddRange(setSavedBooks);
                                            IReadOnlyCollection<string> setOtherBooks
                                                = await objOptionsToCheck.GetBooksAsync(token).ConfigureAwait(false);
                                            int intExtraBooks = setOtherBooks.Count(x => !setDummyBooks.Remove(x));
                                            setDummyBooks.ExceptWith(setOtherBooks);
                                            // Missing books are weighted a lot more heavily than extra books
                                            intReturn -= (setDummyBooks.Count * (intBaselineCustomDataCount + byte.MaxValue)
                                                          + intExtraBooks) * intBaseline;
                                        }

                                        return intReturn;
                                    }

                                    blnSuccess =
                                        (blnSync
                                            ? SettingsManager.LoadedCharacterSettings
                                            : await SettingsManager.GetLoadedCharacterSettingsAsync(token)
                                                .ConfigureAwait(false)).TryGetValue(_strSettingsKey,
                                            out objProspectiveSettings);

                                    if (!blnSuccess && blnHashCodeSuccess)
                                    {
                                        CharacterSettings objHashCodeMatchSettings
                                            = blnSync
                                                ? SettingsManager.LoadedCharacterSettings.FirstOrDefault(
                                                    x => x.Value.GetEquatableHashCode(token) == intSettingsHashCode).Value
                                                : (await (await SettingsManager
                                                                .GetLoadedCharacterSettingsAsync(token)
                                                                .ConfigureAwait(false))
                                                         .FirstOrDefaultAsync(
                                                             async x => await x.Value.GetEquatableHashCodeAsync(token)
                                                                               .ConfigureAwait(false)
                                                                        == intSettingsHashCode, token)
                                                         .ConfigureAwait(false)).Value;
                                        if (objHashCodeMatchSettings?.BuildMethod == eSavedBuildMethod)
                                        {
                                            blnSuccess = true;
                                            objProspectiveSettings = objHashCodeMatchSettings;
                                        }
                                    }

                                    if (!blnSuccess)
                                    {
                                        // Prompt if we want to switch options or leave
                                        if (!Utils.IsUnitTest && showWarnings)
                                        {
                                            if ((blnSync
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    ? Program.ShowScrollableMessageBox(
                                                        string.Format(
                                                            GlobalSettings.CultureInfo,
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            LanguageManager.GetString(
                                                                "Message_CharacterOptions_CannotLoadSetting",
                                                                token: token),
                                                            Path.GetFileNameWithoutExtension(_strSettingsKey)),
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        LanguageManager.GetString(
                                                            "MessageTitle_CharacterOptions_CannotLoadSetting",
                                                            token: token),
                                                        MessageBoxButtons.YesNo, MessageBoxIcon.Error)
                                                    : await Program.ShowScrollableMessageBoxAsync(
                                                        string.Format(
                                                            GlobalSettings.CultureInfo,
                                                            await LanguageManager.GetStringAsync(
                                                                "Message_CharacterOptions_CannotLoadSetting",
                                                                token: token).ConfigureAwait(false),
                                                            Path.GetFileNameWithoutExtension(_strSettingsKey)),
                                                        await LanguageManager.GetStringAsync(
                                                            "MessageTitle_CharacterOptions_CannotLoadSetting",
                                                            token: token).ConfigureAwait(false),
                                                        MessageBoxButtons.YesNo, MessageBoxIcon.Error,
                                                        token: token).ConfigureAwait(false)) == DialogResult.No)
                                            {
                                                return false;
                                            }

                                            blnShowSelectBP = true;
                                        }

                                        // Set up interim options for selection by build method
                                        string strReplacementSettingsKey = string.Empty;
                                        int intMostSuitable = int.MinValue;
                                        foreach (KeyValuePair<string, CharacterSettings> kvpLoopOptions in
                                                 SettingsManager.LoadedCharacterSettings)
                                        {
                                            token.ThrowIfCancellationRequested();
                                            int intLoopScore
                                                = blnSync
                                                    ? CalculateCharacterSettingsMatchScore(kvpLoopOptions.Value)
                                                    : await CalculateCharacterSettingsMatchScoreAsync(kvpLoopOptions
                                                        .Value).ConfigureAwait(false);
                                            if (intLoopScore > intMostSuitable)
                                            {
                                                intMostSuitable = intLoopScore;
                                                strReplacementSettingsKey = kvpLoopOptions.Key;
                                            }
                                        }

                                        if (string.IsNullOrEmpty(strReplacementSettingsKey))
                                            blnSuccess = false;
                                        else
                                            blnSuccess =
                                                (blnSync
                                                    ? SettingsManager.LoadedCharacterSettings
                                                    : await SettingsManager.GetLoadedCharacterSettingsAsync(token)
                                                        .ConfigureAwait(false)).TryGetValue(strReplacementSettingsKey,
                                                    out objProspectiveSettings);

                                        if (!blnSuccess)
                                        {
                                            strReplacementSettingsKey
                                                = GlobalSettings.DefaultCharacterSettingDefaultValue;
                                            blnSuccess = (blnSync
                                                ? SettingsManager.LoadedCharacterSettings
                                                : await SettingsManager.GetLoadedCharacterSettingsAsync(token)
                                                    .ConfigureAwait(false)).TryGetValue(
                                                strReplacementSettingsKey, out objProspectiveSettings);
                                            if (!blnSuccess)
                                            {
                                                objProspectiveSettings
                                                    = (blnSync
                                                        ? SettingsManager.LoadedCharacterSettings
                                                        : await SettingsManager.GetLoadedCharacterSettingsAsync(token)
                                                            .ConfigureAwait(false)).FirstOrDefault().Value;
                                                strReplacementSettingsKey = blnSync
                                                    ? objProspectiveSettings.DictionaryKey
                                                    : await objProspectiveSettings.GetDictionaryKeyAsync(token).ConfigureAwait(false);
                                            }
                                        }

                                        _strSettingsKey = strReplacementSettingsKey;
                                        if (blnSync)
                                            LoadAsDirty = true;
                                        else
                                            await SetLoadAsDirtyAsync(true, token).ConfigureAwait(false);
                                    }
                                    else if (!(blnSync ? Created : await GetCreatedAsync(token).ConfigureAwait(false)) && objProspectiveSettings.BuildMethod != eSavedBuildMethod)
                                    {
                                        // Prompt if we want to switch options or leave
                                        if (!Utils.IsUnitTest && showWarnings)
                                        {
                                            if ((blnSync
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    ? Program.ShowScrollableMessageBox(
                                                        string.Format(
                                                            GlobalSettings.CultureInfo,
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            LanguageManager.GetString(
                                                                "Message_CharacterOptions_DesyncBuildMethod",
                                                                token: token),
                                                            Path.GetFileNameWithoutExtension(_strSettingsKey),
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            LanguageManager.GetString(
                                                                "String_" + objProspectiveSettings
                                                                    .BuildMethod, token: token),
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            LanguageManager.GetString(
                                                                "String_" + eSavedBuildMethod, token: token)),
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        LanguageManager.GetString(
                                                            "MessageTitle_CharacterOptions_DesyncBuildMethod",
                                                            token: token),
                                                        MessageBoxButtons.YesNo, MessageBoxIcon.Error)
                                                    : await Program.ShowScrollableMessageBoxAsync(
                                                        string.Format(
                                                            GlobalSettings.CultureInfo,
                                                            await LanguageManager.GetStringAsync(
                                                                "Message_CharacterOptions_DesyncBuildMethod",
                                                                token: token).ConfigureAwait(false),
                                                            Path.GetFileNameWithoutExtension(_strSettingsKey),
                                                            await LanguageManager.GetStringAsync(
                                                                    "String_" + objProspectiveSettings
                                                                        .BuildMethod, token: token)
                                                                .ConfigureAwait(false),
                                                            await LanguageManager.GetStringAsync(
                                                                    "String_" + eSavedBuildMethod,
                                                                    token: token)
                                                                .ConfigureAwait(false)),
                                                        await LanguageManager.GetStringAsync(
                                                            "MessageTitle_CharacterOptions_DesyncBuildMethod",
                                                            token: token).ConfigureAwait(false),
                                                        MessageBoxButtons.YesNo, MessageBoxIcon.Error,
                                                        token: token).ConfigureAwait(false)) == DialogResult.No)
                                            {
                                                return false;
                                            }

                                            blnShowSelectBP = true;
                                        }

                                        // Set up interim options for selection by build method
                                        string strReplacementSettingsKey = string.Empty;
                                        int intMostSuitable = int.MinValue;
                                        foreach (KeyValuePair<string, CharacterSettings> kvpLoopOptions in SettingsManager.LoadedCharacterSettings)
                                        {
                                            token.ThrowIfCancellationRequested();
                                            int intLoopScore
                                                = blnSync
                                                    ? CalculateCharacterSettingsMatchScore(kvpLoopOptions.Value)
                                                    : await CalculateCharacterSettingsMatchScoreAsync(kvpLoopOptions
                                                        .Value).ConfigureAwait(false);
                                            if (intLoopScore > intMostSuitable)
                                            {
                                                intMostSuitable = intLoopScore;
                                                strReplacementSettingsKey = kvpLoopOptions.Key;
                                            }
                                        }

                                        if (string.IsNullOrEmpty(strReplacementSettingsKey))
                                            blnSuccess = false;
                                        else
                                            blnSuccess = (blnSync
                                                ? SettingsManager.LoadedCharacterSettings
                                                : await SettingsManager.GetLoadedCharacterSettingsAsync(token)
                                                    .ConfigureAwait(false)).TryGetValue(
                                                strReplacementSettingsKey, out objProspectiveSettings);

                                        if (!blnSuccess)
                                        {
                                            strReplacementSettingsKey
                                                = GlobalSettings.DefaultCharacterSettingDefaultValue;
                                            blnSuccess = (blnSync
                                                ? SettingsManager.LoadedCharacterSettings
                                                : await SettingsManager.GetLoadedCharacterSettingsAsync(token)
                                                    .ConfigureAwait(false)).TryGetValue(
                                                strReplacementSettingsKey, out objProspectiveSettings);
                                            if (!blnSuccess)
                                            {
                                                objProspectiveSettings
                                                    = (blnSync
                                                        ? SettingsManager.LoadedCharacterSettings
                                                        : await SettingsManager.GetLoadedCharacterSettingsAsync(token)
                                                            .ConfigureAwait(false)).FirstOrDefault().Value;
                                                strReplacementSettingsKey = blnSync
                                                    ? objProspectiveSettings.DictionaryKey
                                                    : await objProspectiveSettings.GetDictionaryKeyAsync(token).ConfigureAwait(false);
                                            }
                                        }

                                        _strSettingsKey = strReplacementSettingsKey;
                                        if (blnSync)
                                            LoadAsDirty = true;
                                        else
                                            await SetLoadAsDirtyAsync(true, token).ConfigureAwait(false);
                                    }
                                    else if (!Utils.IsUnitTest && showWarnings)
                                    {
                                        // Legacy load stuff
                                        if (setSavedBooks.Count > 0 || lstSavedCustomDataDirectoryNames.Count > 0)
                                        {
                                            // More books is fine, so just test if the stored book list is a subset of the current option's book list
                                            bool blnPromptConfirmSetting =
                                                !setSavedBooks.IsSubsetOf(objProspectiveSettings.Books);
                                            if (!blnPromptConfirmSetting)
                                            {
                                                IReadOnlyList<CustomDataDirectoryInfo> lstProspectiveInfos
                                                    = blnSync
                                                        ? objProspectiveSettings.EnabledCustomDataDirectoryInfos
                                                        : await objProspectiveSettings
                                                            .GetEnabledCustomDataDirectoryInfosAsync(token).ConfigureAwait(false);
                                                // More custom data directories is not fine because additional ones might apply rules that weren't present before, so prompt
                                                blnPromptConfirmSetting = lstSavedCustomDataDirectoryNames.Count !=
                                                                          lstProspectiveInfos.Count;
                                                if (!blnPromptConfirmSetting)
                                                {
                                                    // Check to make sure all the names are the same
                                                    for (int i = 0; i < lstSavedCustomDataDirectoryNames.Count; ++i)
                                                    {
                                                        if (lstSavedCustomDataDirectoryNames[i]
                                                            != lstProspectiveInfos[i].Name)
                                                        {
                                                            blnPromptConfirmSetting = true;
                                                            break;
                                                        }
                                                    }
                                                }
                                            }

                                            if (blnPromptConfirmSetting)
                                            {
                                                DialogResult eShowBPResult = blnSync
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    ? Program.ShowScrollableMessageBox(
                                                        string.Format(
                                                            GlobalSettings.CultureInfo,
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            LanguageManager.GetString(
                                                                "Message_CharacterOptions_DesyncBooksOrCustomData",
                                                                token: token),
                                                            objProspectiveSettings.Name),
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        LanguageManager.GetString(
                                                            "MessageTitle_CharacterOptions_DesyncBooksOrCustomData",
                                                            token: token),
                                                        MessageBoxButtons.YesNoCancel, MessageBoxIcon.Warning)
                                                    : await Program.ShowScrollableMessageBoxAsync(
                                                        string.Format(
                                                            GlobalSettings.CultureInfo,
                                                            await LanguageManager.GetStringAsync(
                                                                "Message_CharacterOptions_DesyncBooksOrCustomData",
                                                                token: token).ConfigureAwait(false),
                                                            objProspectiveSettings.Name),
                                                        await LanguageManager.GetStringAsync(
                                                            "MessageTitle_CharacterOptions_DesyncBooksOrCustomData",
                                                            token: token).ConfigureAwait(false),
                                                        MessageBoxButtons.YesNoCancel, MessageBoxIcon.Warning,
                                                        token: token).ConfigureAwait(false);
                                                if (eShowBPResult == DialogResult.Cancel)
                                                {
                                                    return false;
                                                }

                                                blnShowSelectBP = eShowBPResult == DialogResult.Yes;
                                            }
                                        }
                                        else if (blnHashCodeSuccess
                                                 && !objProspectiveSettings.BuiltInOption
                                                 // Need to make sure that the save was made in the same version of Chummer, otherwise we can get a hash code mismatch from settings themselves changing
                                                 && LastSavedVersion == Utils.CurrentChummerVersion
                                                 && (blnSync
                                                     // ReSharper disable once MethodHasAsyncOverload
                                                     ? objProspectiveSettings.GetEquatableHashCode(token)
                                                     : await objProspectiveSettings.GetEquatableHashCodeAsync(
                                                         token).ConfigureAwait(false))
                                                 != intSettingsHashCode)
                                        {
                                            DialogResult eShowBPResult = blnSync
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                ? Program.ShowScrollableMessageBox(
                                                    string.Format(
                                                        GlobalSettings.CultureInfo,
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        LanguageManager.GetString(
                                                            "Message_CharacterOptions_DesyncFromHashCode",
                                                            token: token),
                                                        objProspectiveSettings.Name),
                                                    // ReSharper disable once MethodHasAsyncOverload
                                                    LanguageManager.GetString(
                                                        "MessageTitle_CharacterOptions_DesyncFromHashCode",
                                                        token: token),
                                                    MessageBoxButtons.YesNoCancel, MessageBoxIcon.Warning)
                                                : await Program.ShowScrollableMessageBoxAsync(
                                                    string.Format(
                                                        GlobalSettings.CultureInfo,
                                                        await LanguageManager.GetStringAsync(
                                                            "Message_CharacterOptions_DesyncFromHashCode",
                                                            token: token).ConfigureAwait(false),
                                                        objProspectiveSettings.Name),
                                                    await LanguageManager.GetStringAsync(
                                                        "MessageTitle_CharacterOptions_DesyncFromHashCode",
                                                        token: token).ConfigureAwait(false),
                                                    MessageBoxButtons.YesNoCancel, MessageBoxIcon.Warning,
                                                    token: token).ConfigureAwait(false);
                                            if (eShowBPResult == DialogResult.Cancel)
                                            {
                                                return false;
                                            }

                                            blnShowSelectBP = eShowBPResult == DialogResult.Yes;
                                        }
                                    }
                                }

                                if (blnSync)
                                    Settings = objProspectiveSettings;
                                else
                                    await SetSettingsAsync(objProspectiveSettings, token).ConfigureAwait(false);

                                if (blnShowSelectBP)
                                {
                                    if (blnSync)
                                    {
                                        LoadAsDirty = true;
                                        // ReSharper disable once MethodHasAsyncOverload
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        using (ThreadSafeForm<SelectBuildMethod> frmPickBP
                                               = ThreadSafeForm<SelectBuildMethod>.Get(
                                                   () => new SelectBuildMethod(this, true)))
                                        {
                                            // ReSharper disable once MethodHasAsyncOverload
                                            if (frmPickBP.ShowDialogSafe(this, token) != DialogResult.OK)
                                            {
                                                return false;
                                            }
                                        }
                                    }
                                    else
                                    {
                                        await SetLoadAsDirtyAsync(true, token).ConfigureAwait(false);
                                        using (ThreadSafeForm<SelectBuildMethod> frmPickBP
                                               = await ThreadSafeForm<SelectBuildMethod>
                                                       .GetAsync(() => new SelectBuildMethod(this, true), token)
                                                       .ConfigureAwait(false))
                                        {
                                            if (await frmPickBP.ShowDialogSafeAsync(this, token).ConfigureAwait(false)
                                                != DialogResult.OK)
                                            {
                                                return false;
                                            }
                                        }
                                    }
                                }

                                if (xmlCharacterNavigator.TryGetDecFieldQuickly("essenceatspecialstart",
                                        ref _decEssenceAtSpecialStart) &&
                                    _decEssenceAtSpecialStart > ESS.MetatypeMaximum)
                                {
                                    // fix to work around a mistake made when saving decimal values in previous versions.
                                    _decEssenceAtSpecialStart /= 10;
                                }

                                xmlCharacterNavigator.TryGetStringFieldQuickly("createdversion",
                                                                               ref _strVersionCreated);

                                // Metatype information.
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("iscritter", ref _blnIsCritter);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("metatype", ref _strMetatype);
                                if (!xmlCharacterNavigator.TryGetGuidFieldQuickly("metatypeid", ref _guiMetatype))
                                {
                                    // ReSharper disable once MethodHasAsyncOverload
                                    XPathNavigator objMetatypeNode = blnSync
                                        ? GetNodeXPath(true, token: token)
                                        : await GetNodeXPathAsync(true, token: token).ConfigureAwait(false);
                                    if (objMetatypeNode == null || !Guid.TryParse(
                                            objMetatypeNode.SelectSingleNodeAndCacheExpression("id", token)?.Value, out _guiMetatype))
                                    {
                                        return false;
                                    }
                                }

                                xmlCharacterNavigator.TryGetStringFieldQuickly("movement", ref _strMovement);

                                xmlCharacterNavigator.TryGetStringFieldQuickly("walk", ref _strWalk);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("run", ref _strRun);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("sprint", ref _strSprint);

                                _strRunAlt = xmlCharacterNavigator.SelectSingleNodeAndCacheExpression("run/@alt", token)
                                                 ?.Value ??
                                             string.Empty;
                                _strWalkAlt = xmlCharacterNavigator.SelectSingleNodeAndCacheExpression("walk/@alt", token)
                                                  ?.Value ??
                                              string.Empty;
                                _strSprintAlt = xmlCharacterNavigator
                                                    .SelectSingleNodeAndCacheExpression("sprint/@alt", token)?.Value ??
                                                string.Empty;

                                xmlCharacterNavigator.TryGetInt32FieldQuickly("initiativedice",
                                                                              ref _intInitiativeDice);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("metatypebp", ref _intMetatypeBP);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("metavariant", ref _strMetavariant);
                                //Shim for characters created prior to Run Faster Errata
                                if (_strMetavariant == "Cyclopean")
                                    _strMetavariant = "Cyclops";
                                // Legacy shim for characters with no metavariant still saved with "None" as their metavariant
                                else if (_strMetavariant == "None")
                                    _strMetavariant = string.Empty;

                                //Shim for metavariants that were saved with an incorrect metatype string.
                                if (!string.IsNullOrEmpty(_strMetavariant) && _strMetatype == _strMetavariant)
                                {
                                    // ReSharper disable once MethodHasAsyncOverload
                                    _strMetatype = (blnSync
                                            ? GetNodeXPath(true, token: token)
                                            : await GetNodeXPathAsync(true, token: token).ConfigureAwait(false))
                                        ?.SelectSingleNodeAndCacheExpression("name", token)?.Value ?? "Human";
                                }

                                if (string.IsNullOrEmpty(_strMetavariant))
                                {
                                    _guiMetavariant = Guid.Empty;
                                }
                                else if (!xmlCharacterNavigator.TryGetGuidFieldQuickly("metavariantid",
                                        ref _guiMetavariant))
                                {
                                    XPathNavigator objMetavariantNode = blnSync
                                        // ReSharper disable once MethodHasAsyncOverload
                                        ? this.GetNodeXPath(token: token)
                                        : await this.GetNodeXPathAsync(token: token).ConfigureAwait(false);
                                    if (!Guid.TryParse(
                                            objMetavariantNode?.SelectSingleNodeAndCacheExpression("id", token)?.Value,
                                            out _guiMetavariant))
                                        _guiMetavariant = Guid.Empty;
                                }
                                // Empty metavariant GUID takes precedence over non-empty metavariant name
                                else if (_guiMetavariant == Guid.Empty)
                                {
                                    _strMetavariant = string.Empty;
                                }

                                bool blnDoSourceFetch =
                                    !xmlCharacterNavigator.TryGetStringFieldQuickly("source", ref _strSource) ||
                                    string.IsNullOrEmpty(_strSource);
                                // ReSharper disable once ConvertIfToOrExpression
                                if (!xmlCharacterNavigator.TryGetStringFieldQuickly("page", ref _strPage) ||
                                    string.IsNullOrEmpty(_strPage) || _strPage == "0")
                                    blnDoSourceFetch = true;
                                if (blnDoSourceFetch)
                                {
                                    XPathNavigator xmlCharNode
                                        = blnSync
                                            // ReSharper disable once MethodHasAsyncOverload
                                            ? this.GetNodeXPath(token: token)
                                            : await this.GetNodeXPathAsync(token: token).ConfigureAwait(false);
                                    if (xmlCharNode != null)
                                    {
                                        _strSource = xmlCharNode.SelectSingleNodeAndCacheExpression("source", token)?.Value
                                                     ?? _strSource;
                                        _strPage = xmlCharNode.SelectSingleNodeAndCacheExpression("page", token)?.Value
                                                   ?? _strPage;
                                    }
                                }

                                xmlCharacterNavigator.TryGetStringFieldQuickly("metatypecategory",
                                                                               ref _strMetatypeCategory);

                                // General character information.
                                xmlCharacterNavigator.TryGetStringFieldQuickly("name", ref _strName);
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    LoadMugshots(xmlCharacterNavigator, token);
                                else
                                    await LoadMugshotsAsync(xmlCharacterNavigator, token).ConfigureAwait(false);
                                if (!xmlCharacterNavigator.TryGetStringFieldQuickly("gender", ref _strGender))
                                    xmlCharacterNavigator.TryGetStringFieldQuickly("sex", ref _strGender);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("age", ref _strAge);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("eyes", ref _strEyes);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("height", ref _strHeight);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("weight", ref _strWeight);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("skin", ref _strSkin);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("hair", ref _strHair);
                                xmlCharacterNavigator.TryGetMultiLineStringFieldQuickly("description",
                                    ref _strDescription);
                                xmlCharacterNavigator.TryGetMultiLineStringFieldQuickly("background",
                                    ref _strBackground);
                                xmlCharacterNavigator.TryGetMultiLineStringFieldQuickly("concept", ref _strConcept);
                                xmlCharacterNavigator.TryGetMultiLineStringFieldQuickly("notes", ref _strNotes);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("alias", ref _strAlias);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("playername", ref _strPlayerName);
                                xmlCharacterNavigator.TryGetMultiLineStringFieldQuickly("gamenotes",
                                    ref _strGameNotes);
                                if (!xmlCharacterNavigator.TryGetStringFieldQuickly("primaryarm",
                                        ref _strPrimaryArm))
                                    _strPrimaryArm = "Right";

                                xmlCharacterNavigator.TryGetStringFieldQuickly("prioritymetatype",
                                                                               ref _strPriorityMetatype);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("priorityattributes",
                                                                               ref _strPriorityAttributes);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("priorityspecial",
                                                                               ref _strPrioritySpecial);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("priorityskills",
                                                                               ref _strPrioritySkills);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("priorityresources",
                                                                               ref _strPriorityResources);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("prioritytalent",
                                                                               ref _strPriorityTalent);

                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    _lstPrioritySkills.Clear();
                                else
                                    await _lstPrioritySkills.ClearAsync(token).ConfigureAwait(false);
                                foreach (XPathNavigator xmlSkillName in xmlCharacterNavigator.SelectAndCacheExpression("priorityskills/priorityskill", token))
                                {
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstPrioritySkills.Add(xmlSkillName.Value);
                                    else
                                        await _lstPrioritySkills.AddAsync(xmlSkillName.Value, token)
                                                                .ConfigureAwait(false);
                                }

                                string strSkill1 = string.Empty;
                                string strSkill2 = string.Empty;
                                if (xmlCharacterNavigator.TryGetStringFieldQuickly("priorityskill1",
                                        ref strSkill1) &&
                                    !string.IsNullOrEmpty(strSkill1))
                                {
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstPrioritySkills.Add(strSkill1);
                                    else
                                        await _lstPrioritySkills.AddAsync(strSkill1, token).ConfigureAwait(false);
                                }

                                if (xmlCharacterNavigator.TryGetStringFieldQuickly("priorityskill2",
                                        ref strSkill2) &&
                                    !string.IsNullOrEmpty(strSkill2))
                                {
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstPrioritySkills.Add(strSkill2);
                                    else
                                        await _lstPrioritySkills.AddAsync(strSkill2, token).ConfigureAwait(false);
                                }

                                xmlCharacterNavigator.TryGetBoolFieldQuickly("possessed", ref _blnPossessed);

                                xmlCharacterNavigator.TryGetInt32FieldQuickly("contactpoints",
                                                                              ref _intCachedContactPoints);
                                xmlCharacterNavigator.TryGetDecFieldQuickly("basecarrylimit",
                                                                            ref _decCachedBaseCarryLimit);
                                xmlCharacterNavigator.TryGetDecFieldQuickly("baseliftlimit",
                                                                            ref _decCachedBaseLiftLimit);
                                xmlCharacterNavigator.TryGetDecFieldQuickly("totalcarriedweight",
                                                                            ref _decCachedTotalCarriedWeight);
                                xmlCharacterNavigator.TryGetDecFieldQuickly("encumbranceinterval",
                                                                            ref _decCachedEncumbranceInterval);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("cfplimit", ref _intCFPLimit);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("ainormalprogramlimit",
                                                                              ref _intAINormalProgramLimit);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("aiadvancedprogramlimit",
                                                                              ref _intAIAdvancedProgramLimit);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("currentcounterspellingdice",
                                                                              ref _intCurrentCounterspellingDice);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("currentliftcarryhits",
                                                                              ref _intCurrentLiftCarryHits);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("spelllimit", ref _intFreeSpells);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("karma", ref _intKarma);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("totalkarma", ref _intTotalKarma);

                                xmlCharacterNavigator.TryGetInt32FieldQuickly("special", ref _intSpecial);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("totalspecial", ref _intTotalSpecial);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("totalattributes",
                                                                              ref _intTotalAttributes);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("edgeused", ref _intEdgeUsed);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("streetcred", ref _intStreetCred);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("notoriety", ref _intNotoriety);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("publicawareness",
                                                                              ref _intPublicAwareness);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("burntstreetcred",
                                                                              ref _intBurntStreetCred);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("baseastralreputation",
                                                                              ref _intBaseAstralReputation);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("basewildreputation",
                                                                              ref _intBaseWildReputation);
                                xmlCharacterNavigator.TryGetDecFieldQuickly("nuyen", ref _decNuyen);
                                xmlCharacterNavigator.TryGetDecFieldQuickly("startingnuyen", ref _decStartingNuyen);
                                xmlCharacterNavigator.TryGetDecFieldQuickly("nuyenbp", ref _decNuyenBP);

                                xmlCharacterNavigator.TryGetBoolFieldQuickly("adept", ref _blnAdeptEnabled);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("magician", ref _blnMagicianEnabled);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("technomancer",
                                                                             ref _blnTechnomancerEnabled);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("ai", ref _blnAdvancedProgramsEnabled);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("cyberwaredisabled",
                                                                             ref _blnCyberwareDisabled);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("initiationdisabled",
                                                                             ref _blnInitiationDisabled);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("critter", ref _blnCritterEnabled);

                                xmlCharacterNavigator.TryGetDecFieldQuickly("prototypetranshuman",
                                                                            ref _decPrototypeTranshuman);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("magenabled", ref _blnMAGEnabled);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("initiategrade",
                                                                              ref _intInitiateGrade);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("resenabled", ref _blnRESEnabled);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("submersiongrade",
                                                                              ref _intSubmersionGrade);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("depenabled", ref _blnDEPEnabled);
                                // Legacy shim
                                if (!_blnCreated && !_blnMAGEnabled && !_blnRESEnabled && !_blnDEPEnabled)
                                    _decEssenceAtSpecialStart = decimal.MinValue;
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("groupmember", ref _blnGroupMember);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("groupname", ref _strGroupName);
                                xmlCharacterNavigator.TryGetMultiLineStringFieldQuickly("groupnotes",
                                    ref _strGroupNotes);
                                //end load_char_misc
                            }

                            XmlNodeList objXmlNodeList;
                            XmlNodeList objXmlLocationList;
                            XmlNode xmlRootQualitiesNode;

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("String_MentorSpirit", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("String_MentorSpirit",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_mentorspirit", loadActivity))
                            {
                                // Improvements.
                                using (objXmlNodeList = objXmlCharacter.SelectNodes("mentorspirits/mentorspirit"))
                                {
                                    foreach (XmlNode objXmlMentor in objXmlNodeList)
                                    {
                                        MentorSpirit objMentor = new MentorSpirit(this, objXmlMentor);
                                        try
                                        {
                                            if (blnSync)
                                            {
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                objMentor.Load(objXmlMentor);
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                _lstMentorSpirits.Add(objMentor);
                                            }
                                            else
                                            {
                                                await objMentor.LoadAsync(objXmlMentor, token).ConfigureAwait(false);
                                                await _lstMentorSpirits.AddAsync(objMentor, token).ConfigureAwait(false);
                                            }
                                        }
                                        catch
                                        {
                                            if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverload
                                                objMentor.Dispose();
                                            else
                                                await objMentor.DisposeAsync().ConfigureAwait(false);
                                            throw;
                                        }
                                    }
                                }

                                //using finish("load_char_mentorspirit");
                            }

                            List<Improvement> lstCyberadeptSweepGrades =
                                new List<Improvement>(InitiationGrades.Count);

                            // Fastest way to clear is to just create a new bag and then interlock at the end
                            ConcurrentBag<string> lstInternalIdsNeedingReapplyImprovements
                                = new ConcurrentBag<string>();

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("Tab_Improvements", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("Tab_Improvements",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_imp", loadActivity))
                            {
                                // Improvements.
                                objXmlNodeList = objXmlCharacter.SelectNodes("improvements/improvement");
                                bool blnRemoveImprovements = Utils.IsUnitTest;
                                string strCharacterInnerXml = objXmlCharacter.InnerXmlViaPool(token);
                                int intCharacterInnerXmlLength = strCharacterInnerXml.Length;
                                foreach (XmlNode objXmlImprovement in objXmlNodeList)
                                {
                                    // First check if this is an orphaned improvement
                                    if ((blnRemoveImprovements || showWarnings) &&
                                        objXmlImprovement["custom"]?.InnerTextViaPool(token) != bool.TrueString &&
                                        !string.IsNullOrEmpty(strCharacterInnerXml))
                                    {
                                        string strLoopSourceName = objXmlImprovement["sourcename"]?.InnerTextViaPool(token);
                                        if (!string.IsNullOrEmpty(strLoopSourceName)
                                            && strLoopSourceName.IsGuid())
                                        {
                                            // Specialized version of ContainsAny that has been optimized for this specific case because it's a bottleneck
                                            bool ContainsAnySourceId(string strId)
                                            {
                                                if (strCharacterInnerXml.Length < strId.Length + 13)
                                                    return false;

                                                string strCommonNeedle = "id>" + strId + "</";
                                                string strNeedle1 = "<guid>" + strId + "</guid>";
                                                int intNeedle1Length = strNeedle1.Length;
                                                ReadOnlySpan<char> spnNeedle1 = strNeedle1.AsSpan();
                                                string strNeedle2 = "<metatypeid>" + strId + "</metatypeid>";
                                                int intNeedle2Length = strNeedle2.Length;
                                                ReadOnlySpan<char> spnNeedle2 = strNeedle2.AsSpan();
                                                string strNeedle3 = "<metavariantid>" + strId +
                                                                    "</metavariantid>";
                                                int intNeedle3Length = strNeedle3.Length;
                                                ReadOnlySpan<char> spnNeedle3 = strNeedle3.AsSpan();
                                                for (int intLoopIndex = strCharacterInnerXml.IndexOf(
                                                         strCommonNeedle, 3,
                                                         StringComparison.OrdinalIgnoreCase);
                                                     intLoopIndex >= 3 &&
                                                     intCharacterInnerXmlLength - intLoopIndex + 3 >
                                                     intNeedle1Length;
                                                     intLoopIndex = strCharacterInnerXml.IndexOf(strCommonNeedle,
                                                         intLoopIndex + 1,
                                                         StringComparison.OrdinalIgnoreCase))
                                                {
                                                    if (strCharacterInnerXml.AsSpan(intLoopIndex - 3, intNeedle1Length)
                                                        .Equals(spnNeedle1, StringComparison.OrdinalIgnoreCase))
                                                        return true;
                                                    if (intLoopIndex < 9 ||
                                                        intCharacterInnerXmlLength - intLoopIndex + 9 <
                                                        intNeedle2Length)
                                                        continue;
                                                    if (strCharacterInnerXml.AsSpan(intLoopIndex - 9, intNeedle2Length)
                                                        .Equals(spnNeedle2, StringComparison.OrdinalIgnoreCase))
                                                        return true;
                                                    if (intLoopIndex < 12 ||
                                                        intCharacterInnerXmlLength - intLoopIndex + 12 <
                                                        intNeedle3Length)
                                                        continue;
                                                    if (strCharacterInnerXml.AsSpan(intLoopIndex - 12, intNeedle3Length)
                                                        .Equals(spnNeedle3, StringComparison.OrdinalIgnoreCase))
                                                        return true;
                                                }

                                                return false;
                                            }

                                            if (!ContainsAnySourceId(strLoopSourceName))
                                            {
                                                //Utils.BreakIfDebug();
                                                if (blnRemoveImprovements)
                                                    continue;

                                                if (blnSync)
                                                {
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    if (Program.ShowScrollableMessageBox(
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            LanguageManager.GetString(
                                                                "Message_OrphanedImprovements", token: token),
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            LanguageManager.GetString(
                                                                "MessageTitle_OrphanedImprovements",
                                                                token: token),
                                                            MessageBoxButtons.YesNo, MessageBoxIcon.Error) ==
                                                        DialogResult.Yes)
                                                    {
                                                        blnRemoveImprovements = true;
                                                        continue;
                                                    }
                                                }
                                                else if (await Program.ShowScrollableMessageBoxAsync(
                                                             await LanguageManager.GetStringAsync(
                                                                     "Message_OrphanedImprovements",
                                                                     token: token)
                                                                 .ConfigureAwait(false),
                                                             await LanguageManager.GetStringAsync(
                                                                     "MessageTitle_OrphanedImprovements",
                                                                     token: token)
                                                                 .ConfigureAwait(false),
                                                             MessageBoxButtons.YesNo, MessageBoxIcon.Error,
                                                             token: token).ConfigureAwait(false) ==
                                                         DialogResult.Yes)
                                                {
                                                    blnRemoveImprovements = true;
                                                    continue;
                                                }

                                                return false;
                                            }
                                        }
                                    }

                                    string strImprovementSource =
                                        objXmlImprovement["improvementsource"]?.InnerTextViaPool(token);
                                    switch (strImprovementSource)
                                    {
                                        // Do not load condition monitor improvements from older versions of Chummer
                                        case "ConditionMonitor":
                                            continue;
                                        // Load Edge use improvements from older versions of Chummer directly into Character's Edge Use property
                                        case "EdgeUse":
                                            decimal decOldEdgeUsed = 0;
                                            if (objXmlImprovement.TryGetDecFieldQuickly("aug",
                                                    ref decOldEdgeUsed))
                                            {
                                                if (blnSync)
                                                    EdgeUsed = (-decOldEdgeUsed).StandardRound();
                                                else
                                                    await SetEdgeUsedAsync((-decOldEdgeUsed).StandardRound(), token).ConfigureAwait(false);
                                            }
                                            continue;
                                        case nameof(Improvement.ImprovementSource.EssenceLoss):
                                        case nameof(Improvement.ImprovementSource.EssenceLossChargen):
                                            // Do not load essence loss improvements if this character does not have any attributes affected by essence loss
                                            if (_decEssenceAtSpecialStart == decimal.MinValue)
                                                continue;
                                            break;
                                    }

                                    Improvement objImprovement = new Improvement(this);
                                    try
                                    {
                                        token.ThrowIfCancellationRequested();
                                        objImprovement.Load(objXmlImprovement);
                                        // This is initially set to false make sure no property changers are triggered
                                        objImprovement.SetupComplete = true;
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstImprovements.Add(objImprovement);
                                        else
                                            await _lstImprovements.AddAsync(objImprovement, token)
                                                .ConfigureAwait(false);

                                        if (objImprovement.ImproveType ==
                                            Improvement.ImprovementType.SkillsoftAccess &&
                                            objImprovement.Value == 0)
                                        {
                                            lstInternalIdsNeedingReapplyImprovements.Add(objImprovement
                                                .SourceName);
                                        }
                                        // Cyberadept fix
                                        else if (LastSavedVersion <= new ValueVersion(5, 212, 78)
                                                 && objImprovement.ImproveSource ==
                                                 Improvement.ImprovementSource.Echo
                                                 && objImprovement.ImproveType ==
                                                 Improvement.ImprovementType.Attribute
                                                 && objImprovement.ImprovedName == "RESBase"
                                                 && objImprovement.Value > 0
                                                 && objImprovement.Value == objImprovement.Augmented)
                                        {
                                            // Cyberadept in these versions was an echo. It is no longer an echo, and so needs a more complicated reapplication
                                            if (blnSync
                                                    ? Settings.SpecialKarmaCostBasedOnShownValue
                                                    : await (await GetSettingsAsync(token).ConfigureAwait(false)).GetSpecialKarmaCostBasedOnShownValueAsync(token).ConfigureAwait(false))
                                            {
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    _lstImprovements.Remove(objImprovement);
                                                else
                                                    await _lstImprovements.RemoveAsync(objImprovement, token)
                                                        .ConfigureAwait(false);
                                            }
                                            else
                                                lstCyberadeptSweepGrades.Add(objImprovement);
                                        }
                                    }
                                    catch (ArgumentException)
                                    {
                                        lstInternalIdsNeedingReapplyImprovements.Add(
                                            objXmlImprovement["sourcename"]?.InnerTextViaPool(token));
                                    }
                                }

                                //Timekeeper.Finish("load_char_imp");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("Label_Contacts", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("Label_Contacts",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_contacts", loadActivity))
                            {
                                // Contacts.
                                foreach (XPathNavigator xmlContact in
                                         xmlCharacterNavigator.SelectAndCacheExpression("contacts/contact", token))
                                {
                                    Contact objContact = new Contact(this);
                                    if (blnSync)
                                    {
                                        try
                                        {
                                            // ReSharper disable once MethodHasAsyncOverload
                                            objContact.Load(xmlContact, token);
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstContacts.Add(objContact);
                                        }
                                        catch
                                        {
                                            try
                                            {
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                _lstContacts.Remove(objContact);
                                            }
                                            catch
                                            {
                                                //swallow this
                                            }
                                            // ReSharper disable once MethodHasAsyncOverload
                                            objContact.Dispose();
                                            throw;
                                        }
                                    }
                                    else
                                    {
                                        try
                                        {
                                            await objContact.LoadAsync(xmlContact, token).ConfigureAwait(false);
                                            await _lstContacts.AddAsync(objContact, token).ConfigureAwait(false);
                                        }
                                        catch
                                        {
                                            try
                                            {
                                                await _lstContacts.RemoveAsync(objContact, CancellationToken.None).ConfigureAwait(false);
                                            }
                                            catch
                                            {
                                                // swallow this
                                            }
                                            await objContact.DisposeAsync().ConfigureAwait(false);
                                            throw;
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_contacts");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("String_Qualities", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("String_Qualities",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_quality", loadActivity))
                            {
                                // Qualities

                                using (objXmlNodeList = objXmlCharacter.SelectNodes("qualities/quality"))
                                {
                                    bool blnHasOldQualities = false;
                                    xmlRootQualitiesNode =
                                        (blnSync
                                            // ReSharper disable once MethodHasAsyncOverload
                                            ? LoadData("qualities.xml", token: token)
                                            : await LoadDataAsync("qualities.xml", token: token).ConfigureAwait(false))
                                        .SelectSingleNode("/chummer/qualities");
                                    foreach (XmlNode objXmlQuality in objXmlNodeList)
                                    {
                                        if (objXmlQuality["name"] != null)
                                        {
                                            if (!(blnSync
                                                    // ReSharper disable once MethodHasAsyncOverload
                                                    ? CorrectedUnleveledQuality(objXmlQuality, xmlRootQualitiesNode, token)
                                                    : await CorrectedUnleveledQualityAsync(objXmlQuality, xmlRootQualitiesNode, token).ConfigureAwait(false)))
                                            {
                                                Quality objQuality = new Quality(this);
                                                try
                                                {
                                                    token.ThrowIfCancellationRequested();
                                                    if (blnSync)
                                                    {
                                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                        objQuality.Load(objXmlQuality);
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        if (_lstQualities.Any(x => x.InternalId == objQuality.InternalId, token))
                                                            // Corrects an issue arising from older versions of CorrectedUnleveledQuality()
                                                            objQuality.SetGUID(Guid.NewGuid());
                                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                        _lstQualities.Add(objQuality);
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        if (objQuality.GetNodeXPath(token: token)
                                                                      ?.SelectSingleNodeAndCacheExpression(
                                                                          "bonus/addgear/name", token)
                                                                      ?.Value == "Living Persona")
                                                            objLivingPersonaQuality = objQuality;
                                                    }
                                                    else
                                                    {
                                                        await objQuality.LoadAsync(objXmlQuality, token).ConfigureAwait(false);
                                                        if (await _lstQualities.AnyAsync(x => x.InternalId == objQuality.InternalId, token).ConfigureAwait(false))
                                                            // Corrects an issue arising from older versions of CorrectedUnleveledQuality()
                                                            objQuality.SetGUID(Guid.NewGuid());
                                                        await _lstQualities.AddAsync(objQuality, token)
                                                                           .ConfigureAwait(false);
                                                        XPathNavigator objQualityNode = await objQuality
                                                            .GetNodeXPathAsync(token: token).ConfigureAwait(false);
                                                        if (objQualityNode
                                                                ?.SelectSingleNodeAndCacheExpression(
                                                                    "bonus/addgear/name", token)?.Value ==
                                                            "Living Persona")
                                                            objLivingPersonaQuality = objQuality;
                                                    }

                                                    // Legacy shim
                                                    if (LastSavedVersion <= new ValueVersion(5, 195, 1)
                                                        && (objQuality.Name == "The Artisan's Way"
                                                            || objQuality.Name == "The Artist's Way"
                                                            || objQuality.Name == "The Athlete's Way"
                                                            || objQuality.Name == "The Burnout's Way"
                                                            || objQuality.Name == "The Invisible Way"
                                                            || objQuality.Name == "The Magician's Way"
                                                            || objQuality.Name == "The Speaker's Way"
                                                            || objQuality.Name == "The Warrior's Way")
                                                        && objQuality.Bonus?.HasChildNodes == false)
                                                    {
                                                        if (blnSync)
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ImprovementManager.RemoveImprovements(this,
                                                                Improvement.ImprovementSource.Quality,
                                                                objQuality.InternalId, token: token);
                                                        else
                                                            await ImprovementManager.RemoveImprovementsAsync(this,
                                                                Improvement.ImprovementSource.Quality,
                                                                objQuality.InternalId, token).ConfigureAwait(false);
                                                        XmlNode objNode = blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? objQuality.GetNode(token: token)
                                                            : await objQuality.GetNodeAsync(token: token)
                                                                              .ConfigureAwait(false);
                                                        if (objNode != null)
                                                        {
                                                            objQuality.Bonus = objNode["bonus"];
                                                            if (objQuality.Bonus != null)
                                                            {
                                                                ImprovementManager.SetForcedValue(objQuality.Extra, this);
                                                                if (blnSync)
                                                                    // ReSharper disable once MethodHasAsyncOverload
                                                                    ImprovementManager.CreateImprovements(this,
                                                                        Improvement.ImprovementSource.Quality,
                                                                        objQuality.InternalId, objQuality.Bonus, 1,
                                                                        objQuality.CurrentDisplayNameShort, token: token);
                                                                else
                                                                    await ImprovementManager.CreateImprovementsAsync(
                                                                            this,
                                                                            Improvement.ImprovementSource.Quality,
                                                                            objQuality.InternalId, objQuality.Bonus, 1,
                                                                            await objQuality
                                                                                .GetCurrentDisplayNameShortAsync(token)
                                                                                .ConfigureAwait(false), token: token)
                                                                        .ConfigureAwait(false);
                                                                string strSelectedValue =
                                                                    ImprovementManager.GetSelectedValue(this);
                                                                if (!string.IsNullOrEmpty(strSelectedValue))
                                                                {
                                                                    objQuality.Extra = strSelectedValue;
                                                                }
                                                            }

                                                            objQuality.FirstLevelBonus = objNode["firstlevelbonus"];
                                                            if (objQuality.FirstLevelBonus?.HasChildNodes == true)
                                                            {
                                                                string strCheckExtra = blnSync
                                                                    ? objQuality.Extra
                                                                    : await objQuality.GetExtraAsync(token).ConfigureAwait(false);
                                                                string strCheckSourceName = blnSync
                                                                    ? objQuality.SourceName
                                                                    : await objQuality.GetSourceNameAsync(token).ConfigureAwait(false);
                                                                bool blnDoFirstLevel;
                                                                if (blnSync)
                                                                {
                                                                    // ReSharper disable once MethodHasAsyncOverload
                                                                    blnDoFirstLevel = !Qualities.Any(objCheckQuality =>
                                                                        objCheckQuality != objQuality &&
                                                                        objCheckQuality.SourceID == objQuality.SourceID &&
                                                                        objCheckQuality.Extra == strCheckExtra &&
                                                                        objCheckQuality.SourceName == strCheckSourceName, token);
                                                                }
                                                                else
                                                                {
                                                                    blnDoFirstLevel = !await (await GetQualitiesAsync(token).ConfigureAwait(false)).AnyAsync(async objCheckQuality =>
                                                                        objCheckQuality != objQuality &&
                                                                        objCheckQuality.SourceID == objQuality.SourceID &&
                                                                        await objCheckQuality.GetExtraAsync(token).ConfigureAwait(false) == strCheckExtra &&
                                                                        await objCheckQuality.GetSourceNameAsync(token).ConfigureAwait(false) == strCheckSourceName, token).ConfigureAwait(false);
                                                                }

                                                                if (blnDoFirstLevel)
                                                                {
                                                                    ImprovementManager.SetForcedValue(objQuality.Extra, this);
                                                                    if (blnSync)
                                                                        // ReSharper disable once MethodHasAsyncOverload
                                                                        ImprovementManager.CreateImprovements(this,
                                                                            Improvement.ImprovementSource.Quality,
                                                                            objQuality.InternalId,
                                                                            objQuality.FirstLevelBonus, 1,
                                                                            objQuality.CurrentDisplayNameShort, token: token);
                                                                    else
                                                                        await ImprovementManager
                                                                              .CreateImprovementsAsync(
                                                                                  this,
                                                                                  Improvement.ImprovementSource.Quality,
                                                                                  objQuality.InternalId,
                                                                                  objQuality.FirstLevelBonus, 1,
                                                                                  await objQuality
                                                                                      .GetCurrentDisplayNameShortAsync(
                                                                                          token)
                                                                                      .ConfigureAwait(false),
                                                                                  token: token)
                                                                              .ConfigureAwait(false);
                                                                    string strSelectedValue =
                                                                        ImprovementManager.GetSelectedValue(this);
                                                                    if (!string.IsNullOrEmpty(strSelectedValue))
                                                                    {
                                                                        if (blnSync)
                                                                            objQuality.Extra = strSelectedValue;
                                                                        else
                                                                            await objQuality.SetExtraAsync(strSelectedValue, token).ConfigureAwait(false);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        else
                                                        {
                                                            lstInternalIdsNeedingReapplyImprovements.Add(
                                                                objQuality.InternalId);
                                                        }

                                                        objQuality.NaturalWeaponsNode = objNode["naturalweapons"];
                                                        if (objQuality.NaturalWeaponsNode != null)
                                                        {
                                                            ImprovementManager.SetForcedValue(objQuality.Extra, this);
                                                            if (blnSync)
                                                                // ReSharper disable once MethodHasAsyncOverload
                                                                ImprovementManager.CreateImprovements(this,
                                                                    Improvement.ImprovementSource.Quality,
                                                                    objQuality.InternalId,
                                                                    objQuality.NaturalWeaponsNode, 1,
                                                                    objQuality.CurrentDisplayNameShort, token: token);
                                                            else
                                                                await ImprovementManager.CreateImprovementsAsync(this,
                                                                        Improvement.ImprovementSource.Quality,
                                                                        objQuality.InternalId,
                                                                        objQuality.NaturalWeaponsNode, 1,
                                                                        await objQuality
                                                                              .GetCurrentDisplayNameShortAsync(token)
                                                                              .ConfigureAwait(false), token: token)
                                                                    .ConfigureAwait(false);
                                                            string strSelectedValue =
                                                                ImprovementManager.GetSelectedValue(this);
                                                            if (!string.IsNullOrEmpty(strSelectedValue))
                                                            {
                                                                objQuality.Extra = strSelectedValue;
                                                            }
                                                        }
                                                    }

                                                    if (LastSavedVersion <= new ValueVersion(5, 200, 0)
                                                        && objQuality.Name == "Made Man"
                                                        && objQuality.Bonus["selectcontact"] != null)
                                                    {
                                                        string selectedContactUniqueId = Improvements.FirstOrDefault(
                                                                x =>
                                                                    x.SourceName == objQuality.InternalId &&
                                                                    x.ImproveType == Improvement.ImprovementType
                                                                        .ContactForcedLoyalty)
                                                            ?.ImprovedName;
                                                        if (string.IsNullOrWhiteSpace(selectedContactUniqueId))
                                                        {
                                                            selectedContactUniqueId =
                                                                Contacts.FirstOrDefault(x => x.Name == objQuality.Extra)
                                                                        ?.UniqueId;
                                                        }

                                                        if (string.IsNullOrWhiteSpace(selectedContactUniqueId))
                                                        {
                                                            // Populate the Magician Traditions list.
                                                            using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(
                                                                       Utils.ListItemListPool,
                                                                       out List<ListItem> lstContacts))
                                                            {
                                                                foreach (Contact objContact in Contacts)
                                                                {
                                                                    if (objContact.IsGroup)
                                                                        lstContacts.Add(new ListItem(objContact.Name,
                                                                            objContact.UniqueId));
                                                                }

                                                                if (lstContacts.Count > 1)
                                                                {
                                                                    lstContacts.Sort(CompareListItems.CompareNames);
                                                                }

                                                                if (blnSync)
                                                                {
                                                                    // ReSharper disable once MethodHasAsyncOverload
                                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                                    using (ThreadSafeForm<SelectItem> frmPickItem
                                                                           = ThreadSafeForm<SelectItem>.Get(
                                                                               () => new SelectItem()))
                                                                    {
                                                                        frmPickItem.MyForm
                                                                            .SetDropdownItemsMode(lstContacts);
                                                                        // ReSharper disable once MethodHasAsyncOverload
                                                                        if (frmPickItem.ShowDialogSafe(this, token)
                                                                            != DialogResult.OK)
                                                                        {
                                                                            return false;
                                                                        }

                                                                        selectedContactUniqueId
                                                                            = frmPickItem.MyForm.SelectedItem;
                                                                    }
                                                                }
                                                                else
                                                                {
                                                                    using (ThreadSafeForm<SelectItem> frmPickItem
                                                                           = await ThreadSafeForm<SelectItem>
                                                                               .GetAsync(() => new SelectItem(), token)
                                                                               .ConfigureAwait(false))
                                                                    {
                                                                        frmPickItem.MyForm
                                                                            .SetDropdownItemsMode(lstContacts);
                                                                        if (await frmPickItem
                                                                                .ShowDialogSafeAsync(this, token)
                                                                                .ConfigureAwait(false)
                                                                            != DialogResult.OK)
                                                                        {
                                                                            return false;
                                                                        }

                                                                        selectedContactUniqueId
                                                                            = await frmPickItem.MyForm.DoThreadSafeFuncAsync(x => x.SelectedItem, token).ConfigureAwait(false);
                                                                    }
                                                                }
                                                            }
                                                        }

                                                        objQuality.Bonus =
                                                            xmlRootQualitiesNode.SelectSingleNode(
                                                                "quality[name=\"Made Man\"]/bonus");
                                                        objQuality.Extra = string.Empty;
                                                        try
                                                        {
                                                            token.ThrowIfCancellationRequested();
                                                            if (blnSync)
                                                            {
                                                                // ReSharper disable MethodHasAsyncOverload
                                                                ImprovementManager.RemoveImprovements(this,
                                                                    Improvement.ImprovementSource.Quality,
                                                                    objQuality.InternalId, token: token);
                                                                ImprovementManager.CreateImprovement(this, string.Empty,
                                                                    Improvement.ImprovementSource.Quality,
                                                                    objQuality.InternalId,
                                                                    Improvement.ImprovementType.MadeMan,
                                                                    objQuality.CurrentDisplayNameShort, token: token);
                                                                ImprovementManager.CreateImprovement(
                                                                    this, selectedContactUniqueId,
                                                                    Improvement.ImprovementSource.Quality,
                                                                    objQuality.InternalId,
                                                                    Improvement.ImprovementType.AddContact,
                                                                    objQuality.CurrentDisplayNameShort, token: token);
                                                                ImprovementManager.CreateImprovement(
                                                                    this, selectedContactUniqueId,
                                                                    Improvement.ImprovementSource.Quality,
                                                                    objQuality.InternalId,
                                                                    Improvement.ImprovementType.ContactForcedLoyalty,
                                                                    objQuality.CurrentDisplayNameShort, token: token);
                                                                ImprovementManager.CreateImprovement(
                                                                    this, selectedContactUniqueId,
                                                                    Improvement.ImprovementSource.Quality,
                                                                    objQuality.InternalId,
                                                                    Improvement.ImprovementType.ContactForceGroup,
                                                                    objQuality.CurrentDisplayNameShort, token: token);
                                                                ImprovementManager.CreateImprovement(
                                                                    this, selectedContactUniqueId,
                                                                    Improvement.ImprovementSource.Quality,
                                                                    objQuality.InternalId,
                                                                    Improvement.ImprovementType.ContactMakeFree,
                                                                    objQuality.CurrentDisplayNameShort, token: token);
                                                                // ReSharper restore MethodHasAsyncOverload
                                                            }
                                                            else
                                                            {
                                                                await ImprovementManager.RemoveImprovementsAsync(this,
                                                                    Improvement.ImprovementSource.Quality,
                                                                    objQuality.InternalId, token).ConfigureAwait(false);
                                                                await ImprovementManager.CreateImprovementAsync(
                                                                        this, string.Empty,
                                                                        Improvement.ImprovementSource.Quality,
                                                                        objQuality.InternalId,
                                                                        Improvement.ImprovementType.MadeMan,
                                                                        await objQuality
                                                                              .GetCurrentDisplayNameShortAsync(token)
                                                                              .ConfigureAwait(false), token: token)
                                                                    .ConfigureAwait(false);
                                                                await ImprovementManager.CreateImprovementAsync(
                                                                        this, selectedContactUniqueId,
                                                                        Improvement.ImprovementSource.Quality,
                                                                        objQuality.InternalId,
                                                                        Improvement.ImprovementType.AddContact,
                                                                        await objQuality
                                                                              .GetCurrentDisplayNameShortAsync(token)
                                                                              .ConfigureAwait(false), token: token)
                                                                    .ConfigureAwait(false);
                                                                await ImprovementManager.CreateImprovementAsync(
                                                                        this, selectedContactUniqueId,
                                                                        Improvement.ImprovementSource.Quality,
                                                                        objQuality.InternalId,
                                                                        Improvement.ImprovementType
                                                                            .ContactForcedLoyalty,
                                                                        await objQuality
                                                                              .GetCurrentDisplayNameShortAsync(token)
                                                                              .ConfigureAwait(false), token: token)
                                                                    .ConfigureAwait(false);
                                                                await ImprovementManager.CreateImprovementAsync(
                                                                        this, selectedContactUniqueId,
                                                                        Improvement.ImprovementSource.Quality,
                                                                        objQuality.InternalId,
                                                                        Improvement.ImprovementType.ContactForceGroup,
                                                                        await objQuality
                                                                              .GetCurrentDisplayNameShortAsync(token)
                                                                              .ConfigureAwait(false), token: token)
                                                                    .ConfigureAwait(false);
                                                                await ImprovementManager.CreateImprovementAsync(
                                                                        this, selectedContactUniqueId,
                                                                        Improvement.ImprovementSource.Quality,
                                                                        objQuality.InternalId,
                                                                        Improvement.ImprovementType.ContactMakeFree,
                                                                        await objQuality
                                                                              .GetCurrentDisplayNameShortAsync(token)
                                                                              .ConfigureAwait(false), token: token)
                                                                    .ConfigureAwait(false);
                                                            }
                                                        }
                                                        catch
                                                        {
                                                            if (blnSync)
                                                                // ReSharper disable once MethodHasAsyncOverload
                                                                ImprovementManager.Rollback(this, CancellationToken.None);
                                                            else
                                                                await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                                                            throw;
                                                        }

                                                        if (blnSync)
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ImprovementManager.Commit(this, token);
                                                        else
                                                            await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);
                                                    }

                                                    if (LastSavedVersion <= new ValueVersion(5, 212, 43)
                                                        && objQuality.Name == "Inspired"
                                                        && objQuality.Source == "SASS"
                                                        && objQuality.Bonus["selectexpertise"] == null)
                                                    {
                                                        // Old handling of SASS' Inspired quality was both hardcoded and wrong
                                                        // Since SASS' Inspired requires the player to choose a specialization, we always need a prompt,
                                                        // so add the quality to the list for processing when the character is opened.
                                                        lstInternalIdsNeedingReapplyImprovements.Add(
                                                            objQuality.InternalId);
                                                    }

                                                    if (LastSavedVersion <= new ValueVersion(5, 212, 56)
                                                        && objQuality.Name == "Chain Breaker"
                                                        && objQuality.Bonus == null)
                                                    {
                                                        // Chain Breaker bonus requires manual selection of two spirit types, so we need a prompt.
                                                        lstInternalIdsNeedingReapplyImprovements.Add(
                                                            objQuality.InternalId);
                                                    }

                                                    if (LastSavedVersion <= new ValueVersion(5, 212, 78)
                                                        && objQuality.Name == "Resonant Stream: Cyberadept"
                                                        && objQuality.Bonus == null)
                                                    {
                                                        objQuality.Bonus =
                                                            xmlRootQualitiesNode.SelectSingleNode(
                                                                "quality[name=\"Resonant Stream: Cyberadept\"]/bonus");
                                                        try
                                                        {
                                                            token.ThrowIfCancellationRequested();
                                                            if (blnSync)
                                                            {
                                                                // ReSharper disable MethodHasAsyncOverload
                                                                ImprovementManager.RemoveImprovements(this,
                                                                    Improvement.ImprovementSource.Quality,
                                                                    objQuality.InternalId, token: token);
                                                                ImprovementManager.CreateImprovement(this, string.Empty,
                                                                    Improvement.ImprovementSource.Quality,
                                                                    objQuality.InternalId,
                                                                    Improvement.ImprovementType.CyberadeptDaemon,
                                                                    objQuality.CurrentDisplayNameShort, token: token);
                                                                // ReSharper restore MethodHasAsyncOverload
                                                            }
                                                            else
                                                            {
                                                                await ImprovementManager.RemoveImprovementsAsync(this,
                                                                        Improvement.ImprovementSource.Quality,
                                                                        objQuality.InternalId, token: token)
                                                                    .ConfigureAwait(false);
                                                                await ImprovementManager.CreateImprovementAsync(
                                                                        this, string.Empty,
                                                                        Improvement.ImprovementSource.Quality,
                                                                        objQuality.InternalId,
                                                                        Improvement.ImprovementType.CyberadeptDaemon,
                                                                        await objQuality
                                                                              .GetCurrentDisplayNameShortAsync(token)
                                                                              .ConfigureAwait(false), token: token)
                                                                    .ConfigureAwait(false);
                                                            }
                                                        }
                                                        catch
                                                        {
                                                            if (blnSync)
                                                                // ReSharper disable once MethodHasAsyncOverload
                                                                ImprovementManager.Rollback(this, CancellationToken.None);
                                                            else
                                                                await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                                                            throw;
                                                        }

                                                        if (blnSync)
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ImprovementManager.Commit(this, token);
                                                        else
                                                            await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);
                                                    }
                                                }
                                                catch
                                                {
                                                    if (blnSync)
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        objQuality.DeleteQuality(token: CancellationToken.None);
                                                    else
                                                        await objQuality.DeleteQualityAsync(token: CancellationToken.None).ConfigureAwait(false);
                                                    throw;
                                                }
                                            }
                                        }
                                        else
                                        {
                                            // If the Quality does not have a name tag, it is in the old format. Set the flag to show that old Qualities are in use.
                                            blnHasOldQualities = true;
                                        }
                                    }

                                    // If old Qualities are in use, they need to be converted before loading can continue.
                                    if (blnHasOldQualities)
                                    {
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            ConvertOldQualities(objXmlNodeList);
                                        else
                                            await ConvertOldQualitiesAsync(objXmlNodeList, token).ConfigureAwait(false);
                                    }
                                    //Timekeeper.Finish("load_char_quality");
                                }
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("Label_Attributes", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("Label_Attributes",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_attributes", loadActivity))
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    AttributeSection.Load(objXmlCharacter, token);
                                else
                                    await AttributeSection.LoadAsync(objXmlCharacter, token).ConfigureAwait(false);
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("String_Tradition", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("String_Tradition",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_misc2", loadActivity))
                            {
                                // Attempt to load the split MAG CharacterAttribute information for Mystic Adepts.
                                if (_blnAdeptEnabled && _blnMagicianEnabled)
                                {
                                    xmlCharacterNavigator.TryGetInt32FieldQuickly("magsplitadept",
                                        ref _intMAGAdept);
                                    xmlCharacterNavigator.TryGetInt32FieldQuickly("magsplitmagician",
                                        ref _intMAGMagician);
                                }

                                // Attempt to load in the character's tradition (or equivalent for Technomancers)
                                string strTemp = string.Empty;
                                if (xmlCharacterNavigator.TryGetStringFieldQuickly("stream", ref strTemp) &&
                                    !string.IsNullOrEmpty(strTemp) && (blnSync ? RESEnabled : await GetRESEnabledAsync(token).ConfigureAwait(false)))
                                {
                                    // Legacy load a Technomancer tradition
                                    XmlNode xmlTraditionListDataNode =
                                        (blnSync
                                            // ReSharper disable once MethodHasAsyncOverload
                                            ? LoadData("streams.xml", token: token)
                                            : await LoadDataAsync("streams.xml", token: token).ConfigureAwait(false))
                                        .SelectSingleNode("/chummer/traditions");
                                    if (xmlTraditionListDataNode != null)
                                    {
                                        XmlNode xmlTraditionDataNode =
                                            xmlTraditionListDataNode.TryGetNodeByNameOrId("tradition", strTemp);
                                        if (xmlTraditionDataNode != null)
                                        {
                                            if (blnSync)
                                            {
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                if (!_objTradition.Create(xmlTraditionDataNode))
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    _objTradition.ResetTradition();
                                            }
                                            else if (!await _objTradition.CreateAsync(xmlTraditionDataNode, token: token).ConfigureAwait(false))
                                                await _objTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                                        }
                                        else
                                        {
                                            xmlTraditionDataNode =
                                                xmlTraditionListDataNode.SelectSingleNode(
                                                    "tradition[name = \"Default\"]");
                                            if (xmlTraditionDataNode != null)
                                            {
                                                if (blnSync)
                                                {
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    if (!_objTradition.Create(xmlTraditionDataNode))
                                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                        _objTradition.ResetTradition();
                                                }
                                                else if (!await _objTradition.CreateAsync(xmlTraditionDataNode, token: token).ConfigureAwait(false))
                                                    await _objTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                                            }
                                            else
                                            {
                                                xmlTraditionDataNode =
                                                    xmlTraditionListDataNode["tradition"];
                                                if (xmlTraditionDataNode != null)
                                                {
                                                    if (blnSync)
                                                    {
                                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                        if (!_objTradition.Create(xmlTraditionDataNode))
                                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                            _objTradition.ResetTradition();
                                                    }
                                                    else if (!await _objTradition.CreateAsync(xmlTraditionDataNode, token: token).ConfigureAwait(false))
                                                        await _objTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                                                }
                                            }
                                        }
                                    }

                                    if (_objTradition.Type != TraditionType.None)
                                    {
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _objTradition.LegacyLoad(xmlCharacterNavigator);
                                        else
                                            await _objTradition.LegacyLoadAsync(xmlCharacterNavigator, token).ConfigureAwait(false);
                                    }
                                }
                                else
                                {
                                    XPathNavigator xpathTraditionNavigator = xmlCharacterNavigator.SelectSingleNodeAndCacheExpression("tradition", token);
                                    // Regular tradition load
                                    if (xpathTraditionNavigator != null)
                                    {
                                        if (xpathTraditionNavigator.SelectSingleNodeAndCacheExpression("guid", token) != null
                                            || xpathTraditionNavigator.SelectSingleNodeAndCacheExpression("id", token) != null)
                                        {
                                            if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                _objTradition.Load(objXmlCharacter["tradition"]);
                                            else
                                                await _objTradition.LoadAsync(objXmlCharacter["tradition"], token).ConfigureAwait(false);
                                        }
                                        else if (blnSync
                                                     ? MAGEnabled
                                                     : await GetMAGEnabledAsync(token).ConfigureAwait(false))
                                        {
                                            XmlNode xmlTraditionListDataNode =
                                                (blnSync
                                                    // ReSharper disable once MethodHasAsyncOverload
                                                    ? LoadData("traditions.xml", token: token)
                                                    : await LoadDataAsync("traditions.xml", token: token)
                                                        .ConfigureAwait(false))
                                                .SelectSingleNode("/chummer/traditions");
                                            if (xmlTraditionListDataNode != null)
                                            {
                                                xmlCharacterNavigator.TryGetStringFieldQuickly("tradition",
                                                    ref strTemp);
                                                XmlNode xmlTraditionDataNode =
                                                    xmlTraditionListDataNode.TryGetNodeByNameOrId("tradition", strTemp);
                                                if (xmlTraditionDataNode != null)
                                                {
                                                    if (blnSync)
                                                    {
                                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                        if (!_objTradition.Create(xmlTraditionDataNode))
                                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                            _objTradition.ResetTradition();
                                                    }
                                                    else if (!await _objTradition.CreateAsync(xmlTraditionDataNode, token: token).ConfigureAwait(false))
                                                        await _objTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                                                }
                                                else
                                                {
                                                    xmlTraditionDataNode =
                                                        xmlTraditionListDataNode.TryGetNodeByNameOrId("tradition", Tradition.CustomMagicalTraditionGuidString);
                                                    if (xmlTraditionDataNode != null)
                                                    {
                                                        if (blnSync)
                                                        {
                                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                            if (!_objTradition.Create(xmlTraditionDataNode))
                                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                                _objTradition.ResetTradition();
                                                        }
                                                        else if (!await _objTradition.CreateAsync(xmlTraditionDataNode, token: token).ConfigureAwait(false))
                                                            await _objTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                                                    }
                                                }
                                            }

                                            if (_objTradition.Type != TraditionType.None)
                                            {
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    _objTradition.LegacyLoad(xmlCharacterNavigator);
                                                else
                                                    await _objTradition.LegacyLoadAsync(xmlCharacterNavigator, token).ConfigureAwait(false);
                                            }
                                        }
                                    }
                                    // Not null but doesn't have children -> legacy load a magical tradition
                                    else if (xpathTraditionNavigator != null && (blnSync ? MAGEnabled : await GetMAGEnabledAsync(token).ConfigureAwait(false)))
                                    {
                                        XmlNode xmlTraditionListDataNode =
                                            (blnSync
                                                // ReSharper disable once MethodHasAsyncOverload
                                                ? LoadData("traditions.xml", token: token)
                                                : await LoadDataAsync("traditions.xml", token: token)
                                                    .ConfigureAwait(false))
                                            .SelectSingleNode("/chummer/traditions");
                                        if (xmlTraditionListDataNode != null)
                                        {
                                            xmlCharacterNavigator.TryGetStringFieldQuickly("tradition",
                                                ref strTemp);
                                            XmlNode xmlTraditionDataNode =
                                                xmlTraditionListDataNode.TryGetNodeByNameOrId("tradition", strTemp);
                                            if (xmlTraditionDataNode != null)
                                            {
                                                if (blnSync)
                                                {
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    if (!_objTradition.Create(xmlTraditionDataNode))
                                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                        _objTradition.ResetTradition();
                                                }
                                                else if (!await _objTradition.CreateAsync(xmlTraditionDataNode, token: token).ConfigureAwait(false))
                                                    await _objTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                                            }
                                            else
                                            {
                                                xmlTraditionDataNode =
                                                    xmlTraditionListDataNode.TryGetNodeByNameOrId("tradition", Tradition.CustomMagicalTraditionGuidString);
                                                if (xmlTraditionDataNode != null)
                                                {
                                                    if (blnSync)
                                                    {
                                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                        if (!_objTradition.Create(xmlTraditionDataNode))
                                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                            _objTradition.ResetTradition();
                                                    }
                                                    else if (!await _objTradition.CreateAsync(xmlTraditionDataNode, token: token).ConfigureAwait(false))
                                                        await _objTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                                                }
                                            }
                                        }

                                        if (_objTradition.Type != TraditionType.None)
                                        {
                                            if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                _objTradition.LegacyLoad(xmlCharacterNavigator);
                                            else
                                                await _objTradition.LegacyLoadAsync(xmlCharacterNavigator, token).ConfigureAwait(false);
                                        }
                                    }
                                }

                                // Attempt to load Condition Monitor Progress.
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("physicalcmfilled",
                                                                              ref _intPhysicalCMFilled);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("stuncmfilled", ref _intStunCMFilled);

                                xmlCharacterNavigator.TryGetBoolFieldQuickly("psyche", ref _blnPsycheActive);
                                //Timekeeper.Finish("load_char_misc2");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_Skills", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager
                                                                  .GetStringAsync("Tab_Skills", token: token)
                                                                  .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_skills", loadActivity)) //slightly messy
                            {
                                _oldSkillsBackup = objXmlCharacter["skills"]?.Clone();
                                _oldSkillGroupBackup = objXmlCharacter["skillgroups"]?.Clone();

                                XmlElement objSkillNode = objXmlCharacter["newskills"];
                                if (blnSync)
                                {
                                    if (objSkillNode != null)
                                    {
                                        // ReSharper disable once MethodHasAsyncOverload
                                        SkillsSection.Load(objSkillNode, false, loadActivity, token);
                                    }
                                    else
                                    {
                                        // ReSharper disable once MethodHasAsyncOverload
                                        SkillsSection.Load(objXmlCharacter, true, loadActivity, token);
                                    }
                                }
                                else if (objSkillNode != null)
                                {
                                    await SkillsSection.LoadAsync(objSkillNode, false, loadActivity, token)
                                                       .ConfigureAwait(false);
                                }
                                else
                                {
                                    await SkillsSection.LoadAsync(objXmlCharacter, true, loadActivity, token)
                                                       .ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_skills");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("String_Locations", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("String_Locations",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_loc", loadActivity))
                            {
                                // Locations.
                                objXmlLocationList = objXmlCharacter.SelectNodes("gearlocations/gearlocation");
                                foreach (XmlNode objXmlLocation in objXmlLocationList)
                                {
                                    Location objLocation = new Location(this, _lstGearLocations);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        objLocation.Load(objXmlLocation);
                                    else
                                        await objLocation.LoadAsync(objXmlLocation, token).ConfigureAwait(false);
                                }

                                objXmlLocationList = objXmlCharacter.SelectNodes("locations/location");
                                foreach (XmlNode objXmlLocation in objXmlLocationList)
                                {
                                    Location objLocation = new Location(this, _lstGearLocations);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        objLocation.Load(objXmlLocation);
                                    else
                                        await objLocation.LoadAsync(objXmlLocation, token).ConfigureAwait(false);
                                }

                                objXmlLocationList = objXmlCharacter.SelectNodes("gearlocations/location");
                                foreach (XmlNode objXmlLocation in objXmlLocationList)
                                {
                                    Location objLocation = new Location(this, _lstGearLocations);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        objLocation.Load(objXmlLocation);
                                    else
                                        await objLocation.LoadAsync(objXmlLocation, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_loc");
                            }

                            using (Timekeeper.StartSyncron("load_char_abundle", loadActivity))
                            {
                                // Armor Bundles.
                                objXmlLocationList = objXmlCharacter.SelectNodes("armorbundles/armorbundle");
                                foreach (XmlNode objXmlLocation in objXmlLocationList)
                                {
                                    Location objLocation = new Location(this, _lstArmorLocations);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        objLocation.Load(objXmlLocation);
                                    else
                                        await objLocation.LoadAsync(objXmlLocation, token).ConfigureAwait(false);
                                }

                                objXmlLocationList = objXmlCharacter.SelectNodes("armorlocations/armorlocation");
                                foreach (XmlNode objXmlLocation in objXmlLocationList)
                                {
                                    Location objLocation = new Location(this, _lstArmorLocations);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        objLocation.Load(objXmlLocation);
                                    else
                                        await objLocation.LoadAsync(objXmlLocation, token).ConfigureAwait(false);
                                }

                                objXmlLocationList = objXmlCharacter.SelectNodes("armorlocations/location");
                                foreach (XmlNode objXmlLocation in objXmlLocationList)
                                {
                                    Location objLocation = new Location(this, _lstArmorLocations);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        objLocation.Load(objXmlLocation);
                                    else
                                        await objLocation.LoadAsync(objXmlLocation, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_abundle");
                            }

                            using (Timekeeper.StartSyncron("load_char_vloc", loadActivity))
                            {
                                // Vehicle Locations.
                                XmlNodeList objXmlVehicleLocationList =
                                    objXmlCharacter.SelectNodes("vehiclelocations/vehiclelocation");
                                foreach (XmlNode objXmlLocation in objXmlVehicleLocationList)
                                {
                                    Location objLocation = new Location(this, _lstVehicleLocations);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        objLocation.Load(objXmlLocation);
                                    else
                                        await objLocation.LoadAsync(objXmlLocation, token).ConfigureAwait(false);
                                }

                                objXmlVehicleLocationList =
                                    objXmlCharacter.SelectNodes("vehiclelocations/location");
                                foreach (XmlNode objXmlLocation in objXmlVehicleLocationList)
                                {
                                    Location objLocation = new Location(this, _lstVehicleLocations);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        objLocation.Load(objXmlLocation);
                                    else
                                        await objLocation.LoadAsync(objXmlLocation, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_vloc");
                            }

                            using (Timekeeper.StartSyncron("load_char_wloc", loadActivity))
                            {
                                // Weapon Locations.
                                XmlNodeList objXmlWeaponLocationList =
                                    objXmlCharacter.SelectNodes("weaponlocations/weaponlocation");
                                foreach (XmlNode objXmlLocation in objXmlWeaponLocationList)
                                {
                                    Location objLocation = new Location(this, _lstWeaponLocations);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        objLocation.Load(objXmlLocation);
                                    else
                                        await objLocation.LoadAsync(objXmlLocation, token).ConfigureAwait(false);
                                }

                                objXmlWeaponLocationList = objXmlCharacter.SelectNodes("weaponlocations/location");
                                foreach (XmlNode objXmlLocation in objXmlWeaponLocationList)
                                {
                                    Location objLocation = new Location(this, _lstWeaponLocations);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        objLocation.Load(objXmlLocation);
                                    else
                                        await objLocation.LoadAsync(objXmlLocation, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_wloc");
                            }

                            using (Timekeeper.StartSyncron("load_char_sfoci", loadActivity))
                            {
                                // Stacked Foci.
                                objXmlNodeList = objXmlCharacter.SelectNodes("stackedfoci/stackedfocus");
                                foreach (XmlNode objXmlStack in objXmlNodeList)
                                {
                                    StackedFocus objStack = new StackedFocus(this);
                                    if (blnSync)
                                    {
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        objStack.Load(objXmlStack);
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstStackedFoci.Add(objStack);
                                    }
                                    else
                                    {
                                        await objStack.LoadAsync(objXmlStack, token).ConfigureAwait(false);
                                        await _lstStackedFoci.AddAsync(objStack, token).ConfigureAwait(false);
                                    }
                                }

                                //Timekeeper.Finish("load_char_sfoci");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_Armor", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager
                                                                  .GetStringAsync("Tab_Armor", token: token)
                                                                  .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_armor", loadActivity))
                            {
                                // Armor.
                                objXmlNodeList = objXmlCharacter.SelectNodes("armors/armor");
                                foreach (XmlNode objXmlArmor in objXmlNodeList)
                                {
                                    Armor objArmor = new Armor(this);
                                    if (blnSync)
                                    {
                                        try
                                        {
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            objArmor.Load(objXmlArmor);
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstArmor.Add(objArmor);
                                        }
                                        catch
                                        {
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            objArmor.DeleteArmor();
                                            throw;
                                        }
                                    }
                                    else
                                    {
                                        try
                                        {
                                            await objArmor.LoadAsync(objXmlArmor, token: token).ConfigureAwait(false);
                                            await _lstArmor.AddAsync(objArmor, token).ConfigureAwait(false);
                                        }
                                        catch
                                        {
                                            await objArmor.DeleteArmorAsync(token: CancellationToken.None).ConfigureAwait(false);
                                            throw;
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_armor");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_Drugs", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager
                                                                  .GetStringAsync("Tab_Drugs", token: token)
                                                                  .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_drugs", loadActivity))
                            {
                                // Drugs.
                                objXmlNodeList = objXmlCharacter.SelectNodes("drugs/drug");
                                foreach (XmlNode objXmlDrug in objXmlNodeList)
                                {
                                    Drug objDrug = new Drug(this);
                                    if (blnSync)
                                    {
                                        try
                                        {
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            objDrug.Load(objXmlDrug);
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstDrugs.Add(objDrug);
                                        }
                                        catch
                                        {
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            objDrug.Remove(false);
                                            throw;
                                        }
                                    }
                                    else
                                    {
                                        try
                                        {
                                            await objDrug.LoadAsync(objXmlDrug, token).ConfigureAwait(false);
                                            await _lstDrugs.AddAsync(objDrug, token).ConfigureAwait(false);
                                        }
                                        catch
                                        {
                                            await objDrug.RemoveAsync(false, token).ConfigureAwait(false);
                                            throw;
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_drugs");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("Tab_Cyberware", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager
                                                                  .GetStringAsync("Tab_Cyberware", token: token)
                                                                  .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_ware", loadActivity))
                            {
                                // Cyberware/Bioware.
                                objXmlNodeList = objXmlCharacter.SelectNodes("cyberwares/cyberware");
                                // Dictionary for instantly re-applying outdated improvements for 'ware with pair bonuses in legacy shim
                                Dictionary<Cyberware, int> dicPairableCyberwares =
                                    new Dictionary<Cyberware, int>(objXmlNodeList.Count);
                                foreach (XmlNode objXmlCyberware in objXmlNodeList)
                                {
                                    Cyberware objCyberware = new Cyberware(this);
                                    if (blnSync)
                                    {
                                        try
                                        {
                                            // ReSharper disable once MethodHasAsyncOverload
                                            objCyberware.Load(objXmlCyberware, token: token);
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstCyberware.Add(objCyberware);
                                        }
                                        catch
                                        {
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            objCyberware.DeleteCyberware();
                                            throw;
                                        }
                                    }
                                    else
                                    {
                                        try
                                        {
                                            await objCyberware.LoadAsync(objXmlCyberware, token: token).ConfigureAwait(false);
                                            await _lstCyberware.AddAsync(objCyberware, token).ConfigureAwait(false);
                                        }
                                        catch
                                        {
                                            await objCyberware.DeleteCyberwareAsync(token: CancellationToken.None).ConfigureAwait(false);
                                            throw;
                                        }
                                    }

                                    // Legacy shim #1
                                    if (objCyberware.Name == "Myostatin Inhibitor" &&
                                        LastSavedVersion <= new ValueVersion(5, 195, 1) &&
                                        !(blnSync
                                            // ReSharper disable once MethodHasAsyncOverload
                                            ? Improvements.Any(x =>
                                                                   x.SourceName == objCyberware.InternalId &&
                                                                   x.ImproveType == Improvement.ImprovementType
                                                                       .AttributeKarmaCost, token)
                                            : await Improvements.AnyAsync(x =>
                                                                              x.SourceName == objCyberware.InternalId &&
                                                                              x.ImproveType == Improvement
                                                                                  .ImprovementType
                                                                                  .AttributeKarmaCost, token).ConfigureAwait(false)))
                                    {
                                        XmlNode objNode = blnSync
                                            // ReSharper disable once MethodHasAsyncOverload
                                            ? objCyberware.GetNode(token: token)
                                            : await objCyberware.GetNodeAsync(token: token).ConfigureAwait(false);
                                        if (objNode != null)
                                        {
                                            using (TemporaryStringArray aParams = new TemporaryStringArray(objCyberware.InternalId, objCyberware.InternalId + "Pair"))
                                            {
                                                if (blnSync)
                                                {
                                                    // ReSharper disable once MethodHasAsyncOverload
                                                    ImprovementManager.RemoveImprovements(this, objCyberware.SourceType,
                                                        aParams, token: token);
                                                }
                                                else
                                                {
                                                    await ImprovementManager.RemoveImprovementsAsync(
                                                        this, objCyberware.SourceType,
                                                        aParams, token: token).ConfigureAwait(false);
                                                }
                                            }

                                            objCyberware.Bonus = objNode["bonus"];
                                            objCyberware.WirelessBonus = objNode["wirelessbonus"];
                                            objCyberware.PairBonus = objNode["pairbonus"];
                                            if (!string.IsNullOrEmpty(objCyberware.Forced) &&
                                                objCyberware.Forced != "Right" &&
                                                objCyberware.Forced != "Left")
                                                ImprovementManager.SetForcedValue(objCyberware.Forced, this);
                                            if (objCyberware.Bonus != null)
                                            {
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverload
                                                    ImprovementManager.CreateImprovements(this, objCyberware.SourceType,
                                                        objCyberware.InternalId, objCyberware.Bonus,
                                                        objCyberware.Rating,
                                                        objCyberware.CurrentDisplayNameShort, token: token);
                                                else
                                                    await ImprovementManager.CreateImprovementsAsync(
                                                                                this, objCyberware.SourceType,
                                                                                objCyberware.InternalId,
                                                                                objCyberware.Bonus,
                                                                                await objCyberware.GetRatingAsync(token)
                                                                                    .ConfigureAwait(false),
                                                                                await objCyberware
                                                                                    .GetCurrentDisplayNameShortAsync(
                                                                                        token)
                                                                                    .ConfigureAwait(false),
                                                                                token: token)
                                                                            .ConfigureAwait(false);
                                                string strSelectedValue =
                                                    ImprovementManager.GetSelectedValue(this);
                                                if (!string.IsNullOrEmpty(strSelectedValue))
                                                    objCyberware.Extra = strSelectedValue;
                                            }

                                            if (objCyberware.WirelessOn && objCyberware.WirelessBonus != null)
                                            {
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverload
                                                    ImprovementManager.CreateImprovements(this, objCyberware.SourceType,
                                                        objCyberware.InternalId, objCyberware.WirelessBonus,
                                                        objCyberware.Rating,
                                                        objCyberware.CurrentDisplayNameShort, token: token);
                                                else
                                                    await ImprovementManager.CreateImprovementsAsync(
                                                                                this, objCyberware.SourceType,
                                                                                objCyberware.InternalId,
                                                                                objCyberware.WirelessBonus,
                                                                                await objCyberware.GetRatingAsync(token)
                                                                                    .ConfigureAwait(false),
                                                                                await objCyberware
                                                                                    .GetCurrentDisplayNameShortAsync(
                                                                                        token)
                                                                                    .ConfigureAwait(false),
                                                                                token: token)
                                                                            .ConfigureAwait(false);
                                                string strSelectedValue = ImprovementManager.GetSelectedValue(this);
                                                if (!string.IsNullOrEmpty(strSelectedValue) &&
                                                    string.IsNullOrEmpty(objCyberware.Extra))
                                                    objCyberware.Extra = strSelectedValue;
                                            }

                                            if (!(blnSync ? objCyberware.IsModularCurrentlyEquipped : await objCyberware.GetIsModularCurrentlyEquippedAsync(token).ConfigureAwait(false)))
                                            {
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    objCyberware.ChangeModularEquip(false);
                                                else
                                                    await objCyberware.ChangeModularEquipAsync(false, token: token)
                                                                      .ConfigureAwait(false);
                                            }
                                            else if (objCyberware.PairBonus != null)
                                            {
                                                Cyberware objMatchingCyberware =
                                                    dicPairableCyberwares.Keys.FirstOrDefault(
                                                        x =>
                                                            x.Name == objCyberware.Name &&
                                                            x.Extra == objCyberware.Extra);
                                                if (objMatchingCyberware != null)
                                                    ++dicPairableCyberwares[objMatchingCyberware];
                                                else
                                                    dicPairableCyberwares.Add(objCyberware, 1);
                                            }
                                        }
                                        else
                                            lstInternalIdsNeedingReapplyImprovements.Add(objCyberware.InternalId);
                                    }
                                }

                                // Legacy Shim #2 (needed to be separate because we're dealing with PairBonuses here, and we don't know if something needs its PairBonus reapplied until all Cyberwares have been loaded)
                                if (LastSavedVersion <= new ValueVersion(5, 200, 0))
                                {
                                    if (blnSync)
                                    {
                                        // ReSharper disable MethodHasAsyncOverload
                                        Cyberware.ForEach(objCyberware =>
                                        {
                                            if (objCyberware.PairBonus?.HasChildNodes == true &&
                                                !Cyberware.DeepAny(x => x.Children, x =>
                                                {
                                                    if (!objCyberware.IncludePair.Contains(x.Name) ||
                                                        x.Extra != objCyberware.Extra ||
                                                        !x.IsModularCurrentlyEquipped)
                                                        return false;
                                                    string strToMatch = x.InternalId + "Pair";
                                                    return Improvements.Any(y => y.SourceName == strToMatch, token);
                                                }))
                                            {
                                                XmlNode objNode = objCyberware.GetNode(token: token);
                                                if (objNode != null)
                                                {
                                                    using (TemporaryStringArray aParams = new TemporaryStringArray(objCyberware.InternalId, objCyberware.InternalId + "Pair"))
                                                    {
                                                        ImprovementManager.RemoveImprovements(this, objCyberware.SourceType, aParams, token: token);
                                                    }

                                                    objCyberware.Bonus = objNode["bonus"];
                                                    objCyberware.WirelessBonus = objNode["wirelessbonus"];
                                                    objCyberware.PairBonus = objNode["pairbonus"];
                                                    if (!string.IsNullOrEmpty(objCyberware.Forced) &&
                                                        objCyberware.Forced != "Right" &&
                                                        objCyberware.Forced != "Left")
                                                        ImprovementManager.SetForcedValue(objCyberware.Forced, this);
                                                    if (objCyberware.Bonus != null)
                                                    {
                                                        ImprovementManager.CreateImprovements(this,
                                                            objCyberware.SourceType,
                                                            objCyberware.InternalId, objCyberware.Bonus,
                                                            objCyberware.Rating,
                                                            objCyberware.CurrentDisplayNameShort, token: token);
                                                        string strSelectedValue =
                                                            ImprovementManager.GetSelectedValue(this);
                                                        if (!string.IsNullOrEmpty(strSelectedValue))
                                                            objCyberware.Extra = strSelectedValue;
                                                    }

                                                    if (objCyberware.WirelessOn && objCyberware.WirelessBonus != null)
                                                    {
                                                        ImprovementManager.CreateImprovements(this,
                                                            objCyberware.SourceType,
                                                            objCyberware.InternalId, objCyberware.WirelessBonus,
                                                            objCyberware.Rating,
                                                            objCyberware.CurrentDisplayNameShort, token: token);
                                                        string strSelectedValue = ImprovementManager.GetSelectedValue(this);
                                                        if (!string.IsNullOrEmpty(strSelectedValue) &&
                                                            string.IsNullOrEmpty(objCyberware.Extra))
                                                            objCyberware.Extra = strSelectedValue;
                                                    }

                                                    if (!objCyberware.IsModularCurrentlyEquipped)
                                                    {
                                                        objCyberware.ChangeModularEquip(false);
                                                    }
                                                    else if (objCyberware.PairBonus != null)
                                                    {
                                                        Cyberware objMatchingCyberware =
                                                            dicPairableCyberwares.Keys.FirstOrDefault(
                                                                x =>
                                                                    x.Name == objCyberware.Name &&
                                                                    x.Extra == objCyberware.Extra);
                                                        if (objMatchingCyberware != null)
                                                            ++dicPairableCyberwares[objMatchingCyberware];
                                                        else
                                                            dicPairableCyberwares.Add(objCyberware, 1);
                                                    }
                                                }
                                                else
                                                    lstInternalIdsNeedingReapplyImprovements.Add(objCyberware.InternalId);
                                            }
                                        }, token);
                                        // ReSharper restore MethodHasAsyncOverload
                                    }
                                    else
                                    {
                                        await (await GetCyberwareAsync(token).ConfigureAwait(false)).ForEachAsync(async objCyberware =>
                                        {
                                            if (objCyberware.PairBonus?.HasChildNodes == true &&
                                                !await (await GetCyberwareAsync(token).ConfigureAwait(false)).DeepAnyAsync(x => x.GetChildrenAsync(token), async x =>
                                                {
                                                    if (!objCyberware.IncludePair.Contains(x.Name) ||
                                                        x.Extra != objCyberware.Extra ||
                                                        !await x.GetIsModularCurrentlyEquippedAsync(token).ConfigureAwait(false))
                                                        return false;
                                                    string strToMatch = x.InternalId + "Pair";
                                                    return await Improvements.AnyAsync(y => y.SourceName == strToMatch, token).ConfigureAwait(false);
                                                }, token).ConfigureAwait(false))
                                            {
                                                XmlNode objNode = await objCyberware.GetNodeAsync(token: token).ConfigureAwait(false);
                                                if (objNode != null)
                                                {
                                                    using (TemporaryStringArray aParams = new TemporaryStringArray(objCyberware.InternalId, objCyberware.InternalId + "Pair"))
                                                    {
                                                        await ImprovementManager.RemoveImprovementsAsync(this, objCyberware.SourceType, aParams, token: token).ConfigureAwait(false);
                                                    }
                                                    objCyberware.Bonus = objNode["bonus"];
                                                    objCyberware.WirelessBonus = objNode["wirelessbonus"];
                                                    objCyberware.PairBonus = objNode["pairbonus"];
                                                    if (!string.IsNullOrEmpty(objCyberware.Forced) &&
                                                        objCyberware.Forced != "Right" &&
                                                        objCyberware.Forced != "Left")
                                                        ImprovementManager.SetForcedValue(objCyberware.Forced, this);
                                                    if (objCyberware.Bonus != null)
                                                    {
                                                        await ImprovementManager.CreateImprovementsAsync(this,
                                                                objCyberware.SourceType,
                                                                objCyberware.InternalId, objCyberware.Bonus,
                                                                await objCyberware.GetRatingAsync(token)
                                                                    .ConfigureAwait(false),
                                                                await objCyberware
                                                                      .GetCurrentDisplayNameShortAsync(token)
                                                                      .ConfigureAwait(false), token: token)
                                                            .ConfigureAwait(false);
                                                        string strSelectedValue =
                                                            ImprovementManager.GetSelectedValue(this);
                                                        if (!string.IsNullOrEmpty(strSelectedValue))
                                                            objCyberware.Extra = strSelectedValue;
                                                    }

                                                    if (objCyberware.WirelessOn && objCyberware.WirelessBonus != null)
                                                    {
                                                        await ImprovementManager.CreateImprovementsAsync(this,
                                                                objCyberware.SourceType,
                                                                objCyberware.InternalId, objCyberware.WirelessBonus,
                                                                await objCyberware.GetRatingAsync(token)
                                                                    .ConfigureAwait(false),
                                                                await objCyberware
                                                                      .GetCurrentDisplayNameShortAsync(token)
                                                                      .ConfigureAwait(false), token: token)
                                                            .ConfigureAwait(false);
                                                        string strSelectedValue = ImprovementManager.GetSelectedValue(this);
                                                        if (!string.IsNullOrEmpty(strSelectedValue) &&
                                                            string.IsNullOrEmpty(objCyberware.Extra))
                                                            objCyberware.Extra = strSelectedValue;
                                                    }

                                                    if (!await objCyberware.GetIsModularCurrentlyEquippedAsync(token).ConfigureAwait(false))
                                                    {
                                                        await objCyberware.ChangeModularEquipAsync(false, token: token)
                                                                          .ConfigureAwait(false);
                                                    }
                                                    else if (objCyberware.PairBonus != null)
                                                    {
                                                        Cyberware objMatchingCyberware =
                                                            dicPairableCyberwares.Keys.FirstOrDefault(
                                                                x =>
                                                                    x.Name == objCyberware.Name &&
                                                                    x.Extra == objCyberware.Extra);
                                                        if (objMatchingCyberware != null)
                                                            ++dicPairableCyberwares[objMatchingCyberware];
                                                        else
                                                            dicPairableCyberwares.Add(objCyberware, 1);
                                                    }
                                                }
                                                else
                                                    lstInternalIdsNeedingReapplyImprovements.Add(objCyberware.InternalId);
                                            }
                                        }, token).ConfigureAwait(false);
                                    }
                                }

                                // Separate Pass for PairBonuses
                                foreach (KeyValuePair<Cyberware, int> objItem in dicPairableCyberwares)
                                {
                                    Cyberware objCyberware = objItem.Key;
                                    int intCyberwaresCount = objItem.Value;
                                    List<Cyberware> lstPairableCyberwares = blnSync
                                        ? Cyberware.DeepWhere(x => x.Children,
                                                              x => objCyberware.IncludePair.Contains(x.Name) &&
                                                                   x.Extra == objCyberware.Extra &&
                                                                   x.IsModularCurrentlyEquipped, token).ToList()
                                        : await (await GetCyberwareAsync(token).ConfigureAwait(false)).DeepWhereAsync(x => x.GetChildrenAsync(token),
                                                                         async x => objCyberware.IncludePair.Contains(x.Name)
                                                                              && x.Extra == objCyberware.Extra
                                                                              && await x.GetIsModularCurrentlyEquippedAsync(token).ConfigureAwait(false), token).ConfigureAwait(false);
                                    // Need to use slightly different logic if this cyberware has a location (Left or Right) and only pairs with itself because Lefts can only be paired with Rights and Rights only with Lefts
                                    if (!string.IsNullOrEmpty(objCyberware.Location) &&
                                        objCyberware.IncludePair.All(x => x == objCyberware.Name))
                                    {
                                        int intMatchLocationCount = 0;
                                        int intNotMatchLocationCount = 0;
                                        foreach (Cyberware objPairableCyberware in lstPairableCyberwares)
                                        {
                                            if (objPairableCyberware.Location != objCyberware.Location)
                                                ++intNotMatchLocationCount;
                                            else
                                                ++intMatchLocationCount;
                                        }

                                        // Set the count to the total number of cyberwares in matching pairs, which would mean 2x the number of whichever location contains the fewest members (since every single one of theirs would have a pair)
                                        intCyberwaresCount =
                                            Math.Min(intNotMatchLocationCount, intMatchLocationCount) *
                                            2;
                                    }

                                    if (intCyberwaresCount > 0)
                                    {
                                        foreach (Cyberware objLoopCyberware in lstPairableCyberwares)
                                        {
                                            if ((intCyberwaresCount & 1) == 0)
                                            {
                                                if (!string.IsNullOrEmpty(objCyberware.Forced) &&
                                                    objCyberware.Forced != "Right" &&
                                                    objCyberware.Forced != "Left")
                                                    ImprovementManager.SetForcedValue(objCyberware.Forced, this);
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverload
                                                    ImprovementManager.CreateImprovements(this,
                                                        objLoopCyberware.SourceType,
                                                        objLoopCyberware.InternalId + "Pair",
                                                        objLoopCyberware.PairBonus,
                                                        objLoopCyberware.Rating,
                                                        objLoopCyberware.CurrentDisplayNameShort, token: token);
                                                else
                                                    await ImprovementManager.CreateImprovementsAsync(this,
                                                                                objLoopCyberware.SourceType,
                                                                                objLoopCyberware.InternalId + "Pair",
                                                                                objLoopCyberware.PairBonus,
                                                                                await objLoopCyberware
                                                                                    .GetRatingAsync(token)
                                                                                    .ConfigureAwait(false),
                                                                                await objLoopCyberware
                                                                                    .GetCurrentDisplayNameShortAsync(
                                                                                        token)
                                                                                    .ConfigureAwait(false),
                                                                                token: token)
                                                                            .ConfigureAwait(false);
                                                string strSelectedValue = ImprovementManager.GetSelectedValue(this);
                                                if (!string.IsNullOrEmpty(strSelectedValue) &&
                                                    string.IsNullOrEmpty(objCyberware.Extra))
                                                    objCyberware.Extra = strSelectedValue;
                                            }

                                            --intCyberwaresCount;
                                            if (intCyberwaresCount <= 0)
                                                break;
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_ware");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("Label_SelectedSpells", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("Label_SelectedSpells",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_spells", loadActivity))
                            {
                                // Spells.
                                objXmlNodeList = objXmlCharacter.SelectNodes("spells/spell");
                                foreach (XmlNode objXmlSpell in objXmlNodeList)
                                {
                                    Spell objSpell = new Spell(this);
                                    try
                                    {
                                        if (blnSync)
                                        {
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            objSpell.Load(objXmlSpell);
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstSpells.Add(objSpell);
                                        }
                                        else
                                        {
                                            await objSpell.LoadAsync(objXmlSpell, token).ConfigureAwait(false);
                                            await _lstSpells.AddAsync(objSpell, token).ConfigureAwait(false);
                                        }
                                    }
                                    catch
                                    {
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            objSpell.Remove(false);
                                        else
                                            await objSpell.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                                        throw;
                                    }
                                }
                                //Timekeeper.Finish("load_char_spells");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_Adept", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager
                                                                  .GetStringAsync("Tab_Adept", token: token)
                                                                  .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_powers", loadActivity))
                            {
                                // Powers.
                                objXmlNodeList = objXmlCharacter.SelectNodes("powers/power");
                                if (objXmlNodeList.Count > 0)
                                {
                                    using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(
                                               Utils.ListItemListPool, out List<ListItem> lstPowerOrder))
                                    {
                                        bool blnDoEnhancedAccuracyRefresh =
                                            LastSavedVersion <= new ValueVersion(5, 198, 26);
                                        // Sort the Powers in alphabetical order.
                                        foreach (XmlNode xmlPower in objXmlNodeList)
                                        {
                                            string strGuid = xmlPower["guid"]?.InnerTextViaPool(token);
                                            string strPowerName = xmlPower["name"]?.InnerTextViaPool(token) ?? string.Empty;
                                            if (blnDoEnhancedAccuracyRefresh
                                                && strPowerName == "Enhanced Accuracy (skill)")
                                            {
                                                lstInternalIdsNeedingReapplyImprovements.Add(strGuid);
                                            }

                                            if (!string.IsNullOrEmpty(strGuid))
                                                lstPowerOrder.Add(new ListItem(strGuid,
                                                                               strPowerName
                                                                               + (xmlPower["extra"]?.InnerTextViaPool(token)
                                                                                   ?? string.Empty)));
                                            else
                                            {
                                                Power objPower = new Power(this);
                                                if (blnSync)
                                                {
                                                    try
                                                    {
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        objPower.Load(xmlPower, token);
                                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                        _lstPowers.Add(objPower);
                                                    }
                                                    catch
                                                    {
                                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                        objPower.DeletePower();
                                                        throw;
                                                    }
                                                }
                                                else
                                                {
                                                    try
                                                    {
                                                        await objPower.LoadAsync(xmlPower, token).ConfigureAwait(false);
                                                        await _lstPowers.AddAsync(objPower, token).ConfigureAwait(false);
                                                    }
                                                    catch
                                                    {
                                                        await objPower.DeletePowerAsync(CancellationToken.None).ConfigureAwait(false);
                                                        throw;
                                                    }
                                                }
                                            }
                                        }

                                        lstPowerOrder.Sort(CompareListItems.CompareNames);

                                        foreach (ListItem objItem in lstPowerOrder)
                                        {
                                            XmlNode objNode =
                                                objXmlCharacter.SelectSingleNode(
                                                    "powers/power[guid = " + objItem.Value.ToString().CleanXPath()
                                                                           + "]");
                                            if (objNode != null)
                                            {
                                                Power objPower = new Power(this);
                                                if (blnSync)
                                                {
                                                    try
                                                    {
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        objPower.Load(objNode, token);
                                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                        _lstPowers.Add(objPower);
                                                    }
                                                    catch
                                                    {
                                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                        objPower.DeletePower();
                                                        throw;
                                                    }
                                                }
                                                else
                                                {
                                                    try
                                                    {
                                                        await objPower.LoadAsync(objNode, token).ConfigureAwait(false);
                                                        await _lstPowers.AddAsync(objPower, token).ConfigureAwait(false);
                                                    }
                                                    catch
                                                    {
                                                        await objPower.DeletePowerAsync(CancellationToken.None).ConfigureAwait(false);
                                                        throw;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_powers");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("Label_Spirits", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager
                                                                  .GetStringAsync("Label_Spirits", token: token)
                                                                  .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_spirits", loadActivity))
                            {
                                // Spirits/Sprites.
                                foreach (XPathNavigator xmlSpirit in xmlCharacterNavigator.SelectAndCacheExpression("spirits/spirit", token))
                                {
                                    Spirit objSpirit = new Spirit(this);
                                    if (blnSync)
                                    {
                                        try
                                        {
                                            // ReSharper disable once MethodHasAsyncOverload
                                            objSpirit.Load(xmlSpirit, token);
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstSpirits.Add(objSpirit);
                                        }
                                        catch
                                        {
                                            try
                                            {
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                _lstSpirits.Remove(objSpirit);
                                            }
                                            catch
                                            {
                                                //swallow this
                                            }
                                            // ReSharper disable once MethodHasAsyncOverload
                                            objSpirit.Dispose();
                                            throw;
                                        }
                                    }
                                    else
                                    {
                                        try
                                        {
                                            await objSpirit.LoadAsync(xmlSpirit, token).ConfigureAwait(false);
                                            await _lstSpirits.AddAsync(objSpirit, token).ConfigureAwait(false);
                                        }
                                        catch
                                        {
                                            try
                                            {
                                                await _lstSpirits.RemoveAsync(objSpirit, token: token).ConfigureAwait(false);
                                            }
                                            catch
                                            {
                                                //swallow this
                                            }
                                            await objSpirit.DisposeAsync().ConfigureAwait(false);
                                            throw;
                                        }
                                    }
                                }

                                // If we don't have any Fettered spirits, make sure that we
                                if (blnSync)
                                {
                                    // ReSharper disable once MethodHasAsyncOverload
                                    if (!_lstSpirits.Any(s => s.Fettered, token)
                                        // ReSharper disable once MethodHasAsyncOverload
                                        && Improvements.Any(imp => imp.ImproveSource == Improvement.ImprovementSource.SpiritFettering, token))
                                    {
                                        // ReSharper disable once MethodHasAsyncOverload
                                        ImprovementManager.RemoveImprovements(
                                            this, Improvement.ImprovementSource.SpiritFettering, token: token);
                                    }
                                }
                                else
                                {
                                    if (!await _lstSpirits.AnyAsync(s => s.GetFetteredAsync(token), token).ConfigureAwait(false)
                                        && await Improvements
                                                 .AnyAsync(
                                                     imp => imp.ImproveSource
                                                            == Improvement.ImprovementSource.SpiritFettering, token)
                                                 .ConfigureAwait(false))
                                    {
                                        await ImprovementManager.RemoveImprovementsAsync(this,
                                                                    Improvement.ImprovementSource.SpiritFettering,
                                                                    token: token)
                                                                .ConfigureAwait(false);
                                    }
                                }

                                //Timekeeper.Finish("load_char_spirits");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("Label_ComplexForms", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("Label_ComplexForms",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_complex", loadActivity))
                            {
                                // Complex Forms/Technomancer Programs.
                                objXmlNodeList = objXmlCharacter.SelectNodes("complexforms/complexform");
                                foreach (XmlNode objXmlComplexForm in objXmlNodeList)
                                {
                                    ComplexForm objComplexForm = new ComplexForm(this);
                                    try
                                    {
                                        if (blnSync)
                                        {
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            objComplexForm.Load(objXmlComplexForm);
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstComplexForms.Add(objComplexForm);
                                        }
                                        else
                                        {
                                            await objComplexForm.LoadAsync(objXmlComplexForm, token).ConfigureAwait(false);
                                            await _lstComplexForms.AddAsync(objComplexForm, token).ConfigureAwait(false);
                                        }
                                    }
                                    catch
                                    {
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            objComplexForm.Remove(false);
                                        else
                                            await objComplexForm.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                                        throw;
                                    }
                                }

                                //Timekeeper.Finish("load_char_complex");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("Tab_AdvancedPrograms", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("Tab_AdvancedPrograms",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_aiprogram", loadActivity))
                            {
                                // Complex Forms/Technomancer Programs.
                                objXmlNodeList = objXmlCharacter.SelectNodes("aiprograms/aiprogram");
                                foreach (XmlNode objXmlProgram in objXmlNodeList)
                                {
                                    AIProgram objProgram = new AIProgram(this);
                                    try
                                    {
                                        if (blnSync)
                                        {
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            objProgram.Load(objXmlProgram);
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstAIPrograms.Add(objProgram);
                                        }
                                        else
                                        {
                                            await objProgram.LoadAsync(objXmlProgram, token).ConfigureAwait(false);
                                            await _lstAIPrograms.AddAsync(objProgram, token).ConfigureAwait(false);
                                        }
                                    }
                                    catch
                                    {
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            objProgram.Remove(false);
                                        else
                                            await objProgram.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                                        throw;
                                    }
                                }

                                //Timekeeper.Finish("load_char_aiprogram");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("Tab_MartialArts", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("Tab_MartialArts",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_martialarts", loadActivity))
                            {
                                // Martial Arts.
                                objXmlNodeList = objXmlCharacter.SelectNodes("martialarts/martialart");
                                foreach (XmlNode objXmlArt in objXmlNodeList)
                                {
                                    MartialArt objMartialArt = new MartialArt(this);
                                    try
                                    {
                                        if (blnSync)
                                        {
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            objMartialArt.Load(objXmlArt);
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstMartialArts.Add(objMartialArt);
                                        }
                                        else
                                        {
                                            await objMartialArt.LoadAsync(objXmlArt, token).ConfigureAwait(false);
                                            await _lstMartialArts.AddAsync(objMartialArt, token).ConfigureAwait(false);
                                        }
                                    }
                                    catch
                                    {
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            objMartialArt.DeleteMartialArt();
                                        else
                                            await objMartialArt.DeleteMartialArtAsync(token: CancellationToken.None).ConfigureAwait(false);
                                        throw;
                                    }
                                }

                                //Timekeeper.Finish("load_char_marts");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_Limits", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager
                                                                  .GetStringAsync("Tab_Limits", token: token)
                                                                  .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_mod", loadActivity))
                            {
                                // Limit Modifiers.
                                objXmlNodeList = objXmlCharacter.SelectNodes("limitmodifiers/limitmodifier");
                                foreach (XmlNode objXmlLimit in objXmlNodeList)
                                {
                                    LimitModifier objLimitModifier = new LimitModifier(this);
                                    if (blnSync)
                                    {
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        objLimitModifier.Load(objXmlLimit);
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstLimitModifiers.Add(objLimitModifier);
                                    }
                                    else
                                    {
                                        await objLimitModifier.LoadAsync(objXmlLimit, token).ConfigureAwait(false);
                                        await _lstLimitModifiers.AddAsync(objLimitModifier, token).ConfigureAwait(false);
                                    }
                                }

                                //Timekeeper.Finish("load_char_mod");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("String_SelectPACKSKit_Lifestyles", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager
                                              .GetStringAsync("String_SelectPACKSKit_Lifestyles", token: token)
                                              .ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_lifestyle", loadActivity))
                            {
                                // Lifestyles.
                                objXmlNodeList = objXmlCharacter.SelectNodes("lifestyles/lifestyle");
                                foreach (XmlNode objXmlLifestyle in objXmlNodeList)
                                {
                                    Lifestyle objLifestyle = new Lifestyle(this);
                                    try
                                    {
                                        if (blnSync)
                                        {
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            objLifestyle.Load(objXmlLifestyle);
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstLifestyles.Add(objLifestyle);
                                        }
                                        else
                                        {
                                            await objLifestyle.LoadAsync(objXmlLifestyle, token: token).ConfigureAwait(false);
                                            await _lstLifestyles.AddAsync(objLifestyle, token).ConfigureAwait(false);
                                        }
                                    }
                                    catch
                                    {
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            objLifestyle.Remove(false);
                                        else
                                            await objLifestyle.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                                        throw;
                                    }
                                }

                                //Timekeeper.Finish("load_char_lifestyle");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_Gear", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager
                                                                  .GetStringAsync("Tab_Gear", token: token)
                                                                  .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_gear", loadActivity))
                            {
                                // <gears>
                                objXmlNodeList = objXmlCharacter.SelectNodes("gears/gear");
                                foreach (XmlNode objXmlGear in objXmlNodeList)
                                {
                                    Gear objGear = new Gear(this);
                                    if (blnSync)
                                    {
                                        try
                                        {
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            objGear.Load(objXmlGear);
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstGear.Add(objGear);
                                        }
                                        catch
                                        {
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            objGear.DeleteGear();
                                            throw;
                                        }
                                    }
                                    else
                                    {
                                        try
                                        {
                                            await objGear.LoadAsync(objXmlGear, token: token).ConfigureAwait(false);
                                            await _lstGear.AddAsync(objGear, token).ConfigureAwait(false);
                                        }
                                        catch
                                        {
                                            await objGear.DeleteGearAsync(token: CancellationToken.None).ConfigureAwait(false);
                                            throw;
                                        }
                                    }
                                }

                                // If the character has a technomancer quality but no Living Persona commlink, its improvements get re-applied immediately
                                if (objLivingPersonaQuality != null && LastSavedVersion <= new ValueVersion(5, 195, 1))
                                {
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverload
                                        ImprovementManager.RemoveImprovements(this,
                                                                              Improvement.ImprovementSource.Quality,
                                                                              objLivingPersonaQuality.InternalId, token: token);
                                    else
                                        await ImprovementManager.RemoveImprovementsAsync(this,
                                            Improvement.ImprovementSource.Quality,
                                            objLivingPersonaQuality.InternalId, token: token).ConfigureAwait(false);

                                    XmlNode objNode = blnSync
                                        // ReSharper disable once MethodHasAsyncOverload
                                        ? objLivingPersonaQuality.GetNode(token: token)
                                        : await objLivingPersonaQuality.GetNodeAsync(token: token)
                                                                       .ConfigureAwait(false);
                                    if (objNode != null)
                                    {
                                        objLivingPersonaQuality.Bonus = objNode["bonus"];
                                        if (objLivingPersonaQuality.Bonus != null)
                                        {
                                            ImprovementManager.SetForcedValue(objLivingPersonaQuality.Extra, this);
                                            if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverload
                                                ImprovementManager.CreateImprovements(this,
                                                    Improvement.ImprovementSource.Quality,
                                                    objLivingPersonaQuality.InternalId,
                                                    objLivingPersonaQuality
                                                        .Bonus, 1,
                                                    objLivingPersonaQuality.CurrentDisplayNameShort, token: token);
                                            else
                                                await ImprovementManager.CreateImprovementsAsync(this,
                                                    Improvement.ImprovementSource.Quality,
                                                    objLivingPersonaQuality.InternalId,
                                                    objLivingPersonaQuality
                                                        .Bonus, 1,
                                                    await objLivingPersonaQuality.GetCurrentDisplayNameShortAsync(token)
                                                        .ConfigureAwait(false), token: token).ConfigureAwait(false);
                                            string strSelectedValue =
                                                ImprovementManager.GetSelectedValue(this);
                                            if (!string.IsNullOrEmpty(strSelectedValue))
                                            {
                                                objLivingPersonaQuality.Extra = strSelectedValue;
                                            }
                                        }

                                        objLivingPersonaQuality.FirstLevelBonus = objNode["firstlevelbonus"];
                                        if (objLivingPersonaQuality.FirstLevelBonus?.HasChildNodes == true)
                                        {
                                            string strCheckExtra = blnSync
                                                ? objLivingPersonaQuality.Extra
                                                : await objLivingPersonaQuality.GetExtraAsync(token).ConfigureAwait(false);
                                            string strCheckSourceName = blnSync
                                                ? objLivingPersonaQuality.SourceName
                                                : await objLivingPersonaQuality.GetSourceNameAsync(token).ConfigureAwait(false);
                                            bool blnDoFirstLevel;
                                            if (blnSync)
                                            {
                                                // ReSharper disable once MethodHasAsyncOverload
                                                blnDoFirstLevel = !Qualities.Any(objCheckQuality =>
                                                    objCheckQuality != objLivingPersonaQuality &&
                                                    objCheckQuality.SourceID == objLivingPersonaQuality.SourceID &&
                                                    objCheckQuality.Extra == strCheckExtra &&
                                                    objCheckQuality.SourceName == strCheckSourceName, token);
                                            }
                                            else
                                            {
                                                blnDoFirstLevel = !await (await GetQualitiesAsync(token).ConfigureAwait(false)).AnyAsync(async objCheckQuality =>
                                                    objCheckQuality != objLivingPersonaQuality &&
                                                    objCheckQuality.SourceID == objLivingPersonaQuality.SourceID &&
                                                    await objCheckQuality.GetExtraAsync(token).ConfigureAwait(false) == strCheckExtra &&
                                                    await objCheckQuality.GetSourceNameAsync(token).ConfigureAwait(false) == strCheckSourceName, token).ConfigureAwait(false);
                                            }

                                            if (blnDoFirstLevel)
                                            {
                                                ImprovementManager.SetForcedValue(objLivingPersonaQuality.Extra, this);
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverload
                                                    ImprovementManager.CreateImprovements(this,
                                                        Improvement.ImprovementSource.Quality,
                                                        objLivingPersonaQuality.InternalId,
                                                        objLivingPersonaQuality
                                                            .FirstLevelBonus, 1,
                                                        objLivingPersonaQuality.CurrentDisplayNameShort, token: token);
                                                else
                                                    await ImprovementManager.CreateImprovementsAsync(this,
                                                                                Improvement.ImprovementSource.Quality,
                                                                                objLivingPersonaQuality.InternalId,
                                                                                objLivingPersonaQuality
                                                                                    .FirstLevelBonus, 1,
                                                                                await objLivingPersonaQuality
                                                                                    .GetCurrentDisplayNameShortAsync(
                                                                                        token)
                                                                                    .ConfigureAwait(false),
                                                                                token: token)
                                                                            .ConfigureAwait(false);
                                                string strSelectedValue =
                                                    ImprovementManager.GetSelectedValue(this);
                                                if (!string.IsNullOrEmpty(strSelectedValue))
                                                {
                                                    if (blnSync)
                                                        objLivingPersonaQuality.Extra = strSelectedValue;
                                                    else
                                                        await objLivingPersonaQuality.SetExtraAsync(strSelectedValue, token).ConfigureAwait(false);
                                                }
                                            }
                                        }
                                    }
                                    else
                                    {
                                        // Failed to re-apply the improvements immediately, so let's just add it for processing when the character is opened
                                        lstInternalIdsNeedingReapplyImprovements.Add(
                                            objLivingPersonaQuality.InternalId);
                                    }

                                    objLivingPersonaQuality.NaturalWeaponsNode = objNode["naturalweapons"];
                                    if (objLivingPersonaQuality.NaturalWeaponsNode != null)
                                    {
                                        ImprovementManager.SetForcedValue(objLivingPersonaQuality.Extra, this);
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverload
                                            ImprovementManager.CreateImprovements(this,
                                                Improvement.ImprovementSource.Quality,
                                                objLivingPersonaQuality.InternalId,
                                                objLivingPersonaQuality
                                                    .NaturalWeaponsNode, 1,
                                                objLivingPersonaQuality.CurrentDisplayNameShort, token: token);
                                        else
                                            await ImprovementManager.CreateImprovementsAsync(this,
                                                                        Improvement.ImprovementSource.Quality,
                                                                        objLivingPersonaQuality.InternalId,
                                                                        objLivingPersonaQuality
                                                                            .NaturalWeaponsNode, 1,
                                                                        await objLivingPersonaQuality
                                                                              .GetCurrentDisplayNameShortAsync(token)
                                                                              .ConfigureAwait(false), token: token)
                                                                    .ConfigureAwait(false);
                                        string strSelectedValue =
                                            ImprovementManager.GetSelectedValue(this);
                                        if (!string.IsNullOrEmpty(strSelectedValue))
                                        {
                                            objLivingPersonaQuality.Extra = strSelectedValue;
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_gear");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("Label_Vehicles", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("Label_Vehicles",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_car", loadActivity))
                            {
                                // Vehicles.
                                objXmlNodeList = objXmlCharacter.SelectNodes("vehicles/vehicle");
                                foreach (XmlNode objXmlVehicle in objXmlNodeList)
                                {
                                    Vehicle objVehicle = new Vehicle(this);
                                    if (blnSync)
                                    {
                                        try
                                        {
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            objVehicle.Load(objXmlVehicle);
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstVehicles.Add(objVehicle);
                                        }
                                        catch
                                        {
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            objVehicle.DeleteVehicle();
                                            throw;
                                        }
                                    }
                                    else
                                    {
                                        try
                                        {
                                            await objVehicle.LoadAsync(objXmlVehicle, token: token).ConfigureAwait(false);
                                            await _lstVehicles.AddAsync(objVehicle, token).ConfigureAwait(false);
                                        }
                                        catch
                                        {
                                            await objVehicle.DeleteVehicleAsync(CancellationToken.None).ConfigureAwait(false);
                                            throw;
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_car");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_Weapons", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager
                                                                  .GetStringAsync("Tab_Weapons", token: token)
                                                                  .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_weapons", loadActivity))
                            {
                                // Weapons.
                                objXmlNodeList = objXmlCharacter.SelectNodes("weapons/weapon");
                                foreach (XmlNode objXmlWeapon in objXmlNodeList)
                                {
                                    Weapon objWeapon = new Weapon(this);
                                    if (blnSync)
                                    {
                                        try
                                        {
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            objWeapon.Load(objXmlWeapon);
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstWeapons.Add(objWeapon);
                                        }
                                        catch
                                        {
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            objWeapon.DeleteWeapon();
                                            throw;
                                        }
                                    }
                                    else
                                    {
                                        try
                                        {
                                            await objWeapon.LoadAsync(objXmlWeapon, token: token).ConfigureAwait(false);
                                            await _lstWeapons.AddAsync(objWeapon, token).ConfigureAwait(false);
                                        }
                                        catch
                                        {
                                            await objWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                                            throw;
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_weapons");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("String_Metamagics", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("String_Metamagics",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_metamagics", loadActivity))
                            {
                                // Metamagics/Echoes.
                                objXmlNodeList = objXmlCharacter.SelectNodes("metamagics/metamagic");
                                foreach (XmlNode objXmlMetamagic in objXmlNodeList)
                                {
                                    Metamagic objMetamagic = new Metamagic(this);
                                    if (blnSync)
                                    {
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        objMetamagic.Load(objXmlMetamagic);
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstMetamagics.Add(objMetamagic);
                                    }
                                    else
                                    {
                                        await objMetamagic.LoadAsync(objXmlMetamagic, token).ConfigureAwait(false);
                                        await _lstMetamagics.AddAsync(objMetamagic, token).ConfigureAwait(false);
                                    }
                                }

                                //Timekeeper.Finish("load_char_mmagic");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("String_Arts", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager
                                                                  .GetStringAsync("String_Arts", token: token)
                                                                  .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_arts", loadActivity))
                            {
                                // Arts
                                objXmlNodeList = objXmlCharacter.SelectNodes("arts/art");
                                foreach (XmlNode objXmlArt in objXmlNodeList)
                                {
                                    Art objArt = new Art(this);
                                    if (blnSync)
                                    {
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        objArt.Load(objXmlArt);
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstArts.Add(objArt);
                                    }
                                    else
                                    {
                                        await objArt.LoadAsync(objXmlArt, token).ConfigureAwait(false);
                                        await _lstArts.AddAsync(objArt, token).ConfigureAwait(false);
                                    }
                                }

                                //Timekeeper.Finish("load_char_arts");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("String_Enhancements", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("String_Enhancements",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_enhancements", loadActivity))
                            {
                                // Enhancements
                                objXmlNodeList = objXmlCharacter.SelectNodes("enhancements/enhancement");
                                foreach (XmlNode objXmlEnhancement in objXmlNodeList)
                                {
                                    Enhancement objEnhancement = new Enhancement(this);
                                    if (blnSync)
                                    {
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        objEnhancement.Load(objXmlEnhancement);
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstEnhancements.Add(objEnhancement);
                                    }
                                    else
                                    {
                                        await objEnhancement.LoadAsync(objXmlEnhancement, token).ConfigureAwait(false);
                                        await _lstEnhancements.AddAsync(objEnhancement, token).ConfigureAwait(false);
                                    }
                                }

                                //Timekeeper.Finish("load_char_ench");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_Critter", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager
                                                                  .GetStringAsync("Tab_Critter", token: token)
                                                                  .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_critterpowers", loadActivity))
                            {
                                // Critter Powers.
                                objXmlNodeList = objXmlCharacter.SelectNodes("critterpowers/critterpower");
                                foreach (XmlNode objXmlPower in objXmlNodeList)
                                {
                                    CritterPower objPower = new CritterPower(this);
                                    if (blnSync)
                                    {
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        objPower.Load(objXmlPower);
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstCritterPowers.Add(objPower);
                                    }
                                    else
                                    {
                                        await objPower.LoadAsync(objXmlPower, token).ConfigureAwait(false);
                                        await _lstCritterPowers.AddAsync(objPower, token).ConfigureAwait(false);
                                    }
                                }

                                //Timekeeper.Finish("load_char_cpow");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("Label_SummaryFoci", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("Label_SummaryFoci",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_foci", loadActivity))
                            {
                                // Foci.
                                objXmlNodeList = objXmlCharacter.SelectNodes("foci/focus");
                                foreach (XmlNode objXmlFocus in objXmlNodeList)
                                {
                                    Focus objFocus = new Focus(this);
                                    if (blnSync)
                                    {
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        objFocus.Load(objXmlFocus);
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstFoci.Add(objFocus);
                                    }
                                    else
                                    {
                                        await objFocus.LoadAsync(objXmlFocus, token).ConfigureAwait(false);
                                        await _lstFoci.AddAsync(objFocus, token).ConfigureAwait(false);
                                    }
                                }

                                //Timekeeper.Finish("load_char_foci");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("Label_SummaryInitiation", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager
                                                                  .GetStringAsync("Label_SummaryInitiation",
                                                                      token: token)
                                                                  .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_init", loadActivity))
                            {
                                // Initiation Grades.
                                objXmlNodeList = objXmlCharacter.SelectNodes("initiationgrades/initiationgrade");
                                foreach (XmlNode objXmlGrade in objXmlNodeList)
                                {
                                    InitiationGrade objGrade = new InitiationGrade(this);
                                    objGrade.Load(objXmlGrade);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstInitiationGrades.Add(objGrade);
                                    else
                                        await _lstInitiationGrades.AddAsync(objGrade, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_init");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("String_Expenses", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("String_Expenses",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            // While expenses are to be saved in create mode due to starting nuyen and starting karma being logged as expense log entries,
                            // they shouldn't get loaded in create mode because they shouldn't be there.
                            if (Created)
                            {
                                using (Timekeeper.StartSyncron("load_char_elog", loadActivity))
                                {
                                    // Expense Log Entries.
                                    XmlNodeList objXmlExpenseList = objXmlCharacter.SelectNodes("expenses/expense");
                                    foreach (XmlNode objXmlExpense in objXmlExpenseList)
                                    {
                                        ExpenseLogEntry objExpenseLogEntry = new ExpenseLogEntry(this);
                                        if (blnSync)
                                        {
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            objExpenseLogEntry.Load(objXmlExpense);
                                            _lstExpenseLog.AddWithSort(objExpenseLogEntry, token: token);
                                        }
                                        else
                                        {
                                            await objExpenseLogEntry.LoadAsync(objXmlExpense, token).ConfigureAwait(false);
                                            await _lstExpenseLog.AddWithSortAsync(objExpenseLogEntry, token: token)
                                                                .ConfigureAwait(false);
                                        }
                                    }

                                    //Timekeeper.Finish("load_char_elog");
                                }
                            }
#if DEBUG
                            else
                            {
                                // There shouldn't be any expenses for a character loaded in create mode. This code is to help narrow down issues should expenses somehow be created.
                                XmlNodeList objXmlExpenseList = objXmlCharacter.SelectNodes("expenses/expense");
                                if (objXmlExpenseList?.Count > 0)
                                {
                                    Utils.BreakIfDebug();
                                }
                            }
#endif
                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("Tip_Skill_Sustain", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("Tip_Skill_Sustain",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            // Need to load these after everything else so that we can properly link them up during loading
                            using (Timekeeper.StartSyncron("load_char_sustainedobjects", loadActivity))
                            {
                                objXmlNodeList = objXmlCharacter.SelectNodes("sustainedobjects");
                                foreach (XmlNode objXmlSustained in objXmlNodeList)
                                {
                                    SustainedObject objSustained = new SustainedObject(this, objXmlSustained);
                                    if (!objSustained.InternalId.IsEmptyGuid())
                                    {
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstSustainedObjects.Add(objSustained);
                                        else
                                            await _lstSustainedObjects.AddAsync(objSustained, token)
                                                .ConfigureAwait(false);
                                    }
                                }
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("Tab_Improvements", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("Tab_Improvements",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_igroup", loadActivity))
                            {
                                // Improvement Groups.
                                XmlNodeList objXmlGroupList =
                                    objXmlCharacter.SelectNodes("improvementgroups/improvementgroup");
                                if (blnSync)
                                {
                                    foreach (XmlNode objXmlGroup in objXmlGroupList)
                                    {
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstImprovementGroups.Add(objXmlGroup.InnerTextViaPool(token));
                                    }
                                }
                                else
                                {
                                    foreach (XmlNode objXmlGroup in objXmlGroupList)
                                    {
                                        await _lstImprovementGroups.AddAsync(objXmlGroup.InnerTextViaPool(token), token)
                                                                   .ConfigureAwait(false);
                                    }
                                }

                                //Timekeeper.Finish("load_char_igroup");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_Calendar", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager
                                                                  .GetStringAsync("Tab_Calendar", token: token)
                                                                  .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_calendar", loadActivity))
                            {
                                // Calendar.
                                XmlNodeList objXmlWeekList = objXmlCharacter.SelectNodes("calendar/week");
                                foreach (XmlNode objXmlWeek in objXmlWeekList)
                                {
                                    CalendarWeek objWeek = new CalendarWeek();
                                    try
                                    {
                                        token.ThrowIfCancellationRequested();
                                        if (blnSync)
                                        {
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            objWeek.Load(objXmlWeek);
                                            _lstCalendar.AddWithSort(objWeek, (x, y) => y.CompareTo(x), token: token);
                                        }
                                        else
                                        {
                                            await objWeek.LoadAsync(objXmlWeek, token).ConfigureAwait(false);
                                            await _lstCalendar
                                                  .AddWithSortAsync(objWeek, (x, y) => y.CompareTo(x), token: token)
                                                  .ConfigureAwait(false);
                                        }
                                    }
                                    catch
                                    {
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverload
                                            objWeek.Dispose();
                                        else
                                            await objWeek.DisposeAsync().ConfigureAwait(false);
                                        throw;
                                    }
                                }

                                //Timekeeper.Finish("load_char_calendar");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("String_LegacyFixes", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("String_LegacyFixes",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_unarmed", loadActivity))
                            {
                                // Look for the unarmed attack
                                bool blnFoundUnarmed = false;
                                foreach (Weapon objWeapon in _lstWeapons)
                                {
                                    if (objWeapon.Name == "Unarmed Attack")
                                    {
                                        blnFoundUnarmed = true;
                                        break;
                                    }
                                }

                                if (!blnFoundUnarmed)
                                {
                                    // Add the Unarmed Attack Weapon to the character.
                                    XmlDocument objXmlWeaponDoc = blnSync
                                        // ReSharper disable once MethodHasAsyncOverload
                                        ? LoadData("weapons.xml", token: token)
                                        : await LoadDataAsync("weapons.xml", token: token).ConfigureAwait(false);
                                    XmlNode objXmlWeapon =
                                        objXmlWeaponDoc.SelectSingleNode(
                                            "/chummer/weapons/weapon[name = \"Unarmed Attack\"]");
                                    if (objXmlWeapon != null)
                                    {
                                        Weapon objWeapon = new Weapon(this);
                                        try
                                        {
                                            if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverload
                                                objWeapon.Create(objXmlWeapon, _lstWeapons, token: token);
                                            else
                                                await objWeapon.CreateAsync(objXmlWeapon, _lstWeapons, token: token).ConfigureAwait(false);
                                            objWeapon.IncludedInWeapon = true; // Unarmed attack can never be removed
                                            if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                _lstWeapons.Add(objWeapon);
                                            else
                                                await _lstWeapons.AddAsync(objWeapon, token).ConfigureAwait(false);
                                        }
                                        catch
                                        {
                                            if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                objWeapon.DeleteWeapon();
                                            else
                                                await objWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                                            throw;
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_unarmed");
                            }

                            using (Timekeeper.StartSyncron("load_char_dwarffix", loadActivity))
                            {
                                // converting from old dwarven resistance to new dwarven resistance
                                if (Metatype.Equals("dwarf", StringComparison.OrdinalIgnoreCase))
                                {
                                    Quality objOldQuality = blnSync
                                        ? Qualities.FirstOrDefault(x =>
                                                                       x.Name.Equals(
                                                                           "Resistance to Pathogens and Toxins",
                                                                           StringComparison.Ordinal))
                                        : await Qualities.FirstOrDefaultAsync(x =>
                                                                                  x.Name.Equals(
                                                                                      "Resistance to Pathogens and Toxins",
                                                                                      StringComparison.Ordinal), token)
                                                         .ConfigureAwait(false);
                                    if (objOldQuality != null)
                                    {
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverload
                                            objOldQuality.DeleteQuality(token: token);
                                        else
                                            await objOldQuality.DeleteQualityAsync(token: token).ConfigureAwait(false);

                                        if (blnSync
                                                // ReSharper disable once MethodHasAsyncOverload
                                                ? Qualities.All(x => !x.Name.Equals("Resistance to Pathogens/Toxins", StringComparison.Ordinal)
                                                                     && !x.Name.Equals("Dwarf Resistance", StringComparison.Ordinal), token)
                                                : await Qualities.AllAsync(x => !x.Name.Equals("Resistance to Pathogens/Toxins", StringComparison.Ordinal)
                                                                               && !x.Name.Equals("Dwarf Resistance", StringComparison.Ordinal), token).ConfigureAwait(false))
                                        {
                                            XmlNode objXmlDwarfQuality =
                                                xmlRootQualitiesNode.SelectSingleNode(
                                                    "quality[name = \"Resistance to Pathogens/Toxins\"]") ??
                                                xmlRootQualitiesNode.SelectSingleNode(
                                                    "quality[name = \"Dwarf Resistance\"]");

                                            List<Weapon> lstWeapons = new List<Weapon>(1);
                                            Quality objQuality = new Quality(this);

                                            try
                                            {
                                                token.ThrowIfCancellationRequested();
                                                if (blnSync)
                                                {
                                                    // ReSharper disable once MethodHasAsyncOverload
                                                    objQuality.Create(objXmlDwarfQuality, QualitySource.Metatype,
                                                        lstWeapons, token: token);
                                                    foreach (Weapon objWeapon in lstWeapons)
                                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                        Weapons.Add(objWeapon);
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    Qualities.Add(objQuality);
                                                }
                                                else
                                                {
                                                    await objQuality.CreateAsync(objXmlDwarfQuality, QualitySource.Metatype,
                                                        lstWeapons, token: token).ConfigureAwait(false);
                                                    foreach (Weapon objWeapon in lstWeapons)
                                                        await Weapons.AddAsync(objWeapon, token).ConfigureAwait(false);
                                                    await Qualities.AddAsync(objQuality, token).ConfigureAwait(false);
                                                }
                                            }
                                            catch
                                            {
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverload
                                                    objQuality.DeleteQuality(token: CancellationToken.None);
                                                else
                                                    await objQuality.DeleteQualityAsync(token: CancellationToken.None).ConfigureAwait(false);
                                                throw;
                                            }
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_dwarffix");
                            }

                            using (Timekeeper.StartSyncron("load_char_cyberadeptfix", loadActivity))
                            {
                                //Sweep through grades if we have any cyberadept improvements that need reassignment
                                if (lstCyberadeptSweepGrades.Count > 0)
                                {
                                    foreach (Improvement objCyberadeptImprovement in lstCyberadeptSweepGrades)
                                    {
                                        InitiationGrade objBestGradeMatch = null;
                                        if (blnSync)
                                        {
                                            // ReSharper disable once MethodHasAsyncOverload
                                            InitiationGrades.ForEach(objInitiationGrade =>
                                            {
                                                if (!objInitiationGrade.Technomancer
                                                    || objInitiationGrade.Grade.DivAwayFromZero(2) >
                                                    objCyberadeptImprovement.Value
                                                    || Metamagics.Any(x => x.Grade == objInitiationGrade.Grade, token)
                                                    || lstCyberadeptSweepGrades.TrueForAll(x =>
                                                            x.ImproveSource != Improvement.ImprovementSource
                                                                .CyberadeptDaemon
                                                            || x.SourceName != objInitiationGrade.InternalId))
                                                    return;
                                                if (objBestGradeMatch == null ||
                                                    objBestGradeMatch.Grade > objInitiationGrade.Grade)
                                                    objBestGradeMatch = objInitiationGrade;
                                            }, token);
                                        }
                                        else
                                        {
                                            await InitiationGrades.ForEachAsync(async objInitiationGrade =>
                                            {
                                                if (!objInitiationGrade.Technomancer
                                                    || objInitiationGrade.Grade.DivAwayFromZero(2) >
                                                    objCyberadeptImprovement.Value
                                                    || await Metamagics.AnyAsync(
                                                        x => x.Grade == objInitiationGrade.Grade, token).ConfigureAwait(false)
                                                    || lstCyberadeptSweepGrades.TrueForAll(x =>
                                                        x.ImproveSource != Improvement.ImprovementSource
                                                            .CyberadeptDaemon
                                                        || x.SourceName != objInitiationGrade.InternalId))
                                                    return;
                                                if (objBestGradeMatch == null ||
                                                    objBestGradeMatch.Grade > objInitiationGrade.Grade)
                                                    objBestGradeMatch = objInitiationGrade;
                                            }, token).ConfigureAwait(false);
                                        }

                                        if (objBestGradeMatch != null)
                                        {
                                            objCyberadeptImprovement.ImproveSource =
                                                Improvement.ImprovementSource.CyberadeptDaemon;
                                            objCyberadeptImprovement.SourceName = objBestGradeMatch.InternalId;
                                        }
                                        else if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstImprovements.Remove(objCyberadeptImprovement);
                                        else
                                            await _lstImprovements.RemoveAsync(objCyberadeptImprovement, token)
                                                                  .ConfigureAwait(false);
                                    }
                                }

                                //Timekeeper.Finish("load_char_cyberadeptfix");
                            }

                            using (Timekeeper.StartSyncron("load_char_mentorspiritfix", loadActivity))
                            {
                                if (blnSync)
                                {
                                    Quality objMentorQuality = Qualities.FirstOrDefault(q => q.Name == "Mentor Spirit");
                                    // This character doesn't have any improvements tied to a cached Mentor Spirit value, so re-apply the improvement that adds the Mentor spirit
                                    // ReSharper disable once MethodHasAsyncOverload
                                    if (objMentorQuality != null && !Improvements.Any(imp =>
                                                imp.ImproveType == Improvement.ImprovementType.MentorSpirit &&
                                                !string.IsNullOrEmpty(imp.ImprovedName), token))
                                    {
                                        // Selecting bonuses for a mentor spirit mid-load is confusing, so just show the error and let the player manually re-apply
                                        lstInternalIdsNeedingReapplyImprovements.Add(objMentorQuality.InternalId);
                                    }
                                }
                                else
                                {
                                    Quality objMentorQuality = await Qualities.FirstOrDefaultAsync(q => q.Name == "Mentor Spirit", token).ConfigureAwait(false);
                                    // This character doesn't have any improvements tied to a cached Mentor Spirit value, so re-apply the improvement that adds the Mentor spirit
                                    if (objMentorQuality != null && !await Improvements.AnyAsync(imp =>
                                            imp.ImproveType == Improvement.ImprovementType.MentorSpirit &&
                                            !string.IsNullOrEmpty(imp.ImprovedName), token).ConfigureAwait(false))
                                    {
                                        // Selecting bonuses for a mentor spirit mid-load is confusing, so just show the error and let the player manually re-apply
                                        lstInternalIdsNeedingReapplyImprovements.Add(objMentorQuality.InternalId);
                                    }
                                }

                                //Timekeeper.Finish("load_char_mentorspiritfix");
                            }

                            using (Timekeeper.StartSyncron("load_char_startingnuyenfix", loadActivity))
                            {
                                if (blnSync)
                                {
                                    if (!Created)
                                    {
                                        _decNuyenBP = Math.Max(Math.Min(_decNuyenBP, TotalNuyenMaximumBP), 0);
                                    }
                                }
                                else if (!await GetCreatedAsync(token).ConfigureAwait(false))
                                {
                                    _decNuyenBP =
                                        Math.Max(
                                            Math.Min(_decNuyenBP,
                                                await GetTotalNuyenMaximumBPAsync(token).ConfigureAwait(false)), 0);
                                }
                            }

                            // Fix legacy cases where characters have more attribute points assigned than allowed
                            using (Timekeeper.StartSyncron("load_char_badattributesfix", loadActivity))
                            {
                                if (blnSync)
                                {
                                    if (!Created)
                                    {
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        AttributeSection.AllAttributes.ForEach(x => x.DoBaseFix(), token);
                                    }
                                }
                                else if (!await GetCreatedAsync(token).ConfigureAwait(false))
                                {
                                    await AttributeSection.AllAttributes
                                        .ForEachAsync(async x => await x.DoBaseFixAsync(token: token).ConfigureAwait(false),
                                            token).ConfigureAwait(false);
                                }
                            }

                            // Fix skills that shouldn't be allowed to have specializations having them anyway (needed at the last step because improvements and skill groups can affect this)
                            using (Timekeeper.StartSyncron("load_char_badskillspecsfix", loadActivity))
                            {
                                if (blnSync)
                                {
                                    if (!Created)
                                    {
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        SkillsSection.Skills.ForEach(x =>
                                        {
                                            if (x.Specializations.Count > 0 && !x.CanHaveSpecs)
                                                x.Specializations.Clear();
                                        }, token);
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        SkillsSection.KnowledgeSkills.ForEach(x =>
                                        {
                                            if (x.Specializations.Count > 0 && !x.CanHaveSpecs)
                                                x.Specializations.Clear();
                                        }, token);
                                    }
                                }
                                else if (!await GetCreatedAsync(token).ConfigureAwait(false))
                                {
                                    SkillsSection objSkillsSection = await GetSkillsSectionAsync(token).ConfigureAwait(false);
                                    await (await objSkillsSection.GetSkillsAsync(token).ConfigureAwait(false))
                                        .ForEachWithSideEffectsAsync(
                                            async x =>
                                            {
                                                ThreadSafeObservableCollection<SkillSpecialization> lstSpecs =
                                                    await x.GetSpecializationsAsync(token).ConfigureAwait(false);
                                                if (await lstSpecs.GetCountAsync(token).ConfigureAwait(false) > 0 &&
                                                    !await x.GetCanHaveSpecsAsync(token).ConfigureAwait(false))
                                                    await lstSpecs.ClearAsync(token).ConfigureAwait(false);
                                            }, token).ConfigureAwait(false);
                                    await (await objSkillsSection.GetKnowledgeSkillsAsync(token).ConfigureAwait(false))
                                        .ForEachWithSideEffectsAsync(
                                            async x =>
                                            {
                                                ThreadSafeObservableCollection<SkillSpecialization> lstSpecs =
                                                    await x.GetSpecializationsAsync(token).ConfigureAwait(false);
                                                if (await lstSpecs.GetCountAsync(token).ConfigureAwait(false) > 0 &&
                                                    !await x.GetCanHaveSpecsAsync(token).ConfigureAwait(false))
                                                    await lstSpecs.ClearAsync(token).ConfigureAwait(false);
                                            }, token).ConfigureAwait(false);
                                }
                            }

                            if (LastSavedVersion <= new ValueVersion(5, 225, 686))
                            {
                                // Fix legacy cases where characters have dealer connection improvement keys saved in non-English
                                using (Timekeeper.StartSyncron("load_char_nonenglishdealerconnectionfix", loadActivity))
                                {
                                    if (blnSync)
                                    {
                                        // ReSharper disable MethodHasAsyncOverload
                                        List<Improvement> lstDealerConnectionImprovements = ImprovementManager
                                            .GetCachedImprovementListForValueOf(
                                                this, Improvement.ImprovementType.DealerConnection, token: token);
                                        foreach (Improvement objImprovement in lstDealerConnectionImprovements)
                                        {
                                            string strCategory = objImprovement.UniqueName;
                                            if (!string.IsNullOrEmpty(
                                                    LanguageManager.GetString("String_DealerConnection_" + strCategory,
                                                        false, token)))
                                                continue;
                                            if (LanguageManager.GetString("String_DealerConnection_Drones",
                                                    token: token) ==
                                                strCategory)
                                            {
                                                objImprovement.ImprovedName = "Drones";
                                                objImprovement.UniqueName = "Drones";
                                            }
                                            else if (LanguageManager.GetString(
                                                         "String_DealerConnection_Groundcraft", token: token) ==
                                                     strCategory)
                                            {
                                                objImprovement.ImprovedName = "Groundcraft";
                                                objImprovement.UniqueName = "Groundcraft";
                                            }
                                            else if (LanguageManager.GetString(
                                                         "String_DealerConnection_Aircraft", token: token) ==
                                                     strCategory)
                                            {
                                                objImprovement.ImprovedName = "Aircraft";
                                                objImprovement.UniqueName = "Aircraft";
                                            }
                                            else if (LanguageManager.GetString(
                                                         "String_DealerConnection_Watercraft", token: token) ==
                                                     strCategory)
                                            {
                                                objImprovement.ImprovedName = "Watercraft";
                                                objImprovement.UniqueName = "Watercraft";
                                            }
                                        }
                                        // ReSharper enable MethodHasAsyncOverload
                                    }
                                    else
                                    {
                                        List<Improvement> lstDealerConnectionImprovements = await ImprovementManager
                                            .GetCachedImprovementListForValueOfAsync(
                                                this, Improvement.ImprovementType.DealerConnection, token: token)
                                            .ConfigureAwait(false);
                                        foreach (Improvement objImprovement in lstDealerConnectionImprovements)
                                        {
                                            string strCategory = objImprovement.UniqueName;
                                            if (!string.IsNullOrEmpty(
                                                    await LanguageManager.GetStringAsync(
                                                        "String_DealerConnection_" + strCategory,
                                                        false, token).ConfigureAwait(false)))
                                                continue;
                                            if (await LanguageManager
                                                    .GetStringAsync("String_DealerConnection_Drones", token: token)
                                                    .ConfigureAwait(false) ==
                                                strCategory)
                                            {
                                                objImprovement.ImprovedName = "Drones";
                                                objImprovement.UniqueName = "Drones";
                                            }
                                            else if (await LanguageManager
                                                         .GetStringAsync("String_DealerConnection_Groundcraft",
                                                             token: token).ConfigureAwait(false) ==
                                                     strCategory)
                                            {
                                                objImprovement.ImprovedName = "Groundcraft";
                                                objImprovement.UniqueName = "Groundcraft";
                                            }
                                            else if (await LanguageManager
                                                         .GetStringAsync("String_DealerConnection_Aircraft",
                                                             token: token).ConfigureAwait(false) ==
                                                     strCategory)
                                            {
                                                objImprovement.ImprovedName = "Aircraft";
                                                objImprovement.UniqueName = "Aircraft";
                                            }
                                            else if (await LanguageManager
                                                         .GetStringAsync("String_DealerConnection_Watercraft",
                                                             token: token).ConfigureAwait(false) ==
                                                     strCategory)
                                            {
                                                objImprovement.ImprovedName = "Watercraft";
                                                objImprovement.UniqueName = "Watercraft";
                                            }
                                        }
                                    }
                                }
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("Tab_Options_Plugins", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("Tab_Options_Plugins",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            //Plugins
                            using (Timekeeper.StartSyncron("load_char_plugins", loadActivity))
                            {
                                foreach (IPlugin plugin in blnSync
                                             ? Program.PluginLoader.MyActivePlugins
                                             : await Program.PluginLoader.GetMyActivePluginsAsync(token)
                                                 .ConfigureAwait(false))
                                {
                                    foreach (XmlNode objXmlPlugin in objXmlCharacter.SelectNodes("plugins/" +
                                                 plugin.GetPluginAssembly().GetName().Name))
                                    {
                                        plugin.LoadFileElement(this, objXmlPlugin.InnerTextViaPool(token));
                                    }
                                }

                                //Timekeeper.Finish("load_plugins");
                            }

                            ConcurrentBag<string> lstOldIds = Interlocked.Exchange(ref _lstInternalIdsNeedingReapplyImprovements,
                                                 lstInternalIdsNeedingReapplyImprovements);
                            if (lstOldIds != null)
                            {
                                foreach (string strOldId in lstOldIds)
                                    lstInternalIdsNeedingReapplyImprovements.Add(strOldId);
                            }
                        }
                        finally
                        {
                            if (blnSync)
                                IsLoading = false;
                            else
                                await SetIsLoadingAsync(false, token).ConfigureAwait(false);
                        }

                        if (frmLoadingForm != null)
                        {
                            if (blnSync)
                                // ReSharper disable once MethodHasAsyncOverload
                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                frmLoadingForm.PerformStep(
                                    LanguageManager.GetString("String_GeneratedImprovements", token: token));
                            else
                                await frmLoadingForm.PerformStepAsync(
                                    await LanguageManager.GetStringAsync("String_GeneratedImprovements", token: token)
                                                         .ConfigureAwait(false), token: token).ConfigureAwait(false);
                        }

                        // Refresh certain improvements
                        using (Timekeeper.StartSyncron("load_char_improvementrefreshers1", loadActivity))
                        {
                            // Process all events related to improvements
                            using (new FetchSafelyFromSafeObjectPool<
                                       Dictionary<INotifyMultiplePropertiesChangedAsync, HashSet<string>>>(
                                       Utils.DictionaryForMultiplePropertyChangedPool,
                                       out Dictionary<INotifyMultiplePropertiesChangedAsync, HashSet<string>>
                                           dicChangedProperties))
                            {
                                try
                                {
                                    token.ThrowIfCancellationRequested();
                                    HashSet<string> setAlwaysChangedProperties = Utils.StringHashSetPool.Get();
                                    dicChangedProperties.Add(this, setAlwaysChangedProperties);
                                    setAlwaysChangedProperties.Add(nameof(BlackMarketDiscount));
                                    setAlwaysChangedProperties.Add(nameof(DealerConnectionDiscount));
                                    setAlwaysChangedProperties.Add(nameof(Essence));
                                    setAlwaysChangedProperties.Add(nameof(WoundModifier));
                                    setAlwaysChangedProperties.Add(nameof(SustainingPenalty));
                                    setAlwaysChangedProperties.Add(nameof(Encumbrance));
                                    setAlwaysChangedProperties.Add(nameof(ArmorEncumbrance));
                                    setAlwaysChangedProperties.Add(nameof(LimbCount)); // Makes sure attributes properly reflect equipped cyberlimbs whose effects aren't handled through improvements

                                    if (blnSync)
                                    {
                                        foreach (Improvement objImprovement in Improvements)
                                        {
                                            if (!objImprovement.Enabled)
                                                continue;
                                            foreach ((INotifyMultiplePropertiesChangedAsync objItemToUpdate,
                                                         string strPropertyToUpdate) in objImprovement
                                                         .GetRelevantPropertyChangers())
                                            {
                                                if (!dicChangedProperties.TryGetValue(
                                                        objItemToUpdate, out HashSet<string> setChangedProperties))
                                                {
                                                    setChangedProperties = Utils.StringHashSetPool.Get();
                                                    dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                                }

                                                setChangedProperties.Add(strPropertyToUpdate);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        await Improvements.ForEachAsync(objImprovement =>
                                        {
                                            if (!objImprovement.Enabled)
                                                return;
                                            foreach ((INotifyMultiplePropertiesChangedAsync objItemToUpdate,
                                                         string strPropertyToUpdate) in objImprovement
                                                         .GetRelevantPropertyChangers())
                                            {
                                                if (!dicChangedProperties.TryGetValue(
                                                        objItemToUpdate, out HashSet<string> setChangedProperties))
                                                {
                                                    setChangedProperties = Utils.StringHashSetPool.Get();
                                                    dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                                }

                                                setChangedProperties.Add(strPropertyToUpdate);
                                            }
                                        }, token).ConfigureAwait(false);
                                    }

                                    foreach (KeyValuePair<INotifyMultiplePropertiesChangedAsync, HashSet<string>>
                                                 kvpToProcess in
                                             dicChangedProperties)
                                    {
                                        if (blnSync)
                                            kvpToProcess.Key.OnMultiplePropertiesChanged(kvpToProcess.Value);
                                        else
                                            await kvpToProcess.Key
                                                .OnMultiplePropertiesChangedAsync(kvpToProcess.Value, token)
                                                .ConfigureAwait(false);
                                    }
                                }
                                finally
                                {
                                    List<HashSet<string>> lstToReturn = dicChangedProperties.Values.ToList();
                                    for (int i = lstToReturn.Count - 1; i >= 0; --i)
                                    {
                                        HashSet<string> setLoop = lstToReturn[i];
                                        Utils.StringHashSetPool.Return(ref setLoop);
                                    }
                                }
                            }

                            // Curb Mystic Adept power points if the values that were loaded in would be illegal
                            int intMysAdPPs =
                                blnSync ? MysticAdeptPowerPoints : await GetMysticAdeptPowerPointsAsync(token).ConfigureAwait(false);
                            if (intMysAdPPs > 0)
                            {
                                int intMAGTotalValue = blnSync
                                    ? MAG.TotalValue
                                    : await (await GetAttributeAsync("MAG", token: token).ConfigureAwait(false))
                                            .GetTotalValueAsync(token).ConfigureAwait(false);
                                if (intMysAdPPs > intMAGTotalValue)
                                {
                                    if (blnSync)
                                        MysticAdeptPowerPoints = intMAGTotalValue;
                                    else
                                        await SetMysticAdeptPowerPointsAsync(intMAGTotalValue, token).ConfigureAwait(false);
                                }
                            }

                            if (blnSync)
                            {
                                if (!InitiationEnabled || !AddInitiationsAllowed)
                                {
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ClearInitiations(token);
                                }
                            }
                            else if (!await GetInitiationEnabledAsync(token).ConfigureAwait(false) || !await GetAddInitiationsAllowedAsync(token).ConfigureAwait(false))
                                await ClearInitiationsAsync(token).ConfigureAwait(false);

                            // Very rough fix for when Karma values somehow exceed KarmaMaximum after loading in. This shouldn't happen in the first place, but this ad-hoc patch will help fix crashes.
                            if (blnSync)
                            {
                                if (!Created)
                                {
                                    foreach (CharacterAttrib objAttrib in GetAllAttributesForModification(token))
                                    {
                                        while (objAttrib.Base > 0 && objAttrib.KarmaMaximum < 0)
                                        {
                                            --objAttrib.Base;
                                        }

                                        objAttrib.Karma = Math.Min(objAttrib.Karma, objAttrib.KarmaMaximum);
                                    }
                                }
                            }
                            else if (!await GetCreatedAsync(token).ConfigureAwait(false))
                            {
                                foreach (CharacterAttrib objAttrib in await GetAllAttributesForModificationAsync(token).ConfigureAwait(false))
                                {
                                    while (await objAttrib.GetBaseAsync(token).ConfigureAwait(false) > 0 &&
                                           await objAttrib.GetKarmaMaximumAsync(token).ConfigureAwait(false) < 0)
                                    {
                                        await objAttrib.ModifyBaseAsync(-1, token).ConfigureAwait(false);
                                    }

                                    int intKarmaMaximum =
                                        await objAttrib.GetKarmaMaximumAsync(token).ConfigureAwait(false);
                                    if (await objAttrib.GetKarmaAsync(token).ConfigureAwait(false) > intKarmaMaximum)
                                        await objAttrib.SetKarmaAsync(intKarmaMaximum, token).ConfigureAwait(false);
                                }
                            }

                            while (_setPostLoadMethods.TryTake(out Func<CancellationToken, bool> funcToCall))
                            {
                                if (!funcToCall.Invoke(token))
                                    return false;
                            }

                            if (blnSync)
                            {
                                while (_setPostLoadAsyncMethods.TryTake(out Func<CancellationToken, Task<bool>> funcToCall))
                                {
                                    if (!Utils.SafelyRunSynchronously(() => funcToCall.Invoke(token), token))
                                        return false;
                                }
                            }
                            else
                            {
                                while (_setPostLoadAsyncMethods.TryTake(out Func<CancellationToken, Task<bool>> funcToCall))
                                {
                                    if (!await funcToCall.Invoke(token).ConfigureAwait(false))
                                        return false;
                                }
                            }
                            //Timekeeper.Finish("load_char_improvementrefreshers");
                        }

                        //// If the character had old Qualities that were converted, immediately save the file so they are in the new format.
                        //if (blnHasOldQualities)
                        //{
                        //    Timekeeper.Start("load_char_resav");  //Lets not silently save file on load?
                        //    Save();
                        //    Timekeeper.Finish("load_char_resav");
                        //}
                        loadActivity.SetSuccess(true);
                    }
                    catch (Exception e)
                    {
                        e = e.Demystify();
                        loadActivity.SetSuccess(false);
                        Log.Error(e);
                        throw;
                    }
                }

                return true;
            }
            finally
            {
                if (blnSync)
                    // ReSharper disable once MethodHasAsyncOverload
                    objLocker.Dispose();
                else
                    await objLockerAsync.DisposeAsync().ConfigureAwait(false);
            }
        }

        public Task<XmlDocument> GenerateExportXml(CultureInfo objCultureInfo, string strLanguage)
        {
            return CommonFunctions.GenerateCharactersExportXml(objCultureInfo, strLanguage, this);
        }

        public Task<XmlDocument> GenerateExportXml(CultureInfo objCultureInfo, string strLanguage, CancellationToken objToken)
        {
            return CommonFunctions.GenerateCharactersExportXml(objCultureInfo, strLanguage, objToken, this);
        }

        /// <summary>
        /// Print this character information to a XmlTextWriter. This creates only the character object itself, not any of the opening or closing XmlDocument items.
        /// This can be used to write multiple characters to a single XmlDocument.
        /// </summary>
        /// <param name="objWriter">XmlTextWriter to write to.</param>
        /// <param name="objCulture">Culture in which to print.</param>
        /// <param name="strLanguageToPrint">Language in which to print.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public Task PrintToXmlTextWriter(XmlWriter objWriter, CultureInfo objCulture = null,
                                         string strLanguageToPrint = "", CancellationToken token = default)
        {
            return objWriter != null
                ? PrintToXmlTextWriterCore(objWriter, objCulture, strLanguageToPrint, token)
                : Task.FromException(new ArgumentNullException(nameof(objWriter)));
        }

        /// <summary>
        /// Print this character information to a XmlTextWriter. This creates only the character object itself, not any of the opening or closing XmlDocument items.
        /// This can be used to write multiple characters to a single XmlDocument.
        /// </summary>
        /// <param name="objWriter">XmlTextWriter to write to.</param>
        /// <param name="objCulture">Culture in which to print.</param>
        /// <param name="strLanguageToPrint">Language in which to print.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        private async Task PrintToXmlTextWriterCore(XmlWriter objWriter, CultureInfo objCulture = null,
                                                    string strLanguageToPrint = "", CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (objCulture == null)
                objCulture = GlobalSettings.CultureInfo;
            if (string.IsNullOrEmpty(strLanguageToPrint))
                strLanguageToPrint = GlobalSettings.Language;

            IAsyncDisposable objLockerAsync = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                // <character>
                XmlElementWriteHelper objCharacterElement
                    = await objWriter.StartElementAsync("character", token: token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    // <settings />
                    await objWriter
                        .WriteElementStringAsync("settings", await GetSettingsKeyAsync(token).ConfigureAwait(false),
                            token: token).ConfigureAwait(false);
                    // <buildmethod />
                    await objWriter
                        .WriteElementStringAsync("buildmethod", (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetBuildMethodAsync(token).ConfigureAwait(false)).ToString(), token: token)
                        .ConfigureAwait(false);
                    // <imageformat />
                    await objWriter.WriteElementStringAsync("imageformat",
                            "jpeg", token: token)
                        .ConfigureAwait(
                            false); // Here for legacy/compatibility purposes, we always export as JPEG now
                    // <metatype />
                    await objWriter
                        .WriteElementStringAsync(
                            "metatype", await DisplayMetatypeAsync(strLanguageToPrint, token).ConfigureAwait(false),
                            token: token).ConfigureAwait(false);
                    // <metatype_english />
                    await objWriter.WriteElementStringAsync("metatype_english", await GetMetatypeAsync(token).ConfigureAwait(false), token: token)
                        .ConfigureAwait(false);
                    // <metatype_guid />
                    await objWriter.WriteElementStringAsync("metatype_guid",
                            MetatypeGuid.ToString(
                                "D", GlobalSettings.InvariantCultureInfo), token: token)
                        .ConfigureAwait(false);
                    // <metavariant />
                    await objWriter.WriteElementStringAsync("metavariant",
                            await DisplayMetavariantAsync(strLanguageToPrint, token)
                                .ConfigureAwait(false), token: token)
                        .ConfigureAwait(false);
                    // <metavariant_english />
                    await objWriter.WriteElementStringAsync("metavariant_english", Metavariant, token: token)
                        .ConfigureAwait(false);
                    // <metavariant_guid />
                    await objWriter.WriteElementStringAsync("metavariant_guid",
                            (await GetMetavariantGuidAsync(token).ConfigureAwait(false)).ToString(
                                "D", GlobalSettings.InvariantCultureInfo), token: token)
                        .ConfigureAwait(false);
                    // <movement />
                    await objWriter
                        .WriteElementStringAsync(
                            "movement",
                            await FullMovementAsync(objCulture, strLanguageToPrint, token).ConfigureAwait(false),
                            token: token).ConfigureAwait(false);
                    // <walk />
                    await objWriter
                        .WriteElementStringAsync(
                            "walk",
                            await FullMovementAsync(objCulture, strLanguageToPrint, token).ConfigureAwait(false),
                            token: token).ConfigureAwait(false);
                    // <run />
                    await objWriter
                        .WriteElementStringAsync(
                            "run",
                            await FullMovementAsync(objCulture, strLanguageToPrint, token).ConfigureAwait(false),
                            token: token).ConfigureAwait(false);
                    // <sprint />
                    await objWriter
                        .WriteElementStringAsync(
                            "sprint",
                            await FullMovementAsync(objCulture, strLanguageToPrint, token).ConfigureAwait(false),
                            token: token).ConfigureAwait(false);
                    // <movementwalk />
                    await objWriter.WriteElementStringAsync("movementwalk",
                            await GetMovementAsync(
                                    objCulture, strLanguageToPrint, token)
                                .ConfigureAwait(false), token: token)
                        .ConfigureAwait(false);
                    // <movementswim />
                    await objWriter
                        .WriteElementStringAsync("movementswim",
                            await GetSwimAsync(objCulture, strLanguageToPrint, token)
                                .ConfigureAwait(false), token: token).ConfigureAwait(false);
                    // <movementfly />
                    await objWriter
                        .WriteElementStringAsync("movementfly",
                            await GetFlyAsync(objCulture, strLanguageToPrint, token)
                                .ConfigureAwait(false), token: token).ConfigureAwait(false);

                    // <prioritymetatype />
                    await objWriter.WriteElementStringAsync("prioritymetatype", await GetMetatypePriorityAsync(token).ConfigureAwait(false), token: token)
                        .ConfigureAwait(false);
                    // <priorityattributes />
                    await objWriter.WriteElementStringAsync("priorityattributes", await GetAttributesPriorityAsync(token).ConfigureAwait(false), token: token)
                        .ConfigureAwait(false);
                    // <priorityspecial />
                    await objWriter.WriteElementStringAsync("priorityspecial", await GetSpecialPriorityAsync(token).ConfigureAwait(false), token: token)
                        .ConfigureAwait(false);
                    // <priorityskills />
                    await objWriter.WriteElementStringAsync("priorityskills", await GetSkillsPriorityAsync(token).ConfigureAwait(false), token: token)
                        .ConfigureAwait(false);
                    // <priorityresources />
                    await objWriter.WriteElementStringAsync("priorityresources", await GetResourcesPriorityAsync(token).ConfigureAwait(false), token: token)
                        .ConfigureAwait(false);

                    // <priorityskills>
                    XmlElementWriteHelper objPrioritySkillsElement
                        = await objWriter.StartElementAsync("priorityskills", token: token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        foreach (string strSkill in PriorityBonusSkillList)
                        {
                            await objWriter.WriteElementStringAsync("priorityskill", strSkill, token: token)
                                .ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        // </priorityskills>
                        await objPrioritySkillsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <handedness />
                    if (await GetAmbidextrousAsync(token).ConfigureAwait(false))
                    {
                        await objWriter.WriteElementStringAsync("primaryarm",
                                await LanguageManager.GetStringAsync(
                                    "String_Ambidextrous", strLanguageToPrint,
                                    token: token).ConfigureAwait(false), token: token)
                            .ConfigureAwait(false);
                    }
                    else if (await GetPrimaryArmAsync(token).ConfigureAwait(false) == "Left")
                    {
                        await objWriter.WriteElementStringAsync("primaryarm",
                                await LanguageManager.GetStringAsync(
                                    "String_Improvement_SideLeft", strLanguageToPrint,
                                    token: token).ConfigureAwait(false), token: token)
                            .ConfigureAwait(false);
                    }
                    else
                    {
                        await objWriter.WriteElementStringAsync("primaryarm",
                                await LanguageManager.GetStringAsync(
                                        "String_Improvement_SideRight",
                                        strLanguageToPrint, token: token)
                                    .ConfigureAwait(false), token: token)
                            .ConfigureAwait(false);
                    }

                    // If the character does not have a name, call them Unnamed Character. This prevents a transformed document from
                    // having a self-terminated title tag which causes browser to not rendering anything.
                    // <name />
                    string strMyName = await GetNameAsync(token).ConfigureAwait(false);
                    await objWriter.WriteElementStringAsync("name",
                            !string.IsNullOrEmpty(strMyName)
                                ? strMyName
                                : await LanguageManager.GetStringAsync(
                                    "String_UnnamedCharacter", strLanguageToPrint,
                                    token: token).ConfigureAwait(false), token: token)
                        .ConfigureAwait(false);

                    await PrintMugshots(objWriter, token).ConfigureAwait(false);

                    // <sex />
                    await objWriter.WriteElementStringAsync("gender",
                            await TranslateExtraAsync(
                                    await ReverseTranslateExtraAsync(
                                        await GetGenderAsync(token).ConfigureAwait(false), GlobalSettings.Language, "contacts.xml",
                                        token: token).ConfigureAwait(false),
                                    strLanguageToPrint, "contacts.xml", token: token)
                                .ConfigureAwait(false), token: token)
                        .ConfigureAwait(false);
                    // <age />
                    await objWriter.WriteElementStringAsync("age",
                        await TranslateExtraAsync(
                            await ReverseTranslateExtraAsync(
                                await GetAgeAsync(token).ConfigureAwait(false), GlobalSettings.Language, "contacts.xml",
                                token: token).ConfigureAwait(false),
                            strLanguageToPrint,
                            "contacts.xml", token: token).ConfigureAwait(false),
                        token: token).ConfigureAwait(false);
                    // <eyes />
                    await objWriter.WriteElementStringAsync("eyes",
                        await TranslateExtraAsync(
                            await ReverseTranslateExtraAsync(await GetEyesAsync(token).ConfigureAwait(false), token: token)
                                .ConfigureAwait(false),
                            strLanguageToPrint, token: token).ConfigureAwait(false),
                        token: token).ConfigureAwait(false);
                    // <height />
                    await objWriter.WriteElementStringAsync("height",
                        await TranslateExtraAsync(
                            await ReverseTranslateExtraAsync(await GetHeightAsync(token).ConfigureAwait(false), token: token)
                                .ConfigureAwait(false),
                            strLanguageToPrint, token: token).ConfigureAwait(false),
                        token: token).ConfigureAwait(false);
                    // <weight />
                    await objWriter.WriteElementStringAsync("weight",
                        await TranslateExtraAsync(
                            await ReverseTranslateExtraAsync(await GetWeightAsync(token).ConfigureAwait(false), token: token)
                                .ConfigureAwait(false),
                            strLanguageToPrint, token: token).ConfigureAwait(false),
                        token: token).ConfigureAwait(false);
                    // <skin />
                    await objWriter.WriteElementStringAsync("skin",
                        await TranslateExtraAsync(
                            await ReverseTranslateExtraAsync(await GetSkinAsync(token).ConfigureAwait(false), token: token)
                                .ConfigureAwait(false),
                            strLanguageToPrint, token: token).ConfigureAwait(false),
                        token: token).ConfigureAwait(false);
                    // <hair />
                    await objWriter.WriteElementStringAsync("hair",
                        await TranslateExtraAsync(
                            await ReverseTranslateExtraAsync(await GetHairAsync(token).ConfigureAwait(false), token: token)
                                .ConfigureAwait(false),
                            strLanguageToPrint, token: token).ConfigureAwait(false),
                        token: token).ConfigureAwait(false);
                    // <description />
                    await objWriter
                        .WriteElementStringAsync("description",
                            await (await GetDescriptionAsync(token).ConfigureAwait(false)).RtfToHtmlAsync(token).ConfigureAwait(false),
                            token: token).ConfigureAwait(false);
                    // <background />
                    await objWriter
                        .WriteElementStringAsync("background",
                            await (await GetBackgroundAsync(token).ConfigureAwait(false)).RtfToHtmlAsync(token).ConfigureAwait(false),
                            token: token).ConfigureAwait(false);
                    // <concept />
                    await objWriter
                        .WriteElementStringAsync("concept", await (await GetConceptAsync(token).ConfigureAwait(false)).RtfToHtmlAsync(token).ConfigureAwait(false),
                            token: token).ConfigureAwait(false);
                    // <notes />
                    await objWriter
                        .WriteElementStringAsync("notes", await (await GetNotesAsync(token).ConfigureAwait(false)).RtfToHtmlAsync(token).ConfigureAwait(false),
                            token: token).ConfigureAwait(false);
                    // <alias />
                    await objWriter.WriteElementStringAsync("alias", await GetAliasAsync(token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                    // <playername />
                    await objWriter.WriteElementStringAsync("playername", await GetPlayerNameAsync(token).ConfigureAwait(false), token: token)
                        .ConfigureAwait(false);
                    // <gamenotes />
                    await objWriter
                        .WriteElementStringAsync("gamenotes",
                            await GameNotes.RtfToHtmlAsync(token).ConfigureAwait(false),
                            token: token).ConfigureAwait(false);

                    // <limitphysical />
                    await objWriter
                        .WriteElementStringAsync("limitphysical", LimitPhysical.ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <limitmental />
                    await objWriter
                        .WriteElementStringAsync("limitmental", LimitMental.ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <limitsocial />
                    await objWriter
                        .WriteElementStringAsync("limitsocial", LimitSocial.ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <limitastral />
                    await objWriter
                        .WriteElementStringAsync("limitastral", LimitAstral.ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <contactpoints />
                    await objWriter
                        .WriteElementStringAsync("contactpoints",
                            (await GetContactPointsAsync(token).ConfigureAwait(false)).ToString(
                                objCulture), token: token)
                        .ConfigureAwait(false);
                    // <contactpointsused />
                    await objWriter.WriteElementStringAsync("contactpointsused",
                            (await GetContactPointsUsedAsync(token)
                                .ConfigureAwait(false)).Item1.ToString(objCulture),
                            token: token)
                        .ConfigureAwait(false);
                    // <cfplimit />
                    await objWriter.WriteElementStringAsync("cfplimit", CFPLimit.ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <totalaiprogramlimit />
                    await objWriter.WriteElementStringAsync("ainormalprogramlimit",
                            AINormalProgramLimit.ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <aiadvancedprogramlimit />
                    await objWriter.WriteElementStringAsync("aiadvancedprogramlimit",
                            AIAdvancedProgramLimit.ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <spelllimit />
                    await objWriter.WriteElementStringAsync("spelllimit",
                            (await GetFreeSpellsAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <karma />
                    await objWriter
                        .WriteElementStringAsync(
                            "karma", (await GetKarmaAsync(token).ConfigureAwait(false)).ToString(objCulture),
                            token: token).ConfigureAwait(false);
                    // <totalkarma />
                    await objWriter
                        .WriteElementStringAsync("totalkarma", (await GetCareerKarmaAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <special />
                    await objWriter.WriteElementStringAsync("special", (await GetSpecialAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <totalspecial />
                    await objWriter
                        .WriteElementStringAsync("totalspecial", (await GetTotalSpecialAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <attributes />
                    await objWriter.WriteElementStringAsync("attributes", (await GetAttributesAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <totalattributes />
                    await objWriter
                        .WriteElementStringAsync("totalattributes", (await GetTotalAttributesAsync(token).ConfigureAwait(false)).ToString(objCulture),
                            token: token).ConfigureAwait(false);
                    // <edgeused />
                    await objWriter.WriteElementStringAsync("edgeused", (await GetEdgeUsedAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <edgeremaining />
                    await objWriter
                        .WriteElementStringAsync("edgeremaining", (await GetEdgeRemainingAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <streetcred />
                    await objWriter.WriteElementStringAsync("streetcred", StreetCred.ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <calculatedstreetcred />
                    await objWriter.WriteElementStringAsync("calculatedstreetcred",
                            CalculatedStreetCred.ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <totalstreetcred />
                    await objWriter
                        .WriteElementStringAsync("totalstreetcred", TotalStreetCred.ToString(objCulture),
                            token: token).ConfigureAwait(false);
                    // <burntstreetcred />
                    await objWriter
                        .WriteElementStringAsync("burntstreetcred", BurntStreetCred.ToString(objCulture),
                            token: token).ConfigureAwait(false);
                    // <notoriety />
                    await objWriter.WriteElementStringAsync("notoriety", Notoriety.ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <calculatednotoriety />
                    await objWriter.WriteElementStringAsync("calculatednotoriety",
                            CalculatedNotoriety.ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <totalnotoriety />
                    await objWriter
                        .WriteElementStringAsync("totalnotoriety", TotalNotoriety.ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <publicawareness />
                    await objWriter
                        .WriteElementStringAsync("publicawareness", PublicAwareness.ToString(objCulture),
                            token: token).ConfigureAwait(false);
                    // <calculatedpublicawareness />
                    await objWriter.WriteElementStringAsync("calculatedpublicawareness",
                        CalculatedPublicAwareness.ToString(objCulture),
                        token: token).ConfigureAwait(false);
                    // <totalpublicawareness />
                    await objWriter.WriteElementStringAsync("totalpublicawareness",
                            TotalPublicAwareness.ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <astralreputation />
                    await objWriter
                        .WriteElementStringAsync("astralreputation", AstralReputation.ToString(objCulture),
                            token: token).ConfigureAwait(false);
                    // <totalastralreputation />
                    await objWriter.WriteElementStringAsync("totalastralreputation",
                            TotalAstralReputation.ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <wildreputation />
                    await objWriter
                        .WriteElementStringAsync("wildreputation", WildReputation.ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <totalwildreputation />
                    await objWriter.WriteElementStringAsync("totalwildreputation",
                            TotalWildReputation.ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <created />
                    await objWriter.WriteElementStringAsync(
                            "created", (await GetCreatedAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.InvariantCultureInfo), token: token)
                        .ConfigureAwait(false);
                    string strNuyenFormat = await (await GetSettingsAsync(token).ConfigureAwait(false)).GetNuyenFormatAsync(token).ConfigureAwait(false);
                    // <nuyen />
                    await objWriter
                        .WriteElementStringAsync("nuyen", (await GetNuyenAsync(token).ConfigureAwait(false)).ToString(strNuyenFormat, objCulture),
                            token: token).ConfigureAwait(false);
                    // <adept />
                    await objWriter.WriteElementStringAsync(
                            "adept", (await GetAdeptEnabledAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.InvariantCultureInfo),
                            token: token)
                        .ConfigureAwait(false);
                    // <magician />
                    await objWriter.WriteElementStringAsync(
                            "magician", (await GetMagicianEnabledAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.InvariantCultureInfo),
                            token: token)
                        .ConfigureAwait(false);
                    // <technomancer />
                    await objWriter.WriteElementStringAsync("technomancer",
                            (await GetTechnomancerEnabledAsync(token).ConfigureAwait(false)).ToString(
                                GlobalSettings.InvariantCultureInfo), token: token)
                        .ConfigureAwait(false);
                    // <ai />
                    await objWriter.WriteElementStringAsync("ai",
                            (await GetAdvancedProgramsEnabledAsync(token).ConfigureAwait(false)).ToString(
                                GlobalSettings.InvariantCultureInfo), token: token)
                        .ConfigureAwait(false);
                    // <cyberwaredisabled />
                    await objWriter.WriteElementStringAsync("cyberwaredisabled",
                            (await GetCyberwareDisabledAsync(token).ConfigureAwait(false)).ToString(
                                GlobalSettings.InvariantCultureInfo), token: token)
                        .ConfigureAwait(false);
                    // <critter />
                    await objWriter.WriteElementStringAsync(
                            "critter", (await GetCritterEnabledAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.InvariantCultureInfo),
                            token: token)
                        .ConfigureAwait(false);

                    await objWriter.WriteElementStringAsync(
                        "totaless",
                        (await EssenceAsync(token: token).ConfigureAwait(false)).ToString(
                            await (await GetSettingsAsync(token).ConfigureAwait(false)).GetEssenceFormatAsync(token).ConfigureAwait(false), objCulture), token: token).ConfigureAwait(false);

                    // <tradition />
                    Tradition objTradition = await GetMagicTraditionAsync(token).ConfigureAwait(false);
                    if (objTradition.Type != TraditionType.None)
                    {
                        await objTradition.Print(objWriter, objCulture, strLanguageToPrint, token)
                            .ConfigureAwait(false);
                    }

                    // <attributes>
                    XmlElementWriteHelper objAttributesElement
                        = await objWriter.StartElementAsync("attributes", token: token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await AttributeSection.Print(objWriter, objCulture, strLanguageToPrint, token)
                            .ConfigureAwait(false);
                    }
                    finally
                    {
                        // </attributes>
                        await objAttributesElement.DisposeAsync().ConfigureAwait(false);
                    }

                    int intArmor = await GetTotalArmorRatingAsync(token).ConfigureAwait(false);
                    int intFireArmor = await GetTotalFireArmorRatingAsync(token).ConfigureAwait(false);
                    int intColdArmor = await GetTotalColdArmorRatingAsync(token).ConfigureAwait(false);
                    int intElectricityArmor = await GetTotalElectricityArmorRatingAsync(token).ConfigureAwait(false);
                    int intAcidArmor = await GetTotalAcidArmorRatingAsync(token).ConfigureAwait(false);
                    int intFallingArmor = await GetTotalFallingArmorRatingAsync(token).ConfigureAwait(false);
                    // <dodge />
                    await objWriter.WriteElementStringAsync("dodge", Dodge.ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <armor />
                    await objWriter.WriteElementStringAsync("armor", intArmor.ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <firearmor />
                    await objWriter
                        .WriteElementStringAsync("firearmor", intFireArmor.ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <coldarmor />
                    await objWriter
                        .WriteElementStringAsync("coldarmor", intColdArmor.ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <electricityarmor />
                    await objWriter
                        .WriteElementStringAsync("electricityarmor", intElectricityArmor.ToString(objCulture),
                            token: token).ConfigureAwait(false);
                    // <acidarmor />
                    await objWriter
                        .WriteElementStringAsync("acidarmor", intAcidArmor.ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <fallingarmor />
                    await objWriter
                        .WriteElementStringAsync("fallingarmor", intFallingArmor.ToString(objCulture), token: token)
                        .ConfigureAwait(false);

                    int intDamageResistanceDice = (await ImprovementManager
                            .ValueOfAsync(
                                this, Improvement.ImprovementType.DamageResistance,
                                token: token).ConfigureAwait(false))
                        .StandardRound();
                    int intBodTotalValue = await (await GetAttributeAsync("BOD", token: token).ConfigureAwait(false))
                        .GetTotalValueAsync(token).ConfigureAwait(false);
                    // <armordicestun />
                    await objWriter.WriteElementStringAsync("armordicestun",
                        (intBodTotalValue + intDamageResistanceDice
                                          + intArmor).ToString(objCulture),
                        token: token).ConfigureAwait(false);
                    // <firearmordicestun />
                    await objWriter.WriteElementStringAsync("firearmordicestun",
                        (intBodTotalValue + intDamageResistanceDice
                                          + intFireArmor)
                        .ToString(objCulture), token: token).ConfigureAwait(false);
                    // <coldarmordicestun />
                    await objWriter.WriteElementStringAsync("coldarmordicestun",
                        (intBodTotalValue + intDamageResistanceDice
                                          + intColdArmor)
                        .ToString(objCulture), token: token).ConfigureAwait(false);
                    // <electricityarmordicestun />
                    await objWriter.WriteElementStringAsync("electricityarmordicestun",
                        (intBodTotalValue + intDamageResistanceDice
                                          + intElectricityArmor)
                        .ToString(objCulture), token: token).ConfigureAwait(false);
                    // <acidarmordicestun />
                    await objWriter.WriteElementStringAsync("acidarmordicestun",
                        (intBodTotalValue + intDamageResistanceDice
                                          + intAcidArmor)
                        .ToString(objCulture), token: token).ConfigureAwait(false);
                    // <fallingarmordicestun />
                    await objWriter.WriteElementStringAsync("fallingarmordicestun",
                        (intBodTotalValue + intDamageResistanceDice
                                          + intFallingArmor)
                        .ToString(objCulture), token: token).ConfigureAwait(false);
                    // <armordicephysical />
                    await objWriter.WriteElementStringAsync("armordicephysical",
                        (intBodTotalValue + intDamageResistanceDice
                                          + intArmor).ToString(objCulture),
                        token: token).ConfigureAwait(false);
                    // <firearmordicephysical />
                    await objWriter.WriteElementStringAsync("firearmordicephysical",
                        (intBodTotalValue + intDamageResistanceDice
                                          + intFireArmor)
                        .ToString(objCulture), token: token).ConfigureAwait(false);
                    // <coldarmordicephysical />
                    await objWriter.WriteElementStringAsync("coldarmordicephysical",
                        (intBodTotalValue + intDamageResistanceDice
                                          + intColdArmor)
                        .ToString(objCulture), token: token).ConfigureAwait(false);
                    // <electricityarmordicephysical />
                    await objWriter.WriteElementStringAsync("electricityarmordicephysical",
                        (intBodTotalValue + intDamageResistanceDice
                                          + intElectricityArmor)
                        .ToString(objCulture), token: token).ConfigureAwait(false);
                    // <acidarmordicephysical />
                    await objWriter.WriteElementStringAsync("acidarmordicephysical",
                        (intBodTotalValue + intDamageResistanceDice
                                          + intAcidArmor)
                        .ToString(objCulture), token: token).ConfigureAwait(false);
                    // <fallingarmordicephysical />
                    await objWriter.WriteElementStringAsync("fallingarmordicephysical",
                        (intBodTotalValue + intDamageResistanceDice
                                          + intFallingArmor)
                        .ToString(objCulture), token: token).ConfigureAwait(false);

                    bool blnIsAI = await GetIsAIAsync(token).ConfigureAwait(false);
                    bool blnPhysicalTrackIsCore = blnIsAI && !(HomeNode is Vehicle);
                    // Condition Monitors.
                    // <physicalcm />
                    int intPhysicalCM = await GetPhysicalCMAsync(token).ConfigureAwait(false);
                    await objWriter
                        .WriteElementStringAsync("physicalcm", intPhysicalCM.ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    await objWriter.WriteElementStringAsync("physicalcmiscorecm",
                            blnPhysicalTrackIsCore.ToString(
                                GlobalSettings.InvariantCultureInfo), token: token)
                        .ConfigureAwait(false);
                    // <stuncm />
                    int intStunCM = await GetStunCMAsync(token).ConfigureAwait(false);
                    await objWriter.WriteElementStringAsync("stuncm", intStunCM.ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    await objWriter.WriteElementStringAsync("stuncmismatrixcm",
                        blnIsAI.ToString(GlobalSettings.InvariantCultureInfo),
                        token: token).ConfigureAwait(false);

                    // Condition Monitor Progress.
                    // <physicalcmfilled />
                    await objWriter
                        .WriteElementStringAsync("physicalcmfilled", PhysicalCMFilled.ToString(objCulture),
                            token: token).ConfigureAwait(false);
                    // <stuncmfilled />
                    await objWriter
                        .WriteElementStringAsync("stuncmfilled", StunCMFilled.ToString(objCulture), token: token)
                        .ConfigureAwait(false);

                    // <cmthreshold>
                    await objWriter
                        .WriteElementStringAsync("cmthreshold",
                            (await GetCMThresholdAsync(token).ConfigureAwait(false)).ToString(
                                objCulture), token: token).ConfigureAwait(false);
                    // <cmthresholdoffset>
                    await objWriter.WriteElementStringAsync("physicalcmthresholdoffset",
                            Math.Min(
                                    await GetPhysicalCMThresholdOffsetAsync(token)
                                        .ConfigureAwait(false), intPhysicalCM)
                                .ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <cmthresholdoffset>
                    await objWriter.WriteElementStringAsync("stuncmthresholdoffset",
                            Math.Min(
                                    await GetStunCMThresholdOffsetAsync(token)
                                        .ConfigureAwait(false), intStunCM)
                                .ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <cmoverflow>
                    await objWriter
                        .WriteElementStringAsync("cmoverflow",
                            (await GetCMOverflowAsync(token).ConfigureAwait(false)).ToString(
                                objCulture), token: token).ConfigureAwait(false);

                    // <psyche>
                    await objWriter.WriteElementStringAsync(
                            "psyche", _blnPsycheActive.ToString(GlobalSettings.InvariantCultureInfo),
                            token: token)
                        .ConfigureAwait(false);

                    // Calculate Initiatives.
                    // Initiative.
                    await objWriter
                        .WriteElementStringAsync("init", await GetInitiativeAsync(objCulture, strLanguageToPrint, token).ConfigureAwait(false), token: token)
                        .ConfigureAwait(false);
                    await objWriter
                        .WriteElementStringAsync("initdice", (await GetInitiativeDiceAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    await objWriter
                        .WriteElementStringAsync("initvalue", (await GetInitiativeValueAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    await objWriter.WriteElementStringAsync("initbonus",
                            Math.Max(
                                    await ImprovementManager.ValueOfAsync(
                                        this, Improvement.ImprovementType.Initiative,
                                        token: token).ConfigureAwait(false),
                                    0)
                                .ToString(objCulture), token: token)
                        .ConfigureAwait(false);

                    // Astral Initiative.
                    if (await GetMAGEnabledAsync(token).ConfigureAwait(false))
                    {
                        await objWriter.WriteElementStringAsync("astralinit",
                            await GetAstralInitiativeAsync(objCulture, strLanguageToPrint, token).ConfigureAwait(false),
                            token: token).ConfigureAwait(false);
                        await objWriter.WriteElementStringAsync("astralinitdice",
                                (await GetAstralInitiativeDiceAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                            .ConfigureAwait(false);
                        await objWriter.WriteElementStringAsync("astralinitvalue",
                            (await GetAstralInitiativeValueAsync(token).ConfigureAwait(false)).ToString(objCulture),
                            token: token).ConfigureAwait(false);
                    }

                    // Matrix Initiative (AR).
                    await objWriter.WriteElementStringAsync("matrixarinit",
                        await GetMatrixInitiativeAsync(objCulture, strLanguageToPrint, token).ConfigureAwait(false),
                        token: token).ConfigureAwait(false);
                    await objWriter.WriteElementStringAsync("matrixarinitdice",
                            (await GetMatrixInitiativeDiceAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    await objWriter.WriteElementStringAsync("matrixarinitvalue",
                            (await GetMatrixInitiativeValueAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);

                    // Matrix Initiative (Cold).
                    await objWriter.WriteElementStringAsync("matrixcoldinit",
                        await GetMatrixInitiativeColdAsync(objCulture, strLanguageToPrint, token).ConfigureAwait(false),
                        token: token).ConfigureAwait(false);
                    await objWriter.WriteElementStringAsync("matrixcoldinitdice",
                            (await GetMatrixInitiativeColdDiceAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    await objWriter.WriteElementStringAsync("matrixcoldinitvalue",
                            (await GetMatrixInitiativeColdValueAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);

                    // Matrix Initiative (Hot).
                    await objWriter.WriteElementStringAsync("matrixhotinit",
                        await GetMatrixInitiativeHotAsync(objCulture, strLanguageToPrint, token).ConfigureAwait(false),
                        token: token).ConfigureAwait(false);
                    await objWriter.WriteElementStringAsync("matrixhotinitdice",
                            (await GetMatrixInitiativeHotDiceAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    await objWriter.WriteElementStringAsync("matrixhotinitvalue",
                        (await GetMatrixInitiativeHotValueAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);

                    // Rigger Initiative.
                    await objWriter.WriteElementStringAsync("riggerinit",
                            await GetInitiativeAsync(objCulture, strLanguageToPrint, token).ConfigureAwait(false), token: token)
                        .ConfigureAwait(false);

                    // <magenabled />
                    await objWriter.WriteElementStringAsync("magenabled",
                        (await GetMAGEnabledAsync(token).ConfigureAwait(false)).ToString(GlobalSettings
                            .InvariantCultureInfo),
                        token: token).ConfigureAwait(false);
                    // <initiategrade />
                    await objWriter
                        .WriteElementStringAsync("initiategrade", (await GetInitiateGradeAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <resenabled />
                    await objWriter.WriteElementStringAsync("resenabled",
                        (await GetRESEnabledAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.InvariantCultureInfo),
                        token: token).ConfigureAwait(false);
                    // <submersiongrade />
                    await objWriter
                        .WriteElementStringAsync("submersiongrade", SubmersionGrade.ToString(objCulture),
                            token: token).ConfigureAwait(false);
                    // <depenabled />
                    await objWriter.WriteElementStringAsync("depenabled",
                        (await GetDEPEnabledAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.InvariantCultureInfo),
                        token: token).ConfigureAwait(false);
                    // <groupmember />
                    await objWriter.WriteElementStringAsync("groupmember",
                        (await GetGroupMemberAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.InvariantCultureInfo),
                        token: token).ConfigureAwait(false);
                    // <groupname />
                    await objWriter.WriteElementStringAsync("groupname", await GetGroupNameAsync(token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                    // <groupnotes />
                    await objWriter.WriteElementStringAsync("groupnotes", await GetGroupNotesAsync(token).ConfigureAwait(false), token: token)
                        .ConfigureAwait(false);
                    // <surprise />
                    await objWriter.WriteElementStringAsync("surprise", (await GetSurpriseAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <composure />
                    await objWriter.WriteElementStringAsync("composure", (await GetComposureAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <judgeintentions />
                    await objWriter
                        .WriteElementStringAsync("judgeintentions", (await GetJudgeIntentionsAsync(token).ConfigureAwait(false)).ToString(objCulture),
                            token: token).ConfigureAwait(false);
                    // <judgeintentionsresist />
                    await objWriter.WriteElementStringAsync("judgeintentionsresist",
                            (await GetJudgeIntentionsResistAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <liftandcarry />
                    await objWriter
                        .WriteElementStringAsync("liftandcarry", (await GetLiftAndCarryAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <memory />
                    await objWriter.WriteElementStringAsync("memory", (await GetMemoryAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    string strWeightFormat = await (await GetSettingsAsync(token).ConfigureAwait(false)).GetWeightFormatAsync(token).ConfigureAwait(false);
                    // <liftweight />
                    await objWriter.WriteElementStringAsync("liftweight",
                        (await GetLiftLimitAsync(token).ConfigureAwait(false)).ToString(strWeightFormat, objCulture),
                        token: token).ConfigureAwait(false);
                    // <carryweight />
                    await objWriter.WriteElementStringAsync("carryweight",
                        (await GetCarryLimitAsync(token).ConfigureAwait(false)).ToString(strWeightFormat, objCulture),
                        token: token).ConfigureAwait(false);
                    // <totalcarriedweight />
                    await objWriter.WriteElementStringAsync("totalcarriedweight",
                            (await GetTotalCarriedWeightAsync(token).ConfigureAwait(false)).ToString(
                                strWeightFormat, objCulture), token: token)
                        .ConfigureAwait(false);
                    // <fatigueresist />
                    await objWriter
                        .WriteElementStringAsync("fatigueresist", (await GetFatigueResistAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <radiationresist />
                    await objWriter
                        .WriteElementStringAsync("radiationresist", (await GetRadiationResistAsync(token).ConfigureAwait(false)).ToString(objCulture),
                            token: token).ConfigureAwait(false);
                    // <sonicresist />
                    await objWriter
                        .WriteElementStringAsync("sonicresist", (await GetSonicResistAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    // <toxincontacttesist />
                    await objWriter.WriteElementStringAsync("toxincontactresist",
                        await ToxinContactResistAsync(strLanguageToPrint, objCulture, token).ConfigureAwait(false),
                        token: token).ConfigureAwait(false);
                    // <toxiningestionresist />
                    await objWriter.WriteElementStringAsync("toxiningestionresist",
                        await ToxinIngestionResistAsync(strLanguageToPrint, objCulture, token).ConfigureAwait(false),
                        token: token).ConfigureAwait(false);
                    // <toxininhalationresist />
                    await objWriter.WriteElementStringAsync("toxininhalationresist",
                        await ToxinInhalationResistAsync(strLanguageToPrint, objCulture, token).ConfigureAwait(false),
                        token: token).ConfigureAwait(false);
                    // <toxininjectionresist />
                    await objWriter.WriteElementStringAsync("toxininjectionresist",
                        await ToxinInjectionResistAsync(strLanguageToPrint, objCulture, token).ConfigureAwait(false),
                        token: token).ConfigureAwait(false);
                    // <pathogencontactresist />
                    await objWriter.WriteElementStringAsync("pathogencontactresist",
                        await PathogenContactResistAsync(strLanguageToPrint, objCulture, token).ConfigureAwait(false),
                        token: token).ConfigureAwait(false);
                    // <pathogeningestionresist />
                    await objWriter.WriteElementStringAsync("pathogeningestionresist",
                        await PathogenIngestionResistAsync(strLanguageToPrint, objCulture, token).ConfigureAwait(false),
                        token: token).ConfigureAwait(false);
                    // <pathogeninhalationresist />
                    await objWriter.WriteElementStringAsync("pathogeninhalationresist",
                        await PathogenInhalationResistAsync(strLanguageToPrint, objCulture, token).ConfigureAwait(false),
                        token: token).ConfigureAwait(false);
                    // <pathogeninjectionresist />
                    await objWriter.WriteElementStringAsync("pathogeninjectionresist",
                        await PathogenInjectionResistAsync(strLanguageToPrint, objCulture, token).ConfigureAwait(false),
                        token: token).ConfigureAwait(false);
                    // <physiologicaladdictionresistfirsttime />
                    await objWriter.WriteElementStringAsync("physiologicaladdictionresistfirsttime",
                        (await GetPhysiologicalAddictionResistFirstTimeAsync(token).ConfigureAwait(false)).ToString(objCulture),
                        token: token).ConfigureAwait(false);
                    // <physiologicaladdictionresistalreadyaddicted />
                    await objWriter.WriteElementStringAsync("physiologicaladdictionresistalreadyaddicted",
                        (await GetPhysiologicalAddictionResistAlreadyAddictedAsync(token).ConfigureAwait(false)).ToString(
                            objCulture), token: token).ConfigureAwait(false);
                    // <psychologicaladdictionresistfirsttime />
                    await objWriter.WriteElementStringAsync("psychologicaladdictionresistfirsttime",
                        (await GetPsychologicalAddictionResistFirstTimeAsync(token).ConfigureAwait(false)).ToString(objCulture),
                        token: token).ConfigureAwait(false);
                    // <psychologicaladdictionresistalreadyaddicted />
                    await objWriter.WriteElementStringAsync("psychologicaladdictionresistalreadyaddicted",
                        (await GetPsychologicalAddictionResistAlreadyAddictedAsync(token).ConfigureAwait(false)).ToString(
                            objCulture), token: token).ConfigureAwait(false);
                    // <physicalcmnaturalrecovery />
                    await objWriter.WriteElementStringAsync("physicalcmnaturalrecovery",
                        (await GetPhysicalCMNaturalRecoveryAsync(token).ConfigureAwait(false)).ToString(objCulture),
                        token: token).ConfigureAwait(false);
                    // <stuncmnaturalrecovery />
                    await objWriter.WriteElementStringAsync("stuncmnaturalrecovery",
                            (await GetStunCMNaturalRecoveryAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);

                    // Spell Resistances
                    //Indirect Dodge
                    await objWriter.WriteElementStringAsync("indirectdefenseresist",
                        (await GetSpellDefenseIndirectDodgeAsync(token).ConfigureAwait(false)).ToString(objCulture),
                        token: token).ConfigureAwait(false);
                    //Direct Soak - Mana
                    await objWriter.WriteElementStringAsync("directmanaresist",
                        (await GetSpellDefenseDirectSoakManaAsync(token).ConfigureAwait(false)).ToString(objCulture),
                        token: token).ConfigureAwait(false);
                    //Direct Soak - Physical
                    await objWriter.WriteElementStringAsync("directphysicalresist",
                        (await GetSpellDefenseDirectSoakPhysicalAsync(token).ConfigureAwait(false)).ToString(objCulture),
                        token: token).ConfigureAwait(false);
                    //Detection Spells
                    await objWriter.WriteElementStringAsync("detectionspellresist",
                            (await GetSpellDefenseDetectionAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    //Decrease Attribute - BOD
                    await objWriter.WriteElementStringAsync("decreasebodresist",
                            (await GetSpellDefenseDecreaseBODAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    //Decrease Attribute - AGI
                    await objWriter.WriteElementStringAsync("decreaseagiresist",
                            (await GetSpellDefenseDecreaseAGIAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    //Decrease Attribute - REA
                    await objWriter.WriteElementStringAsync("decreaserearesist",
                            (await GetSpellDefenseDecreaseREAAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    //Decrease Attribute - STR
                    await objWriter.WriteElementStringAsync("decreasestrresist",
                            (await GetSpellDefenseDecreaseSTRAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    //Decrease Attribute - CHA
                    await objWriter.WriteElementStringAsync("decreasecharesist",
                            (await GetSpellDefenseDecreaseCHAAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    //Decrease Attribute - INT
                    await objWriter.WriteElementStringAsync("decreaseintresist",
                            (await GetSpellDefenseDecreaseINTAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    //Decrease Attribute - LOG
                    await objWriter.WriteElementStringAsync("decreaselogresist",
                            (await GetSpellDefenseDecreaseLOGAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    //Decrease Attribute - WIL
                    await objWriter.WriteElementStringAsync("decreasewilresist",
                            (await GetSpellDefenseDecreaseWILAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    //Illusion - Mana
                    await objWriter.WriteElementStringAsync("illusionmanaresist",
                            (await GetSpellDefenseIllusionManaAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                        .ConfigureAwait(false);
                    //Illusion - Physical
                    await objWriter.WriteElementStringAsync("illusionphysicalresist",
                        (await GetSpellDefenseIllusionPhysicalAsync(token).ConfigureAwait(false)).ToString(objCulture),
                        token: token).ConfigureAwait(false);
                    //Manipulation - Mental
                    await objWriter.WriteElementStringAsync("manipulationmentalresist",
                        (await GetSpellDefenseManipulationMentalAsync(token).ConfigureAwait(false)).ToString(objCulture),
                        token: token).ConfigureAwait(false);
                    //Manipulation - Physical
                    await objWriter.WriteElementStringAsync("manipulationphysicalresist",
                        (await GetSpellDefenseManipulationPhysicalAsync(token).ConfigureAwait(false)).ToString(objCulture),
                        token: token).ConfigureAwait(false);

                    // <skills>
                    XmlElementWriteHelper objSkillsElement
                        = await objWriter.StartElementAsync("skills", token: token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await (await GetSkillsSectionAsync(token).ConfigureAwait(false)).Print(objWriter, objCulture, strLanguageToPrint, token: token)
                            .ConfigureAwait(false);
                    }
                    finally
                    {
                        // </skills>
                        await objSkillsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <contacts>
                    XmlElementWriteHelper objContactsElement
                        = await objWriter.StartElementAsync("contacts", token: token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await (await GetContactsAsync(token).ConfigureAwait(false)).ForEachAsync(x => x.Print(objWriter, objCulture, strLanguageToPrint, token), token).ConfigureAwait(false);
                    }
                    finally
                    {
                        // </contacts>
                        await objContactsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <limitmodifiersphys>
                    XmlElementWriteHelper objLimitModifiersPhysElement = await objWriter
                        .StartElementAsync(
                            "limitmodifiersphys", token: token)
                        .ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await (await GetLimitModifiersAsync(token).ConfigureAwait(false)).ForEachAsync(objLimitModifier =>
                        {
                            if (objLimitModifier.Limit == "Physical")
                            {
                                return objLimitModifier.Print(objWriter, objCulture, strLanguageToPrint, token);
                            }

                            return Task.CompletedTask;
                        }, token).ConfigureAwait(false);

                        // Populate Limit Modifiers from Improvements
                        foreach (Improvement objImprovement in await ImprovementManager
                                     .GetCachedImprovementListForValueOfAsync(this,
                                         Improvement.ImprovementType.LimitModifier,
                                         "Physical", token: token)
                                     .ConfigureAwait(false))
                        {
                            string strName = await GetObjectNameAsync(objImprovement, strLanguageToPrint, token)
                                .ConfigureAwait(false);
                            if (strName == objImprovement.SourceName)
                                strName = objImprovement.UniqueName;
                            strName += await LanguageManager
                                           .GetStringAsync("String_Colon", strLanguageToPrint, token: token)
                                           .ConfigureAwait(false) +
                                       await LanguageManager
                                           .GetStringAsync("String_Space", strLanguageToPrint, token: token)
                                           .ConfigureAwait(false);
                            if (objImprovement.Value > 0)
                                strName += "+";
                            strName += objImprovement.Value.ToString(objCulture);

                            if (!string.IsNullOrEmpty(objImprovement.Condition))
                                strName += "," + await LanguageManager
                                               .GetStringAsync("String_Space", strLanguageToPrint, token: token)
                                               .ConfigureAwait(false) +
                                           objImprovement.Condition;

                            // <limitmodifier>
                            XmlElementWriteHelper objLimitModifierElement = await objWriter
                                .StartElementAsync("limitmodifier", token: token).ConfigureAwait(false);
                            try
                            {
                                token.ThrowIfCancellationRequested();
                                await objWriter.WriteElementStringAsync("name", strName, token: token)
                                    .ConfigureAwait(false);
                                if (GlobalSettings.PrintNotes)
                                    await objWriter.WriteElementStringAsync("notes", await objImprovement.GetNotesAsync(token).ConfigureAwait(false), token: token)
                                        .ConfigureAwait(false);
                            }
                            finally
                            {
                                // </limitmodifier>
                                await objLimitModifierElement.DisposeAsync().ConfigureAwait(false);
                            }
                        }
                    }
                    finally
                    {
                        // </limitmodifiersphys>
                        await objLimitModifiersPhysElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <limitmodifiersment>
                    XmlElementWriteHelper objLimitModifiersMentElement = await objWriter
                        .StartElementAsync(
                            "limitmodifiersment", token: token)
                        .ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await (await GetLimitModifiersAsync(token).ConfigureAwait(false)).ForEachAsync(objLimitModifier =>
                        {
                            if (objLimitModifier.Limit == "Mental")
                            {
                                return objLimitModifier.Print(objWriter, objCulture, strLanguageToPrint, token);
                            }

                            return Task.CompletedTask;
                        }, token).ConfigureAwait(false);

                        // Populate Limit Modifiers from Improvements
                        foreach (Improvement objImprovement in await ImprovementManager
                                     .GetCachedImprovementListForValueOfAsync(this,
                                         Improvement.ImprovementType.LimitModifier,
                                         "Mental", token: token).ConfigureAwait(false))
                        {
                            string strName = await GetObjectNameAsync(objImprovement, strLanguageToPrint, token)
                                .ConfigureAwait(false);
                            if (strName == objImprovement.SourceName)
                                strName = objImprovement.UniqueName;
                            strName += await LanguageManager
                                           .GetStringAsync("String_Colon", strLanguageToPrint, token: token)
                                           .ConfigureAwait(false) +
                                       await LanguageManager
                                           .GetStringAsync("String_Space", strLanguageToPrint, token: token)
                                           .ConfigureAwait(false);
                            if (objImprovement.Value > 0)
                                strName += "+";
                            strName += objImprovement.Value.ToString(objCulture);

                            if (!string.IsNullOrEmpty(objImprovement.Condition))
                                strName += "," + await LanguageManager
                                               .GetStringAsync("String_Space", strLanguageToPrint, token: token)
                                               .ConfigureAwait(false) +
                                           objImprovement.Condition;

                            // <limitmodifier>
                            XmlElementWriteHelper objLimitModifierElement = await objWriter
                                .StartElementAsync("limitmodifier", token: token).ConfigureAwait(false);
                            try
                            {
                                token.ThrowIfCancellationRequested();
                                await objWriter.WriteElementStringAsync("name", strName, token: token)
                                    .ConfigureAwait(false);
                                if (GlobalSettings.PrintNotes)
                                    await objWriter.WriteElementStringAsync("notes", await objImprovement.GetNotesAsync(token).ConfigureAwait(false), token: token)
                                        .ConfigureAwait(false);
                            }
                            finally
                            {
                                // </limitmodifier>
                                await objLimitModifierElement.DisposeAsync().ConfigureAwait(false);
                            }
                        }
                    }
                    finally
                    {
                        // </limitmodifiersment>
                        await objLimitModifiersMentElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <limitmodifierssoc>
                    XmlElementWriteHelper objLimitModifiersSocElement
                        = await objWriter.StartElementAsync("limitmodifierssoc", token: token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await (await GetLimitModifiersAsync(token).ConfigureAwait(false)).ForEachAsync(objLimitModifier =>
                        {
                            if (objLimitModifier.Limit == "Social")
                            {
                                return objLimitModifier.Print(objWriter, objCulture, strLanguageToPrint, token);
                            }

                            return Task.CompletedTask;
                        }, token).ConfigureAwait(false);

                        // Populate Limit Modifiers from Improvements
                        foreach (Improvement objImprovement in await ImprovementManager
                                     .GetCachedImprovementListForValueOfAsync(this,
                                         Improvement.ImprovementType.LimitModifier,
                                         "Social", token: token).ConfigureAwait(false))
                        {
                            string strName = await GetObjectNameAsync(objImprovement, strLanguageToPrint, token)
                                .ConfigureAwait(false);
                            if (strName == objImprovement.SourceName)
                                strName = objImprovement.UniqueName;
                            strName += await LanguageManager
                                           .GetStringAsync("String_Colon", strLanguageToPrint, token: token)
                                           .ConfigureAwait(false) +
                                       await LanguageManager
                                           .GetStringAsync("String_Space", strLanguageToPrint, token: token)
                                           .ConfigureAwait(false);
                            if (objImprovement.Value > 0)
                                strName += "+";
                            strName += objImprovement.Value.ToString(objCulture);

                            if (!string.IsNullOrEmpty(objImprovement.Condition))
                                strName += "," + await LanguageManager
                                               .GetStringAsync("String_Space", strLanguageToPrint, token: token)
                                               .ConfigureAwait(false) +
                                           objImprovement.Condition;

                            // <limitmodifier>
                            XmlElementWriteHelper objLimitModifierElement = await objWriter
                                .StartElementAsync("limitmodifier", token: token).ConfigureAwait(false);
                            try
                            {
                                token.ThrowIfCancellationRequested();
                                await objWriter.WriteElementStringAsync("name", strName, token: token)
                                    .ConfigureAwait(false);
                                if (GlobalSettings.PrintNotes)
                                    await objWriter.WriteElementStringAsync("notes", await objImprovement.GetNotesAsync(token).ConfigureAwait(false), token: token)
                                        .ConfigureAwait(false);
                            }
                            finally
                            {
                                // </limitmodifier>
                                await objLimitModifierElement.DisposeAsync().ConfigureAwait(false);
                            }
                        }
                    }
                    finally
                    {
                        // </limitmodifierssoc>
                        await objLimitModifiersSocElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <mentorspirits>
                    XmlElementWriteHelper objMentorSpiritsElement
                        = await objWriter.StartElementAsync("mentorspirits", token: token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await (await GetMentorSpiritsAsync(token).ConfigureAwait(false))
                            .ForEachAsync(x => x.Print(objWriter, strLanguageToPrint, token), token).ConfigureAwait(false);
                    }
                    finally
                    {
                        // </mentorspirits>
                        await objMentorSpiritsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <spells>
                    XmlElementWriteHelper objSpellsElement
                        = await objWriter.StartElementAsync("spells", token: token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await (await GetSpellsAsync(token).ConfigureAwait(false))
                            .ForEachAsync(x => x.Print(objWriter, objCulture, strLanguageToPrint, token), token).ConfigureAwait(false);
                    }
                    finally
                    {
                        // </spells>
                        await objSpellsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <powers>
                    XmlElementWriteHelper objPowersElement
                        = await objWriter.StartElementAsync("powers", token: token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await (await GetPowersAsync(token).ConfigureAwait(false))
                            .ForEachAsync(x => x.Print(objWriter, objCulture, strLanguageToPrint, token), token).ConfigureAwait(false);
                    }
                    finally
                    {
                        // </powers>
                        await objPowersElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <spirits>
                    XmlElementWriteHelper objSpiritsElement
                        = await objWriter.StartElementAsync("spirits", token: token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await (await GetSpiritsAsync(token).ConfigureAwait(false))
                            .ForEachAsync(x => x.Print(objWriter, objCulture, strLanguageToPrint, token), token).ConfigureAwait(false);
                    }
                    finally
                    {
                        // </spirits>
                        await objSpiritsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <complexforms>
                    XmlElementWriteHelper objComplexFormsElement
                        = await objWriter.StartElementAsync("complexforms", token: token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await (await GetComplexFormsAsync(token).ConfigureAwait(false))
                            .ForEachAsync(x => x.Print(objWriter, strLanguageToPrint, token), token).ConfigureAwait(false);
                    }
                    finally
                    {
                        // </complexforms>
                        await objComplexFormsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <aiprograms>
                    XmlElementWriteHelper objAIProgramsElement
                        = await objWriter.StartElementAsync("aiprograms", token: token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await (await GetAIProgramsAsync(token).ConfigureAwait(false))
                            .ForEachAsync(x => x.Print(objWriter, strLanguageToPrint, token), token).ConfigureAwait(false);
                    }
                    finally
                    {
                        // </aiprograms>
                        await objAIProgramsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <martialarts>
                    XmlElementWriteHelper objMartialArtsElement
                        = await objWriter.StartElementAsync("martialarts", token: token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await (await GetMartialArtsAsync(token).ConfigureAwait(false))
                            .ForEachAsync(x => x.Print(objWriter, objCulture, strLanguageToPrint, token), token).ConfigureAwait(false);
                    }
                    finally
                    {
                        // </martialarts>
                        await objMartialArtsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <armors>
                    XmlElementWriteHelper objArmorsElement
                        = await objWriter.StartElementAsync("armors", token: token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await (await GetArmorAsync(token).ConfigureAwait(false))
                            .ForEachAsync(x => x.Print(objWriter, objCulture, strLanguageToPrint, token), token).ConfigureAwait(false);
                    }
                    finally
                    {
                        // </armors>
                        await objArmorsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <weapons>
                    XmlElementWriteHelper objWeaponsElement
                        = await objWriter.StartElementAsync("weapons", token: token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await (await GetWeaponsAsync(token).ConfigureAwait(false))
                            .ForEachAsync(x => x.Print(objWriter, objCulture, strLanguageToPrint, token), token).ConfigureAwait(false);
                    }
                    finally
                    {
                        // </weapons>
                        await objWeaponsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <cyberwares>
                    XmlElementWriteHelper objCyberwaresElement
                        = await objWriter.StartElementAsync("cyberwares", token: token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await (await GetCyberwareAsync(token).ConfigureAwait(false))
                            .ForEachAsync(x => x.Print(objWriter, objCulture, strLanguageToPrint, token), token).ConfigureAwait(false);
                    }
                    finally
                    {
                        // </cyberwares>
                        await objCyberwaresElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <qualities>
                    XmlElementWriteHelper objQualitiesElement
                        = await objWriter.StartElementAsync("qualities", token: token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        ThreadSafeObservableCollection<Quality> lstQualities = await GetQualitiesAsync(token).ConfigureAwait(false);
                        // Multiple instances of the same quality are combined into just one entry with a number next to it (e.g. 6 discrete entries of "Focused Concentration" become "Focused Concentration 6")
                        Dictionary<string, int> strQualitiesToPrint = new Dictionary<string, int>(await lstQualities.GetCountAsync(token).ConfigureAwait(false));
                        await lstQualities.ForEachAsync(async objQuality =>
                        {
                            string strKey = await objQuality.GetSourceIDStringAsync(token).ConfigureAwait(false)
                                + "|" + await objQuality.GetSourceNameAsync(token).ConfigureAwait(false)
                                + "|" + await objQuality.GetExtraAsync(token).ConfigureAwait(false);
                            if (strQualitiesToPrint.TryGetValue(strKey, out int intExistingRating))
                            {
                                strQualitiesToPrint[strKey] = intExistingRating + 1;
                            }
                            else
                            {
                                strQualitiesToPrint.Add(strKey, 1);
                            }
                        }, token).ConfigureAwait(false);

                        await lstQualities.ForEachAsync(async objQuality =>
                        {
                            string strKey = await objQuality.GetSourceIDStringAsync(token).ConfigureAwait(false)
                                + "|" + await objQuality.GetSourceNameAsync(token).ConfigureAwait(false)
                                + "|" + await objQuality.GetExtraAsync(token).ConfigureAwait(false);
                            if (strQualitiesToPrint.TryGetValue(strKey, out int intLoopRating))
                            {
                                await objQuality.Print(objWriter, intLoopRating, objCulture, strLanguageToPrint, token)
                                    .ConfigureAwait(false);
                                strQualitiesToPrint.Remove(strKey);
                            }
                        }, token).ConfigureAwait(false);
                    }
                    finally
                    {
                        // </qualities>
                        await objQualitiesElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <lifestyles>
                    XmlElementWriteHelper objLifestylesElement
                        = await objWriter.StartElementAsync("lifestyles", token: token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await (await GetLifestylesAsync(token).ConfigureAwait(false))
                            .ForEachAsync(x => x.Print(objWriter, objCulture, strLanguageToPrint, token), token).ConfigureAwait(false);
                    }
                    finally
                    {
                        // </lifestyles>
                        await objLifestylesElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <gears>
                    XmlElementWriteHelper objGearsElement
                        = await objWriter.StartElementAsync("gears", token: token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await (await GetGearAsync(token).ConfigureAwait(false))
                            .ForEachAsync(x => x.Print(objWriter, objCulture, strLanguageToPrint, token), token).ConfigureAwait(false);
                    }
                    finally
                    {
                        // </gears>
                        await objGearsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <drugs>
                    XmlElementWriteHelper objDrugsElement
                        = await objWriter.StartElementAsync("drugs", token: token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await (await GetDrugsAsync(token).ConfigureAwait(false))
                            .ForEachAsync(x => x.Print(objWriter, objCulture, strLanguageToPrint, token), token).ConfigureAwait(false);
                    }
                    finally
                    {
                        // </drugs>
                        await objDrugsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <vehicles>
                    XmlElementWriteHelper objVehiclesElement
                        = await objWriter.StartElementAsync("vehicles", token: token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await (await GetVehiclesAsync(token).ConfigureAwait(false))
                            .ForEachAsync(x => x.Print(objWriter, objCulture, strLanguageToPrint, token), token).ConfigureAwait(false);
                    }
                    finally
                    {
                        // </vehicles>
                        await objVehiclesElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <initiationgrade>
                    XmlElementWriteHelper objInitiationGradeElement
                        = await objWriter.StartElementAsync("initiationgrade", token: token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await (await GetInitiationGradesAsync(token).ConfigureAwait(false)).ForEachAsync(async objGrade =>
                        {
                            await objGrade.Print(objWriter, objCulture, token).ConfigureAwait(false);

                            //TODO: Probably better to integrate this into the main print method, but eh.
                            // <metamagics>
                            XmlElementWriteHelper objInitiationMetamagicsElement
                                = await objWriter.StartElementAsync("metamagics", token: token).ConfigureAwait(false);
                            try
                            {
                                token.ThrowIfCancellationRequested();
                                await (await GetMetamagicsAsync(token).ConfigureAwait(false))
                                    .ForEachAsync(x => x.Grade == objGrade.Grade
                                        ? x.Print(objWriter, objCulture, strLanguageToPrint, token)
                                        : Task.CompletedTask, token).ConfigureAwait(false);
                            }
                            finally
                            {
                                // </metamagics>
                                await objInitiationMetamagicsElement.DisposeAsync().ConfigureAwait(false);
                            }

                            // <arts>
                            XmlElementWriteHelper objInitiationArtsElement
                                = await objWriter.StartElementAsync("arts", token: token).ConfigureAwait(false);
                            try
                            {
                                token.ThrowIfCancellationRequested();
                                await (await GetArtsAsync(token).ConfigureAwait(false))
                                    .ForEachAsync(x => x.Grade == objGrade.Grade
                                        ? x.Print(objWriter, strLanguageToPrint, token)
                                        : Task.CompletedTask, token).ConfigureAwait(false);
                            }
                            finally
                            {
                                // </arts>
                                await objInitiationArtsElement.DisposeAsync().ConfigureAwait(false);
                            }

                            // <enhancements>
                            XmlElementWriteHelper objInitiationEnhancementsElement = await objWriter
                                .StartElementAsync("enhancements", token: token).ConfigureAwait(false);
                            try
                            {
                                token.ThrowIfCancellationRequested();
                                await (await GetEnhancementsAsync(token).ConfigureAwait(false))
                                    .ForEachAsync(x => x.Grade == objGrade.Grade
                                        ? x.Print(objWriter, strLanguageToPrint, token)
                                        : Task.CompletedTask, token).ConfigureAwait(false);
                            }
                            finally
                            {
                                // </enhancements>
                                await objInitiationEnhancementsElement.DisposeAsync().ConfigureAwait(false);
                            }
                        }, token).ConfigureAwait(false);
                    }
                    finally
                    {
                        // </initiationgrade>
                        await objInitiationGradeElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <metamagics>
                    XmlElementWriteHelper objMetamagicsElement
                        = await objWriter.StartElementAsync("metamagics", token: token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await (await GetMetamagicsAsync(token).ConfigureAwait(false))
                            .ForEachAsync(x => x.Print(objWriter, objCulture, strLanguageToPrint, token), token).ConfigureAwait(false);
                    }
                    finally
                    {
                        // </metamagics>
                        await objMetamagicsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <arts>
                    XmlElementWriteHelper objArtsElement
                        = await objWriter.StartElementAsync("arts", token: token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await (await GetArtsAsync(token).ConfigureAwait(false))
                            .ForEachAsync(x => x.Print(objWriter, strLanguageToPrint, token), token).ConfigureAwait(false);
                    }
                    finally
                    {
                        // </arts>
                        await objArtsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <enhancements>
                    XmlElementWriteHelper objEnhancementsElement
                        = await objWriter.StartElementAsync("enhancements", token: token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await (await GetEnhancementsAsync(token).ConfigureAwait(false))
                            .ForEachAsync(x => x.Print(objWriter, strLanguageToPrint, token), token).ConfigureAwait(false);
                    }
                    finally
                    {
                        // </enhancements>
                        await objEnhancementsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <critterpowers>
                    XmlElementWriteHelper objCritterPowersElement
                        = await objWriter.StartElementAsync("critterpowers", token: token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await (await GetCritterPowersAsync(token).ConfigureAwait(false))
                            .ForEachAsync(x => x.Print(objWriter, strLanguageToPrint, token), token).ConfigureAwait(false);
                    }
                    finally
                    {
                        // </critterpowers>
                        await objCritterPowersElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <sustainedobjects>
                    XmlElementWriteHelper objSustainedObjectsElement
                        = await objWriter.StartElementAsync("sustainedobjects", token: token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await (await GetSustainedCollectionAsync(token).ConfigureAwait(false))
                            .ForEachAsync(x => x.Print(objWriter, objCulture, strLanguageToPrint, token), token).ConfigureAwait(false);
                    }
                    finally
                    {
                        // </sustainedobjects>
                        await objSustainedObjectsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <otherarmors>
                    XmlElementWriteHelper objOtherArmorsElement
                        = await objWriter.StartElementAsync("otherarmors", token: token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        foreach (Improvement objImprovement in await ImprovementManager
                                     .GetCachedImprovementListForValueOfAsync(
                                         this, Improvement.ImprovementType.Armor,
                                         token: token).ConfigureAwait(false))
                        {
                            if (objImprovement.ImproveSource == Improvement.ImprovementSource.Armor
                                || objImprovement.ImproveSource == Improvement.ImprovementSource.ArmorMod)
                                continue;
                            // <otherarmor>
                            XmlElementWriteHelper objBaseElement = await objWriter
                                .StartElementAsync("otherarmor", token: token)
                                .ConfigureAwait(false);
                            try
                            {
                                token.ThrowIfCancellationRequested();
                                await objWriter.WriteElementStringAsync("guid", objImprovement.InternalId, token: token)
                                    .ConfigureAwait(false);
                                await objWriter
                                    .WriteElementStringAsync("sourcename", objImprovement.SourceName, token: token)
                                    .ConfigureAwait(false);
                                await objWriter
                                    .WriteElementStringAsync("objectname",
                                        await GetObjectNameAsync(
                                                objImprovement, strLanguageToPrint, token)
                                            .ConfigureAwait(false), token: token)
                                    .ConfigureAwait(false);
                                await objWriter
                                    .WriteElementStringAsync("objectname_english",
                                        await GetObjectNameAsync(
                                            objImprovement, GlobalSettings.DefaultLanguage,
                                            token).ConfigureAwait(false), token: token)
                                    .ConfigureAwait(false);
                                await objWriter
                                    .WriteElementStringAsync(
                                        "armor", objImprovement.Value.ToString(GlobalSettings.InvariantCultureInfo),
                                        token: token).ConfigureAwait(false);
                                await objWriter
                                    .WriteElementStringAsync("improvesource", objImprovement.ImproveSource.ToString(),
                                        token: token).ConfigureAwait(false);
                                await objWriter
                                    .WriteElementStringAsync(
                                        "enabled",
                                        objImprovement.Enabled.ToString(GlobalSettings.InvariantCultureInfo),
                                        token: token).ConfigureAwait(false);
                                await objWriter
                                    .WriteElementStringAsync("customname", objImprovement.CustomName, token: token)
                                    .ConfigureAwait(false);
                                await objWriter
                                    .WriteElementStringAsync("customgroup", objImprovement.CustomGroup, token: token)
                                    .ConfigureAwait(false);
                                if (GlobalSettings.PrintNotes)
                                    await objWriter.WriteElementStringAsync("notes", await objImprovement.GetNotesAsync(token).ConfigureAwait(false), token: token)
                                        .ConfigureAwait(false);
                            }
                            finally
                            {
                                // </otherarmor>
                                await objBaseElement.DisposeAsync().ConfigureAwait(false);
                            }
                        }
                    }
                    finally
                    {
                        // </otherarmors>
                        await objOtherArmorsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <calendar>
                    XmlElementWriteHelper objCalendarElement
                        = await objWriter.StartElementAsync("calendar", token: token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await (await GetCalendarAsync(token).ConfigureAwait(false))
                            .ForEachAsync(x => x.Print(objWriter, objCulture, GlobalSettings.PrintNotes, token), token).ConfigureAwait(false);
                    }
                    finally
                    {
                        // </calendar>
                        await objCalendarElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // Print the Expense Log Entries if the option is enabled.
                    if (GlobalSettings.PrintExpenses)
                    {
                        // <expenses>
                        XmlElementWriteHelper objExpensesElement
                            = await objWriter.StartElementAsync("expenses", token: token).ConfigureAwait(false);
                        try
                        {
                            token.ThrowIfCancellationRequested();
                            foreach (ExpenseLogEntry objExpense in (await GetExpenseEntriesAsync(token).ConfigureAwait(false)).Reverse())
                                await objExpense.Print(objWriter, objCulture, strLanguageToPrint, token)
                                    .ConfigureAwait(false);
                        }
                        finally
                        {
                            // </expenses>
                            await objExpensesElement.DisposeAsync().ConfigureAwait(false);
                        }
                    }
                }
                finally
                {
                    // </character>
                    await objCharacterElement.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLockerAsync.DisposeAsync().ConfigureAwait(false);
            }
        }

        #endregion Create, Save, Load and Print Methods

        private int _intIsDisposed;

        public bool IsDisposed => _intIsDisposed > 0;

        /// <summary>
        /// Remove stray event handlers and clear all info used by this character
        /// </summary>
        public void Dispose()
        {
            if (LockObject.IsDisposed)
                return;

            if (Program.OpenCharacters.Contains(this)
                || Program.OpenCharacters.Any(x => x.LinkedCharacters.Contains(this)))
                return; // Do not actually dispose any characters who are still in the open characters list or required by a character who is

            if (Interlocked.CompareExchange(ref _intIsDisposed, 1, 0) > 0)
                return;

            using (LockObject.EnterWriteLock()) // Wait for all pending locks to get freed before disposing
            {
                Interlocked.Exchange(ref _lstInternalIdsNeedingReapplyImprovements, null);
                _objSettings.MultiplePropertiesChangedAsync -= OptionsOnPropertyChanged;
                ImprovementManager.ClearAllCharacterValues(this);
                _lstLinkedCharacters.Clear(); // Clear this list because it relates to Contacts and Spirits disposal
                foreach (Image imgMugshot in _lstMugshots)
                    imgMugshot.Dispose();
                _lstMugshots.Dispose();
                foreach (Contact objContact in _lstContacts)
                    objContact.Dispose();
                _lstContacts.Dispose();
                foreach (Spirit objSpirit in _lstSpirits)
                    objSpirit.Dispose();
                _lstSpirits.Dispose();
                foreach (Armor objItem in _lstArmor)
                    objItem.Dispose();
                _lstArmor.Dispose();
                foreach (Weapon objItem in _lstWeapons)
                    objItem.Dispose();
                _lstWeapons.Dispose();
                foreach (Gear objItem in _lstGear)
                    objItem.Dispose();
                _lstGear.Dispose();
                foreach (Cyberware objItem in _lstCyberware)
                    objItem.Dispose();
                _lstCyberware.Dispose();
                foreach (Vehicle objItem in _lstVehicles)
                    objItem.Dispose();
                _lstVehicles.Dispose();
                foreach (Lifestyle objItem in _lstLifestyles)
                    objItem.Dispose();
                _lstLifestyles.Dispose();
                foreach (Spell objItem in _lstSpells)
                    objItem.Dispose();
                _lstSpells.Dispose();
                foreach (MartialArt objItem in _lstMartialArts)
                    objItem.Dispose();
                _lstMartialArts.Dispose();
                foreach (ComplexForm objItem in _lstComplexForms)
                    objItem.Dispose();
                _lstComplexForms.Dispose();
                _lstAIPrograms.Dispose();
                _lstPowers.Dispose();
                _lstCritterPowers.Dispose();
                _lstFoci.Dispose();
                foreach (StackedFocus objItem in _lstStackedFoci)
                    objItem.Dispose();
                _lstStackedFoci.Dispose();
                _lstMetamagics.Dispose();
                _lstArts.Dispose();
                _lstEnhancements.Dispose();
                _lstImprovements.Dispose();
                _lstInitiationGrades.Dispose();
                foreach (Quality objItem in _lstQualities)
                    objItem.Dispose();
                _lstQualities.Dispose();
                foreach (CalendarWeek objItem in _lstCalendar)
                    objItem.Dispose();
                _lstCalendar.Dispose();
                foreach (Drug objItem in _lstDrugs)
                    objItem.Dispose();
                _lstDrugs.Dispose();
                foreach (MentorSpirit objItem in _lstMentorSpirits)
                    objItem.Dispose();
                _lstMentorSpirits.Dispose();
                _lstExpenseLog.Dispose();
                foreach (Location objItem in _lstArmorLocations)
                    objItem.Dispose();
                _lstArmorLocations.Dispose();
                foreach (Location objItem in _lstGearLocations)
                    objItem.Dispose();
                _lstGearLocations.Dispose();
                foreach (Location objItem in _lstWeaponLocations)
                    objItem.Dispose();
                _lstWeaponLocations.Dispose();
                foreach (Location objItem in _lstVehicleLocations)
                    objItem.Dispose();
                _lstVehicleLocations.Dispose();
                _lstImprovementGroups.Dispose();
                _lstLimitModifiers.Dispose();
                _lstSustainedObjects.Dispose();
                _lstPrioritySkills.Dispose();
                _objSkillsSection.Dispose();
                _objAttributeSection.Dispose();
                _setDoOnSaveCompleted.Dispose();
                _setDoOnSaveCompletedAsync.Dispose();
                if (!SettingsManager.LoadedCharacterSettings.ContainsKey(_objSettings.DictionaryKey))
                    _objSettings.Dispose();
                _objCachedEssenceLock.Dispose();
                _objCachedSourceDetailLock.Dispose();
                _objCachedPowerPointsUsedLock.Dispose();
                _objAvailabilityMapLock.Dispose();
                _objCachedHasAnyQualitiesWithQualityLevelsLock.Dispose();
                _objTradition.Dispose();
                if (_lstCachedContactArchetypes != null)
                    Utils.ListItemListPool.Return(ref _lstCachedContactArchetypes);
                // to help the GC
                PropertyChanged = null;
                MultiplePropertiesChanged = null;
                _setPropertyChangedAsync.Clear();
                _setMultiplePropertiesChangedAsync.Clear();
            }

            LockObject.Dispose();
        }

        /// <summary>
        /// Remove stray event handlers and clear all info used by this character
        /// </summary>
        public async ValueTask DisposeAsync()
        {
            if (LockObject.IsDisposed)
                return;

            if (await Program.OpenCharacters.ContainsAsync(this).ConfigureAwait(false)
                || await Program.OpenCharacters.AnyAsync(async x => (await x.GetLinkedCharactersAsync().ConfigureAwait(false)).Contains(this)).ConfigureAwait(false))
                return; // Do not actually dispose any characters who are still in the open characters list or required by a character who is

            if (Interlocked.CompareExchange(ref _intIsDisposed, 1, 0) > 0)
                return;

            IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync().ConfigureAwait(false);
            try
            {
                Interlocked.Exchange(ref _lstInternalIdsNeedingReapplyImprovements, null);
                _objSettings.MultiplePropertiesChangedAsync -= OptionsOnPropertyChanged;
                ImprovementManager.ClearAllCharacterValues(this);
                _lstLinkedCharacters.Clear(); // Clear this list because it relates to Contacts and Spirits disposal
                await _lstMugshots.ForEachAsync(x => x.Dispose()).ConfigureAwait(false);
                await _lstContacts.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false)).ConfigureAwait(false);
                await _lstSpirits.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false)).ConfigureAwait(false);
                await _lstArmor.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false)).ConfigureAwait(false);
                await _lstWeapons.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false)).ConfigureAwait(false);
                await _lstGear.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false)).ConfigureAwait(false);
                await _lstCyberware.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false)).ConfigureAwait(false);
                await _lstVehicles.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false)).ConfigureAwait(false);
                await _lstLifestyles.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false)).ConfigureAwait(false);
                await _lstSpells.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false)).ConfigureAwait(false);
                await _lstMartialArts.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false)).ConfigureAwait(false);
                await _lstMartialArts.DisposeAsync().ConfigureAwait(false);
                await _lstComplexForms.DisposeAsync().ConfigureAwait(false);
                await _lstAIPrograms.DisposeAsync().ConfigureAwait(false);
                await _lstPowers.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false)).ConfigureAwait(false);
                await _lstPowers.DisposeAsync().ConfigureAwait(false);
                await _lstCritterPowers.DisposeAsync().ConfigureAwait(false);
                await _lstFoci.DisposeAsync().ConfigureAwait(false);
                await _lstStackedFoci.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false)).ConfigureAwait(false);
                await _lstStackedFoci.DisposeAsync().ConfigureAwait(false);
                await _lstMetamagics.DisposeAsync().ConfigureAwait(false);
                await _lstArts.DisposeAsync().ConfigureAwait(false);
                await _lstEnhancements.DisposeAsync().ConfigureAwait(false);
                await _lstImprovements.DisposeAsync().ConfigureAwait(false);
                await _lstInitiationGrades.DisposeAsync().ConfigureAwait(false);
                await _lstQualities.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false)).ConfigureAwait(false);
                await _lstQualities.DisposeAsync().ConfigureAwait(false);
                await _lstCalendar.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false)).ConfigureAwait(false);
                await _lstCalendar.DisposeAsync().ConfigureAwait(false);
                await _lstDrugs.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false)).ConfigureAwait(false);
                await _lstDrugs.DisposeAsync().ConfigureAwait(false);
                await _lstMentorSpirits.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false)).ConfigureAwait(false);
                await _lstMentorSpirits.DisposeAsync().ConfigureAwait(false);
                await _lstExpenseLog.DisposeAsync().ConfigureAwait(false);
                await _lstArmorLocations.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false)).ConfigureAwait(false);
                await _lstGearLocations.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false)).ConfigureAwait(false);
                await _lstWeaponLocations.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false)).ConfigureAwait(false);
                await _lstVehicleLocations.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false)).ConfigureAwait(false);
                await _lstArmorLocations.DisposeAsync().ConfigureAwait(false);
                await _lstGearLocations.DisposeAsync().ConfigureAwait(false);
                await _lstWeaponLocations.DisposeAsync().ConfigureAwait(false);
                await _lstVehicleLocations.DisposeAsync().ConfigureAwait(false);
                await _lstImprovementGroups.DisposeAsync().ConfigureAwait(false);
                await _lstLimitModifiers.DisposeAsync().ConfigureAwait(false);
                await _lstSustainedObjects.DisposeAsync().ConfigureAwait(false);
                await _lstPrioritySkills.DisposeAsync().ConfigureAwait(false);
                await _objSkillsSection.DisposeAsync().ConfigureAwait(false);
                await _objAttributeSection.DisposeAsync().ConfigureAwait(false);
                await _setDoOnSaveCompleted.DisposeAsync().ConfigureAwait(false);
                await _setDoOnSaveCompletedAsync.DisposeAsync().ConfigureAwait(false);
                if (!(await SettingsManager.GetLoadedCharacterSettingsAsync().ConfigureAwait(false))
                    .ContainsKey(await _objSettings.GetDictionaryKeyAsync().ConfigureAwait(false)))
                    await _objSettings.DisposeAsync().ConfigureAwait(false);
                await _objCachedEssenceLock.DisposeAsync().ConfigureAwait(false);
                await _objCachedSourceDetailLock.DisposeAsync().ConfigureAwait(false);
                await _objCachedPowerPointsUsedLock.DisposeAsync().ConfigureAwait(false);
                await _objAvailabilityMapLock.DisposeAsync().ConfigureAwait(false);
                await _objCachedHasAnyQualitiesWithQualityLevelsLock.DisposeAsync().ConfigureAwait(false);
                await _objTradition.DisposeAsync().ConfigureAwait(false);
                if (_lstCachedContactArchetypes != null)
                    Utils.ListItemListPool.Return(ref _lstCachedContactArchetypes);
                // to help the GC
                PropertyChanged = null;
                MultiplePropertiesChanged = null;
                _setPropertyChangedAsync.Clear();
                _setMultiplePropertiesChangedAsync.Clear();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }

            await LockObject.DisposeAsync().ConfigureAwait(false);
        }

        /// <summary>
        /// Reset all of the Character information and start from scratch.
        /// </summary>
        public void ResetCharacter(CancellationToken token = default)
        {
            using (LockObject.EnterWriteLock(token))
            {
                _intFreeSpells = 0;
                _intCFPLimit = 0;
                _intAINormalProgramLimit = 0;
                _intAIAdvancedProgramLimit = 0;
                _intCachedCareerKarma = int.MinValue;
                _intCachedContactPoints = int.MinValue;
                _decCachedBaseCarryLimit = decimal.MinValue;
                _decCachedBaseLiftLimit = decimal.MinValue;
                _decCachedTotalCarriedWeight = decimal.MinValue;
                _decCachedEncumbranceInterval = decimal.MinValue;
                _intCachedEnemyKarma = int.MinValue;
                _intCachedInitiationEnabled = int.MinValue;
                _intCachedMetagenicNegativeQualities = int.MinValue;
                _intCachedMetagenicPositiveQualities = int.MinValue;
                _intCachedNegativeQualities = int.MinValue;
                _intCachedNegativeQualityLimitKarma = int.MinValue;
                _intCachedPositiveQualityLimitKarma = int.MinValue;
                _intCachedPositiveQualities = int.MinValue;
                _intCachedRedlinerBonus = int.MinValue;
                _intCachedRestrictedGear = int.MinValue;
                _intCachedTotalAcidArmorRating = int.MinValue;
                _intCachedTotalArmorRating = int.MinValue;
                _intCachedTotalColdArmorRating = int.MinValue;
                _intCachedTotalElectricityArmorRating = int.MinValue;
                _intCachedTotalFallingArmorRating = int.MinValue;
                _intCachedTotalFireArmorRating = int.MinValue;
                _intCurrentCounterspellingDice = 0;
                _intCurrentLiftCarryHits = 0;
                _decCachedBiowareEssence = decimal.MinValue;
                _decCachedCyberwareEssence = decimal.MinValue;
                ResetCachedEssence(token);
                _decCachedEssenceHole = decimal.MinValue;
                _decCachedPowerPointsUsed = decimal.MinValue;
                _decCachedPrototypeTranshumanEssenceUsed = decimal.MinValue;
                _intKarma = 0;
                _intSpecial = 0;
                _intTotalSpecial = 0;
                _intAttributes = 0;
                _intTotalAttributes = 0;
                _intEdgeUsed = 0;
                _intBoundSpiritLimit = int.MinValue;
                _intRegisteredSpriteLimit = int.MinValue;

                // Reset Metatype Information.
                _strMetatype = "Human";
                _strMetavariant = string.Empty;
                _strMetatypeCategory = "Metahuman";
                _intMetatypeBP = 0;
                _strMovement = string.Empty;
                _guiMetatype = Guid.Empty;
                _guiMetavariant = Guid.Empty;

                // Reset Special Tab Flags.
                _blnAdeptEnabled = false;
                _blnMagicianEnabled = false;
                _blnTechnomancerEnabled = false;
                _blnAdvancedProgramsEnabled = false;
                _blnCyberwareDisabled = false;
                _blnInitiationDisabled = false;
                _blnCritterEnabled = false;
                _objTradition.ResetTradition();

                // Reset Attributes.
                AttributeSection.Reset(token: token);
                SkillsSection.Reset(token: token);
                _blnMAGEnabled = false;
                _blnRESEnabled = false;
                _blnDEPEnabled = false;
                _blnGroupMember = false;
                _strGroupName = string.Empty;
                _strGroupNotes = string.Empty;
                _intInitiateGrade = 0;
                _intSubmersionGrade = 0;

                _intMAGAdept = 0;
                _intMAGMagician = 0;

                _lstLinkedCharacters.Clear();
                _intMainMugshotIndex = -1;
                _lstMugshots.ForEach(x => x.Dispose(), token);
                _lstMugshots.Clear();
                _lstContacts.ForEach(x => x.Dispose(), token);
                _lstContacts.Clear();
                _lstSpirits.ForEach(x => x.Dispose(), token);
                _lstSpirits.Clear();
                _lstArmor.ForEach(x => x.Dispose(), token);
                _lstWeapons.ForEach(x => x.Dispose(), token);
                _lstGear.ForEach(x => x.Dispose(), token);
                _lstCyberware.ForEach(x => x.Dispose(), token);
                _lstVehicles.ForEach(x => x.Dispose(), token);
                _lstLifestyles.ForEach(x => x.Dispose(), token);
                _lstSpells.ForEach(x => x.Dispose(), token);
                _lstComplexForms.ForEach(x => x.Dispose(), token);
                _lstPowers.ForEach(x => x.Dispose(), token);
                _lstMartialArts.ForEach(x => x.Dispose(), token);
                _lstStackedFoci.ForEach(x => x.Dispose(), token);
                _lstDrugs.ForEach(x => x.Dispose(), token);
                _lstMentorSpirits.ForEach(x => x.Dispose(), token);
                _lstGearLocations.ForEach(x => x.Dispose(), token);
                _lstArmorLocations.ForEach(x => x.Dispose(), token);
                _lstWeaponLocations.ForEach(x => x.Dispose(), token);
                _lstVehicleLocations.ForEach(x => x.Dispose(), token);
                // Reset all of the Lists.
                // This kills the GC
                ImprovementManager.ClearAllCharacterValues(this, token);
                _lstImprovements.Clear();
                _lstSpells.Clear();
                _lstSustainedObjects.Clear();
                _lstFoci.Clear();
                _lstStackedFoci.Clear();
                _lstPowers.Clear();
                _lstComplexForms.Clear();
                _lstAIPrograms.Clear();
                _lstMartialArts.Clear();
                _lstLimitModifiers.Clear();
                _lstArmor.Clear();
                _lstCyberware.Clear();
                _lstMetamagics.Clear();
                _lstArts.Clear();
                _lstEnhancements.Clear();
                _lstWeapons.Clear();
                _lstLifestyles.Clear();
                _lstGear.Clear();
                _lstVehicles.Clear();
                _lstExpenseLog.Clear();
                _lstCritterPowers.Clear();
                _lstInitiationGrades.Clear();
                _lstQualities.Clear();
                _lstCalendar.Clear();
                _lstDrugs.Clear();
                _lstMentorSpirits.Clear();
                _lstGearLocations.Clear();
                _lstArmorLocations.Clear();
                _lstWeaponLocations.Clear();
                _lstVehicleLocations.Clear();
                _lstImprovementGroups.Clear();

                LoadAsDirty = false;
            }
        }

        /// <summary>
        /// Reset all of the Character information and start from scratch.
        /// </summary>
        public async Task ResetCharacterAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                _intFreeSpells = 0;
                _intCFPLimit = 0;
                _intAINormalProgramLimit = 0;
                _intAIAdvancedProgramLimit = 0;
                _intCachedCareerKarma = int.MinValue;
                _intCachedContactPoints = int.MinValue;
                _decCachedBaseCarryLimit = decimal.MinValue;
                _decCachedBaseLiftLimit = decimal.MinValue;
                _decCachedTotalCarriedWeight = decimal.MinValue;
                _decCachedEncumbranceInterval = decimal.MinValue;
                _intCachedEnemyKarma = int.MinValue;
                _intCachedInitiationEnabled = int.MinValue;
                _intCachedMetagenicNegativeQualities = int.MinValue;
                _intCachedMetagenicPositiveQualities = int.MinValue;
                _intCachedNegativeQualities = int.MinValue;
                _intCachedNegativeQualityLimitKarma = int.MinValue;
                _intCachedPositiveQualityLimitKarma = int.MinValue;
                _intCachedPositiveQualities = int.MinValue;
                _intCachedRedlinerBonus = int.MinValue;
                _intCachedRestrictedGear = int.MinValue;
                _intCachedTotalAcidArmorRating = int.MinValue;
                _intCachedTotalArmorRating = int.MinValue;
                _intCachedTotalColdArmorRating = int.MinValue;
                _intCachedTotalElectricityArmorRating = int.MinValue;
                _intCachedTotalFallingArmorRating = int.MinValue;
                _intCachedTotalFireArmorRating = int.MinValue;
                _intCurrentCounterspellingDice = 0;
                _intCurrentLiftCarryHits = 0;
                _decCachedBiowareEssence = decimal.MinValue;
                _decCachedCyberwareEssence = decimal.MinValue;
                await ResetCachedEssenceAsync(token).ConfigureAwait(false);
                _decCachedEssenceHole = decimal.MinValue;
                _decCachedPowerPointsUsed = decimal.MinValue;
                _decCachedPrototypeTranshumanEssenceUsed = decimal.MinValue;
                _intKarma = 0;
                _intSpecial = 0;
                _intTotalSpecial = 0;
                _intAttributes = 0;
                _intTotalAttributes = 0;
                _intEdgeUsed = 0;
                _intBoundSpiritLimit = int.MinValue;
                _intRegisteredSpriteLimit = int.MinValue;

                // Reset Metatype Information.
                _strMetatype = "Human";
                _strMetavariant = string.Empty;
                _strMetatypeCategory = "Metahuman";
                _intMetatypeBP = 0;
                _strMovement = string.Empty;
                _guiMetatype = Guid.Empty;
                _guiMetavariant = Guid.Empty;

                // Reset Special Tab Flags.
                _blnAdeptEnabled = false;
                _blnMagicianEnabled = false;
                _blnTechnomancerEnabled = false;
                _blnAdvancedProgramsEnabled = false;
                _blnCyberwareDisabled = false;
                _blnInitiationDisabled = false;
                _blnCritterEnabled = false;
                await _objTradition.ResetTraditionAsync(token).ConfigureAwait(false);

                // Reset Attributes.
                await AttributeSection.ResetAsync(token: token).ConfigureAwait(false);
                await SkillsSection.ResetAsync(token: token).ConfigureAwait(false);
                _blnMAGEnabled = false;
                _blnRESEnabled = false;
                _blnDEPEnabled = false;
                _blnGroupMember = false;
                _strGroupName = string.Empty;
                _strGroupNotes = string.Empty;
                _intInitiateGrade = 0;
                _intSubmersionGrade = 0;

                _intMAGAdept = 0;
                _intMAGMagician = 0;

                _lstLinkedCharacters.Clear();
                _intMainMugshotIndex = -1;
                await _lstMugshots.ForEachAsync(x => x.Dispose(), token).ConfigureAwait(false);
                await _lstMugshots.ClearAsync(token).ConfigureAwait(false);
                await _lstContacts.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false), token)
                                  .ConfigureAwait(false);
                await _lstContacts.ClearAsync(token).ConfigureAwait(false);
                await _lstSpirits.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false), token)
                                 .ConfigureAwait(false);
                await _lstSpirits.ClearAsync(token).ConfigureAwait(false);
                await _lstArmor.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false), token)
                               .ConfigureAwait(false);
                await _lstWeapons.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false), token)
                                 .ConfigureAwait(false);
                await _lstGear.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false), token)
                              .ConfigureAwait(false);
                await _lstCyberware.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false), token)
                                   .ConfigureAwait(false);
                await _lstVehicles.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false), token)
                                  .ConfigureAwait(false);
                await _lstLifestyles.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false), token)
                                    .ConfigureAwait(false);
                await _lstSpells.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false), token)
                    .ConfigureAwait(false);
                await _lstPowers.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false), token)
                                .ConfigureAwait(false);
                await _lstMartialArts.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false), token)
                                     .ConfigureAwait(false);
                await _lstStackedFoci.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false), token)
                                     .ConfigureAwait(false);
                await _lstDrugs.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false), token)
                               .ConfigureAwait(false);
                await _lstMentorSpirits.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false), token)
                                       .ConfigureAwait(false);
                await _lstGearLocations.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false), token).ConfigureAwait(false);
                await _lstArmorLocations.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false), token).ConfigureAwait(false);
                await _lstWeaponLocations.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false), token).ConfigureAwait(false);
                await _lstVehicleLocations.ForEachWithSideEffectsAsync(async x => await x.DisposeAsync().ConfigureAwait(false), token).ConfigureAwait(false);
                // Reset all of the Lists.
                // This kills the GC
                ImprovementManager.ClearAllCharacterValues(this, token);
                await _lstImprovements.ClearAsync(token).ConfigureAwait(false);
                await _lstSpells.ClearAsync(token).ConfigureAwait(false);
                await _lstSustainedObjects.ClearAsync(token).ConfigureAwait(false);
                await _lstFoci.ClearAsync(token).ConfigureAwait(false);
                await _lstStackedFoci.ClearAsync(token).ConfigureAwait(false);
                await _lstPowers.ClearAsync(token).ConfigureAwait(false);
                await _lstComplexForms.ClearAsync(token).ConfigureAwait(false);
                await _lstAIPrograms.ClearAsync(token).ConfigureAwait(false);
                await _lstMartialArts.ClearAsync(token).ConfigureAwait(false);
                await _lstLimitModifiers.ClearAsync(token).ConfigureAwait(false);
                await _lstArmor.ClearAsync(token).ConfigureAwait(false);
                await _lstCyberware.ClearAsync(token).ConfigureAwait(false);
                await _lstMetamagics.ClearAsync(token).ConfigureAwait(false);
                await _lstArts.ClearAsync(token).ConfigureAwait(false);
                await _lstEnhancements.ClearAsync(token).ConfigureAwait(false);
                await _lstWeapons.ClearAsync(token).ConfigureAwait(false);
                await _lstLifestyles.ClearAsync(token).ConfigureAwait(false);
                await _lstGear.ClearAsync(token).ConfigureAwait(false);
                await _lstVehicles.ClearAsync(token).ConfigureAwait(false);
                await _lstExpenseLog.ClearAsync(token).ConfigureAwait(false);
                await _lstCritterPowers.ClearAsync(token).ConfigureAwait(false);
                await _lstInitiationGrades.ClearAsync(token).ConfigureAwait(false);
                await _lstQualities.ClearAsync(token).ConfigureAwait(false);
                await _lstCalendar.ClearAsync(token).ConfigureAwait(false);
                await _lstDrugs.ClearAsync(token).ConfigureAwait(false);
                await _lstMentorSpirits.ClearAsync(token).ConfigureAwait(false);
                await _lstGearLocations.ClearAsync(token).ConfigureAwait(false);
                await _lstArmorLocations.ClearAsync(token).ConfigureAwait(false);
                await _lstWeaponLocations.ClearAsync(token).ConfigureAwait(false);
                await _lstVehicleLocations.ClearAsync(token).ConfigureAwait(false);
                await _lstImprovementGroups.ClearAsync(token).ConfigureAwait(false);
                await SetLoadAsDirtyAsync(false, token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        #endregion Initialization, Save, Load, Print, and Reset Methods

        #region Helper Methods

        public IEnumerable<IHasInternalId> GetItemsByInternalIds(IEnumerable<string> lstIds, bool blnOnlyValidImprovementSources = false, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool, out HashSet<string> setIds))
            {
                token.ThrowIfCancellationRequested();
                foreach (string strId in lstIds)
                {
                    if (!string.IsNullOrEmpty(strId))
                        setIds.Add(strId.TrimEndOnce("Pair").TrimEndOnce("Wireless"));
                }
                if (setIds.Count == 0)
                    yield break;
                using (LockObject.EnterReadLock(token))
                {
                    foreach (Gear objGear in Gear.GetAllDescendants(x => x.Children, token))
                    {
                        if (setIds.Remove(objGear.InternalId))
                        {
                            yield return objGear;
                            if (setIds.Count == 0)
                                yield break;
                        }
                    }

                    foreach (Armor objArmor in Armor)
                    {
                        token.ThrowIfCancellationRequested();
                        if (setIds.Remove(objArmor.InternalId))
                        {
                            yield return objArmor;
                            if (setIds.Count == 0)
                                yield break;
                        }
                        foreach (ArmorMod objMod in objArmor.ArmorMods)
                        {
                            token.ThrowIfCancellationRequested();
                            if (setIds.Remove(objMod.InternalId))
                            {
                                yield return objMod;
                                if (setIds.Count == 0)
                                    yield break;
                            }
                            foreach (Gear objGear in objMod.GearChildren.GetAllDescendants(x => x.Children, token))
                            {
                                if (setIds.Remove(objGear.InternalId))
                                {
                                    yield return objGear;
                                    if (setIds.Count == 0)
                                        yield break;
                                }
                            }
                        }
                        foreach (Gear objGear in objArmor.GearChildren.GetAllDescendants(x => x.Children, token))
                        {
                            if (setIds.Remove(objGear.InternalId))
                            {
                                yield return objGear;
                                if (setIds.Count == 0)
                                    yield break;
                            }
                        }
                    }

                    foreach (Weapon objWeapon in Weapons.GetAllDescendants(x => x.UnderbarrelWeapons, token))
                    {
                        if (setIds.Remove(objWeapon.InternalId))
                        {
                            yield return objWeapon;
                            if (setIds.Count == 0)
                                yield break;
                        }
                        foreach (WeaponAccessory objMod in objWeapon.WeaponAccessories)
                        {
                            token.ThrowIfCancellationRequested();
                            if (setIds.Remove(objMod.InternalId))
                            {
                                yield return objMod;
                                if (setIds.Count == 0)
                                    yield break;
                            }
                            foreach (Gear objGear in objMod.GearChildren.GetAllDescendants(x => x.Children, token))
                            {
                                if (setIds.Remove(objGear.InternalId))
                                {
                                    yield return objGear;
                                    if (setIds.Count == 0)
                                        yield break;
                                }
                            }
                        }
                    }

                    foreach (Cyberware objCyberware in Cyberware.GetAllDescendants(x => x.Children, token))
                    {
                        if (setIds.Remove(objCyberware.InternalId))
                        {
                            yield return objCyberware;
                            if (setIds.Count == 0)
                                yield break;
                        }
                        foreach (Gear objGear in objCyberware.GearChildren.GetAllDescendants(x => x.Children, token))
                        {
                            if (setIds.Remove(objGear.InternalId))
                            {
                                yield return objGear;
                                if (setIds.Count == 0)
                                    yield break;
                            }
                        }
                    }

                    foreach (Drug objDrug in Drugs)
                    {
                        token.ThrowIfCancellationRequested();
                        if (setIds.Remove(objDrug.InternalId))
                        {
                            yield return objDrug;
                            if (setIds.Count == 0)
                                yield break;
                        }
                        foreach (DrugComponent objComponent in objDrug.Components)
                        {
                            token.ThrowIfCancellationRequested();
                            if (setIds.Remove(objComponent.InternalId))
                            {
                                yield return objComponent;
                                if (setIds.Count == 0)
                                    yield break;
                            }
                        }
                    }

                    foreach (Lifestyle objLifestyle in Lifestyles)
                    {
                        token.ThrowIfCancellationRequested();
                        if (setIds.Remove(objLifestyle.InternalId))
                        {
                            yield return objLifestyle;
                            if (setIds.Count == 0)
                                yield break;
                        }
                        foreach (LifestyleQuality objQuality in objLifestyle.LifestyleQualities)
                        {
                            token.ThrowIfCancellationRequested();
                            if (setIds.Remove(objQuality.InternalId))
                            {
                                yield return objQuality;
                                if (setIds.Count == 0)
                                    yield break;
                            }
                        }
                    }

                    foreach (Improvement objImprovement in Improvements)
                    {
                        token.ThrowIfCancellationRequested();
                        if (setIds.Remove(objImprovement.InternalId))
                        {
                            yield return objImprovement;
                            if (setIds.Count == 0)
                                yield break;
                        }
                    }

                    foreach (Art objArt in Arts)
                    {
                        token.ThrowIfCancellationRequested();
                        if (setIds.Remove(objArt.InternalId))
                        {
                            yield return objArt;
                            if (setIds.Count == 0)
                                yield break;
                        }
                    }
                    foreach (CritterPower objCritterPower in CritterPowers)
                    {
                        token.ThrowIfCancellationRequested();
                        if (setIds.Remove(objCritterPower.InternalId))
                        {
                            yield return objCritterPower;
                            if (setIds.Count == 0)
                                yield break;
                        }
                    }
                    foreach (Enhancement objEnhancement in Enhancements)
                    {
                        token.ThrowIfCancellationRequested();
                        if (setIds.Remove(objEnhancement.InternalId))
                        {
                            yield return objEnhancement;
                            if (setIds.Count == 0)
                                yield break;
                        }
                    }
                    foreach (InitiationGrade objGrade in InitiationGrades)
                    {
                        token.ThrowIfCancellationRequested();
                        if (setIds.Remove(objGrade.InternalId))
                        {
                            yield return objGrade;
                            if (setIds.Count == 0)
                                yield break;
                        }
                    }
                    foreach (LimitModifier objModifier in LimitModifiers)
                    {
                        token.ThrowIfCancellationRequested();
                        if (setIds.Remove(objModifier.InternalId))
                        {
                            yield return objModifier;
                            if (setIds.Count == 0)
                                yield break;
                        }
                    }
                    foreach (MartialArt objArt in MartialArts)
                    {
                        token.ThrowIfCancellationRequested();
                        if (setIds.Remove(objArt.InternalId))
                        {
                            yield return objArt;
                            if (setIds.Count == 0)
                                yield break;
                        }
                        foreach (MartialArtTechnique objTechnique in objArt.Techniques)
                        {
                            token.ThrowIfCancellationRequested();
                            if (setIds.Remove(objTechnique.InternalId))
                            {
                                yield return objTechnique;
                                if (setIds.Count == 0)
                                    yield break;
                            }
                        }
                    }
                    foreach (MentorSpirit objMentor in MentorSpirits)
                    {
                        token.ThrowIfCancellationRequested();
                        if (setIds.Remove(objMentor.InternalId))
                        {
                            yield return objMentor;
                            if (setIds.Count == 0)
                                yield break;
                        }
                    }
                    foreach (Metamagic objMetamagic in Metamagics)
                    {
                        token.ThrowIfCancellationRequested();
                        if (setIds.Remove(objMetamagic.InternalId))
                        {
                            yield return objMetamagic;
                            if (setIds.Count == 0)
                                yield break;
                        }
                    }
                    foreach (Power objPower in Powers)
                    {
                        token.ThrowIfCancellationRequested();
                        if (setIds.Remove(objPower.InternalId))
                        {
                            yield return objPower;
                            if (setIds.Count == 0)
                                yield break;
                        }
                    }
                    foreach (Quality objQuality in Qualities)
                    {
                        token.ThrowIfCancellationRequested();
                        if (setIds.Remove(objQuality.InternalId))
                        {
                            yield return objQuality;
                            if (setIds.Count == 0)
                                yield break;
                        }
                    }
                    token.ThrowIfCancellationRequested();
                    if (setIds.Remove(MagicTradition.InternalId))
                    {
                        yield return MagicTradition;
                        if (setIds.Count == 0)
                            yield break;
                    }

                    if (!blnOnlyValidImprovementSources)
                    {
                        foreach (Vehicle objVehicle in Vehicles)
                        {
                            token.ThrowIfCancellationRequested();
                            if (setIds.Remove(objVehicle.InternalId))
                            {
                                yield return objVehicle;
                                if (setIds.Count == 0)
                                    yield break;
                            }
                            foreach (Gear objGear in objVehicle.GearChildren.GetAllDescendants(x => x.Children, token))
                            {
                                if (setIds.Remove(objGear.InternalId))
                                {
                                    yield return objGear;
                                    if (setIds.Count == 0)
                                        yield break;
                                }
                            }
                            foreach (Weapon objWeapon in objVehicle.Weapons.GetAllDescendants(x => x.UnderbarrelWeapons, token))
                            {
                                if (setIds.Remove(objWeapon.InternalId))
                                {
                                    yield return objWeapon;
                                    if (setIds.Count == 0)
                                        yield break;
                                }
                                foreach (WeaponAccessory objMod in objWeapon.WeaponAccessories)
                                {
                                    token.ThrowIfCancellationRequested();
                                    if (setIds.Remove(objMod.InternalId))
                                    {
                                        yield return objMod;
                                        if (setIds.Count == 0)
                                            yield break;
                                    }
                                    foreach (Gear objGear in objMod.GearChildren.GetAllDescendants(x => x.Children, token))
                                    {
                                        if (setIds.Remove(objGear.InternalId))
                                        {
                                            yield return objGear;
                                            if (setIds.Count == 0)
                                                yield break;
                                        }
                                    }
                                }
                            }
                            foreach (VehicleMod objMod in objVehicle.Mods)
                            {
                                token.ThrowIfCancellationRequested();
                                if (setIds.Remove(objMod.InternalId))
                                {
                                    yield return objMod;
                                    if (setIds.Count == 0)
                                        yield break;
                                }
                                foreach (Cyberware objCyberware in objMod.Cyberware.GetAllDescendants(x => x.Children, token))
                                {
                                    if (setIds.Remove(objCyberware.InternalId))
                                    {
                                        yield return objCyberware;
                                        if (setIds.Count == 0)
                                            yield break;
                                    }
                                    foreach (Gear objGear in objCyberware.GearChildren.GetAllDescendants(x => x.Children, token))
                                    {
                                        if (setIds.Remove(objGear.InternalId))
                                        {
                                            yield return objGear;
                                            if (setIds.Count == 0)
                                                yield break;
                                        }
                                    }
                                }
                            }
                            foreach (WeaponMount objMount in objVehicle.WeaponMounts)
                            {
                                token.ThrowIfCancellationRequested();
                                if (setIds.Remove(objMount.InternalId))
                                {
                                    yield return objMount;
                                    if (setIds.Count == 0)
                                        yield break;
                                }
                                foreach (WeaponMountOption objOption in objMount.WeaponMountOptions)
                                {
                                    token.ThrowIfCancellationRequested();
                                    if (setIds.Remove(objOption.InternalId))
                                    {
                                        yield return objOption;
                                        if (setIds.Count == 0)
                                            yield break;
                                    }
                                }
                                foreach (Weapon objWeapon in objMount.Weapons.GetAllDescendants(x => x.UnderbarrelWeapons, token))
                                {
                                    if (setIds.Remove(objWeapon.InternalId))
                                    {
                                        yield return objWeapon;
                                        if (setIds.Count == 0)
                                            yield break;
                                    }
                                    foreach (WeaponAccessory objMod in objWeapon.WeaponAccessories)
                                    {
                                        token.ThrowIfCancellationRequested();
                                        if (setIds.Remove(objMod.InternalId))
                                        {
                                            yield return objMod;
                                            if (setIds.Count == 0)
                                                yield break;
                                        }
                                        foreach (Gear objGear in objMod.GearChildren.GetAllDescendants(x => x.Children, token))
                                        {
                                            if (setIds.Remove(objGear.InternalId))
                                            {
                                                yield return objGear;
                                                if (setIds.Count == 0)
                                                    yield break;
                                            }
                                        }
                                    }
                                }
                                foreach (VehicleMod objMod in objMount.Mods)
                                {
                                    token.ThrowIfCancellationRequested();
                                    if (setIds.Remove(objMod.InternalId))
                                    {
                                        yield return objMod;
                                        if (setIds.Count == 0)
                                            yield break;
                                    }
                                    foreach (Cyberware objCyberware in objMod.Cyberware.GetAllDescendants(x => x.Children, token))
                                    {
                                        if (setIds.Remove(objCyberware.InternalId))
                                        {
                                            yield return objCyberware;
                                            if (setIds.Count == 0)
                                                yield break;
                                        }
                                        foreach (Gear objGear in objCyberware.GearChildren.GetAllDescendants(x => x.Children, token))
                                        {
                                            if (setIds.Remove(objGear.InternalId))
                                            {
                                                yield return objGear;
                                                if (setIds.Count == 0)
                                                    yield break;
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        foreach (Skill objSkill in SkillsSection.Skills)
                        {
                            token.ThrowIfCancellationRequested();
                            if (setIds.Remove(objSkill.InternalId))
                            {
                                yield return objSkill;
                                if (setIds.Count == 0)
                                    yield break;
                            }
                            foreach (SkillSpecialization objSpec in objSkill.Specializations)
                            {
                                token.ThrowIfCancellationRequested();
                                if (setIds.Remove(objSpec.InternalId))
                                {
                                    yield return objSpec;
                                    if (setIds.Count == 0)
                                        yield break;
                                }
                            }
                        }
                        foreach (SkillGroup objGroup in SkillsSection.SkillGroups)
                        {
                            token.ThrowIfCancellationRequested();
                            if (setIds.Remove(objGroup.InternalId))
                            {
                                yield return objGroup;
                                if (setIds.Count == 0)
                                    yield break;
                            }
                        }
                        foreach (KnowledgeSkill objSkill in SkillsSection.KnowledgeSkills)
                        {
                            token.ThrowIfCancellationRequested();
                            if (setIds.Remove(objSkill.InternalId))
                            {
                                yield return objSkill;
                                if (setIds.Count == 0)
                                    yield break;
                            }
                            foreach (SkillSpecialization objSpec in objSkill.Specializations)
                            {
                                token.ThrowIfCancellationRequested();
                                if (setIds.Remove(objSpec.InternalId))
                                {
                                    yield return objSpec;
                                    if (setIds.Count == 0)
                                        yield break;
                                }
                            }
                        }

                        foreach (Contact objContact in Contacts)
                        {
                            token.ThrowIfCancellationRequested();
                            if (setIds.Remove(objContact.InternalId))
                            {
                                yield return objContact;
                                if (setIds.Count == 0)
                                    yield break;
                            }
                        }
                        foreach (Spirit objSpirit in Spirits)
                        {
                            token.ThrowIfCancellationRequested();
                            if (setIds.Remove(objSpirit.InternalId))
                            {
                                yield return objSpirit;
                                if (setIds.Count == 0)
                                    yield break;
                            }
                        }

                        foreach (AIProgram objProgram in AIPrograms)
                        {
                            token.ThrowIfCancellationRequested();
                            if (setIds.Remove(objProgram.InternalId))
                            {
                                yield return objProgram;
                                if (setIds.Count == 0)
                                    yield break;
                            }
                        }
                        foreach (CalendarWeek objWeek in Calendar)
                        {
                            token.ThrowIfCancellationRequested();
                            if (setIds.Remove(objWeek.InternalId))
                            {
                                yield return objWeek;
                                if (setIds.Count == 0)
                                    yield break;
                            }
                        }
                        foreach (ComplexForm objComplexForm in ComplexForms)
                        {
                            token.ThrowIfCancellationRequested();
                            if (setIds.Remove(objComplexForm.InternalId))
                            {
                                yield return objComplexForm;
                                if (setIds.Count == 0)
                                    yield break;
                            }
                        }
                        foreach (ExpenseLogEntry objEntry in ExpenseEntries)
                        {
                            token.ThrowIfCancellationRequested();
                            if (setIds.Remove(objEntry.InternalId))
                            {
                                yield return objEntry;
                                if (setIds.Count == 0)
                                    yield break;
                            }
                        }
                        foreach (Focus objFocus in Foci)
                        {
                            token.ThrowIfCancellationRequested();
                            if (setIds.Remove(objFocus.InternalId))
                            {
                                yield return objFocus;
                                if (setIds.Count == 0)
                                    yield break;
                            }
                        }
                        foreach (Spell objSpell in Spells)
                        {
                            token.ThrowIfCancellationRequested();
                            if (setIds.Remove(objSpell.InternalId))
                            {
                                yield return objSpell;
                                if (setIds.Count == 0)
                                    yield break;
                            }
                        }
                        foreach (SustainedObject objSustained in SustainedCollection)
                        {
                            token.ThrowIfCancellationRequested();
                            if (setIds.Remove(objSustained.InternalId))
                            {
                                yield return objSustained;
                                if (setIds.Count == 0)
                                    yield break;
                            }
                        }
                    }
                }
            }
        }

        public async Task<List<IHasInternalId>> GetItemsByInternalIdsAsync(IEnumerable<string> lstIds, bool blnOnlyValidImprovementSources = false, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool, out HashSet<string> setIds))
            {
                token.ThrowIfCancellationRequested();
                foreach (string strId in lstIds)
                {
                    if (!string.IsNullOrEmpty(strId))
                        setIds.Add(strId.TrimEndOnce("Pair").TrimEndOnce("Wireless"));
                }
                List<IHasInternalId> lstReturn = new List<IHasInternalId>(setIds.Count);
                if (setIds.Count == 0)
                    return lstReturn;
                IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    await (await Gear.GetAllDescendantsAsync(x => x.Children, token)).ForEachWithBreakAsync(x =>
                    {
                        if (setIds.Remove(x.InternalId))
                        {
                            lstReturn.Add(x);
                            if (setIds.Count == 0)
                                return false;
                        }
                        return true;
                    }, token).ConfigureAwait(false);
                    if (setIds.Count == 0)
                        return lstReturn;
                    await Armor.ForEachWithBreakAsync(async objArmor =>
                    {
                        if (setIds.Remove(objArmor.InternalId))
                        {
                            lstReturn.Add(objArmor);
                            if (setIds.Count == 0)
                                return false;
                        }
                        await objArmor.ArmorMods.ForEachWithBreakAsync(async objMod =>
                        {
                            if (setIds.Remove(objMod.InternalId))
                            {
                                lstReturn.Add(objMod);
                                if (setIds.Count == 0)
                                    return false;
                            }
                            await (await objMod.GearChildren.GetAllDescendantsAsync(x => x.Children, token)).ForEachWithBreakAsync(x =>
                            {
                                if (setIds.Remove(x.InternalId))
                                {
                                    lstReturn.Add(x);
                                    if (setIds.Count == 0)
                                        return false;
                                }
                                return true;
                            }, token).ConfigureAwait(false);
                            return setIds.Count > 0;
                        }, token).ConfigureAwait(false);
                        if (setIds.Count == 0)
                            return false;
                        await (await objArmor.GearChildren.GetAllDescendantsAsync(x => x.Children, token)).ForEachWithBreakAsync(x =>
                        {
                            if (setIds.Remove(x.InternalId))
                            {
                                lstReturn.Add(x);
                                if (setIds.Count == 0)
                                    return false;
                            }
                            return true;
                        }, token).ConfigureAwait(false);
                        return setIds.Count > 0;
                    }, token).ConfigureAwait(false);
                    if (setIds.Count == 0)
                        return lstReturn;
                    await (await Weapons.GetAllDescendantsAsync(x => x.Children, token)).ForEachWithBreakAsync(async objWeapon =>
                    {
                        if (setIds.Remove(objWeapon.InternalId))
                        {
                            lstReturn.Add(objWeapon);
                            if (setIds.Count == 0)
                                return false;
                        }
                        await objWeapon.WeaponAccessories.ForEachWithBreakAsync(async objMod =>
                        {
                            if (setIds.Remove(objMod.InternalId))
                            {
                                lstReturn.Add(objMod);
                                if (setIds.Count == 0)
                                    return false;
                            }
                            await (await objMod.GearChildren.GetAllDescendantsAsync(x => x.Children, token)).ForEachWithBreakAsync(x =>
                            {
                                if (setIds.Remove(x.InternalId))
                                {
                                    lstReturn.Add(x);
                                    if (setIds.Count == 0)
                                        return false;
                                }
                                return true;
                            }, token).ConfigureAwait(false);
                            return setIds.Count > 0;
                        }, token).ConfigureAwait(false);
                        return setIds.Count > 0;
                    }, token).ConfigureAwait(false);
                    if (setIds.Count == 0)
                        return lstReturn;
                    await (await Cyberware.GetAllDescendantsAsync(x => x.Children, token)).ForEachWithBreakAsync(async objCyberware =>
                    {
                        token.ThrowIfCancellationRequested();
                        if (setIds.Remove(objCyberware.InternalId))
                        {
                            lstReturn.Add(objCyberware);
                            if (setIds.Count == 0)
                                return false;
                        }
                        await (await objCyberware.GearChildren.GetAllDescendantsAsync(x => x.Children, token)).ForEachWithBreakAsync(x =>
                        {
                            if (setIds.Remove(x.InternalId))
                            {
                                lstReturn.Add(x);
                                if (setIds.Count == 0)
                                    return false;
                            }
                            return true;
                        }, token).ConfigureAwait(false);
                        return setIds.Count > 0;
                    }, token).ConfigureAwait(false);
                    if (setIds.Count == 0)
                        return lstReturn;
                    await Drugs.ForEachWithBreakAsync(async objDrug =>
                    {
                        token.ThrowIfCancellationRequested();
                        if (setIds.Remove(objDrug.InternalId))
                        {
                            lstReturn.Add(objDrug);
                            if (setIds.Count == 0)
                                return false;
                        }
                        await objDrug.Components.ForEachWithBreakAsync(x =>
                        {
                            if (setIds.Remove(x.InternalId))
                            {
                                lstReturn.Add(x);
                                if (setIds.Count == 0)
                                    return false;
                            }
                            return true;
                        }, token).ConfigureAwait(false);
                        return setIds.Count > 0;
                    }, token).ConfigureAwait(false);
                    if (setIds.Count == 0)
                        return lstReturn;
                    await Lifestyles.ForEachWithBreakAsync(async objLifestyle =>
                    {
                        token.ThrowIfCancellationRequested();
                        if (setIds.Remove(objLifestyle.InternalId))
                        {
                            lstReturn.Add(objLifestyle);
                            if (setIds.Count == 0)
                                return false;
                        }
                        await objLifestyle.LifestyleQualities.ForEachWithBreakAsync(x =>
                        {
                            if (setIds.Remove(x.InternalId))
                            {
                                lstReturn.Add(x);
                                if (setIds.Count == 0)
                                    return false;
                            }
                            return true;
                        }, token).ConfigureAwait(false);
                        return setIds.Count > 0;
                    }, token).ConfigureAwait(false);
                    if (setIds.Count == 0)
                        return lstReturn;
                    await Improvements.ForEachWithBreakAsync(x =>
                    {
                        if (setIds.Remove(x.InternalId))
                        {
                            lstReturn.Add(x);
                            if (setIds.Count == 0)
                                return false;
                        }
                        return true;
                    }, token).ConfigureAwait(false);
                    if (setIds.Count == 0)
                        return lstReturn;
                    await Arts.ForEachWithBreakAsync(x =>
                    {
                        if (setIds.Remove(x.InternalId))
                        {
                            lstReturn.Add(x);
                            if (setIds.Count == 0)
                                return false;
                        }
                        return true;
                    }, token).ConfigureAwait(false);
                    if (setIds.Count == 0)
                        return lstReturn;
                    await CritterPowers.ForEachWithBreakAsync(x =>
                    {
                        if (setIds.Remove(x.InternalId))
                        {
                            lstReturn.Add(x);
                            if (setIds.Count == 0)
                                return false;
                        }
                        return true;
                    }, token).ConfigureAwait(false);
                    if (setIds.Count == 0)
                        return lstReturn;
                    await Enhancements.ForEachWithBreakAsync(x =>
                    {
                        if (setIds.Remove(x.InternalId))
                        {
                            lstReturn.Add(x);
                            if (setIds.Count == 0)
                                return false;
                        }
                        return true;
                    }, token).ConfigureAwait(false);
                    if (setIds.Count == 0)
                        return lstReturn;
                    await InitiationGrades.ForEachWithBreakAsync(x =>
                    {
                        if (setIds.Remove(x.InternalId))
                        {
                            lstReturn.Add(x);
                            if (setIds.Count == 0)
                                return false;
                        }
                        return true;
                    }, token).ConfigureAwait(false);
                    if (setIds.Count == 0)
                        return lstReturn;
                    await LimitModifiers.ForEachWithBreakAsync(x =>
                    {
                        if (setIds.Remove(x.InternalId))
                        {
                            lstReturn.Add(x);
                            if (setIds.Count == 0)
                                return false;
                        }
                        return true;
                    }, token).ConfigureAwait(false);
                    if (setIds.Count == 0)
                        return lstReturn;
                    await MartialArts.ForEachWithBreakAsync(async objArt =>
                    {
                        token.ThrowIfCancellationRequested();
                        if (setIds.Remove(objArt.InternalId))
                        {
                            lstReturn.Add(objArt);
                            if (setIds.Count == 0)
                                return false;
                        }
                        await objArt.Techniques.ForEachWithBreakAsync(x =>
                        {
                            if (setIds.Remove(x.InternalId))
                            {
                                lstReturn.Add(x);
                                if (setIds.Count == 0)
                                    return false;
                            }
                            return true;
                        }, token).ConfigureAwait(false);
                        return setIds.Count > 0;
                    }, token).ConfigureAwait(false);
                    if (setIds.Count == 0)
                        return lstReturn;
                    await MentorSpirits.ForEachWithBreakAsync(x =>
                    {
                        if (setIds.Remove(x.InternalId))
                        {
                            lstReturn.Add(x);
                            if (setIds.Count == 0)
                                return false;
                        }
                        return true;
                    }, token).ConfigureAwait(false);
                    if (setIds.Count == 0)
                        return lstReturn;
                    await Metamagics.ForEachWithBreakAsync(x =>
                    {
                        if (setIds.Remove(x.InternalId))
                        {
                            lstReturn.Add(x);
                            if (setIds.Count == 0)
                                return false;
                        }
                        return true;
                    }, token).ConfigureAwait(false);
                    if (setIds.Count == 0)
                        return lstReturn;
                    await Powers.ForEachWithBreakAsync(x =>
                    {
                        if (setIds.Remove(x.InternalId))
                        {
                            lstReturn.Add(x);
                            if (setIds.Count == 0)
                                return false;
                        }
                        return true;
                    }, token).ConfigureAwait(false);
                    if (setIds.Count == 0)
                        return lstReturn;
                    await Qualities.ForEachWithBreakAsync(x =>
                    {
                        if (setIds.Remove(x.InternalId))
                        {
                            lstReturn.Add(x);
                            if (setIds.Count == 0)
                                return false;
                        }
                        return true;
                    }, token).ConfigureAwait(false);
                    if (setIds.Count == 0)
                        return lstReturn;
                    token.ThrowIfCancellationRequested();
                    if (setIds.Remove(MagicTradition.InternalId))
                    {
                        lstReturn.Add(MagicTradition);
                        if (setIds.Count == 0)
                            return lstReturn;
                    }

                    if (!blnOnlyValidImprovementSources)
                    {
                        await Vehicles.ForEachWithBreakAsync(async objVehicle =>
                        {
                            if (setIds.Remove(objVehicle.InternalId))
                            {
                                lstReturn.Add(objVehicle);
                                if (setIds.Count == 0)
                                    return false;
                            }
                            await (await objVehicle.GearChildren.GetAllDescendantsAsync(x => x.Children, token)).ForEachWithBreakAsync(x =>
                            {
                                if (setIds.Remove(x.InternalId))
                                {
                                    lstReturn.Add(x);
                                    if (setIds.Count == 0)
                                        return false;
                                }
                                return true;
                            }, token).ConfigureAwait(false);
                            if (setIds.Count == 0)
                                return false;
                            await (await objVehicle.Weapons.GetAllDescendantsAsync(x => x.Children, token)).ForEachWithBreakAsync(async objWeapon =>
                            {
                                if (setIds.Remove(objWeapon.InternalId))
                                {
                                    lstReturn.Add(objWeapon);
                                    if (setIds.Count == 0)
                                        return false;
                                }
                                await objWeapon.WeaponAccessories.ForEachWithBreakAsync(async objMod =>
                                {
                                    if (setIds.Remove(objMod.InternalId))
                                    {
                                        lstReturn.Add(objMod);
                                        if (setIds.Count == 0)
                                            return false;
                                    }
                                    await (await objMod.GearChildren.GetAllDescendantsAsync(x => x.Children, token)).ForEachWithBreakAsync(x =>
                                    {
                                        if (setIds.Remove(x.InternalId))
                                        {
                                            lstReturn.Add(x);
                                            if (setIds.Count == 0)
                                                return false;
                                        }
                                        return true;
                                    }, token).ConfigureAwait(false);
                                    return setIds.Count > 0;
                                }, token).ConfigureAwait(false);
                                return setIds.Count > 0;
                            }, token).ConfigureAwait(false);
                            if (setIds.Count == 0)
                                return false;
                            await objVehicle.Mods.ForEachWithBreakAsync(async objMod =>
                            {
                                if (setIds.Remove(objMod.InternalId))
                                {
                                    lstReturn.Add(objMod);
                                    if (setIds.Count == 0)
                                        return false;
                                }
                                await (await objMod.Cyberware.GetAllDescendantsAsync(x => x.Children, token)).ForEachWithBreakAsync(async objCyberware =>
                                {
                                    if (setIds.Remove(objCyberware.InternalId))
                                    {
                                        lstReturn.Add(objCyberware);
                                        if (setIds.Count == 0)
                                            return false;
                                    }
                                    await (await objCyberware.GearChildren.GetAllDescendantsAsync(x => x.Children, token)).ForEachWithBreakAsync(x =>
                                    {
                                        if (setIds.Remove(x.InternalId))
                                        {
                                            lstReturn.Add(x);
                                            if (setIds.Count == 0)
                                                return false;
                                        }
                                        return true;
                                    }, token).ConfigureAwait(false);
                                    return setIds.Count > 0;
                                }, token).ConfigureAwait(false);
                                return setIds.Count > 0;
                            }, token).ConfigureAwait(false);
                            if (setIds.Count == 0)
                                return false;
                            await objVehicle.WeaponMounts.ForEachWithBreakAsync(async objMount =>
                            {
                                if (setIds.Remove(objMount.InternalId))
                                {
                                    lstReturn.Add(objMount);
                                    if (setIds.Count == 0)
                                        return false;
                                }
                                await objMount.WeaponMountOptions.ForEachWithBreakAsync(objOption =>
                                {
                                    token.ThrowIfCancellationRequested();
                                    if (setIds.Remove(objOption.InternalId))
                                    {
                                        lstReturn.Add(objOption);
                                        if (setIds.Count == 0)
                                            return false;
                                    }
                                    return true;
                                }, token).ConfigureAwait(false);
                                if (setIds.Count == 0)
                                    return false;
                                await (await objMount.Weapons.GetAllDescendantsAsync(x => x.Children, token)).ForEachWithBreakAsync(async objWeapon =>
                                {
                                    if (setIds.Remove(objWeapon.InternalId))
                                    {
                                        lstReturn.Add(objWeapon);
                                        if (setIds.Count == 0)
                                            return false;
                                    }
                                    await objWeapon.WeaponAccessories.ForEachWithBreakAsync(async objMod =>
                                    {
                                        if (setIds.Remove(objMod.InternalId))
                                        {
                                            lstReturn.Add(objMod);
                                            if (setIds.Count == 0)
                                                return false;
                                        }
                                        await (await objMod.GearChildren.GetAllDescendantsAsync(x => x.Children, token)).ForEachWithBreakAsync(x =>
                                        {
                                            if (setIds.Remove(x.InternalId))
                                            {
                                                lstReturn.Add(x);
                                                if (setIds.Count == 0)
                                                    return false;
                                            }
                                            return true;
                                        }, token).ConfigureAwait(false);
                                        return setIds.Count > 0;
                                    }, token).ConfigureAwait(false);
                                    return setIds.Count > 0;
                                }, token).ConfigureAwait(false);
                                if (setIds.Count == 0)
                                    return false;
                                await objMount.Mods.ForEachWithBreakAsync(async objMod =>
                                {
                                    if (setIds.Remove(objMod.InternalId))
                                    {
                                        lstReturn.Add(objMod);
                                        if (setIds.Count == 0)
                                            return false;
                                    }
                                    await (await objMod.Cyberware.GetAllDescendantsAsync(x => x.Children, token)).ForEachWithBreakAsync(async objCyberware =>
                                    {
                                        if (setIds.Remove(objCyberware.InternalId))
                                        {
                                            lstReturn.Add(objCyberware);
                                            if (setIds.Count == 0)
                                                return false;
                                        }
                                        await (await objCyberware.GearChildren.GetAllDescendantsAsync(x => x.Children, token)).ForEachWithBreakAsync(x =>
                                        {
                                            if (setIds.Remove(x.InternalId))
                                            {
                                                lstReturn.Add(x);
                                                if (setIds.Count == 0)
                                                    return false;
                                            }
                                            return true;
                                        }, token).ConfigureAwait(false);
                                        return setIds.Count > 0;
                                    }, token).ConfigureAwait(false);
                                    return setIds.Count > 0;
                                }, token).ConfigureAwait(false);
                                return setIds.Count > 0;
                            }, token).ConfigureAwait(false);
                            return setIds.Count > 0;
                        }, token).ConfigureAwait(false);
                        if (setIds.Count == 0)
                            return lstReturn;

                        await SkillsSection.Skills.ForEachWithBreakAsync(async objSkill =>
                        {
                            token.ThrowIfCancellationRequested();
                            if (setIds.Remove(objSkill.InternalId))
                            {
                                lstReturn.Add(objSkill);
                                if (setIds.Count == 0)
                                    return false;
                            }
                            await objSkill.Specializations.ForEachWithBreakAsync(x =>
                            {
                                if (setIds.Remove(x.InternalId))
                                {
                                    lstReturn.Add(x);
                                    if (setIds.Count == 0)
                                        return false;
                                }
                                return true;
                            }, token).ConfigureAwait(false);
                            return setIds.Count > 0;
                        }, token).ConfigureAwait(false);
                        if (setIds.Count == 0)
                            return lstReturn;
                        await SkillsSection.SkillGroups.ForEachWithBreakAsync(x =>
                        {
                            if (setIds.Remove(x.InternalId))
                            {
                                lstReturn.Add(x);
                                if (setIds.Count == 0)
                                    return false;
                            }
                            return true;
                        }, token).ConfigureAwait(false);
                        if (setIds.Count == 0)
                            return lstReturn;
                        await SkillsSection.KnowledgeSkills.ForEachWithBreakAsync(async objSkill =>
                        {
                            token.ThrowIfCancellationRequested();
                            if (setIds.Remove(objSkill.InternalId))
                            {
                                lstReturn.Add(objSkill);
                                if (setIds.Count == 0)
                                    return false;
                            }
                            await objSkill.Specializations.ForEachWithBreakAsync(x =>
                            {
                                if (setIds.Remove(x.InternalId))
                                {
                                    lstReturn.Add(x);
                                    if (setIds.Count == 0)
                                        return false;
                                }
                                return true;
                            }, token).ConfigureAwait(false);
                            return setIds.Count > 0;
                        }, token).ConfigureAwait(false);
                        if (setIds.Count == 0)
                            return lstReturn;
                        await Contacts.ForEachWithBreakAsync(x =>
                        {
                            if (setIds.Remove(x.InternalId))
                            {
                                lstReturn.Add(x);
                                if (setIds.Count == 0)
                                    return false;
                            }
                            return true;
                        }, token).ConfigureAwait(false);
                        if (setIds.Count == 0)
                            return lstReturn;
                        await Spirits.ForEachWithBreakAsync(x =>
                        {
                            if (setIds.Remove(x.InternalId))
                            {
                                lstReturn.Add(x);
                                if (setIds.Count == 0)
                                    return false;
                            }
                            return true;
                        }, token).ConfigureAwait(false);
                        if (setIds.Count == 0)
                            return lstReturn;

                        await AIPrograms.ForEachWithBreakAsync(x =>
                        {
                            if (setIds.Remove(x.InternalId))
                            {
                                lstReturn.Add(x);
                                if (setIds.Count == 0)
                                    return false;
                            }
                            return true;
                        }, token).ConfigureAwait(false);
                        if (setIds.Count == 0)
                            return lstReturn;
                        await Calendar.ForEachWithBreakAsync(x =>
                        {
                            if (setIds.Remove(x.InternalId))
                            {
                                lstReturn.Add(x);
                                if (setIds.Count == 0)
                                    return false;
                            }
                            return true;
                        }, token).ConfigureAwait(false);
                        if (setIds.Count == 0)
                            return lstReturn;
                        await ComplexForms.ForEachWithBreakAsync(x =>
                        {
                            if (setIds.Remove(x.InternalId))
                            {
                                lstReturn.Add(x);
                                if (setIds.Count == 0)
                                    return false;
                            }
                            return true;
                        }, token).ConfigureAwait(false);
                        if (setIds.Count == 0)
                            return lstReturn;
                        await ExpenseEntries.ForEachWithBreakAsync(x =>
                        {
                            if (setIds.Remove(x.InternalId))
                            {
                                lstReturn.Add(x);
                                if (setIds.Count == 0)
                                    return false;
                            }
                            return true;
                        }, token).ConfigureAwait(false);
                        if (setIds.Count == 0)
                            return lstReturn;
                        await Foci.ForEachWithBreakAsync(x =>
                        {
                            if (setIds.Remove(x.InternalId))
                            {
                                lstReturn.Add(x);
                                if (setIds.Count == 0)
                                    return false;
                            }
                            return true;
                        }, token).ConfigureAwait(false);
                        if (setIds.Count == 0)
                            return lstReturn;
                        await Spells.ForEachWithBreakAsync(x =>
                        {
                            if (setIds.Remove(x.InternalId))
                            {
                                lstReturn.Add(x);
                                if (setIds.Count == 0)
                                    return false;
                            }
                            return true;
                        }, token).ConfigureAwait(false);
                        if (setIds.Count == 0)
                            return lstReturn;
                        await SustainedCollection.ForEachWithBreakAsync(x =>
                        {
                            if (setIds.Remove(x.InternalId))
                            {
                                lstReturn.Add(x);
                                if (setIds.Count == 0)
                                    return false;
                            }
                            return true;
                        }, token).ConfigureAwait(false);
                        if (setIds.Count == 0)
                            return lstReturn;
                    }
                    return lstReturn;
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
        }

        /// <summary>
        /// Retrieve the name of the Object that created an Improvement.
        /// </summary>
        /// <param name="objImprovement">Improvement to check.</param>
        /// <param name="strLanguage">Language in which to fetch name.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public string GetObjectName(Improvement objImprovement, string strLanguage = "", CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (objImprovement == null)
                return string.Empty;
            if (string.IsNullOrEmpty(strLanguage))
                strLanguage = GlobalSettings.Language;
            string strSpace = LanguageManager.GetString("String_Space", strLanguage, token: token);
            string strImprovedSourceName = objImprovement.SourceName.TrimEndOnce("Pair");
            bool blnWireless = false;

            if (strImprovedSourceName.EndsWith("Wireless", StringComparison.Ordinal))
            {
                blnWireless = true;
                strImprovedSourceName = strImprovedSourceName.TrimEndOnce("Wireless", true);
            }

            Improvement.ImprovementSource eSource = objImprovement.ImproveSource;
            using (LockObject.EnterReadLock(token))
            {
                switch (eSource)
                {
                    case Improvement.ImprovementSource.Bioware:
                    case Improvement.ImprovementSource.Cyberware:
                        {
                            Cyberware objCyberware = Cyberware.DeepFirstOrDefault(x => x.Children,
                                                                                  x => x.InternalId == strImprovedSourceName
                                                                                      && x.SourceType == eSource, token);
                            if (objCyberware != null)
                            {
                                string strWareReturn = objCyberware.DisplayNameShort(strLanguage);
                                if (objCyberware.Parent != null)
                                    strWareReturn += strSpace + "(" + objCyberware.Parent.DisplayNameShort(strLanguage)
                                                     + ")";
                                if (blnWireless)
                                    strWareReturn += strSpace + LanguageManager.GetString("String_Wireless", strLanguage, token: token);
                                return strWareReturn;
                            }

                            foreach (Vehicle objVehicle in Vehicles)
                            {
                                foreach (VehicleMod objVehicleMod in objVehicle.Mods)
                                {
                                    objCyberware = objVehicleMod.Cyberware.DeepFirstOrDefault(x => x.Children,
                                        x => x.InternalId == strImprovedSourceName, token);
                                    if (objCyberware != null)
                                    {
                                        string strWareReturn
                                            = objCyberware.DisplayNameShort(strLanguage) + strSpace + "("
                                              + objVehicle.DisplayNameShort(strLanguage) + ","
                                              + strSpace + objVehicleMod.DisplayNameShort(strLanguage);
                                        if (objCyberware.Parent != null)
                                            strWareReturn += "," + strSpace
                                                                 + objCyberware.Parent.DisplayNameShort(strLanguage);
                                        strWareReturn += ")";
                                        if (blnWireless)
                                            strWareReturn
                                                += strSpace + LanguageManager.GetString("String_Wireless", strLanguage, token: token);
                                        return strWareReturn;
                                    }
                                }

                                foreach (WeaponMount objMount in objVehicle.WeaponMounts)
                                {
                                    foreach (VehicleMod objVehicleMod in objMount.Mods)
                                    {
                                        objCyberware = objVehicleMod.Cyberware.DeepFirstOrDefault(x => x.Children,
                                            x => x.InternalId == strImprovedSourceName, token);
                                        if (objCyberware != null)
                                        {
                                            string strWareReturn
                                                = objCyberware.DisplayNameShort(strLanguage) + strSpace + "("
                                                  + objVehicle.DisplayNameShort(strLanguage) + "," + strSpace
                                                  + objMount.DisplayNameShort(strLanguage) + ","
                                                  + strSpace + objVehicleMod.DisplayNameShort(strLanguage);
                                            if (objCyberware.Parent != null)
                                                strWareReturn += "," + strSpace
                                                                     + objCyberware.Parent.DisplayNameShort(strLanguage);
                                            strWareReturn += ")";
                                            if (blnWireless)
                                                strWareReturn += strSpace
                                                                 + LanguageManager.GetString(
                                                                     "String_Wireless", strLanguage, token: token);
                                            return strWareReturn;
                                        }
                                    }
                                }
                            }

                            break;
                        }
                    case Improvement.ImprovementSource.Gear:
                        {
                            Gear objReturnGear =
                                Gear.DeepFirstOrDefault(x => x.Children, x => x.InternalId == strImprovedSourceName, token);
                            if (objReturnGear != null)
                            {
                                string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                                if (objReturnGear.Parent is Gear parent)
                                    strGearReturn += strSpace + "(" + parent.DisplayNameShort(strLanguage) + ")";
                                if (blnWireless)
                                    strGearReturn += strSpace + LanguageManager.GetString("String_Wireless", strLanguage, token: token);
                                return strGearReturn;
                            }

                            objReturnGear
                                = Weapons.FindWeaponGear(strImprovedSourceName, out WeaponAccessory objGearAccessory, token);

                            if (objReturnGear != null)
                            {
                                string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                                if (objReturnGear.Parent is Gear parent)
                                    strGearReturn += strSpace + "(" + objGearAccessory.Parent.DisplayNameShort(strLanguage)
                                                     + ","
                                                     + strSpace
                                                     + objGearAccessory.DisplayNameShort(strLanguage) + "," + strSpace
                                                     + parent.DisplayNameShort(strLanguage) + ")";
                                else
                                    strGearReturn += strSpace + "(" + objGearAccessory.Parent.DisplayNameShort(strLanguage)
                                                     + ","
                                                     + strSpace + objGearAccessory.DisplayNameShort(strLanguage) + ")";
                                if (blnWireless)
                                    strGearReturn
                                        += strSpace + LanguageManager.GetString("String_Wireless", strLanguage, token: token);
                                return strGearReturn;
                            }

                            objReturnGear
                                = Armor.FindArmorGear(strImprovedSourceName, out Armor objArmor, out ArmorMod objArmorMod, token);
                            if (objReturnGear != null)
                            {
                                string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                                if (objReturnGear.Parent is Gear objParent)
                                {
                                    strGearReturn += strSpace + "(" + objArmor.DisplayNameShort(strLanguage, token) + ","
                                                     + strSpace
                                                     + objArmorMod.DisplayNameShort(strLanguage) + "," + strSpace
                                                     + objParent.DisplayNameShort(strLanguage) + ")";
                                }
                                else if (objArmorMod != null)
                                    strGearReturn += strSpace + "(" + objArmor.DisplayNameShort(strLanguage, token) + ","
                                                     + strSpace
                                                     + objArmorMod.DisplayNameShort(strLanguage) + ")";
                                else
                                    strGearReturn += strSpace + "(" + objArmor.DisplayNameShort(strLanguage, token) + ")";

                                if (blnWireless)
                                    strGearReturn += strSpace + LanguageManager.GetString("String_Wireless", strLanguage, token: token);
                                return strGearReturn;
                            }

                            objReturnGear
                                = Cyberware.FindCyberwareGear(strImprovedSourceName, out Cyberware objGearCyberware, token);

                            if (objReturnGear != null)
                            {
                                string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                                if (objReturnGear.Parent is Gear parent)
                                    strGearReturn += strSpace + "(" + objGearCyberware.DisplayNameShort(strLanguage) + ","
                                                     + strSpace
                                                     + strSpace + parent.DisplayNameShort(strLanguage) + ")";
                                else
                                    strGearReturn += strSpace + "(" + objGearCyberware.DisplayNameShort(strLanguage) + ")";
                                if (blnWireless)
                                    strGearReturn += strSpace + LanguageManager.GetString("String_Wireless", strLanguage, token: token);
                                return strGearReturn;
                            }

                            foreach (Vehicle objVehicle in Vehicles)
                            {
                                objReturnGear = objVehicle.GearChildren.DeepFirstOrDefault(x => x.Children,
                                    x => x.InternalId == strImprovedSourceName, token);
                                if (objReturnGear != null)
                                {
                                    string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                                    if (objReturnGear.Parent is Gear parent)
                                        strGearReturn += strSpace + "(" + objVehicle.DisplayNameShort(strLanguage) + ","
                                                         + strSpace
                                                         + strSpace + parent.DisplayNameShort(strLanguage) + ")";
                                    else
                                        strGearReturn += strSpace + "(" + objVehicle.DisplayNameShort(strLanguage) + ")";
                                    if (blnWireless)
                                        strGearReturn
                                            += strSpace + LanguageManager.GetString("String_Wireless", strLanguage, token: token);
                                    return strGearReturn;
                                }

                                foreach (Weapon objWeapon in objVehicle.Weapons.DeepWhere(x => x.Children,
                                             x => x.WeaponAccessories.Any(y => y.GearChildren.Count > 0, token), token))
                                {
                                    foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                                    {
                                        objReturnGear = objAccessory.GearChildren.DeepFirstOrDefault(x => x.Children,
                                            x => x.InternalId == strImprovedSourceName, token);
                                        if (objReturnGear != null)
                                        {
                                            string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                                            if (objReturnGear.Parent is Gear parent)
                                                strGearReturn
                                                    += strSpace + "(" + objVehicle.DisplayNameShort(strLanguage) + ","
                                                       + strSpace
                                                       + objWeapon.DisplayNameShort(strLanguage) + "," + strSpace
                                                       + objAccessory.DisplayNameShort(strLanguage) + ","
                                                       + strSpace + parent.DisplayNameShort(strLanguage) + ")";
                                            else
                                                strGearReturn
                                                    += strSpace + "(" + objVehicle.DisplayNameShort(strLanguage) + ","
                                                       + strSpace
                                                       + objWeapon.DisplayNameShort(strLanguage) + "," + strSpace
                                                       + objAccessory.DisplayNameShort(strLanguage) + ")";
                                            if (blnWireless)
                                                strGearReturn += strSpace
                                                                 + LanguageManager.GetString(
                                                                     "String_Wireless", strLanguage, token: token);
                                            return strGearReturn;
                                        }
                                    }
                                }

                                foreach (VehicleMod objVehicleMod in objVehicle.Mods)
                                {
                                    foreach (Weapon objWeapon in objVehicleMod.Weapons.DeepWhere(x => x.Children,
                                                 x => x.WeaponAccessories.Any(y => y.GearChildren.Count > 0, token), token))
                                    {
                                        foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                                        {
                                            objReturnGear = objAccessory.GearChildren.DeepFirstOrDefault(x => x.Children,
                                                x => x.InternalId == strImprovedSourceName, token);
                                            if (objReturnGear != null)
                                            {
                                                string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                                                if (objReturnGear.Parent is Gear parent)
                                                    strGearReturn
                                                        += strSpace + "(" + objVehicle.DisplayNameShort(strLanguage) + ","
                                                           + strSpace + objVehicleMod.DisplayNameShort(strLanguage)
                                                           + "," + strSpace + objWeapon.DisplayNameShort(strLanguage) + ","
                                                           + strSpace + objAccessory.DisplayNameShort(strLanguage)
                                                           + "," + strSpace + parent.DisplayNameShort(strLanguage) + ")";
                                                else
                                                    strGearReturn
                                                        += strSpace + "(" + objVehicle.DisplayNameShort(strLanguage) + ","
                                                           + strSpace + objVehicleMod.DisplayNameShort(strLanguage)
                                                           + "," + strSpace + objWeapon.DisplayNameShort(strLanguage) + ","
                                                           + strSpace + objAccessory.DisplayNameShort(strLanguage) + ")";
                                                if (blnWireless)
                                                    strGearReturn += strSpace
                                                                     + LanguageManager.GetString(
                                                                         "String_Wireless", strLanguage, token: token);
                                                return strGearReturn;
                                            }
                                        }
                                    }

                                    foreach (Cyberware objCyberware in objVehicleMod.Cyberware.DeepWhere(x => x.Children,
                                                 x => x.GearChildren.Count > 0, token))
                                    {
                                        objReturnGear = objCyberware.GearChildren.DeepFirstOrDefault(x => x.Children,
                                            x => x.InternalId == strImprovedSourceName, token);
                                        if (objReturnGear != null)
                                        {
                                            string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                                            if (objReturnGear.Parent is Gear parent)
                                                strGearReturn
                                                    += strSpace + "(" + objVehicle.DisplayNameShort(strLanguage) + ","
                                                       + strSpace + objVehicleMod.DisplayNameShort(strLanguage)
                                                       + "," + strSpace + objCyberware.DisplayNameShort(strLanguage) + ","
                                                       + strSpace + parent.DisplayNameShort(strLanguage) + ")";
                                            else
                                                strGearReturn
                                                    += strSpace + "(" + objVehicle.DisplayNameShort(strLanguage) + ","
                                                       + strSpace + objVehicleMod.DisplayNameShort(strLanguage)
                                                       + "," + strSpace + objCyberware.DisplayNameShort(strLanguage) + ")";
                                            if (blnWireless)
                                                strGearReturn += strSpace
                                                                 + LanguageManager.GetString(
                                                                     "String_Wireless", strLanguage, token: token);
                                            return strGearReturn;
                                        }
                                    }
                                }

                                foreach (WeaponMount objMount in objVehicle.WeaponMounts)
                                {
                                    foreach (VehicleMod objVehicleMod in objMount.Mods)
                                    {
                                        foreach (Weapon objWeapon in objVehicleMod.Weapons.DeepWhere(x => x.Children,
                                                     x => x.WeaponAccessories.Any(y => y.GearChildren.Count > 0, token), token))
                                        {
                                            foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                                            {
                                                objReturnGear = objAccessory.GearChildren.DeepFirstOrDefault(
                                                    x => x.Children,
                                                    x => x.InternalId == strImprovedSourceName, token);
                                                if (objReturnGear != null)
                                                {
                                                    string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                                                    if (objReturnGear.Parent is Gear parent)
                                                        strGearReturn
                                                            += strSpace + "(" + objVehicle.DisplayNameShort(strLanguage)
                                                               + ","
                                                               + strSpace + objMount.DisplayNameShort(strLanguage) + ","
                                                               + strSpace + objVehicleMod.DisplayNameShort(strLanguage)
                                                               + "," + strSpace + objWeapon.DisplayNameShort(strLanguage)
                                                               + ","
                                                               + strSpace + objAccessory.DisplayNameShort(strLanguage)
                                                               + "," + strSpace + parent.DisplayNameShort(strLanguage)
                                                               + ")";
                                                    else
                                                        strGearReturn
                                                            += strSpace + "(" + objVehicle.DisplayNameShort(strLanguage)
                                                               + ","
                                                               + strSpace + objMount.DisplayNameShort(strLanguage) + ","
                                                               + strSpace + objVehicleMod.DisplayNameShort(strLanguage)
                                                               + "," + strSpace + objWeapon.DisplayNameShort(strLanguage)
                                                               + ","
                                                               + strSpace + objAccessory.DisplayNameShort(strLanguage)
                                                               + ")";
                                                    if (blnWireless)
                                                        strGearReturn += strSpace
                                                                         + LanguageManager.GetString(
                                                                             "String_Wireless", strLanguage, token: token);
                                                    return strGearReturn;
                                                }
                                            }
                                        }

                                        foreach (Cyberware objCyberware in objVehicleMod.Cyberware.DeepWhere(
                                                     x => x.Children,
                                                     x => x.GearChildren.Count > 0, token))
                                        {
                                            objReturnGear = objCyberware.GearChildren.DeepFirstOrDefault(x => x.Children,
                                                x => x.InternalId == strImprovedSourceName, token);
                                            if (objReturnGear != null)
                                            {
                                                string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                                                if (objReturnGear.Parent is Gear parent)
                                                    strGearReturn
                                                        += strSpace + "(" + objVehicle.DisplayNameShort(strLanguage) + ","
                                                           + strSpace + objMount.DisplayNameShort(strLanguage) + ","
                                                           + strSpace
                                                           + objVehicleMod.DisplayNameShort(strLanguage)
                                                           + "," + strSpace + objCyberware.DisplayNameShort(strLanguage)
                                                           + ","
                                                           + strSpace + parent.DisplayNameShort(strLanguage) + ")";
                                                else
                                                    strGearReturn
                                                        += strSpace + "(" + objVehicle.DisplayNameShort(strLanguage) + ","
                                                           + strSpace + objMount.DisplayNameShort(strLanguage) + ","
                                                           + strSpace
                                                           + objVehicleMod.DisplayNameShort(strLanguage)
                                                           + "," + strSpace + objCyberware.DisplayNameShort(strLanguage)
                                                           + ")";
                                                if (blnWireless)
                                                    strGearReturn += strSpace
                                                                     + LanguageManager.GetString(
                                                                         "String_Wireless", strLanguage, token: token);
                                                return strGearReturn;
                                            }
                                        }
                                    }
                                }
                            }

                            break;
                        }
                    case Improvement.ImprovementSource.Spell:
                        foreach (Spell objSpell in Spells)
                        {
                            if (objSpell.InternalId == strImprovedSourceName)
                            {
                                return objSpell.DisplayNameShort(strLanguage);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.Power:
                        foreach (Power objPower in Powers)
                        {
                            if (objPower.InternalId == strImprovedSourceName)
                            {
                                return objPower.DisplayNameShort(strLanguage);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.CritterPower:
                        foreach (CritterPower objPower in CritterPowers)
                        {
                            if (objPower.InternalId == strImprovedSourceName)
                            {
                                return objPower.DisplayNameShort(strLanguage);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.Metamagic:
                        foreach (Metamagic objMetamagic in Metamagics)
                        {
                            if (objMetamagic.InternalId == strImprovedSourceName
                                && objMetamagic.SourceType == Improvement.ImprovementSource.Metamagic)
                            {
                                return objMetamagic.DisplayNameShort(strLanguage);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.Echo:
                        foreach (Metamagic objMetamagic in Metamagics)
                        {
                            if (objMetamagic.InternalId == strImprovedSourceName
                                && objMetamagic.SourceType == Improvement.ImprovementSource.Echo)
                            {
                                return objMetamagic.DisplayNameShort(strLanguage);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.Art:
                        foreach (Art objArt in Arts)
                        {
                            if (objArt.InternalId == strImprovedSourceName)
                            {
                                return objArt.DisplayNameShort(strLanguage);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.Enhancement:
                        foreach (Enhancement objEnhancement in Enhancements)
                        {
                            if (objEnhancement.InternalId == strImprovedSourceName)
                            {
                                return objEnhancement.DisplayNameShort(strLanguage);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.Armor:
                        {
                            foreach (Armor objArmor in Armor)
                            {
                                if (objArmor.InternalId == strImprovedSourceName)
                                {
                                    string strReturnArmor = objArmor.DisplayNameShort(strLanguage, token);
                                    if (blnWireless)
                                        strReturnArmor
                                            += strSpace + LanguageManager.GetString("String_Wireless", strLanguage, token: token);
                                    return strReturnArmor;
                                }
                            }

                            break;
                        }
                    case Improvement.ImprovementSource.ArmorMod:
                        {
                            foreach (Armor objArmor in Armor)
                            {
                                foreach (ArmorMod objMod in objArmor.ArmorMods)
                                {
                                    if (objMod.InternalId == strImprovedSourceName)
                                    {
                                        string strReturnArmorMod = objMod.DisplayNameShort(strLanguage) + strSpace + "("
                                                                   + objArmor.DisplayNameShort(strLanguage, token) + ")";
                                        if (blnWireless)
                                            strReturnArmorMod
                                                += strSpace + LanguageManager.GetString("String_Wireless", strLanguage, token: token);
                                        return strReturnArmorMod;
                                    }
                                }
                            }

                            break;
                        }
                    case Improvement.ImprovementSource.ComplexForm:
                        foreach (ComplexForm objComplexForm in ComplexForms)
                        {
                            if (objComplexForm.InternalId == strImprovedSourceName)
                            {
                                return objComplexForm.DisplayNameShort(strLanguage);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.AIProgram:
                        foreach (AIProgram objProgram in AIPrograms)
                        {
                            if (objProgram.InternalId == strImprovedSourceName)
                            {
                                return objProgram.DisplayNameShort(strLanguage);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.Quality:
                        {
                            if (strImprovedSourceName.StartsWith("SEEKER", StringComparison.Ordinal))
                            {
                                string strReturn = string.Empty;
                                if (GlobalSettings.Language != GlobalSettings.DefaultLanguage)
                                {
                                    strReturn = LoadDataXPath("qualities.xml", token: token)
                                                .SelectSingleNodeAndCacheExpression(
                                                    strImprovedSourceName == "SEEKER_WIL"
                                                        ? "/chummer/qualities/quality[name = \"Cyber-Singularity Seeker\"]/translate"
                                                        : "/chummer/qualities/quality[name = \"Redliner\"]/translate", token)
                                                ?.Value;
                                }

                                if (string.IsNullOrEmpty(strReturn))
                                    strReturn = strImprovedSourceName == "SEEKER_WIL"
                                        ? "Cyber-Singularity Seeker"
                                        : "Redliner";
                                return strReturn;
                            }

                            foreach (Quality objQuality in Qualities)
                            {
                                if (objQuality.InternalId == strImprovedSourceName)
                                {
                                    return objQuality.DisplayNameShort(strLanguage);
                                }
                            }

                            break;
                        }

                    case Improvement.ImprovementSource.MartialArtTechnique:
                        foreach (MartialArtTechnique objTechnique in MartialArts.SelectMany(x => x.Techniques))
                        {
                            if (objTechnique.InternalId == strImprovedSourceName)
                            {
                                return objTechnique.DisplayName(strLanguage);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.MentorSpirit:
                        foreach (MentorSpirit objMentorSpirit in MentorSpirits)
                        {
                            if (objMentorSpirit.InternalId == strImprovedSourceName)
                            {
                                return objMentorSpirit.DisplayNameShort(strLanguage);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.Heritage:
                        return LanguageManager.GetString("String_Priority", strLanguage, token: token);

                    case Improvement.ImprovementSource.Initiation:
                        return LanguageManager.GetString("Tab_Initiation", strLanguage, token: token);

                    case Improvement.ImprovementSource.Submersion:
                        return LanguageManager.GetString("Tab_Submersion", strLanguage, token: token);

                    case Improvement.ImprovementSource.Encumbrance:
                        return LanguageManager.GetString("String_Encumbrance", strLanguage, token: token);

                    case Improvement.ImprovementSource.ArmorEncumbrance:
                        return LanguageManager.GetString("String_ArmorEncumbrance", strLanguage, token: token);

                    case Improvement.ImprovementSource.Tradition:
                        return LanguageManager.GetString("String_Tradition", strLanguage, token: token);

                    case Improvement.ImprovementSource.AstralReputation:
                        return LanguageManager.GetString("String_AstralReputation", strLanguage, token: token);

                    case Improvement.ImprovementSource.CyberadeptDaemon:
                        return LoadDataXPath("qualities.xml", strLanguage, token: token)
                               .SelectSingleNode(
                                   "/chummer/qualities/quality[name = \"Resonant Stream: Cyberadept\"]/translate")
                               ?.Value ?? "Resonant Stream: Cyberadept";

                    default:
                        {
                            if (objImprovement.ImproveType == Improvement.ImprovementType.ArmorEncumbrancePenalty)
                                return LanguageManager.GetString("String_ArmorEncumbrance", strLanguage, token: token);
                            // If this comes from a custom Improvement, use the name the player gave it instead of showing a GUID.
                            if (!string.IsNullOrEmpty(objImprovement.CustomName))
                                return objImprovement.CustomName;
                            string strReturn = strImprovedSourceName;
                            if (string.IsNullOrEmpty(strReturn) || strReturn.IsGuid())
                            {
                                string strTemp = LanguageManager.GetString("String_" + objImprovement.ImproveSource,
                                                                           strLanguage, false, token: token);
                                if (!string.IsNullOrEmpty(strTemp))
                                    strReturn = strTemp;
                            }

                            return strReturn;
                        }
                }
            }

            return string.Empty;
        }

        /// <summary>
        /// Retrieve the name of the Object that created an Improvement.
        /// </summary>
        /// <param name="objImprovement">Improvement to check.</param>
        /// <param name="strLanguage">Language in which to fetch name.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public async Task<string> GetObjectNameAsync(Improvement objImprovement, string strLanguage = "", CancellationToken token = default)
        {
            if (objImprovement == null)
                return string.Empty;
            if (string.IsNullOrEmpty(strLanguage))
                strLanguage = GlobalSettings.Language;
            string strSpace = await LanguageManager.GetStringAsync("String_Space", strLanguage, token: token).ConfigureAwait(false);
            string strImprovedSourceName = objImprovement.SourceName.TrimEndOnce("Pair");
            bool blnWireless = false;

            if (strImprovedSourceName.EndsWith("Wireless", StringComparison.Ordinal))
            {
                blnWireless = true;
                strImprovedSourceName = strImprovedSourceName.TrimEndOnce("Wireless", true);
            }

            Improvement.ImprovementSource eSource = objImprovement.ImproveSource;
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                switch (eSource)
                {
                    case Improvement.ImprovementSource.Bioware:
                    case Improvement.ImprovementSource.Cyberware:
                        {
                            string strWareReturn = string.Empty;
                            Cyberware objCyberware = await (await GetCyberwareAsync(token).ConfigureAwait(false)).DeepFirstOrDefaultAsync(x => x.GetChildrenAsync(token),
                                x => x.InternalId == strImprovedSourceName
                                     && x.SourceType == eSource, token).ConfigureAwait(false);
                            if (objCyberware != null)
                            {
                                strWareReturn = await objCyberware.DisplayNameShortAsync(strLanguage, token)
                                    .ConfigureAwait(false);
                                Cyberware objParent = await objCyberware.GetParentAsync(token).ConfigureAwait(false);
                                if (objParent != null)
                                    strWareReturn += strSpace + "(" + await objParent
                                                         .DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false)
                                                     + ")";
                                if (blnWireless)
                                    strWareReturn += strSpace + await LanguageManager
                                        .GetStringAsync(
                                            "String_Wireless", strLanguage, token: token)
                                        .ConfigureAwait(false);
                                return strWareReturn;
                            }

                            await Vehicles.ForEachWithBreakAsync(async objVehicle =>
                            {
                                await objVehicle.Mods.ForEachWithBreakAsync(async objVehicleMod =>
                                {
                                    objCyberware = await objVehicleMod.Cyberware.DeepFirstOrDefaultAsync(
                                        x => x.GetChildrenAsync(token),
                                        x => x.InternalId == strImprovedSourceName, token).ConfigureAwait(false);
                                    if (objCyberware != null)
                                    {
                                        strWareReturn
                                            = await objCyberware.DisplayNameShortAsync(strLanguage, token)
                                                  .ConfigureAwait(false) + strSpace + "("
                                              + await objVehicle.DisplayNameShortAsync(strLanguage, token)
                                                  .ConfigureAwait(false) + ","
                                              + strSpace + await objVehicleMod
                                                  .DisplayNameShortAsync(strLanguage, token: token)
                                                  .ConfigureAwait(false);
                                        Cyberware objParent = await objCyberware.GetParentAsync(token).ConfigureAwait(false);
                                        if (objParent != null)
                                            strWareReturn += "," + strSpace
                                                                 + await objParent
                                                                     .DisplayNameShortAsync(strLanguage, token)
                                                                     .ConfigureAwait(false);
                                        strWareReturn += ")";
                                        if (blnWireless)
                                            strWareReturn
                                                += strSpace + await LanguageManager
                                                    .GetStringAsync(
                                                        "String_Wireless", strLanguage, token: token)
                                                    .ConfigureAwait(false);
                                        return false;
                                    }

                                    return true;
                                }, token).ConfigureAwait(false);
                                if (!string.IsNullOrEmpty(strWareReturn))
                                    return false;

                                await objVehicle.WeaponMounts.ForEachWithBreakAsync(async objMount =>
                                {
                                    await objMount.Mods.ForEachWithBreakAsync(async objVehicleMod =>
                                    {
                                        objCyberware = await objVehicleMod.Cyberware.DeepFirstOrDefaultAsync(
                                            x => x.GetChildrenAsync(token),
                                            x => x.InternalId == strImprovedSourceName, token).ConfigureAwait(false);
                                        if (objCyberware != null)
                                        {
                                            strWareReturn
                                                = await objCyberware.DisplayNameShortAsync(strLanguage, token)
                                                      .ConfigureAwait(false) + strSpace + "("
                                                  + await objVehicle.DisplayNameShortAsync(strLanguage, token)
                                                      .ConfigureAwait(false) + "," + strSpace
                                                  + await objMount.DisplayNameShortAsync(strLanguage, token)
                                                      .ConfigureAwait(false) + ","
                                                  + strSpace + await objVehicleMod
                                                      .DisplayNameShortAsync(strLanguage, token)
                                                      .ConfigureAwait(false);
                                            Cyberware objParent = await objCyberware.GetParentAsync(token).ConfigureAwait(false);
                                            if (objParent != null)
                                                strWareReturn += "," + strSpace
                                                                     + await objParent
                                                                         .DisplayNameShortAsync(strLanguage, token)
                                                                         .ConfigureAwait(false);
                                            strWareReturn += ")";
                                            if (blnWireless)
                                                strWareReturn += strSpace
                                                                 + await LanguageManager.GetStringAsync(
                                                                         "String_Wireless", strLanguage, token: token)
                                                                     .ConfigureAwait(false);
                                            return false;
                                        }

                                        return true;
                                    }, token).ConfigureAwait(false);
                                    return string.IsNullOrEmpty(strWareReturn);
                                }, token).ConfigureAwait(false);
                                return string.IsNullOrEmpty(strWareReturn);
                            }, token).ConfigureAwait(false);

                            break;
                        }
                    case Improvement.ImprovementSource.Gear:
                        {
                            string strGearReturn = string.Empty;
                            Gear objReturnGear =
                                await Gear.DeepFirstOrDefaultAsync(x => x.Children,
                                    x => x.InternalId == strImprovedSourceName, token).ConfigureAwait(false);
                            if (objReturnGear != null)
                            {
                                strGearReturn = await objReturnGear.DisplayNameShortAsync(strLanguage, token: token)
                                    .ConfigureAwait(false);
                                if (objReturnGear.Parent is Gear parent)
                                    strGearReturn += strSpace + "(" +
                                                     await parent.DisplayNameShortAsync(strLanguage, token: token)
                                                         .ConfigureAwait(false) + ")";
                                if (blnWireless)
                                    strGearReturn += strSpace + await LanguageManager
                                        .GetStringAsync("String_Wireless", strLanguage, token: token).ConfigureAwait(false);
                                return strGearReturn;
                            }

                            WeaponAccessory objGearAccessory;
                            (objReturnGear, objGearAccessory)
                                = await Weapons.FindWeaponGearAsync(strImprovedSourceName, token).ConfigureAwait(false);

                            if (objReturnGear != null)
                            {
                                strGearReturn = await objReturnGear.DisplayNameShortAsync(strLanguage, token: token)
                                    .ConfigureAwait(false);
                                if (objReturnGear.Parent is Gear parent)
                                    strGearReturn += strSpace + "(" + await objGearAccessory.Parent
                                                         .DisplayNameShortAsync(strLanguage, token: token)
                                                         .ConfigureAwait(false)
                                                     + ","
                                                     + strSpace
                                                     + await objGearAccessory
                                                         .DisplayNameShortAsync(strLanguage, token: token)
                                                         .ConfigureAwait(false) + "," + strSpace
                                                     + await parent.DisplayNameShortAsync(strLanguage, token)
                                                         .ConfigureAwait(false) + ")";
                                else
                                    strGearReturn += strSpace + "(" + await objGearAccessory.Parent
                                                         .DisplayNameShortAsync(strLanguage, token: token)
                                                         .ConfigureAwait(false)
                                                     + ","
                                                     + strSpace + await objGearAccessory
                                                         .DisplayNameShortAsync(strLanguage, token: token)
                                                         .ConfigureAwait(false) + ")";
                                if (blnWireless)
                                    strGearReturn
                                        += strSpace + await LanguageManager
                                            .GetStringAsync("String_Wireless", strLanguage, token: token)
                                            .ConfigureAwait(false);
                                return strGearReturn;
                            }

                            Armor objArmor;
                            ArmorMod objArmorMod;
                            (objReturnGear, objArmor, objArmorMod)
                                = await Armor.FindArmorGearAsync(strImprovedSourceName, token).ConfigureAwait(false);
                            if (objReturnGear != null)
                            {
                                strGearReturn = await objReturnGear.DisplayNameShortAsync(strLanguage, token)
                                    .ConfigureAwait(false);
                                if (objReturnGear.Parent is Gear objParent)
                                {
                                    strGearReturn += strSpace + "(" +
                                                     await objArmor.DisplayNameShortAsync(strLanguage, token)
                                                         .ConfigureAwait(false) + ","
                                                     + strSpace
                                                     + await objArmorMod.DisplayNameShortAsync(strLanguage, token)
                                                         .ConfigureAwait(false) + "," + strSpace
                                                     + await objParent.DisplayNameShortAsync(strLanguage, token)
                                                         .ConfigureAwait(false) + ")";
                                }
                                else if (objArmorMod != null)
                                    strGearReturn += strSpace + "(" +
                                                     await objArmor.DisplayNameShortAsync(strLanguage, token)
                                                         .ConfigureAwait(false) + ","
                                                     + strSpace
                                                     + await objArmorMod.DisplayNameShortAsync(strLanguage, token)
                                                         .ConfigureAwait(false) + ")";
                                else
                                    strGearReturn += strSpace + "(" +
                                                     await objArmor.DisplayNameShortAsync(strLanguage, token)
                                                         .ConfigureAwait(false) + ")";

                                if (blnWireless)
                                    strGearReturn += strSpace + await LanguageManager
                                        .GetStringAsync("String_Wireless", strLanguage, token: token).ConfigureAwait(false);
                                return strGearReturn;
                            }

                            Cyberware objGearCyberware;
                            (objReturnGear, objGearCyberware)
                                = await Cyberware.FindCyberwareGearAsync(strImprovedSourceName, token).ConfigureAwait(false);

                            if (objReturnGear != null)
                            {
                                strGearReturn = await objReturnGear.DisplayNameShortAsync(strLanguage, token: token)
                                    .ConfigureAwait(false);
                                if (objReturnGear.Parent is Gear parent)
                                    strGearReturn += strSpace + "(" + await objGearCyberware
                                                         .DisplayNameShortAsync(strLanguage, token: token)
                                                         .ConfigureAwait(false) + ","
                                                     + strSpace
                                                     + strSpace +
                                                     await parent.DisplayNameShortAsync(strLanguage, token: token)
                                                         .ConfigureAwait(false) + ")";
                                else
                                    strGearReturn += strSpace + "(" + await objGearCyberware
                                        .DisplayNameShortAsync(strLanguage, token: token).ConfigureAwait(false) + ")";
                                if (blnWireless)
                                    strGearReturn += strSpace + await LanguageManager
                                        .GetStringAsync("String_Wireless", strLanguage, token: token).ConfigureAwait(false);
                                return strGearReturn;
                            }

                            await Vehicles.ForEachWithBreakAsync(async objVehicle =>
                            {
                                objReturnGear = await objVehicle.GearChildren.DeepFirstOrDefaultAsync(x => x.Children,
                                    x => x.InternalId == strImprovedSourceName, token).ConfigureAwait(false);
                                if (objReturnGear != null)
                                {
                                    strGearReturn = await objReturnGear.DisplayNameShortAsync(strLanguage, token: token)
                                        .ConfigureAwait(false);
                                    if (objReturnGear.Parent is Gear parent)
                                        strGearReturn
                                            += strSpace + "(" + await objVehicle
                                                   .DisplayNameShortAsync(strLanguage, token: token)
                                                   .ConfigureAwait(false) + ","
                                               + strSpace
                                               + strSpace + await parent
                                                   .DisplayNameShortAsync(strLanguage, token: token)
                                                   .ConfigureAwait(false) + ")";
                                    else
                                        strGearReturn += strSpace + "(" + await objVehicle
                                                             .DisplayNameShortAsync(strLanguage, token: token)
                                                             .ConfigureAwait(false)
                                                         + ")";
                                    if (blnWireless)
                                        strGearReturn
                                            += strSpace + await LanguageManager
                                                .GetStringAsync(
                                                    "String_Wireless", strLanguage, token: token)
                                                .ConfigureAwait(false);
                                    return false;
                                }

                                foreach (Weapon objWeapon in await objVehicle.Weapons.DeepWhereAsync(x => x.Children,
                                             x => x.WeaponAccessories.AnyAsync(
                                                 async y =>
                                                     await y.GearChildren.GetCountAsync(token).ConfigureAwait(false) > 0,
                                                 token),
                                             token).ConfigureAwait(false))
                                {
                                    await objWeapon.WeaponAccessories.ForEachWithBreakAsync(async objAccessory =>
                                    {
                                        objReturnGear = await objAccessory.GearChildren.DeepFirstOrDefaultAsync(
                                            x => x.Children,
                                            x => x.InternalId == strImprovedSourceName, token).ConfigureAwait(false);
                                        if (objReturnGear != null)
                                        {
                                            strGearReturn = await objReturnGear
                                                .DisplayNameShortAsync(strLanguage, token)
                                                .ConfigureAwait(false);
                                            if (objReturnGear.Parent is Gear parent)
                                                strGearReturn
                                                    += strSpace + "(" + await objVehicle
                                                           .DisplayNameShortAsync(strLanguage, token)
                                                           .ConfigureAwait(false) + ","
                                                       + strSpace
                                                       + await objWeapon.DisplayNameShortAsync(strLanguage, token)
                                                           .ConfigureAwait(false) + "," + strSpace
                                                       + await objAccessory.DisplayNameShortAsync(strLanguage, token)
                                                           .ConfigureAwait(false) + ","
                                                       + strSpace + await parent
                                                           .DisplayNameShortAsync(strLanguage, token)
                                                           .ConfigureAwait(false) + ")";
                                            else
                                                strGearReturn
                                                    += strSpace + "(" + await objVehicle
                                                           .DisplayNameShortAsync(strLanguage, token)
                                                           .ConfigureAwait(false) + ","
                                                       + strSpace
                                                       + await objWeapon.DisplayNameShortAsync(strLanguage, token)
                                                           .ConfigureAwait(false) + "," + strSpace
                                                       + await objAccessory.DisplayNameShortAsync(strLanguage, token)
                                                           .ConfigureAwait(false) + ")";
                                            if (blnWireless)
                                                strGearReturn += strSpace
                                                                 + await LanguageManager.GetStringAsync(
                                                                         "String_Wireless", strLanguage, token: token)
                                                                     .ConfigureAwait(false);
                                            return false;
                                        }

                                        return true;
                                    }, token).ConfigureAwait(false);
                                    if (!string.IsNullOrEmpty(strGearReturn))
                                        return false;
                                }

                                await objVehicle.Mods.ForEachWithBreakAsync(async objVehicleMod =>
                                {
                                    foreach (Weapon objWeapon in await objVehicleMod.Weapons.DeepWhereAsync(
                                                 x => x.Children,
                                                 x => x.WeaponAccessories.AnyAsync(
                                                     async y => await y.GearChildren.GetCountAsync(token)
                                                         .ConfigureAwait(false) > 0, token),
                                                 token).ConfigureAwait(false))
                                    {
                                        await objWeapon.WeaponAccessories.ForEachWithBreakAsync(async objAccessory =>
                                        {
                                            objReturnGear = await objAccessory.GearChildren.DeepFirstOrDefaultAsync(
                                                x => x.Children,
                                                x => x.InternalId == strImprovedSourceName, token).ConfigureAwait(false);
                                            if (objReturnGear != null)
                                            {
                                                strGearReturn = await objReturnGear
                                                    .DisplayNameShortAsync(strLanguage, token)
                                                    .ConfigureAwait(false);
                                                if (objReturnGear.Parent is Gear parent)
                                                    strGearReturn
                                                        += strSpace + "(" + await objVehicle
                                                               .DisplayNameShortAsync(strLanguage, token)
                                                               .ConfigureAwait(false) + ","
                                                           + strSpace + await objVehicleMod
                                                               .DisplayNameShortAsync(strLanguage, token)
                                                               .ConfigureAwait(false)
                                                           + "," + strSpace
                                                           + await objWeapon.DisplayNameShortAsync(strLanguage, token)
                                                               .ConfigureAwait(false) + ","
                                                           + strSpace + await objAccessory
                                                               .DisplayNameShortAsync(strLanguage, token)
                                                               .ConfigureAwait(false)
                                                           + "," + strSpace
                                                           + await parent.DisplayNameShortAsync(strLanguage, token)
                                                               .ConfigureAwait(false) + ")";
                                                else
                                                    strGearReturn
                                                        += strSpace + "(" + await objVehicle
                                                               .DisplayNameShortAsync(strLanguage, token)
                                                               .ConfigureAwait(false) + ","
                                                           + strSpace + await objVehicleMod
                                                               .DisplayNameShortAsync(strLanguage, token)
                                                               .ConfigureAwait(false)
                                                           + "," + strSpace
                                                           + await objWeapon.DisplayNameShortAsync(strLanguage, token)
                                                               .ConfigureAwait(false) + ","
                                                           + strSpace + await objAccessory
                                                               .DisplayNameShortAsync(strLanguage, token)
                                                               .ConfigureAwait(false) + ")";
                                                if (blnWireless)
                                                    strGearReturn += strSpace
                                                                     + await LanguageManager.GetStringAsync(
                                                                             "String_Wireless", strLanguage,
                                                                             token: token)
                                                                         .ConfigureAwait(false);
                                                return false;
                                            }

                                            return true;
                                        }, token).ConfigureAwait(false);
                                        if (!string.IsNullOrEmpty(strGearReturn))
                                            return false;
                                    }

                                    foreach (Cyberware objCyberware in await objVehicleMod.Cyberware.DeepWhereAsync(
                                                 x => x.GetChildrenAsync(token),
                                                 async x =>
                                                     await (await x.GetGearChildrenAsync(token).ConfigureAwait(false)).GetCountAsync(token).ConfigureAwait(false) > 0,
                                                 token).ConfigureAwait(false))
                                    {
                                        objReturnGear = await objCyberware.GearChildren.DeepFirstOrDefaultAsync(
                                            x => x.Children,
                                            x => x.InternalId == strImprovedSourceName, token).ConfigureAwait(false);
                                        if (objReturnGear != null)
                                        {
                                            strGearReturn = await objReturnGear
                                                .DisplayNameShortAsync(strLanguage, token)
                                                .ConfigureAwait(false);
                                            if (objReturnGear.Parent is Gear parent)
                                                strGearReturn
                                                    += strSpace + "(" + await objVehicle
                                                           .DisplayNameShortAsync(strLanguage, token)
                                                           .ConfigureAwait(false) + ","
                                                       + strSpace + await objVehicleMod
                                                           .DisplayNameShortAsync(strLanguage, token)
                                                           .ConfigureAwait(false)
                                                       + "," + strSpace + await objCyberware
                                                           .DisplayNameShortAsync(strLanguage, token)
                                                           .ConfigureAwait(false) + ","
                                                       + strSpace + await parent
                                                           .DisplayNameShortAsync(strLanguage, token)
                                                           .ConfigureAwait(false) + ")";
                                            else
                                                strGearReturn
                                                    += strSpace + "(" + await objVehicle
                                                           .DisplayNameShortAsync(strLanguage, token)
                                                           .ConfigureAwait(false) + ","
                                                       + strSpace + await objVehicleMod
                                                           .DisplayNameShortAsync(strLanguage, token)
                                                           .ConfigureAwait(false)
                                                       + "," + strSpace + await objCyberware
                                                           .DisplayNameShortAsync(strLanguage, token)
                                                           .ConfigureAwait(false) + ")";
                                            if (blnWireless)
                                                strGearReturn += strSpace
                                                                 + await LanguageManager.GetStringAsync(
                                                                         "String_Wireless", strLanguage, token: token)
                                                                     .ConfigureAwait(false);
                                            return false;
                                        }
                                    }

                                    return true;
                                }, token).ConfigureAwait(false);
                                if (!string.IsNullOrEmpty(strGearReturn))
                                    return false;

                                await objVehicle.WeaponMounts.ForEachWithBreakAsync(async objMount =>
                                {
                                    await objMount.Mods.ForEachWithBreakAsync(async objVehicleMod =>
                                    {
                                        foreach (Weapon objWeapon in await objVehicleMod.Weapons.DeepWhereAsync(
                                                         x => x.Children,
                                                         x => x.WeaponAccessories.AnyAsync(
                                                             y => y.GearChildren.Count > 0, token), token)
                                                     .ConfigureAwait(false))
                                        {
                                            await objWeapon.WeaponAccessories.ForEachWithBreakAsync(
                                                async objAccessory =>
                                                {
                                                    objReturnGear = await objAccessory.GearChildren
                                                        .DeepFirstOrDefaultAsync(
                                                            x => x.Children,
                                                            x => x.InternalId == strImprovedSourceName, token).ConfigureAwait(false);
                                                    if (objReturnGear != null)
                                                    {
                                                        strGearReturn = await objReturnGear
                                                            .DisplayNameShortAsync(strLanguage, token)
                                                            .ConfigureAwait(false);
                                                        if (objReturnGear.Parent is Gear parent)
                                                            strGearReturn
                                                                += strSpace + "(" + await objVehicle
                                                                       .DisplayNameShortAsync(strLanguage, token)
                                                                       .ConfigureAwait(false)
                                                                   + ","
                                                                   + strSpace + await objMount
                                                                       .DisplayNameShortAsync(strLanguage, token)
                                                                       .ConfigureAwait(false) + ","
                                                                   + strSpace + await objVehicleMod
                                                                       .DisplayNameShortAsync(strLanguage, token)
                                                                       .ConfigureAwait(false)
                                                                   + "," + strSpace + await objWeapon
                                                                       .DisplayNameShortAsync(strLanguage, token)
                                                                       .ConfigureAwait(false)
                                                                   + ","
                                                                   + strSpace + await objAccessory
                                                                       .DisplayNameShortAsync(strLanguage, token)
                                                                       .ConfigureAwait(false)
                                                                   + "," + strSpace + await parent
                                                                       .DisplayNameShortAsync(strLanguage, token)
                                                                       .ConfigureAwait(false)
                                                                   + ")";
                                                        else
                                                            strGearReturn
                                                                += strSpace + "(" + await objVehicle
                                                                       .DisplayNameShortAsync(strLanguage, token)
                                                                       .ConfigureAwait(false)
                                                                   + ","
                                                                   + strSpace + await objMount
                                                                       .DisplayNameShortAsync(strLanguage, token)
                                                                       .ConfigureAwait(false) + ","
                                                                   + strSpace + await objVehicleMod
                                                                       .DisplayNameShortAsync(strLanguage, token)
                                                                       .ConfigureAwait(false)
                                                                   + "," + strSpace + await objWeapon
                                                                       .DisplayNameShortAsync(strLanguage, token)
                                                                       .ConfigureAwait(false)
                                                                   + ","
                                                                   + strSpace + await objAccessory
                                                                       .DisplayNameShortAsync(strLanguage, token)
                                                                       .ConfigureAwait(false)
                                                                   + ")";
                                                        if (blnWireless)
                                                            strGearReturn += strSpace
                                                                             + await LanguageManager.GetStringAsync(
                                                                                 "String_Wireless", strLanguage,
                                                                                 token: token).ConfigureAwait(false);
                                                        return false;
                                                    }

                                                    return true;
                                                }, token).ConfigureAwait(false);
                                        }

                                        foreach (Cyberware objCyberware in await objVehicleMod.Cyberware.DeepWhereAsync(
                                                     x => x.GetChildrenAsync(token),
                                                     async x => await (await x.GetGearChildrenAsync(token).ConfigureAwait(false)).GetCountAsync(token).ConfigureAwait(false) > 0, token).ConfigureAwait(false))
                                        {
                                            objReturnGear = await (await objCyberware.GetGearChildrenAsync(token).ConfigureAwait(false)).DeepFirstOrDefaultAsync(
                                                x => x.Children,
                                                x => x.InternalId == strImprovedSourceName, token).ConfigureAwait(false);
                                            if (objReturnGear != null)
                                            {
                                                strGearReturn = await objReturnGear
                                                    .DisplayNameShortAsync(strLanguage, token)
                                                    .ConfigureAwait(false);
                                                if (objReturnGear.Parent is Gear parent)
                                                    strGearReturn
                                                        += strSpace + "(" + await objVehicle
                                                               .DisplayNameShortAsync(strLanguage, token)
                                                               .ConfigureAwait(false) + ","
                                                           + strSpace + await objMount
                                                               .DisplayNameShortAsync(strLanguage, token)
                                                               .ConfigureAwait(false) + ","
                                                           + strSpace
                                                           + await objVehicleMod
                                                               .DisplayNameShortAsync(strLanguage, token)
                                                               .ConfigureAwait(false)
                                                           + "," + strSpace + await objCyberware
                                                               .DisplayNameShortAsync(strLanguage, token)
                                                               .ConfigureAwait(false)
                                                           + ","
                                                           + strSpace + await parent
                                                               .DisplayNameShortAsync(strLanguage, token)
                                                               .ConfigureAwait(false) + ")";
                                                else
                                                    strGearReturn
                                                        += strSpace + "(" + await objVehicle
                                                               .DisplayNameShortAsync(strLanguage, token)
                                                               .ConfigureAwait(false) + ","
                                                           + strSpace + await objMount
                                                               .DisplayNameShortAsync(strLanguage, token)
                                                               .ConfigureAwait(false) + ","
                                                           + strSpace
                                                           + await objVehicleMod
                                                               .DisplayNameShortAsync(strLanguage, token)
                                                               .ConfigureAwait(false)
                                                           + "," + strSpace + await objCyberware
                                                               .DisplayNameShortAsync(strLanguage, token)
                                                               .ConfigureAwait(false)
                                                           + ")";
                                                if (blnWireless)
                                                    strGearReturn += strSpace
                                                                     + await LanguageManager.GetStringAsync(
                                                                             "String_Wireless", strLanguage,
                                                                             token: token)
                                                                         .ConfigureAwait(false);
                                                return false;
                                            }
                                        }

                                        return true;
                                    }, token).ConfigureAwait(false);
                                    return string.IsNullOrEmpty(strGearReturn);
                                }, token).ConfigureAwait(false);
                                return string.IsNullOrEmpty(strGearReturn);
                            }, token).ConfigureAwait(false);

                            break;
                        }
                    case Improvement.ImprovementSource.Spell:
                        Spell objSpell = await Spells
                            .FirstOrDefaultAsync(x => x.InternalId == strImprovedSourceName, token)
                            .ConfigureAwait(false);
                        if (objSpell != null)
                            return await objSpell.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false);
                        break;

                    case Improvement.ImprovementSource.Power:
                        Power objPower = await Powers
                            .FirstOrDefaultAsync(x => x.InternalId == strImprovedSourceName, token)
                            .ConfigureAwait(false);
                        if (objPower != null)
                            return await objPower.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false);
                        break;

                    case Improvement.ImprovementSource.CritterPower:
                        CritterPower objCritterPower = await CritterPowers
                            .FirstOrDefaultAsync(x => x.InternalId == strImprovedSourceName, token)
                            .ConfigureAwait(false);
                        if (objCritterPower != null)
                            return await objCritterPower.DisplayNameShortAsync(strLanguage, token)
                                .ConfigureAwait(false);
                        break;

                    case Improvement.ImprovementSource.Metamagic:
                        Metamagic objMetamagic = await Metamagics
                            .FirstOrDefaultAsync(
                                x => x.InternalId == strImprovedSourceName &&
                                     x.SourceType == Improvement.ImprovementSource.Metamagic, token)
                            .ConfigureAwait(false);
                        if (objMetamagic != null)
                            return await objMetamagic.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false);
                        break;

                    case Improvement.ImprovementSource.Echo:
                        Metamagic objEcho = await Metamagics
                            .FirstOrDefaultAsync(
                                x => x.InternalId == strImprovedSourceName &&
                                     x.SourceType == Improvement.ImprovementSource.Echo, token).ConfigureAwait(false);
                        if (objEcho != null)
                            return await objEcho.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false);
                        break;

                    case Improvement.ImprovementSource.Art:
                        Art objArt = await Arts.FirstOrDefaultAsync(x => x.InternalId == strImprovedSourceName, token)
                            .ConfigureAwait(false);
                        if (objArt != null)
                            return await objArt.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false);
                        break;

                    case Improvement.ImprovementSource.Enhancement:
                        Enhancement objEnhancement = await Enhancements
                            .FirstOrDefaultAsync(x => x.InternalId == strImprovedSourceName, token)
                            .ConfigureAwait(false);
                        if (objEnhancement != null)
                            return await objEnhancement.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false);
                        break;
                    case Improvement.ImprovementSource.Armor:
                        {
                            Armor objArmor = await Armor
                                .FirstOrDefaultAsync(x => x.InternalId == strImprovedSourceName, token)
                                .ConfigureAwait(false);
                            if (objArmor != null)
                            {
                                string strReturnArmor = await objArmor.DisplayNameShortAsync(strLanguage, token)
                                    .ConfigureAwait(false);
                                if (blnWireless)
                                    strReturnArmor
                                        += strSpace + await LanguageManager
                                            .GetStringAsync("String_Wireless", strLanguage, token: token)
                                            .ConfigureAwait(false);
                                return strReturnArmor;
                            }

                            break;
                        }
                    case Improvement.ImprovementSource.ArmorMod:
                        {
                            ArmorMod objMod = null;
                            await Armor.ForEachWithBreakAsync(async x =>
                            {
                                objMod = await x.ArmorMods.FirstOrDefaultAsync(
                                    y => y.InternalId == strImprovedSourceName, token).ConfigureAwait(false);
                                return objMod == null;
                            }, token).ConfigureAwait(false);
                            if (objMod != null)
                            {
                                string strReturnArmorMod =
                                    await objMod.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) +
                                    strSpace + "("
                                    + await objMod.Parent.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) +
                                    ")";
                                if (blnWireless)
                                    strReturnArmorMod
                                        += strSpace + await LanguageManager
                                            .GetStringAsync("String_Wireless", strLanguage, token: token)
                                            .ConfigureAwait(false);
                                return strReturnArmorMod;
                            }

                            break;
                        }
                    case Improvement.ImprovementSource.ComplexForm:
                        ComplexForm objComplexForm = await ComplexForms
                            .FirstOrDefaultAsync(x => x.InternalId == strImprovedSourceName, token)
                            .ConfigureAwait(false);
                        if (objComplexForm != null)
                            return await objComplexForm.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false);
                        break;
                    case Improvement.ImprovementSource.AIProgram:
                        AIProgram objAIProgram = await AIPrograms
                            .FirstOrDefaultAsync(x => x.InternalId == strImprovedSourceName, token)
                            .ConfigureAwait(false);
                        if (objAIProgram != null)
                            return await objAIProgram.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false);
                        break;
                    case Improvement.ImprovementSource.Quality:
                        {
                            if (strImprovedSourceName.StartsWith("SEEKER", StringComparison.Ordinal))
                            {
                                string strReturn = string.Empty;
                                if (GlobalSettings.Language != GlobalSettings.DefaultLanguage)
                                {
                                    strReturn = (await LoadDataXPathAsync("qualities.xml", token: token)
                                            .ConfigureAwait(false))
                                        .SelectSingleNodeAndCacheExpression(
                                            strImprovedSourceName == "SEEKER_WIL"
                                                ? "/chummer/qualities/quality[name = \"Cyber-Singularity Seeker\"]/translate"
                                                : "/chummer/qualities/quality[name = \"Redliner\"]/translate",
                                            token)?.Value;
                                }

                                if (string.IsNullOrEmpty(strReturn))
                                    strReturn = strImprovedSourceName == "SEEKER_WIL"
                                        ? "Cyber-Singularity Seeker"
                                        : "Redliner";
                                return strReturn;
                            }

                            Quality objQuality = await Qualities
                                .FirstOrDefaultAsync(x => x.InternalId == strImprovedSourceName, token)
                                .ConfigureAwait(false);
                            if (objQuality != null)
                                return await objQuality.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false);

                            break;
                        }

                    case Improvement.ImprovementSource.MartialArtTechnique:
                        MartialArtTechnique objTechnique = null;
                        await MartialArts.ForEachWithBreakAsync(async x =>
                        {
                            objTechnique = await x.Techniques.FirstOrDefaultAsync(
                                y => y.InternalId == strImprovedSourceName, token).ConfigureAwait(false);
                            return objTechnique == null;
                        }, token).ConfigureAwait(false);
                        if (objTechnique != null)
                            return await objTechnique.DisplayNameAsync(strLanguage, token).ConfigureAwait(false);
                        break;

                    case Improvement.ImprovementSource.MentorSpirit:
                        MentorSpirit objMentorSpirit = await MentorSpirits
                            .FirstOrDefaultAsync(x => x.InternalId == strImprovedSourceName, token)
                            .ConfigureAwait(false);
                        if (objMentorSpirit != null)
                            return await objMentorSpirit.DisplayNameShortAsync(strLanguage, token)
                                .ConfigureAwait(false);
                        break;

                    case Improvement.ImprovementSource.Heritage:
                        return await LanguageManager.GetStringAsync("String_Priority", strLanguage, token: token)
                            .ConfigureAwait(false);

                    case Improvement.ImprovementSource.Initiation:
                        return await LanguageManager.GetStringAsync("Tab_Initiation", strLanguage, token: token)
                            .ConfigureAwait(false);

                    case Improvement.ImprovementSource.Submersion:
                        return await LanguageManager.GetStringAsync("Tab_Submersion", strLanguage, token: token)
                            .ConfigureAwait(false);

                    case Improvement.ImprovementSource.Encumbrance:
                        return await LanguageManager.GetStringAsync("String_Encumbrance", strLanguage, token: token)
                            .ConfigureAwait(false);

                    case Improvement.ImprovementSource.ArmorEncumbrance:
                        return await LanguageManager
                            .GetStringAsync("String_ArmorEncumbrance", strLanguage, token: token).ConfigureAwait(false);

                    case Improvement.ImprovementSource.Tradition:
                        return await LanguageManager.GetStringAsync("String_Tradition", strLanguage, token: token)
                            .ConfigureAwait(false);

                    case Improvement.ImprovementSource.AstralReputation:
                        return await LanguageManager
                            .GetStringAsync("String_AstralReputation", strLanguage, token: token).ConfigureAwait(false);

                    case Improvement.ImprovementSource.CyberadeptDaemon:
                        return (await LoadDataXPathAsync("qualities.xml", strLanguage, token: token)
                                .ConfigureAwait(false))
                            .SelectSingleNode(
                                "/chummer/qualities/quality[name = \"Resonant Stream: Cyberadept\"]/translate")
                            ?.Value ?? "Resonant Stream: Cyberadept";

                    default:
                        {
                            if (objImprovement.ImproveType == Improvement.ImprovementType.ArmorEncumbrancePenalty)
                                return await LanguageManager
                                    .GetStringAsync("String_ArmorEncumbrance", strLanguage, token: token)
                                    .ConfigureAwait(false);
                            // If this comes from a custom Improvement, use the name the player gave it instead of showing a GUID.
                            if (!string.IsNullOrEmpty(objImprovement.CustomName))
                                return objImprovement.CustomName;
                            string strReturn = strImprovedSourceName;
                            if (string.IsNullOrEmpty(strReturn) || strReturn.IsGuid())
                            {
                                string strTemp = await LanguageManager.GetStringAsync(
                                    "String_" + objImprovement.ImproveSource,
                                    strLanguage, false, token: token).ConfigureAwait(false);
                                if (!string.IsNullOrEmpty(strTemp))
                                    strReturn = strTemp;
                            }

                            return strReturn;
                        }
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }

            return string.Empty;
        }

        public void CleanUpOrphanedImprovements(CancellationToken token = default)
        {
            using (LockObject.EnterWriteLock(token))
            {
                int intNewImprovementCount = 0;
                int intOldImprovementCount = Improvements.Count;
                // Loop this until we remove every single orphaned improvement (necessary because orphaned improvements can add other improvements)
                while (intOldImprovementCount != intNewImprovementCount)
                {
                    intOldImprovementCount = Improvements.Count;
                    // Relying on (a lack of) GetObjectName is slower than ideal, but much easier to maintain
                    Improvements.RemoveAll(x => string.IsNullOrEmpty(GetObjectName(x, GlobalSettings.DefaultLanguage, token)), token);
                    intNewImprovementCount = Improvements.Count;
                }
            }
        }

        public async Task CleanUpOrphanedImprovementsAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intNewImprovementCount = 0;
                int intOldImprovementCount = await Improvements.GetCountAsync(token).ConfigureAwait(false);
                // Loop this until we remove every single orphaned improvement (necessary because orphaned improvements can add other improvements)
                while (intOldImprovementCount != intNewImprovementCount)
                {
                    intOldImprovementCount = await Improvements.GetCountAsync(token).ConfigureAwait(false);
                    // Relying on (a lack of) GetObjectName is slower than ideal, but much easier to maintain
                    await Improvements.RemoveAllAsync(
                        x => string.IsNullOrEmpty(GetObjectName(x, GlobalSettings.DefaultLanguage, token)), token).ConfigureAwait(false);
                    intNewImprovementCount = await Improvements.GetCountAsync(token).ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public void FormatImprovementModifiers(StringBuilder sbdToolTip, Improvement.ImprovementType eType, string strSpace, int intModifiers, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (sbdToolTip == null)
                return;
            sbdToolTip.Append(strSpace, '+').Append(strSpace, LanguageManager.GetString("Tip_Modifiers", token: token));
            bool blnFirstModifier = true;
            using (LockObject.EnterReadLock(token))
            {
                foreach (Improvement objLoopImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                 this, eType, token: token))
                {
                    if (blnFirstModifier)
                    {
                        blnFirstModifier = false;
                        sbdToolTip.Append(LanguageManager.GetString("String_Colon", token: token));
                    }
                    else
                        sbdToolTip.Append(',');

                    sbdToolTip.Append(strSpace, GetObjectName(objLoopImprovement, token: token));
                }
            }

            sbdToolTip.Append(strSpace, '(').Append(intModifiers.ToString(GlobalSettings.CultureInfo), ')');
        }

        public void FormatImprovementModifiers(StringBuilder sbdToolTip, IEnumerable<Improvement.ImprovementType> improvements, string strSpace, int intModifiers, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (sbdToolTip == null)
                return;
            sbdToolTip.Append(strSpace, '+').Append(strSpace, LanguageManager.GetString("Tip_Modifiers", token: token));
            bool blnFirstModifier = true;
            using (LockObject.EnterReadLock(token))
            {
                foreach (Improvement.ImprovementType eType in improvements)
                {
                    foreach (Improvement objLoopImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                 this, eType, token: token))
                    {
                        if (blnFirstModifier)
                        {
                            blnFirstModifier = false;
                            sbdToolTip.Append(LanguageManager.GetString("String_Colon", token: token));
                        }
                        else
                            sbdToolTip.Append(',');

                        sbdToolTip.Append(strSpace, GetObjectName(objLoopImprovement, token: token));
                    }
                }
            }

            sbdToolTip.Append(strSpace, '(').Append(intModifiers.ToString(GlobalSettings.CultureInfo), ')');
        }

        public async Task FormatImprovementModifiersAsync(StringBuilder sbdToolTip, Improvement.ImprovementType eType, string strSpace, int intModifiers, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (sbdToolTip == null)
                return;
            sbdToolTip.Append(strSpace, '+').Append(strSpace, await LanguageManager.GetStringAsync("Tip_Modifiers", token: token).ConfigureAwait(false));
            bool blnFirstModifier = true;
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                foreach (Improvement objLoopImprovement in await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                this, eType, token: token).ConfigureAwait(false))
                {
                    if (blnFirstModifier)
                    {
                        blnFirstModifier = false;
                        sbdToolTip.Append(await LanguageManager.GetStringAsync("String_Colon", token: token).ConfigureAwait(false));
                    }
                    else
                        sbdToolTip.Append(',');

                    sbdToolTip.Append(strSpace, await GetObjectNameAsync(objLoopImprovement, token: token).ConfigureAwait(false));
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }

            sbdToolTip.Append(strSpace, '(').Append(intModifiers.ToString(GlobalSettings.CultureInfo), ')');
        }

        public async Task FormatImprovementModifiersAsync(StringBuilder sbdToolTip, IEnumerable<Improvement.ImprovementType> improvements, string strSpace, int intModifiers, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (sbdToolTip == null)
                return;
            sbdToolTip.Append(strSpace, '+').Append(strSpace, await LanguageManager.GetStringAsync("Tip_Modifiers", token: token).ConfigureAwait(false));
            bool blnFirstModifier = true;
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                foreach (Improvement.ImprovementType eType in improvements)
                {
                    foreach (Improvement objLoopImprovement in await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                 this, eType, token: token).ConfigureAwait(false))
                    {
                        if (blnFirstModifier)
                        {
                            blnFirstModifier = false;
                            sbdToolTip.Append(await LanguageManager.GetStringAsync("String_Colon", token: token).ConfigureAwait(false));
                        }
                        else
                            sbdToolTip.Append(',');

                        sbdToolTip.Append(strSpace, await GetObjectNameAsync(objLoopImprovement, token: token).ConfigureAwait(false));
                    }
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }

            sbdToolTip.Append(strSpace, '(').Append(intModifiers.ToString(GlobalSettings.CultureInfo), ')');
        }

        /// <summary>
        /// Return an enumerable of CyberwareGrades from XML files.
        /// </summary>
        /// <param name="objSource">Source to load the Grades from, either Bioware or Cyberware.</param>
        /// <param name="blnIgnoreBannedGrades">Whether to ignore grades banned at chargen.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public IEnumerable<Grade> GetGrades(Improvement.ImprovementSource objSource, bool blnIgnoreBannedGrades = false, CancellationToken token = default)
        {
            using (LockObject.EnterReadLock(token))
            {
                string strXPath;
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdFilter))
                {
                    if (Settings != null)
                    {
                        sbdFilter.Append('(', Settings.BookXPath(token: token), ") and ");
                        if (!IgnoreRules && !Created && !blnIgnoreBannedGrades)
                        {
                            foreach (string strBannedGrade in Settings.BannedWareGrades)
                            {
                                sbdFilter.Append("not(contains(name, ", strBannedGrade.CleanXPath(), ")) and ");
                            }
                        }
                    }

                    if (sbdFilter.Length != 0)
                    {
                        sbdFilter.Length -= 5;
                        strXPath = sbdFilter.Insert(0, "/chummer/grades/grade[(").Append(")]").ToString();
                    }
                    else
                        strXPath = "/chummer/grades/grade";
                }

                using (XmlNodeList xmlGradeList = LoadData(Grade.GetDataFileNameFromImprovementSource(objSource), token: token)
                           .SelectNodes(strXPath))
                {
                    if (xmlGradeList?.Count > 0)
                    {
                        foreach (XmlNode objNode in xmlGradeList)
                        {
                            Grade objGrade = new Grade(this, objSource);
                            objGrade.Load(objNode);
                            yield return objGrade;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Return a specific Cyberware grade based on its name.
        /// </summary>
        /// <param name="objSource">Source to load the Grades from, either Bioware or Cyberware.</param>
        /// <param name="strName">Name of the grade to fetch.</param>
        /// <param name="blnIgnoreBannedGrades">Whether to ignore grades banned at chargen.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public Grade GetGradeByName(Improvement.ImprovementSource objSource, string strName, bool blnIgnoreBannedGrades = false, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            Grade objStandardGrade = null;
            foreach (Grade objGrade in GetGrades(objSource, blnIgnoreBannedGrades, token))
            {
                string strGradeName = objGrade.Name;
                if (strGradeName == strName)
                    return objGrade;
                if (strGradeName == "Standard")
                    objStandardGrade = objGrade;
            }
            return objStandardGrade;
        }

        /// <summary>
        /// Return a specific Cyberware grade based on its name.
        /// </summary>
        /// <param name="objSource">Source to load the Grades from, either Bioware or Cyberware.</param>
        /// <param name="strName">Name of the grade to fetch.</param>
        /// <param name="blnIgnoreBannedGrades">Whether to ignore grades banned at chargen.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public async Task<Grade> GetGradeByNameAsync(Improvement.ImprovementSource objSource, string strName, bool blnIgnoreBannedGrades = false, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                Grade objStandardGrade = null;
                string strXPath;
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdFilter))
                {
                    CharacterSettings objSettings = await GetSettingsAsync(token).ConfigureAwait(false);
                    if (objSettings != null)
                    {
                        sbdFilter.Append(await objSettings.BookXPathAsync(token: token).ConfigureAwait(false), " and ");
                        if (!await GetIgnoreRulesAsync(token).ConfigureAwait(false) && !await GetCreatedAsync(token).ConfigureAwait(false) && !blnIgnoreBannedGrades)
                        {
                            foreach (string strBannedGrade in objSettings.BannedWareGrades)
                            {
                                sbdFilter.Append("not(contains(name, ", strBannedGrade.CleanXPath(), ")) and ");
                            }
                        }
                    }

                    if (sbdFilter.Length != 0)
                    {
                        sbdFilter.Length -= 5;
                        strXPath = sbdFilter.Insert(0, "/chummer/grades/grade[(").Append(")]").ToString();
                    }
                    else
                        strXPath = "/chummer/grades/grade";
                }

                using (XmlNodeList xmlGradeList =
                       (await LoadDataAsync(Grade.GetDataFileNameFromImprovementSource(objSource), token: token).ConfigureAwait(false))
                           .SelectNodes(strXPath))
                {
                    if (xmlGradeList?.Count > 0)
                    {
                        foreach (XmlNode objNode in xmlGradeList)
                        {
                            Grade objGrade = new Grade(this, objSource);
                            await objGrade.LoadAsync(objNode, token).ConfigureAwait(false);
                            string strGradeName = objGrade.Name;
                            if (strGradeName == strName)
                                return objGrade;
                            if (strGradeName == "Standard")
                                objStandardGrade = objGrade;
                        }
                    }
                }

                return objStandardGrade;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Return a list of CyberwareGrades from XML files.
        /// </summary>
        /// <param name="objSource">Source to load the Grades from, either Bioware or Cyberware.</param>
        /// <param name="blnIgnoreBannedGrades">Whether to ignore grades banned at chargen.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public List<Grade> GetGradesList(Improvement.ImprovementSource objSource, bool blnIgnoreBannedGrades = false, CancellationToken token = default)
        {
            return GetGrades(objSource, blnIgnoreBannedGrades, token).ToList();
        }

        /// <summary>
        /// Return a list of CyberwareGrades from XML files.
        /// </summary>
        /// <param name="objSource">Source to load the Grades from, either Bioware or Cyberware.</param>
        /// <param name="blnIgnoreBannedGrades">Whether to ignore grades banned at chargen.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public async Task<List<Grade>> GetGradesListAsync(Improvement.ImprovementSource objSource, bool blnIgnoreBannedGrades = false, CancellationToken token = default)
        {
            List<Grade> lstReturn;
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                string strXPath;
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdFilter))
                {
                    if (Settings != null)
                    {
                        sbdFilter.Append(await (await GetSettingsAsync(token).ConfigureAwait(false)).BookXPathAsync(token: token).ConfigureAwait(false), " and ");
                        if (!blnIgnoreBannedGrades && !await GetCreatedAsync(token).ConfigureAwait(false) && !await GetIgnoreRulesAsync(token).ConfigureAwait(false))
                        {
                            foreach (string strBannedGrade in (await GetSettingsAsync(token).ConfigureAwait(false)).BannedWareGrades)
                            {
                                sbdFilter.Append("not(contains(name, ", strBannedGrade.CleanXPath(), ")) and ");
                            }
                        }
                    }

                    if (sbdFilter.Length != 0)
                    {
                        sbdFilter.Length -= 5;
                        strXPath = sbdFilter.Insert(0, "/chummer/grades/grade[(").Append(")]").ToString();
                    }
                    else
                        strXPath = "/chummer/grades/grade";
                }

                using (XmlNodeList xmlGradeList = (await LoadDataAsync(Grade.GetDataFileNameFromImprovementSource(objSource), token: token).ConfigureAwait(false))
                           .SelectNodes(strXPath))
                {
                    lstReturn = new List<Grade>(xmlGradeList?.Count ?? 0);
                    if (xmlGradeList?.Count > 0)
                    {
                        foreach (XmlNode objNode in xmlGradeList)
                        {
                            Grade objGrade = new Grade(this, objSource);
                            await objGrade.LoadAsync(objNode, token).ConfigureAwait(false);
                            lstReturn.Add(objGrade);
                        }
                    }
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }

            return lstReturn;
        }

        /// <summary>
        /// Calculate the number of Free Spirit Power Points used.
        /// </summary>
        public async Task<string> CalculateFreeSpiritPowerPointsAsync(CancellationToken token = default)
        {
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);

            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await GetMetatypeAsync(token).ConfigureAwait(false) == "Free Spirit" && !await GetIsCritterAsync(token).ConfigureAwait(false))
                {
                    // PC Free Spirit.
                    decimal decPowerPoints = await (await GetCritterPowersAsync(token).ConfigureAwait(false))
                                                   .SumAsync(x => x.CountTowardsLimit, x => x.PowerPoints, token: token)
                                                   .ConfigureAwait(false);

                    int intPowerPoints = await (await GetAttributeAsync("EDG", token: token).ConfigureAwait(false))
                                               .GetTotalValueAsync(token).ConfigureAwait(false)
                                         + (await ImprovementManager
                                                  .ValueOfAsync(this, Improvement.ImprovementType.FreeSpiritPowerPoints,
                                                                token: token).ConfigureAwait(false)).StandardRound();

                    // If the house rule to base Power Points on the character's MAG value instead, use the character's MAG.
                    if (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetFreeSpiritPowerPointsMAGAsync(token).ConfigureAwait(false))
                        intPowerPoints = await (await GetAttributeAsync("MAG", token: token).ConfigureAwait(false))
                                               .GetTotalValueAsync(token).ConfigureAwait(false)
                                         + (await ImprovementManager
                                                  .ValueOfAsync(this, Improvement.ImprovementType.FreeSpiritPowerPoints,
                                                                token: token).ConfigureAwait(false)).StandardRound();

                    return intPowerPoints.ToString(GlobalSettings.CultureInfo) + strSpace + "("
                           + (intPowerPoints - decPowerPoints).ToString(GlobalSettings.CultureInfo) + strSpace
                           + await LanguageManager.GetStringAsync("String_Remaining", token: token).ConfigureAwait(false) + ")";
                }
                else
                {
                    int intPowerPoints;

                    switch ((await GetMetatypeAsync(token).ConfigureAwait(false)).ToUpperInvariant())
                    {
                        case "FREE SPIRIT":
                            // Critter Free Spirits have a number of Power Points equal to their EDG plus any Free Spirit Power Points Improvements.
                            intPowerPoints = await (await GetAttributeAsync("EDG", token: token).ConfigureAwait(false))
                                                   .GetTotalValueAsync(token).ConfigureAwait(false)
                                             + (await ImprovementManager
                                                      .ValueOfAsync(
                                                          this, Improvement.ImprovementType.FreeSpiritPowerPoints,
                                                          token: token).ConfigureAwait(false)).StandardRound();
                            break;

                        case "ALLY SPIRIT":
                            // Ally Spirits get a number of Power Points equal to their MAG.
                            intPowerPoints = await (await GetAttributeAsync("MAG", token: token).ConfigureAwait(false))
                                                   .GetTotalValueAsync(token).ConfigureAwait(false);
                            break;

                        default:
                            // Spirits get 1 Power Point for every 3 full points of Force (MAG) they possess.
                            intPowerPoints = await (await GetAttributeAsync("MAG", token: token).ConfigureAwait(false))
                                                   .GetTotalValueAsync(token).ConfigureAwait(false) / 3;
                            break;
                    }

                    decimal decUsed = await (await GetCritterPowersAsync(token).ConfigureAwait(false))
                                            .SumAsync(x => x.Category != "Weakness" && x.CountTowardsLimit,
                                                      x => x.PowerPoints, token: token).ConfigureAwait(false);

                    return intPowerPoints.ToString(GlobalSettings.CultureInfo) + strSpace + "("
                           + (intPowerPoints - decUsed).ToString(GlobalSettings.CultureInfo) + strSpace
                           + await LanguageManager.GetStringAsync("String_Remaining", token: token).ConfigureAwait(false) + ")";
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Calculate the number of Free Sprite Power Points used.
        /// </summary>
        public async Task<string> CalculateFreeSpritePowerPointsAsync(CancellationToken token = default)
        {
            // Free Sprite Power Points.
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                decimal decUsedPowerPoints = await (await GetCritterPowersAsync(token).ConfigureAwait(false))
                                                   .SumAsync(x => x.CountTowardsLimit, x => x.PowerPoints, token)
                                                   .ConfigureAwait(false);

                int intPowerPoints = await (await GetAttributeAsync("EDG", token: token).ConfigureAwait(false))
                                           .GetTotalValueAsync(token).ConfigureAwait(false)
                                     + (await ImprovementManager
                                              .ValueOfAsync(this, Improvement.ImprovementType.FreeSpiritPowerPoints,
                                                            token: token).ConfigureAwait(false)).StandardRound();

                string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);

                return intPowerPoints.ToString(GlobalSettings.CultureInfo) + strSpace + "("
                       + (intPowerPoints - decUsedPowerPoints).ToString(GlobalSettings.CultureInfo)
                       + strSpace + await LanguageManager.GetStringAsync("String_Remaining", token: token).ConfigureAwait(false) + ")";
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Construct a list of possible places to put a piece of modular cyberware. Names are display names of the given items, values are internalIDs of the given items.
        /// </summary>
        /// <param name="objModularCyberware">Cyberware for which to construct the list.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public IEnumerable<ListItem> ConstructModularCyberlimbList([NotNull] Cyberware objModularCyberware, CancellationToken token = default)
        {
            yield return new ListItem("None", LanguageManager.GetString("String_None", token: token));

            string strSpace = LanguageManager.GetString("String_Space", token: token);

            using (LockObject.EnterReadLock(token))
            {
                Grade objGrade = objModularCyberware.Grade;
                foreach (Cyberware objLoopCyberware in Cyberware.GetAllDescendants(x => x.Children, token))
                {
                    // Make sure this has an eligible mount location and it's not the selected piece modular cyberware
                    if (objModularCyberware.PlugsIntoTargetCyberware(objLoopCyberware)
                        && (objLoopCyberware.Location == objModularCyberware.Location
                            || string.IsNullOrEmpty(objModularCyberware.Location))
                        && objLoopCyberware.Grade.Name == objGrade.Name
                        && objLoopCyberware != objModularCyberware
                        // Make sure it's not the place where the mount is already occupied (either by us or something else)
                        && !objLoopCyberware.Children.Any(x => x.PlugsIntoTargetCyberware(objLoopCyberware), token))
                    {
                        string strName = objLoopCyberware.Parent?.CurrentDisplayName
                                         ?? objLoopCyberware.CurrentDisplayName;
                        yield return new ListItem(objLoopCyberware.InternalId, strName);
                    }
                }

                foreach (Vehicle objLoopVehicle in Vehicles)
                {
                    foreach (VehicleMod objLoopVehicleMod in objLoopVehicle.Mods)
                    {
                        foreach (Cyberware objLoopCyberware in objLoopVehicleMod.Cyberware.GetAllDescendants(
                                     x => x.Children, token))
                        {
                            // Make sure this has an eligible mount location and it's not the selected piece modular cyberware
                            if (objModularCyberware.PlugsIntoTargetCyberware(objLoopCyberware)
                                && objLoopCyberware.Location == objModularCyberware.Location
                                && objLoopCyberware.Grade.Name == objGrade.Name
                                && objLoopCyberware != objModularCyberware
                                // Make sure it's not the place where the mount is already occupied (either by us or something else)
                                && !objLoopCyberware.Children.Any(x => x.PlugsIntoTargetCyberware(objLoopCyberware), token))
                            {
                                string strName = objLoopVehicle.CurrentDisplayName
                                                 + strSpace + (objLoopCyberware.Parent?.CurrentDisplayName
                                                               ?? objLoopVehicleMod.CurrentDisplayName);
                                yield return new ListItem(objLoopCyberware.InternalId, strName);
                            }
                        }
                    }

                    foreach (WeaponMount objLoopWeaponMount in objLoopVehicle.WeaponMounts)
                    {
                        foreach (VehicleMod objLoopVehicleMod in objLoopWeaponMount.Mods)
                        {
                            foreach (Cyberware objLoopCyberware in objLoopVehicleMod.Cyberware.GetAllDescendants(
                                         x => x.Children, token))
                            {
                                // Make sure this has an eligible mount location and it's not the selected piece modular cyberware
                                if (objModularCyberware.PlugsIntoTargetCyberware(objLoopCyberware)
                                    && objLoopCyberware.Location == objModularCyberware.Location
                                    && objLoopCyberware.Grade.Name == objGrade.Name
                                    && objLoopCyberware != objModularCyberware
                                    // Make sure it's not the place where the mount is already occupied (either by us or something else)
                                    && !objLoopCyberware.Children.Any(x => x.PlugsIntoTargetCyberware(objLoopCyberware), token))
                                {
                                    string strName = objLoopVehicle.CurrentDisplayName
                                                     + strSpace + (objLoopCyberware.Parent?.CurrentDisplayName
                                                                   ?? objLoopVehicleMod.CurrentDisplayName);
                                    yield return new ListItem(objLoopCyberware.InternalId, strName);
                                }
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Construct a list of possible places to put a piece of modular cyberware. Names are display names of the given items, values are internalIDs of the given items.
        /// </summary>
        /// <param name="objModularCyberware">Cyberware for which to construct the list.</param>
        /// <param name="blnUsePool">If set to true, the returned list will be taken from <see cref="Utils.ListItemListPool"/> instead of newly allocated.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public async Task<List<ListItem>> ConstructModularCyberlimbListAsync([NotNull] Cyberware objModularCyberware, bool blnUsePool = false,
            CancellationToken token = default)
        {
            List<ListItem> lstReturn = blnUsePool ? Utils.ListItemListPool.Get() : new List<ListItem>(3);
            try
            {
                lstReturn.Add(new ListItem("None",
                        await LanguageManager.GetStringAsync("String_None", token: token).ConfigureAwait(false)));

                string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);

                IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    Grade objGrade = await objModularCyberware.GetGradeAsync(token).ConfigureAwait(false);
                    await (await (await GetCyberwareAsync(token).ConfigureAwait(false))
                        .GetAllDescendantsAsync(x => x.Children, token).ConfigureAwait(false)).ForEachAsync(x => ProcessCyberware(x, objGrade, null), token).ConfigureAwait(false);

                    await (await GetVehiclesAsync(token).ConfigureAwait(false)).ForEachAsync(async objLoopVehicle =>
                    {
                        await objLoopVehicle.Mods.ForEachAsync(async objLoopVehicleMod =>
                        {
                            await (await objLoopVehicleMod.Cyberware.GetAllDescendantsAsync(x => x.GetChildrenAsync(token), token)
                                .ConfigureAwait(false)).ForEachAsync(x => ProcessCyberware(x, objGrade, objLoopVehicleMod), token).ConfigureAwait(false);
                        }, token).ConfigureAwait(false);

                        await objLoopVehicle.WeaponMounts.ForEachAsync(objLoopWeaponMount =>
                        {
                            return objLoopWeaponMount.Mods.ForEachAsync(async objLoopVehicleMod =>
                            {
                                await (await objLoopVehicleMod.Cyberware.GetAllDescendantsAsync(x => x.GetChildrenAsync(token), token)
                                    .ConfigureAwait(false)).ForEachAsync(x => ProcessCyberware(x, objGrade, objLoopVehicleMod), token).ConfigureAwait(false);
                            }, token);
                        }, token).ConfigureAwait(false);
                    }, token).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }

                return lstReturn;

                async Task ProcessCyberware(Cyberware objLoopCyberware, Grade objGrade, VehicleMod objVehicleMod)
                {
                    // Make sure this has an eligible mount location and it's not the selected piece modular cyberware
                    if (await objModularCyberware.PlugsIntoTargetCyberwareAsync(objLoopCyberware, token).ConfigureAwait(false)
                        && objLoopCyberware.Location == objModularCyberware.Location
                        && (await objLoopCyberware.GetGradeAsync(token).ConfigureAwait(false)).Name ==
                        objGrade.Name
                        && objLoopCyberware != objModularCyberware
                        // Make sure it's not the place where the mount is already occupied (either by us or something else)
                        && !await (await objLoopCyberware.GetChildrenAsync(token).ConfigureAwait(false)).AnyAsync(
                                x => x.PlugsIntoTargetCyberwareAsync(objLoopCyberware, token), token)
                            .ConfigureAwait(false))
                    {
                        string strName = objVehicleMod != null
                            ? await objVehicleMod.Parent.GetCurrentDisplayNameAsync(token)
                                  .ConfigureAwait(false) + strSpace
                            : string.Empty;
                        Cyberware objLoopParent = await objLoopCyberware.GetParentAsync(token).ConfigureAwait(false);
                        if (objLoopParent != null)
                            strName += strSpace + await objLoopParent.GetCurrentDisplayNameAsync(token)
                                      .ConfigureAwait(false);
                        else if (objVehicleMod != null)
                            strName += strSpace + await objVehicleMod.GetCurrentDisplayNameAsync(token)
                                      .ConfigureAwait(false);
                        lstReturn.Add(new ListItem(objLoopCyberware.InternalId, strName));
                    }
                }
            }
            catch
            {
                if (blnUsePool)
                    Utils.ListItemListPool.Return(ref lstReturn);
                throw;
            }
        }

        public async Task<bool> SwitchBuildMethods(CharacterBuildMethod eOldBuildMethod, CharacterBuildMethod eNewBuildMethod, string strOldSettingsKey, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (await GetCreatedAsync(token).ConfigureAwait(false))
                return true;
            DialogResult eResult;
            if (eNewBuildMethod.UsesPriorityTables())
            {
                using (ThreadSafeForm<SelectMetatypePriority> frmSelectMetatype = await ThreadSafeForm<SelectMetatypePriority>.GetAsync(() => new SelectMetatypePriority(this), token).ConfigureAwait(false))
                {
                    eResult = await frmSelectMetatype.ShowDialogSafeAsync(this, token).ConfigureAwait(false);
                }
            }
            else
            {
                using (ThreadSafeForm<SelectMetatypeKarma> frmSelectMetatype = await ThreadSafeForm<SelectMetatypeKarma>.GetAsync(() => new SelectMetatypeKarma(this), token).ConfigureAwait(false))
                {
                    eResult = await frmSelectMetatype.ShowDialogSafeAsync(this, token).ConfigureAwait(false);
                }
            }

            IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (eResult != DialogResult.OK)
                {
                    await SetSettingsKeyAsync(strOldSettingsKey, token).ConfigureAwait(false);
                    return false;
                }

                if (eOldBuildMethod == CharacterBuildMethod.LifeModule)
                {
                    ThreadSafeObservableCollection<Quality> lstQualities = await GetQualitiesAsync(token).ConfigureAwait(false);
                    IAsyncDisposable objLocker2 = await lstQualities.LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        for (int i = await lstQualities.GetCountAsync(token).ConfigureAwait(false) - 1; i >= 0; --i)
                        {
                            if (i >= await lstQualities.GetCountAsync(token).ConfigureAwait(false))
                                continue;
                            Quality objQuality = await lstQualities.GetValueAtAsync(i, token).ConfigureAwait(false);
                            if (objQuality.OriginSource == QualitySource.LifeModule)
                                await objQuality.DeleteQualityAsync(token: token).ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        await objLocker2.DisposeAsync().ConfigureAwait(false);
                    }
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }

            return true;
        }

        public async Task<ValueTuple<string, int>> CalculateKarmaValue(string strLanguage, CultureInfo objCulture, CancellationToken token = default)
        {
            string strColonCharacter = await LanguageManager.GetStringAsync("String_Colon", strLanguage, token: token).ConfigureAwait(false);
            string strSpace = await LanguageManager.GetStringAsync("String_Space", strLanguage, token: token).ConfigureAwait(false);
            string strKarmaSuffix = strSpace + await LanguageManager.GetStringAsync("String_Karma", strLanguage, token: token).ConfigureAwait(false);
            int intExtraKarmaToRemoveForPointBuyComparison = 0;
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                CharacterSettings objSettings = await GetSettingsAsync(token).ConfigureAwait(false);
                int intReturn = await objSettings.GetBuildKarmaAsync(token).ConfigureAwait(false);

                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdMessage))
                {
                    sbdMessage.AppendLine(await LanguageManager.GetStringAsync("Message_KarmaValue", strLanguage, token: token).ConfigureAwait(false))
                        .AppendLine()
                        .Append(await LanguageManager.GetStringAsync("Label_Base", strLanguage, token: token).ConfigureAwait(false))
                        .Append(strColonCharacter, strSpace, intReturn.ToString(objCulture), strKarmaSuffix);

                    if (await GetEffectiveBuildMethodUsesPriorityTablesAsync(token).ConfigureAwait(false))
                    {
                        // Karma value of all qualities (we're ignoring metatype cost because Point Buy karma costs don't line up with other methods' values)
                        int intMetatypeQualitiesValue = await (await GetQualitiesAsync(token).ConfigureAwait(false)).SumAsync(async objQuality =>
                        {
                            if (objQuality.OriginSource == QualitySource.Metatype
                                || objQuality.OriginSource == QualitySource.MetatypeRemovable)
                            {
                                XPathNavigator xmlQualityNode = await objQuality.GetNodeXPathAsync(token: token).ConfigureAwait(false);
                                if (xmlQualityNode == null)
                                    return 0;
                                int intLoopKarma = 0;
                                if (xmlQualityNode.TryGetInt32FieldQuickly("karma", ref intLoopKarma))
                                    return intLoopKarma;
                            }
                            return 0;
                        }, token).ConfigureAwait(false);

                        // Subtract extra karma cost of a metatype in priority
                        int intMetatypePriorityKarmaCost = -await GetMetatypeBPAsync(token).ConfigureAwait(false);
                        // For point buy comparisons, we need to use the metatype's Point Buy cost for the comparison, not attributes + metatype qualities.
                        intExtraKarmaToRemoveForPointBuyComparison += intMetatypePriorityKarmaCost + intMetatypeQualitiesValue;
                        int intAttributesValue = 0;
                        // Zeroed to -10 because that's Human's value at default settings
                        int intMetatypeExtraAttributesValue = -2 * await objSettings.GetKarmaAttributeAsync(token).ConfigureAwait(false);
                        intExtraKarmaToRemoveForPointBuyComparison += intMetatypeExtraAttributesValue;
                        // Value from attribute points and raised attribute minimums
                        foreach (CharacterAttrib objLoopAttrib in AttributeSection.AllAttributes)
                        {
                            string strAttributeName = objLoopAttrib.Abbrev;
                            if (strAttributeName != "ESS" &&
                                (strAttributeName != "MAGAdept"
                                 || (await GetIsMysticAdeptAsync(token).ConfigureAwait(false) && await objSettings.GetMysAdeptSecondMAGAttributeAsync(token).ConfigureAwait(false)))
                                &&
                                await objLoopAttrib.GetMetatypeMaximumAsync(token).ConfigureAwait(false) > 0)
                            {
                                int intLoopAttribValue
                                    = await objLoopAttrib.GetAttributeValueModifiersAsync(token).ConfigureAwait(false)
                                      + Math.Max(
                                          objLoopAttrib.Base
                                          + await objLoopAttrib.GetFreeBaseAsync(token).ConfigureAwait(false)
                                          + await objLoopAttrib.GetRawMinimumAsync(token).ConfigureAwait(false),
                                          await objLoopAttrib.GetTotalMinimumAsync(token).ConfigureAwait(false));
                                if (intLoopAttribValue > 1)
                                {
                                    bool blnIsRegularAttribute
                                        = strAttributeName != "MAG" && strAttributeName != "MAGAdept" &&
                                          strAttributeName != "RES" && strAttributeName != "DEP";
                                    intMetatypeExtraAttributesValue += ((intLoopAttribValue + 1) * intLoopAttribValue / 2 - 1)
                                                                       * await objSettings.GetKarmaAttributeAsync(token).ConfigureAwait(false);
                                    if (blnIsRegularAttribute)
                                    {
                                        int intMetatypeMinimumDelta = await objLoopAttrib.GetMetatypeMinimumAsync(token)
                                            .ConfigureAwait(false) - 1;
                                        int intVanillaAttribValue
                                            = await objLoopAttrib.GetAttributeValueModifiersAsync(token)
                                                                 .ConfigureAwait(false) + Math.Max(
                                                objLoopAttrib.Base
                                                + await objLoopAttrib.GetFreeBaseAsync(token).ConfigureAwait(false)
                                                + await objLoopAttrib.GetRawMinimumAsync(token).ConfigureAwait(false)
                                                - intMetatypeMinimumDelta,
                                                await objLoopAttrib.GetTotalMinimumAsync(token).ConfigureAwait(false)
                                                - intMetatypeMinimumDelta);
                                        intAttributesValue
                                            += ((intVanillaAttribValue + 1) * intVanillaAttribValue / 2 - 1) *
                                               await objSettings.GetKarmaAttributeAsync(token).ConfigureAwait(false);
                                    }
                                    else
                                        intAttributesValue += ((intLoopAttribValue + 1) * intLoopAttribValue / 2 - 1) *
                                                              await objSettings.GetKarmaAttributeAsync(token).ConfigureAwait(false);

                                    // Separately calculate and apply Point Buy calculation modification from higher metatype minima
                                    if (blnIsRegularAttribute)
                                    {
                                        // All non-regular attributes are forced to start at 0 or 1 anyway, so while it is hacky to
                                        // only consider regular attributes, it is what makes the math work 99% of the time, and
                                        // handling non-regular attributes in a special way would be too complicated in Chummer's setup.
                                        int intMetatypeBaseAttribValue = await objLoopAttrib
                                                                               .GetMetatypeMinimumAsync(token)
                                                                               .ConfigureAwait(false);
                                        if (intMetatypeBaseAttribValue > 1)
                                        {
                                            intExtraKarmaToRemoveForPointBuyComparison
                                                += ((intMetatypeBaseAttribValue + 1) * intMetatypeBaseAttribValue / 2
                                                    - 1) * await objSettings.GetKarmaAttributeAsync(token)
                                                                            .ConfigureAwait(false);
                                        }
                                    }
                                }
                            }
                        }

                        intMetatypeExtraAttributesValue -= intAttributesValue;

                        if (intMetatypePriorityKarmaCost + intMetatypeExtraAttributesValue + intMetatypeQualitiesValue != 0)
                        {
                            sbdMessage.AppendLine()
                                      .Append(await LanguageManager.GetStringAsync("Label_SumtoTenHeritage", strLanguage, token: token).ConfigureAwait(false))
                                      .Append(strSpace, (intMetatypePriorityKarmaCost + intMetatypeExtraAttributesValue + intMetatypeQualitiesValue).ToString(
                                                  objCulture), strKarmaSuffix);
                            intReturn += intMetatypePriorityKarmaCost + intMetatypeExtraAttributesValue
                                                                      + intMetatypeQualitiesValue;
                        }

                        if (intAttributesValue != 0)
                        {
                            sbdMessage.AppendLine()
                                      .Append(await LanguageManager.GetStringAsync("Label_SumtoTenAttributes", strLanguage, token: token).ConfigureAwait(false))
                                      .Append(strSpace, intAttributesValue.ToString(objCulture), strKarmaSuffix);
                            intReturn += intAttributesValue;
                        }

                        // Karma needs to be added based on the character's metatype/metavariant Point Buy karma cost because that is what is used in Point Buy,
                        // not the metatype/metavariant attribute/quality costs.
                        int intTemp = 0;
                        if ((await this.GetNodeXPathAsync(token: token).ConfigureAwait(false))?.TryGetInt32FieldQuickly("karma", ref intTemp) == true)
                            intExtraKarmaToRemoveForPointBuyComparison -= intTemp;

                        // This is where "Talent" qualities like Adept and Technomancer get added in
                        int intTalentPriorityQualitiesKarma
                            = await (await GetQualitiesAsync(token).ConfigureAwait(false)).SumAsync(
                                objQuality => objQuality.OriginSource == QualitySource.Heritage, async objQuality =>
                                {
                                    XPathNavigator xmlQualityNode
                                        = await objQuality.GetNodeXPathAsync(token: token).ConfigureAwait(false);
                                    if (xmlQualityNode == null)
                                        return 0;
                                    int intLoopKarma = 0;
                                    xmlQualityNode.TryGetInt32FieldQuickly("karma", ref intLoopKarma);
                                    return intLoopKarma;
                                }, token).ConfigureAwait(false);

                        if (intTalentPriorityQualitiesKarma != 0)
                        {
                            sbdMessage.AppendLine()
                                .Append(await LanguageManager.GetStringAsync("String_Qualities", strLanguage, token: token).ConfigureAwait(false))
                                .Append(strColonCharacter, strSpace, intTalentPriorityQualitiesKarma.ToString(objCulture), strKarmaSuffix);
                            intReturn += intTalentPriorityQualitiesKarma;
                        }

                        // Value from free spells
                        int intFreeSpellsKarma = await GetFreeSpellsAsync(token).ConfigureAwait(false) * await SpellKarmaCostAsync("Spells", token).ConfigureAwait(false);
                        if (intFreeSpellsKarma != 0)
                        {
                            sbdMessage.AppendLine().Append(await LanguageManager.GetStringAsync("String_FreeSpells", strLanguage, token: token).ConfigureAwait(false))
                                      .Append(strColonCharacter, strSpace, intFreeSpellsKarma.ToString(objCulture), strKarmaSuffix);
                            intReturn += intFreeSpellsKarma;
                        }

                        // Value from free complex forms
                        int intFreeCFsKarma = await GetCFPLimitAsync(token).ConfigureAwait(false) * await GetComplexFormKarmaCostAsync(token).ConfigureAwait(false);
                        if (intFreeCFsKarma != 0)
                        {
                            sbdMessage.AppendLine().Append(await LanguageManager.GetStringAsync("String_FreeCFs", strLanguage, token: token).ConfigureAwait(false))
                                      .Append(strColonCharacter, strSpace, intFreeCFsKarma.ToString(objCulture), strKarmaSuffix);
                            intReturn += intFreeCFsKarma;
                        }

                        int intSkillPointsKarma = 0;
                        // Value from skill points
                        await (await (await GetSkillsSectionAsync(token).ConfigureAwait(false)).GetSkillsAsync(token).ConfigureAwait(false)).ForEachAsync(async objLoopActiveSkill =>
                        {
                            SkillGroup objLoopGroup = objLoopActiveSkill.SkillGroupObject;
                            if (objLoopGroup == null || await objLoopGroup.GetBaseAsync(token).ConfigureAwait(false) <= 0)
                            {
                                int intLoopRating = await objLoopActiveSkill.GetBaseAsync(token).ConfigureAwait(false);
                                if (intLoopRating > 0)
                                {
                                    intSkillPointsKarma += await objSettings.GetKarmaNewActiveSkillAsync(token)
                                                                            .ConfigureAwait(false);
                                    intSkillPointsKarma += ((intLoopRating + 1) * intLoopRating / 2 - 1)
                                                           * await objSettings.GetKarmaImproveActiveSkillAsync(token)
                                                                              .ConfigureAwait(false);
                                    if (await GetEffectiveBuildMethodIsLifeModuleAsync(token).ConfigureAwait(false))
                                        intSkillPointsKarma
                                            += await (await objLoopActiveSkill.GetSpecializationsAsync(token).ConfigureAwait(false))
                                                                       .CountAsync(x => x.GetFreeAsync(token), token: token)
                                                                       .ConfigureAwait(false) *
                                               await objSettings.GetKarmaSpecializationAsync(token)
                                                                .ConfigureAwait(false);
                                    else if (!await objLoopActiveSkill.GetBuyWithKarmaAsync(token)
                                                                      .ConfigureAwait(false))
                                        intSkillPointsKarma += objLoopActiveSkill.Specializations.Count
                                                               * await objSettings.GetKarmaSpecializationAsync(token)
                                                                   .ConfigureAwait(false);
                                }
                            }
                        }, token).ConfigureAwait(false);

                        if (intSkillPointsKarma != 0)
                        {
                            sbdMessage.AppendLine().Append(await LanguageManager.GetStringAsync("String_SkillPoints", strLanguage, token: token).ConfigureAwait(false))
                                      .Append(strColonCharacter, strSpace, intSkillPointsKarma.ToString(objCulture), strKarmaSuffix);
                            intReturn += intSkillPointsKarma;
                        }

                        int intSkillGroupPointsKarma = 0;
                        // Value from skill group points
                        await (await (await GetSkillsSectionAsync(token).ConfigureAwait(false)).GetSkillGroupsAsync(token).ConfigureAwait(false)).ForEachAsync(async objLoopGroup =>
                        {
                            int intLoopRating = await objLoopGroup.GetBaseAsync(token).ConfigureAwait(false);
                            if (intLoopRating <= 0)
                                return;
                            intSkillGroupPointsKarma
                                += await objSettings.GetKarmaNewSkillGroupAsync(token).ConfigureAwait(false);
                            intSkillGroupPointsKarma += ((intLoopRating + 1) * intLoopRating / 2 - 1)
                                                        * await objSettings.GetKarmaImproveSkillGroupAsync(token)
                                                                           .ConfigureAwait(false);
                        }, token).ConfigureAwait(false);

                        if (intSkillGroupPointsKarma != 0)
                        {
                            sbdMessage.AppendLine()
                                      .Append(await LanguageManager.GetStringAsync("String_SkillGroupPoints", strLanguage, token: token).ConfigureAwait(false))
                                      .Append(strColonCharacter, strSpace, intSkillGroupPointsKarma.ToString(objCulture), strKarmaSuffix);
                            intReturn += intSkillGroupPointsKarma;
                        }

                        // Starting Nuyen karma value
                        decimal decBaseStartingNuyen
                            = await CalculateStartingNuyenFromKarmaAsync(Math.Min(await GetNuyenBPAsync(token).ConfigureAwait(false), await GetTotalNuyenMaximumBPAsync(token).ConfigureAwait(false)), await GetStartingNuyenAsync(token).ConfigureAwait(false), token).ConfigureAwait(false);
                        if (decBaseStartingNuyen != 0)
                        {
                            // Start off with the negative value of the karma we put into nuyen to make this calculation work properly for weird, nonlinear scaling
                            int intNuyenKarma = -Math.Min(await GetNuyenBPAsync(token).ConfigureAwait(false), await GetTotalNuyenMaximumBPAsync(token).ConfigureAwait(false)).ToInt32();
                            // This looks horrible, but we cannot use binary search or calculate karma value directly because XPath expressions are so free-form
                            // The only option is to loop through every possible Karma value until we find the lowest one that gives more nuyen than Priority gives
                            for (int i = 0; i < int.MaxValue; ++i)
                            {
                                decimal decLoopNuyen = await CalculateStartingNuyenFromKarmaAsync(i, 0, token).ConfigureAwait(false);
                                // This looks quite wonky when what we're actually looking for is the exact value, but effectively rounds karma requirements up in cases where Nuyen doesn't divide cleanly
                                if (decLoopNuyen >= decBaseStartingNuyen)
                                {
                                    intNuyenKarma += i;
                                    break;
                                }
                            }

                            if (intNuyenKarma != 0)
                            {
                                sbdMessage.AppendLine()
                                          .Append(await LanguageManager.GetStringAsync("Checkbox_CreatePACKSKit_StartingNuyen",
                                                      strLanguage, token: token).ConfigureAwait(false))
                                          .Append(strColonCharacter, strSpace, intNuyenKarma.ToString(objCulture), strKarmaSuffix);
                                intReturn += intNuyenKarma;
                            }
                        }
                    }

                    int intContactPointsValue = await GetContactPointsAsync(token).ConfigureAwait(false) * await objSettings.GetKarmaContactAsync(token).ConfigureAwait(false);
                    if (intContactPointsValue != 0)
                    {
                        sbdMessage.AppendLine().Append(await LanguageManager.GetStringAsync("String_Contacts", strLanguage, token: token).ConfigureAwait(false))
                                  .Append(strColonCharacter, strSpace, intContactPointsValue.ToString(objCulture), strKarmaSuffix);
                        intReturn += intContactPointsValue;
                        intExtraKarmaToRemoveForPointBuyComparison += intContactPointsValue;
                    }

                    int intKnowledgePointsValue = 0;
                    await (await (await GetSkillsSectionAsync(token).ConfigureAwait(false)).GetKnowledgeSkillsAsync(token).ConfigureAwait(false)).ForEachAsync(
                        async objLoopKnowledgeSkill =>
                        {
                            int intLoopRating = await objLoopKnowledgeSkill.GetBaseAsync(token).ConfigureAwait(false);
                            if (intLoopRating > 0)
                            {
                                intKnowledgePointsValue += await objSettings.GetKarmaNewKnowledgeSkillAsync(token)
                                                                            .ConfigureAwait(false);
                                intKnowledgePointsValue += ((intLoopRating + 1) * intLoopRating / 2 - 1) *
                                                           await objSettings.GetKarmaImproveKnowledgeSkillAsync(token)
                                                                            .ConfigureAwait(false);
                                if (await GetEffectiveBuildMethodIsLifeModuleAsync(token).ConfigureAwait(false))
                                    intKnowledgePointsValue
                                        += await (await objLoopKnowledgeSkill.GetSpecializationsAsync(token).ConfigureAwait(false)).CountAsync(x => x.GetFreeAsync(token), token)
                                                                      .ConfigureAwait(false) *
                                           await objSettings.GetKarmaKnowledgeSpecializationAsync(token)
                                                            .ConfigureAwait(false);
                                else if (!await objLoopKnowledgeSkill.GetBuyWithKarmaAsync(token).ConfigureAwait(false))
                                    intKnowledgePointsValue += objLoopKnowledgeSkill.Specializations.Count *
                                                               await objSettings
                                                                     .GetKarmaKnowledgeSpecializationAsync(token)
                                                                     .ConfigureAwait(false);
                            }
                        }, token).ConfigureAwait(false);

                    if (intKnowledgePointsValue != 0)
                    {
                        sbdMessage.AppendLine().Append(await LanguageManager.GetStringAsync("Label_KnowledgeSkills", strLanguage, token: token).ConfigureAwait(false))
                                  .Append(strColonCharacter, strSpace, intKnowledgePointsValue.ToString(objCulture), strKarmaSuffix);
                        intReturn += intKnowledgePointsValue;
                        intExtraKarmaToRemoveForPointBuyComparison += intKnowledgePointsValue;
                    }

                    sbdMessage.AppendLine().AppendLine().Append(await LanguageManager.GetStringAsync("String_Total", strLanguage, token: token).ConfigureAwait(false))
                              .Append(strColonCharacter, strSpace, intReturn.ToString(objCulture), strSpace).AppendLine(strKarmaSuffix).AppendLine()
                              .Append(await LanguageManager.GetStringAsync("String_TotalComparisonWithPointBuy", strLanguage, token: token).ConfigureAwait(false))
                              .Append(strColonCharacter, strSpace, (intReturn - intExtraKarmaToRemoveForPointBuyComparison).ToString(
                                          objCulture), strKarmaSuffix);

                    return new ValueTuple<string, int>(sbdMessage.ToString(), intReturn);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Creates a list of keywords for each category of an XML node. Used to preselect whether items of that category are discounted by the Black Market Pipeline quality.
        /// </summary>
        public IEnumerable<string> GenerateBlackMarketMappings(XPathNavigator xmlCategoryList, CancellationToken token = default)
        {
            if (xmlCategoryList == null)
                yield break;
            using (LockObject.EnterReadLock(token))
            {
                // Character has no Black Market discount qualities. Fail out early.
                if (!BlackMarketDiscount)
                    yield break;
                // if the passed list is still the root, assume we're looking for default categories. Special cases like vehicle modcategories are expected to be passed through by the parameter.
                if (xmlCategoryList.Name == "chummer")
                {
                    xmlCategoryList = xmlCategoryList.SelectSingleNodeAndCacheExpression("categories", token);
                    if (xmlCategoryList == null)
                        yield break;
                }

                // Get all the improved names of the Black Market Pipeline improvements. In most cases this should only be 1 item, but supports custom content.
                using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                out HashSet<string> setNames))
                {
                    foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                 this, Improvement.ImprovementType.BlackMarketDiscount, token: token))
                    {
                        setNames.Add(objImprovement.ImprovedName);
                    }

                    // For each category node, split the comma-separated blackmarket attribute (if present on the node), then add each category where any of those items matches a Black Market Pipeline improvement.
                    foreach (XPathNavigator xmlCategoryNode in xmlCategoryList.SelectAndCacheExpression("category", token))
                    {
                        string strBlackMarketAttribute
                            = xmlCategoryNode.SelectSingleNodeAndCacheExpression("@blackmarket", token)?.Value;
                        if (!string.IsNullOrEmpty(strBlackMarketAttribute) &&
                            strBlackMarketAttribute.SplitNoAlloc(',', StringSplitOptions.RemoveEmptyEntries)
                                                   .Any(x => setNames.Contains(x)))
                        {
                            yield return xmlCategoryNode.Value;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Creates a list of keywords for each category of an XML node. Used to preselect whether items of that category are discounted by the Black Market Pipeline quality.
        /// </summary>
        public async Task<List<string>> GenerateBlackMarketMappingsAsync(XPathNavigator xmlCategoryList, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            List<string> lstReturn;
            if (xmlCategoryList == null)
                return new List<string>();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                // Character has no Black Market discount qualities. Fail out early.
                if (!BlackMarketDiscount)
                    return new List<string>();
                // if the passed list is still the root, assume we're looking for default categories. Special cases like vehicle modcategories are expected to be passed through by the parameter.
                if (xmlCategoryList.Name == "chummer")
                {
                    xmlCategoryList = xmlCategoryList.SelectSingleNodeAndCacheExpression("categories", token);
                    if (xmlCategoryList == null)
                        return new List<string>();
                }

                // Get all the improved names of the Black Market Pipeline improvements. In most cases this should only be 1 item, but supports custom content.
                using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                out HashSet<string> setNames))
                {
                    foreach (Improvement objImprovement in await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                 this, Improvement.ImprovementType.BlackMarketDiscount, token: token).ConfigureAwait(false))
                    {
                        setNames.Add(objImprovement.ImprovedName);
                    }

                    XPathNodeIterator lstCategories = xmlCategoryList.SelectAndCacheExpression("category", token);
                    lstReturn = new List<string>(lstCategories.Count);

                    // For each category node, split the comma-separated blackmarket attribute (if present on the node), then add each category where any of those items matches a Black Market Pipeline improvement.
                    foreach (XPathNavigator xmlCategoryNode in lstCategories)
                    {
                        string strBlackMarketAttribute
                            = xmlCategoryNode.SelectSingleNodeAndCacheExpression("@blackmarket", token)?.Value;
                        if (!string.IsNullOrEmpty(strBlackMarketAttribute) &&
                            strBlackMarketAttribute.SplitNoAlloc(',', StringSplitOptions.RemoveEmptyEntries)
                                                   .Any(x => setNames.Contains(x)))
                        {
                            lstReturn.Add(xmlCategoryNode.Value);
                        }
                    }
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
            return lstReturn;
        }

        /// <summary>
        /// Book code (using the translated version if applicable) using the character's data files.
        /// </summary>
        /// <param name="strAltCode">Book code to search for.</param>
        /// <param name="strLanguage">Language to load.</param>
        public string LanguageBookCodeFromAltCode(string strAltCode, string strLanguage = "")
        {
            return CommonFunctions.LanguageBookCodeFromAltCode(strAltCode, strLanguage, this.Settings);
        }

        /// <summary>
        /// Book code (using the translated version if applicable) using the character's data files.
        /// </summary>
        /// <param name="strAltCode">Book code to search for.</param>
        /// <param name="strLanguage">Language to load.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public async Task<string> LanguageBookCodeFromAltCodeAsync(string strAltCode, string strLanguage = "", CancellationToken token = default)
        {
            return await CommonFunctions.LanguageBookCodeFromAltCodeAsync(strAltCode, strLanguage, await this.GetSettingsAsync(token).ConfigureAwait(false), token).ConfigureAwait(false);
        }

        /// <summary>
        /// Book code (using the translated version if applicable) using the character's data files.
        /// </summary>
        /// <param name="strCode">Book code to search for.</param>
        /// <param name="strLanguage">Language to load.</param>
        public string LanguageBookShort(string strCode, string strLanguage = "")
        {
            return CommonFunctions.LanguageBookShort(strCode, strLanguage, this.Settings);
        }

        /// <summary>
        /// Book code (using the translated version if applicable) using the character's data files.
        /// </summary>
        /// <param name="strCode">Book code to search for.</param>
        /// <param name="strLanguage">Language to load.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public async Task<string> LanguageBookShortAsync(string strCode, string strLanguage = "", CancellationToken token = default)
        {
            return await CommonFunctions.LanguageBookShortAsync(strCode, strLanguage, await this.GetSettingsAsync(token).ConfigureAwait(false), token).ConfigureAwait(false);
        }

        /// <summary>
        /// Book name (using the translated version if applicable) using the character's data files.
        /// </summary>
        /// <param name="strCode">Book code to search for.</param>
        /// <param name="strLanguage">Language to load.</param>
        public string LanguageBookLong(string strCode, string strLanguage = "")
        {
            return CommonFunctions.LanguageBookLong(strCode, strLanguage, this.Settings);
        }

        /// <summary>
        /// Book name (using the translated version if applicable) using the character's data files.
        /// </summary>
        /// <param name="strCode">Book code to search for.</param>
        /// <param name="strLanguage">Language to load.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public async Task<string> LanguageBookLongAsync(string strCode, string strLanguage = "", CancellationToken token = default)
        {
            return await CommonFunctions.LanguageBookLongAsync(strCode, strLanguage, await this.GetSettingsAsync(token).ConfigureAwait(false), token).ConfigureAwait(false);
        }

        /// <summary>
        /// Attempt to translate any Extra text for an item using the character's data files.
        /// </summary>
        /// <param name="strExtra">Extra string to translate.</param>
        /// <param name="strIntoLanguage">Language into which the string should be translated</param>
        /// <param name="strPreferFile">Name of a file to prefer for extras before all others.</param>
        /// <param name="token">CancellationToken to use.</param>
        public string TranslateExtra(string strExtra, string strIntoLanguage = "", string strPreferFile = "", CancellationToken token = default)
        {
            return LanguageManager.TranslateExtra(strExtra, strIntoLanguage, this, strPreferFile, token);
        }

        /// <summary>
        /// Attempt to translate any Extra text for an item using the character's data files.
        /// </summary>
        /// <param name="strExtra">Extra string to translate.</param>
        /// <param name="strIntoLanguage">Language into which the string should be translated</param>
        /// <param name="strPreferFile">Name of a file to prefer for extras before all others.</param>
        /// <param name="token">CancellationToken to use.</param>
        public Task<string> TranslateExtraAsync(string strExtra, string strIntoLanguage = "", string strPreferFile = "", CancellationToken token = default)
        {
            return LanguageManager.TranslateExtraAsync(strExtra, strIntoLanguage, this, strPreferFile, token);
        }

        /// <summary>
        /// Attempt to translate any Extra text for an item from a foreign language to the default one using the character's data files.
        /// </summary>
        /// <param name="strExtra">Extra string to translate.</param>
        /// <param name="strFromLanguage">Language from which the string should be translated</param>
        /// <param name="strPreferFile">Name of a file to prefer for extras before all others.</param>
        /// <param name="token">CancellationToken to use.</param>
        public string ReverseTranslateExtra(string strExtra, string strFromLanguage = "", string strPreferFile = "", CancellationToken token = default)
        {
            return LanguageManager.ReverseTranslateExtra(strExtra, strFromLanguage, this, strPreferFile, token);
        }

        /// <summary>
        /// Attempt to translate any Extra text for an item from a foreign language to the default one using the character's data files.
        /// </summary>
        /// <param name="strExtra">Extra string to translate.</param>
        /// <param name="strFromLanguage">Language from which the string should be translated</param>
        /// <param name="strPreferFile">Name of a file to prefer for extras before all others.</param>
        /// <param name="token">CancellationToken to use.</param>
        public Task<string> ReverseTranslateExtraAsync(string strExtra, string strFromLanguage = "", string strPreferFile = "", CancellationToken token = default)
        {
            return LanguageManager.ReverseTranslateExtraAsync(strExtra, strFromLanguage, this, strPreferFile, token);
        }

        #endregion Helper Methods

        #region UI Methods

        #region Move TreeNodes

        /// <summary>
        /// Move a Gear TreeNode after Drag and Drop, changing its parent.
        /// </summary>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="objGearNode">Node of gear to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public void MoveGearParent(TreeNode objDestination, TreeNode objGearNode, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (objGearNode == null || objDestination == null)
                return;
            // The item cannot be dropped onto itself or onto one of its children.
            for (TreeNode objCheckNode = objDestination;
                objCheckNode != null && objCheckNode.Level >= objDestination.Level;
                objCheckNode = objCheckNode.Parent)
                if (objCheckNode == objGearNode)
                    return;
            if (!(objGearNode.Tag is Gear objGear))
                return;

            // Gear cannot be moved to one if its children.
            bool blnAllowMove = true;
            if (objDestination.Level > 0)
            {
                TreeNode objFindNode = objDestination;
                do
                {
                    objFindNode = objFindNode.Parent;
                    if (objFindNode.Tag == objGear)
                    {
                        blnAllowMove = false;
                        break;
                    }
                } while (objFindNode.Level > 0);
            }

            if (!blnAllowMove)
                return;

            using (LockObject.EnterUpgradeableReadLock(token))
            {
                // Remove the Gear from the character.
                if (objGear.Parent is IHasChildren<Gear> parent)
                    parent.Children.Remove(objGear);
                else
                    Gear.Remove(objGear);

                switch (objDestination.Tag)
                {
                    case Location objLocation:
                        // The Gear was moved to a location, so add it to the character instead.
                        objGear.Location = objLocation;
                        objLocation.Children.Add(objGear);
                        Gear.Add(objGear);
                        break;

                    case Gear objParent:
                        // Add the Gear as a child of the destination Node and clear its location.
                        objGear.Location = null;
                        objParent.Children.Add(objGear);
                        break;
                }
            }
        }

        /// <summary>
        /// Move a Gear TreeNode after Drag and Drop, changing its parent.
        /// </summary>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="objGearNode">Node of gear to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public async Task MoveGearParentAsync(TreeNode objDestination, TreeNode objGearNode, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (objGearNode == null || objDestination == null)
                return;
            // The item cannot be dropped onto itself or onto one of its children.
            for (TreeNode objCheckNode = objDestination;
                objCheckNode != null && objCheckNode.Level >= objDestination.Level;
                objCheckNode = objCheckNode.Parent)
                if (objCheckNode == objGearNode)
                    return;
            if (!(objGearNode.Tag is Gear objGear))
                return;

            // Gear cannot be moved to one if its children.
            bool blnAllowMove = true;
            if (objDestination.Level > 0)
            {
                TreeNode objFindNode = objDestination;
                do
                {
                    objFindNode = objFindNode.Parent;
                    if (objFindNode.Tag == objGear)
                    {
                        blnAllowMove = false;
                        break;
                    }
                } while (objFindNode.Level > 0);
            }

            if (!blnAllowMove)
                return;

            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                // Remove the Gear from the character.
                if (objGear.Parent is IHasChildren<Gear> parent)
                    await parent.Children.RemoveAsync(objGear, token).ConfigureAwait(false);
                else
                    await Gear.RemoveAsync(objGear, token).ConfigureAwait(false);

                switch (objDestination.Tag)
                {
                    case Location objLocation:
                        // The Gear was moved to a location, so add it to the character instead.
                        objGear.Location = objLocation;
                        await objLocation.Children.AddAsync(objGear, token).ConfigureAwait(false);
                        await Gear.AddAsync(objGear, token).ConfigureAwait(false);
                        break;

                    case Gear objParent:
                        // Add the Gear as a child of the destination Node and clear its location.
                        objGear.Location = null;
                        await objParent.Children.AddAsync(objGear, token).ConfigureAwait(false);
                        break;
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Move a Gear TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodeToMove">Node of gear to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public void MoveGearNode(int intNewIndex, TreeNode objDestination, TreeNode nodeToMove, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (objDestination == null || nodeToMove == null)
                return;
            if (!(nodeToMove.Tag is Gear objGear))
                return;
            TreeNode objNewParent = objDestination;
            while (objNewParent.Level > 0 && !(objNewParent.Tag is Location))
                objNewParent = objNewParent.Parent;

            using (LockObject.EnterUpgradeableReadLock(token))
            {
                switch (objNewParent.Tag)
                {
                    case Location objLocation:
                        if (nodeToMove.TreeView != null)
                            nodeToMove.TreeView.DoThreadSafe(nodeToMove.Remove, token);
                        else
                            nodeToMove.Remove();
                        objGear.Location = objLocation;
                        if (objNewParent.TreeView != null)
                            objNewParent.TreeView.DoThreadSafe(() => objNewParent.Nodes.Insert(0, nodeToMove), token);
                        else
                            objNewParent.Nodes.Insert(0, nodeToMove);
                        break;

                    case string _:
                        objGear.Location = null;
                        intNewIndex = Math.Min(intNewIndex, Gear.Count - 1);
                        Gear.Move(Gear.IndexOf(objGear), intNewIndex);
                        break;
                }
            }
        }

        /// <summary>
        /// Move a Gear TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodeToMove">Node of gear to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public async Task MoveGearNodeAsync(int intNewIndex, TreeNode objDestination, TreeNode nodeToMove, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (objDestination == null || nodeToMove == null)
                return;
            if (!(nodeToMove.Tag is Gear objGear))
                return;
            TreeNode objNewParent = objDestination;
            while (objNewParent.Level > 0 && !(objNewParent.Tag is Location))
                objNewParent = objNewParent.Parent;

            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                switch (objNewParent.Tag)
                {
                    case Location objLocation:
                        if (nodeToMove.TreeView != null)
                            await nodeToMove.TreeView.DoThreadSafeAsync(nodeToMove.Remove, token).ConfigureAwait(false);
                        else
                            nodeToMove.Remove();
                        objGear.Location = objLocation;
                        if (objNewParent.TreeView != null)
                            await objNewParent.TreeView.DoThreadSafeAsync(() =>
                                objNewParent.Nodes.Insert(0, nodeToMove), token).ConfigureAwait(false);
                        else
                            objNewParent.Nodes.Insert(0, nodeToMove);
                        break;

                    case string _:
                        objGear.Location = null;
                        intNewIndex = Math.Min(intNewIndex, await Gear.GetCountAsync(token).ConfigureAwait(false) - 1);
                        await Gear.MoveAsync(await Gear.IndexOfAsync(objGear, token).ConfigureAwait(false), intNewIndex, token).ConfigureAwait(false);
                        break;
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Move a Gear Location TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodOldNode">Node of gear location to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public void MoveGearRoot(int intNewIndex, TreeNode objDestination, TreeNode nodOldNode, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (!(nodOldNode?.Tag is Location objLocation))
                return;
            if (objDestination != null)
            {
                TreeNode objNewParent = objDestination;
                while (objNewParent.Level > 0)
                    objNewParent = objNewParent.Parent;
                intNewIndex = objNewParent.Index;
                if (!(objNewParent.Tag is Location))
                    intNewIndex = 0;
            }
            using (LockObject.EnterUpgradeableReadLock(token))
                GearLocations.Move(GearLocations.IndexOf(objLocation), intNewIndex);
        }

        /// <summary>
        /// Move a Gear Location TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodOldNode">Node of gear location to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public async Task MoveGearRootAsync(int intNewIndex, TreeNode objDestination, TreeNode nodOldNode, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (!(nodOldNode?.Tag is Location objLocation))
                return;
            if (objDestination != null)
            {
                TreeNode objNewParent = objDestination;
                while (objNewParent.Level > 0)
                    objNewParent = objNewParent.Parent;
                intNewIndex = objNewParent.Index;
                if (!(objNewParent.Tag is Location))
                    intNewIndex = 0;
            }
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                await GearLocations.MoveAsync(await GearLocations.IndexOfAsync(objLocation, token).ConfigureAwait(false), intNewIndex, token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Move a Lifestyle TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodLifestyleNode">Node of lifestyle to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public void MoveLifestyleNode(int intNewIndex, TreeNode objDestination, TreeNode nodLifestyleNode, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (nodLifestyleNode == null)
                return;
            if (objDestination != null)
            {
                TreeNode objNewParent = objDestination;
                while (objNewParent.Level > 0)
                    objNewParent = objNewParent.Parent;
                intNewIndex = objNewParent.Index;
            }

            if (!(nodLifestyleNode.Tag is Lifestyle objLifestyle))
                return;
            using (LockObject.EnterUpgradeableReadLock(token))
                Lifestyles.Move(Lifestyles.IndexOf(objLifestyle), intNewIndex);
        }

        /// <summary>
        /// Move a Lifestyle TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodLifestyleNode">Node of lifestyle to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public async Task MoveLifestyleNodeAsync(int intNewIndex, TreeNode objDestination, TreeNode nodLifestyleNode, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (nodLifestyleNode == null)
                return;
            if (objDestination != null)
            {
                TreeNode objNewParent = objDestination;
                while (objNewParent.Level > 0)
                    objNewParent = objNewParent.Parent;
                intNewIndex = objNewParent.Index;
            }

            if (!(nodLifestyleNode.Tag is Lifestyle objLifestyle))
                return;
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                await Lifestyles.MoveAsync(await Lifestyles.IndexOfAsync(objLifestyle, token).ConfigureAwait(false), intNewIndex, token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Move an Armor TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodeToMove">Node of armor to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public void MoveArmorNode(int intNewIndex, TreeNode objDestination, TreeNode nodeToMove, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (objDestination == null)
                return;
            if (!(nodeToMove?.Tag is Armor objArmor))
                return;
            TreeNode objNewParent = objDestination;
            while (objNewParent.Level > 0 && !(objNewParent.Tag is Location))
                objNewParent = objNewParent.Parent;

            using (LockObject.EnterUpgradeableReadLock(token))
            {
                switch (objNewParent.Tag)
                {
                    case Location objLocation:
                        if (nodeToMove.TreeView != null)
                            nodeToMove.TreeView.DoThreadSafe(nodeToMove.Remove, token);
                        else
                            nodeToMove.Remove();
                        objArmor.Location = objLocation;
                        if (objNewParent.TreeView != null)
                            objNewParent.TreeView.DoThreadSafe(() => objNewParent.Nodes.Insert(0, nodeToMove), token);
                        else
                            objNewParent.Nodes.Insert(0, nodeToMove);
                        break;

                    case string _:
                        objArmor.Location = null;
                        intNewIndex = Math.Min(intNewIndex, Armor.Count - 1);
                        Armor.Move(Armor.IndexOf(objArmor), intNewIndex);
                        break;
                }
            }
        }

        /// <summary>
        /// Move an Armor TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodeToMove">Node of armor to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public async Task MoveArmorNodeAsync(int intNewIndex, TreeNode objDestination, TreeNode nodeToMove, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (objDestination == null)
                return;
            if (!(nodeToMove?.Tag is Armor objArmor))
                return;
            TreeNode objNewParent = objDestination;
            while (objNewParent.Level > 0 && !(objNewParent.Tag is Location))
                objNewParent = objNewParent.Parent;

            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                switch (objNewParent.Tag)
                {
                    case Location objLocation:
                        if (nodeToMove.TreeView != null)
                            await nodeToMove.TreeView.DoThreadSafeAsync(nodeToMove.Remove, token).ConfigureAwait(false);
                        else
                            nodeToMove.Remove();
                        objArmor.Location = objLocation;
                        if (objNewParent.TreeView != null)
                            await objNewParent.TreeView.DoThreadSafeAsync(() => objNewParent.Nodes.Insert(0, nodeToMove), token).ConfigureAwait(false);
                        else
                            objNewParent.Nodes.Insert(0, nodeToMove);
                        break;

                    case string _:
                        objArmor.Location = null;
                        intNewIndex = Math.Min(intNewIndex, await Armor.GetCountAsync(token).ConfigureAwait(false) - 1);
                        await Armor.MoveAsync(await Armor.IndexOfAsync(objArmor, token).ConfigureAwait(false), intNewIndex, token).ConfigureAwait(false);
                        break;
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Move an Armor Location TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodOldNode">Node of armor location to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public void MoveArmorRoot(int intNewIndex, TreeNode objDestination, TreeNode nodOldNode, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (!(nodOldNode?.Tag is Location objLocation))
                return;
            if (objDestination != null)
            {
                TreeNode objNewParent = objDestination;
                while (objNewParent.Level > 0)
                    objNewParent = objNewParent.Parent;
                intNewIndex = objNewParent.Index;
                if (!(objNewParent.Tag is Location))
                    intNewIndex = 0;
            }
            using (LockObject.EnterUpgradeableReadLock(token))
                ArmorLocations.Move(ArmorLocations.IndexOf(objLocation), intNewIndex);
        }

        /// <summary>
        /// Move an Armor Location TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodOldNode">Node of armor location to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public async Task MoveArmorRootAsync(int intNewIndex, TreeNode objDestination, TreeNode nodOldNode, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (!(nodOldNode?.Tag is Location objLocation))
                return;
            if (objDestination != null)
            {
                TreeNode objNewParent = objDestination;
                while (objNewParent.Level > 0)
                    objNewParent = objNewParent.Parent;
                intNewIndex = objNewParent.Index;
                if (!(objNewParent.Tag is Location))
                    intNewIndex = 0;
            }
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                await ArmorLocations.MoveAsync(await ArmorLocations.IndexOfAsync(objLocation, token).ConfigureAwait(false), intNewIndex, token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Move a Weapon TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodeToMove">Node of weapon to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public void MoveWeaponNode(int intNewIndex, TreeNode objDestination, TreeNode nodeToMove, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (objDestination == null)
                return;
            if (!(nodeToMove?.Tag is Weapon objWeapon))
                return;
            TreeNode objNewParent = objDestination;
            while (objNewParent.Level > 0 && !(objNewParent.Tag is Location))
                objNewParent = objNewParent.Parent;

            using (LockObject.EnterUpgradeableReadLock(token))
            {
                switch (objNewParent.Tag)
                {
                    case Location objLocation:
                        if (nodeToMove.TreeView != null)
                            nodeToMove.TreeView.DoThreadSafe(nodeToMove.Remove, token);
                        else
                            nodeToMove.Remove();
                        objWeapon.Location = objLocation;
                        if (objNewParent.TreeView != null)
                            objNewParent.TreeView.DoThreadSafe(() => objNewParent.Nodes.Insert(0, nodeToMove), token);
                        else
                            objNewParent.Nodes.Insert(0, nodeToMove);
                        break;

                    case string _:
                        objWeapon.Location = null;
                        intNewIndex = Math.Min(intNewIndex, Weapons.Count - 1);
                        Weapons.Move(Weapons.IndexOf(objWeapon), intNewIndex);
                        break;
                }
            }
        }

        /// <summary>
        /// Move a Weapon TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodeToMove">Node of weapon to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public async Task MoveWeaponNodeAsync(int intNewIndex, TreeNode objDestination, TreeNode nodeToMove, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (objDestination == null)
                return;
            if (!(nodeToMove?.Tag is Weapon objWeapon))
                return;
            TreeNode objNewParent = objDestination;
            while (objNewParent.Level > 0 && !(objNewParent.Tag is Location))
                objNewParent = objNewParent.Parent;

            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                switch (objNewParent.Tag)
                {
                    case Location objLocation:
                        if (nodeToMove.TreeView != null)
                            await nodeToMove.TreeView.DoThreadSafeAsync(nodeToMove.Remove, token).ConfigureAwait(false);
                        else
                            nodeToMove.Remove();
                        objWeapon.Location = objLocation;
                        if (objNewParent.TreeView != null)
                            await objNewParent.TreeView.DoThreadSafeAsync(() => objNewParent.Nodes.Insert(0, nodeToMove), token).ConfigureAwait(false);
                        else
                            objNewParent.Nodes.Insert(0, nodeToMove);
                        break;

                    case string _:
                        objWeapon.Location = null;
                        intNewIndex = Math.Min(intNewIndex, await Weapons.GetCountAsync(token).ConfigureAwait(false) - 1);
                        await Weapons.MoveAsync(await Weapons.IndexOfAsync(objWeapon, token).ConfigureAwait(false), intNewIndex, token).ConfigureAwait(false);
                        break;
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Move a Weapon Location TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodOldNode">Node of weapon location to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public void MoveWeaponRoot(int intNewIndex, TreeNode objDestination, TreeNode nodOldNode, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (!(nodOldNode?.Tag is Location objLocation))
                return;
            if (objDestination != null)
            {
                TreeNode objNewParent = objDestination;
                while (objNewParent.Level > 0)
                    objNewParent = objNewParent.Parent;
                intNewIndex = objNewParent.Index;
                if (!(objNewParent.Tag is Location))
                    intNewIndex = 0;
            }
            using (LockObject.EnterUpgradeableReadLock(token))
                WeaponLocations.Move(WeaponLocations.IndexOf(objLocation), intNewIndex);
        }

        /// <summary>
        /// Move a Weapon Location TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodOldNode">Node of weapon location to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public async Task MoveWeaponRootAsync(int intNewIndex, TreeNode objDestination, TreeNode nodOldNode, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (!(nodOldNode?.Tag is Location objLocation))
                return;
            if (objDestination != null)
            {
                TreeNode objNewParent = objDestination;
                while (objNewParent.Level > 0)
                    objNewParent = objNewParent.Parent;
                intNewIndex = objNewParent.Index;
                if (!(objNewParent.Tag is Location))
                    intNewIndex = 0;
            }
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                await WeaponLocations.MoveAsync(await WeaponLocations.IndexOfAsync(objLocation, token).ConfigureAwait(false), intNewIndex, token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Move a Vehicle TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodeToMove">Node of vehicle to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public void MoveVehicleNode(int intNewIndex, TreeNode objDestination, TreeNode nodeToMove, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (objDestination == null)
                return;
            if (!(nodeToMove?.Tag is Vehicle objVehicle))
                return;
            TreeNode objNewParent = objDestination;
            while (objNewParent.Level > 0 && !(objNewParent.Tag is Location))
                objNewParent = objNewParent.Parent;

            using (LockObject.EnterUpgradeableReadLock(token))
            {
                switch (objNewParent.Tag)
                {
                    case Location objLocation:
                        if (nodeToMove.TreeView != null)
                            nodeToMove.TreeView.DoThreadSafe(nodeToMove.Remove, token);
                        else
                            nodeToMove.Remove();
                        objVehicle.Location = objLocation;
                        if (objNewParent.TreeView != null)
                            objNewParent.TreeView.DoThreadSafe(() => objNewParent.Nodes.Insert(0, nodeToMove), token);
                        else
                            objNewParent.Nodes.Insert(0, nodeToMove);
                        break;

                    case string _:
                        objVehicle.Location = null;
                        intNewIndex = Math.Min(intNewIndex, Vehicles.Count - 1);
                        Vehicles.Move(Vehicles.IndexOf(objVehicle), intNewIndex);
                        break;
                }
            }
        }

        /// <summary>
        /// Move a Vehicle TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodeToMove">Node of vehicle to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public async Task MoveVehicleNodeAsync(int intNewIndex, TreeNode objDestination, TreeNode nodeToMove, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (objDestination == null)
                return;
            if (!(nodeToMove?.Tag is Vehicle objVehicle))
                return;
            TreeNode objNewParent = objDestination;
            while (objNewParent.Level > 0 && !(objNewParent.Tag is Location))
                objNewParent = objNewParent.Parent;

            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                switch (objNewParent.Tag)
                {
                    case Location objLocation:
                        if (nodeToMove.TreeView != null)
                            await nodeToMove.TreeView.DoThreadSafeAsync(nodeToMove.Remove, token).ConfigureAwait(false);
                        else
                            nodeToMove.Remove();
                        objVehicle.Location = objLocation;
                        if (objNewParent.TreeView != null)
                            await objNewParent.TreeView.DoThreadSafeAsync(() => objNewParent.Nodes.Insert(0, nodeToMove), token).ConfigureAwait(false);
                        else
                            objNewParent.Nodes.Insert(0, nodeToMove);
                        break;

                    case string _:
                        objVehicle.Location = null;
                        intNewIndex = Math.Min(intNewIndex, await Vehicles.GetCountAsync(token).ConfigureAwait(false) - 1);
                        await Vehicles.MoveAsync(await Vehicles.IndexOfAsync(objVehicle, token).ConfigureAwait(false), intNewIndex, token).ConfigureAwait(false);
                        break;
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Move a Vehicle Gear TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="nodDestination">Destination Node.</param>
        /// <param name="nodGearNode">Node of gear to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public void MoveVehicleGearParent(TreeNode nodDestination, TreeNode nodGearNode, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (nodDestination == null || nodGearNode == null)
                return;
            // The item cannot be dropped onto itself or onto one of its children.
            for (TreeNode objCheckNode = nodDestination;
                objCheckNode != null && objCheckNode.Level >= nodDestination.Level;
                objCheckNode = objCheckNode.Parent)
                if (objCheckNode == nodGearNode)
                    return;
            if (!(nodGearNode.Tag is IHasInternalId nodeId))
                return;
            using (LockObject.EnterUpgradeableReadLock(token))
            {
                // Locate the currently selected piece of Gear.
                //TODO: Better interface for determining what the parent of a bit of gear is.
                Gear objGear = Vehicles.FindVehicleGear(nodeId.InternalId, out Vehicle objOldVehicle,
                                                        out WeaponAccessory objOldWeaponAccessory,
                                                        out Cyberware objOldCyberware, token);

                if (objGear == null)
                    return;

                using (LockObject.EnterWriteLock(token))
                {
                    if (nodDestination.Tag is Gear objDestinationGear)
                    {
                        // Remove the Gear from the Vehicle.
                        if (objGear.Parent is IHasChildren<Gear> parent)
                            parent.Children.Remove(objGear);
                        else if (objOldCyberware != null)
                            objOldCyberware.GearChildren.Remove(objGear);
                        else if (objOldWeaponAccessory != null)
                            objOldWeaponAccessory.GearChildren.Remove(objGear);
                        else
                            objOldVehicle.GearChildren.Remove(objGear);

                        // Add the Gear to its new parent.
                        objGear.Location = null;
                        objDestinationGear.Children.Add(objGear);
                    }
                    else
                    {
                        // Determine if this is a Location.
                        TreeNode nodVehicleNode = nodDestination;
                        Location objLocation = null;
                        while (nodVehicleNode.Level > 1)
                        {
                            if (objLocation is null && nodVehicleNode.Tag is Location loc)
                            {
                                objLocation = loc;
                            }

                            nodVehicleNode = nodVehicleNode.Parent;
                        }

                        // Determine if this is a Location in the destination Vehicle.
                        if (nodDestination.Tag is Vehicle objNewVehicle)
                        {
                            // Remove the Gear from the Vehicle.
                            if (objGear.Parent is IHasChildren<Gear> parent)
                                parent.Children.Remove(objGear);
                            else if (objOldCyberware != null)
                                objOldCyberware.GearChildren.Remove(objGear);
                            else if (objOldWeaponAccessory != null)
                                objOldWeaponAccessory.GearChildren.Remove(objGear);
                            else
                                objOldVehicle.GearChildren.Remove(objGear);

                            // Add the Gear to the Vehicle and set its Location.
                            objGear.Parent = objNewVehicle;
                            objNewVehicle.GearChildren.Add(objGear);
                            objLocation?.Children.Add(objGear);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Move a Vehicle Gear TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="nodDestination">Destination Node.</param>
        /// <param name="nodGearNode">Node of gear to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public async Task MoveVehicleGearParentAsync(TreeNode nodDestination, TreeNode nodGearNode, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (nodDestination == null || nodGearNode == null)
                return;
            // The item cannot be dropped onto itself or onto one of its children.
            for (TreeNode objCheckNode = nodDestination;
                objCheckNode != null && objCheckNode.Level >= nodDestination.Level;
                objCheckNode = objCheckNode.Parent)
            {
                if (objCheckNode == nodGearNode)
                    return;
            }

            if (!(nodGearNode.Tag is IHasInternalId nodeId))
                return;
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                // Locate the currently selected piece of Gear.
                //TODO: Better interface for determining what the parent of a bit of gear is.
                (Gear objGear, Vehicle objOldVehicle, WeaponAccessory objOldWeaponAccessory, Cyberware objOldCyberware) = await Vehicles.FindVehicleGearAsync(nodeId.InternalId, token: token).ConfigureAwait(false);

                if (objGear == null)
                    return;

                IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    if (nodDestination.Tag is Gear objDestinationGear)
                    {
                        // Remove the Gear from the Vehicle.
                        if (objGear.Parent is IHasChildren<Gear> parent)
                            await parent.Children.RemoveAsync(objGear, token).ConfigureAwait(false);
                        else if (objOldCyberware != null)
                            await objOldCyberware.GearChildren.RemoveAsync(objGear, token).ConfigureAwait(false);
                        else if (objOldWeaponAccessory != null)
                            await objOldWeaponAccessory.GearChildren.RemoveAsync(objGear, token).ConfigureAwait(false);
                        else
                            await objOldVehicle.GearChildren.RemoveAsync(objGear, token).ConfigureAwait(false);

                        // Add the Gear to its new parent.
                        objGear.Location = null;
                        await objDestinationGear.Children.AddAsync(objGear, token).ConfigureAwait(false);
                    }
                    else
                    {
                        // Determine if this is a Location.
                        TreeNode nodVehicleNode = nodDestination;
                        Location objLocation = null;
                        while (nodVehicleNode.Level > 1)
                        {
                            if (objLocation is null && nodVehicleNode.Tag is Location loc)
                            {
                                objLocation = loc;
                            }

                            nodVehicleNode = nodVehicleNode.Parent;
                        }

                        // Determine if this is a Location in the destination Vehicle.
                        if (nodDestination.Tag is Vehicle objNewVehicle)
                        {
                            // Remove the Gear from the Vehicle.
                            if (objGear.Parent is IHasChildren<Gear> parent)
                                await parent.Children.RemoveAsync(objGear, token).ConfigureAwait(false);
                            else if (objOldCyberware != null)
                                await objOldCyberware.GearChildren.RemoveAsync(objGear, token).ConfigureAwait(false);
                            else if (objOldWeaponAccessory != null)
                                await objOldWeaponAccessory.GearChildren.RemoveAsync(objGear, token).ConfigureAwait(false);
                            else
                                await objOldVehicle.GearChildren.RemoveAsync(objGear, token).ConfigureAwait(false);

                            // Add the Gear to the Vehicle and set its Location.
                            objGear.Parent = objNewVehicle;
                            await objNewVehicle.GearChildren.AddAsync(objGear, token).ConfigureAwait(false);
                            if (objLocation != null)
                                await objLocation.Children.AddAsync(objGear, token).ConfigureAwait(false);
                        }
                    }
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Move an Improvement TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodOldNode">Node of improvement to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public void MoveImprovementNode(TreeNode objDestination, TreeNode nodOldNode, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (objDestination == null)
                return;
            if (!(nodOldNode?.Tag is Improvement objImprovement))
                return;
            TreeNode objNewParent = objDestination;
            while (objNewParent.Level > 0)
                objNewParent = objNewParent.Parent;
            string strGroup = objNewParent.Tag?.ToString() ?? string.Empty;
            if (!string.IsNullOrEmpty(strGroup) && strGroup != "Node_SelectedImprovements")
                strGroup = objNewParent.Text;
            using (LockObject.EnterWriteLock(token))
            {
                objImprovement.CustomGroup = strGroup;
                Improvements[Improvements.IndexOf(objImprovement)] = objImprovement;
            }
        }

        /// <summary>
        /// Move an Improvement TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodOldNode">Node of improvement to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public async Task MoveImprovementNodeAsync(TreeNode objDestination, TreeNode nodOldNode, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (objDestination == null)
                return;
            if (!(nodOldNode?.Tag is Improvement objImprovement))
                return;
            TreeNode objNewParent = objDestination;
            while (objNewParent.Level > 0)
                objNewParent = objNewParent.Parent;
            string strGroup = objNewParent.Tag?.ToString() ?? string.Empty;
            if (!string.IsNullOrEmpty(strGroup) && strGroup != "Node_SelectedImprovements")
                strGroup = objNewParent.Text;
            IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                objImprovement.CustomGroup = strGroup;
                await Improvements.SetValueAtAsync(await Improvements.IndexOfAsync(objImprovement, token).ConfigureAwait(false), objImprovement, token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Move an Improvement Group TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodOldNode">Node of improvement group to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public void MoveImprovementRoot(int intNewIndex, TreeNode objDestination, TreeNode nodOldNode, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (nodOldNode == null)
                return;
            string strNewGroup = string.Empty;
            if (objDestination != null)
            {
                TreeNode objNewParent = objDestination;
                while (objNewParent.Level > 0)
                    objNewParent = objNewParent.Parent;
                intNewIndex = objNewParent.Index;
                strNewGroup = objNewParent.Tag?.ToString() ?? string.Empty;
            }

            string strLocation = nodOldNode.Tag.ToString();
            using (LockObject.EnterUpgradeableReadLock(token))
            {
                ThreadSafeObservableCollection<string> lstImprovementGroups = ImprovementGroups;
                if (!lstImprovementGroups.Contains(strNewGroup))
                    intNewIndex = 0;
                lstImprovementGroups.Move(lstImprovementGroups.IndexOf(strLocation), intNewIndex);
            }
        }

        /// <summary>
        /// Move an Improvement Group TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodOldNode">Node of improvement group to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public async Task MoveImprovementRootAsync(int intNewIndex, TreeNode objDestination, TreeNode nodOldNode, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (nodOldNode == null)
                return;
            string strNewGroup = string.Empty;
            if (objDestination != null)
            {
                TreeNode objNewParent = objDestination;
                while (objNewParent.Level > 0)
                    objNewParent = objNewParent.Parent;
                intNewIndex = objNewParent.Index;
                strNewGroup = objNewParent.Tag?.ToString() ?? string.Empty;
            }

            string strLocation = nodOldNode.Tag.ToString();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                ThreadSafeObservableCollection<string> lstImprovementGroups = await GetImprovementGroupsAsync(token).ConfigureAwait(false);
                if (!await lstImprovementGroups.ContainsAsync(strNewGroup, token).ConfigureAwait(false))
                    intNewIndex = 0;
                await lstImprovementGroups.MoveAsync(await lstImprovementGroups.IndexOfAsync(strLocation, token).ConfigureAwait(false), intNewIndex, token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        #endregion Move TreeNodes

        #region Tab clearing

        /// <summary>
        /// Clear all Spell tab elements from the character.
        /// </summary>
        public void ClearMagic(bool blnKeepAdeptEligible, CancellationToken token = default)
        {
            using (LockObject.EnterWriteLock(token))
            {
                if (ImprovementManager
                        .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.FreeSpells, token: token)
                        .Count > 0
                    || ImprovementManager
                        .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.FreeSpellsATT,
                            token: token).Count > 0
                    || ImprovementManager
                        .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.FreeSpellsSkill,
                            token: token).Count >
                    0)
                {
                    // Run through all of the Spells and remove their Improvements.
                    if (Spells.All(x =>
                            x.Grade == 0 && (!blnKeepAdeptEligible || x.Category != "Rituals" ||
                                             x.Descriptors.Contains("Spell")), token))
                    {
                        List<string> lstIds = Spells.Select(x => x.InternalId).ToList();
                        ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Spell,
                            lstIds, token: token);
                        Spells.Clear();
                    }
                    else
                    {
                        for (int i = Spells.Count - 1; i >= 0; --i)
                        {
                            if (i < Spells.Count)
                            {
                                Spell objToRemove = Spells[i];
                                if (objToRemove.Grade == 0 &&
                                    (!blnKeepAdeptEligible || objToRemove.Category != "Rituals" ||
                                     objToRemove.Descriptors.Contains("Spell")))
                                {
                                    objToRemove.Remove(false);
                                }
                            }
                        }
                    }
                }

                if (Spirits.All(x => x.EntityType == SpiritType.Spirit, token))
                {
                    Spirits.Clear();
                }
                else
                {
                    for (int i = Spirits.Count - 1; i >= 0; --i)
                    {
                        if (i < Spirits.Count)
                        {
                            Spirit objToRemove = Spirits[i];
                            if (objToRemove.EntityType == SpiritType.Spirit)
                            {
                                Spirits.RemoveAt(i);
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Clear all Spell tab elements from the character.
        /// </summary>
        public async Task ClearMagicAsync(bool blnKeepAdeptEligible, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if ((await ImprovementManager
                        .GetCachedImprovementListForValueOfAsync(this, Improvement.ImprovementType.FreeSpells,
                            token: token).ConfigureAwait(false))
                    .Count > 0
                    || (await ImprovementManager
                        .GetCachedImprovementListForValueOfAsync(this, Improvement.ImprovementType.FreeSpellsATT,
                            token: token).ConfigureAwait(false)).Count > 0
                    || (await ImprovementManager
                        .GetCachedImprovementListForValueOfAsync(this, Improvement.ImprovementType.FreeSpellsSkill,
                            token: token).ConfigureAwait(false)).Count >
                    0)
                {
                    ThreadSafeObservableCollection<Spell> lstSpells =
                        await GetSpellsAsync(token).ConfigureAwait(false);
                    // Run through all of the Spells and remove their Improvements.
                    if (await lstSpells
                            .AllAsync(
                                x => x.Grade == 0 && (!blnKeepAdeptEligible || x.Category != "Rituals" ||
                                                      x.Descriptors.Contains("Spell")), token: token)
                            .ConfigureAwait(false))
                    {
                        List<string> lstIds = new List<string>(await lstSpells.GetCountAsync(token).ConfigureAwait(false));
                        await lstSpells.ForEachAsync(x => lstIds.Add(x.InternalId), token).ConfigureAwait(false);
                        await ImprovementManager.RemoveImprovementsAsync(this, Improvement.ImprovementSource.Spell,
                            lstIds, token: token).ConfigureAwait(false);
                        await lstSpells.ClearAsync(token).ConfigureAwait(false);
                    }
                    else
                    {
                        for (int i = await lstSpells.GetCountAsync(token).ConfigureAwait(false) - 1; i >= 0; --i)
                        {
                            if (i < await lstSpells.GetCountAsync(token).ConfigureAwait(false))
                            {
                                Spell objToRemove = await lstSpells.GetValueAtAsync(i, token).ConfigureAwait(false);
                                if (objToRemove.Grade == 0 &&
                                    (!blnKeepAdeptEligible || objToRemove.Category != "Rituals" ||
                                     objToRemove.Descriptors.Contains("Spell")))
                                {
                                    await objToRemove.RemoveAsync(false, token).ConfigureAwait(false);
                                }
                            }
                        }
                    }
                }

                ThreadSafeObservableCollection<Spirit> lstSpirits =
                    await GetSpiritsAsync(token).ConfigureAwait(false);
                if (await lstSpirits.AllAsync(async x => await x.GetEntityTypeAsync(token).ConfigureAwait(false) == SpiritType.Spirit, token).ConfigureAwait(false))
                {
                    await lstSpirits.ClearAsync(token).ConfigureAwait(false);
                }
                else
                {
                    for (int i = await lstSpirits.GetCountAsync(token).ConfigureAwait(false) - 1; i >= 0; --i)
                    {
                        if (i < await lstSpirits.GetCountAsync(token).ConfigureAwait(false))
                        {
                            Spirit objToRemove = await lstSpirits.GetValueAtAsync(i, token).ConfigureAwait(false);
                            if (await objToRemove.GetEntityTypeAsync(token).ConfigureAwait(false) == SpiritType.Spirit)
                            {
                                await lstSpirits.RemoveAtAsync(i, token).ConfigureAwait(false);
                            }
                        }
                    }
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Clear all Adept tab elements from the character.
        /// </summary>
        public void ClearAdeptPowers(CancellationToken token = default)
        {
            using (LockObject.EnterUpgradeableReadLock(token))
            {
                if (Powers.All(x => x.FreeLevels == 0 && x.FreePoints == 0, token))
                {
                    List<string> lstIds = Powers.Select(x => x.InternalId).ToList();
                    using (LockObject.EnterWriteLock(token))
                    {
                        ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Power, lstIds,
                            token: token);
                        Powers.Clear();
                    }
                }
                else
                {
                    using (LockObject.EnterWriteLock(token))
                    {
                        // Run through all powers and remove the ones not added by improvements or foci
                        for (int i = Powers.Count - 1; i >= 0; --i)
                        {
                            if (i < Powers.Count)
                            {
                                Power objToRemove = Powers[i];
                                if (objToRemove.FreeLevels == 0 && objToRemove.FreePoints == 0)
                                {
                                    // Remove the Improvements created by the Power.
                                    ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Power,
                                        objToRemove.InternalId, token: token);
                                    Powers.RemoveAt(i);
                                }
                                else
                                    objToRemove.Rating = 0;
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Clear all Adept tab elements from the character.
        /// </summary>
        public async Task ClearAdeptPowersAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                ThreadSafeBindingList<Power> lstPowers = await GetPowersAsync(token).ConfigureAwait(false);
                if (await lstPowers.AllAsync(async x => await x.GetFreeLevelsAsync(token).ConfigureAwait(false) == 0 && await x.GetFreePointsAsync(token).ConfigureAwait(false) == 0, token).ConfigureAwait(false))
                {
                    List<string> lstIds = new List<string>(await lstPowers.GetCountAsync(token).ConfigureAwait(false));
                    await lstPowers.ForEachAsync(x => lstIds.Add(x.InternalId), token).ConfigureAwait(false);
                    IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await ImprovementManager.RemoveImprovementsAsync(this, Improvement.ImprovementSource.Power,
                            lstIds,
                            token: token).ConfigureAwait(false);
                        await lstPowers.ClearAsync(token).ConfigureAwait(false);
                    }
                    finally
                    {
                        await objLocker2.DisposeAsync().ConfigureAwait(false);
                    }
                }
                else
                {
                    IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        // Run through all powers and remove the ones not added by improvements or foci
                        for (int i = await lstPowers.GetCountAsync(token).ConfigureAwait(false) - 1; i >= 0; --i)
                        {
                            if (i < await lstPowers.GetCountAsync(token).ConfigureAwait(false))
                            {
                                Power objToRemove = await lstPowers.GetValueAtAsync(i, token).ConfigureAwait(false);
                                if (await objToRemove.GetFreeLevelsAsync(token).ConfigureAwait(false) == 0 &&
                                    await objToRemove.GetFreePointsAsync(token).ConfigureAwait(false) == 0)
                                {
                                    // Remove the Improvements created by the Power.
                                    await ImprovementManager.RemoveImprovementsAsync(this,
                                        Improvement.ImprovementSource.Power,
                                        objToRemove.InternalId, token: token).ConfigureAwait(false);
                                    await lstPowers.RemoveAtAsync(i, token).ConfigureAwait(false);
                                }
                                else
                                    await objToRemove.SetRatingAsync(0, token).ConfigureAwait(false);
                            }
                        }
                    }
                    finally
                    {
                        await objLocker2.DisposeAsync().ConfigureAwait(false);
                    }
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Clear all Technomancer tab elements from the character.
        /// </summary>
        public void ClearResonance(CancellationToken token = default)
        {
            using (LockObject.EnterWriteLock(token))
            {
                // Run through all of the Complex Forms and remove their Improvements.
                for (int i = ComplexForms.Count - 1; i >= 0; --i)
                {
                    if (i < ComplexForms.Count)
                    {
                        ComplexForm objToRemove = ComplexForms[i];
                        if (objToRemove.Grade == 0)
                        {
                            objToRemove.Remove(false);
                        }
                    }
                }

                if (Spirits.All(x => x.EntityType == SpiritType.Sprite, token))
                {
                    Spirits.Clear();
                }
                else
                {
                    for (int i = Spirits.Count - 1; i >= 0; --i)
                    {
                        if (i < Spirits.Count)
                        {
                            Spirit objToRemove = Spirits[i];
                            if (objToRemove.EntityType == SpiritType.Sprite)
                            {
                                Spirits.RemoveAt(i);
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Clear all Technomancer tab elements from the character.
        /// </summary>
        public async Task ClearResonanceAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                ThreadSafeObservableCollection<ComplexForm> lstComplexForms = await GetComplexFormsAsync(token).ConfigureAwait(false);
                // Run through all of the Complex Forms and remove their Improvements.
                for (int i = await lstComplexForms.GetCountAsync(token).ConfigureAwait(false) - 1; i >= 0; --i)
                {
                    if (i < await lstComplexForms.GetCountAsync(token).ConfigureAwait(false))
                    {
                        ComplexForm objToRemove =
                            await lstComplexForms.GetValueAtAsync(i, token).ConfigureAwait(false);
                        if (objToRemove.Grade == 0)
                        {
                            // Remove the Improvements created by the Spell.
                            await objToRemove.RemoveAsync(false, token).ConfigureAwait(false);
                        }
                    }
                }

                ThreadSafeObservableCollection<Spirit> lstSpirits = await GetSpiritsAsync(token).ConfigureAwait(false);
                if (await lstSpirits.AllAsync(async x => await x.GetEntityTypeAsync(token).ConfigureAwait(false) == SpiritType.Sprite, token).ConfigureAwait(false))
                {
                    await lstSpirits.ClearAsync(token).ConfigureAwait(false);
                }
                else
                {
                    for (int i = await lstSpirits.GetCountAsync(token).ConfigureAwait(false) - 1; i >= 0; --i)
                    {
                        if (i < await lstSpirits.GetCountAsync(token).ConfigureAwait(false))
                        {
                            Spirit objToRemove = await lstSpirits.GetValueAtAsync(i, token).ConfigureAwait(false);
                            if (await objToRemove.GetEntityTypeAsync(token).ConfigureAwait(false) == SpiritType.Sprite)
                            {
                                await lstSpirits.RemoveAtAsync(i, token).ConfigureAwait(false);
                            }
                        }
                    }
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Clear all Advanced Programs tab elements from the character.
        /// </summary>
        public void ClearAdvancedPrograms(CancellationToken token = default)
        {
            using (LockObject.EnterUpgradeableReadLock(token))
            {
                using (LockObject.EnterWriteLock(token))
                {
                    // Run through all advanced programs and remove the ones not added by improvements
                    for (int i = AIPrograms.Count - 1; i >= 0; --i)
                    {
                        if (i < AIPrograms.Count)
                        {
                            AIProgram objToRemove = AIPrograms[i];
                            if (objToRemove.CanDelete)
                            {
                                objToRemove.Remove(false);
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Clear all Advanced Programs tab elements from the character.
        /// </summary>
        public async Task ClearAdvancedProgramsAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    ThreadSafeObservableCollection<AIProgram> lstAIPrograms =
                        await GetAIProgramsAsync(token).ConfigureAwait(false);
                    for (int i = await lstAIPrograms.GetCountAsync(token).ConfigureAwait(false) - 1; i >= 0; --i)
                    {
                        if (i < await lstAIPrograms.GetCountAsync(token).ConfigureAwait(false))
                        {
                            AIProgram objToRemove =
                                await lstAIPrograms.GetValueAtAsync(i, token).ConfigureAwait(false);
                            if (objToRemove.CanDelete)
                            {
                                // Remove the Improvements created by the Program.
                                await objToRemove.RemoveAsync(false, token).ConfigureAwait(false);
                            }
                        }
                    }
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Clear all cyberware and bioware implanted on the character.
        /// </summary>
        public void ClearCyberwareTab(CancellationToken token = default)
        {
            using (LockObject.EnterUpgradeableReadLock(token))
            {
                string strDisabledSource = string.Empty;
                if (Created)
                {
                    Improvement objDisablingImprovement = ImprovementManager
                        .GetCachedImprovementListForValueOf(
                            this,
                            Improvement.ImprovementType.SpecialTab,
                            "Cyberware", token: token)
                        .Find(x => x.UniqueName == "disabletab");
                    if (objDisablingImprovement != null)
                    {
                        strDisabledSource = LanguageManager.GetString("String_Space", token: token) +
                                            "(" + GetObjectName(objDisablingImprovement, GlobalSettings.Language, token: token) +
                                            ")" +
                                            LanguageManager.GetString("String_Space", token: token);
                    }
                }

                using (LockObject.EnterWriteLock(token))
                {
                    foreach (Cyberware objCyberware in Cyberware
                                 .Where(x => x.SourceID != Backend.Equipment.Cyberware.EssenceHoleGUID
                                             && x.SourceID != Backend.Equipment.Cyberware
                                                 .EssenceAntiHoleGUID && x.IsModularCurrentlyEquipped)
                                 .ToList())
                    {
                        if (!string.IsNullOrEmpty(objCyberware.PlugsIntoModularMount))
                        {
                            if (objCyberware.CanRemoveThroughImprovements)
                            {
                                objCyberware.Parent?.Children.Remove(objCyberware);
                                Cyberware.Add(objCyberware);
                                objCyberware.ChangeModularEquip(false);
                            }
                        }
                        else if (objCyberware.CanRemoveThroughImprovements)
                        {
                            objCyberware.DeleteCyberware();
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(this);
                            string strEntry = LanguageManager.GetString(
                                objCyberware.SourceType == Improvement.ImprovementSource.Cyberware
                                    ? "String_ExpenseSoldCyberware"
                                    : "String_ExpenseSoldBioware", token: token);
                            objExpense.Create(0,
                                strEntry + strDisabledSource
                                         + objCyberware.CurrentDisplayNameShort,
                                ExpenseType.Nuyen, DateTime.Now);
                            ExpenseEntries.AddWithSort(objExpense, token: token);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Clear all cyberware and bioware implanted on the character.
        /// </summary>
        public async Task ClearCyberwareTabAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                string strDisabledSource = string.Empty;
                if (await GetCreatedAsync(token).ConfigureAwait(false))
                {
                    Improvement objDisablingImprovement = (await ImprovementManager
                            .GetCachedImprovementListForValueOfAsync(
                                this,
                                Improvement.ImprovementType.SpecialTab,
                                "Cyberware", token: token).ConfigureAwait(false))
                        .Find(x => x.UniqueName == "disabletab");
                    if (objDisablingImprovement != null)
                    {
                        strDisabledSource = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false) +
                                            "(" + await GetObjectNameAsync(objDisablingImprovement, GlobalSettings.Language, token: token).ConfigureAwait(false) +
                                            ")" +
                                            await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
                    }
                }

                IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    foreach (Cyberware objCyberware in await Cyberware
                                 .ToListAsync(async x =>
                                 {
                                     Guid guidSourceId = await x.GetSourceIDAsync(token).ConfigureAwait(false);
                                     return guidSourceId != Backend.Equipment.Cyberware.EssenceHoleGUID
                                            && guidSourceId != Backend.Equipment.Cyberware.EssenceAntiHoleGUID
                                            && await x.GetIsModularCurrentlyEquippedAsync(token).ConfigureAwait(false);
                                 }, token: token).ConfigureAwait(false))
                    {
                        if (!string.IsNullOrEmpty(await objCyberware.GetPlugsIntoModularMountAsync(token).ConfigureAwait(false)))
                        {
                            if (await objCyberware.GetCanRemoveThroughImprovementsAsync(token).ConfigureAwait(false))
                            {
                                Cyberware objParent = await objCyberware.GetParentAsync(token).ConfigureAwait(false);
                                if (objParent != null)
                                    await (await objParent.GetChildrenAsync(token).ConfigureAwait(false)).RemoveAsync(objCyberware, token).ConfigureAwait(false);
                                await Cyberware.AddAsync(objCyberware, token).ConfigureAwait(false);
                                await objCyberware.ChangeModularEquipAsync(false, token: token).ConfigureAwait(false);
                            }
                        }
                        else if (await objCyberware.GetCanRemoveThroughImprovementsAsync(token).ConfigureAwait(false))
                        {
                            await objCyberware.DeleteCyberwareAsync(token: token).ConfigureAwait(false);
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(this);
                            string strEntry = await LanguageManager.GetStringAsync(
                                await objCyberware.GetSourceTypeAsync(token).ConfigureAwait(false) == Improvement.ImprovementSource.Cyberware
                                    ? "String_ExpenseSoldCyberware"
                                    : "String_ExpenseSoldBioware", token: token).ConfigureAwait(false);
                            objExpense.Create(0,
                                strEntry + strDisabledSource
                                         + await objCyberware.GetCurrentDisplayNameShortAsync(token).ConfigureAwait(false),
                                ExpenseType.Nuyen, DateTime.Now);
                            await ExpenseEntries.AddWithSortAsync(objExpense, token: token).ConfigureAwait(false);
                        }
                    }
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Clear all Critter tab elements from the character.
        /// </summary>
        public void ClearCritterPowers(CancellationToken token = default)
        {
            using (LockObject.EnterUpgradeableReadLock(token))
            {
                if (CritterPowers.All(x => x.Grade >= 0, token))
                {
                    List<string> lstIds = CritterPowers.Select(x => x.InternalId).ToList();
                    using (LockObject.EnterWriteLock(token))
                    {
                        ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.CritterPower, lstIds, token: token);
                        CritterPowers.Clear();
                    }
                }
                else
                {
                    using (LockObject.EnterWriteLock(token))
                    {
                        for (int i = CritterPowers.Count - 1; i >= 0; --i)
                        {
                            if (i < CritterPowers.Count)
                            {
                                CritterPower objToRemove = CritterPowers[i];
                                if (objToRemove.Grade >= 0)
                                {
                                    // Remove the Improvements created by the Metamagic.
                                    ImprovementManager.RemoveImprovements(this,
                                        Improvement.ImprovementSource.CritterPower,
                                        objToRemove.InternalId, token: token);
                                    CritterPowers.RemoveAt(i);
                                }
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Clear all Critter tab elements from the character.
        /// </summary>
        public async Task ClearCritterPowersAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                ThreadSafeObservableCollection<CritterPower> lstCritterPowers =
                    await GetCritterPowersAsync(token).ConfigureAwait(false);
                if (await lstCritterPowers.AllAsync(x => x.Grade >= 0, token: token).ConfigureAwait(false))
                {
                    List<string> lstIds = new List<string>(await lstCritterPowers.GetCountAsync(token).ConfigureAwait(false));
                    await lstCritterPowers.ForEachAsync(x => lstIds.Add(x.InternalId), token).ConfigureAwait(false);
                    IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await ImprovementManager.RemoveImprovementsAsync(this, Improvement.ImprovementSource.CritterPower, lstIds,
                            token: token).ConfigureAwait(false);
                        await lstCritterPowers.ClearAsync(token).ConfigureAwait(false);
                    }
                    finally
                    {
                        await objLocker2.DisposeAsync().ConfigureAwait(false);
                    }
                }
                else
                {
                    IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        for (int i = await lstCritterPowers.GetCountAsync(token).ConfigureAwait(false) - 1; i >= 0; --i)
                        {
                            if (i < await lstCritterPowers.GetCountAsync(token).ConfigureAwait(false))
                            {
                                CritterPower objToRemove =
                                    await lstCritterPowers.GetValueAtAsync(i, token).ConfigureAwait(false);
                                if (objToRemove.Grade >= 0)
                                {
                                    // Remove the Improvements created by the Metamagic.
                                    await ImprovementManager.RemoveImprovementsAsync(this,
                                        Improvement.ImprovementSource.CritterPower,
                                        objToRemove.InternalId, token: token).ConfigureAwait(false);
                                    await lstCritterPowers.RemoveAtAsync(i, token).ConfigureAwait(false);
                                }
                            }
                        }
                    }
                    finally
                    {
                        await objLocker2.DisposeAsync().ConfigureAwait(false);
                    }
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Clear all Initiation tab elements from the character that were not added by improvements.
        /// </summary>
        public void ClearInitiations(CancellationToken token = default)
        {
            using (LockObject.EnterWriteLock(token))
            {
                // Do not update grade numbers until after we're done processing everything
                _blnClearingInitiations = true;
                try
                {
                    token.ThrowIfCancellationRequested();
                    // We need to remove grades that can potentially add stuff that adds grades, so we cannot use foreach
                    for (int i = InitiationGrades.Count - 1; i >= 0; --i)
                    {
                        InitiationGrades[i].Remove(false, false);
                    }
                }
                finally
                {
                    _blnClearingInitiations = false;
                }

                // Now update our grade numbers
                InitiateGrade = 0;
                SubmersionGrade = 0;
            }
        }

        /// <summary>
        /// Clear all Initiation tab elements from the character that were not added by improvements.
        /// </summary>
        public async Task ClearInitiationsAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                // Do not update grade numbers until after we're done processing everything
                _blnClearingInitiations = true;
                try
                {
                    token.ThrowIfCancellationRequested();
                    // We need to remove grades that can potentially add stuff that adds grades, so we cannot use foreach
                    for (int i = await InitiationGrades.GetCountAsync(token).ConfigureAwait(false) - 1; i >= 0; --i)
                    {
                        await (await InitiationGrades.GetValueAtAsync(i, token).ConfigureAwait(false))
                              .RemoveAsync(false, false, token).ConfigureAwait(false);
                    }
                }
                finally
                {
                    _blnClearingInitiations = false;
                }

                // Now update our grade numbers
                await SetInitiateGradeAsync(0, token).ConfigureAwait(false);
                await SetSubmersionGradeAsync(0, token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        #endregion Tab clearing

        #endregion UI Methods

        #region Basic Properties

        private CharacterSettings _objSettings;

        /// <summary>
        /// Character Settings object.
        /// </summary>
        public CharacterSettings Settings
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _objSettings;
            }
            private set // Private to make sure this is always in sync with GameplayOption
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    IDisposable objReaderLock = value?.IsDisposed == false ? value.LockObject.EnterUpgradeableReadLock() : null;
                    try
                    {
                        CharacterSettings objOldSettings = Interlocked.Exchange(ref _objSettings, value);
                        IDisposable objReaderLock2 = objOldSettings?.LockObject.EnterUpgradeableReadLock();
                        try
                        {
                            if (ReferenceEquals(objOldSettings, value))
                                return;
                            bool blnActuallyDifferentSettings = objOldSettings?.HasIdenticalSettings(value) != false;
                            if (objOldSettings?.IsDisposed == false)
                            {
                                try
                                {
                                    objOldSettings.MultiplePropertiesChangedAsync -= OptionsOnPropertyChanged;
                                }
                                catch (ObjectDisposedException)
                                {
                                    //swallow this
                                }
                            }
                            if (value?.IsDisposed == false)
                            {
                                try
                                {
                                    value.MultiplePropertiesChangedAsync += OptionsOnPropertyChanged;
                                }
                                catch (ObjectDisposedException)
                                {
                                    //swallow this
                                }
                            }

                            if (!blnActuallyDifferentSettings || IsLoading)
                                return;
                            OnPropertyChanged();
                            if (value?.IsDisposed == false)
                            {
                                Utils.SafelyRunSynchronously(async () =>
                                {
                                    await OptionsOnMultiplePropertyChanged(await value
                                            .GetDifferingPropertyNamesAsync(objOldSettings).ConfigureAwait(false))
                                        .ConfigureAwait(false);
                                });
                            }
                            else if (objOldSettings != null)
                            {
                                Utils.SafelyRunSynchronously(async () =>
                                {
                                    await OptionsOnMultiplePropertyChanged(await objOldSettings
                                            .GetDifferingPropertyNamesAsync(null).ConfigureAwait(false))
                                        .ConfigureAwait(false);
                                });
                            }
                        }
                        finally
                        {
                            objReaderLock2?.Dispose();
                        }
                    }
                    finally
                    {
                        objReaderLock?.Dispose();
                    }
                }
            }
        }

        /// <summary>
        /// Character Settings object.
        /// </summary>
        public async Task<CharacterSettings> GetSettingsAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _objSettings;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character Settings object.
        /// </summary>
        private async Task SetSettingsAsync(CharacterSettings value, CancellationToken token = default) // Private to make sure this is always in sync with GameplayOption
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                IAsyncDisposable objLocker2 = null;
                if (value?.IsDisposed == false)
                    objLocker2 = await value.LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    CharacterSettings objOldSettings = Interlocked.Exchange(ref _objSettings, value);
                    IAsyncDisposable objLocker3 = null;
                    if (objOldSettings != null)
                        objLocker3 = await objOldSettings.LockObject.EnterUpgradeableReadLockAsync(token)
                            .ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        if (ReferenceEquals(objOldSettings, value))
                            return;
                        bool blnActuallyDifferentSettings = true;
                        if (objOldSettings?.IsDisposed == false)
                        {
                            blnActuallyDifferentSettings = !await objOldSettings.HasIdenticalSettingsAsync(value, token)
                                .ConfigureAwait(false);
                            objOldSettings.MultiplePropertiesChangedAsync -= OptionsOnPropertyChanged;
                        }

                        if (value?.IsDisposed == false)
                        {
                            value.MultiplePropertiesChangedAsync += OptionsOnPropertyChanged;
                        }

                        if (!blnActuallyDifferentSettings || IsLoading)
                            return;
                        await OnPropertyChangedAsync(nameof(Settings), token).ConfigureAwait(false);
                        if (value?.IsDisposed == false)
                        {
                            await OptionsOnMultiplePropertyChanged(await value
                                    .GetDifferingPropertyNamesAsync(objOldSettings, token).ConfigureAwait(false), token)
                                .ConfigureAwait(false);
                        }
                        else if (objOldSettings != null)
                        {
                            await OptionsOnMultiplePropertyChanged(await objOldSettings
                                    .GetDifferingPropertyNamesAsync(null, token).ConfigureAwait(false), token)
                                .ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        if (objLocker3 != null)
                            await objLocker3.DisposeAsync().ConfigureAwait(false);
                    }
                }
                finally
                {
                    if (objLocker2 != null)
                        await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Name of the file the Character is saved to.
        /// </summary>
        public string FileName
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _strFileName;
            }
            set
            {
                if (!string.IsNullOrWhiteSpace(value)
                    && !value.EndsWith(".chum5", StringComparison.OrdinalIgnoreCase)
                    && !value.EndsWith(".chum5lz", StringComparison.OrdinalIgnoreCase))
                {
                    value = Path.GetFileNameWithoutExtension(value) + ".chum5";
                    using (LockObject.EnterReadLock())
                    {
                        if (!string.IsNullOrWhiteSpace(_strFileName)
                            && _strFileName.EndsWith(".chum5lz", StringComparison.OrdinalIgnoreCase))
                            value += "lz";
                    }
                }

                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _strFileName, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Name of the file the Character is saved to.
        /// </summary>
        public async Task<string> GetFileNameAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _strFileName;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Name of the file the Character is saved to.
        /// </summary>
        public async Task SetFileNameAsync(string value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (!string.IsNullOrWhiteSpace(value)
                && !value.EndsWith(".chum5", StringComparison.OrdinalIgnoreCase)
                && !value.EndsWith(".chum5lz", StringComparison.OrdinalIgnoreCase))
            {
                value = Path.GetFileNameWithoutExtension(value) + ".chum5";
                IAsyncDisposable objLocker2 = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
                try
                {
                    if (!string.IsNullOrWhiteSpace(_strFileName)
                        && _strFileName.EndsWith(".chum5lz", StringComparison.OrdinalIgnoreCase))
                        value += "lz";
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }

            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _strFileName, value) == value)
                    return;
                await OnPropertyChangedAsync(nameof(FileName), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Last write time of the file to which this character is saved.
        /// </summary>
        public DateTime FileLastWriteTime
        {
            get
            {
                string strFileName = FileName;
                return string.IsNullOrEmpty(strFileName) || !File.Exists(strFileName)
                    ? DateTime.MinValue
                    : File.GetLastWriteTimeUtc(strFileName);
            }
        }

        /// <summary>
        /// Last write time of the file to which this character is saved.
        /// </summary>
        public async Task<DateTime> GetFileLastWriteTimeAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strFileName = await GetFileNameAsync(token).ConfigureAwait(false);
            return string.IsNullOrEmpty(strFileName) || !File.Exists(strFileName)
                    ? DateTime.MinValue
                    : File.GetLastWriteTimeUtc(strFileName);
        }

        /// <summary>
        /// Whether the character has been saved as Created and can no longer be modified using the Build system.
        /// </summary>
        [HubTag]
        public bool Created
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _blnCreated;
            }
        }

        public void SetCreated(bool value, bool blnDoOnPropertyChanged = true)
        {
            using (LockObject.EnterUpgradeableReadLock())
            {
                if (_blnCreated == value)
                    return;
                using (LockObject.EnterWriteLock())
                {
                    _blnCreated = value;
                    if (blnDoOnPropertyChanged)
                        OnPropertyChanged(nameof(Created));
                }
            }
        }

        public async Task SetCreatedAsync(bool value, bool blnDoOnPropertyChanged = true,
                                               CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_blnCreated == value)
                    return;
                IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    _blnCreated = value;
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }

                if (blnDoOnPropertyChanged)
                    await OnPropertyChangedAsync(nameof(Created), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public async Task<bool> GetCreatedAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _blnCreated;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's name.
        /// </summary>
        [HubTag]
        public string Name
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _strName;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _strName, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's name.
        /// </summary>
        public async Task<string> GetNameAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _strName;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's name.
        /// </summary>
        public async Task SetNameAsync(string value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _strName, value) != value)
                    await OnPropertyChangedAsync(nameof(Name), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's portraits encoded using Base64.
        /// </summary>
        public ThreadSafeList<Image> Mugshots
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstMugshots;
            }
        }

        /// <summary>
        /// Character's portraits encoded using Base64.
        /// </summary>
        public async Task<ThreadSafeList<Image>> GetMugshotsAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstMugshots;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's main portrait encoded using Base64.
        /// </summary>
        public Image MainMugshot
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (MainMugshotIndex >= Mugshots.Count || MainMugshotIndex < 0)
                        return null;

                    return Mugshots[MainMugshotIndex];
                }
            }
            set
            {
                if (value == null)
                {
                    MainMugshotIndex = -1;
                    return;
                }

                using (LockObject.EnterUpgradeableReadLock())
                {
                    int intNewMainMugshotIndex = Mugshots.IndexOf(value);
                    if (intNewMainMugshotIndex != -1)
                    {
                        MainMugshotIndex = intNewMainMugshotIndex;
                    }
                    else
                    {
                        using (LockObject.EnterWriteLock())
                        using (Mugshots.LockObject.EnterWriteLock())
                        {
                            Mugshots.Add(value);
                            MainMugshotIndex = Mugshots.IndexOf(value);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Character's main portrait encoded using Base64.
        /// </summary>
        public async Task<Image> GetMainMugshotAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intIndex = await GetMainMugshotIndexAsync(token).ConfigureAwait(false);
                if (intIndex < 0)
                    return null;
                ThreadSafeList<Image> lstMugshots = await GetMugshotsAsync(token).ConfigureAwait(false);
                if (intIndex >= await lstMugshots.GetCountAsync(token).ConfigureAwait(false))
                    return null;

                return await lstMugshots.GetValueAtAsync(intIndex, token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's main portrait encoded using Base64.
        /// </summary>
        public async Task SetMainMugshotAsync(Image value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (value == null)
            {
                await SetMainMugshotIndexAsync(-1, token).ConfigureAwait(false);
                return;
            }
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                ThreadSafeList<Image> lstMugshots = await GetMugshotsAsync(token).ConfigureAwait(false);
                int intNewMainMugshotIndex = await lstMugshots.IndexOfAsync(value, token).ConfigureAwait(false);
                if (intNewMainMugshotIndex != -1)
                {
                    await SetMainMugshotIndexAsync(intNewMainMugshotIndex, token).ConfigureAwait(false);
                }
                else
                {
                    IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        IAsyncDisposable objLocker3 = await lstMugshots.LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                        try
                        {
                            token.ThrowIfCancellationRequested();
                            await lstMugshots.AddAsync(value, token).ConfigureAwait(false);
                            await SetMainMugshotIndexAsync(await lstMugshots.IndexOfAsync(value, token).ConfigureAwait(false), token).ConfigureAwait(false);
                        }
                        finally
                        {
                            await objLocker3.DisposeAsync().ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        await objLocker2.DisposeAsync().ConfigureAwait(false);
                    }
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Index of Character's main portrait. -1 if set to none.
        /// </summary>
        public int MainMugshotIndex
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _intMainMugshotIndex;
            }
            set
            {
                if (value < -1)
                    value = -1;

                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (value >= Mugshots.Count)
                        value = -1;
                    if (Interlocked.Exchange(ref _intMainMugshotIndex, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Index of Character's main portrait. -1 if set to none.
        /// </summary>
        public async Task<int> GetMainMugshotIndexAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _intMainMugshotIndex;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Index of Character's main portrait. -1 if set to none.
        /// </summary>
        public async Task SetMainMugshotIndexAsync(int value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (value < -1)
                value = -1;
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (value >= await (await GetMugshotsAsync(token).ConfigureAwait(false)).GetCountAsync(token).ConfigureAwait(false))
                    value = -1;
                if (Interlocked.Exchange(ref _intMainMugshotIndex, value) != value)
                    await OnPropertyChangedAsync(nameof(MainMugshotIndex), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Index of Character's main portrait. -1 if set to none.
        /// </summary>
        public async Task ModifyMainMugshotIndexAsync(int value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (value == 0)
                return;
            IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intOldValue = _intMainMugshotIndex;
                int intNewValue = Interlocked.Add(ref _intMainMugshotIndex, value);
                if (intNewValue < -1 || intNewValue >= await (await GetMugshotsAsync(token).ConfigureAwait(false)).GetCountAsync(token).ConfigureAwait(false))
                    intNewValue = -1;
                if (intOldValue != intNewValue)
                    await OnPropertyChangedAsync(nameof(MainMugshotIndex), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public void SaveMugshots(XmlWriter objWriter, CancellationToken token = default)
        {
            Utils.SafelyRunSynchronously(() => SaveMugshotsCore(true, objWriter, token), token);
        }

        public Task SaveMugshotsAsync(XmlWriter objWriter, CancellationToken token = default)
        {
            return SaveMugshotsCore(false, objWriter, token);
        }

        public async Task SaveMugshotsCore(bool blnSync, XmlWriter objWriter, CancellationToken token = default)
        {
            if (objWriter == null)
                return;

            token.ThrowIfCancellationRequested();
            IDisposable objLocker = null;
            IAsyncDisposable objLockerAsync = null;
            if (blnSync)
                // ReSharper disable once MethodHasAsyncOverload
                objLocker = LockObject.EnterReadLock(token);
            else
                objLockerAsync = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (blnSync)
                {
                    objWriter.WriteElementString("mainmugshotindex",
                                                 MainMugshotIndex.ToString(GlobalSettings.InvariantCultureInfo));
                    // <mugshot>
                    // ReSharper disable once MethodHasAsyncOverload
                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                    using (objWriter.StartElement("mugshots"))
                    {
                        foreach (Image imgMugshot in Mugshots)
                        {
                            // ReSharper disable once MethodHasAsyncOverload
                            objWriter.WriteElementString(
                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                "mugshot", GlobalSettings.ImageToBase64StringForStorage(imgMugshot, token));
                        }
                    }
                    // </mugshot>
                }
                else
                {
                    await objWriter.WriteElementStringAsync("mainmugshotindex",
                                                            MainMugshotIndex.ToString(
                                                                GlobalSettings.InvariantCultureInfo), token: token).ConfigureAwait(false);
                    // <mugshots>
                    XmlElementWriteHelper objBaseElement = await objWriter.StartElementAsync("mugshots", token: token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await (await GetMugshotsAsync(token).ConfigureAwait(false)).ForEachAsync(async imgMugshot =>
                        {
                            await objWriter.WriteElementStringAsync(
                                "mugshot",
                                await GlobalSettings.ImageToBase64StringForStorageAsync(imgMugshot, token)
                                    .ConfigureAwait(false), token: token).ConfigureAwait(false);
                        }, token).ConfigureAwait(false);
                    }
                    finally
                    {
                        // </mugshots>
                        await objBaseElement.DisposeAsync().ConfigureAwait(false);
                    }
                }
            }
            finally
            {
                objLocker?.Dispose();
                if (objLockerAsync != null)
                    await objLockerAsync.DisposeAsync().ConfigureAwait(false);
            }
        }

        public void LoadMugshots(XPathNavigator xmlSavedNode, CancellationToken token = default)
        {
            // Mugshots
            using (LockObject.EnterWriteLock(token))
            {
                xmlSavedNode.TryGetInt32FieldQuickly("mainmugshotindex", ref _intMainMugshotIndex);
                XPathNodeIterator xmlMugshotsList = xmlSavedNode.SelectAndCacheExpression("mugshots/mugshot", token);
                if (xmlMugshotsList.Count > 0)
                {
                    string[] astrMugshotsBase64 = ArrayPool<string>.Shared.Rent(xmlMugshotsList.Count);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        int j = 0;
                        foreach (XPathNavigator objXmlMugshot in xmlMugshotsList)
                        {
                            string strMugshot = objXmlMugshot.Value;
                            if (!string.IsNullOrWhiteSpace(strMugshot))
                                astrMugshotsBase64[j++] = strMugshot;
                            else
                                astrMugshotsBase64[j++] = string.Empty;
                        }

                        if (xmlMugshotsList.Count > 1)
                        {
                            Bitmap[] objMugshotImages = new Bitmap[xmlMugshotsList.Count];
                            token.ThrowIfCancellationRequested();
                            Parallel.For(0, xmlMugshotsList.Count,
                                            i =>
                                            {
                                                string strLoop = astrMugshotsBase64[i];
                                                if (!string.IsNullOrEmpty(strLoop))
                                                    objMugshotImages[i] = strLoop.ToImage(PixelFormat.Format32bppPArgb, token);
                                                else
                                                    objMugshotImages[i] = null;
                                            });
                            for (int i = 0; i < xmlMugshotsList.Count; ++i)
                            {
                                Bitmap objLoop = objMugshotImages[i];
                                if (objLoop != null)
                                    _lstMugshots.Add(objLoop);
                            }
                        }
                        else
                        {
                            string strLoop = astrMugshotsBase64[0];
                            if (!string.IsNullOrEmpty(strLoop))
                                _lstMugshots.Add(strLoop.ToImage(PixelFormat.Format32bppPArgb, token));
                        }
                    }
                    finally
                    {
                        ArrayPool<string>.Shared.Return(astrMugshotsBase64);
                    }
                }

                // Legacy Shimmer
                if (_lstMugshots.Count == 0)
                {
                    XPathNavigator objOldMugshotNode = xmlSavedNode.SelectSingleNodeAndCacheExpression("mugshot", token);
                    string strMugshot = objOldMugshotNode?.Value;
                    if (!string.IsNullOrWhiteSpace(strMugshot))
                    {
                        _lstMugshots.Add(strMugshot.ToImage(PixelFormat.Format32bppPArgb, token));
                        _intMainMugshotIndex = 0;
                    }
                }
            }
        }

        public async Task LoadMugshotsAsync(XPathNavigator xmlSavedNode, CancellationToken token = default)
        {
            // Mugshots
            IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                xmlSavedNode.TryGetInt32FieldQuickly("mainmugshotindex", ref _intMainMugshotIndex);
                XPathNodeIterator xmlMugshotsList = xmlSavedNode.SelectAndCacheExpression("mugshots/mugshot", token);
                if (xmlMugshotsList.Count > 0)
                {
                    string[] astrMugshotsBase64 = ArrayPool<string>.Shared.Rent(xmlMugshotsList.Count);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        int j = 0;
                        foreach (XPathNavigator objXmlMugshot in xmlMugshotsList)
                        {
                            string strMugshot = objXmlMugshot.Value;
                            if (!string.IsNullOrWhiteSpace(strMugshot))
                                astrMugshotsBase64[j++] = strMugshot;
                            else
                                astrMugshotsBase64[j++] = string.Empty;
                        }

                        if (xmlMugshotsList.Count > 1)
                        {
                            Bitmap[] aobjMugshots = await ParallelExtensions.ForAsync(0, xmlMugshotsList.Count, i =>
                            {
                                string strLoop = astrMugshotsBase64[i];
                                if (!string.IsNullOrEmpty(strLoop))
                                    return strLoop.ToImageAsync(PixelFormat.Format32bppPArgb, token);
                                return Task.FromResult<Bitmap>(null);
                            }, token).ConfigureAwait(false);
                            foreach (Bitmap objImage in aobjMugshots)
                            {
                                if (objImage != null)
                                    await _lstMugshots.AddAsync(objImage, token).ConfigureAwait(false);
                            }
                        }
                        else
                        {
                            string strLoop = astrMugshotsBase64[0];
                            if (!string.IsNullOrEmpty(strLoop))
                                await _lstMugshots.AddAsync(await strLoop.ToImageAsync(PixelFormat.Format32bppPArgb, token).ConfigureAwait(false), token).ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        ArrayPool<string>.Shared.Return(astrMugshotsBase64);
                    }
                }

                // Legacy Shimmer
                if (await _lstMugshots.GetCountAsync(token).ConfigureAwait(false) == 0)
                {
                    XPathNavigator objOldMugshotNode = xmlSavedNode.SelectSingleNodeAndCacheExpression("mugshot", token);
                    string strMugshot = objOldMugshotNode?.Value;
                    if (!string.IsNullOrWhiteSpace(strMugshot))
                    {
                        await _lstMugshots.AddAsync(await strMugshot.ToImageAsync(PixelFormat.Format32bppPArgb, token).ConfigureAwait(false), token).ConfigureAwait(false);
                        _intMainMugshotIndex = 0;
                    }
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public async Task PrintMugshots(XmlWriter objWriter, CancellationToken token = default)
        {
            if (objWriter == null)
                return;
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                ThreadSafeList<Image> lstMugshots = await GetMugshotsAsync(token).ConfigureAwait(false);
                if (await lstMugshots.GetCountAsync(token).ConfigureAwait(false) > 0)
                {
                    // Note: Internet Explorer 8 and earlier are the only browsers that do not support data URIs.
                    // The workaround for them would require saving each image to a file first and then referencing that file instead of embedding the image's base64 directly.
                    // However, users who only use IE8 and earlier are so vanishingly small compared to the effort this workaround requires that we are just not going to bother.

                    Image imgMainMugshot = await GetMainMugshotAsync(token).ConfigureAwait(false);
                    if (imgMainMugshot != null)
                    {
                        // <mainmugshotbase64 />
                        await objWriter.WriteElementStringAsync("mainmugshotbase64", await imgMainMugshot.ToBase64StringAsJpegAsync(token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                    }

                    // <othermugshots>
                    await objWriter.WriteElementStringAsync("hasothermugshots",
                                                            (imgMainMugshot == null || await lstMugshots.GetCountAsync(token).ConfigureAwait(false) > 1).ToString(
                                                                GlobalSettings.InvariantCultureInfo), token: token).ConfigureAwait(false);

                    // <othermugshots>
                    XmlElementWriteHelper objOtherMugshotsElement = await objWriter.StartElementAsync("othermugshots", token: token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        for (int i = 0; i < await lstMugshots.GetCountAsync(token).ConfigureAwait(false); ++i)
                        {
                            if (i == await GetMainMugshotIndexAsync(token).ConfigureAwait(false))
                                continue;
                            Image imgMugshot = await lstMugshots.GetValueAtAsync(i, token).ConfigureAwait(false);

                            // <mugshot>
                            XmlElementWriteHelper objMugshotElement = await objWriter.StartElementAsync("mugshot", token: token).ConfigureAwait(false);
                            try
                            {
                                token.ThrowIfCancellationRequested();
                                await objWriter.WriteElementStringAsync(
                                    "stringbase64", await imgMugshot.ToBase64StringAsJpegAsync(token: token).ConfigureAwait(false),
                                    token: token).ConfigureAwait(false);
                            }
                            finally
                            {
                                // </mugshot>
                                await objMugshotElement.DisposeAsync().ConfigureAwait(false);
                            }
                        }
                    }
                    finally
                    {
                        // </othermugshots>
                        await objOtherMugshotsElement.DisposeAsync().ConfigureAwait(false);
                    }
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's Gameplay Option.
        /// </summary>
        [HubTag]
        public string SettingsKey
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _strSettingsKey;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (_strSettingsKey == value)
                        return;
                    if (!SettingsManager.LoadedCharacterSettings.TryGetValue(
                            value, out CharacterSettings objNewSettings))
                        throw new InvalidOperationException(nameof(SettingsKey));
                    using (LockObject.EnterWriteLock())
                    {
                        if (Interlocked.Exchange(ref _strSettingsKey, value) == value)
                            return;
                        Settings = objNewSettings;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Character's Gameplay Option.
        /// </summary>
        public async Task<string> GetSettingsKeyAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _strSettingsKey;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public async Task SetSettingsKeyAsync(string value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_strSettingsKey == value)
                    return;
                if (!(await SettingsManager.GetLoadedCharacterSettingsAsync(token).ConfigureAwait(false)).TryGetValue(
                        value, out CharacterSettings objNewSettings))
                    throw new InvalidOperationException(nameof(SettingsKey));
                IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    if (Interlocked.Exchange(ref _strSettingsKey, value) == value)
                        return;
                    await SetSettingsAsync(objNewSettings, token).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }

                await OnPropertyChangedAsync(nameof(SettingsKey), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's Metatype Priority.
        /// </summary>
        [HubTag]
        public string MetatypePriority
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _strPriorityMetatype;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _strPriorityMetatype, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Metatype Priority.
        /// </summary>
        public async Task<string> GetMetatypePriorityAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _strPriorityMetatype;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's Metatype Priority.
        /// </summary>
        public async Task SetMetatypePriorityAsync(string value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _strPriorityMetatype, value) == value)
                    return;

                await OnPropertyChangedAsync(nameof(MetatypePriority), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's Attributes Priority.
        /// </summary>
        [HubTag]
        public string AttributesPriority
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _strPriorityAttributes;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _strPriorityAttributes, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Attributes Priority.
        /// </summary>
        public async Task<string> GetAttributesPriorityAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _strPriorityAttributes;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's Attributes Priority.
        /// </summary>
        public async Task SetAttributesPriorityAsync(string value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _strPriorityAttributes, value) == value)
                    return;

                await OnPropertyChangedAsync(nameof(AttributesPriority), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's Special Priority.
        /// </summary>
        [HubTag]
        public string SpecialPriority
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _strPrioritySpecial;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _strPrioritySpecial, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Special Priority.
        /// </summary>
        public async Task<string> GetSpecialPriorityAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _strPrioritySpecial;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's Special Priority.
        /// </summary>
        public async Task SetSpecialPriorityAsync(string value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _strPrioritySpecial, value) == value)
                    return;

                await OnPropertyChangedAsync(nameof(SpecialPriority), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's Skills Priority.
        /// </summary>
        [HubTag]
        public string SkillsPriority
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _strPrioritySkills;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _strPrioritySkills, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Skills Priority.
        /// </summary>
        public async Task<string> GetSkillsPriorityAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _strPrioritySkills;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's Skills Priority.
        /// </summary>
        public async Task SetSkillsPriorityAsync(string value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _strPrioritySkills, value) == value)
                    return;

                await OnPropertyChangedAsync(nameof(SkillsPriority), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's Resources Priority.
        /// </summary>
        [HubTag]
        public string ResourcesPriority
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _strPriorityResources;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _strPriorityResources, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Resources Priority.
        /// </summary>
        public async Task<string> GetResourcesPriorityAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _strPriorityResources;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's Resources Priority.
        /// </summary>
        public async Task SetResourcesPriorityAsync(string value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _strPriorityResources, value) == value)
                    return;

                await OnPropertyChangedAsync(nameof(ResourcesPriority), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's Talent Priority.
        /// </summary>
        [HubTag]
        public string TalentPriority
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _strPriorityTalent;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _strPriorityTalent, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Talent Priority.
        /// </summary>
        public async Task<string> GetTalentPriorityAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _strPriorityTalent;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's Talent Priority.
        /// </summary>
        public async Task SetTalentPriorityAsync(string value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _strPriorityTalent, value) == value)
                    return;

                await OnPropertyChangedAsync(nameof(TalentPriority), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's list of priority bonus skills.
        /// </summary>
        public ThreadSafeList<string> PriorityBonusSkillList
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstPrioritySkills;
            }
        }

        /// <summary>
        /// Character's gender.
        /// </summary>
        public string Gender
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _strGender;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _strGender, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's gender.
        /// </summary>
        public async Task<string> GetGenderAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _strGender;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's gender.
        /// </summary>
        public async Task SetGenderAsync(string value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _strGender, value) != value)
                    await OnPropertyChangedAsync(nameof(Gender), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private string _strCachedCharacterGrammaticGender = string.Empty;

        public string CharacterGrammaticGender
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (!string.IsNullOrEmpty(_strCachedCharacterGrammaticGender))
                        return _strCachedCharacterGrammaticGender;
                    switch (ReverseTranslateExtra(Gender).ToUpperInvariant())
                    {
                        case "M":
                        case "MALE":
                        case "MAN":
                        case "BOY":
                        case "LORD":
                        case "GENTLEMAN":
                        case "GUY":
                            return _strCachedCharacterGrammaticGender = "male";

                        case "F":
                        case "W":
                        case "FEMALE":
                        case "WOMAN":
                        case "GIRL":
                        case "LADY":
                        case "GAL":
                            return _strCachedCharacterGrammaticGender = "female";

                        default:
                            return _strCachedCharacterGrammaticGender = "neutral";
                    }
                }
            }
        }

        public async Task<string> GetCharacterGrammaticGenderAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (!string.IsNullOrEmpty(_strCachedCharacterGrammaticGender))
                    return _strCachedCharacterGrammaticGender;
                switch ((await ReverseTranslateExtraAsync(await GetGenderAsync(token).ConfigureAwait(false), token: token).ConfigureAwait(false)).ToUpperInvariant())
                {
                    case "M":
                    case "MALE":
                    case "MAN":
                    case "BOY":
                    case "LORD":
                    case "GENTLEMAN":
                    case "GUY":
                        return _strCachedCharacterGrammaticGender = "male";

                    case "F":
                    case "W":
                    case "FEMALE":
                    case "WOMAN":
                    case "GIRL":
                    case "LADY":
                    case "GAL":
                        return _strCachedCharacterGrammaticGender = "female";

                    default:
                        return _strCachedCharacterGrammaticGender = "neutral";
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's age.
        /// </summary>
        public string Age
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _strAge;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _strAge, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's age.
        /// </summary>
        public async Task<string> GetAgeAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _strAge;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's age.
        /// </summary>
        public async Task SetAgeAsync(string value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _strAge, value) != value)
                    await OnPropertyChangedAsync(nameof(Age), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's eyes.
        /// </summary>
        public string Eyes
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _strEyes;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _strEyes, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's eyes.
        /// </summary>
        public async Task<string> GetEyesAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _strEyes;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's eyes.
        /// </summary>
        public async Task SetEyesAsync(string value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _strEyes, value) != value)
                    await OnPropertyChangedAsync(nameof(Eyes), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's height.
        /// </summary>
        public string Height
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _strHeight;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _strHeight, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's height.
        /// </summary>
        public async Task<string> GetHeightAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _strHeight;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's height.
        /// </summary>
        public async Task SetHeightAsync(string value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _strHeight, value) != value)
                    await OnPropertyChangedAsync(nameof(Height), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's weight.
        /// </summary>
        public string Weight
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _strWeight;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _strWeight, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's weight.
        /// </summary>
        public async Task<string> GetWeightAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _strWeight;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's weight.
        /// </summary>
        public async Task SetWeightAsync(string value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _strWeight, value) != value)
                    await OnPropertyChangedAsync(nameof(Weight), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's skin.
        /// </summary>
        public string Skin
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _strSkin;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _strSkin, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's skin.
        /// </summary>
        public async Task<string> GetSkinAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _strSkin;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's skin.
        /// </summary>
        public async Task SetSkinAsync(string value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _strSkin, value) != value)
                    await OnPropertyChangedAsync(nameof(Skin), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's hair.
        /// </summary>
        public string Hair
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _strHair;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _strHair, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's hair.
        /// </summary>
        public async Task<string> GetHairAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _strHair;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's hair.
        /// </summary>
        public async Task SetHairAsync(string value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _strHair, value) != value)
                    await OnPropertyChangedAsync(nameof(Hair), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's description.
        /// </summary>
        public string Description
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _strDescription;
            }
            set
            {
                string strNewText = value.RtfToPlainText();
                if (string.IsNullOrWhiteSpace(strNewText))
                    value = string.Empty;
                using (LockObject.EnterUpgradeableReadLock())
                {
                    string strOldValue = Interlocked.Exchange(ref _strDescription, value);
                    if (strOldValue == value)
                        return;
                    string strNewHtml = value.RtfToHtml();
                    string strOldText = strOldValue.RtfToPlainText();
                    string strOldHtml = strOldValue.RtfToHtml();
                    // There's something wonky with Rtf comparison, so do an HTML comparison to be sure that something was definitely changed
                    if ((!string.IsNullOrWhiteSpace(strOldText) || !string.IsNullOrWhiteSpace(strNewText))
                        && (!string.IsNullOrWhiteSpace(strOldHtml) || !string.IsNullOrWhiteSpace(strNewHtml))
                        && strOldHtml != strNewHtml)
                        OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's description.
        /// </summary>
        public async Task<string> GetDescriptionAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _strDescription;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's description.
        /// </summary>
        public async Task SetDescriptionAsync(string value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strNewText = await value.RtfToPlainTextAsync(token: token).ConfigureAwait(false);
            if (string.IsNullOrWhiteSpace(strNewText))
                value = string.Empty;
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                string strOldValue = Interlocked.Exchange(ref _strDescription, value);
                if (strOldValue == value)
                    return;
                string strNewHtml = await value.RtfToHtmlAsync(token: token).ConfigureAwait(false);
                string strOldText = await strOldValue.RtfToPlainTextAsync(token: token).ConfigureAwait(false);
                string strOldHtml = await strOldValue.RtfToHtmlAsync(token: token).ConfigureAwait(false);
                // There's something wonky with Rtf comparison, so do an HTML comparison to be sure that something was definitely changed
                if ((!string.IsNullOrWhiteSpace(strOldText) || !string.IsNullOrWhiteSpace(strNewText))
                    && (!string.IsNullOrWhiteSpace(strOldHtml) || !string.IsNullOrWhiteSpace(strNewHtml))
                    && strOldHtml != strNewHtml)
                    await OnPropertyChangedAsync(nameof(Description), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's background.
        /// </summary>
        public string Background
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _strBackground;
            }
            set
            {
                string strNewText = value.RtfToPlainText();
                if (string.IsNullOrWhiteSpace(strNewText))
                    value = string.Empty;
                using (LockObject.EnterUpgradeableReadLock())
                {
                    string strOldValue = Interlocked.Exchange(ref _strBackground, value);
                    if (strOldValue == value)
                        return;
                    string strNewHtml = value.RtfToHtml();
                    string strOldText = strOldValue.RtfToPlainText();
                    string strOldHtml = strOldValue.RtfToHtml();
                    // There's something wonky with Rtf comparison, so do an HTML comparison to be sure that something was definitely changed
                    if ((!string.IsNullOrWhiteSpace(strOldText) || !string.IsNullOrWhiteSpace(strNewText))
                        && (!string.IsNullOrWhiteSpace(strOldHtml) || !string.IsNullOrWhiteSpace(strNewHtml))
                        && strOldHtml != strNewHtml)
                        OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's background.
        /// </summary>
        public async Task<string> GetBackgroundAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _strBackground;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's background.
        /// </summary>
        public async Task SetBackgroundAsync(string value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strNewText = await value.RtfToPlainTextAsync(token: token).ConfigureAwait(false);
            if (string.IsNullOrWhiteSpace(strNewText))
                value = string.Empty;
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                string strOldValue = Interlocked.Exchange(ref _strBackground, value);
                if (strOldValue == value)
                    return;
                string strNewHtml = await value.RtfToHtmlAsync(token: token).ConfigureAwait(false);
                string strOldText = await strOldValue.RtfToPlainTextAsync(token: token).ConfigureAwait(false);
                string strOldHtml = await strOldValue.RtfToHtmlAsync(token: token).ConfigureAwait(false);
                // There's something wonky with Rtf comparison, so do an HTML comparison to be sure that something was definitely changed
                if ((!string.IsNullOrWhiteSpace(strOldText) || !string.IsNullOrWhiteSpace(strNewText))
                    && (!string.IsNullOrWhiteSpace(strOldHtml) || !string.IsNullOrWhiteSpace(strNewHtml))
                    && strOldHtml != strNewHtml)
                    await OnPropertyChangedAsync(nameof(Background), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's concept.
        /// </summary>
        public string Concept
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _strConcept;
            }
            set
            {
                string strNewText = value.RtfToPlainText();
                if (string.IsNullOrWhiteSpace(strNewText))
                    value = string.Empty;
                using (LockObject.EnterUpgradeableReadLock())
                {
                    string strOldValue = Interlocked.Exchange(ref _strConcept, value);
                    if (strOldValue == value)
                        return;
                    string strNewHtml = value.RtfToHtml();
                    string strOldText = strOldValue.RtfToPlainText();
                    string strOldHtml = strOldValue.RtfToHtml();
                    // There's something wonky with Rtf comparison, so do an HTML comparison to be sure that something was definitely changed
                    if ((!string.IsNullOrWhiteSpace(strOldText) || !string.IsNullOrWhiteSpace(strNewText))
                        && (!string.IsNullOrWhiteSpace(strOldHtml) || !string.IsNullOrWhiteSpace(strNewHtml))
                        && strOldHtml != strNewHtml)
                        OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's concept.
        /// </summary>
        public async Task<string> GetConceptAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _strConcept;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's concept.
        /// </summary>
        public async Task SetConceptAsync(string value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strNewText = await value.RtfToPlainTextAsync(token: token).ConfigureAwait(false);
            if (string.IsNullOrWhiteSpace(strNewText))
                value = string.Empty;
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                string strOldValue = Interlocked.Exchange(ref _strConcept, value);
                if (strOldValue == value)
                    return;
                string strNewHtml = await value.RtfToHtmlAsync(token: token).ConfigureAwait(false);
                string strOldText = await strOldValue.RtfToPlainTextAsync(token: token).ConfigureAwait(false);
                string strOldHtml = await strOldValue.RtfToHtmlAsync(token: token).ConfigureAwait(false);
                // There's something wonky with Rtf comparison, so do an HTML comparison to be sure that something was definitely changed
                if ((!string.IsNullOrWhiteSpace(strOldText) || !string.IsNullOrWhiteSpace(strNewText))
                    && (!string.IsNullOrWhiteSpace(strOldHtml) || !string.IsNullOrWhiteSpace(strNewHtml))
                    && strOldHtml != strNewHtml)
                    await OnPropertyChangedAsync(nameof(Concept), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character notes.
        /// </summary>
        public string Notes
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _strNotes;
            }
            set
            {
                string strNewText = value.RtfToPlainText();
                if (string.IsNullOrWhiteSpace(strNewText))
                    value = string.Empty;
                using (LockObject.EnterUpgradeableReadLock())
                {
                    string strOldValue = Interlocked.Exchange(ref _strNotes, value);
                    if (strOldValue == value)
                        return;
                    string strNewHtml = value.RtfToHtml();
                    string strOldText = strOldValue.RtfToPlainText();
                    string strOldHtml = strOldValue.RtfToHtml();
                    // There's something wonky with Rtf comparison, so do an HTML comparison to be sure that something was definitely changed
                    if ((!string.IsNullOrWhiteSpace(strOldText) || !string.IsNullOrWhiteSpace(strNewText))
                        && (!string.IsNullOrWhiteSpace(strOldHtml) || !string.IsNullOrWhiteSpace(strNewHtml))
                        && strOldHtml != strNewHtml)
                        OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character notes.
        /// </summary>
        public async Task<string> GetNotesAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _strNotes;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character notes.
        /// </summary>
        public async Task SetNotesAsync(string value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strNewText = await value.RtfToPlainTextAsync(token: token).ConfigureAwait(false);
            if (string.IsNullOrWhiteSpace(strNewText))
                value = string.Empty;
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                string strOldValue = Interlocked.Exchange(ref _strNotes, value);
                if (strOldValue == value)
                    return;
                string strNewHtml = await value.RtfToHtmlAsync(token: token).ConfigureAwait(false);
                string strOldText = await strOldValue.RtfToPlainTextAsync(token: token).ConfigureAwait(false);
                string strOldHtml = await strOldValue.RtfToHtmlAsync(token: token).ConfigureAwait(false);
                // There's something wonky with Rtf comparison, so do an HTML comparison to be sure that something was definitely changed
                if ((!string.IsNullOrWhiteSpace(strOldText) || !string.IsNullOrWhiteSpace(strNewText))
                    && (!string.IsNullOrWhiteSpace(strOldHtml) || !string.IsNullOrWhiteSpace(strNewHtml))
                    && strOldHtml != strNewHtml)
                    await OnPropertyChangedAsync(nameof(Notes), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// General gameplay notes.
        /// </summary>
        public string GameNotes
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _strGameNotes;
            }
            set
            {
                string strNewText = value.RtfToPlainText();
                if (string.IsNullOrWhiteSpace(strNewText))
                    value = string.Empty;
                using (LockObject.EnterUpgradeableReadLock())
                {
                    string strOldValue = Interlocked.Exchange(ref _strGameNotes, value);
                    if (strOldValue == value)
                        return;
                    string strNewHtml = value.RtfToHtml();
                    string strOldText = strOldValue.RtfToPlainText();
                    string strOldHtml = strOldValue.RtfToHtml();
                    // There's something wonky with Rtf comparison, so do an HTML comparison to be sure that something was definitely changed
                    if ((!string.IsNullOrWhiteSpace(strOldText) || !string.IsNullOrWhiteSpace(strNewText))
                        && (!string.IsNullOrWhiteSpace(strOldHtml) || !string.IsNullOrWhiteSpace(strNewHtml))
                        && strOldHtml != strNewHtml)
                        OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// General gameplay notes.
        /// </summary>
        public async Task<string> GetGameNotesAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _strGameNotes;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// General gameplay notes.
        /// </summary>
        public async Task SetGameNotesAsync(string value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strNewText = await value.RtfToPlainTextAsync(token: token).ConfigureAwait(false);
            if (string.IsNullOrWhiteSpace(strNewText))
                value = string.Empty;
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                string strOldValue = Interlocked.Exchange(ref _strGameNotes, value);
                if (strOldValue == value)
                    return;
                string strNewHtml = await value.RtfToHtmlAsync(token: token).ConfigureAwait(false);
                string strOldText = await strOldValue.RtfToPlainTextAsync(token: token).ConfigureAwait(false);
                string strOldHtml = await strOldValue.RtfToHtmlAsync(token: token).ConfigureAwait(false);
                // There's something wonky with Rtf comparison, so do an HTML comparison to be sure that something was definitely changed
                if ((!string.IsNullOrWhiteSpace(strOldText) || !string.IsNullOrWhiteSpace(strNewText))
                    && (!string.IsNullOrWhiteSpace(strOldHtml) || !string.IsNullOrWhiteSpace(strNewHtml))
                    && strOldHtml != strNewHtml)
                    await OnPropertyChangedAsync(nameof(GameNotes), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// What is the Characters preferred hand
        /// </summary>
        public string PrimaryArm
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _strPrimaryArm;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _strPrimaryArm, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// What is the Characters preferred hand
        /// </summary>
        public async Task<string> GetPrimaryArmAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _strPrimaryArm;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// What is the Characters preferred hand
        /// </summary>
        public async Task SetPrimaryArmAsync(string value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _strPrimaryArm, value) == value)
                    return;
                await OnPropertyChangedAsync(nameof(PrimaryArm), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Player name.
        /// </summary>
        [HubTag]
        public string PlayerName
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _strPlayerName;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _strPlayerName, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Player name.
        /// </summary>
        public async Task<string> GetPlayerNameAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _strPlayerName;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Player name.
        /// </summary>
        public async Task SetPlayerNameAsync(string value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _strPlayerName, value) != value)
                    await OnPropertyChangedAsync(nameof(PlayerName), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's alias.
        /// </summary>
        [HubTag]
        public string Alias
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _strAlias;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _strAlias, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's alias.
        /// </summary>
        public async Task<string> GetAliasAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _strAlias;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's alias.
        /// </summary>
        public async Task SetAliasAsync(string value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _strAlias, value) != value)
                    await OnPropertyChangedAsync(nameof(Alias), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's name to use when loading them in a new tab.
        /// </summary>
        public string CharacterName
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (!string.IsNullOrWhiteSpace(Alias))
                        return Alias;
                    return !string.IsNullOrWhiteSpace(Name)
                        ? Name
                        : LanguageManager.GetString("String_UnnamedCharacter");
                }
            }
        }

        /// <summary>
        /// Character's name to use when loading them in a new tab.
        /// </summary>
        public async Task<string> GetCharacterNameAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                string strAlias = await GetAliasAsync(token).ConfigureAwait(false);
                if (!string.IsNullOrWhiteSpace(strAlias))
                    return strAlias;
                string strName = await GetNameAsync(token).ConfigureAwait(false);
                return !string.IsNullOrWhiteSpace(strName)
                    ? strName
                    : await LanguageManager.GetStringAsync("String_UnnamedCharacter", token: token)
                                           .ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string CurrentDisplayName => CharacterName;

        public Task<string> GetCurrentDisplayNameAsync(CancellationToken token = default) =>
            GetCharacterNameAsync(token);

        /// <summary>
        /// Street Cred.
        /// </summary>
        [HubTag]
        public int StreetCred
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _intStreetCred;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _intStreetCred, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Street Cred.
        /// </summary>
        public async Task<int> GetStreetCredAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _intStreetCred;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Street Cred.
        /// </summary>
        public async Task SetStreetCredAsync(int value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _intStreetCred, value) != value)
                    await OnPropertyChangedAsync(nameof(StreetCred), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Burnt Street Cred.
        /// </summary>
        public int BurntStreetCred
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _intBurntStreetCred;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _intBurntStreetCred, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Burnt Street Cred.
        /// </summary>
        public async Task<int> GetBurntStreetCredAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _intBurntStreetCred;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Burnt Street Cred.
        /// </summary>
        public async Task SetBurntStreetCredAsync(int value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _intBurntStreetCred, value) != value)
                    await OnPropertyChangedAsync(nameof(BurntStreetCred), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Burnt Street Cred.
        /// </summary>
        public async Task ModifyBurntStreetCredAsync(int value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (value == 0)
                return;
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                Interlocked.Add(ref _intBurntStreetCred, _intBurntStreetCred);
                await OnPropertyChangedAsync(nameof(BurntStreetCred), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Notoriety.
        /// </summary>
        [HubTag]
        public int Notoriety
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _intNotoriety;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _intNotoriety, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Notoriety.
        /// </summary>
        public async Task<int> GetNotorietyAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _intNotoriety;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Notoriety.
        /// </summary>
        public async Task SetNotorietyAsync(int value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _intNotoriety, value) != value)
                    await OnPropertyChangedAsync(nameof(Notoriety), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Public Awareness.
        /// </summary>
        public int PublicAwareness
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _intPublicAwareness;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _intPublicAwareness, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Public Awareness.
        /// </summary>
        public async Task<int> GetPublicAwarenessAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _intPublicAwareness;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Public Awareness.
        /// </summary>
        public async Task SetPublicAwarenessAsync(int value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _intPublicAwareness, value) != value)
                    await OnPropertyChangedAsync(nameof(PublicAwareness), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private bool RefreshAstralReputationImprovements(CancellationToken token = default)
        {
            if (IsLoading) // Not all improvements are guaranteed to have been loaded in, so just skip the refresh until the end
            {
                EnqueuePostLoadMethod(RefreshAstralReputationImprovements, token);
                return true;
            }

            using (LockObject.EnterWriteLock(token))
            {
                int intCurrentTotalAstralReputation = TotalAstralReputation;
                List<Improvement> lstCurrentAstralReputationImprovements = Improvements
                    .Where(x => x.ImproveSource
                                == Improvement.ImprovementSource
                                    .AstralReputation).ToList();
                if (lstCurrentAstralReputationImprovements.TrueForAll(x => x.Value == -intCurrentTotalAstralReputation))
                    return true;
                ImprovementManager.RemoveImprovements(this, lstCurrentAstralReputationImprovements, token: token);
                try
                {
                    token.ThrowIfCancellationRequested();
                    ImprovementManager.CreateImprovement(this, "Summoning",
                        Improvement.ImprovementSource.AstralReputation,
                        nameof(TotalAstralReputation).ToUpperInvariant(),
                        Improvement.ImprovementType.Skill,
                        Guid.NewGuid()
                            .ToString("D", GlobalSettings.InvariantCultureInfo),
                        -intCurrentTotalAstralReputation, token: token);
                    ImprovementManager.CreateImprovement(this, "Binding",
                        Improvement.ImprovementSource.AstralReputation,
                        nameof(TotalAstralReputation).ToUpperInvariant(),
                        Improvement.ImprovementType.Skill,
                        Guid.NewGuid()
                            .ToString("D", GlobalSettings.InvariantCultureInfo),
                        -intCurrentTotalAstralReputation, token: token);
                    ImprovementManager.CreateImprovement(this, "Banishing",
                        Improvement.ImprovementSource.AstralReputation,
                        nameof(TotalAstralReputation).ToUpperInvariant(),
                        Improvement.ImprovementType.Skill,
                        Guid.NewGuid()
                            .ToString("D", GlobalSettings.InvariantCultureInfo),
                        -intCurrentTotalAstralReputation, token: token);
                    if (intCurrentTotalAstralReputation >= 3)
                        ImprovementManager.CreateImprovement(this, "Chain Breaker",
                            Improvement.ImprovementSource.AstralReputation,
                            nameof(TotalAstralReputation).ToUpperInvariant(),
                            Improvement.ImprovementType.DisableQuality,
                            Guid.NewGuid()
                                .ToString(
                                    "D", GlobalSettings.InvariantCultureInfo),
                            -intCurrentTotalAstralReputation, token: token);
                }
                catch
                {
                    ImprovementManager.Rollback(this, CancellationToken.None);
                    throw;
                }

                ImprovementManager.Commit(this, token);
                return true;
            }
        }

        private async Task<bool> RefreshAstralReputationImprovementsAsync(CancellationToken token = default)
        {
            if (IsLoading) // Not all improvements are guaranteed to have been loaded in, so just skip the refresh until the end
            {
                await EnqueuePostLoadAsyncMethodAsync(RefreshAstralReputationImprovementsAsync, token).ConfigureAwait(false);
                return true;
            }

            IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intCurrentTotalAstralReputation = TotalAstralReputation;
                List<Improvement> lstCurrentAstralReputationImprovements = await (await GetImprovementsAsync(token).ConfigureAwait(false))
                    .ToListAsync(x => x.ImproveSource == Improvement.ImprovementSource.AstralReputation, token).ConfigureAwait(false);
                if (lstCurrentAstralReputationImprovements.TrueForAll(x => x.Value == -intCurrentTotalAstralReputation))
                    return true;
                await ImprovementManager.RemoveImprovementsAsync(this, lstCurrentAstralReputationImprovements,
                    token: token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    await ImprovementManager.CreateImprovementAsync(this, "Summoning",
                        Improvement.ImprovementSource.AstralReputation,
                        nameof(TotalAstralReputation).ToUpperInvariant(),
                        Improvement.ImprovementType.Skill,
                        Guid.NewGuid()
                            .ToString("D", GlobalSettings.InvariantCultureInfo),
                        -intCurrentTotalAstralReputation, token: token).ConfigureAwait(false);
                    await ImprovementManager.CreateImprovementAsync(this, "Binding",
                        Improvement.ImprovementSource.AstralReputation,
                        nameof(TotalAstralReputation).ToUpperInvariant(),
                        Improvement.ImprovementType.Skill,
                        Guid.NewGuid()
                            .ToString("D", GlobalSettings.InvariantCultureInfo),
                        -intCurrentTotalAstralReputation, token: token).ConfigureAwait(false);
                    await ImprovementManager.CreateImprovementAsync(this, "Banishing",
                        Improvement.ImprovementSource.AstralReputation,
                        nameof(TotalAstralReputation).ToUpperInvariant(),
                        Improvement.ImprovementType.Skill,
                        Guid.NewGuid()
                            .ToString("D", GlobalSettings.InvariantCultureInfo),
                        -intCurrentTotalAstralReputation, token: token).ConfigureAwait(false);
                    if (intCurrentTotalAstralReputation >= 3)
                        await ImprovementManager.CreateImprovementAsync(this, "Chain Breaker",
                            Improvement.ImprovementSource.AstralReputation,
                            nameof(TotalAstralReputation).ToUpperInvariant(),
                            Improvement.ImprovementType.DisableQuality,
                            Guid.NewGuid()
                                .ToString(
                                    "D", GlobalSettings.InvariantCultureInfo),
                            -intCurrentTotalAstralReputation, token: token).ConfigureAwait(false);
                }
                catch
                {
                    await ImprovementManager.RollbackAsync(this, token).ConfigureAwait(false);
                    throw;
                }

                await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);
                return true;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Tooltip to use for Astral Reputation total.
        /// </summary>
        public string AstralReputationTooltip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdReturn))
                {
                    using (LockObject.EnterReadLock())
                    {
                        sbdReturn.Append(AstralReputation.ToString(GlobalSettings.CultureInfo));

                        foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.AstralReputation))
                        {
                            sbdReturn.Append(strSpace, '+')
                                .Append(strSpace, GetObjectName(objImprovement), strSpace)
                                .Append('(', objImprovement.Value.ToString(GlobalSettings.CultureInfo), ')');
                        }
                    }

                    return sbdReturn.ToString();
                }
            }
        }

        /// <summary>
        /// Tooltip to use for Astral Reputation total.
        /// </summary>
        public async Task<string> GetAstralReputationTooltipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                       out StringBuilder sbdReturn))
            {
                IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    sbdReturn.Append(
                        (await GetAstralReputationAsync(token).ConfigureAwait(false)).ToString(GlobalSettings
                            .CultureInfo));

                    foreach (Improvement objImprovement in await ImprovementManager
                                 .GetCachedImprovementListForValueOfAsync(this,
                                     Improvement.ImprovementType.AstralReputation, token: token)
                                 .ConfigureAwait(false))
                    {
                        sbdReturn.Append(strSpace, '+')
                            .Append(strSpace, await GetObjectNameAsync(objImprovement, token: token).ConfigureAwait(false), strSpace)
                            .Append('(', objImprovement.Value.ToString(GlobalSettings.CultureInfo), ')');
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }

                return sbdReturn.ToString();
            }
        }

        /// <summary>
        /// Astral Reputation (SG 207).
        /// </summary>
        public int TotalAstralReputation
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return Math.Max(
                        0,
                        AstralReputation + ImprovementManager
                                           .ValueOf(this, Improvement.ImprovementType.AstralReputation)
                                           .StandardRound());
            }
        }

        /// <summary>
        /// Astral Reputation (SG 207).
        /// </summary>
        public async Task<int> GetTotalAstralReputationAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return Math.Max(
                    0,
                    await GetAstralReputationAsync(token).ConfigureAwait(false) +
                    (await ImprovementManager
                        .ValueOfAsync(this, Improvement.ImprovementType.AstralReputation, token: token)
                        .ConfigureAwait(false)).StandardRound());
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Points of Astral Reputation that have added or removed manually (latter usually by burning Wild Reputation).
        /// </summary>
        public int AstralReputation
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _intBaseAstralReputation;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _intBaseAstralReputation, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Points of Astral Reputation that have added or removed manually (latter usually by burning Wild Reputation).
        /// </summary>
        public async Task<int> GetAstralReputationAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _intBaseAstralReputation;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Points of Astral Reputation that have added or removed manually (latter usually by burning Wild Reputation).
        /// </summary>
        public async Task SetAstralReputationAsync(int value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _intBaseAstralReputation, value) != value)
                    await OnPropertyChangedAsync(nameof(AstralReputation), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Tooltip to use for Wild Reputation total.
        /// </summary>
        public string WildReputationTooltip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdReturn))
                {
                    using (LockObject.EnterReadLock())
                    {
                        sbdReturn.Append(WildReputation.ToString(GlobalSettings.CultureInfo));

                        foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.AstralReputationWild))
                        {
                            sbdReturn.Append(strSpace, '+').Append(strSpace, GetObjectName(objImprovement), strSpace)
                                .Append('(', objImprovement.Value.ToString(GlobalSettings.CultureInfo), ')');
                        }
                    }

                    return sbdReturn.ToString();
                }
            }
        }

        /// <summary>
        /// Tooltip to use for Wild Reputation total.
        /// </summary>
        public async Task<string> GetWildReputationTooltipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                       out StringBuilder sbdReturn))
            {
                IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    sbdReturn.Append((await GetWildReputationAsync(token).ConfigureAwait(false))
                        .ToString(GlobalSettings.CultureInfo));

                    foreach (Improvement objImprovement in await ImprovementManager
                                 .GetCachedImprovementListForValueOfAsync(this,
                                     Improvement.ImprovementType.AstralReputationWild, token: token)
                                 .ConfigureAwait(false))
                    {
                        sbdReturn.Append(strSpace, '+').Append(strSpace, await GetObjectNameAsync(objImprovement, token: token).ConfigureAwait(false), strSpace)
                            .Append('(', objImprovement.Value.ToString(GlobalSettings.CultureInfo), ')');
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }

                return sbdReturn.ToString();
            }
        }

        /// <summary>
        /// Total Reputation with Wild Spirits (FA 175).
        /// </summary>
        public int TotalWildReputation
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return Math.Max(0,
                                    WildReputation
                                    + ImprovementManager.ValueOf(this, Improvement.ImprovementType.AstralReputationWild)
                                                        .StandardRound());
            }
        }

        /// <summary>
        /// Total Reputation with Wild Spirits (FA 175).
        /// </summary>
        public async Task<int> GetTotalWildReputationAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return Math.Max(0,
                    await GetWildReputationAsync(token).ConfigureAwait(false) + (await ImprovementManager
                        .ValueOfAsync(this, Improvement.ImprovementType.AstralReputationWild, token: token)
                        .ConfigureAwait(false)).StandardRound());
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Points of Wild Reputation that have added or removed manually (latter usually by burning it to lower Astral Reputation).
        /// </summary>
        public int WildReputation
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _intBaseWildReputation;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _intBaseWildReputation, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Points of Astral Reputation that have added or removed manually (latter usually by burning Wild Reputation).
        /// </summary>
        public async Task<int> GetWildReputationAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _intBaseWildReputation;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Points of Astral Reputation that have added or removed manually (latter usually by burning Wild Reputation).
        /// </summary>
        public async Task SetWildReputationAsync(int value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _intBaseWildReputation, value) != value)
                    await OnPropertyChangedAsync(nameof(WildReputation), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Number of Physical Condition Monitor Boxes that are filled.
        /// </summary>
        public int PhysicalCMFilled
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (HomeNode is Vehicle objVehicle)
                        return objVehicle.PhysicalCMFilled;

                    return _intPhysicalCMFilled;
                }
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (HomeNode is Vehicle objVehicle)
                    {
                        if (objVehicle.PhysicalCMFilled != value)
                        {
                            using (LockObject.EnterWriteLock())
                            {
                                objVehicle.PhysicalCMFilled = value;
                                OnPropertyChanged();
                            }
                        }
                    }
                    else if (Interlocked.Exchange(ref _intPhysicalCMFilled, value) != value)
                    {
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Number of Physical Condition Monitor Boxes that are filled.
        /// </summary>
        public async Task<int> GetPhysicalCMFilledAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await GetHomeNodeAsync(token).ConfigureAwait(false) is Vehicle objVehicle)
                    return objVehicle.PhysicalCMFilled;

                return _intPhysicalCMFilled;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Number of Physical Condition Monitor Boxes that are filled.
        /// </summary>
        public async Task SetPhysicalCMFilledAsync(int value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (HomeNode is Vehicle objVehicle)
                {
                    if (objVehicle.PhysicalCMFilled != value)
                    {
                        IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                        try
                        {
                            token.ThrowIfCancellationRequested();
                            objVehicle.PhysicalCMFilled = value;
                            await OnPropertyChangedAsync(nameof(PhysicalCMFilled), token).ConfigureAwait(false);
                        }
                        finally
                        {
                            await objLocker2.DisposeAsync().ConfigureAwait(false);
                        }
                    }
                }
                else if (Interlocked.Exchange(ref _intPhysicalCMFilled, value) != value)
                {
                    await OnPropertyChangedAsync(nameof(PhysicalCMFilled), token).ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Number of Stun Condition Monitor Boxes that are filled.
        /// </summary>
        public int StunCMFilled
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (IsAI && HomeNode != null)
                    {
                        // A.I. do not have a Stun Condition Monitor, but they do have a Matrix Condition Monitor if they are in their home node.
                        return HomeNode.MatrixCMFilled;
                    }

                    return _intStunCMFilled;
                }
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (IsAI && HomeNode != null)
                    {
                        // A.I. do not have a Stun Condition Monitor, but they do have a Matrix Condition Monitor if they are in their home node.
                        if (HomeNode.MatrixCMFilled != value)
                        {
                            using (LockObject.EnterWriteLock())
                            {
                                HomeNode.MatrixCMFilled = value;
                                OnPropertyChanged();
                            }
                        }
                    }
                    else if (Interlocked.Exchange(ref _intStunCMFilled, value) != value)
                    {
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Number of Stun Condition Monitor Boxes that are filled.
        /// </summary>
        public async Task<int> GetStunCMFilledAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    IHasMatrixAttributes objHomeNode = await GetHomeNodeAsync(token).ConfigureAwait(false);
                    if (objHomeNode != null)
                    {
                        // A.I. do not have a Stun Condition Monitor, but they do have a Matrix Condition Monitor if they are in their home node.
                        return objHomeNode.MatrixCMFilled;
                    }
                }

                return _intStunCMFilled;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Number of Stun Condition Monitor Boxes that are filled.
        /// </summary>
        public async Task SetStunCMFilledAsync(int value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    IHasMatrixAttributes objHomeNode = await GetHomeNodeAsync(token).ConfigureAwait(false);
                    if (objHomeNode != null)
                    {
                        // A.I. do not have a Stun Condition Monitor, but they do have a Matrix Condition Monitor if they are in their home node.
                        if (HomeNode.MatrixCMFilled != value)
                        {
                            IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                            try
                            {
                                token.ThrowIfCancellationRequested();
                                HomeNode.MatrixCMFilled = value;
                                await OnPropertyChangedAsync(nameof(StunCMFilled), token).ConfigureAwait(false);
                            }
                            finally
                            {
                                await objLocker2.DisposeAsync().ConfigureAwait(false);
                            }
                        }
                    }
                    else if (Interlocked.Exchange(ref _intStunCMFilled, value) != value)
                    {
                        await OnPropertyChangedAsync(nameof(StunCMFilled), token).ConfigureAwait(false);
                    }
                }
                else if (Interlocked.Exchange(ref _intStunCMFilled, value) != value)
                {
                    await OnPropertyChangedAsync(nameof(StunCMFilled), token).ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public bool AddInitiationsAllowed
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return Created || IgnoreRules || Settings.AllowInitiationInCreateMode;
            }
        }

        public async Task<bool> GetAddInitiationsAllowedAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await GetCreatedAsync(token).ConfigureAwait(false)
                       || await GetIgnoreRulesAsync(token).ConfigureAwait(false)
                       || await (await GetSettingsAsync(token).ConfigureAwait(false))
                           .GetAllowInitiationInCreateModeAsync(token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether character creation rules should be ignored.
        /// </summary>
        [HubTag]
        public bool IgnoreRules
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _blnIgnoreRules;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (_blnIgnoreRules == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnIgnoreRules = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Whether character creation rules should be ignored.
        /// </summary>
        public async Task<bool> GetIgnoreRulesAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _blnIgnoreRules;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether character creation rules should be ignored.
        /// </summary>
        public async Task SetIgnoreRulesAsync(bool value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_blnIgnoreRules == value)
                    return;
                IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    _blnIgnoreRules = value;
                    await OnPropertyChangedAsync(nameof(IgnoreRules), token).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Contact Points.
        /// </summary>
        public int ContactPoints
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (_intCachedContactPoints == int.MinValue)
                    {
                        string strExpression = Settings.ContactPointsExpression;
                        if (strExpression.DoesNeedXPathProcessingToBeConvertedToNumber(out decimal decValue))
                        {
                            strExpression = ProcessAttributesInXPath(strExpression);
                            // This is first converted to a decimal and rounded up since some items have a multiplier that is not a whole number, such as 2.5.
                            (bool blnIsSuccess, object objProcess)
                                    = CommonFunctions.EvaluateInvariantXPath(strExpression);
                            return _intCachedContactPoints = blnIsSuccess ? ((double)objProcess).StandardRound() : 0;
                        }
                        else
                            _intCachedContactPoints = decValue.StandardRound();
                    }

                    return _intCachedContactPoints;
                }
            }
        }

        public async Task<int> GetContactPointsAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_intCachedContactPoints == int.MinValue)
                {
                    string strExpression = await (await GetSettingsAsync(token).ConfigureAwait(false)).GetContactPointsExpressionAsync(token).ConfigureAwait(false);
                    if (strExpression.DoesNeedXPathProcessingToBeConvertedToNumber(out decimal decValue))
                    {
                        strExpression = await ProcessAttributesInXPathAsync(strExpression, token: token).ConfigureAwait(false);
                        // This is first converted to a decimal and rounded up since some items have a multiplier that is not a whole number, such as 2.5.
                        (bool blnIsSuccess, object objProcess)
                                = await CommonFunctions.EvaluateInvariantXPathAsync(strExpression, token).ConfigureAwait(false);
                        return _intCachedContactPoints = blnIsSuccess ? ((double)objProcess).StandardRound() : 0;
                    }
                    else
                        _intCachedContactPoints = decValue.StandardRound();
                }

                return _intCachedContactPoints;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Number of free Contact Points (and Friends in High Places Points) the character has used.
        /// </summary>
        public ValueTuple<int, int> ContactPointsUsed
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    bool blnFriendsInHighPlaces = FriendsInHighPlaces;
                    int intHighPlacesFriends = 0;
                    int intPointsInContacts = Contacts.Sum(objContact =>
                    {
                        // Don't care about free contacts and group contacts
                        if (objContact.EntityType != ContactType.Contact)
                            return 0;
                        if (objContact.IsGroup)
                            return 0;
                        int intCost = objContact.ContactPoints;
                        if (intCost == 0)
                            return 0;

                        if (objContact.Connection >= 8 && blnFriendsInHighPlaces)
                        {
                            intHighPlacesFriends += intCost;
                        }
                        else
                        {
                            return intCost;
                        }
                        return 0;
                    });
                    return new ValueTuple<int, int>(intPointsInContacts, intHighPlacesFriends);
                }
            }
        }

        /// <summary>
        /// Number of free Contact Points (and Friends in High Places Points) the character has used.
        /// </summary>
        public async Task<ValueTuple<int, int>> GetContactPointsUsedAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                bool blnFriendsInHighPlaces
                    = await GetFriendsInHighPlacesAsync(token).ConfigureAwait(false);
                int intHighPlacesFriends = 0;
                ThreadSafeObservableCollection<Contact> lstContacts = await GetContactsAsync(token).ConfigureAwait(false);
                int intPointsInContacts = await lstContacts.SumAsync(async objContact =>
                {
                    // Don't care about free contacts and group contacts
                    if (await objContact.GetEntityTypeAsync(token).ConfigureAwait(false) != ContactType.Contact)
                        return 0;
                    if (await objContact.GetIsGroupAsync(token).ConfigureAwait(false))
                        return 0;
                    int intCost = await objContact.GetContactPointsAsync(token).ConfigureAwait(false);
                    if (intCost == 0)
                        return 0;

                    if (await objContact.GetConnectionAsync(token).ConfigureAwait(false) >= 8 && blnFriendsInHighPlaces)
                    {
                        intHighPlacesFriends += intCost;
                    }
                    else
                    {
                        return intCost;
                    }
                    return 0;
                }, token).ConfigureAwait(false);

                return new ValueTuple<int, int>(intPointsInContacts, intHighPlacesFriends);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Carry limit (in kg) with added Lift and Carry hits.
        /// </summary>
        public decimal CarryLimit
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return BaseCarryLimit + CurrentLiftCarryHits * 10m;
            }
        }

        /// <summary>
        /// Lift limit (in kg) with added Lift and Carry hits.
        /// </summary>
        public async Task<decimal> GetCarryLimitAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await GetBaseCarryLimitAsync(token).ConfigureAwait(false) + await GetCurrentLiftCarryHitsAsync(token).ConfigureAwait(false) * 10m;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Carry limit (in kg) without added Lift and Carry hits.
        /// </summary>
        public decimal BaseCarryLimit
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    decimal decReturn = _decCachedBaseCarryLimit;
                    if (decReturn != decimal.MinValue)
                        return decReturn;
                    string strExpression = Settings.CarryLimitExpression;
                    if (strExpression.DoesNeedXPathProcessingToBeConvertedToNumber(out decReturn))
                    {
                        strExpression = ProcessAttributesInXPath(strExpression);
                        (bool blnIsSuccess, object objProcess)
                                    = CommonFunctions.EvaluateInvariantXPath(
                                        strExpression);
                        return _decCachedBaseCarryLimit = blnIsSuccess ? Convert.ToDecimal((double)objProcess) : 0;
                    }
                    return _decCachedBaseCarryLimit = decReturn;
                }
            }
        }

        /// <summary>
        /// Carry limit (in kg) without added Lift and Carry hits.
        /// </summary>
        public async Task<decimal> GetBaseCarryLimitAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                decimal decReturn = _decCachedBaseCarryLimit;
                if (decReturn != decimal.MinValue)
                    return decReturn;
                string strExpression = await (await GetSettingsAsync(token).ConfigureAwait(false))
                    .GetCarryLimitExpressionAsync(token).ConfigureAwait(false);
                if (strExpression.DoesNeedXPathProcessingToBeConvertedToNumber(out decReturn))
                {
                    strExpression = await ProcessAttributesInXPathAsync(strExpression, token: token).ConfigureAwait(false);
                    // This is first converted to a decimal and rounded up since some items have a multiplier that is not a whole number, such as 2.5.
                    (bool blnIsSuccess, object objProcess)
                        = await CommonFunctions.EvaluateInvariantXPathAsync(strExpression, token)
                            .ConfigureAwait(false);
                    return _decCachedBaseCarryLimit = blnIsSuccess ? Convert.ToDecimal((double)objProcess) : 0;
                }
                return _decCachedBaseCarryLimit = decReturn;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Lift limit (in kg) with added Lift and Carry hits.
        /// </summary>
        public decimal LiftLimit
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return BaseLiftLimit + CurrentLiftCarryHits * 10m;
            }
        }

        /// <summary>
        /// Lift limit (in kg) with added Lift and Carry hits.
        /// </summary>
        public async Task<decimal> GetLiftLimitAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await GetBaseLiftLimitAsync(token).ConfigureAwait(false) + await GetCurrentLiftCarryHitsAsync(token).ConfigureAwait(false) * 10m;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Lift limit (in kg) without added Lift and Carry hits.
        /// </summary>
        public decimal BaseLiftLimit
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    decimal decReturn = _decCachedBaseLiftLimit;
                    if (decReturn != decimal.MinValue)
                        return decReturn;
                    string strExpression = Settings.LiftLimitExpression;
                    if (strExpression.DoesNeedXPathProcessingToBeConvertedToNumber(out decReturn))
                    {
                        strExpression = ProcessAttributesInXPath(strExpression);
                        (bool blnIsSuccess, object objProcess)
                                = CommonFunctions.EvaluateInvariantXPath(
                                    strExpression);
                        return _decCachedBaseLiftLimit = blnIsSuccess ? Convert.ToDecimal((double)objProcess) : 0;
                    }
                    return _decCachedBaseLiftLimit = decReturn;
                }
            }
        }

        /// <summary>
        /// Carry limit (in kg) without added Lift and Carry hits.
        /// </summary>
        public async Task<decimal> GetBaseLiftLimitAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                decimal decReturn = _decCachedBaseLiftLimit;
                if (decReturn != decimal.MinValue)
                    return decReturn;
                string strExpression = await (await GetSettingsAsync(token).ConfigureAwait(false))
                    .GetLiftLimitExpressionAsync(token).ConfigureAwait(false);
                if (strExpression.DoesNeedXPathProcessingToBeConvertedToNumber(out decReturn))
                {
                    strExpression = await ProcessAttributesInXPathAsync(strExpression, token: token).ConfigureAwait(false);
                    (bool blnIsSuccess, object objProcess)
                            = await CommonFunctions.EvaluateInvariantXPathAsync(strExpression, token)
                                .ConfigureAwait(false);
                    return _decCachedBaseLiftLimit = blnIsSuccess ? Convert.ToDecimal((double)objProcess) : 0;
                }
                return _decCachedBaseLiftLimit = decReturn;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Encumbrance interval (in kg).
        /// </summary>
        public decimal EncumbranceInterval
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    decimal decReturn = _decCachedEncumbranceInterval;
                    if (decReturn != decimal.MinValue)
                        return decReturn;
                    string strExpression = Settings.EncumbranceIntervalExpression;
                    if (strExpression.DoesNeedXPathProcessingToBeConvertedToNumber(out decReturn))
                    {
                        strExpression = ProcessAttributesInXPath(strExpression);
                        (bool blnIsSuccess, object objProcess)
                                = CommonFunctions.EvaluateInvariantXPath(
                                    strExpression);
                        decReturn = blnIsSuccess ? Convert.ToDecimal((double)objProcess) : 0;
                    }

                    // Need this to make sure our division doesn't go haywire
                    if (decReturn <= 0)
                        decReturn = DecimalExtensions.DoubleEpsilon;

                    return _decCachedEncumbranceInterval = decReturn;
                }
            }
        }

        /// <summary>
        /// Encumbrance interval (in kg).
        /// </summary>
        public async Task<decimal> GetEncumbranceIntervalAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                decimal decReturn = _decCachedEncumbranceInterval;
                if (decReturn != decimal.MinValue)
                    return decReturn;
                string strExpression = await (await GetSettingsAsync(token).ConfigureAwait(false))
                    .GetEncumbranceIntervalExpressionAsync(token).ConfigureAwait(false);
                if (strExpression.DoesNeedXPathProcessingToBeConvertedToNumber(out decReturn))
                {
                    strExpression = await ProcessAttributesInXPathAsync(strExpression, token: token).ConfigureAwait(false);
                    (bool blnIsSuccess, object objProcess)
                            = await CommonFunctions.EvaluateInvariantXPathAsync(
                                strExpression, token).ConfigureAwait(false);
                    decReturn = blnIsSuccess ? Convert.ToDecimal((double)objProcess) : 0;
                }

                // Need this to make sure our division doesn't go haywire
                if (decReturn <= 0)
                    decReturn = DecimalExtensions.DoubleEpsilon;

                return _decCachedEncumbranceInterval = decReturn;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// CFP Limit.
        /// </summary>
        public int CFPLimit
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _intCFPLimit;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _intCFPLimit, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// CFP Limit.
        /// </summary>
        public async Task<int> GetCFPLimitAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _intCFPLimit;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// CFP Limit.
        /// </summary>
        public async Task SetCFPLimitAsync(int value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _intCFPLimit, value) == value)
                    return;
                await OnPropertyChangedAsync(nameof(CFPLimit), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Total AI Program Limit.
        /// </summary>
        public int AINormalProgramLimit
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _intAINormalProgramLimit;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _intAINormalProgramLimit, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Total AI Program Limit.
        /// </summary>
        public async Task<int> GetAINormalProgramLimitAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _intAINormalProgramLimit;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Total AI Program Limit.
        /// </summary>
        public async Task SetAINormalProgramLimitAsync(int value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _intAINormalProgramLimit, value) == value)
                    return;
                await OnPropertyChangedAsync(nameof(AINormalProgramLimit), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// AI Advanced Program Limit.
        /// </summary>
        public int AIAdvancedProgramLimit
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _intAIAdvancedProgramLimit;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _intAIAdvancedProgramLimit, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// AI Advanced Program Limit.
        /// </summary>
        public async Task<int> GetAIAdvancedProgramLimitAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _intAIAdvancedProgramLimit;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// AI Advanced Program Limit.
        /// </summary>
        public async Task SetAIAdvancedProgramLimitAsync(int value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _intAIAdvancedProgramLimit, value) == value)
                    return;
                await OnPropertyChangedAsync(nameof(AIAdvancedProgramLimit), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Spell Limit.
        /// </summary>
        public int FreeSpells
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _intFreeSpells;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _intFreeSpells, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Spell Limit.
        /// </summary>
        public async Task<int> GetFreeSpellsAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _intFreeSpells;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Spell Limit.
        /// </summary>
        public async Task SetFreeSpellsAsync(int value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _intFreeSpells, value) == value)
                    return;
                await OnPropertyChangedAsync(nameof(FreeSpells), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Karma.
        /// </summary>
        public int Karma
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _intKarma;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _intKarma, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Karma.
        /// </summary>
        public async Task<int> GetKarmaAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _intKarma;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Karma.
        /// </summary>
        public async Task SetKarmaAsync(int value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _intKarma, value) == value)
                    return;
                await OnPropertyChangedAsync(nameof(Karma), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Karma.
        /// </summary>
        public async Task ModifyKarmaAsync(int value, CancellationToken token = default)
        {
            if (value == 0)
                return;
            IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                Interlocked.Add(ref _intKarma, value);
                await OnPropertyChangedAsync(nameof(Karma), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplayKarma
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return Karma.ToString(GlobalSettings.CultureInfo);
            }
        }

        public async Task<string> GetDisplayKarmaAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return (await GetKarmaAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Special.
        /// </summary>
        public int Special
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _intSpecial;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _intSpecial, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Special.
        /// </summary>
        public async Task<int> GetSpecialAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _intSpecial;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Special.
        /// </summary>
        public async Task SetSpecialAsync(int value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _intSpecial, value) == value)
                    return;
                await OnPropertyChangedAsync(nameof(Special), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// TotalSpecial.
        /// </summary>
        public int TotalSpecial
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _intTotalSpecial;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _intTotalSpecial, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// TotalSpecial.
        /// </summary>
        public async Task<int> GetTotalSpecialAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _intTotalSpecial;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// TotalSpecial.
        /// </summary>
        public async Task SetTotalSpecialAsync(int value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _intTotalSpecial, value) == value)
                    return;
                await OnPropertyChangedAsync(nameof(TotalSpecial), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Attributes.
        /// </summary>
        public int Attributes
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _intAttributes;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _intAttributes, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Attributes.
        /// </summary>
        public async Task<int> GetAttributesAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _intAttributes;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Attributes.
        /// </summary>
        public async Task SetAttributesAsync(int value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _intAttributes, value) == value)
                    return;
                await OnPropertyChangedAsync(nameof(Attributes), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// TotalAttributes.
        /// </summary>
        public int TotalAttributes
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _intTotalAttributes;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _intTotalAttributes, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// TotalAttributes.
        /// </summary>
        public async Task<int> GetTotalAttributesAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _intTotalAttributes;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// TotalAttributes.
        /// </summary>
        public async Task SetTotalAttributesAsync(int value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _intTotalAttributes, value) == value)
                    return;
                await OnPropertyChangedAsync(nameof(TotalAttributes), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private int _intCachedCareerKarma = int.MinValue;

        /// <summary>
        /// Total amount of Karma the character has earned over the career.
        /// </summary>
        [HubTag]
        public int CareerKarma
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (_intCachedCareerKarma != int.MinValue)
                        return _intCachedCareerKarma;

                    int intKarma = 0;

                    foreach (ExpenseLogEntry objEntry in _lstExpenseLog)
                    {
                        // Since we're only interested in the amount they have earned, only count values that are greater than 0 and are not refunds.
                        if (objEntry.Type == ExpenseType.Karma && (objEntry.Amount > 0 || objEntry.ForceCareerVisible)
                                                               && !objEntry.Refund)
                            intKarma += objEntry.Amount.StandardRound();
                    }

                    return _intCachedCareerKarma = intKarma;
                }
            }
        }

        /// <summary>
        /// Total amount of Karma the character has earned over the career.
        /// </summary>
        public async Task<int> GetCareerKarmaAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_intCachedCareerKarma != int.MinValue)
                    return _intCachedCareerKarma;
                return _intCachedCareerKarma = await _lstExpenseLog.SumAsync(objEntry =>
                {
                    // Since we're only interested in the amount they have earned, only count values that are greater than 0 and are not refunds.
                    if (objEntry.Type == ExpenseType.Karma
                        && (objEntry.Amount > 0 || objEntry.ForceCareerVisible)
                        && !objEntry.Refund)
                        return objEntry.Amount.StandardRound();
                    return 0;
                }, token: token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplayCareerKarma => CareerKarma.ToString(GlobalSettings.CultureInfo);

        public async Task<string> GetDisplayCareerKarmaAsync(CancellationToken token = default) =>
            (await GetCareerKarmaAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo);

        private decimal _decCachedCareerNuyen = decimal.MinValue;

        /// <summary>
        /// Total amount of Nuyen the character has earned over the career.
        /// </summary>
        public decimal CareerNuyen
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    decimal decNuyen = _decCachedCareerNuyen;
                    if (decNuyen != decimal.MinValue)
                        return decNuyen;
                    decNuyen = 0;

                    foreach (ExpenseLogEntry objEntry in _lstExpenseLog)
                    {
                        // Since we're only interested in the amount they have earned, only count values that are greater than 0 and are not refunds.
                        if (objEntry.Type == ExpenseType.Nuyen
                            && (objEntry.Amount > 0 || objEntry.ForceCareerVisible)
                            && !objEntry.Refund)
                            decNuyen += objEntry.Amount;
                    }

                    return _decCachedCareerNuyen = decNuyen;
                }
            }
        }

        public async Task<decimal> GetCareerNuyenAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_decCachedCareerNuyen != decimal.MinValue)
                    return _decCachedCareerNuyen;
                return _decCachedCareerNuyen = await _lstExpenseLog.SumAsync(objEntry =>
                {
                    // Since we're only interested in the amount they have earned, only count values that are greater than 0 and are not refunds.
                    if (objEntry.Type == ExpenseType.Nuyen
                        && (objEntry.Amount > 0 || objEntry.ForceCareerVisible)
                        && !objEntry.Refund)
                        return objEntry.Amount;
                    return 0;
                }, token: token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplayCareerNuyen
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return CareerNuyen.ToString(Settings.NuyenFormat, GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol");
            }
        }

        public async Task<string> GetDisplayCareerNuyenAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                string strNuyenFormat = await (await GetSettingsAsync(token).ConfigureAwait(false)).GetNuyenFormatAsync(token).ConfigureAwait(false);
                return (await GetCareerNuyenAsync(token).ConfigureAwait(false)).ToString(strNuyenFormat,
                    GlobalSettings.CultureInfo) + await LanguageManager
                    .GetStringAsync("String_NuyenSymbol", token: token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public int EdgeUsed
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _intEdgeUsed;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _intEdgeUsed, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        public async Task<int> GetEdgeUsedAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _intEdgeUsed;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public async Task SetEdgeUsedAsync(int value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _intEdgeUsed, value) == value)
                    return;
                await OnPropertyChangedAsync(nameof(EdgeUsed), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public async Task ModifyEdgeUsedAsync(int value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (value == 0)
                return;
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                Interlocked.Add(ref _intEdgeUsed, value);
                await OnPropertyChangedAsync(nameof(EdgeUsed), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public int EdgeRemaining
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return EDG.TotalValue - EdgeUsed;
            }
        }

        public async Task<int> GetEdgeRemainingAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await (await GetAttributeAsync("EDG", token: token).ConfigureAwait(false))
                           .GetTotalValueAsync(token).ConfigureAwait(false) -
                       await GetEdgeUsedAsync(token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string EdgeRemainingString
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return EdgeRemaining.ToString(GlobalSettings.CultureInfo) + LanguageManager.GetString("String_Of")
                                                                              + EDG.TotalValue.ToString(
                                                                                  GlobalSettings.CultureInfo)
                                                                              + LanguageManager.GetString(
                                                                                  "String_Space")
                                                                              + LanguageManager.GetString(
                                                                                  "String_Remaining");
            }
        }

        public async Task<string> GetEdgeRemainingStringAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return (await GetEdgeRemainingAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo) +
                       await LanguageManager.GetStringAsync("String_Of", token: token).ConfigureAwait(false) +
                       (await (await GetAttributeAsync("EDG", token: token).ConfigureAwait(false))
                           .GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo) +
                       await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false) +
                       await LanguageManager.GetStringAsync("String_Remaining", token: token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether the character is a Critter.
        /// </summary>
        [HubTag]
        public bool IsCritter
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _blnIsCritter;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (_blnIsCritter == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnIsCritter = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Whether the character is a Critter.
        /// </summary>
        public async Task<bool> GetIsCritterAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _blnIsCritter;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether the character is a Critter.
        /// </summary>
        public async Task SetIsCritterAsync(bool value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_blnIsCritter == value)
                    return;
                IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    _blnIsCritter = value;
                    await OnPropertyChangedAsync(nameof(IsCritter), token).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether the character is a changeling.
        /// </summary>
        [HubTag]
        public bool IsChangeling
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return MetagenicLimit > 0;
            }
        }

        /// <summary>
        /// Whether the character is a changeling.
        /// </summary>
        public async Task<bool> GetIsChangelingAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await GetMetagenicLimitAsync(token).ConfigureAwait(false) > 0;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// The highest number of free Metagenic qualities the character can have.
        /// </summary>
        public int MetagenicLimit => ImprovementManager.ValueOf(this, Improvement.ImprovementType.MetageneticLimit)
                                                       .StandardRound();

        /// <summary>
        /// The highest number of free Metagenic qualities the character can have.
        /// </summary>
        public async Task<int> GetMetagenicLimitAsync(CancellationToken token = default) =>
            (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.MetageneticLimit, token: token)
                .ConfigureAwait(false)).StandardRound();

        public int SpecialModificationLimit =>
            ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpecialModificationLimit)
                              .StandardRound();

        public async Task<int> GetSpecialModificationLimitAsync(CancellationToken token = default) =>
            (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpecialModificationLimit, token: token)
                .ConfigureAwait(false)).StandardRound();

        /// <summary>
        /// Whether the character is possessed by a Spirit.
        /// </summary>
        public bool Possessed
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _blnPossessed;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (_blnPossessed == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnPossessed = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Whether the character is possessed by a Spirit.
        /// </summary>
        public async Task<bool> GetPossessedAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _blnPossessed;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether the character is possessed by a Spirit.
        /// </summary>
        public async Task SetPossessedAsync(bool value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_blnPossessed == value)
                    return;
                IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    _blnPossessed = value;
                    await OnPropertyChangedAsync(nameof(Possessed), token).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public int SpellKarmaCost(string strCategory = "")
        {
            using (LockObject.EnterReadLock())
            {
                decimal decReturn = Settings.KarmaSpell;
                decReturn += ImprovementManager.ValueOf(this, Improvement.ImprovementType.NewSpellKarmaCost,
                                                        strImprovedName: strCategory, blnIncludeNonImproved: true);
                decimal decMultiplier = 1.0m;
                foreach (Improvement objLoopImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                             this, Improvement.ImprovementType.NewSpellKarmaCostMultiplier, strCategory, blnIncludeNonImproved: true))
                {
                    decMultiplier *= objLoopImprovement.Value / 100.0m;
                }

                if (decMultiplier != 1.0m)
                    decReturn *= decMultiplier;

                return Math.Max(decReturn.StandardRound(), 0);
            }
        }

        public async Task<int> SpellKarmaCostAsync(string strCategory = "", CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                decimal decReturn = await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKarmaSpellAsync(token).ConfigureAwait(false);
                decReturn += await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.NewSpellKarmaCost,
                                                                   strImprovedName: strCategory, blnIncludeNonImproved: true, token: token).ConfigureAwait(false);
                decimal decMultiplier = 1.0m;
                foreach (Improvement objLoopImprovement in await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                             this, Improvement.ImprovementType.NewSpellKarmaCostMultiplier, strCategory, blnIncludeNonImproved: true, token: token).ConfigureAwait(false))
                {
                    decMultiplier *= objLoopImprovement.Value / 100.0m;
                }

                if (decMultiplier != 1.0m)
                    decReturn *= decMultiplier;

                return Math.Max(decReturn.StandardRound(), 0);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public int ComplexFormKarmaCost
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    decimal decReturn = Settings.KarmaNewComplexForm;
                    decReturn += ImprovementManager.ValueOf(this, Improvement.ImprovementType.NewComplexFormKarmaCost);
                    decimal decMultiplier = 1.0m;
                    foreach (Improvement objLoopImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                 this, Improvement.ImprovementType.NewComplexFormKarmaCostMultiplier))
                    {
                        decMultiplier *= objLoopImprovement.Value / 100.0m;
                    }

                    if (decMultiplier != 1.0m)
                        decReturn *= decMultiplier;

                    return Math.Max(decReturn.StandardRound(), 0);
                }
            }
        }

        public async Task<int> GetComplexFormKarmaCostAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                decimal decReturn = await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKarmaNewComplexFormAsync(token).ConfigureAwait(false);
                decReturn += await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.NewComplexFormKarmaCost, token: token).ConfigureAwait(false);
                decimal decMultiplier = 1.0m;
                foreach (Improvement objLoopImprovement in await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                             this, Improvement.ImprovementType.NewComplexFormKarmaCostMultiplier, token: token).ConfigureAwait(false))
                {
                    decMultiplier *= objLoopImprovement.Value / 100.0m;
                }

                if (decMultiplier != 1.0m)
                    decReturn *= decMultiplier;

                return Math.Max(decReturn.StandardRound(), 0);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public int AIProgramKarmaCost
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    decimal decReturn = Settings.KarmaNewAIProgram;
                    decReturn += ImprovementManager.ValueOf(this, Improvement.ImprovementType.NewAIProgramKarmaCost);
                    decimal decMultiplier = 1.0m;
                    foreach (Improvement objLoopImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                 this, Improvement.ImprovementType.NewAIProgramKarmaCostMultiplier))
                    {
                        decMultiplier *= objLoopImprovement.Value / 100.0m;
                    }
                    
                    if (decMultiplier != 1.0m)
                        decReturn *= decMultiplier;

                    return Math.Max(decReturn.StandardRound(), 0);
                }
            }
        }

        public async Task<int> GetAIProgramKarmaCostAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                decimal decReturn = await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKarmaNewAIProgramAsync(token).ConfigureAwait(false);
                decReturn += await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.NewAIProgramKarmaCost, token: token).ConfigureAwait(false);
                decimal decMultiplier = 1.0m;
                foreach (Improvement objLoopImprovement in await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                             this, Improvement.ImprovementType.NewAIProgramKarmaCostMultiplier, token: token).ConfigureAwait(false))
                {
                    decMultiplier *= objLoopImprovement.Value / 100.0m;
                }

                if (decMultiplier != 1.0m)
                    decReturn *= decMultiplier;

                return Math.Max(decReturn.StandardRound(), 0);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public int AIAdvancedProgramKarmaCost
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    decimal decReturn = Settings.KarmaNewAIAdvancedProgram;
                    decReturn += ImprovementManager.ValueOf(this, Improvement.ImprovementType.NewAIAdvancedProgramKarmaCost);
                    decimal decMultiplier = 1.0m;
                    foreach (Improvement objLoopImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                 this, Improvement.ImprovementType.NewAIAdvancedProgramKarmaCostMultiplier))
                    {
                        decMultiplier *= objLoopImprovement.Value / 100.0m;
                    }

                    if (decMultiplier != 1.0m)
                        decReturn *= decMultiplier;

                    return Math.Max(decReturn.StandardRound(), 0);
                }
            }
        }

        public async Task<int> GetAIAdvancedProgramKarmaCostAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                decimal decReturn = await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKarmaNewAIAdvancedProgramAsync(token).ConfigureAwait(false);
                decReturn += await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.NewAIAdvancedProgramKarmaCost, token: token).ConfigureAwait(false);
                decimal decMultiplier = 1.0m;
                foreach (Improvement objLoopImprovement in await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                             this, Improvement.ImprovementType.NewAIAdvancedProgramKarmaCostMultiplier, token: token).ConfigureAwait(false))
                {
                    decMultiplier *= objLoopImprovement.Value / 100.0m;
                }

                if (decMultiplier != 1.0m)
                    decReturn *= decMultiplier;

                return Math.Max(decReturn.StandardRound(), 0);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public bool Ambidextrous => ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Ambidextrous).Count > 0;

        public async Task<bool> GetAmbidextrousAsync(CancellationToken token = default)
        {
            return (await ImprovementManager.GetCachedImprovementListForValueOfAsync(this, Improvement.ImprovementType.Ambidextrous, token: token).ConfigureAwait(false)).Count > 0;
        }

        #endregion Basic Properties

        #region Attributes

        /// <summary>
        /// Get a CharacterAttribute by its name.
        /// </summary>
        /// <param name="strAttribute">CharacterAttribute name to retrieve.</param>
        /// <param name="blnExplicit">Whether to force looking for a specific attribute name.
        /// Mostly expected to be used for gutting Mystic Adept power points.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public CharacterAttrib GetAttribute(string strAttribute, bool blnExplicit = false, CancellationToken token = default)
        {
            using (LockObject.EnterReadLock(token))
            {
                if (strAttribute == "MAGAdept" && !blnExplicit && (!IsMysticAdept || !Settings.MysAdeptSecondMAGAttribute))
                    strAttribute = "MAG";
                return AttributeSection.GetAttributeByName(strAttribute, token);
            }
        }

        /// <summary>
        /// Get a CharacterAttribute by its name.
        /// </summary>
        /// <param name="strAttribute">CharacterAttribute name to retrieve.</param>
        /// <param name="blnExplicit">Whether to force looking for a specific attribute name.
        /// Mostly expected to be used for gutting Mystic Adept power points.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public async Task<CharacterAttrib> GetAttributeAsync(string strAttribute, bool blnExplicit = false, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (strAttribute == "MAGAdept" && !blnExplicit && (!await GetIsMysticAdeptAsync(token).ConfigureAwait(false) || !await (await GetSettingsAsync(token).ConfigureAwait(false)).GetMysAdeptSecondMAGAttributeAsync(token).ConfigureAwait(false)))
                    strAttribute = "MAG";
                return await (await GetAttributeSectionAsync(token).ConfigureAwait(false)).GetAttributeByNameAsync(strAttribute, token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Get all of a Character's CharacterAttributes.
        /// </summary>
        /// <param name="token">Cancellation token to listen to.</param>
        public IEnumerable<CharacterAttrib> GetAllAttributes(CancellationToken token = default)
        {
            using (LockObject.EnterReadLock(token))
            {
                foreach (CharacterAttrib objAttribute in AttributeSection.AllAttributes)
                {
                    token.ThrowIfCancellationRequested();
                    yield return objAttribute;
                }
            }
        }

        /// <summary>
        /// Get all of a Character's CharacterAttributes.
        /// </summary>
        /// <param name="token">Cancellation token to listen to.</param>
        public async Task<List<CharacterAttrib>> GetAllAttributesAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            return (await (await GetAttributeSectionAsync(token).ConfigureAwait(false)).GetAllAttributesAsync(token).ConfigureAwait(false)).ToList();
        }

        /// <summary>
        /// Get all CharacterAttributes that have a particular abbreviation.
        /// </summary>
        /// <param name="strAttribute">CharacterAttribute name to retrieve.</param>
        /// <param name="blnExplicit">Whether to force looking for a specific attribute name.
        /// Mostly expected to be used for gutting Mystic Adept power points.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public IEnumerable<CharacterAttrib> GetAllAttributes(string strAttribute, bool blnExplicit = false, CancellationToken token = default)
        {
            using (AttributeSection.LockObject.EnterReadLock(token))
            {
                if (strAttribute == "MAGAdept" && (!IsMysticAdept || !Settings.MysAdeptSecondMAGAttribute)
                                               && !blnExplicit)
                    strAttribute = "MAG";
                foreach (CharacterAttrib objAttribute in AttributeSection.AllAttributes)
                {
                    token.ThrowIfCancellationRequested();
                    if (objAttribute.Abbrev == strAttribute)
                        yield return objAttribute;
                }
            }
        }

        /// <summary>
        /// Get all CharacterAttributes that have a particular abbreviation.
        /// </summary>
        /// <param name="strAttribute">CharacterAttribute name to retrieve.</param>
        /// <param name="blnExplicit">Whether to force looking for a specific attribute name.
        /// Mostly expected to be used for gutting Mystic Adept power points.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public async Task<List<CharacterAttrib>> GetAllAttributesAsync(string strAttribute, bool blnExplicit = false, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            AttributeSection objAttributeSection = await GetAttributeSectionAsync(token).ConfigureAwait(false);
            IAsyncDisposable objLocker = await objAttributeSection.LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                if (strAttribute == "MAGAdept" && (!await GetIsMysticAdeptAsync(token).ConfigureAwait(false)
                                                   || !await (await GetSettingsAsync(token).ConfigureAwait(false)).GetMysAdeptSecondMAGAttributeAsync(token).ConfigureAwait(false))
                                               && !blnExplicit)
                    strAttribute = "MAG";
                List<CharacterAttrib> lstReturn = new List<CharacterAttrib>(2);
                foreach (CharacterAttrib objAttribute in await objAttributeSection.GetAllAttributesAsync(token).ConfigureAwait(false))
                {
                    token.ThrowIfCancellationRequested();
                    if (objAttribute.Abbrev == strAttribute)
                        lstReturn.Add(objAttribute);
                }

                return lstReturn;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Get all of a Character's CharacterAttributes.
        /// </summary>
        /// <param name="token">Cancellation token to listen to.</param>
        public IEnumerable<CharacterAttrib> GetAllAttributesForModification(CancellationToken token = default)
        {
            using (LockObject.EnterUpgradeableReadLock(token))
            {
                foreach (CharacterAttrib objAttribute in AttributeSection.AllAttributes)
                {
                    token.ThrowIfCancellationRequested();
                    yield return objAttribute;
                }
            }
        }

        /// <summary>
        /// Get all of a Character's CharacterAttributes.
        /// </summary>
        /// <param name="token">Cancellation token to listen to.</param>
        public Task<List<CharacterAttrib>> GetAllAttributesForModificationAsync(CancellationToken token = default)
        {
            // Regular GetAllAttributesAsync already works for modifications because it closes the non-upgradeable read lock before returning its list
            return GetAllAttributesAsync(token);
        }

        /// <summary>
        /// Get all CharacterAttributes that have a particular abbreviation.
        /// </summary>
        /// <param name="strAttribute">CharacterAttribute name to retrieve.</param>
        /// <param name="blnExplicit">Whether to force looking for a specific attribute name.
        /// Mostly expected to be used for gutting Mystic Adept power points.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public IEnumerable<CharacterAttrib> GetAllForModificationAttributes(string strAttribute, bool blnExplicit = false, CancellationToken token = default)
        {
            using (AttributeSection.LockObject.EnterUpgradeableReadLock(token))
            {
                if (strAttribute == "MAGAdept" && (!IsMysticAdept || !Settings.MysAdeptSecondMAGAttribute)
                                               && !blnExplicit)
                    strAttribute = "MAG";
                foreach (CharacterAttrib objAttribute in AttributeSection.AllAttributes)
                {
                    token.ThrowIfCancellationRequested();
                    if (objAttribute.Abbrev == strAttribute)
                        yield return objAttribute;
                }
            }
        }

        /// <summary>
        /// Get all CharacterAttributes that have a particular abbreviation.
        /// </summary>
        /// <param name="strAttribute">CharacterAttribute name to retrieve.</param>
        /// <param name="blnExplicit">Whether to force looking for a specific attribute name.
        /// Mostly expected to be used for gutting Mystic Adept power points.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public Task<List<CharacterAttrib>> GetAllAttributesForModificationAsync(string strAttribute, bool blnExplicit = false, CancellationToken token = default)
        {
            // Regular GetAllAttributesAsync already works for modifications because it closes the non-upgradeable read lock before returning its list
            return GetAllAttributesAsync(strAttribute, blnExplicit, token);
        }

        /// <summary>
        /// Body (BOD) CharacterAttribute.
        /// </summary>
        public CharacterAttrib BOD
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return AttributeSection.GetAttributeByName("BOD");
            }
        }

        /// <summary>
        /// Agility (AGI) CharacterAttribute.
        /// </summary>
        public CharacterAttrib AGI
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return AttributeSection.GetAttributeByName("AGI");
            }
        }

        /// <summary>
        /// Reaction (REA) CharacterAttribute.
        /// </summary>
        public CharacterAttrib REA
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return AttributeSection.GetAttributeByName("REA");
            }
        }

        /// <summary>
        /// Strength (STR) CharacterAttribute.
        /// </summary>
        public CharacterAttrib STR
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return AttributeSection.GetAttributeByName("STR");
            }
        }

        /// <summary>
        /// Charisma (CHA) CharacterAttribute.
        /// </summary>
        public CharacterAttrib CHA
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return AttributeSection.GetAttributeByName("CHA");
            }
        }

        /// <summary>
        /// Intuition (INT) CharacterAttribute.
        /// </summary>
        public CharacterAttrib INT
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return AttributeSection.GetAttributeByName("INT");
            }
        }

        /// <summary>
        /// Logic (LOG) CharacterAttribute.
        /// </summary>
        public CharacterAttrib LOG
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return AttributeSection.GetAttributeByName("LOG");
            }
        }

        /// <summary>
        /// Willpower (WIL) CharacterAttribute.
        /// </summary>
        public CharacterAttrib WIL
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return AttributeSection.GetAttributeByName("WIL");
            }
        }

        /// <summary>
        /// Edge (EDG) CharacterAttribute.
        /// </summary>
        public CharacterAttrib EDG
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return AttributeSection.GetAttributeByName("EDG");
            }
        }

        /// <summary>
        /// Magic (MAG) CharacterAttribute.
        /// </summary>
        public CharacterAttrib MAG
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return AttributeSection.GetAttributeByName("MAG");
            }
        }

        /// <summary>
        /// Reflection of MAG (hide it, if it is not enabled!)
        /// </summary>
        [HubTag("Magic")]
        public CharacterAttrib ReflectionMAG
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return MAGEnabled ? MAG : null;
            }
        }

        /// <summary>
        /// Magic (MAG) CharacterAttribute for Adept powers of Mystic Adepts when the appropriate house rule is enabled.
        /// </summary>
        public CharacterAttrib MAGAdept
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (Settings.MysAdeptSecondMAGAttribute && IsMysticAdept)
                        return AttributeSection.GetAttributeByName("MAGAdept");
                    return MAG;
                }
            }
        }

        /// <summary>
        /// Reflection of MAGAdept (hide it, if it is not enabled!)
        /// </summary>
        [HubTag("MagicAdept")]
        public CharacterAttrib ReflectionMAGAdept
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return MAGEnabled ? MAGAdept : null;
            }
        }

        /// <summary>
        /// Resonance (RES) CharacterAttribute.
        /// </summary>
        public CharacterAttrib RES
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return AttributeSection.GetAttributeByName("RES");
            }
        }

        /// <summary>
        /// Reflection of RES (hide it, if it is not enabled!)
        /// </summary>
        [HubTag("Resonance")]
        public CharacterAttrib ReflectionRES
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return RESEnabled ? RES : null;
            }
        }

        /// <summary>
        /// Depth (DEP) Attribute.
        /// </summary>
        public CharacterAttrib DEP
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return AttributeSection.GetAttributeByName("DEP");
            }
        }

        /// <summary>
        /// Reflection of DEP (hide it, if it is not enabled!)
        /// </summary>
        [HubTag("Depth")]
        public CharacterAttrib ReflectionDEP
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return DEPEnabled ? DEP : null;
            }
        }

        /// <summary>
        /// Essence (ESS) Attribute.
        /// </summary>
        public CharacterAttrib ESS => AttributeSection.GetAttributeByName("ESS");

        /// <summary>
        /// Is the MAG CharacterAttribute enabled?
        /// </summary>
        [HubTag]
        public bool MAGEnabled
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _blnMAGEnabled;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (_blnMAGEnabled == value)
                        return;
                    if (IsLoading)
                    {
                        using (LockObject.EnterWriteLock())
                        {
                            _blnMAGEnabled = value;
                            OnPropertyChanged();
                        }

                        return;
                    }
                    using (LockObject.EnterWriteLock())
                    {
                        _blnMAGEnabled = value;
                        if (value)
                        {
                            // Career mode, so no extra calculations need to be done for EssenceAtSpecialStart
                            if (Created)
                            {
                                ResetCachedEssence();
                                EssenceAtSpecialStart = Essence(true, "MAG");
                            }
                            // EssenceAtSpecialStart needs to be calculated by assuming that the character took the MAG-enabling quality with the highest essence penalty first, as that would be the most optimal
                            else
                            {
                                // If this character has any MAG-enabling bonuses that could be granted before all others (because they're priority and/or metatype-given),
                                // it has to be assumed those are taken first.
                                List<Improvement> lstAttributeImprovements = ImprovementManager
                                    .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Attribute,
                                                                        "MAG");
                                bool blnCountOnlyPriorityOrMetatypeGivenBonuses = lstAttributeImprovements.Exists(
                                    x => x.ImproveSource
                                         == Improvement.ImprovementSource
                                                       .Metatype
                                         || x.ImproveSource
                                         == Improvement.ImprovementSource
                                                       .Metavariant
                                         || x.ImproveSource
                                         == Improvement.ImprovementSource
                                                       .Heritage);
                                if (!blnCountOnlyPriorityOrMetatypeGivenBonuses)
                                {
                                    List<string> lstMAGEnablingQualityIds = lstAttributeImprovements
                                                                            .Where(x => x.ImproveSource
                                                                                == Improvement.ImprovementSource
                                                                                    .Quality).Select(
                                                                                x => x.SourceName).ToList();
                                    // Can't use foreach because new items can get added to this list while it is looping
                                    for (int i = 0; i < lstMAGEnablingQualityIds.Count; ++i)
                                    {
                                        Quality objQuality
                                            = Qualities.FirstOrDefault(
                                                x => x.InternalId == lstMAGEnablingQualityIds[i]);
                                        if (objQuality != null)
                                        {
                                            if (objQuality.OriginSource == QualitySource.Metatype
                                                || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                                || objQuality.OriginSource == QualitySource.BuiltIn
                                                || objQuality.OriginSource == QualitySource.LifeModule
                                                || objQuality.OriginSource == QualitySource.Heritage
                                                || objQuality.OriginSource == QualitySource.QualityLevelImprovement)
                                            {
                                                blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                                break;
                                            }

                                            if (objQuality.OriginSource == QualitySource.Improvement)
                                            {
                                                List<Improvement> lstSpecificQualityImprovements = ImprovementManager
                                                    .GetCachedImprovementListForValueOf(
                                                        this, Improvement.ImprovementType.SpecificQuality,
                                                        objQuality.InternalId);
                                                if (lstSpecificQualityImprovements.Exists(x =>
                                                        x.ImproveSource == Improvement.ImprovementSource.Metatype
                                                        || x.ImproveSource == Improvement.ImprovementSource
                                                            .Metavariant
                                                        || x.ImproveSource
                                                        == Improvement.ImprovementSource.Heritage))
                                                {
                                                    blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                                    break;
                                                }

                                                // Qualities that add other qualities get added to the list to be checked, too
                                                lstMAGEnablingQualityIds.AddRange(
                                                    lstSpecificQualityImprovements
                                                        .Where(
                                                            x => x.ImproveSource
                                                                 == Improvement.ImprovementSource.Quality)
                                                        .Select(x => x.SourceName));
                                            }
                                        }
                                    }
                                }

                                Dictionary<string, decimal> dicImprovementEssencePenalties =
                                    new Dictionary<string, decimal>(Improvements.Count);
                                foreach (Improvement objImprovement in Improvements)
                                {
                                    if (!objImprovement.Enabled)
                                        continue;
                                    bool blnCountImprovement = !blnCountOnlyPriorityOrMetatypeGivenBonuses
                                                               || objImprovement.ImproveSource
                                                               == Improvement.ImprovementSource.Metatype
                                                               || objImprovement.ImproveSource
                                                               == Improvement.ImprovementSource.Metavariant
                                                               || objImprovement.ImproveSource
                                                               == Improvement.ImprovementSource.Heritage;
                                    if (!blnCountImprovement && objImprovement.ImproveSource
                                        == Improvement.ImprovementSource.Quality)
                                    {
                                        Quality objQuality
                                            = Qualities.FirstOrDefault(x => x.InternalId == objImprovement.SourceName);
                                        while (objQuality != null)
                                        {
                                            if (objQuality.OriginSource == QualitySource.Metatype
                                                || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                                || objQuality.OriginSource == QualitySource.BuiltIn
                                                || objQuality.OriginSource == QualitySource.LifeModule
                                                || objQuality.OriginSource == QualitySource.Heritage
                                                || objQuality.OriginSource == QualitySource.QualityLevelImprovement)
                                            {
                                                blnCountImprovement = true;
                                                break;
                                            }

                                            if (objQuality.OriginSource == QualitySource.Improvement)
                                            {
                                                Improvement objParentImprovement = ImprovementManager
                                                    .GetCachedImprovementListForValueOf(
                                                        this,
                                                        Improvement.ImprovementType
                                                                   .SpecificQuality,
                                                        objQuality.InternalId)
                                                    .FirstOrDefault();
                                                if (objParentImprovement == null)
                                                    break;
                                                if (objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Metatype
                                                    || objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Metavariant
                                                    || objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Heritage)
                                                {
                                                    blnCountImprovement = true;
                                                    break;
                                                }

                                                if (objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Quality)
                                                {
                                                    // Qualities that add other qualities get added to the list to be checked, too
                                                    objQuality = Qualities.FirstOrDefault(
                                                        x => x.InternalId == objParentImprovement.SourceName);
                                                }
                                                else
                                                    break;
                                            }
                                            else
                                                break;
                                        }
                                    }

                                    if (blnCountImprovement)
                                    {
                                        decimal decLoopEssencePenalty = 0;
                                        switch (objImprovement.ImproveType)
                                        {
                                            case Improvement.ImprovementType.EssencePenalty:
                                                decLoopEssencePenalty += objImprovement.Value;
                                                break;

                                            case Improvement.ImprovementType.EssencePenaltyT100:
                                            case Improvement.ImprovementType.EssencePenaltyMAGOnlyT100:
                                                decLoopEssencePenalty += objImprovement.Value / 100.0m;
                                                break;
                                        }

                                        if (decLoopEssencePenalty != 0)
                                        {
                                            if (dicImprovementEssencePenalties.TryGetValue(
                                                    objImprovement.SourceName, out decimal decExistingPenalty))
                                                dicImprovementEssencePenalties[objImprovement.SourceName]
                                                    = decExistingPenalty + decLoopEssencePenalty;
                                            else
                                                dicImprovementEssencePenalties.Add(objImprovement.SourceName,
                                                    decLoopEssencePenalty);
                                        }
                                    }
                                }

                                if (dicImprovementEssencePenalties.Count > 0)
                                    EssenceAtSpecialStart =
                                        ESS.MetatypeMaximum + dicImprovementEssencePenalties.Values.Min();
                                else
                                    EssenceAtSpecialStart = ESS.MetatypeMaximum;
                            }

                            XmlNode xmlTraditionListDataNode
                                = LoadData("traditions.xml").SelectSingleNode("/chummer/traditions");
                            if (xmlTraditionListDataNode != null)
                            {
                                XmlNodeList xmlTraditionDataNodes = xmlTraditionListDataNode.SelectNodes("tradition");
                                if (xmlTraditionDataNodes?.Count == 1)
                                {
                                    if (!MagicTradition.Create(xmlTraditionDataNodes[0]))
                                        MagicTradition.ResetTradition();
                                }
                                else
                                {
                                    MagicTradition.ResetTradition();
                                }
                            }
                            else
                            {
                                MagicTradition.ResetTradition();
                            }
                        }
                        else if (!RESEnabled)
                        {
                            ClearInitiations();
                            MagicTradition.ResetTradition();

                            if (!Created && !DEPEnabled)
                                EssenceAtSpecialStart = decimal.MinValue;
                        }
                        else
                        {
                            XmlNode xmlTraditionListDataNode
                                = LoadData("streams.xml").SelectSingleNode("/chummer/traditions");
                            if (xmlTraditionListDataNode != null)
                            {
                                XmlNodeList xmlTraditionDataNodes = xmlTraditionListDataNode.SelectNodes("tradition");
                                if (xmlTraditionDataNodes?.Count == 1)
                                {
                                    if (!MagicTradition.Create(xmlTraditionDataNodes[0], true))
                                        MagicTradition.ResetTradition();
                                }
                                else
                                {
                                    MagicTradition.ResetTradition();
                                }
                            }
                            else
                            {
                                MagicTradition.ResetTradition();
                            }
                        }
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Is the MAG CharacterAttribute enabled?
        /// </summary>
        public async Task<bool> GetMAGEnabledAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _blnMAGEnabled;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Is the MAG CharacterAttribute enabled?
        /// </summary>
        public async Task SetMAGEnabledAsync(bool value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_blnMAGEnabled == value)
                    return;
                if (IsLoading)
                {
                    IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        _blnMAGEnabled = value;
                    }
                    finally
                    {
                        await objLocker2.DisposeAsync().ConfigureAwait(false);
                    }

                    await OnPropertyChangedAsync(nameof(MAGEnabled), token).ConfigureAwait(false);
                    return;
                }

                IAsyncDisposable objLocker3 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    _blnMAGEnabled = value;
                    if (value)
                    {
                        // Career mode, so no extra calculations need to be done for EssenceAtSpecialStart
                        if (await GetCreatedAsync(token).ConfigureAwait(false))
                        {
                            await ResetCachedEssenceAsync(token).ConfigureAwait(false);
                            await SetEssenceAtSpecialStartAsync(
                                    await EssenceAsync(true, "MAG", token).ConfigureAwait(false), token)
                                .ConfigureAwait(false);
                        }
                        // EssenceAtSpecialStart needs to be calculated by assuming that the character took the MAG-enabling quality with the highest essence penalty first, as that would be the most optimal
                        else
                        {
                            // If this character has any MAG-enabling bonuses that could be granted before all others (because they're priority and/or metatype-given),
                            // it has to be assumed those are taken first.
                            List<Improvement> lstAttributeImprovements = await ImprovementManager
                                .GetCachedImprovementListForValueOfAsync(
                                    this,
                                    Improvement.ImprovementType
                                        .Attribute,
                                    "MAG", token: token)
                                .ConfigureAwait(false);
                            bool blnCountOnlyPriorityOrMetatypeGivenBonuses = lstAttributeImprovements.Exists(
                                x => x.ImproveSource
                                     == Improvement.ImprovementSource
                                         .Metatype
                                     || x.ImproveSource
                                     == Improvement.ImprovementSource
                                         .Metavariant
                                     || x.ImproveSource
                                     == Improvement.ImprovementSource
                                         .Heritage);
                            if (!blnCountOnlyPriorityOrMetatypeGivenBonuses)
                            {
                                List<string> lstMAGEnablingQualityIds = lstAttributeImprovements
                                    .Where(x => x.ImproveSource
                                                == Improvement.ImprovementSource
                                                    .Quality).Select(
                                        x => x.SourceName).ToList();
                                // Can't use foreach because new items can get added to this list while it is looping
                                for (int i = 0; i < lstMAGEnablingQualityIds.Count; ++i)
                                {
                                    int i1 = i;
                                    Quality objQuality
                                        = await Qualities.FirstOrDefaultAsync(
                                                x => x.InternalId == lstMAGEnablingQualityIds[i1],
                                                token: token)
                                            .ConfigureAwait(false);
                                    if (objQuality != null)
                                    {
                                        if (objQuality.OriginSource == QualitySource.Metatype
                                            || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                            || objQuality.OriginSource == QualitySource.BuiltIn
                                            || objQuality.OriginSource == QualitySource.LifeModule
                                            || objQuality.OriginSource == QualitySource.Heritage
                                            || objQuality.OriginSource == QualitySource.QualityLevelImprovement)
                                        {
                                            blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                            break;
                                        }

                                        if (objQuality.OriginSource == QualitySource.Improvement)
                                        {
                                            List<Improvement> lstSpecificQualityImprovements = await ImprovementManager
                                                .GetCachedImprovementListForValueOfAsync(
                                                    this, Improvement.ImprovementType.SpecificQuality,
                                                    objQuality.InternalId, token: token).ConfigureAwait(false);
                                            if (lstSpecificQualityImprovements.Exists(x =>
                                                    x.ImproveSource == Improvement.ImprovementSource.Metatype
                                                    || x.ImproveSource == Improvement.ImprovementSource
                                                        .Metavariant
                                                    || x.ImproveSource
                                                    == Improvement.ImprovementSource.Heritage))
                                            {
                                                blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                                break;
                                            }

                                            // Qualities that add other qualities get added to the list to be checked, too
                                            lstMAGEnablingQualityIds.AddRange(
                                                lstSpecificQualityImprovements
                                                    .Where(
                                                        x => x.ImproveSource
                                                             == Improvement.ImprovementSource.Quality)
                                                    .Select(x => x.SourceName));
                                        }
                                    }
                                }
                            }

                            Dictionary<string, decimal> dicImprovementEssencePenalties =
                                new Dictionary<string, decimal>(
                                    await Improvements.GetCountAsync(token).ConfigureAwait(false));
                            await Improvements.ForEachAsync(async objImprovement =>
                            {
                                if (!objImprovement.Enabled)
                                    return;
                                bool blnCountImprovement = !blnCountOnlyPriorityOrMetatypeGivenBonuses
                                                           || objImprovement.ImproveSource
                                                           == Improvement.ImprovementSource.Metatype
                                                           || objImprovement.ImproveSource
                                                           == Improvement.ImprovementSource.Metavariant
                                                           || objImprovement.ImproveSource
                                                           == Improvement.ImprovementSource.Heritage;
                                if (!blnCountImprovement && objImprovement.ImproveSource
                                    == Improvement.ImprovementSource.Quality)
                                {
                                    Quality objQuality
                                        = await Qualities.FirstOrDefaultAsync(
                                                x => x.InternalId == objImprovement.SourceName,
                                                token: token)
                                            .ConfigureAwait(false);
                                    while (objQuality != null)
                                    {
                                        if (objQuality.OriginSource == QualitySource.Metatype
                                            || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                            || objQuality.OriginSource == QualitySource.BuiltIn
                                            || objQuality.OriginSource == QualitySource.LifeModule
                                            || objQuality.OriginSource == QualitySource.Heritage
                                            || objQuality.OriginSource == QualitySource.QualityLevelImprovement)
                                        {
                                            blnCountImprovement = true;
                                            break;
                                        }

                                        if (objQuality.OriginSource == QualitySource.Improvement)
                                        {
                                            Improvement objParentImprovement = (await ImprovementManager
                                                    .GetCachedImprovementListForValueOfAsync(
                                                        this,
                                                        Improvement.ImprovementType
                                                            .SpecificQuality,
                                                        objQuality.InternalId, token: token).ConfigureAwait(false))
                                                .FirstOrDefault();
                                            if (objParentImprovement == null)
                                                break;
                                            if (objParentImprovement.ImproveSource
                                                == Improvement.ImprovementSource.Metatype
                                                || objParentImprovement.ImproveSource
                                                == Improvement.ImprovementSource.Metavariant
                                                || objParentImprovement.ImproveSource
                                                == Improvement.ImprovementSource.Heritage)
                                            {
                                                blnCountImprovement = true;
                                                break;
                                            }

                                            if (objParentImprovement.ImproveSource
                                                == Improvement.ImprovementSource.Quality)
                                            {
                                                // Qualities that add other qualities get added to the list to be checked, too
                                                objQuality = await Qualities.FirstOrDefaultAsync(
                                                        x => x.InternalId
                                                             == objParentImprovement.SourceName,
                                                        token: token)
                                                    .ConfigureAwait(false);
                                            }
                                            else
                                                break;
                                        }
                                        else
                                            break;
                                    }
                                }

                                if (blnCountImprovement)
                                {
                                    decimal decLoopEssencePenalty = 0;
                                    switch (objImprovement.ImproveType)
                                    {
                                        case Improvement.ImprovementType.EssencePenalty:
                                            decLoopEssencePenalty += objImprovement.Value;
                                            break;

                                        case Improvement.ImprovementType.EssencePenaltyT100:
                                        case Improvement.ImprovementType.EssencePenaltyMAGOnlyT100:
                                            decLoopEssencePenalty += objImprovement.Value / 100.0m;
                                            break;
                                    }

                                    if (decLoopEssencePenalty != 0)
                                    {
                                        if (dicImprovementEssencePenalties.TryGetValue(
                                                objImprovement.SourceName, out decimal decExistingPenalty))
                                            dicImprovementEssencePenalties[objImprovement.SourceName]
                                                = decExistingPenalty + decLoopEssencePenalty;
                                        else
                                            dicImprovementEssencePenalties.Add(objImprovement.SourceName,
                                                decLoopEssencePenalty);
                                    }
                                }
                            }, token).ConfigureAwait(false);

                            if (dicImprovementEssencePenalties.Count > 0)
                                await SetEssenceAtSpecialStartAsync(
                                    await ESS.GetMetatypeMaximumAsync(token).ConfigureAwait(false)
                                    + dicImprovementEssencePenalties.Values.Min(), token).ConfigureAwait(false);
                            else
                                await SetEssenceAtSpecialStartAsync(
                                        await ESS.GetMetatypeMaximumAsync(token).ConfigureAwait(false), token)
                                    .ConfigureAwait(false);
                        }

                        XmlNode xmlTraditionListDataNode
                            = (await LoadDataAsync("traditions.xml", token: token).ConfigureAwait(false)).SelectSingleNode("/chummer/traditions");
                        if (xmlTraditionListDataNode != null)
                        {
                            XmlNodeList xmlTraditionDataNodes = xmlTraditionListDataNode.SelectNodes("tradition");
                            if (xmlTraditionDataNodes?.Count == 1)
                            {
                                if (!await MagicTradition.CreateAsync(xmlTraditionDataNodes[0], token: token).ConfigureAwait(false))
                                    await MagicTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                            }
                            else
                            {
                                await MagicTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                            }
                        }
                        else
                        {
                            await MagicTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                        }
                    }
                    else if (!await GetRESEnabledAsync(token).ConfigureAwait(false))
                    {
                        await ClearInitiationsAsync(token).ConfigureAwait(false);
                        await MagicTradition.ResetTraditionAsync(token).ConfigureAwait(false);

                        if (!await GetCreatedAsync(token).ConfigureAwait(false)
                            && !await GetDEPEnabledAsync(token).ConfigureAwait(false))
                            await SetEssenceAtSpecialStartAsync(decimal.MinValue, token).ConfigureAwait(false);
                    }
                    else
                    {
                        XmlNode xmlTraditionListDataNode
                            = (await LoadDataAsync("streams.xml", token: token).ConfigureAwait(false)).SelectSingleNode("/chummer/traditions");
                        if (xmlTraditionListDataNode != null)
                        {
                            XmlNodeList xmlTraditionDataNodes = xmlTraditionListDataNode.SelectNodes("tradition");
                            if (xmlTraditionDataNodes?.Count == 1)
                            {
                                if (!await MagicTradition.CreateAsync(xmlTraditionDataNodes[0], true, token: token).ConfigureAwait(false))
                                    await MagicTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                            }
                            else
                            {
                                await MagicTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                            }
                        }
                        else
                        {
                            await MagicTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                        }
                    }
                }
                finally
                {
                    await objLocker3.DisposeAsync().ConfigureAwait(false);
                }

                await OnPropertyChangedAsync(nameof(MAGEnabled), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Maximum force of spirits summonable/bindable by the character. Limited to MAG at creation.
        /// </summary>
        public int MaxSpiritForce
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (!MAGEnabled)
                        return 0;
                    int intReturn = Settings.SpiritForceBasedOnTotalMAG ? MAG.TotalValue : MAG.Value;
                    if (intReturn <= 0)
                        return 0;
                    if (Created)
                        intReturn *= 2;
                    return intReturn;
                }
            }
        }

        /// <summary>
        /// Maximum force of spirits summonable/bindable by the character. Limited to MAG at creation.
        /// </summary>
        public async Task<int> GetMaxSpiritForceAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (!await GetMAGEnabledAsync(token).ConfigureAwait(false))
                    return 0;
                CharacterAttrib objMag = await GetAttributeAsync("MAG", token: token).ConfigureAwait(false);
                int intReturn = await (await GetSettingsAsync(token).ConfigureAwait(false))
                    .GetSpiritForceBasedOnTotalMAGAsync(token).ConfigureAwait(false)
                    ? await objMag.GetTotalValueAsync(token).ConfigureAwait(false)
                    : await objMag.GetValueAsync(token).ConfigureAwait(false);
                if (intReturn <= 0)
                    return 0;
                if (await GetCreatedAsync(token).ConfigureAwait(false))
                    intReturn *= 2;
                return intReturn;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public int BoundSpiritLimit
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (_intBoundSpiritLimit == int.MinValue)
                    {
                        string strExpression = Settings.BoundSpiritExpression;
                        if (strExpression.DoesNeedXPathProcessingToBeConvertedToNumber(out decimal decValue))
                        {
                            strExpression = ProcessAttributesInXPath(strExpression);
                            (bool blnIsSuccess, object objProcess)
                                    = CommonFunctions.EvaluateInvariantXPath(
                                        strExpression);
                            _intBoundSpiritLimit = blnIsSuccess ? ((double)objProcess).StandardRound() : 0;
                        }
                        else
                            _intBoundSpiritLimit = decValue.StandardRound();
                    }

                    return _intBoundSpiritLimit;
                }
            }
        }

        public async Task<int> GetBoundSpiritLimitAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_intBoundSpiritLimit == int.MinValue)
                {
                    string strExpression = await (await GetSettingsAsync(token).ConfigureAwait(false)).GetBoundSpiritExpressionAsync(token).ConfigureAwait(false);
                    if (strExpression.DoesNeedXPathProcessingToBeConvertedToNumber(out decimal decValue))
                    {
                        strExpression = await ProcessAttributesInXPathAsync(strExpression, token: token).ConfigureAwait(false);
                        (bool blnIsSuccess, object objProcess)
                                = await CommonFunctions.EvaluateInvariantXPathAsync(
                                    strExpression, token).ConfigureAwait(false);
                        _intBoundSpiritLimit = blnIsSuccess ? ((double)objProcess).StandardRound() : 0;
                    }
                    else
                        _intBoundSpiritLimit = decValue.StandardRound();
                }

                return _intBoundSpiritLimit;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Maximum level of sprites compilable/registrable by the character. Limited to RES at creation.
        /// </summary>
        public int MaxSpriteLevel
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (!RESEnabled)
                        return 0;
                    int intReturn = RES.TotalValue;
                    if (intReturn <= 0)
                        return 0;
                    if (Created)
                        intReturn *= 2;
                    return intReturn;
                }
            }
        }

        /// <summary>
        /// Maximum level of sprites compilable/registrable by the character. Limited to RES at creation.
        /// </summary>
        public async Task<int> GetMaxSpriteLevelAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (!await GetRESEnabledAsync(token).ConfigureAwait(false))
                    return 0;
                CharacterAttrib objRes = await GetAttributeAsync("RES", token: token).ConfigureAwait(false);
                int intReturn = await objRes.GetTotalValueAsync(token).ConfigureAwait(false);
                if (intReturn <= 0)
                    return 0;
                if (await GetCreatedAsync(token).ConfigureAwait(false))
                    intReturn *= 2;
                return intReturn;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public int RegisteredSpriteLimit
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (_intRegisteredSpriteLimit == int.MinValue)
                    {
                        string strExpression = Settings.RegisteredSpriteExpression;
                        if (strExpression.DoesNeedXPathProcessingToBeConvertedToNumber(out decimal decValue))
                        {
                            strExpression = ProcessAttributesInXPath(strExpression);
                            (bool blnIsSuccess, object objProcess)
                                    = CommonFunctions.EvaluateInvariantXPath(strExpression);
                            _intRegisteredSpriteLimit = blnIsSuccess ? ((double)objProcess).StandardRound() : 0;
                        }
                        else
                            _intRegisteredSpriteLimit = decValue.StandardRound();
                    }

                    return _intRegisteredSpriteLimit;
                }
            }
        }

        public async Task<int> GetRegisteredSpriteLimitAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_intRegisteredSpriteLimit == int.MinValue)
                {
                    string strExpression = await (await GetSettingsAsync(token).ConfigureAwait(false)).GetRegisteredSpriteExpressionAsync(token).ConfigureAwait(false);
                    if (strExpression.DoesNeedXPathProcessingToBeConvertedToNumber(out decimal decValue))
                    {
                        strExpression = await ProcessAttributesInXPathAsync(strExpression, token: token).ConfigureAwait(false);
                        (bool blnIsSuccess, object objProcess)
                                = await CommonFunctions.EvaluateInvariantXPathAsync(
                                    strExpression, token).ConfigureAwait(false);
                        _intRegisteredSpriteLimit = blnIsSuccess ? ((double)objProcess).StandardRound() : 0;
                    }
                    else
                        _intRegisteredSpriteLimit = decValue.StandardRound();
                }

                return _intRegisteredSpriteLimit;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Amount of Power Points for Mystic Adepts.
        /// </summary>
        public int MysticAdeptPowerPoints
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _intMAGAdept;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    value = Math.Min(value, MAG.TotalValue);
                    if (Interlocked.Exchange(ref _intMAGAdept, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Amount of Power Points for Mystic Adepts.
        /// </summary>
        public async Task<int> GetMysticAdeptPowerPointsAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _intMAGAdept;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Amount of Power Points for Mystic Adepts.
        /// </summary>
        public async Task SetMysticAdeptPowerPointsAsync(int value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                value = Math.Min(value,
                    await (await GetAttributeAsync("MAG", token: token).ConfigureAwait(false)).GetTotalValueAsync(token)
                        .ConfigureAwait(false));
                if (Interlocked.Exchange(ref _intMAGAdept, value) == value)
                    return;
                await OnPropertyChangedAsync(nameof(MysticAdeptPowerPoints), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Amount of Power Points for Mystic Adepts.
        /// </summary>
        public async Task ModifyMysticAdeptPowerPointsAsync(int value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                value = Math.Min(value,
                    await (await GetAttributeAsync("MAG", token: token).ConfigureAwait(false)).GetTotalValueAsync(token)
                        .ConfigureAwait(false) - _intMAGAdept);
                if (value == 0)
                    return;
                IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    Interlocked.Add(ref _intMAGAdept, value);
                    await OnPropertyChangedAsync(nameof(MysticAdeptPowerPoints), token).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Total Amount of Power Points this character has.
        /// </summary>
        public decimal PowerPointsTotal
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    decimal decMAG = UseMysticAdeptPPs ? MysticAdeptPowerPoints : MAGAdept.TotalValue;

                    // Add any Power Point Improvements to MAG.
                    decMAG += ImprovementManager.ValueOf(this, Improvement.ImprovementType.AdeptPowerPoints);

                    return Math.Max(decMAG, 0);
                }
            }
        }

        /// <summary>
        /// Total Amount of Power Points this character has.
        /// </summary>
        public async Task<decimal> GetPowerPointsTotalAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                decimal decMAG = await GetUseMysticAdeptPPsAsync(token).ConfigureAwait(false)
                    ? await GetMysticAdeptPowerPointsAsync(token).ConfigureAwait(false)
                    : await (await GetAttributeAsync("MAGAdept", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false);

                // Add any Power Point Improvements to MAG.
                decMAG += await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.AdeptPowerPoints, token: token).ConfigureAwait(false);

                return Math.Max(decMAG, 0);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private decimal _decCachedPowerPointsUsed = decimal.MinValue;

        private readonly AsyncFriendlyReaderWriterLock _objCachedPowerPointsUsedLock;

        public decimal PowerPointsUsed
        {
            get
            {
                using (_objCachedPowerPointsUsedLock.EnterReadLock())
                {
                    if (_decCachedPowerPointsUsed != decimal.MinValue)
                        return _decCachedPowerPointsUsed;
                }

                using (_objCachedPowerPointsUsedLock.EnterUpgradeableReadLock())
                {
                    if (_decCachedPowerPointsUsed != decimal.MinValue)
                        return _decCachedPowerPointsUsed;
                    using (_objCachedPowerPointsUsedLock.EnterWriteLock())
                    {
                        return _decCachedPowerPointsUsed = Powers.Sum(objPower => objPower.PowerPoints);
                    }
                }
            }
        }

        public async Task<decimal> GetPowerPointsUsedAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await _objCachedPowerPointsUsedLock.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_decCachedPowerPointsUsed != decimal.MinValue)
                    return _decCachedPowerPointsUsed;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }

            objLocker = await _objCachedPowerPointsUsedLock.EnterUpgradeableReadLockAsync(token)
                .ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_decCachedPowerPointsUsed != decimal.MinValue)
                    return _decCachedPowerPointsUsed;
                IAsyncDisposable objLocker2 =
                    await _objCachedSourceDetailLock.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    return _decCachedPowerPointsUsed = await (await GetPowersAsync(token).ConfigureAwait(false))
                        .SumAsync(
                            objPower => objPower.GetPowerPointsAsync(token),
                            token).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplayPowerPointsRemaining
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (LockObject.EnterReadLock())
                    return PowerPointsTotal.ToString(GlobalSettings.CultureInfo) + strSpace + "(" +
                           (PowerPointsTotal - PowerPointsUsed).ToString(GlobalSettings.CultureInfo) + strSpace +
                           LanguageManager.GetString("String_Remaining") + ")";
            }
        }

        public async Task<string> GetDisplayPowerPointsRemainingAsync(CancellationToken token = default)
        {
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                decimal decTotal = await GetPowerPointsTotalAsync(token).ConfigureAwait(false);
                return decTotal.ToString(GlobalSettings.CultureInfo) + strSpace + "(" +
                       (decTotal - await GetPowerPointsUsedAsync(token).ConfigureAwait(false)).ToString(
                           GlobalSettings.CultureInfo) + strSpace +
                       await LanguageManager.GetStringAsync("String_Remaining", token: token).ConfigureAwait(false)
                       + ")";
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public bool AnyPowerAdeptWayDiscountEnabled => Powers.Any(objPower => objPower.AdeptWayDiscountEnabled);

        public async Task<bool> GetAnyPowerAdeptWayDiscountEnabledAsync(CancellationToken token = default)
        {
            return await (await GetPowersAsync(token).ConfigureAwait(false))
                .AnyAsync(x => x.GetAdeptWayDiscountEnabledAsync(token), token: token).ConfigureAwait(false);
        }

        /// <summary>
        /// Magician's Tradition.
        /// </summary>
        [HubTag("Tradition", "", "MagicTradition", false)]
        public Tradition MagicTradition
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _objTradition;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (_objTradition == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        if (Interlocked.Exchange(ref _objTradition, value) != value)
                            OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Magician's Tradition.
        /// </summary>
        public async Task<Tradition> GetMagicTraditionAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _objTradition;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Initiate Grade.
        /// </summary>
        [HubTag]
        public int InitiateGrade
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _intInitiateGrade;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (_intInitiateGrade == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        int intOldValue = Interlocked.Exchange(ref _intInitiateGrade, value);
                        if (intOldValue == value)
                            return;
                        // Remove any existing Initiation Improvements.
                        if (value == 0)
                        {
                            ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Initiation);
                            // Update any Metamagic Improvements the character might have.
                            foreach (Metamagic objMetamagic in Metamagics.Where(
                                         x => x.SourceType == Improvement.ImprovementSource.Metamagic
                                              && x.Bonus?.InnerXmlContentContains("Rating") == true))
                            {
                                ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Metamagic,
                                                                      objMetamagic.InternalId);
                            }
                        }
                        else if (intOldValue == 0)
                        {
                            try
                            {
                                // Create the new Improvement.
                                ImprovementManager.CreateImprovement(this, "MAG",
                                                                     Improvement.ImprovementSource.Initiation,
                                                                     string.Empty,
                                                                     Improvement.ImprovementType.Attribute,
                                                                     string.Empty, 0, value, 0, 1);
                                ImprovementManager.CreateImprovement(this, "MAGAdept",
                                                                     Improvement.ImprovementSource.Initiation,
                                                                     string.Empty,
                                                                     Improvement.ImprovementType.Attribute,
                                                                     string.Empty, 0, value, 0, 1);
                                // Update any Metamagic Improvements the character might have.
                                foreach (Metamagic objMetamagic in Metamagics.Where(
                                             x => x.SourceType == Improvement.ImprovementSource.Metamagic
                                                  && x.Bonus?.InnerXmlContentContains("Rating") == true))
                                {
                                    ImprovementManager.CreateImprovements(this, Improvement.ImprovementSource.Metamagic,
                                                                          objMetamagic.InternalId, objMetamagic.Bonus,
                                                                          value,
                                                                          objMetamagic.CurrentDisplayNameShort);
                                }
                            }
                            catch
                            {
                                ImprovementManager.Rollback(this, CancellationToken.None);
                                throw;
                            }

                            ImprovementManager.Commit(this);
                        }
                        else
                        {
                            bool blnFoundImprovement = false;
                            // ReSharper disable once ForCanBeConvertedToForeach
                            for (int i = 0; i < Improvements.Count; ++i)
                            {
                                Improvement objImprovement = Improvements[i];
                                if (objImprovement.ImproveSource == Improvement.ImprovementSource.Initiation)
                                {
                                    blnFoundImprovement = true;
                                    objImprovement.Rating = value;
                                }
                            }
                            if (!blnFoundImprovement)
                            {
                                // Create the new Improvement.
                                try
                                {
                                    ImprovementManager.CreateImprovement(this, "MAG",
                                                                         Improvement.ImprovementSource.Initiation,
                                                                         string.Empty,
                                                                         Improvement.ImprovementType.Attribute,
                                                                         string.Empty, 0, value, 0, 1);
                                    ImprovementManager.CreateImprovement(this, "MAGAdept",
                                                                         Improvement.ImprovementSource.Initiation,
                                                                         string.Empty,
                                                                         Improvement.ImprovementType.Attribute,
                                                                         string.Empty, 0, value, 0, 1);
                                }
                                catch
                                {
                                    ImprovementManager.Rollback(this, CancellationToken.None);
                                    throw;
                                }

                                ImprovementManager.Commit(this);
                            }

                            // Update any Metamagic Improvements the character might have.
                            foreach (Metamagic objMetamagic in Metamagics.Where(
                                         x => x.SourceType == Improvement.ImprovementSource.Metamagic
                                              && x.Bonus?.InnerXmlContentContains("Rating") == true))
                            {
                                blnFoundImprovement = false;
                                string strMetamagicId = objMetamagic.InternalId;
                                // ReSharper disable once ForCanBeConvertedToForeach
                                for (int i = 0; i < Improvements.Count; ++i)
                                {
                                    Improvement objImprovement = Improvements[i];
                                    if (objImprovement.SourceName == strMetamagicId &&
                                        objImprovement.ImproveSource == Improvement.ImprovementSource.Metamagic)
                                    {
                                        blnFoundImprovement = true;
                                        objImprovement.Rating = value;
                                    }
                                }
                                // If the Bonus contains "Rating", refresh ratings of existing Improvements.
                                if (!blnFoundImprovement)
                                {
                                    try
                                    {
                                        ImprovementManager.CreateImprovements(
                                            this, Improvement.ImprovementSource.Metamagic,
                                            strMetamagicId, objMetamagic.Bonus, value,
                                            objMetamagic.CurrentDisplayNameShort);
                                    }
                                    catch
                                    {
                                        ImprovementManager.Rollback(this, CancellationToken.None);
                                        throw;
                                    }

                                    ImprovementManager.Commit(this);
                                }
                            }
                        }
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Initiate Grade.
        /// </summary>
        public async Task<int> GetInitiateGradeAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _intInitiateGrade;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Initiate Grade.
        /// </summary>
        public async Task SetInitiateGradeAsync(int value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_intInitiateGrade == value)
                    return;
                IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    int intOldValue = Interlocked.Exchange(ref _intInitiateGrade, value);
                    if (intOldValue == value)
                        return;
                    // Remove any existing Initiation Improvements.
                    if (value == 0)
                    {
                        await ImprovementManager
                            .RemoveImprovementsAsync(this, Improvement.ImprovementSource.Initiation, token: token)
                            .ConfigureAwait(false);
                        // Update any Metamagic Improvements the character might have.
                        await Metamagics.ForEachAsync(async objMetamagic =>
                        {
                            if (objMetamagic.SourceType == Improvement.ImprovementSource.Metamagic
                                && objMetamagic.Bonus?.InnerXmlContentContains("Rating", token) == true)
                            {
                                await ImprovementManager.RemoveImprovementsAsync(
                                    this, Improvement.ImprovementSource.Metamagic,
                                    objMetamagic.InternalId, token).ConfigureAwait(false);
                            }
                        }, token).ConfigureAwait(false);
                    }
                    else if (intOldValue == 0)
                    {
                        try
                        {
                            token.ThrowIfCancellationRequested();
                            // Create the new Improvement.
                            await ImprovementManager.CreateImprovementAsync(
                                this, "MAG", Improvement.ImprovementSource.Initiation,
                                string.Empty, Improvement.ImprovementType.Attribute,
                                string.Empty, 0, value, 0, 1, token: token).ConfigureAwait(false);
                            await ImprovementManager.CreateImprovementAsync(this, "MAGAdept",
                                    Improvement.ImprovementSource.Initiation,
                                    string.Empty,
                                    Improvement.ImprovementType.Attribute,
                                    string.Empty, 0, value, 0, 1, token: token)
                                .ConfigureAwait(false);
                            // Update any Metamagic Improvements the character might have.
                            await Metamagics.ForEachAsync(async objMetamagic =>
                            {
                                if (objMetamagic.SourceType == Improvement.ImprovementSource.Metamagic
                                    && objMetamagic.Bonus?.InnerXmlContentContains("Rating", token) == true)
                                {
                                    await ImprovementManager.CreateImprovementsAsync(
                                        this, Improvement.ImprovementSource.Metamagic, objMetamagic.InternalId,
                                        objMetamagic.Bonus, value,
                                        await objMetamagic.GetCurrentDisplayNameShortAsync(token).ConfigureAwait(false),
                                        token: token).ConfigureAwait(false);
                                }
                            }, token).ConfigureAwait(false);
                        }
                        catch
                        {
                            await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }

                        await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);
                    }
                    else
                    {
                        bool blnFoundImprovement = false;
                        // ReSharper disable once ForCanBeConvertedToForeach
                        for (int i = 0; i < await Improvements.GetCountAsync(token).ConfigureAwait(false); ++i)
                        {
                            Improvement objImprovement
                                = await Improvements.GetValueAtAsync(i, token).ConfigureAwait(false);
                            if (objImprovement.ImproveSource == Improvement.ImprovementSource.Initiation)
                            {
                                blnFoundImprovement = true;
                                await objImprovement.SetRatingAsync(value, token).ConfigureAwait(false);
                            }
                        }

                        if (!blnFoundImprovement)
                        {
                            // Create the new Improvement.
                            try
                            {
                                token.ThrowIfCancellationRequested();
                                await ImprovementManager.CreateImprovementAsync(this, "MAG",
                                        Improvement.ImprovementSource.Initiation,
                                        string.Empty,
                                        Improvement.ImprovementType.Attribute,
                                        string.Empty, 0, value, 0, 1, token: token)
                                    .ConfigureAwait(false);
                                await ImprovementManager.CreateImprovementAsync(this, "MAGAdept",
                                        Improvement.ImprovementSource.Initiation,
                                        string.Empty,
                                        Improvement.ImprovementType.Attribute,
                                        string.Empty, 0, value, 0, 1, token: token)
                                    .ConfigureAwait(false);
                            }
                            catch
                            {
                                await ImprovementManager.RollbackAsync(this, CancellationToken.None)
                                    .ConfigureAwait(false);
                                throw;
                            }

                            await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);
                        }

                        // Update any Metamagic Improvements the character might have.
                        await Metamagics.ForEachAsync(async objMetamagic =>
                        {
                            if (objMetamagic.SourceType == Improvement.ImprovementSource.Metamagic
                                && objMetamagic.Bonus?.InnerXmlContentContains("Rating", token) == true)
                            {
                                blnFoundImprovement = false;
                                string strMetamagicId = objMetamagic.InternalId;
                                // ReSharper disable once ForCanBeConvertedToForeach
                                for (int i = 0;
                                     i < await Improvements.GetCountAsync(token).ConfigureAwait(false);
                                     ++i)
                                {
                                    Improvement objImprovement = await Improvements.GetValueAtAsync(i, token)
                                        .ConfigureAwait(false);
                                    if (objImprovement.SourceName == strMetamagicId && objImprovement.ImproveSource
                                        == Improvement.ImprovementSource.Initiation)
                                    {
                                        blnFoundImprovement = true;
                                        await objImprovement.SetRatingAsync(value, token).ConfigureAwait(false);
                                    }
                                }

                                // If the Bonus contains "Rating", refresh ratings of existing Improvements.
                                if (!blnFoundImprovement)
                                {
                                    try
                                    {
                                        token.ThrowIfCancellationRequested();
                                        await ImprovementManager.CreateImprovementsAsync(
                                            this, Improvement.ImprovementSource.Metamagic, strMetamagicId,
                                            objMetamagic.Bonus, value,
                                            await objMetamagic.GetCurrentDisplayNameShortAsync(token)
                                                .ConfigureAwait(false),
                                            token: token).ConfigureAwait(false);
                                    }
                                    catch
                                    {
                                        await ImprovementManager.RollbackAsync(this, CancellationToken.None)
                                            .ConfigureAwait(false);
                                        throw;
                                    }

                                    await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);
                                }
                            }
                        }, token).ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }

                await OnPropertyChangedAsync(nameof(InitiateGrade), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Is the RES CharacterAttribute enabled?
        /// </summary>
        [HubTag]
        public bool RESEnabled
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _blnRESEnabled;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (_blnRESEnabled == value)
                        return;
                    if (IsLoading)
                    {
                        using (LockObject.EnterWriteLock())
                        {
                            _blnRESEnabled = value;
                            OnPropertyChanged();
                        }

                        return;
                    }

                    using (LockObject.EnterWriteLock())
                    {
                        _blnRESEnabled = value;
                        if (value)
                        {
                            // Career mode, so no extra calculations need to be done for EssenceAtSpecialStart
                            if (Created)
                            {
                                ResetCachedEssence();
                                EssenceAtSpecialStart = Essence(true, "RES");
                            }
                            // EssenceAtSpecialStart needs to be calculated by assuming that the character took the RES-enabling quality with the highest essence penalty first, as that would be the most optimal
                            else
                            {
                                // If this character has any RES-enabling bonuses that could be granted before all others (because they're priority and/or metatype-given),
                                // it has to be assumed those are taken first.
                                List<Improvement> lstAttributeImprovements = ImprovementManager
                                    .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Attribute,
                                        "RES");
                                bool blnCountOnlyPriorityOrMetatypeGivenBonuses = lstAttributeImprovements.Exists(
                                    x => x.ImproveSource
                                         == Improvement.ImprovementSource
                                             .Metatype
                                         || x.ImproveSource
                                         == Improvement.ImprovementSource
                                             .Metavariant
                                         || x.ImproveSource
                                         == Improvement.ImprovementSource
                                             .Heritage);
                                if (!blnCountOnlyPriorityOrMetatypeGivenBonuses)
                                {
                                    List<string> lstRESEnablingQualityIds = lstAttributeImprovements
                                        .Where(x => x.ImproveSource
                                                    == Improvement.ImprovementSource
                                                        .Quality).Select(
                                            x => x.SourceName).ToList();
                                    // Can't use foreach because new items can get added to this list while it is looping
                                    for (int i = 0; i < lstRESEnablingQualityIds.Count; ++i)
                                    {
                                        Quality objQuality
                                            = Qualities.FirstOrDefault(
                                                x => x.InternalId == lstRESEnablingQualityIds[i]);
                                        if (objQuality != null)
                                        {
                                            if (objQuality.OriginSource == QualitySource.Metatype
                                                || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                                || objQuality.OriginSource == QualitySource.BuiltIn
                                                || objQuality.OriginSource == QualitySource.LifeModule
                                                || objQuality.OriginSource == QualitySource.Heritage
                                                || objQuality.OriginSource == QualitySource.QualityLevelImprovement)
                                            {
                                                blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                                break;
                                            }

                                            if (objQuality.OriginSource == QualitySource.Improvement)
                                            {
                                                List<Improvement> lstSpecificQualityImprovements = ImprovementManager
                                                    .GetCachedImprovementListForValueOf(
                                                        this, Improvement.ImprovementType.SpecificQuality,
                                                        objQuality.InternalId);
                                                if (lstSpecificQualityImprovements.Exists(x =>
                                                        x.ImproveSource == Improvement.ImprovementSource.Metatype
                                                        || x.ImproveSource == Improvement.ImprovementSource
                                                            .Metavariant
                                                        || x.ImproveSource
                                                        == Improvement.ImprovementSource.Heritage))
                                                {
                                                    blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                                    break;
                                                }

                                                // Qualities that add other qualities get added to the list to be checked, too
                                                lstRESEnablingQualityIds.AddRange(
                                                    lstSpecificQualityImprovements
                                                        .Where(
                                                            x => x.ImproveSource
                                                                 == Improvement.ImprovementSource.Quality)
                                                        .Select(x => x.SourceName));
                                            }
                                        }
                                    }
                                }

                                Dictionary<string, decimal> dicImprovementEssencePenalties =
                                    new Dictionary<string, decimal>(Improvements.Count);
                                foreach (Improvement objImprovement in Improvements)
                                {
                                    if (!objImprovement.Enabled)
                                        continue;
                                    bool blnCountImprovement = !blnCountOnlyPriorityOrMetatypeGivenBonuses
                                                               || objImprovement.ImproveSource
                                                               == Improvement.ImprovementSource.Metatype
                                                               || objImprovement.ImproveSource
                                                               == Improvement.ImprovementSource.Metavariant
                                                               || objImprovement.ImproveSource
                                                               == Improvement.ImprovementSource.Heritage;
                                    if (!blnCountImprovement
                                        && objImprovement.ImproveSource == Improvement.ImprovementSource.Quality)
                                    {
                                        Quality objQuality
                                            = Qualities.FirstOrDefault(x => x.InternalId == objImprovement.SourceName);
                                        while (objQuality != null)
                                        {
                                            if (objQuality.OriginSource == QualitySource.Metatype
                                                || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                                || objQuality.OriginSource == QualitySource.BuiltIn
                                                || objQuality.OriginSource == QualitySource.LifeModule
                                                || objQuality.OriginSource == QualitySource.Heritage
                                                || objQuality.OriginSource == QualitySource.QualityLevelImprovement)
                                            {
                                                blnCountImprovement = true;
                                                break;
                                            }

                                            if (objQuality.OriginSource == QualitySource.Improvement)
                                            {
                                                Improvement objParentImprovement = ImprovementManager
                                                    .GetCachedImprovementListForValueOf(
                                                        this,
                                                        Improvement.ImprovementType
                                                            .SpecificQuality,
                                                        objQuality.InternalId)
                                                    .FirstOrDefault();
                                                if (objParentImprovement == null)
                                                    break;
                                                if (objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Metatype
                                                    || objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Metavariant
                                                    || objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Heritage)
                                                {
                                                    blnCountImprovement = true;
                                                    break;
                                                }

                                                if (objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Quality)
                                                {
                                                    // Qualities that add other qualities get added to the list to be checked, too
                                                    objQuality = Qualities.FirstOrDefault(
                                                        x => x.InternalId == objParentImprovement.SourceName);
                                                }
                                                else
                                                    break;
                                            }
                                            else
                                                break;
                                        }
                                    }

                                    if (blnCountImprovement)
                                    {
                                        decimal decLoopEssencePenalty = 0;
                                        switch (objImprovement.ImproveType)
                                        {
                                            case Improvement.ImprovementType.EssencePenalty:
                                                decLoopEssencePenalty += objImprovement.Value;
                                                break;

                                            case Improvement.ImprovementType.EssencePenaltyT100:
                                            case Improvement.ImprovementType.EssencePenaltyRESOnlyT100:
                                                decLoopEssencePenalty += objImprovement.Value / 100.0m;
                                                break;
                                        }

                                        if (decLoopEssencePenalty != 0)
                                        {
                                            if (dicImprovementEssencePenalties.TryGetValue(
                                                    objImprovement.SourceName, out decimal decExistingPenalty))
                                                dicImprovementEssencePenalties[objImprovement.SourceName]
                                                    = decExistingPenalty + decLoopEssencePenalty;
                                            else
                                                dicImprovementEssencePenalties.Add(objImprovement.SourceName,
                                                    decLoopEssencePenalty);
                                        }
                                    }
                                }

                                if (dicImprovementEssencePenalties.Count > 0)
                                    EssenceAtSpecialStart =
                                        ESS.MetatypeMaximum + dicImprovementEssencePenalties.Values.Min();
                                else
                                    EssenceAtSpecialStart = ESS.MetatypeMaximum;
                            }

                            XmlNode xmlTraditionListDataNode
                                = LoadData("streams.xml").SelectSingleNode("/chummer/traditions");
                            if (xmlTraditionListDataNode != null)
                            {
                                XmlNodeList xmlTraditionDataNodes = xmlTraditionListDataNode.SelectNodes("tradition");
                                if (xmlTraditionDataNodes?.Count == 1)
                                {
                                    if (!MagicTradition.Create(xmlTraditionDataNodes[0], true))
                                        MagicTradition.ResetTradition();
                                }
                                else
                                {
                                    MagicTradition.ResetTradition();
                                }
                            }
                            else
                            {
                                MagicTradition.ResetTradition();
                            }
                        }
                        else if (!MAGEnabled)
                        {
                            ClearInitiations();
                            MagicTradition.ResetTradition();
                            if (!Created && !DEPEnabled)
                                EssenceAtSpecialStart = decimal.MinValue;
                        }
                        else
                        {
                            XmlNode xmlTraditionListDataNode
                                = LoadData("traditions.xml").SelectSingleNode("/chummer/traditions");
                            if (xmlTraditionListDataNode != null)
                            {
                                XmlNodeList xmlTraditionDataNodes = xmlTraditionListDataNode.SelectNodes("tradition");
                                if (xmlTraditionDataNodes?.Count == 1)
                                {
                                    if (!MagicTradition.Create(xmlTraditionDataNodes[0]))
                                        MagicTradition.ResetTradition();
                                }
                                else
                                {
                                    MagicTradition.ResetTradition();
                                }
                            }
                            else
                            {
                                MagicTradition.ResetTradition();
                            }
                        }

                        ImprovementManager.ClearCachedValue(this, Improvement.ImprovementType.MatrixInitiativeDice);
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Is the RES CharacterAttribute enabled?
        /// </summary>
        public async Task<bool> GetRESEnabledAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _blnRESEnabled;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Is the RES CharacterAttribute enabled?
        /// </summary>
        public async Task SetRESEnabledAsync(bool value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_blnRESEnabled == value)
                    return;
                if (IsLoading)
                {
                    IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        _blnRESEnabled = value;
                    }
                    finally
                    {
                        await objLocker2.DisposeAsync().ConfigureAwait(false);
                    }

                    await OnPropertyChangedAsync(nameof(RESEnabled), token).ConfigureAwait(false);
                    return;
                }

                IAsyncDisposable objLocker3 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    _blnRESEnabled = value;
                    if (value)
                    {
                        // Career mode, so no extra calculations need to be done for EssenceAtSpecialStart
                        if (await GetCreatedAsync(token).ConfigureAwait(false))
                        {
                            await ResetCachedEssenceAsync(token).ConfigureAwait(false);
                            await SetEssenceAtSpecialStartAsync(
                                    await EssenceAsync(true, "RES", token).ConfigureAwait(false), token)
                                .ConfigureAwait(false);
                        }
                        // EssenceAtSpecialStart needs to be calculated by assuming that the character took the RES-enabling quality with the highest essence penalty first, as that would be the most optimal
                        else
                        {
                            // If this character has any RES-enabling bonuses that could be granted before all others (because they're priority and/or metatype-given),
                            // it has to be assumed those are taken first.
                            List<Improvement> lstAttributeImprovements = await ImprovementManager
                                .GetCachedImprovementListForValueOfAsync(
                                    this,
                                    Improvement.ImprovementType
                                        .Attribute,
                                    "RES", token: token)
                                .ConfigureAwait(false);
                            bool blnCountOnlyPriorityOrMetatypeGivenBonuses = lstAttributeImprovements.Exists(
                                x => x.ImproveSource
                                     == Improvement.ImprovementSource
                                         .Metatype
                                     || x.ImproveSource
                                     == Improvement.ImprovementSource
                                         .Metavariant
                                     || x.ImproveSource
                                     == Improvement.ImprovementSource
                                         .Heritage);
                            if (!blnCountOnlyPriorityOrMetatypeGivenBonuses)
                            {
                                List<string> lstRESEnablingQualityIds = lstAttributeImprovements
                                    .Where(x => x.ImproveSource
                                                == Improvement.ImprovementSource
                                                    .Quality).Select(
                                        x => x.SourceName).ToList();
                                // Can't use foreach because new items can get added to this list while it is looping
                                for (int i = 0; i < lstRESEnablingQualityIds.Count; ++i)
                                {
                                    int i1 = i;
                                    Quality objQuality
                                        = await Qualities.FirstOrDefaultAsync(
                                                x => x.InternalId == lstRESEnablingQualityIds[i1],
                                                token: token)
                                            .ConfigureAwait(false);
                                    if (objQuality != null)
                                    {
                                        if (objQuality.OriginSource == QualitySource.Metatype
                                            || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                            || objQuality.OriginSource == QualitySource.BuiltIn
                                            || objQuality.OriginSource == QualitySource.LifeModule
                                            || objQuality.OriginSource == QualitySource.Heritage
                                            || objQuality.OriginSource == QualitySource.QualityLevelImprovement)
                                        {
                                            blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                            break;
                                        }

                                        if (objQuality.OriginSource == QualitySource.Improvement)
                                        {
                                            List<Improvement> lstSpecificQualityImprovements = await ImprovementManager
                                                .GetCachedImprovementListForValueOfAsync(
                                                    this, Improvement.ImprovementType.SpecificQuality,
                                                    objQuality.InternalId, token: token).ConfigureAwait(false);
                                            if (lstSpecificQualityImprovements.Exists(x =>
                                                    x.ImproveSource == Improvement.ImprovementSource.Metatype
                                                    || x.ImproveSource == Improvement.ImprovementSource
                                                        .Metavariant
                                                    || x.ImproveSource
                                                    == Improvement.ImprovementSource.Heritage))
                                            {
                                                blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                                break;
                                            }

                                            // Qualities that add other qualities get added to the list to be checked, too
                                            lstRESEnablingQualityIds.AddRange(
                                                lstSpecificQualityImprovements
                                                    .Where(
                                                        x => x.ImproveSource
                                                             == Improvement.ImprovementSource.Quality)
                                                    .Select(x => x.SourceName));
                                        }
                                    }
                                }
                            }

                            Dictionary<string, decimal> dicImprovementEssencePenalties =
                                new Dictionary<string, decimal>(
                                    await Improvements.GetCountAsync(token).ConfigureAwait(false));
                            await Improvements.ForEachAsync(async objImprovement =>
                            {
                                if (!objImprovement.Enabled)
                                    return;
                                bool blnCountImprovement = !blnCountOnlyPriorityOrMetatypeGivenBonuses
                                                           || objImprovement.ImproveSource
                                                           == Improvement.ImprovementSource.Metatype
                                                           || objImprovement.ImproveSource
                                                           == Improvement.ImprovementSource.Metavariant
                                                           || objImprovement.ImproveSource
                                                           == Improvement.ImprovementSource.Heritage;
                                if (!blnCountImprovement && objImprovement.ImproveSource
                                    == Improvement.ImprovementSource.Quality)
                                {
                                    Quality objQuality
                                        = await Qualities.FirstOrDefaultAsync(
                                                x => x.InternalId == objImprovement.SourceName,
                                                token: token)
                                            .ConfigureAwait(false);
                                    while (objQuality != null)
                                    {
                                        if (objQuality.OriginSource == QualitySource.Metatype
                                            || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                            || objQuality.OriginSource == QualitySource.BuiltIn
                                            || objQuality.OriginSource == QualitySource.LifeModule
                                            || objQuality.OriginSource == QualitySource.Heritage
                                            || objQuality.OriginSource == QualitySource.QualityLevelImprovement)
                                        {
                                            blnCountImprovement = true;
                                            break;
                                        }

                                        if (objQuality.OriginSource == QualitySource.Improvement)
                                        {
                                            Improvement objParentImprovement = (await ImprovementManager
                                                    .GetCachedImprovementListForValueOfAsync(
                                                        this,
                                                        Improvement.ImprovementType
                                                            .SpecificQuality,
                                                        objQuality.InternalId, token: token).ConfigureAwait(false))
                                                .FirstOrDefault();
                                            if (objParentImprovement == null)
                                                break;
                                            if (objParentImprovement.ImproveSource
                                                == Improvement.ImprovementSource.Metatype
                                                || objParentImprovement.ImproveSource
                                                == Improvement.ImprovementSource.Metavariant
                                                || objParentImprovement.ImproveSource
                                                == Improvement.ImprovementSource.Heritage)
                                            {
                                                blnCountImprovement = true;
                                                break;
                                            }

                                            if (objParentImprovement.ImproveSource
                                                == Improvement.ImprovementSource.Quality)
                                            {
                                                // Qualities that add other qualities get added to the list to be checked, too
                                                objQuality = await Qualities.FirstOrDefaultAsync(
                                                        x => x.InternalId
                                                             == objParentImprovement.SourceName,
                                                        token: token)
                                                    .ConfigureAwait(false);
                                            }
                                            else
                                                break;
                                        }
                                        else
                                            break;
                                    }
                                }

                                if (blnCountImprovement)
                                {
                                    decimal decLoopEssencePenalty = 0;
                                    switch (objImprovement.ImproveType)
                                    {
                                        case Improvement.ImprovementType.EssencePenalty:
                                            decLoopEssencePenalty += objImprovement.Value;
                                            break;

                                        case Improvement.ImprovementType.EssencePenaltyT100:
                                        case Improvement.ImprovementType.EssencePenaltyRESOnlyT100:
                                            decLoopEssencePenalty += objImprovement.Value / 100.0m;
                                            break;
                                    }

                                    if (decLoopEssencePenalty != 0)
                                    {
                                        if (dicImprovementEssencePenalties.TryGetValue(
                                                objImprovement.SourceName, out decimal decExistingPenalty))
                                            dicImprovementEssencePenalties[objImprovement.SourceName]
                                                = decExistingPenalty + decLoopEssencePenalty;
                                        else
                                            dicImprovementEssencePenalties.Add(objImprovement.SourceName,
                                                decLoopEssencePenalty);
                                    }
                                }
                            }, token).ConfigureAwait(false);

                            if (dicImprovementEssencePenalties.Count > 0)
                                await SetEssenceAtSpecialStartAsync(
                                    await ESS.GetMetatypeMaximumAsync(token).ConfigureAwait(false)
                                    + dicImprovementEssencePenalties.Values.Min(), token).ConfigureAwait(false);
                            else
                                await SetEssenceAtSpecialStartAsync(
                                        await ESS.GetMetatypeMaximumAsync(token).ConfigureAwait(false), token)
                                    .ConfigureAwait(false);
                        }

                        XmlNode xmlTraditionListDataNode
                            = (await LoadDataAsync("streams.xml", token: token).ConfigureAwait(false)).SelectSingleNode("/chummer/traditions");
                        if (xmlTraditionListDataNode != null)
                        {
                            XmlNodeList xmlTraditionDataNodes = xmlTraditionListDataNode.SelectNodes("tradition");
                            if (xmlTraditionDataNodes?.Count == 1)
                            {
                                if (!await MagicTradition.CreateAsync(xmlTraditionDataNodes[0], true, token: token).ConfigureAwait(false))
                                    await MagicTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                            }
                            else
                            {
                                await MagicTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                            }
                        }
                        else
                        {
                            await MagicTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                        }
                    }
                    else if (!await GetMAGEnabledAsync(token).ConfigureAwait(false))
                    {
                        await ClearInitiationsAsync(token).ConfigureAwait(false);
                        await MagicTradition.ResetTraditionAsync(token).ConfigureAwait(false);

                        if (!await GetCreatedAsync(token).ConfigureAwait(false)
                            && !await GetDEPEnabledAsync(token).ConfigureAwait(false))
                            await SetEssenceAtSpecialStartAsync(decimal.MinValue, token).ConfigureAwait(false);
                    }
                    else
                    {
                        XmlNode xmlTraditionListDataNode
                            = (await LoadDataAsync("traditions.xml", token: token).ConfigureAwait(false)).SelectSingleNode("/chummer/traditions");
                        if (xmlTraditionListDataNode != null)
                        {
                            XmlNodeList xmlTraditionDataNodes = xmlTraditionListDataNode.SelectNodes("tradition");
                            if (xmlTraditionDataNodes?.Count == 1)
                            {
                                if (!await MagicTradition.CreateAsync(xmlTraditionDataNodes[0], token: token).ConfigureAwait(false))
                                    await MagicTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                            }
                            else
                            {
                                await MagicTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                            }
                        }
                        else
                        {
                            await MagicTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                        }
                    }

                    ImprovementManager.ClearCachedValue(this, Improvement.ImprovementType.MatrixInitiativeDice,
                        token: token);
                }
                finally
                {
                    await objLocker3.DisposeAsync().ConfigureAwait(false);
                }

                await OnPropertyChangedAsync(nameof(RESEnabled), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Is the DEP CharacterAttribute enabled?
        /// </summary>
        [HubTag]
        public bool DEPEnabled
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _blnDEPEnabled;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (_blnDEPEnabled == value)
                        return;
                    if (IsLoading)
                    {
                        using (LockObject.EnterWriteLock())
                        {
                            _blnDEPEnabled = value;
                            OnPropertyChanged();
                        }

                        return;
                    }

                    using (LockObject.EnterWriteLock())
                    {
                        _blnDEPEnabled = value;
                        if (value)
                        {
                            // Career mode, so no extra calculations need to be done for EssenceAtSpecialStart
                            if (Created)
                            {
                                ResetCachedEssence();
                                EssenceAtSpecialStart = Essence(true, "DEP");
                            }
                            // EssenceAtSpecialStart needs to be calculated by assuming that the character took the DEP-enabling quality with the highest essence penalty first, as that would be the most optimal
                            else
                            {
                                // If this character has any DEP-enabling bonuses that could be granted before all others (because they're priority and/or metatype-given),
                                // it has to be assumed those are taken first.
                                List<Improvement> lstAttributeImprovements = ImprovementManager
                                    .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Attribute,
                                        "DEP");
                                bool blnCountOnlyPriorityOrMetatypeGivenBonuses = lstAttributeImprovements.Exists(
                                    x => x.ImproveSource
                                         == Improvement.ImprovementSource
                                             .Metatype
                                         || x.ImproveSource
                                         == Improvement.ImprovementSource
                                             .Metavariant
                                         || x.ImproveSource
                                         == Improvement.ImprovementSource
                                             .Heritage);
                                if (!blnCountOnlyPriorityOrMetatypeGivenBonuses)
                                {
                                    List<string> lstDEPEnablingQualityIds = lstAttributeImprovements
                                        .Where(x => x.ImproveSource
                                                    == Improvement.ImprovementSource
                                                        .Quality).Select(
                                            x => x.SourceName).ToList();
                                    // Can't use foreach because new items can get added to this list while it is looping
                                    for (int i = 0; i < lstDEPEnablingQualityIds.Count; ++i)
                                    {
                                        Quality objQuality
                                            = Qualities.FirstOrDefault(
                                                x => x.InternalId == lstDEPEnablingQualityIds[i]);
                                        if (objQuality != null)
                                        {
                                            if (objQuality.OriginSource == QualitySource.Metatype
                                                || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                                || objQuality.OriginSource == QualitySource.BuiltIn
                                                || objQuality.OriginSource == QualitySource.LifeModule
                                                || objQuality.OriginSource == QualitySource.Heritage
                                                || objQuality.OriginSource == QualitySource.QualityLevelImprovement)
                                            {
                                                blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                                break;
                                            }

                                            if (objQuality.OriginSource == QualitySource.Improvement)
                                            {
                                                List<Improvement> lstSpecificQualityImprovements = ImprovementManager
                                                    .GetCachedImprovementListForValueOf(
                                                        this, Improvement.ImprovementType.SpecificQuality,
                                                        objQuality.InternalId);
                                                if (lstSpecificQualityImprovements.Exists(x =>
                                                        x.ImproveSource == Improvement.ImprovementSource.Metatype
                                                        || x.ImproveSource == Improvement.ImprovementSource
                                                            .Metavariant
                                                        || x.ImproveSource
                                                        == Improvement.ImprovementSource.Heritage))
                                                {
                                                    blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                                    break;
                                                }

                                                // Qualities that add other qualities get added to the list to be checked, too
                                                lstDEPEnablingQualityIds.AddRange(
                                                    lstSpecificQualityImprovements
                                                        .Where(
                                                            x => x.ImproveSource
                                                                 == Improvement.ImprovementSource.Quality)
                                                        .Select(x => x.SourceName));
                                            }
                                        }
                                    }
                                }

                                Dictionary<string, decimal> dicImprovementEssencePenalties =
                                    new Dictionary<string, decimal>(Improvements.Count);
                                foreach (Improvement objImprovement in Improvements)
                                {
                                    if (!objImprovement.Enabled)
                                        continue;
                                    bool blnCountImprovement = !blnCountOnlyPriorityOrMetatypeGivenBonuses
                                                               || objImprovement.ImproveSource
                                                               == Improvement.ImprovementSource.Metatype
                                                               || objImprovement.ImproveSource
                                                               == Improvement.ImprovementSource.Metavariant
                                                               || objImprovement.ImproveSource
                                                               == Improvement.ImprovementSource.Heritage;
                                    if (!blnCountImprovement
                                        && objImprovement.ImproveSource == Improvement.ImprovementSource.Quality)
                                    {
                                        Quality objQuality
                                            = Qualities.FirstOrDefault(x => x.InternalId == objImprovement.SourceName);
                                        while (objQuality != null)
                                        {
                                            if (objQuality.OriginSource == QualitySource.Metatype
                                                || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                                || objQuality.OriginSource == QualitySource.BuiltIn
                                                || objQuality.OriginSource == QualitySource.LifeModule
                                                || objQuality.OriginSource == QualitySource.Heritage
                                                || objQuality.OriginSource == QualitySource.QualityLevelImprovement)
                                            {
                                                blnCountImprovement = true;
                                                break;
                                            }

                                            if (objQuality.OriginSource == QualitySource.Improvement)
                                            {
                                                Improvement objParentImprovement = ImprovementManager
                                                    .GetCachedImprovementListForValueOf(
                                                        this,
                                                        Improvement.ImprovementType
                                                            .SpecificQuality,
                                                        objQuality.InternalId)
                                                    .FirstOrDefault();
                                                if (objParentImprovement == null)
                                                    break;
                                                if (objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Metatype
                                                    || objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Metavariant
                                                    || objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Heritage)
                                                {
                                                    blnCountImprovement = true;
                                                    break;
                                                }

                                                if (objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Quality)
                                                {
                                                    // Qualities that add other qualities get added to the list to be checked, too
                                                    objQuality = Qualities.FirstOrDefault(
                                                        x => x.InternalId == objParentImprovement.SourceName);
                                                }
                                                else
                                                    break;
                                            }
                                            else
                                                break;
                                        }
                                    }

                                    if (blnCountImprovement)
                                    {
                                        decimal decLoopEssencePenalty = 0;
                                        switch (objImprovement.ImproveType)
                                        {
                                            case Improvement.ImprovementType.EssencePenalty:
                                                decLoopEssencePenalty += objImprovement.Value;
                                                break;

                                            case Improvement.ImprovementType.EssencePenaltyT100:
                                            case Improvement.ImprovementType.EssencePenaltyDEPOnlyT100:
                                                decLoopEssencePenalty += objImprovement.Value / 100.0m;
                                                break;
                                        }

                                        if (decLoopEssencePenalty != 0)
                                        {
                                            if (dicImprovementEssencePenalties.TryGetValue(
                                                    objImprovement.SourceName, out decimal decExistingPenalty))
                                                dicImprovementEssencePenalties[objImprovement.SourceName]
                                                    = decExistingPenalty + decLoopEssencePenalty;
                                            else
                                                dicImprovementEssencePenalties.Add(objImprovement.SourceName,
                                                    decLoopEssencePenalty);
                                        }
                                    }
                                }

                                if (dicImprovementEssencePenalties.Count > 0)
                                    EssenceAtSpecialStart =
                                        ESS.MetatypeMaximum + dicImprovementEssencePenalties.Values.Min();
                                else
                                    EssenceAtSpecialStart = ESS.MetatypeMaximum;
                            }
                        }
                        else if (!Created && !RESEnabled && !MAGEnabled)
                            EssenceAtSpecialStart = decimal.MinValue;

                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Is the DEP CharacterAttribute enabled?
        /// </summary>
        public async Task<bool> GetDEPEnabledAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _blnDEPEnabled;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Is the DEP CharacterAttribute enabled?
        /// </summary>
        public async Task SetDEPEnabledAsync(bool value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_blnDEPEnabled == value)
                    return;
                if (IsLoading)
                {
                    IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        _blnDEPEnabled = value;
                    }
                    finally
                    {
                        await objLocker2.DisposeAsync().ConfigureAwait(false);
                    }

                    await OnPropertyChangedAsync(nameof(DEPEnabled), token).ConfigureAwait(false);
                    return;
                }

                IAsyncDisposable objLocker3 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    _blnDEPEnabled = value;
                    if (value)
                    {
                        // Career mode, so no extra calculations need to be done for EssenceAtSpecialStart
                        if (await GetCreatedAsync(token).ConfigureAwait(false))
                        {
                            await ResetCachedEssenceAsync(token).ConfigureAwait(false);
                            await SetEssenceAtSpecialStartAsync(
                                    await EssenceAsync(true, "DEP", token).ConfigureAwait(false), token)
                                .ConfigureAwait(false);
                        }
                        // EssenceAtSpecialStart needs to be calculated by assuming that the character took the DEP-enabling quality with the highest essence penalty first, as that would be the most optimal
                        else
                        {
                            // If this character has any DEP-enabling bonuses that could be granted before all others (because they're priority and/or metatype-given),
                            // it has to be assumed those are taken first.
                            List<Improvement> lstAttributeImprovements = await ImprovementManager
                                .GetCachedImprovementListForValueOfAsync(
                                    this,
                                    Improvement.ImprovementType
                                        .Attribute,
                                    "DEP", token: token)
                                .ConfigureAwait(false);
                            bool blnCountOnlyPriorityOrMetatypeGivenBonuses = lstAttributeImprovements.Exists(
                                x => x.ImproveSource
                                     == Improvement.ImprovementSource
                                         .Metatype
                                     || x.ImproveSource
                                     == Improvement.ImprovementSource
                                         .Metavariant
                                     || x.ImproveSource
                                     == Improvement.ImprovementSource
                                         .Heritage);
                            if (!blnCountOnlyPriorityOrMetatypeGivenBonuses)
                            {
                                List<string> lstDEPEnablingQualityIds = lstAttributeImprovements
                                    .Where(x => x.ImproveSource
                                                == Improvement.ImprovementSource
                                                    .Quality).Select(
                                        x => x.SourceName).ToList();
                                // Can't use foreach because new items can get added to this list while it is looping
                                for (int i = 0; i < lstDEPEnablingQualityIds.Count; ++i)
                                {
                                    int i1 = i;
                                    Quality objQuality
                                        = await Qualities.FirstOrDefaultAsync(
                                                x => x.InternalId == lstDEPEnablingQualityIds[i1],
                                                token: token)
                                            .ConfigureAwait(false);
                                    if (objQuality != null)
                                    {
                                        if (objQuality.OriginSource == QualitySource.Metatype
                                            || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                            || objQuality.OriginSource == QualitySource.BuiltIn
                                            || objQuality.OriginSource == QualitySource.LifeModule
                                            || objQuality.OriginSource == QualitySource.Heritage
                                            || objQuality.OriginSource == QualitySource.QualityLevelImprovement)
                                        {
                                            blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                            break;
                                        }

                                        if (objQuality.OriginSource == QualitySource.Improvement)
                                        {
                                            List<Improvement> lstSpecificQualityImprovements = await ImprovementManager
                                                .GetCachedImprovementListForValueOfAsync(
                                                    this, Improvement.ImprovementType.SpecificQuality,
                                                    objQuality.InternalId, token: token).ConfigureAwait(false);
                                            if (lstSpecificQualityImprovements.Exists(x =>
                                                    x.ImproveSource == Improvement.ImprovementSource.Metatype
                                                    || x.ImproveSource == Improvement.ImprovementSource
                                                        .Metavariant
                                                    || x.ImproveSource
                                                    == Improvement.ImprovementSource.Heritage))
                                            {
                                                blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                                break;
                                            }

                                            // Qualities that add other qualities get added to the list to be checked, too
                                            lstDEPEnablingQualityIds.AddRange(
                                                lstSpecificQualityImprovements
                                                    .Where(
                                                        x => x.ImproveSource
                                                             == Improvement.ImprovementSource.Quality)
                                                    .Select(x => x.SourceName));
                                        }
                                    }
                                }
                            }

                            Dictionary<string, decimal> dicImprovementEssencePenalties =
                                new Dictionary<string, decimal>(
                                    await Improvements.GetCountAsync(token).ConfigureAwait(false));
                            await Improvements.ForEachAsync(async objImprovement =>
                            {
                                if (!objImprovement.Enabled)
                                    return;
                                bool blnCountImprovement = !blnCountOnlyPriorityOrMetatypeGivenBonuses
                                                           || objImprovement.ImproveSource
                                                           == Improvement.ImprovementSource.Metatype
                                                           || objImprovement.ImproveSource
                                                           == Improvement.ImprovementSource.Metavariant
                                                           || objImprovement.ImproveSource
                                                           == Improvement.ImprovementSource.Heritage;
                                if (!blnCountImprovement && objImprovement.ImproveSource
                                    == Improvement.ImprovementSource.Quality)
                                {
                                    Quality objQuality
                                        = await Qualities.FirstOrDefaultAsync(
                                                x => x.InternalId == objImprovement.SourceName,
                                                token: token)
                                            .ConfigureAwait(false);
                                    while (objQuality != null)
                                    {
                                        if (objQuality.OriginSource == QualitySource.Metatype
                                            || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                            || objQuality.OriginSource == QualitySource.BuiltIn
                                            || objQuality.OriginSource == QualitySource.LifeModule
                                            || objQuality.OriginSource == QualitySource.Heritage
                                            || objQuality.OriginSource == QualitySource.QualityLevelImprovement)
                                        {
                                            blnCountImprovement = true;
                                            break;
                                        }

                                        if (objQuality.OriginSource == QualitySource.Improvement)
                                        {
                                            Improvement objParentImprovement = (await ImprovementManager
                                                    .GetCachedImprovementListForValueOfAsync(
                                                        this,
                                                        Improvement.ImprovementType
                                                            .SpecificQuality,
                                                        objQuality.InternalId, token: token).ConfigureAwait(false))
                                                .FirstOrDefault();
                                            if (objParentImprovement == null)
                                                break;
                                            if (objParentImprovement.ImproveSource
                                                == Improvement.ImprovementSource.Metatype
                                                || objParentImprovement.ImproveSource
                                                == Improvement.ImprovementSource.Metavariant
                                                || objParentImprovement.ImproveSource
                                                == Improvement.ImprovementSource.Heritage)
                                            {
                                                blnCountImprovement = true;
                                                break;
                                            }

                                            if (objParentImprovement.ImproveSource
                                                == Improvement.ImprovementSource.Quality)
                                            {
                                                // Qualities that add other qualities get added to the list to be checked, too
                                                objQuality = await Qualities.FirstOrDefaultAsync(
                                                        x => x.InternalId
                                                             == objParentImprovement.SourceName,
                                                        token: token)
                                                    .ConfigureAwait(false);
                                            }
                                            else
                                                break;
                                        }
                                        else
                                            break;
                                    }
                                }

                                if (blnCountImprovement)
                                {
                                    decimal decLoopEssencePenalty = 0;
                                    switch (objImprovement.ImproveType)
                                    {
                                        case Improvement.ImprovementType.EssencePenalty:
                                            decLoopEssencePenalty += objImprovement.Value;
                                            break;

                                        case Improvement.ImprovementType.EssencePenaltyT100:
                                        case Improvement.ImprovementType.EssencePenaltyDEPOnlyT100:
                                            decLoopEssencePenalty += objImprovement.Value / 100.0m;
                                            break;
                                    }

                                    if (decLoopEssencePenalty != 0)
                                    {
                                        if (dicImprovementEssencePenalties.TryGetValue(
                                                objImprovement.SourceName, out decimal decExistingPenalty))
                                            dicImprovementEssencePenalties[objImprovement.SourceName]
                                                = decExistingPenalty + decLoopEssencePenalty;
                                        else
                                            dicImprovementEssencePenalties.Add(objImprovement.SourceName,
                                                decLoopEssencePenalty);
                                    }
                                }
                            }, token).ConfigureAwait(false);

                            if (dicImprovementEssencePenalties.Count > 0)
                                await SetEssenceAtSpecialStartAsync(
                                    await ESS.GetMetatypeMaximumAsync(token).ConfigureAwait(false)
                                    + dicImprovementEssencePenalties.Values.Min(), token).ConfigureAwait(false);
                            else
                                await SetEssenceAtSpecialStartAsync(
                                        await ESS.GetMetatypeMaximumAsync(token).ConfigureAwait(false), token)
                                    .ConfigureAwait(false);
                        }
                    }
                    else if (!await GetCreatedAsync(token).ConfigureAwait(false)
                             && !await GetRESEnabledAsync(token).ConfigureAwait(false)
                             && !await GetMAGEnabledAsync(token).ConfigureAwait(false))
                        await SetEssenceAtSpecialStartAsync(decimal.MinValue, token).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker3.DisposeAsync().ConfigureAwait(false);
                }

                await OnPropertyChangedAsync(nameof(DEPEnabled), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        [HubTag]
        public bool IsAI
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return DEPEnabled && BOD?.MetatypeMaximum == 0;
            }
        }

        public async Task<bool> GetIsAIAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (!await GetDEPEnabledAsync(token).ConfigureAwait(false))
                    return false;
                CharacterAttrib objBody = await GetAttributeAsync("BOD", token: token).ConfigureAwait(false);
                return objBody == null || await objBody.GetMetatypeMaximumAsync(token).ConfigureAwait(false) == 0;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Submersion Grade.
        /// </summary>
        [HubTag]
        public int SubmersionGrade
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _intSubmersionGrade;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (_intSubmersionGrade == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        int intOldValue = Interlocked.Exchange(ref _intSubmersionGrade, value);
                        if (intOldValue == value)
                            return;
                        // Remove any existing Submersion Improvements.
                        if (value == 0)
                        {
                            ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Submersion);
                            // Update any Echo Improvements the character might have.
                            foreach (Metamagic objMetamagic in Metamagics.Where(
                                         x => x.SourceType == Improvement.ImprovementSource.Echo
                                              && x.Bonus?.InnerXmlContentContains("Rating") == true))
                            {
                                ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Echo,
                                                                      objMetamagic.InternalId);
                            }
                        }
                        else if (intOldValue == 0)
                        {
                            try
                            {
                                // Create the new Improvement.
                                ImprovementManager.CreateImprovement(this, "RES", Improvement.ImprovementSource.Submersion,
                                                                     string.Empty, Improvement.ImprovementType.Attribute,
                                                                     string.Empty, 0, value, 0, 1);
                                // Update any Echo Improvements the character might have.
                                foreach (Metamagic objMetamagic in Metamagics.Where(
                                             x => x.SourceType == Improvement.ImprovementSource.Echo
                                                  && x.Bonus?.InnerXmlContentContains("Rating") == true))
                                {
                                    ImprovementManager.CreateImprovements(this, Improvement.ImprovementSource.Echo,
                                                                          objMetamagic.InternalId, objMetamagic.Bonus,
                                                                          value,
                                                                          objMetamagic.CurrentDisplayNameShort);
                                }
                            }
                            catch
                            {
                                ImprovementManager.Rollback(this, CancellationToken.None);
                                throw;
                            }

                            ImprovementManager.Commit(this);
                        }
                        else
                        {
                            bool blnFoundImprovement = false;
                            // ReSharper disable once ForCanBeConvertedToForeach
                            for (int i = 0; i < Improvements.Count; ++i)
                            {
                                Improvement objImprovement = Improvements[i];
                                if (objImprovement.ImproveSource == Improvement.ImprovementSource.Submersion)
                                {
                                    blnFoundImprovement = true;
                                    objImprovement.Rating = value;
                                }
                            }
                            if (!blnFoundImprovement)
                            {
                                // Create the new Improvement.
                                try
                                {
                                    ImprovementManager.CreateImprovement(this, "RES",
                                                                         Improvement.ImprovementSource.Submersion,
                                                                         string.Empty,
                                                                         Improvement.ImprovementType.Attribute,
                                                                         string.Empty, 0, value, 0, 1);
                                }
                                catch
                                {
                                    ImprovementManager.Rollback(this, CancellationToken.None);
                                    throw;
                                }

                                ImprovementManager.Commit(this);
                            }

                            // Update any Echo Improvements the character might have.
                            foreach (Metamagic objMetamagic in Metamagics.Where(
                                         x => x.SourceType == Improvement.ImprovementSource.Echo
                                              && x.Bonus?.InnerXmlContentContains("Rating") == true))
                            {
                                blnFoundImprovement = false;
                                string strMetamagicId = objMetamagic.InternalId;
                                // ReSharper disable once ForCanBeConvertedToForeach
                                for (int i = 0; i < Improvements.Count; ++i)
                                {
                                    Improvement objImprovement = Improvements[i];
                                    if (objImprovement.SourceName == strMetamagicId &&
                                        objImprovement.ImproveSource == Improvement.ImprovementSource.Echo)
                                    {
                                        blnFoundImprovement = true;
                                        objImprovement.Rating = value;
                                    }
                                }
                                // If the Bonus contains "Rating", refresh ratings of existing Improvements.
                                if (!blnFoundImprovement)
                                {
                                    try
                                    {
                                        ImprovementManager.CreateImprovements(this, Improvement.ImprovementSource.Echo,
                                                                              strMetamagicId, objMetamagic.Bonus, value,
                                                                              objMetamagic.CurrentDisplayNameShort);
                                    }
                                    catch
                                    {
                                        ImprovementManager.Rollback(this, CancellationToken.None);
                                        throw;
                                    }

                                    ImprovementManager.Commit(this);
                                }
                            }
                        }
                    }
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Submersion Grade.
        /// </summary>
        public async Task<int> GetSubmersionGradeAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _intSubmersionGrade;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Submersion Grade.
        /// </summary>
        public async Task SetSubmersionGradeAsync(int value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_intSubmersionGrade == value)
                    return;
                IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    int intOldValue = Interlocked.Exchange(ref _intSubmersionGrade, value);
                    if (intOldValue == value)
                        return;
                    // Remove any existing Submersion Improvements.
                    if (value == 0)
                    {
                        await ImprovementManager
                            .RemoveImprovementsAsync(this, Improvement.ImprovementSource.Submersion, token: token)
                            .ConfigureAwait(false);
                        // Update any Echo Improvements the character might have.
                        await Metamagics.ForEachAsync(async objMetamagic =>
                        {
                            if (objMetamagic.SourceType == Improvement.ImprovementSource.Echo
                                && objMetamagic.Bonus?.InnerXmlContentContains("Rating", token) == true)
                            {
                                await ImprovementManager.RemoveImprovementsAsync(
                                        this, Improvement.ImprovementSource.Echo,
                                        objMetamagic.InternalId, token: token)
                                    .ConfigureAwait(false);
                            }
                        }, token).ConfigureAwait(false);
                    }
                    else if (intOldValue == 0)
                    {
                        try
                        {
                            token.ThrowIfCancellationRequested();
                            // Create the new Improvement.
                            await ImprovementManager.CreateImprovementAsync(
                                this, "RES", Improvement.ImprovementSource.Submersion,
                                string.Empty, Improvement.ImprovementType.Attribute,
                                string.Empty, 0, value, 0, 1, token: token).ConfigureAwait(false);
                            // Update any Echo Improvements the character might have.
                            await Metamagics.ForEachAsync(async objMetamagic =>
                            {
                                if (objMetamagic.SourceType == Improvement.ImprovementSource.Echo
                                    && objMetamagic.Bonus?.InnerXmlContentContains("Rating", token) == true)
                                {
                                    await ImprovementManager.CreateImprovementsAsync(
                                        this, Improvement.ImprovementSource.Echo, objMetamagic.InternalId,
                                        objMetamagic.Bonus, value,
                                        await objMetamagic.GetCurrentDisplayNameShortAsync(token).ConfigureAwait(false),
                                        token: token).ConfigureAwait(false);
                                }
                            }, token).ConfigureAwait(false);
                        }
                        catch
                        {
                            await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }

                        await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);
                    }
                    else
                    {
                        bool blnFoundImprovement = false;
                        // ReSharper disable once ForCanBeConvertedToForeach
                        for (int i = 0; i < await Improvements.GetCountAsync(token).ConfigureAwait(false); ++i)
                        {
                            Improvement objImprovement
                                = await Improvements.GetValueAtAsync(i, token).ConfigureAwait(false);
                            if (objImprovement.ImproveSource == Improvement.ImprovementSource.Submersion)
                            {
                                blnFoundImprovement = true;
                                await objImprovement.SetRatingAsync(value, token).ConfigureAwait(false);
                            }
                        }

                        if (!blnFoundImprovement)
                        {
                            // Create the new Improvement.
                            try
                            {
                                token.ThrowIfCancellationRequested();
                                await ImprovementManager.CreateImprovementAsync(this, "RES",
                                        Improvement.ImprovementSource.Submersion,
                                        string.Empty,
                                        Improvement.ImprovementType.Attribute,
                                        string.Empty, 0, value, 0, 1, token: token)
                                    .ConfigureAwait(false);
                            }
                            catch
                            {
                                await ImprovementManager.RollbackAsync(this, CancellationToken.None)
                                    .ConfigureAwait(false);
                                throw;
                            }

                            await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);
                        }

                        // Update any Echo Improvements the character might have.
                        await Metamagics.ForEachAsync(async objMetamagic =>
                        {
                            if (objMetamagic.SourceType == Improvement.ImprovementSource.Echo
                                && objMetamagic.Bonus?.InnerXmlContentContains("Rating", token) == true)
                            {
                                blnFoundImprovement = false;
                                string strMetamagicId = objMetamagic.InternalId;
                                // ReSharper disable once ForCanBeConvertedToForeach
                                for (int i = 0;
                                     i < await Improvements.GetCountAsync(token).ConfigureAwait(false);
                                     ++i)
                                {
                                    Improvement objImprovement = await Improvements.GetValueAtAsync(i, token)
                                        .ConfigureAwait(false);
                                    if (objImprovement.SourceName == strMetamagicId && objImprovement.ImproveSource
                                        == Improvement.ImprovementSource.Echo)
                                    {
                                        blnFoundImprovement = true;
                                        await objImprovement.SetRatingAsync(value, token).ConfigureAwait(false);
                                    }
                                }

                                // If the Bonus contains "Rating", refresh ratings of existing Improvements.
                                if (!blnFoundImprovement)
                                {
                                    try
                                    {
                                        token.ThrowIfCancellationRequested();
                                        await ImprovementManager.CreateImprovementsAsync(
                                            this, Improvement.ImprovementSource.Echo, strMetamagicId,
                                            objMetamagic.Bonus,
                                            value,
                                            await objMetamagic.GetCurrentDisplayNameShortAsync(token)
                                                .ConfigureAwait(false),
                                            token: token).ConfigureAwait(false);
                                    }
                                    catch
                                    {
                                        await ImprovementManager.RollbackAsync(this, CancellationToken.None)
                                            .ConfigureAwait(false);
                                        throw;
                                    }

                                    await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);
                                }
                            }
                        }, token).ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }

                await OnPropertyChangedAsync(nameof(SubmersionGrade), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether the character is a member of a Group or Network.
        /// </summary>
        public bool GroupMember
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _blnGroupMember;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (_blnGroupMember == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnGroupMember = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Whether the character is a member of a Group or Network.
        /// </summary>
        public async Task<bool> GetGroupMemberAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _blnGroupMember;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether the character is a member of a Group or Network.
        /// </summary>
        public async Task SetGroupMemberAsync(bool value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_blnGroupMember == value)
                    return;
                IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    _blnGroupMember = value;
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }

                await OnPropertyChangedAsync(nameof(GroupMember), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// The name of the Group the Initiate has joined.
        /// </summary>
        [HubTag]
        public string GroupName
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _strGroupName;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _strGroupName, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// The name of the Group the Initiate has joined.
        /// </summary>
        public async Task<string> GetGroupNameAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _strGroupName;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// The name of the Group the Initiate has joined.
        /// </summary>
        public async Task SetGroupNameAsync(string value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _strGroupName, value) != value)
                    await OnPropertyChangedAsync(nameof(GroupName), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Notes for the Group the Initiate has joined.
        /// </summary>
        public string GroupNotes
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _strGroupNotes;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _strGroupNotes, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Notes for the Group the Initiate has joined.
        /// </summary>
        public async Task<string> GetGroupNotesAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _strGroupNotes;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Notes for the Group the Initiate has joined.
        /// </summary>
        public async Task SetGroupNotesAsync(string value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _strGroupNotes, value) != value)
                    await OnPropertyChangedAsync(nameof(GroupNotes), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Essence the character had when the first gained access to MAG/RES.
        /// </summary>
        public decimal EssenceAtSpecialStart
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _decEssenceAtSpecialStart;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (_decEssenceAtSpecialStart == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _decEssenceAtSpecialStart = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Essence the character had when the first gained access to MAG/RES.
        /// </summary>
        public async Task<decimal> GetEssenceAtSpecialStartAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _decEssenceAtSpecialStart;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Essence the character had when the first gained access to MAG/RES.
        /// </summary>
        public async Task SetEssenceAtSpecialStartAsync(decimal value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_decEssenceAtSpecialStart == value)
                    return;
                IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    _decEssenceAtSpecialStart = value;
                    await OnPropertyChangedAsync(nameof(EssenceAtSpecialStart), token).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private decimal _decCachedEssence = decimal.MinValue;
        private readonly AsyncFriendlyReaderWriterLock _objCachedEssenceLock;

        public void ResetCachedEssence(CancellationToken token = default)
        {
            using (_objCachedEssenceLock.EnterWriteLock(token))
                _decCachedEssence = decimal.MinValue;
        }

        public async Task ResetCachedEssenceAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await _objCachedEssenceLock.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                _decCachedEssence = decimal.MinValue;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's Essence.
        /// </summary>
        /// <param name="blnAttributeSpecific">Whether fetched Essence is to be used to calculate the penalty that a specific attribute should receive from lost Essence (true) or not (false).</param>
        /// <param name="strAttribute">If <paramref name="blnAttributeSpecific"/> is true, the abbreviation of the attribute to use.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public decimal Essence(bool blnAttributeSpecific = false, string strAttribute = "", CancellationToken token = default)
        {
            using (LockObject.EnterReadLock(token))
            {
                decimal decExtraEss = 0.0m;
                IDisposable objLocker = null;
                if (blnAttributeSpecific)
                {
                    switch (strAttribute.ToUpperInvariant())
                    {
                        case "MAG":
                        case "MAGADEPT":
                            decExtraEss = ImprovementManager.ValueOf(
                                          this, Improvement.ImprovementType.EssencePenaltyMAGOnlyT100,
                                          token: token)
                                      / 100.0m;
                            break;
                        case "RES":
                            decExtraEss = ImprovementManager.ValueOf(
                                              this, Improvement.ImprovementType.EssencePenaltyRESOnlyT100,
                                              token: token)
                                          / 100.0m;
                            break;
                        case "DEP":
                            decExtraEss = ImprovementManager.ValueOf(
                                              this, Improvement.ImprovementType.EssencePenaltyDEPOnlyT100,
                                              token: token)
                                          / 100.0m;
                            break;
                    }
                    if (decExtraEss == 0)
                        return Essence(token: token);
                }
                else
                    objLocker = _objCachedEssenceLock.EnterReadLock(token);

                try
                {
                    token.ThrowIfCancellationRequested();
                    if (_decCachedEssence != decimal.MinValue && !blnAttributeSpecific)
                        return _decCachedEssence;
                }
                finally
                {
                    objLocker?.Dispose();
                }

                if (!blnAttributeSpecific)
                    objLocker = _objCachedEssenceLock.EnterUpgradeableReadLock(token);
                try
                {
                    token.ThrowIfCancellationRequested();
                    if (_decCachedEssence != decimal.MinValue && !blnAttributeSpecific)
                        return _decCachedEssence;
                    IDisposable objWriteLocker = null;
                    if (!blnAttributeSpecific)
                        objWriteLocker = _objCachedEssenceLock.EnterWriteLock(token);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        // If the character has a fixed Essence Improvement, permanently fix their Essence at its value.
                        if (ImprovementManager
                            .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.CyborgEssence,
                                                                token: token).Count
                            > 0)
                        {
                            if (!blnAttributeSpecific)
                                _decCachedEssence = 0.1m;
                            return 0.1m;
                        }

                        decimal decESS = ESS.MetatypeMaximum + decExtraEss;
                        decESS += ImprovementManager.ValueOf(this, Improvement.ImprovementType.EssencePenalty,
                                                             token: token);
                        decESS += ImprovementManager.ValueOf(this, Improvement.ImprovementType.EssencePenaltyT100,
                                                             token: token)
                                  / 100.0m;

                        // Run through all of the pieces of Cyberware and include their Essence cost.
                        decESS -= Cyberware.Sum(objCyberware => objCyberware.CalculatedESS);

                        //1781 Essence is not printing
                        //ESS.Base = Convert.ToInt32(decESS); -- Disabled because this messes up Character Validity, and it really shouldn't be what "Base" of an attribute is supposed to be (it's supposed to be extra levels gained)

                        if (!blnAttributeSpecific)
                            _decCachedEssence = decESS;
                        return decESS;
                    }
                    finally
                    {
                        objWriteLocker?.Dispose();
                    }
                }
                finally
                {
                    objLocker?.Dispose();
                }
            }
        }

        /// <summary>
        /// Character's Essence.
        /// </summary>
        /// <param name="blnAttributeSpecific">Whether fetched Essence is to be used to calculate the penalty that a specific attribute should receive from lost Essence (true) or not (false).</param>
        /// <param name="strAttribute">If <paramref name="blnAttributeSpecific"/> is true, the abbreviation of the attribute to use.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public async Task<decimal> EssenceAsync(bool blnAttributeSpecific = false, string strAttribute = "", CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                decimal decExtraEss = 0.0m;

                IAsyncDisposable objLocker2 = null;
                if (blnAttributeSpecific)
                {
                    switch (strAttribute.ToUpperInvariant())
                    {
                        case "MAG":
                        case "MAGADEPT":
                            decExtraEss = await ImprovementManager.ValueOfAsync(
                                              this, Improvement.ImprovementType.EssencePenaltyMAGOnlyT100,
                                              token: token).ConfigureAwait(false)
                                          / 100.0m;
                            break;
                        case "RES":
                            decExtraEss = await ImprovementManager.ValueOfAsync(
                                              this, Improvement.ImprovementType.EssencePenaltyRESOnlyT100,
                                              token: token).ConfigureAwait(false)
                                          / 100.0m;
                            break;
                        case "DEP":
                            decExtraEss = await ImprovementManager.ValueOfAsync(
                                              this, Improvement.ImprovementType.EssencePenaltyDEPOnlyT100,
                                              token: token).ConfigureAwait(false)
                                          / 100.0m;
                            break;
                    }
                    if (decExtraEss == 0)
                        return await EssenceAsync(token: token).ConfigureAwait(false);
                }
                else
                    objLocker2 = await _objCachedEssenceLock.EnterReadLockAsync(token).ConfigureAwait(false);

                try
                {
                    token.ThrowIfCancellationRequested();
                    if (_decCachedEssence != decimal.MinValue && !blnAttributeSpecific)
                        return _decCachedEssence;
                }
                finally
                {
                    if (objLocker2 != null)
                        await objLocker2.DisposeAsync().ConfigureAwait(false);
                }

                objLocker2 = !blnAttributeSpecific
                    ? await _objCachedEssenceLock.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false)
                    : null;
                try
                {
                    token.ThrowIfCancellationRequested();
                    IAsyncDisposable objLocker3 = null;
                    if (!blnAttributeSpecific)
                    {
                        if (_decCachedEssence != decimal.MinValue)
                            return _decCachedEssence;
                        objLocker3 = await _objCachedEssenceLock.EnterWriteLockAsync(token).ConfigureAwait(false);
                    }

                    try
                    {
                        token.ThrowIfCancellationRequested();
                        // If the character has a fixed Essence Improvement, permanently fix their Essence at its value.
                        if ((await ImprovementManager
                                   .GetCachedImprovementListForValueOfAsync(
                                       this, Improvement.ImprovementType.CyborgEssence, token: token)
                                   .ConfigureAwait(false)).Count
                            > 0)
                        {
                            if (!blnAttributeSpecific)
                                _decCachedEssence = 0.1m;
                            return 0.1m;
                        }

                        decimal decESS = await ESS.GetMetatypeMaximumAsync(token).ConfigureAwait(false) + decExtraEss;
                        decESS += await ImprovementManager
                                        .ValueOfAsync(this, Improvement.ImprovementType.EssencePenalty, token: token)
                                        .ConfigureAwait(false);
                        decESS += await ImprovementManager
                                        .ValueOfAsync(this, Improvement.ImprovementType.EssencePenaltyT100,
                                                      token: token).ConfigureAwait(false)
                                  / 100.0m;

                        // Run through all of the pieces of Cyberware and include their Essence cost.
                        decESS -= await Cyberware
                                        .SumAsync(objCyberware => objCyberware.GetCalculatedESSAsync(token),
                                                  token: token).ConfigureAwait(false);

                        //1781 Essence is not printing
                        //ESS.Base = Convert.ToInt32(decESS); -- Disabled because this messes up Character Validity, and it really shouldn't be what "Base" of an attribute is supposed to be (it's supposed to be extra levels gained)

                        if (!blnAttributeSpecific)
                            _decCachedEssence = decESS;
                        return decESS;
                    }
                    finally
                    {
                        if (objLocker3 != null)
                            await objLocker3.DisposeAsync().ConfigureAwait(false);
                    }
                }
                finally
                {
                    if (objLocker2 != null)
                        await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private decimal _decCachedCyberwareEssence = decimal.MinValue;

        /// <summary>
        /// Essence consumed by Cyberware.
        /// </summary>
        public decimal CyberwareEssence
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    decimal decReturn = _decCachedCyberwareEssence;
                    if (decReturn != decimal.MinValue)
                        return decReturn;
                    // Run through all of the pieces of Cyberware and include their Essence cost. Cyberware and Bioware costs are calculated separately.
                    return _decCachedCyberwareEssence = Cyberware
                        .Sum(objCyberware =>
                                 objCyberware.SourceType
                                 == Improvement.ImprovementSource.Cyberware
                                 && !objCyberware.SourceID.Equals(
                                     Backend.Equipment.Cyberware.EssenceHoleGUID)
                                 && !objCyberware.SourceID.Equals(
                                     Backend.Equipment.Cyberware.EssenceAntiHoleGUID),
                             objCyberware => objCyberware.CalculatedESS);
                }
            }
        }

        /// <summary>
        /// Essence consumed by Cyberware.
        /// </summary>
        public async Task<decimal> GetCyberwareEssenceAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                decimal decReturn = _decCachedCyberwareEssence;
                if (decReturn != decimal.MinValue)
                    return decReturn;
                // Run through all of the pieces of Cyberware and include their Essence cost. Cyberware and Bioware costs are calculated separately.
                return _decCachedCyberwareEssence = await Cyberware
                    .SumAsync(async objCyberware =>
                        {
                            if (await objCyberware.GetSourceTypeAsync(token).ConfigureAwait(false) !=
                                Improvement.ImprovementSource.Cyberware)
                                return false;
                            Guid guiSourceId = await objCyberware.GetSourceIDAsync(token).ConfigureAwait(false);
                            return !guiSourceId.Equals(Backend.Equipment.Cyberware.EssenceHoleGUID)
                                   && !guiSourceId.Equals(Backend.Equipment.Cyberware.EssenceAntiHoleGUID);
                        },
                        objCyberware => objCyberware.GetCalculatedESSAsync(token), token: token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private decimal _decCachedBiowareEssence = decimal.MinValue;

        /// <summary>
        /// Essence consumed by Bioware.
        /// </summary>
        public decimal BiowareEssence
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    decimal decReturn = _decCachedBiowareEssence;
                    if (decReturn != decimal.MinValue)
                        return decReturn;
                    // Run through all of the pieces of Cyberware and include their Essence cost. Cyberware and Bioware costs are calculated separately.
                    return _decCachedBiowareEssence = Cyberware
                        .Sum(objCyberware =>
                                 objCyberware.SourceType
                                 == Improvement.ImprovementSource.Bioware
                                 && !objCyberware.SourceID.Equals(
                                     Backend.Equipment.Cyberware.EssenceHoleGUID)
                                 && !objCyberware.SourceID.Equals(
                                     Backend.Equipment.Cyberware.EssenceAntiHoleGUID),
                             objCyberware => objCyberware.CalculatedESS);
                }
            }
        }

        /// <summary>
        /// Essence consumed by Bioware.
        /// </summary>
        public async Task<decimal> GetBiowareEssenceAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                decimal decReturn = _decCachedBiowareEssence;
                if (decReturn != decimal.MinValue)
                    return decReturn;
                // Run through all of the pieces of Cyberware and include their Essence cost. Cyberware and Bioware costs are calculated separately.
                return _decCachedBiowareEssence = await Cyberware
                    .SumAsync(async objCyberware =>
                        {
                            if (await objCyberware.GetSourceTypeAsync(token).ConfigureAwait(false) !=
                                Improvement.ImprovementSource.Bioware)
                                return false;
                            Guid guiSourceId = await objCyberware.GetSourceIDAsync(token).ConfigureAwait(false);
                            return !guiSourceId.Equals(Backend.Equipment.Cyberware.EssenceHoleGUID)
                                   && !guiSourceId.Equals(Backend.Equipment.Cyberware.EssenceAntiHoleGUID);
                        },
                        objCyberware => objCyberware.GetCalculatedESSAsync(token), token: token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private decimal _decCachedEssenceHole = decimal.MinValue;

        /// <summary>
        /// Essence consumed by Essence Holes.
        /// </summary>
        public decimal EssenceHole
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    decimal decReturn = _decCachedEssenceHole;
                    if (decReturn != decimal.MinValue)
                        return decReturn;
                    // Find the total Essence Cost of all Essence Hole objects.
                    return _decCachedEssenceHole = Cyberware
                        .Sum(objCyberware =>
                                 objCyberware.SourceID.Equals(
                                     Backend.Equipment.Cyberware.EssenceHoleGUID)
                                 || objCyberware.SourceID.Equals(
                                     Backend.Equipment.Cyberware.EssenceAntiHoleGUID),
                             objCyberware => objCyberware.CalculatedESS);
                }
            }
        }

        /// <summary>
        /// Essence consumed by Essence Holes.
        /// </summary>
        public async Task<decimal> GetEssenceHoleAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                decimal decReturn = _decCachedEssenceHole;
                if (decReturn != decimal.MinValue)
                    return decReturn;
                // Find the total Essence Cost of all Essence Hole objects.
                return _decCachedEssenceHole = await Cyberware
                    .SumAsync(async objCyberware =>
                    {
                        Guid guiSourceId = await objCyberware.GetSourceIDAsync(token).ConfigureAwait(false);
                        return guiSourceId.Equals(Backend.Equipment.Cyberware.EssenceHoleGUID)
                               || guiSourceId.Equals(Backend.Equipment.Cyberware.EssenceAntiHoleGUID);
                    }, objCyberware => objCyberware.GetCalculatedESSAsync(token), token: token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public void IncreaseEssenceHole(decimal decEssence, bool blnOverflowIntoHole = true)
        {
            IncreaseEssenceHole((decEssence * 100).StandardRound(), blnOverflowIntoHole);
        }

        public void IncreaseEssenceHole(int intCentiessence, bool blnOverflowIntoHole = true)
        {
            using (LockObject.EnterWriteLock())
            {
                Cyberware objAntiHole
                    = Cyberware.FirstOrDefault(x => x.SourceID == Backend.Equipment.Cyberware.EssenceAntiHoleGUID);
                if (objAntiHole != null)
                {
                    int intRating = objAntiHole.Rating;
                    if (intRating > intCentiessence)
                    {
                        objAntiHole.Rating = intRating - intCentiessence;
                        return;
                    }

                    intCentiessence -= intRating;
                    objAntiHole.DeleteCyberware();
                }

                if (blnOverflowIntoHole && intCentiessence != 0)
                {
                    Cyberware objHole
                        = Cyberware.FirstOrDefault(x => x.SourceID == Backend.Equipment.Cyberware.EssenceHoleGUID);
                    if (objHole == null)
                    {
                        XmlNode xmlEssHole = LoadData("cyberware.xml")
                            .TryGetNodeById("/chummer/cyberwares/cyberware",
                                            Backend.Equipment.Cyberware.EssenceHoleGUID);
                        List<Weapon> lstWeapons = new List<Weapon>(1);
                        List<Vehicle> lstVehicles = new List<Vehicle>(1);
                        objHole = new Cyberware(this);
                        try
                        {
                            objHole.Create(
                                xmlEssHole,
                                GetGradeByName(Improvement.ImprovementSource.Cyberware, "None", true),
                                Improvement.ImprovementSource.Cyberware,
                                intCentiessence, lstWeapons,
                                lstVehicles);

                            Cyberware.Add(objHole);

                            foreach (Weapon objWeapon in lstWeapons)
                            {
                                Weapons.Add(objWeapon);
                            }

                            foreach (Vehicle objVehicle in lstVehicles)
                            {
                                Vehicles.Add(objVehicle);
                            }
                        }
                        catch
                        {
                            objHole.DeleteCyberware();
                            throw;
                        }
                    }
                    else
                    {
                        objHole.Rating += intCentiessence;
                    }

                    if (objHole.Rating == 0 && Cyberware.Contains(objHole))
                        Cyberware.Remove(objHole);
                }

                if (objAntiHole?.Rating == 0 && Cyberware.Contains(objAntiHole))
                    Cyberware.Remove(objAntiHole);
            }
        }

        public Task IncreaseEssenceHoleAsync(decimal decEssence, bool blnOverflowIntoHole = true,
            CancellationToken token = default)
        {
            return IncreaseEssenceHoleAsync((decEssence * 100).StandardRound(), blnOverflowIntoHole, token);
        }

        public async Task IncreaseEssenceHoleAsync(int intCentiessence, bool blnOverflowIntoHole = true,
            CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                Cyberware objAntiHole
                    = await Cyberware
                        .FirstOrDefaultAsync(async x => await x.GetSourceIDAsync(token).ConfigureAwait(false) == Backend.Equipment.Cyberware.EssenceAntiHoleGUID, token)
                        .ConfigureAwait(false);
                if (objAntiHole != null)
                {
                    IAsyncDisposable objLocker2 = await objAntiHole.LockObject.EnterUpgradeableReadLockAsync(token)
                        .ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        int intRating = await objAntiHole.GetRatingAsync(token).ConfigureAwait(false);
                        if (intRating > intCentiessence)
                        {
                            await objAntiHole.SetRatingAsync(intRating - intCentiessence, token).ConfigureAwait(false);
                            return;
                        }

                        intCentiessence -= intRating;
                    }
                    finally
                    {
                        await objLocker2.DisposeAsync().ConfigureAwait(false);
                    }

                    await objAntiHole.DeleteCyberwareAsync(token: token).ConfigureAwait(false);
                }

                if (blnOverflowIntoHole && intCentiessence != 0)
                {
                    Cyberware objHole
                        = await Cyberware
                            .FirstOrDefaultAsync(async x => await x.GetSourceIDAsync(token).ConfigureAwait(false) == Backend.Equipment.Cyberware.EssenceHoleGUID, token)
                            .ConfigureAwait(false);
                    if (objHole == null)
                    {
                        XmlNode xmlEssHole = (await LoadDataAsync("cyberware.xml", token: token).ConfigureAwait(false))
                            .TryGetNodeById("/chummer/cyberwares/cyberware",
                                Backend.Equipment.Cyberware.EssenceHoleGUID);
                        List<Weapon> lstWeapons = new List<Weapon>(1);
                        List<Vehicle> lstVehicles = new List<Vehicle>(1);
                        objHole = new Cyberware(this);
                        try
                        {
                            await objHole.CreateAsync(
                                xmlEssHole,
                                await GetGradeByNameAsync(Improvement.ImprovementSource.Cyberware, "None", true, token).ConfigureAwait(false),
                                Improvement.ImprovementSource.Cyberware,
                                intCentiessence, lstWeapons,
                                lstVehicles, token: token).ConfigureAwait(false);

                            await Cyberware.AddAsync(objHole, token).ConfigureAwait(false);

                            foreach (Weapon objWeapon in lstWeapons)
                            {
                                await Weapons.AddAsync(objWeapon, token).ConfigureAwait(false);
                            }

                            foreach (Vehicle objVehicle in lstVehicles)
                            {
                                await Vehicles.AddAsync(objVehicle, token).ConfigureAwait(false);
                            }
                        }
                        catch
                        {
                            await objHole.DeleteCyberwareAsync(token: CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }
                    }
                    else
                    {
                        IAsyncDisposable objLocker2 = await objHole.LockObject.EnterUpgradeableReadLockAsync(token)
                            .ConfigureAwait(false);
                        try
                        {
                            token.ThrowIfCancellationRequested();
                            await objHole
                                .SetRatingAsync(
                                    await objHole.GetRatingAsync(token).ConfigureAwait(false) + intCentiessence, token)
                                .ConfigureAwait(false);
                        }
                        finally
                        {
                            await objLocker2.DisposeAsync().ConfigureAwait(false);
                        }
                    }

                    if (await objHole.GetRatingAsync(token).ConfigureAwait(false) == 0 &&
                        await Cyberware.ContainsAsync(objHole, token).ConfigureAwait(false))
                        await Cyberware.RemoveAsync(objHole, token).ConfigureAwait(false);
                }

                if (objAntiHole != null && await objAntiHole.GetRatingAsync(token).ConfigureAwait(false) == 0 &&
                    await Cyberware.ContainsAsync(objAntiHole, token).ConfigureAwait(false))
                    await Cyberware.RemoveAsync(objAntiHole, token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public void DecreaseEssenceHole(decimal decEssence, bool blnOverflowIntoHole = true)
        {
            DecreaseEssenceHole((decEssence * 100).StandardRound(), blnOverflowIntoHole);
        }

        public void DecreaseEssenceHole(int intCentiessence, bool blnOverflowIntoAntiHole = true)
        {
            using (LockObject.EnterWriteLock())
            {
                Cyberware objHole
                    = Cyberware.FirstOrDefault(x => x.SourceID == Backend.Equipment.Cyberware.EssenceHoleGUID);

                if (objHole != null)
                {
                    int intRating = objHole.Rating;
                    if (intRating > intCentiessence)
                    {
                        objHole.Rating = intRating - intCentiessence;
                        return;
                    }

                    intCentiessence -= intRating;
                    objHole.DeleteCyberware();
                }

                if (blnOverflowIntoAntiHole && intCentiessence != 0)
                {
                    Cyberware objAntiHole
                        = Cyberware.FirstOrDefault(x => x.SourceID == Backend.Equipment.Cyberware.EssenceAntiHoleGUID);
                    if (objAntiHole == null)
                    {
                        XmlNode xmlEssAntiHole = LoadData("cyberware.xml")
                            .TryGetNodeById("/chummer/cyberwares/cyberware",
                                            Backend.Equipment.Cyberware.EssenceAntiHoleGUID);
                        List<Weapon> lstWeapons = new List<Weapon>(1);
                        List<Vehicle> lstVehicles = new List<Vehicle>(1);
                        objAntiHole = new Cyberware(this);
                        try
                        {
                            objAntiHole.Create(xmlEssAntiHole,
                                               GetGradeByName(Improvement.ImprovementSource.Cyberware, "None", true),
                                               Improvement.ImprovementSource.Cyberware, intCentiessence, lstWeapons,
                                               lstVehicles);

                            Cyberware.Add(objAntiHole);

                            foreach (Weapon objWeapon in lstWeapons)
                            {
                                Weapons.Add(objWeapon);
                            }

                            foreach (Vehicle objVehicle in lstVehicles)
                            {
                                Vehicles.Add(objVehicle);
                            }
                        }
                        catch
                        {
                            objAntiHole.DeleteCyberware();
                            throw;
                        }
                    }
                    else
                    {
                        objAntiHole.Rating += intCentiessence;
                    }

                    if (objAntiHole.Rating == 0 && Cyberware.Contains(objAntiHole))
                        Cyberware.Remove(objAntiHole);
                }

                if (objHole?.Rating == 0 && Cyberware.Contains(objHole))
                    Cyberware.Remove(objHole);
            }
        }

        public Task DecreaseEssenceHoleAsync(decimal decEssence, bool blnOverflowIntoHole = true,
            CancellationToken token = default)
        {
            return DecreaseEssenceHoleAsync((decEssence * 100).StandardRound(), blnOverflowIntoHole, token);
        }

        public async Task DecreaseEssenceHoleAsync(int intCentiessence, bool blnOverflowIntoAntiHole = true,
            CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                Cyberware objHole
                    = await Cyberware.FirstOrDefaultAsync(
                        async x => await x.GetSourceIDAsync(token).ConfigureAwait(false) == Backend.Equipment.Cyberware.EssenceHoleGUID, token).ConfigureAwait(false);

                if (objHole != null)
                {
                    IAsyncDisposable objLocker2 =
                        await objHole.LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        int intRating = await objHole.GetRatingAsync(token).ConfigureAwait(false);
                        if (intRating > intCentiessence)
                        {
                            await objHole.SetRatingAsync(intRating - intCentiessence, token).ConfigureAwait(false);
                            return;
                        }

                        intCentiessence -= intRating;
                    }
                    finally
                    {
                        await objLocker2.DisposeAsync().ConfigureAwait(false);
                    }

                    await objHole.DeleteCyberwareAsync(token: token).ConfigureAwait(false);
                }

                if (blnOverflowIntoAntiHole && intCentiessence != 0)
                {
                    Cyberware objAntiHole
                        = await Cyberware.FirstOrDefaultAsync(
                                async x => await x.GetSourceIDAsync(token).ConfigureAwait(false) == Backend.Equipment.Cyberware.EssenceAntiHoleGUID, token)
                            .ConfigureAwait(false);
                    if (objAntiHole == null)
                    {
                        XmlNode xmlEssAntiHole =
                            (await LoadDataAsync("cyberware.xml", token: token).ConfigureAwait(false))
                            .TryGetNodeById("/chummer/cyberwares/cyberware",
                                Backend.Equipment.Cyberware.EssenceAntiHoleGUID);
                        List<Weapon> lstWeapons = new List<Weapon>(1);
                        List<Vehicle> lstVehicles = new List<Vehicle>(1);
                        objAntiHole = new Cyberware(this);
                        try
                        {
                            await objAntiHole.CreateAsync(xmlEssAntiHole,
                                await GetGradeByNameAsync(Improvement.ImprovementSource.Cyberware, "None", true, token).ConfigureAwait(false),
                                Improvement.ImprovementSource.Cyberware, intCentiessence, lstWeapons,
                                lstVehicles, token: token).ConfigureAwait(false);

                            await Cyberware.AddAsync(objAntiHole, token).ConfigureAwait(false);

                            foreach (Weapon objWeapon in lstWeapons)
                            {
                                await Weapons.AddAsync(objWeapon, token).ConfigureAwait(false);
                            }

                            foreach (Vehicle objVehicle in lstVehicles)
                            {
                                await Vehicles.AddAsync(objVehicle, token).ConfigureAwait(false);
                            }
                        }
                        catch
                        {
                            await objAntiHole.DeleteCyberwareAsync(token: CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }
                    }
                    else
                    {
                        IAsyncDisposable objLocker2 = await objAntiHole.LockObject.EnterUpgradeableReadLockAsync(token)
                            .ConfigureAwait(false);
                        try
                        {
                            token.ThrowIfCancellationRequested();
                            await objAntiHole
                                .SetRatingAsync(
                                    await objAntiHole.GetRatingAsync(token).ConfigureAwait(false) + intCentiessence,
                                    token).ConfigureAwait(false);
                        }
                        finally
                        {
                            await objLocker2.DisposeAsync().ConfigureAwait(false);
                        }
                    }

                    if (await objAntiHole.GetRatingAsync(token).ConfigureAwait(false) == 0 &&
                        await Cyberware.ContainsAsync(objAntiHole, token).ConfigureAwait(false))
                        await Cyberware.RemoveAsync(objAntiHole, token).ConfigureAwait(false);
                }

                if (objHole != null && await objHole.GetRatingAsync(token).ConfigureAwait(false) == 0 &&
                    await Cyberware.ContainsAsync(objHole, token).ConfigureAwait(false))
                    await Cyberware.RemoveAsync(objHole, token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private decimal _decCachedPrototypeTranshumanEssenceUsed = decimal.MinValue;

        /// <summary>
        /// Essence consumed by Prototype Transhuman 'ware
        /// </summary>
        public decimal PrototypeTranshumanEssenceUsed
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    decimal decReturn = _decCachedPrototypeTranshumanEssenceUsed;
                    if (decReturn != decimal.MinValue)
                        return decReturn;
                    // Find the total Essence Cost of all Prototype Transhuman 'ware.
                    if (!IsPrototypeTranshuman)
                        return _decCachedPrototypeTranshumanEssenceUsed = 0.0m;
                    return _decCachedPrototypeTranshumanEssenceUsed = Cyberware
                        .Sum(objCyberware => objCyberware.PrototypeTranshuman,
                             objCyberware => objCyberware.CalculatedESSPrototypeInvariant);
                }
            }
        }

        /// <summary>
        /// Essence consumed by Prototype Transhuman 'ware
        /// </summary>
        public async Task<decimal> GetPrototypeTranshumanEssenceUsedAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                decimal decReturn = _decCachedPrototypeTranshumanEssenceUsed;
                if (decReturn != decimal.MinValue)
                    return decReturn;
                // Find the total Essence Cost of all Prototype Transhuman 'ware.
                if (!await GetIsPrototypeTranshumanAsync(token).ConfigureAwait(false))
                    return _decCachedPrototypeTranshumanEssenceUsed = 0.0m;
                return _decCachedPrototypeTranshumanEssenceUsed = await Cyberware
                    .SumAsync(objCyberware => objCyberware.GetPrototypeTranshumanAsync(token),
                        objCyberware => objCyberware.GetCalculatedESSPrototypeInvariantAsync(token), token: token)
                    .ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplayEssence
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return Essence().ToString(Settings.EssenceFormat, GlobalSettings.CultureInfo);
            }
        }

        public async Task<string> GetDisplayEssenceAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return (await EssenceAsync(token: token).ConfigureAwait(false))
                    .ToString(await (await GetSettingsAsync(token).ConfigureAwait(false)).GetEssenceFormatAsync(token).ConfigureAwait(false), GlobalSettings.CultureInfo);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// This is only here for Reflection
        /// </summary>
        [HubTag("Essence")]
        public decimal EssenceDecimal => Essence();

        public string DisplayCyberwareEssence
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return CyberwareEssence.ToString(Settings.EssenceFormat, GlobalSettings.CultureInfo);
            }
        }

        public async Task<string> GetDisplayCyberwareEssenceAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return (await GetCyberwareEssenceAsync(token).ConfigureAwait(false)).ToString(
                    await (await GetSettingsAsync(token).ConfigureAwait(false)).GetEssenceFormatAsync(token).ConfigureAwait(false), GlobalSettings.CultureInfo);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplayBiowareEssence
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return BiowareEssence.ToString(Settings.EssenceFormat, GlobalSettings.CultureInfo);
            }
        }

        public async Task<string> GetDisplayBiowareEssenceAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return (await GetBiowareEssenceAsync(token).ConfigureAwait(false)).ToString(
                    await (await GetSettingsAsync(token).ConfigureAwait(false)).GetEssenceFormatAsync(token).ConfigureAwait(false), GlobalSettings.CultureInfo);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplayEssenceHole
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return EssenceHole.ToString(Settings.EssenceFormat, GlobalSettings.CultureInfo);
            }
        }

        public async Task<string> GetDisplayEssenceHoleAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return (await GetEssenceHoleAsync(token).ConfigureAwait(false)).ToString(
                    await (await GetSettingsAsync(token).ConfigureAwait(false)).GetEssenceFormatAsync(token).ConfigureAwait(false), GlobalSettings.CultureInfo);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplayPrototypeTranshumanEssenceUsed
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (LockObject.EnterReadLock())
                {
                    string strEssenceFormat = Settings.EssenceFormat;
                    return PrototypeTranshumanEssenceUsed.ToString(strEssenceFormat, GlobalSettings.CultureInfo)
                           + strSpace + "/" + strSpace +
                           PrototypeTranshuman.ToString(strEssenceFormat, GlobalSettings.CultureInfo);
                }
            }
        }

        public async Task<string> GetDisplayPrototypeTranshumanEssenceUsedAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                string strEssenceFormat = await (await GetSettingsAsync(token).ConfigureAwait(false)).GetEssenceFormatAsync(token).ConfigureAwait(false);
                return (await GetPrototypeTranshumanEssenceUsedAsync(token).ConfigureAwait(false)).ToString(
                           strEssenceFormat, GlobalSettings.CultureInfo) +
                       strSpace + "/" + strSpace +
                       (await GetPrototypeTranshumanAsync(token).ConfigureAwait(false)).ToString(
                           strEssenceFormat, GlobalSettings.CultureInfo);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        #region Initiative

        #region Physical

        /// <summary>
        /// Physical Initiative.
        /// </summary>
        public string Initiative => GetInitiative(GlobalSettings.CultureInfo, GlobalSettings.Language);

        public Task<string> GetInitiativeAsync(CancellationToken token = default) =>
            GetInitiativeAsync(GlobalSettings.CultureInfo, GlobalSettings.Language, token);

        public string GetInitiative(CultureInfo objCulture, string strLanguage)
        {
            using (LockObject.EnterReadLock())
                return string.Format(objCulture, LanguageManager.GetString("String_Initiative", strLanguage),
                                     InitiativeValue.ToString(objCulture),
                                     InitiativeDice.ToString(objCulture));
        }

        public async Task<string> GetInitiativeAsync(CultureInfo objCulture, string strLanguage, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return string.Format(objCulture, await LanguageManager.GetStringAsync("String_Initiative", strLanguage, token: token).ConfigureAwait(false),
                    (await GetInitiativeValueAsync(token).ConfigureAwait(false)).ToString(objCulture),
                    (await GetInitiativeDiceAsync(token).ConfigureAwait(false)).ToString(objCulture));
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string InitiativeToolTip
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    int intREAAttributeModifiers = REA.AttributeModifiers;
                    int intINTAttributeModifiers = INT.AttributeModifiers;
                    string strSpace = LanguageManager.GetString("String_Space");

                    string strInit = REA.CurrentDisplayAbbrev + strSpace + "(" + REA.Value.ToString(GlobalSettings.CultureInfo)
                                     + ")"
                                     + strSpace + "+" + strSpace + INT.CurrentDisplayAbbrev + strSpace + "("
                                     + INT.Value.ToString(GlobalSettings.CultureInfo) + ")";
                    if (ImprovementManager.ValueOf(this, Improvement.ImprovementType.Initiative) != 0
                        || intINTAttributeModifiers != 0 || intREAAttributeModifiers != 0 || WoundModifier != 0)
                    {
                        strInit += strSpace + "+" + strSpace + LanguageManager.GetString("Tip_Modifiers") + strSpace
                                   + "("
                                   + (ImprovementManager.ValueOf(this, Improvement.ImprovementType.Initiative)
                                      + intINTAttributeModifiers + intREAAttributeModifiers + WoundModifier)
                                   .ToString(GlobalSettings.CultureInfo) + ")";
                    }

                    return string.Format(GlobalSettings.CultureInfo, LanguageManager.GetString("String_Initiative"),
                                         strInit, InitiativeDice.ToString(GlobalSettings.CultureInfo));
                }
            }
        }

        public async Task<string> GetInitiativeToolTipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                CharacterAttrib objRea = await GetAttributeAsync("REA", token: token).ConfigureAwait(false);
                CharacterAttrib objInt = await GetAttributeAsync("INT", token: token).ConfigureAwait(false);
                int intREAAttributeModifiers = await objRea.GetAttributeModifiersAsync(token).ConfigureAwait(false);
                int intINTAttributeModifiers = await objInt.GetAttributeModifiersAsync(token).ConfigureAwait(false);
                string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token)
                    .ConfigureAwait(false);
                string strInit =
                    await objRea.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false) +
                    strSpace + "(" +
                    (await objRea.GetValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo) +
                    ")" + strSpace + "+" + strSpace +
                    await objInt.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false) +
                    strSpace + "(" +
                    (await objInt.GetValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo) +
                    ")";
                decimal decFromImprovements = await ImprovementManager
                    .ValueOfAsync(this, Improvement.ImprovementType.Initiative, token: token).ConfigureAwait(false);
                int intWoundModifier = await GetWoundModifierAsync(token).ConfigureAwait(false);
                if (decFromImprovements != 0 || intINTAttributeModifiers != 0 || intREAAttributeModifiers != 0 ||
                    intWoundModifier != 0)
                {
                    strInit += strSpace + "+" + strSpace +
                               await LanguageManager.GetStringAsync("Tip_Modifiers", token: token)
                                   .ConfigureAwait(false) + strSpace + "(" +
                               (decFromImprovements + intINTAttributeModifiers + intREAAttributeModifiers +
                                intWoundModifier)
                               .ToString(GlobalSettings.CultureInfo) + ")";
                }

                return string.Format(GlobalSettings.CultureInfo,
                    await LanguageManager.GetStringAsync("String_Initiative", token: token).ConfigureAwait(false),
                    strInit, (await GetInitiativeDiceAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo));
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Initiative Dice.
        /// </summary>
        [HubTag]
        public int InitiativeDice
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    int intExtraIP = _intInitiativeDice
                                     + ImprovementManager.ValueOf(this, Improvement.ImprovementType.InitiativeDice)
                                                         .StandardRound()
                                     + ImprovementManager.ValueOf(this, Improvement.ImprovementType.InitiativeDiceAdd)
                                                         .StandardRound();

                    return Math.Min(intExtraIP, Settings.MaxInitiativeDice);
                }
            }
        }

        /// <summary>
        /// Initiative Dice.
        /// </summary>
        public async Task<int> GetInitiativeDiceAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intExtraIP = _intInitiativeDice +
                                 (await ImprovementManager.ValueOfAsync(this,
                                     Improvement.ImprovementType.InitiativeDice, token: token).ConfigureAwait(false))
                                 .StandardRound() +
                                 (await ImprovementManager.ValueOfAsync(this,
                                     Improvement.ImprovementType.InitiativeDiceAdd, token: token).ConfigureAwait(false))
                                 .StandardRound();
                return Math.Min(intExtraIP,
                    await (await GetSettingsAsync(token).ConfigureAwait(false)).GetMaxInitiativeDiceAsync(token)
                        .ConfigureAwait(false));
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        [HubTag]
        public int InitiativeValue
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (INT == null || REA == null)
                    {
                        Utils.BreakIfDebug();
                        return 0;
                    }

                    int intINI = INT.TotalValue + REA.TotalValue + WoundModifier + ImprovementManager
                        .ValueOf(this, Improvement.ImprovementType.Initiative).StandardRound();
                    return Math.Max(intINI, 0);
                }
            }
        }

        /// <summary>
        /// Initiative Dice.
        /// </summary>
        public async Task<int> GetInitiativeValueAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                CharacterAttrib objRea = await GetAttributeAsync("REA", token: token).ConfigureAwait(false);
                CharacterAttrib objInt = await GetAttributeAsync("INT", token: token).ConfigureAwait(false);
                if (objInt == null || objRea == null)
                {
                    Utils.BreakIfDebug();
                    return 0;
                }

                int intINI = await objInt.GetTotalValueAsync(token).ConfigureAwait(false) +
                             await objRea.GetTotalValueAsync(token).ConfigureAwait(false) +
                             await GetWoundModifierAsync(token).ConfigureAwait(false) + (await ImprovementManager
                                 .ValueOfAsync(this, Improvement.ImprovementType.Initiative, token: token)
                                 .ConfigureAwait(false))
                             .StandardRound();
                return Math.Max(intINI, 0);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        #endregion Physical

        #region Astral

        /// <summary>
        /// Astral Initiative.
        /// </summary>
        public string AstralInitiative => GetAstralInitiative(GlobalSettings.CultureInfo, GlobalSettings.Language);

        public Task<string> GetAstralInitiativeAsync(CancellationToken token = default) =>
            GetAstralInitiativeAsync(GlobalSettings.CultureInfo, GlobalSettings.Language, token);

        public string GetAstralInitiative(CultureInfo objCulture, string strLanguageToPrint)
        {
            using (LockObject.EnterReadLock())
                return string.Format(objCulture, LanguageManager.GetString("String_Initiative", strLanguageToPrint),
                                     AstralInitiativeValue.ToString(objCulture),
                                     AstralInitiativeDice.ToString(objCulture));
        }

        public async Task<string> GetAstralInitiativeAsync(CultureInfo objCulture, string strLanguage, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return string.Format(objCulture, await LanguageManager.GetStringAsync("String_Initiative", strLanguage, token: token).ConfigureAwait(false),
                    (await GetAstralInitiativeValueAsync(token).ConfigureAwait(false)).ToString(objCulture),
                    (await GetAstralInitiativeDiceAsync(token).ConfigureAwait(false)).ToString(objCulture));
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string AstralInitiativeToolTip
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (!MAGEnabled)
                        return string.Empty;
                    int intINTAttributeModifiers = INT.AttributeModifiers;
                    string strSpace = LanguageManager.GetString("String_Space");
                    string strInit = INT.CurrentDisplayAbbrev + strSpace + "(" + INT.Value.ToString(GlobalSettings.CultureInfo)
                                     + ")" + strSpace + "×" + strSpace + 2.ToString(GlobalSettings.CultureInfo);
                    if (intINTAttributeModifiers != 0 || WoundModifier != 0)
                        strInit += LanguageManager.GetString("Tip_Modifiers") + strSpace + "("
                                   + (intINTAttributeModifiers + WoundModifier).ToString(GlobalSettings.CultureInfo)
                                   + ")";
                    return string.Format(GlobalSettings.CultureInfo, LanguageManager.GetString("String_Initiative"),
                                         strInit, AstralInitiativeDice.ToString(GlobalSettings.CultureInfo));
                }
            }
        }

        public async Task<string> GetAstralInitiativeToolTipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                CharacterAttrib objInt = await GetAttributeAsync("INT", token: token).ConfigureAwait(false);
                int intINTAttributeModifiers = await objInt.GetAttributeModifiersAsync(token).ConfigureAwait(false);
                string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token)
                    .ConfigureAwait(false);
                string strInit =
                    await objInt.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false) +
                    strSpace + "(" +
                    (await objInt.GetValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo) +
                    ")" + strSpace + "×" + strSpace + 2.ToString(GlobalSettings.CultureInfo);

                int intWoundModifier = await GetWoundModifierAsync(token).ConfigureAwait(false);
                if (intINTAttributeModifiers != 0 || intWoundModifier != 0)
                {
                    strInit += strSpace + "+" + strSpace +
                               await LanguageManager.GetStringAsync("Tip_Modifiers", token: token)
                                   .ConfigureAwait(false) + strSpace + "(" +
                               (intINTAttributeModifiers + intWoundModifier).ToString(GlobalSettings.CultureInfo) + ")";
                }

                return string.Format(GlobalSettings.CultureInfo,
                    await LanguageManager.GetStringAsync("String_Initiative", token: token).ConfigureAwait(false),
                    strInit,
                    (await GetAstralInitiativeDiceAsync(token).ConfigureAwait(false)).ToString(GlobalSettings
                        .CultureInfo));
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Astral Initiative Value.
        /// </summary>
        public int AstralInitiativeValue
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return INT.TotalValue * 2 + WoundModifier;
            }
        }

        /// <summary>
        /// Astral Initiative Value.
        /// </summary>
        public async Task<int> GetAstralInitiativeValueAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await (await GetAttributeAsync("INT", token: token).ConfigureAwait(false))
                           .GetTotalValueAsync(token).ConfigureAwait(false) * 2 +
                       await GetWoundModifierAsync(token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Astral Initiative Dice.
        /// </summary>
        public int AstralInitiativeDice
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return Math.Min(Settings.MinAstralInitiativeDice, Settings.MaxAstralInitiativeDice);
            }
        }

        /// <summary>
        /// Astral Initiative Dice.
        /// </summary>
        public async Task<int> GetAstralInitiativeDiceAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                CharacterSettings objSettings = await GetSettingsAsync(token).ConfigureAwait(false);
                return Math.Min(await objSettings.GetMinAstralInitiativeDiceAsync(token).ConfigureAwait(false),
                    await objSettings.GetMaxAstralInitiativeDiceAsync(token).ConfigureAwait(false));
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        #endregion Astral

        #region Matrix

        #region AR

        /// <summary>
        /// Formatted AR Matrix Initiative.
        /// </summary>
        public string MatrixInitiative => GetMatrixInitiative(GlobalSettings.CultureInfo, GlobalSettings.Language);

        /// <summary>
        /// Formatted AR Matrix Initiative.
        /// </summary>
        public Task<string> GetMatrixInitiativeAsync(CancellationToken token = default) =>
            GetMatrixInitiativeAsync(GlobalSettings.CultureInfo, GlobalSettings.Language, token);

        public string GetMatrixInitiative(CultureInfo objCulture, string strLanguageToPrint)
        {
            using (LockObject.EnterReadLock())
                return string.Format(objCulture, LanguageManager.GetString("String_Initiative", strLanguageToPrint),
                                     MatrixInitiativeValue, MatrixInitiativeDice);
        }

        public async Task<string> GetMatrixInitiativeAsync(CultureInfo objCulture, string strLanguageToPrint,
            CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return string.Format(objCulture,
                    await LanguageManager.GetStringAsync("String_Initiative", strLanguageToPrint, token: token)
                        .ConfigureAwait(false),
                    await GetMatrixInitiativeValueAsync(token).ConfigureAwait(false),
                    await GetMatrixInitiativeDiceAsync(token).ConfigureAwait(false));
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string MatrixInitiativeToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (LockObject.EnterReadLock())
                {
                    int intINTAttributeModifiers = INT.AttributeModifiers;

                    string strInit;
                    if (IsAI)
                    {
                        strInit = INT.CurrentDisplayAbbrev + strSpace + "(" + INT.Value.ToString(GlobalSettings.CultureInfo)
                                  + ")";

                        if (HomeNode != null)
                        {
                            int intHomeNodeDP = HomeNode.GetTotalMatrixAttribute("Data Processing");
                            if (HomeNode is Vehicle objHomeNodeVehicle)
                            {
                                int intHomeNodePilot = objHomeNodeVehicle.Pilot;
                                if (intHomeNodePilot > intHomeNodeDP)
                                    intHomeNodeDP = intHomeNodePilot;
                            }

                            strInit += strSpace + "+" + strSpace + LanguageManager.GetString("String_DataProcessing") +
                                       strSpace + "(" + intHomeNodeDP.ToString(GlobalSettings.CultureInfo) + ")";
                        }

                        if (intINTAttributeModifiers != 0 || WoundModifier != 0)
                        {
                            strInit += strSpace + "+" + strSpace + LanguageManager.GetString("Tip_Modifiers") + strSpace
                                       +
                                       "(" +
                                       (intINTAttributeModifiers + WoundModifier).ToString(GlobalSettings.CultureInfo)
                                       + ")";
                        }
                    }
                    else
                    {
                        int intREAAttributeModifiers = REA.AttributeModifiers;

                        strInit = REA.CurrentDisplayAbbrev + strSpace + "(" + REA.Value.ToString(GlobalSettings.CultureInfo)
                                  + ")" +
                                  strSpace + "+" + strSpace + INT.CurrentDisplayAbbrev + strSpace + "(" +
                                  INT.Value.ToString(GlobalSettings.CultureInfo) + ")";
                        if (ImprovementManager.ValueOf(this, Improvement.ImprovementType.Initiative) != 0
                            || intINTAttributeModifiers != 0 || intREAAttributeModifiers != 0 || WoundModifier != 0)
                        {
                            strInit += strSpace + "+" + strSpace + LanguageManager.GetString("Tip_Modifiers") + strSpace
                                       +
                                       "(" + (ImprovementManager.ValueOf(this, Improvement.ImprovementType.Initiative) +
                                              intINTAttributeModifiers + intREAAttributeModifiers + WoundModifier)
                                       .ToString(GlobalSettings.CultureInfo) + ")";
                        }
                    }

                    return string.Format(GlobalSettings.CultureInfo, LanguageManager.GetString("String_Initiative"),
                                         strInit, MatrixInitiativeDice);
                }
            }
        }

        public async Task<string> GetMatrixInitiativeToolTipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                CharacterAttrib objInt = await GetAttributeAsync("INT", token: token).ConfigureAwait(false);
                int intINTAttributeModifiers = await objInt.GetAttributeModifiersAsync(token).ConfigureAwait(false);

                string strInit;
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    strInit = await objInt.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false) + strSpace + "(" + (await objInt.GetValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo) + ")";

                    IHasMatrixAttributes objHomeNode = await GetHomeNodeAsync(token).ConfigureAwait(false);
                    if (objHomeNode != null)
                    {
                        int intHomeNodeDP = await objHomeNode.GetTotalMatrixAttributeAsync("Data Processing", token).ConfigureAwait(false);
                        if (HomeNode is Vehicle objHomeNodeVehicle)
                        {
                            int intHomeNodePilot = await objHomeNodeVehicle.GetPilotAsync(token).ConfigureAwait(false);
                            if (intHomeNodePilot > intHomeNodeDP)
                                intHomeNodeDP = intHomeNodePilot;
                        }

                        strInit += strSpace + "+" + strSpace + await LanguageManager.GetStringAsync("String_DataProcessing", token: token).ConfigureAwait(false) + strSpace + "(" + intHomeNodeDP.ToString(GlobalSettings.CultureInfo) + ")";
                    }

                    int intWoundModifier = await GetWoundModifierAsync(token).ConfigureAwait(false);
                    if (intINTAttributeModifiers != 0 || intWoundModifier != 0)
                    {
                        strInit += strSpace + "+" + strSpace + await LanguageManager.GetStringAsync("Tip_Modifiers", token: token).ConfigureAwait(false) + strSpace + "(" + (intINTAttributeModifiers + intWoundModifier).ToString(GlobalSettings.CultureInfo) + ")";
                    }
                }
                else
                {
                    CharacterAttrib objRea = await GetAttributeAsync("REA", token: token).ConfigureAwait(false);
                    int intREAAttributeModifiers = await objRea.GetAttributeModifiersAsync(token).ConfigureAwait(false);

                    strInit = await objRea.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false) + strSpace + "(" + (await objRea.GetValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo) + ")" + strSpace + "+" + strSpace + await objInt.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false) + strSpace + "(" + (await objInt.GetValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo) + ")";
                    decimal decFromImprovements = await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.Initiative, token: token).ConfigureAwait(false);
                    int intWoundModifier = await GetWoundModifierAsync(token).ConfigureAwait(false);
                    if (decFromImprovements != 0 || intINTAttributeModifiers != 0 || intREAAttributeModifiers != 0 || intWoundModifier != 0)
                    {
                        strInit += strSpace + "+" + strSpace + await LanguageManager.GetStringAsync("Tip_Modifiers", token: token).ConfigureAwait(false) + strSpace + "(" + (decFromImprovements + intINTAttributeModifiers + intREAAttributeModifiers + intWoundModifier).ToString(GlobalSettings.CultureInfo) + ")";
                    }
                }

                return string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("String_Initiative", token: token).ConfigureAwait(false), strInit, await GetMatrixInitiativeDiceAsync(token).ConfigureAwait(false));
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// AR Matrix Initiative Value.
        /// </summary>
        public int MatrixInitiativeValue
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (IsAI)
                    {
                        int intINI = INT.TotalValue + WoundModifier;
                        if (HomeNode != null)
                        {
                            int intHomeNodeDP = HomeNode.GetTotalMatrixAttribute("Data Processing");
                            if (HomeNode is Vehicle objHomeNodeVehicle)
                            {
                                int intHomeNodePilot = objHomeNodeVehicle.Pilot;
                                if (intHomeNodePilot > intHomeNodeDP)
                                    intHomeNodeDP = intHomeNodePilot;
                            }

                            intINI += intHomeNodeDP;
                        }

                        return intINI;
                    }

                    return InitiativeValue;
                }
            }
        }

        /// <summary>
        /// AR Matrix Initiative Value.
        /// </summary>
        public async Task<int> GetMatrixInitiativeValueAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    int intINI =
                        await (await GetAttributeAsync("INT", token: token).ConfigureAwait(false))
                            .GetTotalValueAsync(token).ConfigureAwait(false) +
                        await GetWoundModifierAsync(token).ConfigureAwait(false);
                    IHasMatrixAttributes objHomeNode = await GetHomeNodeAsync(token).ConfigureAwait(false);
                    if (objHomeNode != null)
                    {
                        int intHomeNodeDP = await objHomeNode.GetTotalMatrixAttributeAsync("Data Processing", token)
                            .ConfigureAwait(false);
                        if (objHomeNode is Vehicle objHomeNodeVehicle)
                        {
                            int intHomeNodePilot = await objHomeNodeVehicle.GetPilotAsync(token).ConfigureAwait(false);
                            if (intHomeNodePilot > intHomeNodeDP)
                                intHomeNodeDP = intHomeNodePilot;
                        }

                        intINI += intHomeNodeDP;
                    }

                    return intINI;
                }

                return await GetInitiativeValueAsync(token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// AR Matrix Initiative Dice.
        /// </summary>
        public int MatrixInitiativeDice
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    int intReturn;
                    // A.I.s always have 4 Matrix Initiative Dice.
                    if (IsAI)
                        intReturn = Settings.MinHotSimInitiativeDice + ImprovementManager
                                                                       .ValueOf(
                                                                           this,
                                                                           Improvement.ImprovementType
                                                                               .MatrixInitiativeDice).StandardRound();
                    else
                        intReturn = InitiativeDice;

                    // Add in any additional Matrix Initiative Pass bonuses.
                    intReturn += ImprovementManager.ValueOf(this, Improvement.ImprovementType.MatrixInitiativeDiceAdd)
                                                   .StandardRound();

                    return Math.Min(intReturn, Settings.MaxInitiativeDice);
                }
            }
        }

        /// <summary>
        /// AR Matrix Initiative Dice.
        /// </summary>
        public async Task<int> GetMatrixInitiativeDiceAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intReturn;
                // A.I.s always have 4 Matrix Initiative Dice.
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                    intReturn =
                        await (await GetSettingsAsync(token).ConfigureAwait(false))
                            .GetMinHotSimInitiativeDiceAsync(token).ConfigureAwait(false) +
                        (await ImprovementManager
                            .ValueOfAsync(this, Improvement.ImprovementType.MatrixInitiativeDice, token: token)
                            .ConfigureAwait(false)).StandardRound();
                else
                    intReturn = await GetInitiativeDiceAsync(token).ConfigureAwait(false);

                // Add in any additional Matrix Initiative Pass bonuses.
                intReturn +=
                    (await ImprovementManager
                        .ValueOfAsync(this, Improvement.ImprovementType.MatrixInitiativeDiceAdd, token: token)
                        .ConfigureAwait(false)).StandardRound();

                return Math.Min(intReturn,
                    await (await GetSettingsAsync(token).ConfigureAwait(false)).GetMaxInitiativeDiceAsync(token)
                        .ConfigureAwait(false));
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        #endregion AR

        #region Cold Sim

        /// <summary>
        /// Matrix Initiative via VR with Cold Sim.
        /// </summary>
        public string MatrixInitiativeCold => GetMatrixInitiativeCold(GlobalSettings.CultureInfo, GlobalSettings.Language);

        /// <summary>
        /// Matrix Initiative via VR with Cold Sim.
        /// </summary>
        public Task<string> GetMatrixInitiativeColdAsync(CancellationToken token = default) =>
            GetMatrixInitiativeColdAsync(GlobalSettings.CultureInfo, GlobalSettings.Language, token);

        public string GetMatrixInitiativeCold(CultureInfo objCulture, string strLanguageToPrint)
        {
            using (LockObject.EnterReadLock())
            {
                if (IsAI)
                {
                    return GetMatrixInitiative(objCulture, strLanguageToPrint);
                }

                return string.Format(
                    objCulture,
                    LanguageManager.GetString(ActiveCommlink == null ? "String_MatrixInitiative" : "String_Initiative",
                                              strLanguageToPrint),
                    MatrixInitiativeColdValue, MatrixInitiativeColdDice);
            }
        }

        public async Task<string> GetMatrixInitiativeColdAsync(CultureInfo objCulture, string strLanguageToPrint,
            CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    return await GetMatrixInitiativeAsync(objCulture, strLanguageToPrint, token).ConfigureAwait(false);
                }

                return string.Format(objCulture,
                    await LanguageManager
                        .GetStringAsync(
                            await GetActiveCommlinkAsync(token).ConfigureAwait(false) == null
                                ? "String_MatrixInitiative"
                                : "String_Initiative", strLanguageToPrint, token: token)
                        .ConfigureAwait(false),
                    await GetMatrixInitiativeColdValueAsync(token).ConfigureAwait(false),
                    await GetMatrixInitiativeColdDiceAsync(token).ConfigureAwait(false));
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string MatrixInitiativeColdToolTip
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (IsAI)
                    {
                        return MatrixInitiativeToolTip;
                    }

                    int intINTAttributeModifiers = INT.AttributeModifiers;

                    string strSpace = LanguageManager.GetString("String_Space");

                    string strInit = INT.CurrentDisplayAbbrev + strSpace + "(" + INT.Value.ToString(GlobalSettings.CultureInfo)
                                     + ")";
                    if (ActiveCommlink != null)
                    {
                        strInit += strSpace + "+" + strSpace + LanguageManager.GetString("String_DataProcessing") +
                                   strSpace + "(" + ActiveCommlink.GetTotalMatrixAttribute("Data Processing")
                                                                  .ToString(GlobalSettings.CultureInfo) + ")";
                    }

                    if (ImprovementManager.ValueOf(this, Improvement.ImprovementType.MatrixInitiative) != 0
                        || intINTAttributeModifiers != 0 || WoundModifier != 0)
                    {
                        strInit += strSpace + "+" + strSpace + LanguageManager.GetString("Tip_Modifiers") + strSpace
                                   + "(" +
                                   (ImprovementManager.ValueOf(this, Improvement.ImprovementType.MatrixInitiative) +
                                    intINTAttributeModifiers + WoundModifier).ToString(GlobalSettings.CultureInfo)
                                   + ")";
                    }

                    return string.Format(GlobalSettings.CultureInfo,
                                         LanguageManager.GetString(
                                             ActiveCommlink == null
                                                 ? "String_MatrixInitiativeLong"
                                                 : "String_Initiative"),
                                         strInit, MatrixInitiativeColdDice);
                }
            }
        }

        public async Task<string> GetMatrixInitiativeColdToolTipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    return await GetMatrixInitiativeToolTipAsync(token).ConfigureAwait(false);
                }

                CharacterAttrib objInt = await GetAttributeAsync("INT", token: token).ConfigureAwait(false);
                int intINTAttributeModifiers = await objInt.GetAttributeModifiersAsync(token).ConfigureAwait(false);

                string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);

                string strInit = await objInt.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false) + strSpace + "(" + (await objInt.GetValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo) + ")";

                IHasMatrixAttributes objActiveCommlink = await GetActiveCommlinkAsync(token).ConfigureAwait(false);
                if (objActiveCommlink != null)
                {
                    strInit += strSpace + "+" + strSpace + await LanguageManager.GetStringAsync("String_DataProcessing", token: token).ConfigureAwait(false) + strSpace + "(" + (await objActiveCommlink.GetTotalMatrixAttributeAsync("Data Processing", token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo) + ")";
                }

                decimal decFromImprovements = await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.MatrixInitiative, token: token).ConfigureAwait(false);
                int intWoundModifier = await GetWoundModifierAsync(token).ConfigureAwait(false);
                if (decFromImprovements != 0 || intINTAttributeModifiers != 0 || intWoundModifier != 0)
                {
                    strInit += strSpace + "+" + strSpace + await LanguageManager.GetStringAsync("Tip_Modifiers", token: token).ConfigureAwait(false) + strSpace + "(" + (decFromImprovements + intINTAttributeModifiers + intWoundModifier).ToString(GlobalSettings.CultureInfo) + ")";
                }

                return string.Format(GlobalSettings.CultureInfo,
                    await LanguageManager.GetStringAsync(
                        objActiveCommlink == null
                            ? "String_MatrixInitiativeLong"
                            : "String_Initiative", token: token).ConfigureAwait(false),
                    strInit, await GetMatrixInitiativeColdDiceAsync(token).ConfigureAwait(false));
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Cold Sim Matrix Initiative Value.
        /// </summary>
        public int MatrixInitiativeColdValue
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (IsAI)
                    {
                        return MatrixInitiativeValue;
                    }

                    int intCommlinkDP = ActiveCommlink?.GetTotalMatrixAttribute("Data Processing") ?? 0;
                    return INT.TotalValue + intCommlinkDP + WoundModifier +
                           ImprovementManager.ValueOf(this, Improvement.ImprovementType.MatrixInitiative)
                                             .StandardRound();
                }
            }
        }

        /// <summary>
        /// Cold Sim Matrix Initiative Value.
        /// </summary>
        public async Task<int> GetMatrixInitiativeColdValueAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    return await GetMatrixInitiativeValueAsync(token).ConfigureAwait(false);
                }

                IHasMatrixAttributes objCommlink = await GetActiveCommlinkAsync(token).ConfigureAwait(false);
                int intCommlinkDP = objCommlink != null
                    ? await objCommlink.GetTotalMatrixAttributeAsync("Data Processing", token).ConfigureAwait(false)
                    : 0;
                return await (await GetAttributeAsync("INT", token: token).ConfigureAwait(false))
                           .GetTotalValueAsync(token).ConfigureAwait(false) + intCommlinkDP +
                       await GetWoundModifierAsync(token).ConfigureAwait(false) + (await ImprovementManager
                           .ValueOfAsync(this, Improvement.ImprovementType.MatrixInitiative, token: token)
                           .ConfigureAwait(false)).StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Cold Sim Matrix Initiative Dice.
        /// </summary>
        public int MatrixInitiativeColdDice
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (IsAI)
                    {
                        return MatrixInitiativeDice;
                    }

                    return Math.Min(
                        Settings.MinColdSimInitiativeDice + ImprovementManager
                                                            .ValueOf(
                                                                this, Improvement.ImprovementType.MatrixInitiativeDice)
                                                            .StandardRound(),
                        Settings.MaxColdSimInitiativeDice);
                }
            }
        }

        /// <summary>
        /// Cold Sim Matrix Initiative Dice.
        /// </summary>
        public async Task<int> GetMatrixInitiativeColdDiceAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    return await GetMatrixInitiativeDiceAsync(token).ConfigureAwait(false);
                }

                CharacterSettings objSettings = await GetSettingsAsync(token).ConfigureAwait(false);
                return Math.Min(
                    await objSettings.GetMinColdSimInitiativeDiceAsync(token).ConfigureAwait(false) +
                    (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.MatrixInitiativeDice, token: token)
                        .ConfigureAwait(false)).StandardRound(),
                    await objSettings.GetMaxColdSimInitiativeDiceAsync(token).ConfigureAwait(false));
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        #endregion Cold Sim

        #region Hot Sim

        /// <summary>
        /// Matrix Initiative via VR with Hot Sim.
        /// </summary>
        public string MatrixInitiativeHot => GetMatrixInitiativeHot(GlobalSettings.CultureInfo, GlobalSettings.Language);

        /// <summary>
        /// Matrix Initiative via VR with Hot Sim.
        /// </summary>
        public Task<string> GetMatrixInitiativeHotAsync(CancellationToken token = default) =>
            GetMatrixInitiativeHotAsync(GlobalSettings.CultureInfo, GlobalSettings.Language, token);

        public string GetMatrixInitiativeHot(CultureInfo objCulture, string strLanguageToPrint)
        {
            using (LockObject.EnterReadLock())
            {
                if (IsAI)
                {
                    return GetMatrixInitiative(objCulture, strLanguageToPrint);
                }

                return string.Format(
                    objCulture,
                    LanguageManager.GetString(ActiveCommlink == null ? "String_MatrixInitiative" : "String_Initiative",
                                              strLanguageToPrint),
                    MatrixInitiativeHotValue, MatrixInitiativeHotDice);
            }
        }

        public async Task<string> GetMatrixInitiativeHotAsync(CultureInfo objCulture, string strLanguageToPrint,
            CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    return await GetMatrixInitiativeAsync(objCulture, strLanguageToPrint, token).ConfigureAwait(false);
                }

                return string.Format(objCulture,
                    await LanguageManager
                        .GetStringAsync(
                            await GetActiveCommlinkAsync(token).ConfigureAwait(false) == null
                                ? "String_MatrixInitiative"
                                : "String_Initiative", strLanguageToPrint, token: token)
                        .ConfigureAwait(false),
                    await GetMatrixInitiativeHotValueAsync(token).ConfigureAwait(false),
                    await GetMatrixInitiativeHotDiceAsync(token).ConfigureAwait(false));
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string MatrixInitiativeHotToolTip
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (IsAI)
                    {
                        return MatrixInitiativeToolTip;
                    }

                    int intINTAttributeModifiers = INT.AttributeModifiers;

                    string strSpace = LanguageManager.GetString("String_Space");

                    string strInit = INT.CurrentDisplayAbbrev + strSpace + "(" + INT.Value.ToString(GlobalSettings.CultureInfo)
                                     + ")";
                    if (ActiveCommlink != null)
                    {
                        strInit += strSpace + "+" + strSpace + LanguageManager.GetString("String_DataProcessing") +
                                   strSpace + "(" + ActiveCommlink.GetTotalMatrixAttribute("Data Processing")
                                                                  .ToString(GlobalSettings.CultureInfo) + ")";
                    }

                    if (ImprovementManager.ValueOf(this, Improvement.ImprovementType.MatrixInitiative) != 0
                        || intINTAttributeModifiers != 0 || WoundModifier != 0)
                    {
                        strInit += strSpace + "+" + strSpace + LanguageManager.GetString("Tip_Modifiers") + strSpace
                                   + "(" +
                                   (ImprovementManager.ValueOf(this, Improvement.ImprovementType.MatrixInitiative) +
                                    intINTAttributeModifiers + WoundModifier).ToString(GlobalSettings.CultureInfo)
                                   + ")";
                    }

                    return string.Format(GlobalSettings.CultureInfo,
                                         LanguageManager.GetString(
                                             ActiveCommlink == null
                                                 ? "String_MatrixInitiativeLong"
                                                 : "String_Initiative"),
                                         strInit, MatrixInitiativeHotDice);
                }
            }
        }

        public async Task<string> GetMatrixInitiativeHotToolTipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    return await GetMatrixInitiativeToolTipAsync(token).ConfigureAwait(false);
                }

                CharacterAttrib objInt = await GetAttributeAsync("INT", token: token).ConfigureAwait(false);
                int intINTAttributeModifiers = await objInt.GetAttributeModifiersAsync(token).ConfigureAwait(false);

                string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);

                string strInit = await objInt.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false) + strSpace + "(" + (await objInt.GetValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo) + ")";

                IHasMatrixAttributes objActiveCommlink = await GetActiveCommlinkAsync(token).ConfigureAwait(false);
                if (objActiveCommlink != null)
                {
                    strInit += strSpace + "+" + strSpace + await LanguageManager.GetStringAsync("String_DataProcessing", token: token).ConfigureAwait(false) + strSpace + "(" + (await objActiveCommlink.GetTotalMatrixAttributeAsync("Data Processing", token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo) + ")";
                }

                decimal decFromImprovements = await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.MatrixInitiative, token: token).ConfigureAwait(false);
                int intWoundModifier = await GetWoundModifierAsync(token).ConfigureAwait(false);
                if (decFromImprovements != 0 || intINTAttributeModifiers != 0 || intWoundModifier != 0)
                {
                    strInit += strSpace + "+" + strSpace + await LanguageManager.GetStringAsync("Tip_Modifiers", token: token).ConfigureAwait(false) + strSpace + "(" + (decFromImprovements + intINTAttributeModifiers + intWoundModifier).ToString(GlobalSettings.CultureInfo) + ")";
                }

                return string.Format(GlobalSettings.CultureInfo,
                    await LanguageManager.GetStringAsync(
                        objActiveCommlink == null
                            ? "String_MatrixInitiativeLong"
                            : "String_Initiative", token: token).ConfigureAwait(false),
                    strInit, await GetMatrixInitiativeHotDiceAsync(token).ConfigureAwait(false));
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Hot Sim Matrix Initiative Value.
        /// </summary>
        public int MatrixInitiativeHotValue
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (IsAI)
                    {
                        return MatrixInitiativeValue;
                    }

                    int intCommlinkDP = ActiveCommlink?.GetTotalMatrixAttribute("Data Processing") ?? 0;
                    return INT.TotalValue + intCommlinkDP + WoundModifier +
                           ImprovementManager.ValueOf(this, Improvement.ImprovementType.MatrixInitiative)
                                             .StandardRound();
                }
            }
        }

        /// <summary>
        /// Hot Sim Matrix Initiative Value.
        /// </summary>
        public async Task<int> GetMatrixInitiativeHotValueAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    return await GetMatrixInitiativeValueAsync(token).ConfigureAwait(false);
                }

                IHasMatrixAttributes objCommlink = await GetActiveCommlinkAsync(token).ConfigureAwait(false);
                int intCommlinkDP = objCommlink != null
                    ? await objCommlink.GetTotalMatrixAttributeAsync("Data Processing", token).ConfigureAwait(false)
                    : 0;
                return await (await GetAttributeAsync("INT", token: token).ConfigureAwait(false))
                           .GetTotalValueAsync(token).ConfigureAwait(false) + intCommlinkDP +
                       await GetWoundModifierAsync(token).ConfigureAwait(false) + (await ImprovementManager
                           .ValueOfAsync(this, Improvement.ImprovementType.MatrixInitiative, token: token)
                           .ConfigureAwait(false)).StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Hot Sim Matrix Initiative Dice.
        /// </summary>
        public int MatrixInitiativeHotDice
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (IsAI)
                    {
                        return MatrixInitiativeDice;
                    }

                    return Math.Min(
                        Settings.MinHotSimInitiativeDice + ImprovementManager
                                                            .ValueOf(
                                                                this, Improvement.ImprovementType.MatrixInitiativeDice)
                                                            .StandardRound(),
                        Settings.MaxHotSimInitiativeDice);
                }
            }
        }

        /// <summary>
        /// Hot Sim Matrix Initiative Dice.
        /// </summary>
        public async Task<int> GetMatrixInitiativeHotDiceAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    return await GetMatrixInitiativeDiceAsync(token).ConfigureAwait(false);
                }

                CharacterSettings objSettings = await GetSettingsAsync(token).ConfigureAwait(false);
                return Math.Min(
                    await objSettings.GetMinHotSimInitiativeDiceAsync(token).ConfigureAwait(false) +
                    (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.MatrixInitiativeDice, token: token)
                        .ConfigureAwait(false)).StandardRound(),
                    await objSettings.GetMaxHotSimInitiativeDiceAsync(token).ConfigureAwait(false));
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        #endregion Hot Sim

        #region XPath Processing

        /// <summary>
        /// Replaces substring in the form of {Skill} with the total dicepool of the skill.
        /// </summary>
        /// <param name="strInput">Stringbuilder object that contains the input.</param>
        /// <param name="dicValueOverrides">Alternative dictionary to use for value lookup instead of SkillsSection.GetActiveSkill.</param>
        public string ProcessMatrixAttributesInXPath(string strInput, IReadOnlyDictionary<string, int> dicValueOverrides = null)
        {
            if (string.IsNullOrEmpty(strInput))
                return strInput;
            string strReturn = strInput;
            using (LockObject.EnterReadLock())
            {
                foreach (string strAttributeName in MatrixAttributes.MatrixAttributeStrings)
                {
                    strReturn = strReturn
                        .CheapReplace("{" + strAttributeName + "}", () =>
                            dicValueOverrides != null &&
                            dicValueOverrides.TryGetValue(strAttributeName, out int intOverride)
                                ? intOverride.ToString()
                                : ActiveCommlink?.GetTotalMatrixAttribute(strAttributeName).ToString());
                }
            }

            return strReturn;
        }

        /// <summary>
        /// Replaces stringbuilder content in the form of {MatrixAttribute} with the total pool of the Matrix Attribute of the Active Commlink, if any.
        /// </summary>
        /// <param name="sbdInput">Stringbuilder object that contains the input.</param>
        /// <param name="dicValueOverrides">Alternative dictionary to use for value lookup instead of SkillsSection.GetActiveSkill.</param>
        public void ProcessMatrixAttributesInXPath(StringBuilder sbdInput, IReadOnlyDictionary<string, int> dicValueOverrides = null)
        {
            if (sbdInput == null || sbdInput.Length <= 0)
                return;
            using (LockObject.EnterReadLock())
            {
                foreach (string strAttributeName in MatrixAttributes.MatrixAttributeStrings)
                {
                    sbdInput.CheapReplace("{" + strAttributeName + "}", () =>
                        dicValueOverrides != null &&
                        dicValueOverrides.TryGetValue(strAttributeName, out int intOverride)
                            ? intOverride.ToString()
                            : ActiveCommlink?.GetTotalMatrixAttribute(strAttributeName)
                                .ToString());
                }
            }
        }

        #endregion XPath Processing

        #endregion Matrix

        #endregion Initiative

        /// <summary>
        /// Character's total Spell Resistance from qualities and metatype properties.
        /// </summary>
        public int SpellResistance => ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance).StandardRound();

        #endregion Attributes

        #region Special CharacterAttribute Tests

        /// <summary>
        /// Composure (WIL + CHA).
        /// </summary>
        public int Composure
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return WIL.TotalValue + CHA.TotalValue +
                           ImprovementManager.ValueOf(this, Improvement.ImprovementType.Composure).StandardRound()
                           + WoundModifier
                           + SustainingPenalty;
            }
        }

        /// <summary>
        /// Composure (WIL + CHA).
        /// </summary>
        public async Task<int> GetComposureAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await (await GetAttributeAsync("WIL", token: token).ConfigureAwait(false))
                           .GetTotalValueAsync(token).ConfigureAwait(false) +
                       await (await GetAttributeAsync("CHA", token: token).ConfigureAwait(false))
                           .GetTotalValueAsync(token)
                           .ConfigureAwait(false) +
                       (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.Composure, token: token)
                           .ConfigureAwait(false)).StandardRound() +
                       await GetWoundModifierAsync(token).ConfigureAwait(false) +
                       await GetSustainingPenaltyAsync(token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string ComposureToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (LockObject.EnterReadLock())
                    {
                        sbdToolTip.Append(CHA.CurrentDisplayAbbrev).Append(strSpace)
                            .Append('(', CHA.TotalValue.ToString(GlobalSettings.CultureInfo), ')')
                            .Append(strSpace, '+').Append(strSpace, WIL.CurrentDisplayAbbrev, strSpace)
                            .Append('(', WIL.TotalValue.ToString(GlobalSettings.CultureInfo), ')');
                        int intWoundModifier = WoundModifier;
                        if (intWoundModifier != 0)
                            sbdToolTip.Append(strSpace, '+').Append(strSpace, LanguageManager.GetString("Tip_Skill_Wounds"), strSpace)
                                .Append('(', intWoundModifier.ToString(GlobalSettings.CultureInfo), ')');
                        int intSustainingPenalty = SustainingPenalty;
                        if (intSustainingPenalty != 0)
                            sbdToolTip.Append(strSpace, '+').Append(strSpace, LanguageManager.GetString("Tip_Skill_Sustain"), strSpace)
                                .Append('(', intSustainingPenalty.ToString(GlobalSettings.CultureInfo), ')');

                        int intModifiers = ImprovementManager.ValueOf(this, Improvement.ImprovementType.Composure)
                            .StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                Improvement.ImprovementType.Composure,
                                strSpace,
                                intModifiers);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public async Task<string> GetComposureToolTipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                       out StringBuilder sbdToolTip))
            {
                IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    CharacterAttrib objCha = await GetAttributeAsync("CHA", token: token).ConfigureAwait(false);
                    CharacterAttrib objWil = await GetAttributeAsync("WIL", token: token).ConfigureAwait(false);
                    sbdToolTip.Append(await objCha.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false), strSpace)
                        .Append('(', (await objCha.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')')
                        .Append(strSpace, '+').Append(strSpace, await objWil.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false), strSpace)
                        .Append('(', (await objWil.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')');
                    int intWoundModifier = await GetWoundModifierAsync(token).ConfigureAwait(false);
                    if (intWoundModifier != 0)
                        sbdToolTip.Append(strSpace, '+').Append(strSpace, await LanguageManager.GetStringAsync("Tip_Skill_Wounds", token: token).ConfigureAwait(false), strSpace)
                            .Append('(', intWoundModifier.ToString(GlobalSettings.CultureInfo), ')');
                    int intSustainingPenalty = await GetSustainingPenaltyAsync(token).ConfigureAwait(false);
                    if (intSustainingPenalty != 0)
                        sbdToolTip.Append(strSpace, '+').Append(strSpace, await LanguageManager.GetStringAsync("Tip_Skill_Sustain", token: token).ConfigureAwait(false), strSpace)
                            .Append('(', intSustainingPenalty.ToString(GlobalSettings.CultureInfo), ')');

                    int intModifiers = (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.Composure, token: token).ConfigureAwait(false))
                        .StandardRound();

                    if (intModifiers != 0)
                    {
                        await FormatImprovementModifiersAsync(
                            sbdToolTip,
                            Improvement.ImprovementType.Composure,
                            strSpace,
                            intModifiers, token).ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }

                return sbdToolTip.ToString();
            }
        }

        /// <summary>
        /// Judge Intentions (INT + CHA).
        /// </summary>
        public int JudgeIntentions
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return INT.TotalValue + CHA.TotalValue +
                           (ImprovementManager.ValueOf(this, Improvement.ImprovementType.JudgeIntentions)
                            + ImprovementManager.ValueOf(this, Improvement.ImprovementType.JudgeIntentionsOffense))
                           .StandardRound()
                           + SustainingPenalty
                           + WoundModifier;
            }
        }

        /// <summary>
        /// Judge Intentions (INT + CHA).
        /// </summary>
        public async Task<int> GetJudgeIntentionsAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await (await GetAttributeAsync("INT", token: token).ConfigureAwait(false))
                           .GetTotalValueAsync(token).ConfigureAwait(false) +
                       await (await GetAttributeAsync("CHA", token: token).ConfigureAwait(false))
                           .GetTotalValueAsync(token)
                           .ConfigureAwait(false) +
                       (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.JudgeIntentions, token: token).ConfigureAwait(false)
                        + await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.JudgeIntentionsOffense, token: token)
                            .ConfigureAwait(false)).StandardRound() +
                       await GetWoundModifierAsync(token).ConfigureAwait(false) +
                       await GetSustainingPenaltyAsync(token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string JudgeIntentionsToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (LockObject.EnterReadLock())
                    {
                        sbdToolTip.Append(CHA.CurrentDisplayAbbrev, strSpace)
                            .Append('(', CHA.TotalValue.ToString(GlobalSettings.CultureInfo), ')')
                            .Append(strSpace, '+').Append(strSpace, INT.CurrentDisplayAbbrev, strSpace)
                            .Append('(', INT.TotalValue.ToString(GlobalSettings.CultureInfo), ')');
                        int intWoundModifier = WoundModifier;
                        if (intWoundModifier != 0)
                            sbdToolTip.Append(strSpace, '+').Append(strSpace, LanguageManager.GetString("Tip_Skill_Wounds"), strSpace)
                                .Append('(', intWoundModifier.ToString(GlobalSettings.CultureInfo), ')');
                        int intSustainingPenalty = SustainingPenalty;
                        if (intSustainingPenalty != 0)
                            sbdToolTip.Append(strSpace, '+').Append(strSpace, LanguageManager.GetString("Tip_Skill_Sustain"), strSpace)
                                .Append('(', intSustainingPenalty.ToString(GlobalSettings.CultureInfo), ')');

                        int intModifiers =
                            (ImprovementManager.ValueOf(this, Improvement.ImprovementType.JudgeIntentions) +
                             ImprovementManager.ValueOf(this, Improvement.ImprovementType.JudgeIntentionsOffense))
                            .StandardRound();

                        if (intModifiers != 0)
                        {
                            using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.JudgeIntentions, Improvement.ImprovementType.JudgeIntentionsOffense))
                            {
                                FormatImprovementModifiers(sbdToolTip, aParams, strSpace, intModifiers);
                            }
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public async Task<string> GetJudgeIntentionsToolTipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                       out StringBuilder sbdToolTip))
            {
                IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    CharacterAttrib objCha = await GetAttributeAsync("CHA", token: token).ConfigureAwait(false);
                    CharacterAttrib objInt = await GetAttributeAsync("INT", token: token).ConfigureAwait(false);
                    sbdToolTip.Append(await objCha.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false), strSpace)
                        .Append('(', (await objCha.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')')
                        .Append(strSpace, '+').Append(strSpace, await objInt.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false), strSpace)
                        .Append('(', (await objInt.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')');
                    int intWoundModifier = await GetWoundModifierAsync(token).ConfigureAwait(false);
                    if (intWoundModifier != 0)
                        sbdToolTip.Append(strSpace, '+').Append(strSpace, await LanguageManager.GetStringAsync("Tip_Skill_Wounds", token: token).ConfigureAwait(false), strSpace)
                            .Append('(', intWoundModifier.ToString(GlobalSettings.CultureInfo), ')');
                    int intSustainingPenalty = await GetSustainingPenaltyAsync(token).ConfigureAwait(false);
                    if (intSustainingPenalty != 0)
                        sbdToolTip.Append(strSpace, '+').Append(strSpace, await LanguageManager.GetStringAsync("Tip_Skill_Sustain", token: token).ConfigureAwait(false), strSpace)
                            .Append('(', intSustainingPenalty.ToString(GlobalSettings.CultureInfo), ')');

                    int intModifiers =
                        (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.JudgeIntentions, token: token).ConfigureAwait(false) +
                         await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.JudgeIntentionsOffense, token: token).ConfigureAwait(false))
                        .StandardRound();

                    if (intModifiers != 0)
                    {
                        using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.JudgeIntentions, Improvement.ImprovementType.JudgeIntentionsOffense))
                        {
                            await FormatImprovementModifiersAsync(
                                sbdToolTip,
                                aParams,
                                strSpace,
                                intModifiers, token).ConfigureAwait(false);
                        }
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }

                return sbdToolTip.ToString();
            }
        }

        /// <summary>
        /// Judge Intentions Resist (CHA + WIL).
        /// </summary>
        public int JudgeIntentionsResist
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return CHA.TotalValue + WIL.TotalValue +
                           (ImprovementManager.ValueOf(this, Improvement.ImprovementType.JudgeIntentions)
                            + ImprovementManager.ValueOf(this, Improvement.ImprovementType.JudgeIntentionsDefense))
                           .StandardRound();
            }
        }

        /// <summary>
        /// Judge Intentions Resist (CHA + WIL).
        /// </summary>
        public async Task<int> GetJudgeIntentionsResistAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await (await GetAttributeAsync("CHA", token: token).ConfigureAwait(false))
                           .GetTotalValueAsync(token).ConfigureAwait(false) +
                       await (await GetAttributeAsync("WIL", token: token).ConfigureAwait(false))
                           .GetTotalValueAsync(token)
                           .ConfigureAwait(false) +
                       (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.JudgeIntentions, token: token).ConfigureAwait(false)
                        + await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.JudgeIntentionsDefense, token: token)
                            .ConfigureAwait(false)).StandardRound() +
                       await GetWoundModifierAsync(token).ConfigureAwait(false) +
                       await GetSustainingPenaltyAsync(token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string JudgeIntentionsResistToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (LockObject.EnterReadLock())
                    {
                        sbdToolTip.Append(CHA.CurrentDisplayAbbrev, strSpace)
                                  .Append('(', CHA.TotalValue.ToString(GlobalSettings.CultureInfo), ')')
                                  .Append(strSpace, '+').Append(strSpace, WIL.CurrentDisplayAbbrev, strSpace)
                                  .Append('(', WIL.TotalValue.ToString(GlobalSettings.CultureInfo), ')');
                        foreach (Improvement objLoopImprovement in
                                 ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.JudgeIntentions))
                        {
                            sbdToolTip.Append(strSpace, '+').Append(strSpace, GetObjectName(objLoopImprovement), strSpace)
                                .Append('(', objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo), ')');
                        }

                        foreach (Improvement objLoopImprovement in
                                 ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.JudgeIntentionsDefense))
                        {
                            sbdToolTip.Append(strSpace, '+').Append(strSpace, GetObjectName(objLoopImprovement), strSpace)
                                .Append('(', objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo), ')');
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        /// <summary>
        /// Lifting and Carrying (STR + BOD).
        /// </summary>
        public int LiftAndCarry
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return STR.TotalValue + BOD.TotalValue +
                           ImprovementManager.ValueOf(this, Improvement.ImprovementType.LiftAndCarry).StandardRound()
                           + WoundModifier
                           + SustainingPenalty;
            }
        }

        /// <summary>
        /// Lifting and Carrying (STR + BOD).
        /// </summary>
        public async Task<int> GetLiftAndCarryAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await (await GetAttributeAsync("STR", token: token).ConfigureAwait(false))
                           .GetTotalValueAsync(token).ConfigureAwait(false) +
                       await (await GetAttributeAsync("BOD", token: token).ConfigureAwait(false))
                           .GetTotalValueAsync(token)
                           .ConfigureAwait(false) +
                       (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.LiftAndCarry, token: token)
                           .ConfigureAwait(false)).StandardRound() +
                       await GetWoundModifierAsync(token).ConfigureAwait(false) +
                       await GetSustainingPenaltyAsync(token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string LiftAndCarryToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (LockObject.EnterReadLock())
                    {
                        sbdToolTip.Append(BOD.CurrentDisplayAbbrev, strSpace)
                            .Append('(', BOD.TotalValue.ToString(GlobalSettings.CultureInfo), ')')
                            .Append(strSpace, '+').Append(strSpace, STR.CurrentDisplayAbbrev, strSpace)
                            .Append('(', STR.TotalValue.ToString(GlobalSettings.CultureInfo), ')');
                        int intWoundModifier = WoundModifier;
                        if (intWoundModifier != 0)
                            sbdToolTip.Append(strSpace, '+').Append(strSpace, LanguageManager.GetString("Tip_Skill_Wounds"), strSpace)
                                .Append('(', intWoundModifier.ToString(GlobalSettings.CultureInfo), ')');
                        int intSustainingPenalty = SustainingPenalty;
                        if (intSustainingPenalty != 0)
                            sbdToolTip.Append(strSpace, '+').Append(strSpace, LanguageManager.GetString("Tip_Skill_Sustain"), strSpace)
                                .Append('(', intSustainingPenalty.ToString(GlobalSettings.CultureInfo), ')');

                        int intModifiers = ImprovementManager.ValueOf(this, Improvement.ImprovementType.LiftAndCarry)
                            .StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                Improvement.ImprovementType.LiftAndCarry,
                                strSpace,
                                intModifiers);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public async Task<string> GetLiftAndCarryToolTipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                       out StringBuilder sbdToolTip))
            {
                IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    CharacterAttrib objBod = await GetAttributeAsync("BOD", token: token).ConfigureAwait(false);
                    CharacterAttrib objStr = await GetAttributeAsync("STR", token: token).ConfigureAwait(false);
                    sbdToolTip.Append(await objBod.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false), strSpace)
                        .Append('(', (await objBod.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')')
                        .Append(strSpace, '+').Append(strSpace, await objStr.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false), strSpace)
                        .Append('(', (await objStr.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')');
                    int intWoundModifier = await GetWoundModifierAsync(token).ConfigureAwait(false);
                    if (intWoundModifier != 0)
                        sbdToolTip.Append(strSpace, '+').Append(strSpace, await LanguageManager.GetStringAsync("Tip_Skill_Wounds", token: token).ConfigureAwait(false), strSpace)
                            .Append('(', intWoundModifier.ToString(GlobalSettings.CultureInfo), ')');
                    int intSustainingPenalty = await GetSustainingPenaltyAsync(token).ConfigureAwait(false);
                    if (intSustainingPenalty != 0)
                        sbdToolTip.Append(strSpace, '+').Append(strSpace, await LanguageManager.GetStringAsync("Tip_Skill_Sustain", token: token).ConfigureAwait(false), strSpace)
                            .Append('(', intSustainingPenalty.ToString(GlobalSettings.CultureInfo), ')');

                    int intModifiers = (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.LiftAndCarry, token: token).ConfigureAwait(false))
                        .StandardRound();

                    if (intModifiers != 0)
                    {
                        await FormatImprovementModifiersAsync(
                            sbdToolTip,
                            Improvement.ImprovementType.LiftAndCarry,
                            strSpace,
                            intModifiers, token).ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }

                return sbdToolTip.ToString();
            }
        }

        public string LiftAndCarryLimits
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return string.Format(GlobalSettings.CultureInfo,
                                         LanguageManager.GetString("Label_OtherLiftAndCarryLimitsFormat"),
                                         LiftLimit.ToString(
                                             Settings.WeightFormat, GlobalSettings.CultureInfo),
                                         CarryLimit.ToString(
                                             Settings.WeightFormat, GlobalSettings.CultureInfo));
            }
        }

        public async Task<string> GetLiftAndCarryLimitsAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                string strFormat = await (await GetSettingsAsync(token).ConfigureAwait(false)).GetWeightFormatAsync(token).ConfigureAwait(false);
                return string.Format(GlobalSettings.CultureInfo,
                    await LanguageManager.GetStringAsync("Label_OtherLiftAndCarryLimitsFormat", token: token).ConfigureAwait(false),
                    LiftLimit.ToString(strFormat, GlobalSettings.CultureInfo),
                    CarryLimit.ToString(strFormat, GlobalSettings.CultureInfo));
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Memory (LOG + WIL).
        /// </summary>
        public int Memory
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return LOG.TotalValue + WIL.TotalValue +
                           ImprovementManager.ValueOf(this, Improvement.ImprovementType.Memory).StandardRound()
                           + WoundModifier
                           + SustainingPenalty;
            }
        }

        /// <summary>
        /// Memory (LOG + WIL).
        /// </summary>
        public async Task<int> GetMemoryAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await (await GetAttributeAsync("LOG", token: token).ConfigureAwait(false))
                           .GetTotalValueAsync(token).ConfigureAwait(false) +
                       await (await GetAttributeAsync("WIL", token: token).ConfigureAwait(false))
                           .GetTotalValueAsync(token)
                           .ConfigureAwait(false) +
                       (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.Memory, token: token)
                           .ConfigureAwait(false)).StandardRound() +
                       await GetWoundModifierAsync(token).ConfigureAwait(false) +
                       await GetSustainingPenaltyAsync(token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string MemoryToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (LockObject.EnterReadLock())
                    {
                        sbdToolTip.Append(LOG.CurrentDisplayAbbrev, strSpace)
                            .Append('(', LOG.TotalValue.ToString(GlobalSettings.CultureInfo), ')')
                            .Append(strSpace, '+').Append(strSpace, WIL.CurrentDisplayAbbrev, strSpace)
                            .Append('(', WIL.TotalValue.ToString(GlobalSettings.CultureInfo), ')');
                        int intWoundModifier = WoundModifier;
                        if (intWoundModifier != 0)
                            sbdToolTip.Append(strSpace, '+').Append(strSpace, LanguageManager.GetString("Tip_Skill_Wounds"), strSpace)
                                .Append('(', intWoundModifier.ToString(GlobalSettings.CultureInfo), ')');
                        int intSustainingPenalty = SustainingPenalty;
                        if (intSustainingPenalty != 0)
                            sbdToolTip.Append(strSpace, '+').Append(strSpace, LanguageManager.GetString("Tip_Skill_Sustain"), strSpace)
                                .Append('(', intSustainingPenalty.ToString(GlobalSettings.CultureInfo), ')');

                        int intModifiers = ImprovementManager.ValueOf(this, Improvement.ImprovementType.Memory)
                            .StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                Improvement.ImprovementType.Memory,
                                strSpace,
                                intModifiers);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public async Task<string> GetMemoryToolTipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                       out StringBuilder sbdToolTip))
            {
                IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    CharacterAttrib objLog = await GetAttributeAsync("LOG", token: token).ConfigureAwait(false);
                    CharacterAttrib objWil = await GetAttributeAsync("WIL", token: token).ConfigureAwait(false);
                    sbdToolTip.Append(await objLog.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false), strSpace)
                        .Append('(', (await objLog.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')')
                        .Append(strSpace, '+')
                        .Append(strSpace, await objWil.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false), strSpace)
                        .Append('(', (await objWil.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')');
                    int intWoundModifier = await GetWoundModifierAsync(token).ConfigureAwait(false);
                    if (intWoundModifier != 0)
                        sbdToolTip.Append(strSpace, '+').Append(strSpace, await LanguageManager.GetStringAsync("Tip_Skill_Wounds", token: token).ConfigureAwait(false), strSpace)
                            .Append('(', intWoundModifier.ToString(GlobalSettings.CultureInfo), ')');
                    int intSustainingPenalty = await GetSustainingPenaltyAsync(token).ConfigureAwait(false);
                    if (intSustainingPenalty != 0)
                        sbdToolTip.Append(strSpace, '+').Append(strSpace, await LanguageManager.GetStringAsync("Tip_Skill_Sustain", token: token).ConfigureAwait(false), strSpace)
                            .Append('(', intSustainingPenalty.ToString(GlobalSettings.CultureInfo), ')');

                    int intModifiers = (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.Memory, token: token).ConfigureAwait(false))
                        .StandardRound();

                    if (intModifiers != 0)
                    {
                        await FormatImprovementModifiersAsync(
                            sbdToolTip,
                            Improvement.ImprovementType.Memory,
                            strSpace,
                            intModifiers, token).ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }

                return sbdToolTip.ToString();
            }
        }

        /// <summary>
        /// Resist test to Fatigue damage (BOD + WIL).
        /// </summary>
        public int FatigueResist
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return BOD.TotalValue + WIL.TotalValue +
                           ImprovementManager.ValueOf(this, Improvement.ImprovementType.FatigueResist).StandardRound();
            }
        }

        /// <summary>
        /// Resist test to Fatigue damage (BOD + WIL).
        /// </summary>
        public async Task<int> GetFatigueResistAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await (await GetAttributeAsync("BOD", token: token).ConfigureAwait(false))
                           .GetTotalValueAsync(token).ConfigureAwait(false) +
                       await (await GetAttributeAsync("WIL", token: token).ConfigureAwait(false))
                           .GetTotalValueAsync(token)
                           .ConfigureAwait(false) +
                       (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.FatigueResist, token: token)
                           .ConfigureAwait(false)).StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Resist test to Radiation damage (BOD + WIL).
        /// </summary>
        public int RadiationResist
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return BOD.TotalValue + WIL.TotalValue +
                           ImprovementManager.ValueOf(this, Improvement.ImprovementType.RadiationResist)
                                             .StandardRound();
            }
        }

        /// <summary>
        /// Resist test to Radiation damage (BOD + WIL).
        /// </summary>
        public async Task<int> GetRadiationResistAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await (await GetAttributeAsync("BOD", token: token).ConfigureAwait(false))
                           .GetTotalValueAsync(token).ConfigureAwait(false) +
                       await (await GetAttributeAsync("WIL", token: token).ConfigureAwait(false))
                           .GetTotalValueAsync(token)
                           .ConfigureAwait(false) +
                       (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.RadiationResist, token: token)
                           .ConfigureAwait(false)).StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Resist test to Sonic Attacks damage (WIL).
        /// </summary>
        public int SonicResist
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return WIL.TotalValue + ImprovementManager.ValueOf(this, Improvement.ImprovementType.SonicResist)
                                                              .StandardRound();
            }
        }

        /// <summary>
        /// Resist test to Sonic Attacks damage (WIL).
        /// </summary>
        public async Task<int> GetSonicResistAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await (await GetAttributeAsync("WIL", token: token).ConfigureAwait(false))
                           .GetTotalValueAsync(token)
                           .ConfigureAwait(false) +
                       (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SonicResist, token: token)
                           .ConfigureAwait(false)).StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Resist test to Contact-vector Toxins (BOD + WIL).
        /// </summary>
        public string ToxinContactResist(string strLanguage, CultureInfo objCulture)
        {
            using (LockObject.EnterReadLock())
            {
                if (IsAI || ImprovementManager
                            .GetCachedImprovementListForValueOf(
                                this, Improvement.ImprovementType.ToxinContactImmune).Count > 0)
                    return LanguageManager.GetString("String_Immune", strLanguage);
                return (BOD.TotalValue + WIL.TotalValue +
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.ToxinContactResist)
                                          .StandardRound())
                    .ToString(objCulture);
            }
        }

        /// <summary>
        /// Resist test to Ingestion-vector Toxins (BOD + WIL).
        /// </summary>
        public string ToxinIngestionResist(string strLanguage, CultureInfo objCulture)
        {
            using (LockObject.EnterReadLock())
            {
                if (IsAI || ImprovementManager
                            .GetCachedImprovementListForValueOf(
                                this, Improvement.ImprovementType.ToxinIngestionImmune).Count > 0)
                    return LanguageManager.GetString("String_Immune", strLanguage);
                return (BOD.TotalValue + WIL.TotalValue +
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.ToxinIngestionResist)
                                          .StandardRound())
                    .ToString(objCulture);
            }
        }

        /// <summary>
        /// Resist test to Inhalation-vector Toxins (BOD + WIL).
        /// </summary>
        public string ToxinInhalationResist(string strLanguage, CultureInfo objCulture)
        {
            using (LockObject.EnterReadLock())
            {
                if (IsAI || ImprovementManager
                            .GetCachedImprovementListForValueOf(
                                this, Improvement.ImprovementType.ToxinInhalationImmune).Count > 0)
                    return LanguageManager.GetString("String_Immune", strLanguage);
                return (BOD.TotalValue + WIL.TotalValue +
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.ToxinInhalationResist)
                                          .StandardRound())
                    .ToString(objCulture);
            }
        }

        /// <summary>
        /// Resist test to Injection-vector Toxins (BOD + WIL).
        /// </summary>
        public string ToxinInjectionResist(string strLanguage, CultureInfo objCulture)
        {
            using (LockObject.EnterReadLock())
            {
                if (IsAI || ImprovementManager
                            .GetCachedImprovementListForValueOf(
                                this, Improvement.ImprovementType.ToxinInjectionImmune).Count > 0)
                    return LanguageManager.GetString("String_Immune", strLanguage);
                return (BOD.TotalValue + WIL.TotalValue +
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.ToxinInjectionResist)
                                          .StandardRound())
                    .ToString(objCulture);
            }
        }

        /// <summary>
        /// Resist test to Contact-vector Pathogens (BOD + WIL).
        /// </summary>
        public string PathogenContactResist(string strLanguage, CultureInfo objCulture)
        {
            using (LockObject.EnterReadLock())
            {
                if (IsAI || ImprovementManager
                            .GetCachedImprovementListForValueOf(
                                this, Improvement.ImprovementType.PathogenContactImmune).Count > 0)
                    return LanguageManager.GetString("String_Immune", strLanguage);
                return (BOD.TotalValue + WIL.TotalValue +
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.PathogenContactResist)
                                          .StandardRound())
                    .ToString(objCulture);
            }
        }

        /// <summary>
        /// Resist test to Ingestion-vector Pathogens (BOD + WIL).
        /// </summary>
        public string PathogenIngestionResist(string strLanguage, CultureInfo objCulture)
        {
            using (LockObject.EnterReadLock())
            {
                if (IsAI || ImprovementManager
                            .GetCachedImprovementListForValueOf(
                                this, Improvement.ImprovementType.PathogenIngestionImmune).Count > 0)
                    return LanguageManager.GetString("String_Immune", strLanguage);
                return (BOD.TotalValue + WIL.TotalValue +
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.PathogenIngestionResist)
                                          .StandardRound())
                    .ToString(objCulture);
            }
        }

        /// <summary>
        /// Resist test to Inhalation-vector Pathogens (BOD + WIL).
        /// </summary>
        public string PathogenInhalationResist(string strLanguage, CultureInfo objCulture)
        {
            using (LockObject.EnterReadLock())
            {
                if (IsAI || ImprovementManager
                            .GetCachedImprovementListForValueOf(
                                this, Improvement.ImprovementType.PathogenInhalationImmune).Count > 0)
                    return LanguageManager.GetString("String_Immune", strLanguage);
                return (BOD.TotalValue + WIL.TotalValue +
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.PathogenInhalationResist)
                                          .StandardRound())
                    .ToString(objCulture);
            }
        }

        /// <summary>
        /// Resist test to Injection-vector Pathogens (BOD + WIL).
        /// </summary>
        public string PathogenInjectionResist(string strLanguage, CultureInfo objCulture)
        {
            using (LockObject.EnterReadLock())
            {
                if (IsAI || ImprovementManager
                            .GetCachedImprovementListForValueOf(
                                this, Improvement.ImprovementType.PathogenInjectionImmune).Count > 0)
                    return LanguageManager.GetString("String_Immune", strLanguage);
                return (BOD.TotalValue + WIL.TotalValue +
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.PathogenInjectionResist)
                                          .StandardRound())
                    .ToString(objCulture);
            }
        }

        /// <summary>
        /// Resist test to Contact-vector Toxins (BOD + WIL).
        /// </summary>
        public async Task<string> ToxinContactResistAsync(string strLanguage, CultureInfo objCulture, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await GetIsAIAsync(token).ConfigureAwait(false)
                    || (await ImprovementManager
                            .GetCachedImprovementListForValueOfAsync(
                                this, Improvement.ImprovementType.ToxinContactImmune, token: token).ConfigureAwait(false)).Count > 0)
                    return await LanguageManager.GetStringAsync("String_Immune", strLanguage, token: token).ConfigureAwait(false);
                return (await (await GetAttributeAsync("BOD", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                        + await (await GetAttributeAsync("WIL", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                        + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.ToxinContactResist, token: token).ConfigureAwait(false))
                                          .StandardRound())
                    .ToString(objCulture);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Resist test to Ingestion-vector Toxins (BOD + WIL).
        /// </summary>
        public async Task<string> ToxinIngestionResistAsync(string strLanguage, CultureInfo objCulture, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await GetIsAIAsync(token).ConfigureAwait(false)
                    || (await ImprovementManager
                            .GetCachedImprovementListForValueOfAsync(
                                this, Improvement.ImprovementType.ToxinIngestionImmune, token: token).ConfigureAwait(false)).Count > 0)
                    return await LanguageManager.GetStringAsync("String_Immune", strLanguage, token: token).ConfigureAwait(false);
                return (await (await GetAttributeAsync("BOD", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                        + await (await GetAttributeAsync("WIL", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                        + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.ToxinIngestionResist, token: token).ConfigureAwait(false))
                                          .StandardRound())
                    .ToString(objCulture);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Resist test to Inhalation-vector Toxins (BOD + WIL).
        /// </summary>
        public async Task<string> ToxinInhalationResistAsync(string strLanguage, CultureInfo objCulture, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await GetIsAIAsync(token).ConfigureAwait(false)
                    || (await ImprovementManager
                            .GetCachedImprovementListForValueOfAsync(
                                this, Improvement.ImprovementType.ToxinInhalationImmune, token: token).ConfigureAwait(false)).Count > 0)
                    return await LanguageManager.GetStringAsync("String_Immune", strLanguage, token: token).ConfigureAwait(false);
                return (await (await GetAttributeAsync("BOD", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                        + await (await GetAttributeAsync("WIL", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                        + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.ToxinInhalationResist, token: token).ConfigureAwait(false))
                                          .StandardRound())
                    .ToString(objCulture);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Resist test to Injection-vector Toxins (BOD + WIL).
        /// </summary>
        public async Task<string> ToxinInjectionResistAsync(string strLanguage, CultureInfo objCulture, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await GetIsAIAsync(token).ConfigureAwait(false)
                    || (await ImprovementManager
                            .GetCachedImprovementListForValueOfAsync(
                                this, Improvement.ImprovementType.ToxinInjectionImmune, token: token).ConfigureAwait(false)).Count > 0)
                    return await LanguageManager.GetStringAsync("String_Immune", strLanguage, token: token).ConfigureAwait(false);
                return (await (await GetAttributeAsync("BOD", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                        + await (await GetAttributeAsync("WIL", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                        + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.ToxinInjectionResist, token: token).ConfigureAwait(false))
                                          .StandardRound())
                    .ToString(objCulture);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Resist test to Contact-vector Pathogens (BOD + WIL).
        /// </summary>
        public async Task<string> PathogenContactResistAsync(string strLanguage, CultureInfo objCulture, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await GetIsAIAsync(token).ConfigureAwait(false)
                    || (await ImprovementManager
                            .GetCachedImprovementListForValueOfAsync(
                                this, Improvement.ImprovementType.PathogenContactImmune, token: token).ConfigureAwait(false)).Count > 0)
                    return await LanguageManager.GetStringAsync("String_Immune", strLanguage, token: token).ConfigureAwait(false);
                return (await (await GetAttributeAsync("BOD", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                        + await (await GetAttributeAsync("WIL", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                        + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.PathogenContactResist, token: token).ConfigureAwait(false))
                                          .StandardRound())
                    .ToString(objCulture);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Resist test to Ingestion-vector Pathogens (BOD + WIL).
        /// </summary>
        public async Task<string> PathogenIngestionResistAsync(string strLanguage, CultureInfo objCulture, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await GetIsAIAsync(token).ConfigureAwait(false)
                    || (await ImprovementManager
                            .GetCachedImprovementListForValueOfAsync(
                                this, Improvement.ImprovementType.PathogenIngestionImmune, token: token).ConfigureAwait(false)).Count > 0)
                    return await LanguageManager.GetStringAsync("String_Immune", strLanguage, token: token).ConfigureAwait(false);
                return (await (await GetAttributeAsync("BOD", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                        + await (await GetAttributeAsync("WIL", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                        + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.PathogenIngestionResist, token: token).ConfigureAwait(false))
                                          .StandardRound())
                    .ToString(objCulture);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Resist test to Inhalation-vector Pathogens (BOD + WIL).
        /// </summary>
        public async Task<string> PathogenInhalationResistAsync(string strLanguage, CultureInfo objCulture, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await GetIsAIAsync(token).ConfigureAwait(false)
                    || (await ImprovementManager
                            .GetCachedImprovementListForValueOfAsync(
                                this, Improvement.ImprovementType.PathogenInhalationImmune, token: token).ConfigureAwait(false)).Count > 0)
                    return await LanguageManager.GetStringAsync("String_Immune", strLanguage, token: token).ConfigureAwait(false);
                return (await (await GetAttributeAsync("BOD", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                        + await (await GetAttributeAsync("WIL", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                        + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.PathogenInhalationResist, token: token).ConfigureAwait(false))
                                          .StandardRound())
                    .ToString(objCulture);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Resist test to Injection-vector Pathogens (BOD + WIL).
        /// </summary>
        public async Task<string> PathogenInjectionResistAsync(string strLanguage, CultureInfo objCulture, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await GetIsAIAsync(token).ConfigureAwait(false)
                    || (await ImprovementManager
                            .GetCachedImprovementListForValueOfAsync(
                                this, Improvement.ImprovementType.PathogenInjectionImmune, token: token).ConfigureAwait(false)).Count > 0)
                    return await LanguageManager.GetStringAsync("String_Immune", strLanguage, token: token).ConfigureAwait(false);
                return (await (await GetAttributeAsync("BOD", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                        + await (await GetAttributeAsync("WIL", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                        + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.PathogenInjectionResist, token: token).ConfigureAwait(false))
                                          .StandardRound())
                    .ToString(objCulture);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Resist test to Physiological Addiction (BOD + WIL) if you are not addicted yet.
        /// </summary>
        public int PhysiologicalAddictionResistFirstTime
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return BOD.TotalValue + WIL.TotalValue + ImprovementManager.ValueOf(this,
                                                                                   Improvement.ImprovementType
                                                                                       .PhysiologicalAddictionFirstTime)
                                                                               .StandardRound();
            }
        }

        /// <summary>
        /// Resist test to Psychological Addiction (LOG + WIL) if you are not addicted yet.
        /// </summary>
        public int PsychologicalAddictionResistFirstTime
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return LOG.TotalValue + WIL.TotalValue + ImprovementManager.ValueOf(this,
                                                                                   Improvement.ImprovementType
                                                                                       .PsychologicalAddictionFirstTime)
                                                                               .StandardRound();
            }
        }

        /// <summary>
        /// Resist test to Physiological Addiction (BOD + WIL) if you are already addicted.
        /// </summary>
        public int PhysiologicalAddictionResistAlreadyAddicted
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return BOD.TotalValue + WIL.TotalValue + ImprovementManager.ValueOf(this,
                                                                                   Improvement.ImprovementType
                                                                                       .PhysiologicalAddictionAlreadyAddicted)
                                                                               .StandardRound();
            }
        }

        /// <summary>
        /// Resist test to Psychological Addiction (LOG + WIL) if you are already addicted.
        /// </summary>
        public int PsychologicalAddictionResistAlreadyAddicted
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return LOG.TotalValue + WIL.TotalValue + ImprovementManager.ValueOf(this,
                                                                                   Improvement.ImprovementType
                                                                                       .PsychologicalAddictionAlreadyAddicted)
                                                                               .StandardRound();
            }
        }

        /// <summary>
        /// Resist test to Physiological Addiction (BOD + WIL) if you are not addicted yet.
        /// </summary>
        public async Task<int> GetPhysiologicalAddictionResistFirstTimeAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await (await GetAttributeAsync("BOD", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                    + await (await GetAttributeAsync("WIL", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                    + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.PhysiologicalAddictionFirstTime, token: token).ConfigureAwait(false))
                        .StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Resist test to Psychological Addiction (LOG + WIL) if you are not addicted yet.
        /// </summary>
        public async Task<int> GetPsychologicalAddictionResistFirstTimeAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await (await GetAttributeAsync("LOG", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                    + await (await GetAttributeAsync("WIL", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                    + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.PsychologicalAddictionFirstTime, token: token).ConfigureAwait(false))
                        .StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Resist test to Physiological Addiction (BOD + WIL) if you are already addicted.
        /// </summary>
        public async Task<int> GetPhysiologicalAddictionResistAlreadyAddictedAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await (await GetAttributeAsync("BOD", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                    + await (await GetAttributeAsync("WIL", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                    + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.PhysiologicalAddictionAlreadyAddicted, token: token).ConfigureAwait(false))
                        .StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Resist test to Psychological Addiction (LOG + WIL) if you are already addicted.
        /// </summary>
        public async Task<int> GetPsychologicalAddictionResistAlreadyAddictedAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await (await GetAttributeAsync("LOG", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                    + await (await GetAttributeAsync("WIL", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                    + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.PsychologicalAddictionAlreadyAddicted, token: token).ConfigureAwait(false))
                        .StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Dicepool for natural recovery from Stun CM box damage (BOD + WIL).
        /// </summary>
        public int StunCMNaturalRecovery
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    // Matrix damage for A.I.s is not naturally repaired
                    if (IsAI)
                        return 0;
                    int intReturn = BOD.TotalValue + WIL.TotalValue +
                                    ImprovementManager.ValueOf(this, Improvement.ImprovementType.StunCMRecovery)
                                                      .StandardRound();
                    if (ImprovementManager
                        .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.AddESStoStunCMRecovery)
                        .Count
                        > 0)
                        intReturn += Essence().ToInt32();
                    return intReturn;
                }
            }
        }

        /// <summary>
        /// Dicepool for natural recovery from Stun CM box damage (BOD + WIL).
        /// </summary>
        public async Task<int> GetStunCMNaturalRecoveryAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                // Matrix damage for A.I.s is not naturally repaired
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                    return 0;
                int intReturn =
                    await (await GetAttributeAsync("BOD", token: token).ConfigureAwait(false)).GetTotalValueAsync(token)
                        .ConfigureAwait(false) +
                    await (await GetAttributeAsync("WIL", token: token).ConfigureAwait(false)).GetTotalValueAsync(token)
                        .ConfigureAwait(false) +
                    (await ImprovementManager
                        .ValueOfAsync(this, Improvement.ImprovementType.StunCMRecovery, token: token)
                        .ConfigureAwait(false)).StandardRound();
                if ((await ImprovementManager
                        .GetCachedImprovementListForValueOfAsync(this,
                            Improvement.ImprovementType.AddESStoStunCMRecovery, token: token).ConfigureAwait(false))
                    .Count > 0)
                    intReturn += (await EssenceAsync(token: token).ConfigureAwait(false)).ToInt32();
                return intReturn;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Dicepool for natural recovery from Physical CM box damage (2 x BOD).
        /// </summary>
        public int PhysicalCMNaturalRecovery
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    int intReturn;
                    if (IsAI)
                    {
                        if (HomeNode is Vehicle)
                            return 0;

                        // A.I.s can restore Core damage via Software + Depth [Data Processing] (1 day) Extended Test
                        intReturn =
                            (SkillsSection.GetActiveSkill("Software")?.PoolOtherAttribute("DEP") ??
                             DEP.TotalValue - 1) +
                            ImprovementManager.ValueOf(this, Improvement.ImprovementType.PhysicalCMRecovery)
                                              .StandardRound();
                    }
                    else
                    {
                        intReturn = 2 * BOD.TotalValue +
                                    ImprovementManager.ValueOf(this, Improvement.ImprovementType.PhysicalCMRecovery)
                                        .StandardRound();
                    }

                    if (ImprovementManager
                            .GetCachedImprovementListForValueOf(
                                this, Improvement.ImprovementType.AddESStoPhysicalCMRecovery).Count
                        > 0)
                        intReturn += Essence().ToInt32();
                    return intReturn;
                }
            }
        }

        /// <summary>
        /// Dicepool for natural recovery from Physical CM box damage (2 x BOD).
        /// </summary>
        public async Task<int> GetPhysicalCMNaturalRecoveryAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intReturn;
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    if (await GetHomeNodeAsync(token).ConfigureAwait(false) is Vehicle)
                        return 0;

                    // A.I.s can restore Core damage via Software + Depth [Data Processing] (1 day) Extended Test
                    Skill objSoftware =
                        await SkillsSection.GetActiveSkillAsync("Software", token).ConfigureAwait(false);
                    intReturn = (objSoftware != null
                                    ? await objSoftware.PoolOtherAttributeAsync("DEP", token: token)
                                        .ConfigureAwait(false)
                                    : await (await GetAttributeAsync("DEP", token: token).ConfigureAwait(false))
                                        .GetTotalValueAsync(token).ConfigureAwait(false) - 1) +
                                (await ImprovementManager
                                    .ValueOfAsync(this, Improvement.ImprovementType.PhysicalCMRecovery, token: token)
                                    .ConfigureAwait(false)).StandardRound();
                }
                else
                {
                    intReturn =
                        2 * await (await GetAttributeAsync("BOD", token: token).ConfigureAwait(false))
                            .GetTotalValueAsync(token).ConfigureAwait(false) +
                        (await ImprovementManager
                            .ValueOfAsync(this, Improvement.ImprovementType.PhysicalCMRecovery, token: token)
                            .ConfigureAwait(false)).StandardRound();
                }

                if ((await ImprovementManager
                        .GetCachedImprovementListForValueOfAsync(this,
                            Improvement.ImprovementType.AddESStoPhysicalCMRecovery, token: token).ConfigureAwait(false))
                    .Count > 0)
                    intReturn += (await EssenceAsync(token: token).ConfigureAwait(false)).ToInt32();
                return intReturn;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        #endregion Special CharacterAttribute Tests

        #region Reputation

        /// <summary>
        /// Amount of Street Cred the character has earned through standard means.
        /// </summary>
        public int CalculatedStreetCred
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    // Street Cred = Career Karma / 10, rounded down
                    int intReturn = CareerKarma /
                                    (10 + ImprovementManager.ValueOf(this,
                                                                     Improvement.ImprovementType.StreetCredMultiplier)
                                                            .StandardRound());

                    // Deduct burnt Street Cred.
                    intReturn -= BurntStreetCred;

                    return intReturn;
                }
            }
        }

        /// <summary>
        /// Amount of Street Cred the character has earned through standard means.
        /// </summary>
        public async Task<int> GetCalculatedStreetCredAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                // Street Cred = Career Karma / 10, rounded down
                int intReturn = await GetCareerKarmaAsync(token).ConfigureAwait(false) / (10 +
                    (await ImprovementManager
                        .ValueOfAsync(this, Improvement.ImprovementType.StreetCredMultiplier, token: token)
                        .ConfigureAwait(false)).StandardRound());

                // Deduct burnt Street Cred.
                intReturn -= await GetBurntStreetCredAsync(token).ConfigureAwait(false);

                return intReturn;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's total amount of Street Cred (earned + GM awarded).
        /// </summary>
        public int TotalStreetCred
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return Math.Max(
                        CalculatedStreetCred + StreetCred +
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.StreetCred).StandardRound(), 0);
            }
        }

        /// <summary>
        /// Character's total amount of Street Cred (earned + GM awarded).
        /// </summary>
        public async Task<int> GetTotalStreetCredAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return Math.Max(
                    await GetCalculatedStreetCredAsync(token).ConfigureAwait(false) +
                    await GetStreetCredAsync(token).ConfigureAwait(false) +
                    (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.StreetCred, token: token)
                        .ConfigureAwait(false)).StandardRound(), 0);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string CareerDisplayStreetCred
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    int intTotalStreetCred = TotalStreetCred;
                    int intCalculatedStreetCred = intTotalStreetCred - StreetCred;
                    return (intCalculatedStreetCred >= 0
                               ? " + " + intCalculatedStreetCred.ToString(GlobalSettings.CultureInfo)
                               : " - " + (-intCalculatedStreetCred).ToString(GlobalSettings.CultureInfo)) + " = " +
                           intTotalStreetCred.ToString(GlobalSettings.CultureInfo);
                }
            }
        }

        public async Task<string> GetCareerDisplayStreetCredAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intTotalStreetCred = await GetTotalStreetCredAsync(token).ConfigureAwait(false);
                int intCalculatedStreetCred =
                    intTotalStreetCred - await GetStreetCredAsync(token).ConfigureAwait(false);
                return (intCalculatedStreetCred >= 0
                           ? " + " + intCalculatedStreetCred.ToString(GlobalSettings.CultureInfo)
                           : " - " + (-intCalculatedStreetCred).ToString(GlobalSettings.CultureInfo)) + " = " +
                       intTotalStreetCred.ToString(GlobalSettings.CultureInfo);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public bool CanBurnStreetCred
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return Created && TotalStreetCred >= 2;
            }
        }

        public async Task<bool> GetCanBurnStreetCredAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await GetCreatedAsync(token).ConfigureAwait(false) &&
                       await GetTotalStreetCredAsync(token).ConfigureAwait(false) >= 2;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Street Cred Tooltip.
        /// </summary>
        public string StreetCredTooltip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdReturn))
                {
                    using (LockObject.EnterReadLock())
                    {
                        sbdReturn.Append(StreetCred.ToString(GlobalSettings.CultureInfo));

                        foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.StreetCred))
                        {
                            sbdReturn.Append(strSpace, '+', strSpace)
                                     .Append(GetObjectName(objImprovement), strSpace, '(')
                                     .Append(objImprovement.Value.ToString(GlobalSettings.CultureInfo), ')');
                        }

                        sbdReturn.Append(strSpace, '+').Append(strSpace, '[')
                                 .Append(LanguageManager.GetString("String_CareerKarma")).Append(strSpace, '÷', strSpace)
                                 .Append((10 + ImprovementManager.ValueOf(
                                             this, Improvement.ImprovementType.StreetCredMultiplier))
                                         .ToString(GlobalSettings.CultureInfo)).Append(']', strSpace, '(')
                                 .Append(
                                     (CareerKarma
                                      / (10 + ImprovementManager.ValueOf(
                                          this, Improvement.ImprovementType.StreetCredMultiplier)))
                                     .ToString(GlobalSettings.CultureInfo), ')');

                        int intBurnedStreetCred = BurntStreetCred;
                        if (intBurnedStreetCred != 0)
                            sbdReturn.Append(strSpace, '-', strSpace)
                                     .Append(LanguageManager.GetString("String_BurntStreetCred"), strSpace)
                                     .Append('(', intBurnedStreetCred.ToString(GlobalSettings.CultureInfo), ')');
                    }

                    return sbdReturn.ToString();
                }
            }
        }

        public async Task<string> GetStreetCredTooltipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdReturn))
            {
                IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    sbdReturn.Append(
                        (await GetStreetCredAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo));

                    foreach (Improvement objImprovement in await ImprovementManager
                                 .GetCachedImprovementListForValueOfAsync(this, Improvement.ImprovementType.StreetCred,
                                     token: token).ConfigureAwait(false))
                    {
                        sbdReturn.Append(strSpace, '+', strSpace)
                            .Append(await GetObjectNameAsync(objImprovement, token: token).ConfigureAwait(false))
                            .Append(strSpace, '(')
                            .Append(objImprovement.Value.ToString(GlobalSettings.CultureInfo), ')');
                    }

                    sbdReturn.Append(strSpace, '+').Append(strSpace, '[')
                        .Append(await LanguageManager.GetStringAsync("String_CareerKarma", token: token)
                            .ConfigureAwait(false)).Append(strSpace, '÷', strSpace)
                        .Append((10 + await ImprovementManager
                            .ValueOfAsync(this, Improvement.ImprovementType.StreetCredMultiplier, token: token)
                            .ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo)).Append(']', strSpace)
                        .Append('(', (await GetCareerKarmaAsync(token).ConfigureAwait(false) / (10 + await ImprovementManager
                            .ValueOfAsync(this, Improvement.ImprovementType.StreetCredMultiplier, token: token)
                            .ConfigureAwait(false))).ToString(GlobalSettings.CultureInfo), ')');

                    int intBurnedStreetCred = await GetBurntStreetCredAsync(token).ConfigureAwait(false);
                    if (intBurnedStreetCred != 0)
                        sbdReturn.Append(strSpace, '-', strSpace)
                            .Append(await LanguageManager.GetStringAsync("String_BurntStreetCred", token: token)
                                .ConfigureAwait(false)).Append(strSpace, '(')
                            .Append(intBurnedStreetCred.ToString(GlobalSettings.CultureInfo), ')');
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }

                return sbdReturn.ToString();
            }
        }

        /// <summary>
        /// Amount of Notoriety the character has earned through standard means.
        /// </summary>
        public int CalculatedNotoriety
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    // Notoriety is simply the total value of Notoriety Improvements + the number of Enemies they have.
                    int intReturn = ImprovementManager.ValueOf(this, Improvement.ImprovementType.Notoriety)
                                                      .StandardRound() -
                                    BurntStreetCred / 2; // + Contacts.Count(x => x.EntityType == ContactType.Enemy);

                    return intReturn;
                }
            }
        }

        /// <summary>
        /// Amount of Notoriety the character has earned through standard means.
        /// </summary>
        public async Task<int> GetCalculatedNotorietyAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                // Notoriety is simply the total value of Notoriety Improvements + the number of Enemies they have.
                int intReturn =
                    (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.Notoriety, token: token)
                        .ConfigureAwait(false)).StandardRound() -
                    await GetBurntStreetCredAsync(token).ConfigureAwait(false) / 2; // + Contacts.Count(x => x.EntityType == ContactType.Enemy);

                return intReturn;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's total amount of Notoriety (earned + GM awarded - burnt Street Cred).
        /// </summary>
        public int TotalNotoriety
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return CalculatedNotoriety + Notoriety;
            }
        }

        /// <summary>
        /// Character's total amount of Notoriety (earned + GM awarded - burnt Street Cred).
        /// </summary>
        public async Task<int> GetTotalNotorietyAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await GetCalculatedNotorietyAsync(token).ConfigureAwait(false) +
                       await GetNotorietyAsync(token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string CareerDisplayNotoriety
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (LockObject.EnterReadLock())
                {
                    int intCalculatedNotoriety = CalculatedNotoriety;
                    return (intCalculatedNotoriety >= 0
                               ? strSpace + "+" + strSpace +
                                 intCalculatedNotoriety.ToString(GlobalSettings.CultureInfo)
                               : strSpace + "-" + strSpace +
                                 (-intCalculatedNotoriety).ToString(GlobalSettings.CultureInfo)) + strSpace + "=" +
                           strSpace + TotalNotoriety.ToString(GlobalSettings.CultureInfo);
                }
            }
        }

        public async Task<string> GetCareerDisplayNotorietyAsync(CancellationToken token = default)
        {
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intCalculatedNotoriety = await GetCalculatedNotorietyAsync(token).ConfigureAwait(false);
                return (intCalculatedNotoriety >= 0
                           ? strSpace + "+" + strSpace + intCalculatedNotoriety.ToString(GlobalSettings.CultureInfo)
                           : strSpace + "-" + strSpace +
                             (-intCalculatedNotoriety).ToString(GlobalSettings.CultureInfo)) +
                       strSpace + "=" + strSpace +
                       (await GetTotalNotorietyAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Tooltip to use for Notoriety total.
        /// </summary>
        public string NotorietyTooltip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdReturn))
                {
                    using (LockObject.EnterReadLock())
                    {
                        sbdReturn.Append(Notoriety.ToString(GlobalSettings.CultureInfo));

                        foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.Notoriety))
                        {
                            sbdReturn.Append(strSpace, '+', strSpace)
                                     .Append(GetObjectName(objImprovement), strSpace, '(')
                                     .Append(objImprovement.Value.ToString(GlobalSettings.CultureInfo), ')');
                        }

                        int intBurnedStreetCred = BurntStreetCred;
                        if (intBurnedStreetCred != 0)
                            sbdReturn.Append(strSpace, '-', strSpace)
                                     .Append(LanguageManager.GetString("String_BurntStreetCred"),
                                         strSpace, '(')
                                     .Append((intBurnedStreetCred / 2).ToString(GlobalSettings.CultureInfo), ')');
                    }

                    return sbdReturn.ToString();
                }
            }
        }

        /// <summary>
        /// Tooltip to use for Notoriety total.
        /// </summary>
        public async Task<string> GetNotorietyTooltipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdReturn))
            {
                IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    sbdReturn.Append(Notoriety.ToString(GlobalSettings.CultureInfo));

                    foreach (Improvement objImprovement in await ImprovementManager
                                 .GetCachedImprovementListForValueOfAsync(this, Improvement.ImprovementType.Notoriety,
                                     token: token).ConfigureAwait(false))
                    {
                        sbdReturn.Append(strSpace, '+', strSpace)
                            .Append(await GetObjectNameAsync(objImprovement, token: token).ConfigureAwait(false)).Append(strSpace, '(')
                            .Append(objImprovement.Value.ToString(GlobalSettings.CultureInfo), ')');
                    }

                    int intBurnedStreetCred = await GetBurntStreetCredAsync(token).ConfigureAwait(false);
                    if (intBurnedStreetCred != 0)
                        sbdReturn.Append(strSpace, '-', strSpace)
                            .Append(await LanguageManager.GetStringAsync("String_BurntStreetCred", token: token).ConfigureAwait(false))
                            .Append(strSpace, '(')
                            .Append((intBurnedStreetCred / 2).ToString(GlobalSettings.CultureInfo), ')');
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }

                return sbdReturn.ToString();
            }
        }

        /// <summary>
        /// Amount of Public Awareness the character has earned through standard means.
        /// </summary>
        public int CalculatedPublicAwareness
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    int intReturn = ImprovementManager.ValueOf(this, Improvement.ImprovementType.PublicAwareness)
                                                      .StandardRound();
                    if (Settings.UseCalculatedPublicAwareness)
                    {
                        // Public Awareness is calculated as (Street Cred + Notoriety) / 3, rounded down.
                        intReturn += (TotalStreetCred + TotalNotoriety) / 3;
                    }

                    return intReturn;
                }
            }
        }

        /// <summary>
        /// Amount of Public Awareness the character has earned through standard means.
        /// </summary>
        public async Task<int> GetCalculatedPublicAwarenessAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intReturn =
                    (await ImprovementManager
                        .ValueOfAsync(this, Improvement.ImprovementType.PublicAwareness, token: token)
                        .ConfigureAwait(false)).StandardRound();
                if (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetUseCalculatedPublicAwarenessAsync(token).ConfigureAwait(false))
                {
                    // Public Awareness is calculated as (Street Cred + Notoriety) / 3, rounded down.
                    intReturn += (await GetTotalStreetCredAsync(token).ConfigureAwait(false) +
                                  await GetTotalNotorietyAsync(token).ConfigureAwait(false)) / 3;
                }

                return intReturn;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's total amount of Public Awareness (earned + GM awarded).
        /// </summary>
        public int TotalPublicAwareness
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    int intReturn = PublicAwareness + CalculatedPublicAwareness;
                    if (intReturn >= 1 && Erased)
                        return 1;
                    return intReturn;
                }
            }
        }

        /// <summary>
        /// Character's total amount of Public Awareness (earned + GM awarded).
        /// </summary>
        public async Task<int> GetTotalPublicAwarenessAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intReturn = await GetPublicAwarenessAsync(token).ConfigureAwait(false) +
                                await GetCalculatedPublicAwarenessAsync(token).ConfigureAwait(false);
                if (intReturn >= 1 && await GetErasedAsync(token).ConfigureAwait(false))
                    return 1;
                return intReturn;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string CareerDisplayPublicAwareness
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (LockObject.EnterReadLock())
                {
                    int intTotalPublicAwareness = TotalPublicAwareness;
                    int intCalculatedPublicAwareness = CalculatedPublicAwareness;
                    return (intCalculatedPublicAwareness >= 0
                               ? strSpace + "+" + strSpace +
                                 intCalculatedPublicAwareness.ToString(GlobalSettings.CultureInfo)
                               : strSpace + "-" + strSpace +
                                 (-intCalculatedPublicAwareness).ToString(GlobalSettings.CultureInfo)) + strSpace +
                           "=" + strSpace + intTotalPublicAwareness.ToString(GlobalSettings.CultureInfo);
                }
            }
        }

        public async Task<string> GetCareerDisplayPublicAwarenessAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intTotalPublicAwareness = await GetTotalPublicAwarenessAsync(token).ConfigureAwait(false);
                int intCalculatedPublicAwareness = await GetCalculatedPublicAwarenessAsync(token).ConfigureAwait(false);
                return (intCalculatedPublicAwareness >= 0
                           ? strSpace + "+" + strSpace +
                             intCalculatedPublicAwareness.ToString(GlobalSettings.CultureInfo)
                           : strSpace + "-" + strSpace +
                             (-intCalculatedPublicAwareness).ToString(GlobalSettings.CultureInfo)) + strSpace +
                       "=" + strSpace + intTotalPublicAwareness.ToString(GlobalSettings.CultureInfo);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Public Awareness Tooltip.
        /// </summary>
        public string PublicAwarenessTooltip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdReturn))
                {
                    using (LockObject.EnterReadLock())
                    {
                        sbdReturn.Append(PublicAwareness.ToString(GlobalSettings.CultureInfo));

                        foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.PublicAwareness))
                        {
                            sbdReturn.Append(strSpace, '+', strSpace)
                                     .Append(GetObjectName(objImprovement), strSpace, '(')
                                     .Append(objImprovement.Value.ToString(GlobalSettings.CultureInfo), ')');
                        }

                        if (Settings.UseCalculatedPublicAwareness)
                        {
                            sbdReturn.Append(strSpace, '+').Append(strSpace, '[')
                                     .Append(LanguageManager.GetString("String_StreetCred"), strSpace)
                                     .Append('+', strSpace).Append(LanguageManager.GetString("String_Notoriety"), ']')
                                     .Append(strSpace, '÷', strSpace)
                                     .Append(3.ToString(GlobalSettings.CultureInfo)).Append(strSpace, '(')
                                     .Append(((TotalStreetCred + TotalNotoriety) / 3).ToString(
                                                 GlobalSettings.CultureInfo), ')');
                        }

                        if (Erased)
                        {
                            int intTotalPublicAwareness = PublicAwareness + CalculatedPublicAwareness;
                            if (intTotalPublicAwareness > 1)
                            {
                                string strErasedString = Qualities.FirstOrDefault(x => x.Name == "Erased")
                                                                  ?.CurrentDisplayNameShort;
                                if (string.IsNullOrEmpty(strErasedString))
                                {
                                    XPathNavigator xmlErasedQuality = LoadDataXPath("qualities.xml")
                                        .SelectSingleNodeAndCacheExpression("chummer/qualities/quality[name = \"Erased\"]");
                                    if (xmlErasedQuality != null)
                                    {
                                        strErasedString
                                            = xmlErasedQuality.SelectSingleNodeAndCacheExpression("translate")?.Value
                                              ?? "Erased";
                                    }
                                }

                                sbdReturn.Append(strSpace, '-', strSpace).Append(strErasedString, strSpace)
                                         .Append('(', (intTotalPublicAwareness - 1).ToString(GlobalSettings.CultureInfo), ')');
                            }
                        }
                    }

                    return sbdReturn.ToString();
                }
            }
        }

        /// <summary>
        /// Public Awareness Tooltip.
        /// </summary>
        public async Task<string> GetPublicAwarenessTooltipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                       out StringBuilder sbdReturn))
            {
                IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    sbdReturn.Append((await GetPublicAwarenessAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo));

                    foreach (Improvement objImprovement in await ImprovementManager
                                 .GetCachedImprovementListForValueOfAsync(this,
                                     Improvement.ImprovementType.PublicAwareness, token: token).ConfigureAwait(false))
                    {
                        sbdReturn.Append(strSpace, '+', strSpace)
                            .Append(await GetObjectNameAsync(objImprovement, token: token).ConfigureAwait(false))
                            .Append(strSpace, '(')
                            .Append(objImprovement.Value.ToString(GlobalSettings.CultureInfo), ')');
                    }

                    if (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetUseCalculatedPublicAwarenessAsync(token).ConfigureAwait(false))
                    {
                        sbdReturn.Append(strSpace, '+').Append(strSpace, '[')
                            .Append(await LanguageManager.GetStringAsync("String_StreetCred", token: token)
                                .ConfigureAwait(false)).Append(strSpace, '+', strSpace)
                            .Append(await LanguageManager.GetStringAsync("String_Notoriety", token: token)
                                .ConfigureAwait(false), ']').Append(strSpace, '÷', strSpace)
                            .Append(3.ToString(GlobalSettings.CultureInfo)).Append(strSpace, '(').Append(
                                ((await GetTotalStreetCredAsync(token).ConfigureAwait(false) +
                                  await GetTotalNotorietyAsync(token).ConfigureAwait(false)) / 3)
                                .ToString(GlobalSettings.CultureInfo), ')');
                    }

                    if (await GetErasedAsync(token).ConfigureAwait(false))
                    {
                        int intTotalPublicAwareness = await GetPublicAwarenessAsync(token).ConfigureAwait(false) +
                                                      await GetCalculatedPublicAwarenessAsync(token)
                                                          .ConfigureAwait(false);
                        if (intTotalPublicAwareness > 1)
                        {
                            string strErasedString = Qualities.FirstOrDefault(x => x.Name == "Erased")
                                ?.CurrentDisplayNameShort;
                            if (string.IsNullOrEmpty(strErasedString))
                            {
                                XPathNavigator xmlErasedQuality =
                                    (await LoadDataXPathAsync("qualities.xml", token: token).ConfigureAwait(false))
                                    .SelectSingleNodeAndCacheExpression("chummer/qualities/quality[name = \"Erased\"]", token);
                                if (xmlErasedQuality != null)
                                {
                                    strErasedString =
                                        xmlErasedQuality.SelectSingleNodeAndCacheExpression("translate", token)?.Value ??
                                        "Erased";
                                }
                            }

                            sbdReturn.Append(strSpace, '-', strSpace).Append(strErasedString)
                                .Append(strSpace, '(')
                                .Append((intTotalPublicAwareness - 1).ToString(GlobalSettings.CultureInfo), ')');
                        }
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }

                return sbdReturn.ToString();
            }
        }

        #endregion Reputation

        #region List Properties

        /// <summary>
        /// Improvements.
        /// </summary>
        public ThreadSafeObservableCollection<Improvement> Improvements
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstImprovements;
            }
        }

        /// <summary>
        /// Improvements.
        /// </summary>
        public async Task<ThreadSafeObservableCollection<Improvement>> GetImprovementsAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstImprovements;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Mentor spirits.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<MentorSpirit> MentorSpirits
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstMentorSpirits;
            }
        }

        public async Task<ThreadSafeObservableCollection<MentorSpirit>> GetMentorSpiritsAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstMentorSpirits;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Contacts and Enemies.
        /// </summary>
        public ThreadSafeObservableCollection<Contact> Contacts
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstContacts;
            }
        }

        public async Task<ThreadSafeObservableCollection<Contact>> GetContactsAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstContacts;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Spirits and Sprites.
        /// </summary>
        public ThreadSafeObservableCollection<Spirit> Spirits
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstSpirits;
            }
        }

        /// <summary>
        /// Spirits and Sprites.
        /// </summary>
        public async Task<ThreadSafeObservableCollection<Spirit>> GetSpiritsAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstSpirits;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Magician Spells.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<Spell> Spells
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstSpells;
            }
        }

        /// <summary>
        /// Magician Spells.
        /// </summary>
        public async Task<ThreadSafeObservableCollection<Spell>> GetSpellsAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstSpells;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Sustained Spells
        /// </summary>
        public ThreadSafeObservableCollection<SustainedObject> SustainedCollection
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstSustainedObjects;
            }
        }

        /// <summary>
        /// Sustained Spells.
        /// </summary>
        public async Task<ThreadSafeObservableCollection<SustainedObject>> GetSustainedCollectionAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstSustainedObjects;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Foci.
        /// </summary>
        public ThreadSafeList<Focus> Foci
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstFoci;
            }
        }

        /// <summary>
        /// Foci.
        /// </summary>
        public async Task<ThreadSafeList<Focus>> GetFociAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstFoci;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Stacked Foci.
        /// </summary>
        public ThreadSafeList<StackedFocus> StackedFoci
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstStackedFoci;
            }
        }

        /// <summary>
        /// Stacked Foci.
        /// </summary>
        public async Task<ThreadSafeList<StackedFocus>> GetStackedFociAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstStackedFoci;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Method to check and potentially override an improvement value based on the presence of power foci (since only one focus can add its Force to a dice pool)
        /// </summary>
        public Improvement GetPowerFocusAdjustedImprovementValue(Improvement objImprovement)
        {
            using (LockObject.EnterReadLock())
            {
                List<Improvement> lstRelevantImprovements = new List<Improvement>(Improvements.Count);
                foreach (Improvement objLoopImprovement in Improvements)
                {
                    if (objLoopImprovement.Enabled
                        && objLoopImprovement.ImproveSource == Improvement.ImprovementSource.Gear
                        && objLoopImprovement.UniqueName == "precedence0"
                        && objLoopImprovement.ImprovedName.Contains("MAG")
                        && (objLoopImprovement.ImproveType == Improvement.ImprovementType.Attribute
                            || objLoopImprovement.ImproveType == Improvement.ImprovementType.SkillAttribute
                            || objLoopImprovement.ImproveType == Improvement.ImprovementType.SkillLinkedAttribute))
                    {
                        lstRelevantImprovements.Add(objLoopImprovement);
                    }
                }
                List<Focus> lstPowerFoci;
                using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                out HashSet<string> setPotentialPowerFociImprovementSources))
                {
                    foreach (Improvement objLoopImprovement in lstRelevantImprovements)
                        setPotentialPowerFociImprovementSources.Add(objLoopImprovement.SourceName);
                    lstPowerFoci = Foci.FindAll(x => x.GearObject?.Bonded == true
                        && setPotentialPowerFociImprovementSources.Contains(x.GearObject.InternalId));
                }
                if (lstPowerFoci.Count > 0)
                {
                    using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                out HashSet<string> setPowerFociIds))
                    {
                        foreach (Focus objFocus in lstPowerFoci)
                            setPowerFociIds.Add(objFocus.GearObject.InternalId);
                        for (int i = lstRelevantImprovements.Count - 1; i >= 0; --i)
                        {
                            if (!setPowerFociIds.Contains(lstRelevantImprovements[i].SourceName))
                                lstRelevantImprovements.RemoveAt(i);
                        }
                    }
                    if (lstRelevantImprovements.Count > 0)
                    {
                        // get any bonded foci that add to the base magic stat and return the highest rated one's rating
                        decimal decMaxFocusBonus = lstRelevantImprovements.Max(x => x.Rating * (x.Value + x.Augmented));
                        if (decMaxFocusBonus > 0)
                        {
                            // If our focus is higher, add in a partial bonus
                            if (decMaxFocusBonus < objImprovement.Value)
                            {
                                // This is hackz -- because we don't want to lose the original improvement's value
                                // we instantiate a fake version of the improvement that isn't saved to represent the diff
                                return new Improvement(this)
                                {
                                    SourceName = objImprovement.SourceName,
                                    ImprovedName = objImprovement.ImprovedName,
                                    ImproveSource = objImprovement.ImproveSource,
                                    ImproveType = objImprovement.ImproveType,
                                    Value = objImprovement.Value - decMaxFocusBonus
                                };
                            }
                            // Power focus rating is higher, return null because we do not want to apply the given improvement
                            return null;
                        }
                    }
                }

                return objImprovement;
            }
        }

        /// <summary>
        /// Method to check and potentially override an improvement value based on the presence of power foci (since only one focus can add its Force to a dice pool)
        /// </summary>
        public async Task<Improvement> GetPowerFocusAdjustedImprovementValueAsync(Improvement objImprovement, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                List<Improvement> lstRelevantImprovements = new List<Improvement>(await Improvements.GetCountAsync(token).ConfigureAwait(false));
                await Improvements.ForEachAsync(objLoopImprovement =>
                {
                    if (objLoopImprovement.Enabled
                        && objLoopImprovement.ImproveSource == Improvement.ImprovementSource.Gear
                        && objLoopImprovement.UniqueName == "precedence0"
                        && objLoopImprovement.ImprovedName.Contains("MAG")
                        && (objLoopImprovement.ImproveType == Improvement.ImprovementType.Attribute
                            || objLoopImprovement.ImproveType == Improvement.ImprovementType.SkillAttribute
                            || objLoopImprovement.ImproveType == Improvement.ImprovementType.SkillLinkedAttribute))
                    {
                        lstRelevantImprovements.Add(objLoopImprovement);
                    }
                }, token).ConfigureAwait(false);
                List<Focus> lstPowerFoci;
                using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                out HashSet<string> setPotentialPowerFociImprovementSources))
                {
                    foreach (Improvement objLoopImprovement in lstRelevantImprovements)
                        setPotentialPowerFociImprovementSources.Add(objLoopImprovement.SourceName);
                    lstPowerFoci = await Foci.FindAllAsync(x => x.GearObject?.Bonded == true
                        && setPotentialPowerFociImprovementSources.Contains(x.GearObject.InternalId), token).ConfigureAwait(false);
                }
                if (lstPowerFoci.Count > 0)
                {
                    using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                out HashSet<string> setPowerFociIds))
                    {
                        foreach (Focus objFocus in lstPowerFoci)
                            setPowerFociIds.Add(objFocus.GearObject.InternalId);
                        for (int i = lstRelevantImprovements.Count - 1; i >= 0; --i)
                        {
                            if (!setPowerFociIds.Contains(lstRelevantImprovements[i].SourceName))
                                lstRelevantImprovements.RemoveAt(i);
                        }
                    }
                    if (lstRelevantImprovements.Count > 0)
                    {
                        // get any bonded foci that add to the base magic stat and return the highest rated one's rating
                        decimal decMaxFocusBonus = lstRelevantImprovements.Max(x => x.Rating * (x.Value + x.Augmented));
                        if (decMaxFocusBonus > 0)
                        {
                            // If our focus is higher, add in a partial bonus
                            if (decMaxFocusBonus < objImprovement.Value)
                            {
                                // This is hackz -- because we don't want to lose the original improvement's value
                                // we instantiate a fake version of the improvement that isn't saved to represent the diff
                                Improvement objPlaceholder = new Improvement(this)
                                {
                                    SourceName = objImprovement.SourceName,
                                    ImprovedName = objImprovement.ImprovedName,
                                    ImproveSource = objImprovement.ImproveSource,
                                    ImproveType = objImprovement.ImproveType
                                };
                                await objPlaceholder.SetValueAsync(objImprovement.Value - decMaxFocusBonus, token).ConfigureAwait(false);
                                return objPlaceholder;
                            }
                            // Power focus rating is higher, return null because we do not want to apply the given improvement
                            return null;
                        }
                    }
                }

                return objImprovement;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Adept Powers.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeBindingList<Power> Powers
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstPowers;
            }
        }

        /// <summary>
        /// Adept Powers.
        /// </summary>
        public async Task<ThreadSafeBindingList<Power>> GetPowersAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstPowers;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Technomancer Complex Forms.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<ComplexForm> ComplexForms
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstComplexForms;
            }
        }

        /// <summary>
        /// Technomancer Complex Forms.
        /// </summary>
        public async Task<ThreadSafeObservableCollection<ComplexForm>> GetComplexFormsAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstComplexForms;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// AI Programs and Advanced Programs
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<AIProgram> AIPrograms
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstAIPrograms;
            }
        }

        /// <summary>
        /// AI Programs and Advanced Programs
        /// </summary>
        public async Task<ThreadSafeObservableCollection<AIProgram>> GetAIProgramsAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstAIPrograms;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Martial Arts.
        /// </summary>
        public ThreadSafeObservableCollection<MartialArt> MartialArts
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstMartialArts;
            }
        }

        /// <summary>
        /// Martial Arts.
        /// </summary>
        public async Task<ThreadSafeObservableCollection<MartialArt>> GetMartialArtsAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstMartialArts;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Limit Modifiers.
        /// </summary>
        public ThreadSafeObservableCollection<LimitModifier> LimitModifiers
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstLimitModifiers;
            }
        }

        /// <summary>
        /// Limit Modifiers.
        /// </summary>
        public async Task<ThreadSafeObservableCollection<LimitModifier>> GetLimitModifiersAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstLimitModifiers;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Armor.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<Armor> Armor
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstArmor;
            }
        }

        /// <summary>
        /// Armor.
        /// </summary>
        public async Task<ThreadSafeObservableCollection<Armor>> GetArmorAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstArmor;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Cyberware and Bioware.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<Cyberware> Cyberware
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstCyberware;
            }
        }

        /// <summary>
        /// Cyberware and Bioware.
        /// </summary>
        public async Task<ThreadSafeObservableCollection<Cyberware>> GetCyberwareAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstCyberware;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Weapons.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<Weapon> Weapons
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstWeapons;
            }
        }

        /// <summary>
        /// Weapons.
        /// </summary>
        public async Task<ThreadSafeObservableCollection<Weapon>> GetWeaponsAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstWeapons;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Lifestyles.
        /// </summary>
        public ThreadSafeObservableCollection<Lifestyle> Lifestyles
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstLifestyles;
            }
        }

        /// <summary>
        /// Lifestyles.
        /// </summary>
        public async Task<ThreadSafeObservableCollection<Lifestyle>> GetLifestylesAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstLifestyles;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Gear.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<Gear> Gear
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstGear;
            }
        }

        /// <summary>
        /// Gear.
        /// </summary>
        public async Task<ThreadSafeObservableCollection<Gear>> GetGearAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstGear;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Vehicles.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<Vehicle> Vehicles
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstVehicles;
            }
        }

        /// <summary>
        /// Vehicles.
        /// </summary>
        public async Task<ThreadSafeObservableCollection<Vehicle>> GetVehiclesAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstVehicles;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Metamagics and Echoes.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<Metamagic> Metamagics
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstMetamagics;
            }
        }

        /// <summary>
        /// Metamagics and Echoes.
        /// </summary>
        public async Task<ThreadSafeObservableCollection<Metamagic>> GetMetamagicsAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstMetamagics;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Enhancements.
        /// </summary>
        public ThreadSafeObservableCollection<Enhancement> Enhancements
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstEnhancements;
            }
        }

        /// <summary>
        /// Enhancements.
        /// </summary>
        public async Task<ThreadSafeObservableCollection<Enhancement>> GetEnhancementsAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstEnhancements;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Arts.
        /// </summary>
        public ThreadSafeObservableCollection<Art> Arts
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstArts;
            }
        }

        /// <summary>
        /// Arts.
        /// </summary>
        public async Task<ThreadSafeObservableCollection<Art>> GetArtsAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstArts;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Critter Powers.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<CritterPower> CritterPowers
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstCritterPowers;
            }
        }

        /// <summary>
        /// Critter Powers.
        /// </summary>
        public async Task<ThreadSafeObservableCollection<CritterPower>> GetCritterPowersAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstCritterPowers;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Initiation and Submersion Grades.
        /// </summary>
        public ThreadSafeObservableCollection<InitiationGrade> InitiationGrades
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstInitiationGrades;
            }
        }

        /// <summary>
        /// Initiation and Submersion Grades.
        /// </summary>
        public async Task<ThreadSafeObservableCollection<InitiationGrade>> GetInitiationGradesAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstInitiationGrades;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Expenses (Karma and Nuyen).
        /// </summary>
        public ThreadSafeObservableCollection<ExpenseLogEntry> ExpenseEntries
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstExpenseLog;
            }
        }

        /// <summary>
        /// Expenses (Karma and Nuyen).
        /// </summary>
        public async Task<ThreadSafeObservableCollection<ExpenseLogEntry>> GetExpenseEntriesAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstExpenseLog;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Qualities (Positive and Negative).
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<Quality> Qualities
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstQualities;
            }
        }

        /// <summary>
        /// Qualities (Positive and Negative).
        /// </summary>
        public async Task<ThreadSafeObservableCollection<Quality>> GetQualitiesAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstQualities;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /*
        /// <summary>
        /// Life modules
        /// </summary>
        public List<LifeModule> LifeModules
        {
            get { return _lstLifeModules; }
        }
        */

        /// <summary>
        /// Gear Locations.
        /// </summary>
        public ThreadSafeObservableCollection<Location> GearLocations
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstGearLocations;
            }
        }

        /// <summary>
        /// Gear Locations.
        /// </summary>
        public async Task<ThreadSafeObservableCollection<Location>> GetGearLocationsAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstGearLocations;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Armor Bundles.
        /// </summary>
        public ThreadSafeObservableCollection<Location> ArmorLocations
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstArmorLocations;
            }
        }

        /// <summary>
        /// Armor Locations.
        /// </summary>
        public async Task<ThreadSafeObservableCollection<Location>> GetArmorLocationsAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstArmorLocations;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Vehicle Locations.
        /// </summary>
        public ThreadSafeObservableCollection<Location> VehicleLocations
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstVehicleLocations;
            }
        }

        /// <summary>
        /// Vehicle Locations.
        /// </summary>
        public async Task<ThreadSafeObservableCollection<Location>> GetVehicleLocationsAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstVehicleLocations;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Weapon Locations.
        /// </summary>
        public ThreadSafeObservableCollection<Location> WeaponLocations
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstWeaponLocations;
            }
        }

        /// <summary>
        /// Weapon Locations.
        /// </summary>
        public async Task<ThreadSafeObservableCollection<Location>> GetWeaponLocationsAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstWeaponLocations;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Improvement Groups.
        /// </summary>
        public ThreadSafeObservableCollection<string> ImprovementGroups
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstImprovementGroups;
            }
        }

        /// <summary>
        /// Improvement Groups.
        /// </summary>
        public async Task<ThreadSafeObservableCollection<string>> GetImprovementGroupsAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstImprovementGroups;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Calendar.
        /// </summary>
        public ThreadSafeBindingList<CalendarWeek> Calendar
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstCalendar;
            }
        }

        /// <summary>
        /// Calendar.
        /// </summary>
        public async Task<ThreadSafeBindingList<CalendarWeek>> GetCalendarAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstCalendar;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Take out the list of internal IDs that need their improvements re-applied (and then immediately re-apply them).
        /// </summary>
        public ConcurrentBag<string> TakeInternalIdsNeedingReapplyImprovements(CancellationToken token = default)
        {
            // Only need read lock because we use interlocked to make sure access is still write-safe
            using (LockObject.EnterReadLock(token))
                return Interlocked.Exchange(ref _lstInternalIdsNeedingReapplyImprovements, null);
        }

        /// <summary>
        /// Take out the list of internal IDs that need their improvements re-applied (and then immediately re-apply them).
        /// </summary>
        public async Task<ConcurrentBag<string>> TakeInternalIdsNeedingReapplyImprovementsAsync(CancellationToken token = default)
        {
            // Only need read lock because we use interlocked to make sure access is still write-safe
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return Interlocked.Exchange(ref _lstInternalIdsNeedingReapplyImprovements, null);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        #endregion List Properties

        #region Armor Properties

        public int GetArmorRating(Improvement.ImprovementType eDamageType = Improvement.ImprovementType.Armor)
        {
            return GetArmorRatingWithImprovement(eDamageType, out int _, out List<Improvement> _);
        }

        public int GetArmorRatingWithImprovement(Improvement.ImprovementType eDamageType, out int intFromEquippedArmorImprovements, out List<Improvement> lstUsedImprovements)
        {
            intFromEquippedArmorImprovements = 0;
            if (eDamageType == Improvement.ImprovementType.None)
            {
                lstUsedImprovements = new List<Improvement>();
                return 0;
            }

            using (LockObject.EnterReadLock())
            {
                List<Armor> lstArmorsToConsider = Armor.Where(objArmor => objArmor.Equipped).ToList();
                decimal decBaseArmorImprovement
                    = ImprovementManager.ValueOf(this, eDamageType, out lstUsedImprovements);
                if (eDamageType != Improvement.ImprovementType.Armor)
                {
                    decBaseArmorImprovement += ImprovementManager.ValueOf(
                        this, Improvement.ImprovementType.Armor, out List<Improvement> lstUsedImprovementsExtra);
                    lstUsedImprovements.AddRange(lstUsedImprovementsExtra);
                }

                if (lstArmorsToConsider.Count == 0)
                    return decBaseArmorImprovement.StandardRound();
                decimal decGeneralArmorImprovementValue = decBaseArmorImprovement;
                Dictionary<Armor, decimal> dicArmorImprovementValues
                    = lstArmorsToConsider.ToDictionary(x => x, y => decBaseArmorImprovement);
                foreach (Improvement objImprovement in lstUsedImprovements)
                {
                    if (objImprovement.ImproveSource != Improvement.ImprovementSource.Armor &&
                        objImprovement.ImproveSource != Improvement.ImprovementSource.ArmorMod)
                        continue;
                    Armor objSourceArmor =
                        lstArmorsToConsider.Find(x => x.InternalId == objImprovement.SourceName)
                        ?? lstArmorsToConsider.FindArmorMod(objImprovement.SourceName)?.Parent;
                    if (objSourceArmor == null)
                        continue;
                    decGeneralArmorImprovementValue -= objImprovement.Value;
                    foreach (Armor objArmor in lstArmorsToConsider)
                    {
                        if (objArmor != objSourceArmor)
                            dicArmorImprovementValues[objArmor] -= objImprovement.Value;
                    }
                }

                int intAverageStrength = Settings.UncappedArmorAccessoryBonuses ? int.MaxValue : STR.TotalValue;

                // Run through the list of Armor currently worn and look at armors that start with '+' since they stack with the highest Armor, but only up to STR.
                Dictionary<Armor, int> dicArmorStackingValues
                    = lstArmorsToConsider.ToDictionary(x => x, y => 0);
                int intNakedStackingValue = 0;
                foreach (Armor objArmor in lstArmorsToConsider)
                {
                    if (!objArmor.ArmorValue.StartsWith('+')
                        && !objArmor.ArmorValue.StartsWith('-')
                        && !objArmor.ArmorOverrideValue.StartsWith('+')
                        && !objArmor.ArmorOverrideValue.StartsWith('-'))
                        continue;
                    string strCustomFitName = objArmor.ArmorMods.FirstOrDefault(x => x.Name == "Custom Fit (Stack)" && x.Equipped)?.Extra ?? string.Empty;

                    foreach (Armor objInnerArmor in lstArmorsToConsider)
                    {
                        if (objInnerArmor == objArmor
                            || objInnerArmor.ArmorValue.StartsWith('+')
                            || objInnerArmor.ArmorValue.StartsWith('-'))
                            continue;
                        if (string.IsNullOrEmpty(strCustomFitName) || strCustomFitName != objInnerArmor.Name)
                        {
                            if (objArmor.ArmorValue.StartsWith('+') || objArmor.ArmorValue.StartsWith('-'))
                                dicArmorStackingValues[objInnerArmor] += objArmor.GetTotalArmor();
                        }
                        else if (objArmor.ArmorOverrideValue.StartsWith('+') || objArmor.ArmorOverrideValue.StartsWith('-'))
                        {
                            dicArmorStackingValues[objInnerArmor] += objArmor.GetTotalOverrideArmor();
                        }
                    }

                    if (intNakedStackingValue < intAverageStrength
                        && (objArmor.ArmorValue.StartsWith('+') || objArmor.ArmorValue.StartsWith('-')))
                        intNakedStackingValue
                            = Math.Min(intNakedStackingValue + objArmor.GetTotalArmor(), intAverageStrength);
                }

                // Run through list of Armor again to cap off any whose stacking bonuses are greater than STR
                foreach (Armor objArmor in lstArmorsToConsider)
                {
                    if (dicArmorStackingValues.TryGetValue(objArmor, out int intStack) && intStack > intAverageStrength)
                        dicArmorStackingValues[objArmor] = intAverageStrength;
                }

                // Run through the list of Armor a third time to retrieve the highest total Armor rating.
                Armor objHighestArmor = null;
                int intHighest = 0;
                foreach (Armor objArmor in lstArmorsToConsider)
                {
                    if (objArmor.ArmorValue.StartsWith('+')
                        || objArmor.ArmorValue.StartsWith('-'))
                        continue;

                    int intArmorValue = objArmor.GetTotalArmor() + dicArmorStackingValues[objArmor] + dicArmorImprovementValues[objArmor].StandardRound();
                    if (intArmorValue > intHighest)
                    {
                        intHighest = intArmorValue;
                        intFromEquippedArmorImprovements = (dicArmorImprovementValues[objArmor] - decGeneralArmorImprovementValue).StandardRound();
                        objHighestArmor = objArmor;
                    }
                }

                int intArmor = objHighestArmor != null
                    ? intHighest
                    : intNakedStackingValue + decGeneralArmorImprovementValue.StandardRound();

                return intArmor;
            }
        }

        public async Task<int> GetArmorRatingAsync(Improvement.ImprovementType eDamageType = Improvement.ImprovementType.Armor, CancellationToken token = default)
        {
            return (await GetArmorRatingWithImprovementAsync(eDamageType, token).ConfigureAwait(false)).Item1;
        }

        public async Task<ValueTuple<int, int, List<Improvement>>> GetArmorRatingWithImprovementAsync(Improvement.ImprovementType eDamageType, CancellationToken token = default)
        {
            if (eDamageType == Improvement.ImprovementType.None)
            {
                return new ValueTuple<int, int, List<Improvement>>(0, 0, new List<Improvement>());
            }

            int intFromEquippedArmorImprovements = 0;
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                List<Armor> lstArmorsToConsider = await (await GetArmorAsync(token).ConfigureAwait(false)).ToListAsync(objArmor => objArmor.Equipped, token: token).ConfigureAwait(false);
                (decimal decBaseArmorImprovement, List<Improvement> lstUsedImprovements)
                    = await ImprovementManager.ValueOfTupleAsync(this, eDamageType, token: token).ConfigureAwait(false);
                if (eDamageType != Improvement.ImprovementType.Armor)
                {
                    (decimal decExtra, List<Improvement> lstUsedImprovementsExtra)
                        = await ImprovementManager.ValueOfTupleAsync(this, Improvement.ImprovementType.Armor, token: token).ConfigureAwait(false);
                    decBaseArmorImprovement += decExtra;
                    lstUsedImprovements.AddRange(lstUsedImprovementsExtra);
                }

                if (lstArmorsToConsider.Count == 0)
                    return new ValueTuple<int, int, List<Improvement>>(decBaseArmorImprovement.StandardRound(), intFromEquippedArmorImprovements, lstUsedImprovements);
                decimal decGeneralArmorImprovementValue = decBaseArmorImprovement;
                Dictionary<Armor, decimal> dicArmorImprovementValues
                    = lstArmorsToConsider.ToDictionary(x => x, y => decBaseArmorImprovement);
                foreach (Improvement objImprovement in lstUsedImprovements)
                {
                    if (objImprovement.ImproveSource != Improvement.ImprovementSource.Armor &&
                        objImprovement.ImproveSource != Improvement.ImprovementSource.ArmorMod)
                        continue;
                    Armor objSourceArmor =
                        lstArmorsToConsider.Find(x => x.InternalId == objImprovement.SourceName)
                        ?? (await lstArmorsToConsider.FindArmorModAsync(objImprovement.SourceName, token).ConfigureAwait(false))?.Parent;
                    if (objSourceArmor == null)
                        continue;
                    decGeneralArmorImprovementValue -= objImprovement.Value;
                    foreach (Armor objArmor in lstArmorsToConsider)
                    {
                        if (objArmor != objSourceArmor)
                            dicArmorImprovementValues[objArmor] -= objImprovement.Value;
                    }
                }

                int intAverageStrength = await (await GetSettingsAsync(token).ConfigureAwait(false)).GetUncappedArmorAccessoryBonusesAsync(token).ConfigureAwait(false)
                    ? int.MaxValue
                    : await (await GetAttributeAsync("STR", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false);

                // Run through the list of Armor currently worn and look at armors that start with '+' since they stack with the highest Armor, but only up to STR.
                Dictionary<Armor, int> dicArmorStackingValues
                    = lstArmorsToConsider.ToDictionary(x => x, y => 0);
                int intNakedStackingValue = 0;
                foreach (Armor objArmor in lstArmorsToConsider)
                {
                    if (!objArmor.ArmorValue.StartsWith('+')
                        && !objArmor.ArmorValue.StartsWith('-')
                        && !objArmor.ArmorOverrideValue.StartsWith('+')
                        && !objArmor.ArmorOverrideValue.StartsWith('-'))
                        continue;
                    string strCustomFitName = (await objArmor.ArmorMods.FirstOrDefaultAsync(x => x.Name == "Custom Fit (Stack)" && x.Equipped, token: token).ConfigureAwait(false))?.Extra ?? string.Empty;

                    foreach (Armor objInnerArmor in lstArmorsToConsider)
                    {
                        if (objInnerArmor == objArmor
                            || objInnerArmor.ArmorValue.StartsWith('+')
                            || objInnerArmor.ArmorValue.StartsWith('-'))
                            continue;
                        if (string.IsNullOrEmpty(strCustomFitName) || strCustomFitName != objInnerArmor.Name)
                        {
                            if (objArmor.ArmorValue.StartsWith('+') || objArmor.ArmorValue.StartsWith('-'))
                                dicArmorStackingValues[objInnerArmor] += await objArmor.GetTotalArmorAsync(token: token).ConfigureAwait(false);
                        }
                        else if (objArmor.ArmorOverrideValue.StartsWith('+') || objArmor.ArmorOverrideValue.StartsWith('-'))
                        {
                            dicArmorStackingValues[objInnerArmor] += await objArmor.GetTotalOverrideArmorAsync(token: token).ConfigureAwait(false);
                        }
                    }

                    if (intNakedStackingValue < intAverageStrength
                        && (objArmor.ArmorValue.StartsWith('+') || objArmor.ArmorValue.StartsWith('-')))
                        intNakedStackingValue
                            = Math.Min(intNakedStackingValue + await objArmor.GetTotalArmorAsync(token: token).ConfigureAwait(false), intAverageStrength);
                }

                // Run through list of Armor again to cap off any whose stacking bonuses are greater than STR
                foreach (Armor objArmor in lstArmorsToConsider)
                {
                    if (dicArmorStackingValues.TryGetValue(objArmor, out int intStack) && intStack > intAverageStrength)
                        dicArmorStackingValues[objArmor] = intAverageStrength;
                }

                // Run through the list of Armor a third time to retrieve the highest total Armor rating.
                Armor objHighestArmor = null;
                int intHighest = 0;
                foreach (Armor objArmor in lstArmorsToConsider)
                {
                    if (objArmor.ArmorValue.StartsWith('+')
                        || objArmor.ArmorValue.StartsWith('-'))
                        continue;

                    int intArmorValue = await objArmor.GetTotalArmorAsync(token: token).ConfigureAwait(false) + dicArmorStackingValues[objArmor] + dicArmorImprovementValues[objArmor].StandardRound();
                    if (intArmorValue > intHighest)
                    {
                        intHighest = intArmorValue;
                        intFromEquippedArmorImprovements = (dicArmorImprovementValues[objArmor] - decGeneralArmorImprovementValue).StandardRound();
                        objHighestArmor = objArmor;
                    }
                }

                int intArmor = objHighestArmor != null
                    ? intHighest
                    : intNakedStackingValue + decGeneralArmorImprovementValue.StandardRound();

                return new ValueTuple<int, int, List<Improvement>>(intArmor, intFromEquippedArmorImprovements, lstUsedImprovements);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public int DamageResistancePool
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    int intBody = 0;
                    if (IsAI)
                    {
                        if (HomeNode is Vehicle objVehicle)
                            intBody = objVehicle.TotalBody;
                    }
                    else
                        intBody = BOD.TotalValue;

                    return intBody +
                           TotalArmorRating +
                           ImprovementManager.ValueOf(this, Improvement.ImprovementType.DamageResistance)
                                             .StandardRound();
                }
            }
        }

        public async Task<int> GetDamageResistancePoolAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intBody = 0;
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    if (await GetHomeNodeAsync(token).ConfigureAwait(false) is Vehicle objVehicle)
                        intBody = await objVehicle.GetTotalBodyAsync(token).ConfigureAwait(false);
                }
                else
                    intBody = await (await GetAttributeAsync("BOD", token: token).ConfigureAwait(false))
                        .GetTotalValueAsync(token).ConfigureAwait(false);

                return intBody + await GetTotalArmorRatingAsync(token).ConfigureAwait(false) +
                       (await ImprovementManager
                           .ValueOfAsync(this, Improvement.ImprovementType.DamageResistance, token: token)
                           .ConfigureAwait(false)).StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DamageResistancePoolToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (LockObject.EnterReadLock())
                {
                    int intBody;
                    string strBodyAbbrev;
                    if (IsAI)
                    {
                        intBody = HomeNode is Vehicle objVehicle ? objVehicle.TotalBody : 0;
                        strBodyAbbrev = LanguageManager.GetString("String_VehicleBody");
                    }
                    else
                    {
                        intBody = BOD.TotalValue;
                        strBodyAbbrev = BOD.CurrentDisplayAbbrev;
                    }

                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append(strBodyAbbrev, strSpace, '(')
                                  .Append(intBody.ToString(GlobalSettings.CultureInfo), ')')
                                  .Append(strSpace, '+', strSpace)
                                  .Append(LanguageManager.GetString("Tip_Armor"), strSpace, '(')
                                  .Append(TotalArmorRating.ToString(GlobalSettings.CultureInfo), ')');

                        foreach (Improvement objLoopImprovement in
                                 ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.DamageResistance))
                        {
                            sbdToolTip.Append(strSpace, '+', strSpace)
                                      .Append(GetObjectName(objLoopImprovement), strSpace, '(')
                                      .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo), ')');
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        public async Task<string> GetDamageResistancePoolToolTipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intBody;
                string strBodyAbbrev;
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    intBody = await GetHomeNodeAsync(token).ConfigureAwait(false) is Vehicle objVehicle ? await objVehicle.GetTotalBodyAsync(token).ConfigureAwait(false) : 0;
                    strBodyAbbrev = await LanguageManager.GetStringAsync("String_VehicleBody", token: token).ConfigureAwait(false);
                }
                else
                {
                    CharacterAttrib objBod = await GetAttributeAsync("BOD", token: token).ConfigureAwait(false);
                    intBody = await objBod.GetTotalValueAsync(token).ConfigureAwait(false);
                    strBodyAbbrev = await objBod.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false);
                }

                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                           out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(strBodyAbbrev, strSpace, '(')
                        .Append(intBody.ToString(GlobalSettings.CultureInfo), ')').Append(strSpace, '+')
                        .Append(strSpace, await LanguageManager.GetStringAsync("Tip_Armor", token: token).ConfigureAwait(false), strSpace)
                        .Append('(', (await GetTotalArmorRatingAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')');

                    foreach (Improvement objLoopImprovement in
                             await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                 this, Improvement.ImprovementType.DamageResistance, token: token).ConfigureAwait(false))
                    {
                        sbdToolTip.Append(strSpace, '+', strSpace)
                            .Append(await GetObjectNameAsync(objLoopImprovement, token: token).ConfigureAwait(false)).Append(strSpace)
                            .Append('(', objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo), ')');
                    }

                    return sbdToolTip.ToString();
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public int CurrentCounterspellingDice
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _intCurrentCounterspellingDice;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _intCurrentCounterspellingDice, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        public async Task<int> GetCurrentCounterspellingDiceAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _intCurrentCounterspellingDice;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public async Task SetCurrentCounterspellingDiceAsync(int value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _intCurrentCounterspellingDice, value) != value)
                    await OnPropertyChangedAsync(nameof(CurrentCounterspellingDice), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public int CurrentLiftCarryHits
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _intCurrentLiftCarryHits;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _intCurrentLiftCarryHits, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        public async Task<int> GetCurrentLiftCarryHitsAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _intCurrentLiftCarryHits;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public async Task SetCurrentLiftCarryHitsAsync(int value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _intCurrentLiftCarryHits, value) != value)
                    await OnPropertyChangedAsync(nameof(CurrentLiftCarryHits), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        #region Dodge

        public int Dodge
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return REA.TotalValue + INT.TotalValue + TotalBonusDodgeRating + WoundModifier + SustainingPenalty;
            }
        }

        public async Task<int> GetDodgeAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await (await GetAttributeAsync("REA", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                       + await (await GetAttributeAsync("INT", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                       + await GetTotalBonusDodgeRatingAsync(token).ConfigureAwait(false)
                       + await GetWoundModifierAsync(token).ConfigureAwait(false)
                       + await GetSustainingPenaltyAsync(token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplayDodge => Dodge.ToString(GlobalSettings.CultureInfo);

        public async Task<string> GetDisplayDodgeAsync(CancellationToken token = default)
        {
            return (await GetDodgeAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo);
        }

        public string DodgeToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (LockObject.EnterReadLock())
                {
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                              out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append(REA.CurrentDisplayAbbrev, strSpace)
                            .Append('(', REA.TotalValue.ToString(GlobalSettings.CultureInfo), ')')
                            .Append(strSpace, '+').Append(strSpace, INT.CurrentDisplayAbbrev, strSpace)
                            .Append('(', INT.TotalValue.ToString(GlobalSettings.CultureInfo), ')')
                            .Append(strSpace, '+').Append(strSpace, LanguageManager.GetString("Tip_Skill_Wounds"), strSpace)
                            .Append('(', WoundModifier.ToString(GlobalSettings.CultureInfo), ')')
                            .Append(strSpace, '+').Append(strSpace, LanguageManager.GetString("Tip_Skill_Sustain"), strSpace)
                            .Append('(', SustainingPenalty.ToString(GlobalSettings.CultureInfo), ')');

                        int intModifiers = TotalBonusDodgeRating;

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                Improvement.ImprovementType.Dodge,
                                strSpace,
                                intModifiers);
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        public async Task<string> GetDodgeToolTipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                       out StringBuilder sbdToolTip))
                {
                    CharacterAttrib objRea = await GetAttributeAsync("REA", token: token).ConfigureAwait(false);
                    CharacterAttrib objInt = await GetAttributeAsync("INT", token: token).ConfigureAwait(false);
                    sbdToolTip
                        .Append(
                            await objRea.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false), strSpace)
                        .Append('(', (await objRea.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings
                            .CultureInfo), ')').Append(strSpace, '+')
                        .Append(strSpace, await objInt.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false), strSpace)
                        .Append('(', (await objInt.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings
                            .CultureInfo), ')').Append(strSpace, '+')
                        .Append(strSpace, await LanguageManager.GetStringAsync("Tip_Skill_Wounds", token: token)
                            .ConfigureAwait(false), strSpace)
                        .Append('(', (await GetWoundModifierAsync(token).ConfigureAwait(false)).ToString(GlobalSettings
                            .CultureInfo), ')').Append(strSpace, '+')
                        .Append(strSpace, await LanguageManager.GetStringAsync("Tip_Skill_Sustain", token: token)
                            .ConfigureAwait(false), strSpace)
                        .Append('(', (await GetSustainingPenaltyAsync(token).ConfigureAwait(false)).ToString(GlobalSettings
                            .CultureInfo), ')');

                    int intModifiers = await GetTotalBonusDodgeRatingAsync(token).ConfigureAwait(false);

                    if (intModifiers != 0)
                    {
                        await FormatImprovementModifiersAsync(
                            sbdToolTip,
                            Improvement.ImprovementType.Dodge,
                            strSpace,
                            intModifiers, token).ConfigureAwait(false);
                    }

                    return sbdToolTip.ToString();
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        #endregion Dodge

        #region Spell Defense

        #region Indirect Dodge

        public int SpellDefenseIndirectDodge => Dodge;

        public Task<int> GetSpellDefenseIndirectDodgeAsync(CancellationToken token = default) => GetDodgeAsync(token);

        public string DisplaySpellDefenseIndirectDodge
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    int intDodge = SpellDefenseIndirectDodge;
                    int intCounterspellingDice = CurrentCounterspellingDice;
                    return intCounterspellingDice == 0
                        ? intDodge.ToString(GlobalSettings.CultureInfo)
                        : intDodge.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + "(" +
                          (intDodge + intCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ")";
                }
            }
        }

        public async Task<string> GetDisplaySpellDefenseIndirectDodgeAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intDodge = await GetSpellDefenseIndirectDodgeAsync(token).ConfigureAwait(false);
                int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                return intCounterspellingDice == 0
                    ? intDodge.ToString(GlobalSettings.CultureInfo)
                    : intDodge.ToString(GlobalSettings.CultureInfo) + await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false)
                        + "(" + (intDodge + intCounterspellingDice).ToString(GlobalSettings.CultureInfo) + ")";
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string SpellDefenseIndirectDodgeToolTip
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    string strToolTip = DodgeToolTip;

                    if (CurrentCounterspellingDice != 0)
                    {
                        string strSpace = LanguageManager.GetString("String_Space");
                        strToolTip += strSpace + "+" + strSpace + LanguageManager.GetString("Label_CounterspellingDice")
                                      +
                                      strSpace + "(" + CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo)
                                      + ")";
                    }

                    return strToolTip;
                }
            }
        }

        public async Task<string> GetSpellDefenseIndirectDodgeToolTipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                string strToolTip = await GetDodgeToolTipAsync(token).ConfigureAwait(false);
                int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                if (intCounterspellingDice != 0)
                {
                    string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
                    strToolTip += strSpace + "+" + strSpace + await LanguageManager.GetStringAsync("Label_CounterspellingDice", token: token).ConfigureAwait(false)
                                  +
                                  strSpace + "(" + intCounterspellingDice.ToString(GlobalSettings.CultureInfo)
                                  + ")";
                }

                return strToolTip;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        #endregion Indirect Dodge

        #region Indirect Soak

        public int SpellDefenseIndirectSoak
        {
            get
            {
                int intAttributes = 0;
                using (LockObject.EnterReadLock())
                {
                    if (IsAI)
                    {
                        if (HomeNode is Vehicle objVehicle)
                            intAttributes = objVehicle.TotalBody;
                    }
                    else
                        intAttributes = BOD.TotalValue;

                    return intAttributes +
                           GetArmorRating(Improvement.ImprovementType.SpellResistance) +
                           ImprovementManager.ValueOf(this, Improvement.ImprovementType.DamageResistance)
                                             .StandardRound();
                }
            }
        }

        public async Task<int> GetSpellDefenseIndirectSoakAsync(CancellationToken token = default)
        {
            int intAttributes = 0;
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    if (await GetHomeNodeAsync(token).ConfigureAwait(false) is Vehicle objVehicle)
                        intAttributes = await objVehicle.GetTotalBodyAsync(token).ConfigureAwait(false);
                }
                else
                    intAttributes = await (await GetAttributeAsync("BOD", token: token).ConfigureAwait(false))
                        .GetTotalValueAsync(token).ConfigureAwait(false);

                return intAttributes +
                       await GetArmorRatingAsync(Improvement.ImprovementType.SpellResistance, token).ConfigureAwait(false) +
                       (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.DamageResistance, token: token).ConfigureAwait(false))
                                         .StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplaySpellDefenseIndirectSoak
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    int intSoak = SpellDefenseIndirectSoak;
                    int intCounterspellingDice = CurrentCounterspellingDice;
                    return intCounterspellingDice == 0
                        ? intSoak.ToString(GlobalSettings.CultureInfo)
                        : intSoak.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + "(" +
                          (intSoak + intCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ")";
                }
            }
        }

        public async Task<string> GetDisplaySpellDefenseIndirectSoakAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intSoak = await GetSpellDefenseIndirectSoakAsync(token).ConfigureAwait(false);
                int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                return intCounterspellingDice == 0
                    ? intSoak.ToString(GlobalSettings.CultureInfo)
                    : intSoak.ToString(GlobalSettings.CultureInfo) +
                      await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false) + "(" +
                      (intSoak + intCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                      + ")";
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string SpellDefenseIndirectSoakToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (LockObject.EnterReadLock())
                {
                    int intBody;
                    string strBodyAbbrev;
                    if (IsAI)
                    {
                        intBody = HomeNode is Vehicle objVehicle ? objVehicle.TotalBody : 0;
                        strBodyAbbrev = LanguageManager.GetString("String_VehicleBody");
                    }
                    else
                    {
                        intBody = BOD.TotalValue;
                        strBodyAbbrev = BOD.CurrentDisplayAbbrev;
                    }

                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append(strBodyAbbrev, strSpace, '(')
                                  .Append(intBody.ToString(GlobalSettings.CultureInfo), ')')
                                  .Append(strSpace, '+', strSpace)
                                  .Append(LanguageManager.GetString("Tip_Armor"), strSpace)
                                  .Append('(', TotalArmorRating.ToString(GlobalSettings.CultureInfo), ')');

                        int intCounterspellingDice = CurrentCounterspellingDice;
                        if (intCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace, '+', strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice"), strSpace)
                                      .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DamageResistance)).StandardRound();

                        if (intModifiers != 0)
                        {
                            using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.DamageResistance))
                            {
                                FormatImprovementModifiers(
                                    sbdToolTip,
                                    aParams,
                                    strSpace,
                                    intModifiers);
                            }
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        public async Task<string> GetSpellDefenseIndirectSoakToolTipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intBody;
                string strBodyAbbrev;
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    intBody = await GetHomeNodeAsync(token).ConfigureAwait(false) is Vehicle objVehicle
                        ? await objVehicle.GetTotalBodyAsync(token).ConfigureAwait(false) : 0;
                    strBodyAbbrev = await LanguageManager.GetStringAsync("String_VehicleBody", token: token).ConfigureAwait(false);
                }
                else
                {
                    CharacterAttrib objAttribute = await GetAttributeAsync("BOD", token: token).ConfigureAwait(false);
                    intBody = await objAttribute.GetTotalValueAsync(token).ConfigureAwait(false);
                    strBodyAbbrev = await objAttribute.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false);
                }

                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(strBodyAbbrev, strSpace, '(')
                              .Append(intBody.ToString(GlobalSettings.CultureInfo), ')')
                              .Append(strSpace, '+', strSpace)
                              .Append(await LanguageManager.GetStringAsync("Tip_Armor", token: token).ConfigureAwait(false), strSpace)
                              .Append('(', (await GetTotalArmorRatingAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')');

                    int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                    if (intCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace, '+', strSpace)
                                  .Append(await LanguageManager.GetStringAsync("Label_CounterspellingDice", token: token).ConfigureAwait(false), strSpace)
                                  .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                    int intModifiers
                        = (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpellResistance, token: token).ConfigureAwait(false)
                           + await ImprovementManager.ValueOfAsync(
                               this, Improvement.ImprovementType.DamageResistance, token: token).ConfigureAwait(false)).StandardRound();

                    if (intModifiers != 0)
                    {
                        using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.DamageResistance))
                        {
                            await FormatImprovementModifiersAsync(
                                sbdToolTip,
                                aParams,
                                strSpace,
                                intModifiers, token).ConfigureAwait(false);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        #endregion Indirect Soak

        #region Direct Soak Mana

        public int SpellDefenseDirectSoakMana
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return WIL.TotalValue
                           + (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                              + ImprovementManager.ValueOf(this, Improvement.ImprovementType.DirectManaSpellResist))
                           .StandardRound();
            }
        }

        public async Task<int> GetSpellDefenseDirectSoakManaAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await (await GetAttributeAsync("WIL", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false) +
                       (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpellResistance, token: token).ConfigureAwait(false)
                        + await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.DirectManaSpellResist, token: token).ConfigureAwait(false))
                                         .StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplaySpellDefenseDirectSoakMana
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    int intSoak = SpellDefenseDirectSoakMana;
                    int intCounterspellingDice = CurrentCounterspellingDice;
                    return intCounterspellingDice == 0
                        ? intSoak.ToString(GlobalSettings.CultureInfo)
                        : intSoak.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + "(" +
                          (intSoak + intCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ")";
                }
            }
        }

        public async Task<string> GetDisplaySpellDefenseDirectSoakManaAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intSoak = await GetSpellDefenseDirectSoakManaAsync(token).ConfigureAwait(false);
                int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                return intCounterspellingDice == 0
                    ? intSoak.ToString(GlobalSettings.CultureInfo)
                    : intSoak.ToString(GlobalSettings.CultureInfo) +
                      await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false) + "(" +
                      (intSoak + intCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                      + ")";
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string SpellDefenseDirectSoakManaToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (LockObject.EnterReadLock())
                {
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append(WIL.CurrentDisplayAbbrev, strSpace, '(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo), ')');

                        int intCounterspellingDice = CurrentCounterspellingDice;
                        if (intCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace, '+', strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice"), strSpace)
                                      .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DirectManaSpellResist)).StandardRound();

                        if (intModifiers != 0)
                        {
                            using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.DirectManaSpellResist))
                            {
                                FormatImprovementModifiers(
                                    sbdToolTip,
                                    aParams,
                                    strSpace,
                                    intModifiers);
                            }
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        public async Task<string> GetSpellDefenseDirectSoakManaToolTipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                CharacterAttrib objWil = await GetAttributeAsync("WIL", token: token).ConfigureAwait(false);
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(await objWil.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false)).Append(strSpace, '(')
                              .Append((await objWil.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')');

                    int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                    if (intCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace, '+', strSpace)
                                  .Append(await LanguageManager.GetStringAsync("Label_CounterspellingDice", token: token).ConfigureAwait(false), strSpace)
                                  .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                    int intModifiers
                        = (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpellResistance, token: token).ConfigureAwait(false)
                           + await ImprovementManager.ValueOfAsync(
                               this, Improvement.ImprovementType.DirectManaSpellResist, token: token).ConfigureAwait(false)).StandardRound();

                    if (intModifiers != 0)
                    {
                        using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.DirectManaSpellResist))
                        {
                            await FormatImprovementModifiersAsync(
                                sbdToolTip,
                                aParams,
                                strSpace,
                                intModifiers, token).ConfigureAwait(false);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        #endregion Direct Soak Mana

        #region Direct Soak Physical

        public int SpellDefenseDirectSoakPhysical
        {
            get
            {
                int intAttributes = 0;
                using (LockObject.EnterReadLock())
                {
                    if (IsAI)
                    {
                        if (HomeNode is Vehicle objVehicle)
                            intAttributes = objVehicle.TotalBody;
                    }
                    else
                        intAttributes = BOD.TotalValue;

                    return intAttributes +
                           (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance) +
                            ImprovementManager.ValueOf(this, Improvement.ImprovementType.DirectPhysicalSpellResist))
                           .StandardRound();
                }
            }
        }

        public async Task<int> GetSpellDefenseDirectSoakPhysicalAsync(CancellationToken token = default)
        {
            int intAttributes = 0;
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    if (await GetHomeNodeAsync(token).ConfigureAwait(false) is Vehicle objVehicle)
                        intAttributes = await objVehicle.GetTotalBodyAsync(token).ConfigureAwait(false);
                }
                else
                    intAttributes = await (await GetAttributeAsync("BOD", token: token).ConfigureAwait(false))
                        .GetTotalValueAsync(token).ConfigureAwait(false);

                return intAttributes +
                       (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpellResistance, token: token).ConfigureAwait(false)
                        + await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.DirectPhysicalSpellResist, token: token).ConfigureAwait(false))
                                         .StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplaySpellDefenseDirectSoakPhysical
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    int intSoak = SpellDefenseDirectSoakPhysical;
                    int intCounterspellingDice = CurrentCounterspellingDice;
                    return intCounterspellingDice == 0
                        ? intSoak.ToString(GlobalSettings.CultureInfo)
                        : intSoak.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + "(" +
                          (intSoak + intCounterspellingDice).ToString(
                              GlobalSettings.CultureInfo)
                          + ")";
                }
            }
        }

        public async Task<string> GetDisplaySpellDefenseDirectSoakPhysicalAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intSoak = await GetSpellDefenseDirectSoakPhysicalAsync(token).ConfigureAwait(false);
                int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                return intCounterspellingDice == 0
                    ? intSoak.ToString(GlobalSettings.CultureInfo)
                    : intSoak.ToString(GlobalSettings.CultureInfo) +
                      await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false) + "(" +
                      (intSoak + intCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                      + ")";
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string SpellDefenseDirectSoakPhysicalToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (LockObject.EnterReadLock())
                {
                    int intBody;
                    string strBodyAbbrev;
                    if (IsAI)
                    {
                        intBody = HomeNode is Vehicle objVehicle ? objVehicle.TotalBody : 0;
                        strBodyAbbrev = LanguageManager.GetString("String_VehicleBody");
                    }
                    else
                    {
                        intBody = BOD.TotalValue;
                        strBodyAbbrev = BOD.CurrentDisplayAbbrev;
                    }

                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append(strBodyAbbrev, strSpace, '(')
                                  .Append(intBody.ToString(GlobalSettings.CultureInfo), ')');

                        int intCounterspellingDice = CurrentCounterspellingDice;
                        if (intCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace, '+', strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice"), strSpace)
                                      .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DirectPhysicalSpellResist))
                            .StandardRound();

                        if (intModifiers != 0)
                        {
                            using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.DirectPhysicalSpellResist))
                            {
                                FormatImprovementModifiers(
                                    sbdToolTip,
                                    aParams,
                                    strSpace,
                                    intModifiers);
                            }
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        public async Task<string> GetSpellDefenseDirectSoakPhysicalToolTipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intBody;
                string strBodyAbbrev;
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    intBody = await GetHomeNodeAsync(token).ConfigureAwait(false) is Vehicle objVehicle ? await objVehicle.GetTotalBodyAsync(token).ConfigureAwait(false) : 0;
                    strBodyAbbrev = await LanguageManager.GetStringAsync("String_VehicleBody", token: token).ConfigureAwait(false);
                }
                else
                {
                    CharacterAttrib objBod = await GetAttributeAsync("BOD", token: token).ConfigureAwait(false);
                    intBody = await objBod.GetTotalValueAsync(token).ConfigureAwait(false);
                    strBodyAbbrev = await objBod.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false);
                }
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(strBodyAbbrev, strSpace, '(')
                        .Append(intBody.ToString(GlobalSettings.CultureInfo), ')');

                    int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                    if (intCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace, '+', strSpace)
                                  .Append(await LanguageManager.GetStringAsync("Label_CounterspellingDice", token: token).ConfigureAwait(false), strSpace)
                                  .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                    int intModifiers
                        = (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpellResistance, token: token).ConfigureAwait(false)
                           + await ImprovementManager.ValueOfAsync(
                               this, Improvement.ImprovementType.DirectPhysicalSpellResist, token: token).ConfigureAwait(false)).StandardRound();

                    if (intModifiers != 0)
                    {
                        using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.DirectPhysicalSpellResist))
                        {
                            await FormatImprovementModifiersAsync(
                                sbdToolTip,
                                aParams,
                                strSpace,
                                intModifiers, token).ConfigureAwait(false);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        #endregion Direct Soak Physical

        #region Detection

        public int SpellDefenseDetection
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return LOG.TotalValue + WIL.TotalValue +
                           (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                            + ImprovementManager.ValueOf(this, Improvement.ImprovementType.DetectionSpellResist))
                                             .StandardRound();
            }
        }

        public async Task<int> GetSpellDefenseDetectionAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await (await GetAttributeAsync("LOG", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                       + await (await GetAttributeAsync("WIL", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                       + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpellResistance, token: token).ConfigureAwait(false)
                          + await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.DetectionSpellResist, token: token).ConfigureAwait(false))
                                         .StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplaySpellDefenseDetection
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    int intDefense = SpellDefenseDetection;
                    int intCounterspellingDice = CurrentCounterspellingDice;
                    return intCounterspellingDice == 0
                        ? intDefense.ToString(GlobalSettings.CultureInfo)
                        : intDefense.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + "(" +
                          (intDefense + intCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ")";
                }
            }
        }

        public async Task<string> GetDisplaySpellDefenseDetectionAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intDefense = await GetSpellDefenseDetectionAsync(token).ConfigureAwait(false);
                int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                return intCounterspellingDice == 0
                    ? intDefense.ToString(GlobalSettings.CultureInfo)
                    : intDefense.ToString(GlobalSettings.CultureInfo) +
                      await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false) + "(" +
                      (intDefense + intCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                      + ")";
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string SpellDefenseDetectionToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (LockObject.EnterReadLock())
                {
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                          out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append(LOG.CurrentDisplayAbbrev, strSpace, '(')
                                  .Append(LOG.TotalValue.ToString(GlobalSettings.CultureInfo), ')', strSpace)
                                  .Append('+', strSpace).Append(WIL.CurrentDisplayAbbrev, strSpace, '(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo), ')');

                        int intCounterspellingDice = CurrentCounterspellingDice;
                        if (intCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace, '+', strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice"), strSpace)
                                      .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DetectionSpellResist)).StandardRound();

                        if (intModifiers != 0)
                        {
                            using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.DetectionSpellResist))
                            {
                                FormatImprovementModifiers(
                                    sbdToolTip,
                                    aParams,
                                    strSpace,
                                    intModifiers);
                            }
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        public async Task<string> GetSpellDefenseDetectionToolTipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                CharacterAttrib objLog = await GetAttributeAsync("LOG", token: token).ConfigureAwait(false);
                CharacterAttrib objWil = await GetAttributeAsync("WIL", token: token).ConfigureAwait(false);
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(await objLog.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false)).Append(strSpace, '(')
                        .Append((await objLog.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')')
                        .Append(strSpace, '+', strSpace)
                        .Append(await objWil.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false)).Append(strSpace, '(')
                        .Append((await objWil.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')');

                    int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                    if (intCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace, '+', strSpace)
                                  .Append(await LanguageManager.GetStringAsync("Label_CounterspellingDice", token: token).ConfigureAwait(false), strSpace)
                                  .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                    int intModifiers
                        = (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpellResistance, token: token).ConfigureAwait(false)
                           + await ImprovementManager.ValueOfAsync(
                               this, Improvement.ImprovementType.DetectionSpellResist, token: token).ConfigureAwait(false)).StandardRound();

                    if (intModifiers != 0)
                    {
                        using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.DetectionSpellResist))
                        {
                            await FormatImprovementModifiersAsync(
                                sbdToolTip,
                                aParams,
                                strSpace,
                                intModifiers, token).ConfigureAwait(false);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        #endregion Detection

        #region Decrease Attributes

        public int SpellDefenseDecreaseBOD
        {
            get
            {
                int intAttributes = 0;
                using (LockObject.EnterReadLock())
                {
                    if (IsAI)
                    {
                        if (HomeNode is Vehicle objVehicle)
                            intAttributes = objVehicle.TotalBody;
                    }
                    else
                        intAttributes = BOD.TotalValue;

                    return intAttributes + WIL.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.DecreaseBODResist))
                                          .StandardRound();
                }
            }
        }

        public async Task<int> GetSpellDefenseDecreaseBODAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            int intAttributes = 0;
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    if (await GetHomeNodeAsync(token).ConfigureAwait(false) is Vehicle objVehicle)
                        intAttributes = await objVehicle.GetTotalBodyAsync(token).ConfigureAwait(false);
                }
                else
                    intAttributes = await (await GetAttributeAsync("BOD", token: token).ConfigureAwait(false))
                        .GetTotalValueAsync(token).ConfigureAwait(false);

                return intAttributes
                    + await (await GetAttributeAsync("WIL", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                    + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpellResistance, token: token).ConfigureAwait(false)
                            + await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.DecreaseBODResist, token: token).ConfigureAwait(false))
                                            .StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplaySpellDefenseDecreaseBOD
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    int intDefense = SpellDefenseDecreaseBOD;
                    int intCounterspellingDice = CurrentCounterspellingDice;
                    return intCounterspellingDice == 0
                        ? intDefense.ToString(GlobalSettings.CultureInfo)
                        : intDefense.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + "(" +
                          (intDefense + intCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ")";
                }
            }
        }

        public async Task<string> GetDisplaySpellDefenseDecreaseBODAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intDefense = await GetSpellDefenseDecreaseBODAsync(token).ConfigureAwait(false);
                int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                return intCounterspellingDice == 0
                    ? intDefense.ToString(GlobalSettings.CultureInfo)
                    : intDefense.ToString(GlobalSettings.CultureInfo) +
                      await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false) + "(" +
                      (intDefense + intCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                      + ")";
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string SpellDefenseDecreaseBODToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (LockObject.EnterReadLock())
                {
                    int intBody;
                    string strBodyAbbrev;
                    if (IsAI)
                    {
                        intBody = HomeNode is Vehicle objVehicle ? objVehicle.TotalBody : 0;
                        strBodyAbbrev = LanguageManager.GetString("String_VehicleBody");
                    }
                    else
                    {
                        intBody = BOD.TotalValue;
                        strBodyAbbrev = BOD.CurrentDisplayAbbrev;
                    }

                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                          out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append(strBodyAbbrev, strSpace, '(')
                                  .Append(intBody.ToString(GlobalSettings.CultureInfo), ')', strSpace)
                                  .Append('+', strSpace).Append(WIL.CurrentDisplayAbbrev, strSpace, '(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo), ')');

                        int intCounterspellingDice = CurrentCounterspellingDice;
                        if (intCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace, '+', strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice"), strSpace)
                                      .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DecreaseBODResist)).StandardRound();

                        if (intModifiers != 0)
                        {
                            using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.DecreaseBODResist))
                            {
                                FormatImprovementModifiers(
                                    sbdToolTip,
                                    aParams,
                                    strSpace,
                                    intModifiers);
                            }
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        public async Task<string> GetSpellDefenseDecreaseBODToolTipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intBody;
                string strBodyAbbrev;
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    intBody = await GetHomeNodeAsync(token).ConfigureAwait(false) is Vehicle objVehicle ? await objVehicle.GetTotalBodyAsync(token).ConfigureAwait(false) : 0;
                    strBodyAbbrev = await LanguageManager.GetStringAsync("String_VehicleBody", token: token).ConfigureAwait(false);
                }
                else
                {
                    CharacterAttrib objBod = await GetAttributeAsync("BOD", token: token).ConfigureAwait(false);
                    intBody = await objBod.GetTotalValueAsync(token).ConfigureAwait(false);
                    strBodyAbbrev = await objBod.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false);
                }
                CharacterAttrib objWil = await GetAttributeAsync("WIL", token: token).ConfigureAwait(false);
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(strBodyAbbrev).Append(strSpace, '(')
                        .Append(intBody.ToString(GlobalSettings.CultureInfo), ')')
                        .Append(strSpace, '+', strSpace)
                        .Append(await objWil.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false)).Append(strSpace, '(')
                        .Append((await objWil.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')');

                    int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                    if (intCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace, '+', strSpace)
                                  .Append(await LanguageManager.GetStringAsync("Label_CounterspellingDice", token: token).ConfigureAwait(false), strSpace)
                                  .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                    int intModifiers
                        = (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpellResistance, token: token).ConfigureAwait(false)
                           + await ImprovementManager.ValueOfAsync(
                               this, Improvement.ImprovementType.DecreaseBODResist, token: token).ConfigureAwait(false)).StandardRound();

                    if (intModifiers != 0)
                    {
                        using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.DecreaseBODResist))
                        {
                            await FormatImprovementModifiersAsync(
                                sbdToolTip,
                                aParams,
                                strSpace,
                                intModifiers, token).ConfigureAwait(false);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public int SpellDefenseDecreaseAGI
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return AGI.TotalValue + WIL.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.DecreaseAGIResist))
                                          .StandardRound();
            }
        }

        public async Task<int> GetSpellDefenseDecreaseAGIAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await (await GetAttributeAsync("AGI", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                       + await (await GetAttributeAsync("WIL", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                       + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpellResistance, token: token).ConfigureAwait(false)
                          + await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.DecreaseAGIResist, token: token).ConfigureAwait(false))
                                         .StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplaySpellDefenseDecreaseAGI
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    int intDefense = SpellDefenseDecreaseAGI;
                    int intCounterspellingDice = CurrentCounterspellingDice;
                    return intCounterspellingDice == 0
                        ? intDefense.ToString(GlobalSettings.CultureInfo)
                        : intDefense.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + "(" +
                          (intDefense + intCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ")";
                }
            }
        }

        public async Task<string> GetDisplaySpellDefenseDecreaseAGIAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intDefense = await GetSpellDefenseDecreaseAGIAsync(token).ConfigureAwait(false);
                int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                return intCounterspellingDice == 0
                    ? intDefense.ToString(GlobalSettings.CultureInfo)
                    : intDefense.ToString(GlobalSettings.CultureInfo) +
                      await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false) + "(" +
                      (intDefense + intCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                      + ")";
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string SpellDefenseDecreaseAGIToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (LockObject.EnterReadLock())
                {
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                              out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append(AGI.CurrentDisplayAbbrev, strSpace, '(')
                                  .Append(AGI.TotalValue.ToString(GlobalSettings.CultureInfo), ')', strSpace)
                                  .Append('+', strSpace).Append(WIL.CurrentDisplayAbbrev, strSpace, '(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo), ')');

                        int intCounterspellingDice = CurrentCounterspellingDice;
                        if (intCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace, '+', strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice"), strSpace)
                                      .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DecreaseAGIResist)).StandardRound();

                        if (intModifiers != 0)
                        {
                            using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.DecreaseAGIResist))
                            {
                                FormatImprovementModifiers(
                                    sbdToolTip,
                                    aParams,
                                    strSpace,
                                    intModifiers);
                            }
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        public async Task<string> GetSpellDefenseDecreaseAGIToolTipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                CharacterAttrib objAgi = await GetAttributeAsync("AGI", token: token).ConfigureAwait(false);
                CharacterAttrib objWil = await GetAttributeAsync("WIL", token: token).ConfigureAwait(false);
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(await objAgi.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false)).Append(strSpace, '(')
                        .Append((await objAgi.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')')
                        .Append(strSpace, '+', strSpace)
                        .Append(await objWil.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false)).Append(strSpace, '(')
                        .Append((await objWil.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')');

                    int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                    if (intCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace, '+', strSpace)
                                  .Append(await LanguageManager.GetStringAsync("Label_CounterspellingDice", token: token).ConfigureAwait(false), strSpace)
                                  .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                    int intModifiers
                        = (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpellResistance, token: token).ConfigureAwait(false)
                           + await ImprovementManager.ValueOfAsync(
                               this, Improvement.ImprovementType.DecreaseAGIResist, token: token).ConfigureAwait(false)).StandardRound();

                    if (intModifiers != 0)
                    {
                        using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.DecreaseAGIResist))
                        {
                            await FormatImprovementModifiersAsync(
                                sbdToolTip,
                                aParams,
                                strSpace,
                                intModifiers, token).ConfigureAwait(false);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public int SpellDefenseDecreaseREA
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return REA.TotalValue + WIL.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.DecreaseREAResist))
                                          .StandardRound();
            }
        }

        public async Task<int> GetSpellDefenseDecreaseREAAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await (await GetAttributeAsync("REA", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                       + await (await GetAttributeAsync("WIL", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                       + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpellResistance, token: token).ConfigureAwait(false)
                          + await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.DecreaseREAResist, token: token).ConfigureAwait(false))
                                         .StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplaySpellDefenseDecreaseREA
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    int intDefense = SpellDefenseDecreaseREA;
                    int intCounterspellingDice = CurrentCounterspellingDice;
                    return intCounterspellingDice == 0
                        ? intDefense.ToString(GlobalSettings.CultureInfo)
                        : intDefense.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + "(" +
                          (intDefense + intCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ")";
                }
            }
        }

        public async Task<string> GetDisplaySpellDefenseDecreaseREAAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intDefense = await GetSpellDefenseDecreaseREAAsync(token).ConfigureAwait(false);
                int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                return intCounterspellingDice == 0
                    ? intDefense.ToString(GlobalSettings.CultureInfo)
                    : intDefense.ToString(GlobalSettings.CultureInfo) +
                      await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false) + "(" +
                      (intDefense + intCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                      + ")";
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string SpellDefenseDecreaseREAToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (LockObject.EnterReadLock())
                {
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                              out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append(REA.CurrentDisplayAbbrev, strSpace, '(')
                                  .Append(REA.TotalValue.ToString(GlobalSettings.CultureInfo), ')', strSpace)
                                  .Append('+', strSpace).Append(WIL.CurrentDisplayAbbrev, strSpace, '(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo), ')');

                        int intCounterspellingDice = CurrentCounterspellingDice;
                        if (intCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace, '+', strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice"), strSpace)
                                      .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DecreaseREAResist)).StandardRound();

                        if (intModifiers != 0)
                        {
                            using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.DecreaseREAResist))
                            {
                                FormatImprovementModifiers(
                                    sbdToolTip,
                                    aParams,
                                    strSpace,
                                    intModifiers);
                            }
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        public async Task<string> GetSpellDefenseDecreaseREAToolTipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                CharacterAttrib objRea = await GetAttributeAsync("REA", token: token).ConfigureAwait(false);
                CharacterAttrib objWil = await GetAttributeAsync("WIL", token: token).ConfigureAwait(false);
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(await objRea.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false)).Append(strSpace, '(')
                        .Append((await objRea.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')')
                        .Append(strSpace, '+', strSpace)
                        .Append(await objWil.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false)).Append(strSpace, '(')
                        .Append((await objWil.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')');

                    int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                    if (intCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace, '+', strSpace)
                                  .Append(await LanguageManager.GetStringAsync("Label_CounterspellingDice", token: token).ConfigureAwait(false), strSpace)
                                  .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                    int intModifiers
                        = (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpellResistance, token: token).ConfigureAwait(false)
                           + await ImprovementManager.ValueOfAsync(
                               this, Improvement.ImprovementType.DecreaseREAResist, token: token).ConfigureAwait(false)).StandardRound();

                    if (intModifiers != 0)
                    {
                        using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.DecreaseREAResist))
                        {
                            await FormatImprovementModifiersAsync(
                                sbdToolTip,
                                aParams,
                                strSpace,
                                intModifiers, token).ConfigureAwait(false);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public int SpellDefenseDecreaseSTR
        {
            get
            {
                int intAttributes = 0;
                using (LockObject.EnterReadLock())
                {
                    if (IsAI)
                    {
                        if (HomeNode is Vehicle objVehicle)
                            intAttributes = objVehicle.TotalBody;
                    }
                    else
                        intAttributes = STR.TotalValue;
                    return intAttributes + WIL.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.DecreaseSTRResist))
                                          .StandardRound();
                }
            }
        }

        public async Task<int> GetSpellDefenseDecreaseSTRAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            int intAttributes = 0;
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    if (await GetHomeNodeAsync(token).ConfigureAwait(false) is Vehicle objVehicle)
                        intAttributes = await objVehicle.GetTotalBodyAsync(token).ConfigureAwait(false);
                }
                else
                    intAttributes = await (await GetAttributeAsync("STR", token: token).ConfigureAwait(false))
                        .GetTotalValueAsync(token).ConfigureAwait(false);
                return intAttributes
                       + await (await GetAttributeAsync("WIL", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                       + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpellResistance, token: token).ConfigureAwait(false)
                          + await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.DecreaseSTRResist, token: token).ConfigureAwait(false))
                                         .StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplaySpellDefenseDecreaseSTR
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    int intDefense = SpellDefenseDecreaseSTR;
                    int intCounterspellingDice = CurrentCounterspellingDice;
                    return intCounterspellingDice == 0
                        ? intDefense.ToString(GlobalSettings.CultureInfo)
                        : intDefense.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + "(" +
                          (intDefense + intCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ")";
                }
            }
        }

        public async Task<string> GetDisplaySpellDefenseDecreaseSTRAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intDefense = await GetSpellDefenseDecreaseSTRAsync(token).ConfigureAwait(false);
                int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                return intCounterspellingDice == 0
                    ? intDefense.ToString(GlobalSettings.CultureInfo)
                    : intDefense.ToString(GlobalSettings.CultureInfo) +
                      await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false) + "(" +
                      (intDefense + intCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                      + ")";
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string SpellDefenseDecreaseSTRToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (LockObject.EnterReadLock())
                {
                    int intStrength;
                    string strStrengthAbbrev;
                    if (IsAI)
                    {
                        intStrength = HomeNode is Vehicle objVehicle ? objVehicle.TotalBody : 0;
                        strStrengthAbbrev = LanguageManager.GetString("String_VehicleBody");
                    }
                    else
                    {
                        intStrength = STR.TotalValue;
                        strStrengthAbbrev = STR.CurrentDisplayAbbrev;
                    }

                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                              out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append(strStrengthAbbrev, strSpace, '(')
                                  .Append(intStrength.ToString(GlobalSettings.CultureInfo), ')', strSpace)
                                  .Append('+', strSpace).Append(WIL.CurrentDisplayAbbrev, strSpace, '(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo), ')');

                        int intCounterspellingDice = CurrentCounterspellingDice;
                        if (intCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace, '+', strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice"), strSpace)
                                      .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DecreaseSTRResist)).StandardRound();

                        if (intModifiers != 0)
                        {
                            using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.DecreaseSTRResist))
                            {
                                FormatImprovementModifiers(
                                    sbdToolTip,
                                    aParams,
                                    strSpace,
                                    intModifiers);
                            }
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        public async Task<string> GetSpellDefenseDecreaseSTRToolTipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intStrength;
                string strStrengthAbbrev;
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    intStrength = await GetHomeNodeAsync(token).ConfigureAwait(false) is Vehicle objVehicle ? await objVehicle.GetTotalBodyAsync(token).ConfigureAwait(false) : 0;
                    strStrengthAbbrev = await LanguageManager.GetStringAsync("String_VehicleBody", token: token).ConfigureAwait(false);
                }
                else
                {
                    CharacterAttrib objStr = await GetAttributeAsync("STR", token: token).ConfigureAwait(false);
                    intStrength = await objStr.GetTotalValueAsync(token).ConfigureAwait(false);
                    strStrengthAbbrev = await objStr.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false);
                }
                CharacterAttrib objWil = await GetAttributeAsync("WIL", token: token).ConfigureAwait(false);
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(strStrengthAbbrev).Append(strSpace, '(')
                        .Append(intStrength.ToString(GlobalSettings.CultureInfo), ')')
                        .Append(strSpace, '+', strSpace)
                        .Append(await objWil.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false)).Append(strSpace, '(')
                        .Append((await objWil.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')');

                    int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                    if (intCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace, '+', strSpace)
                                  .Append(await LanguageManager.GetStringAsync("Label_CounterspellingDice", token: token).ConfigureAwait(false), strSpace)
                                  .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                    int intModifiers
                        = (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpellResistance, token: token).ConfigureAwait(false)
                           + await ImprovementManager.ValueOfAsync(
                               this, Improvement.ImprovementType.DecreaseSTRResist, token: token).ConfigureAwait(false)).StandardRound();

                    if (intModifiers != 0)
                    {
                        using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.DecreaseSTRResist))
                        {
                            await FormatImprovementModifiersAsync(
                                sbdToolTip,
                                aParams,
                                strSpace,
                                intModifiers, token).ConfigureAwait(false);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public int SpellDefenseDecreaseCHA
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return CHA.TotalValue + WIL.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.DecreaseCHAResist))
                                          .StandardRound();
            }
        }

        public async Task<int> GetSpellDefenseDecreaseCHAAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await (await GetAttributeAsync("CHA", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                       + await (await GetAttributeAsync("WIL", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                       + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpellResistance, token: token).ConfigureAwait(false)
                          + await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.DecreaseCHAResist, token: token).ConfigureAwait(false))
                                         .StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplaySpellDefenseDecreaseCHA
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    int intDefense = SpellDefenseDecreaseCHA;
                    int intCounterspellingDice = CurrentCounterspellingDice;
                    return intCounterspellingDice == 0
                        ? intDefense.ToString(GlobalSettings.CultureInfo)
                        : intDefense.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + "(" +
                          (intDefense + intCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ")";
                }
            }
        }

        public async Task<string> GetDisplaySpellDefenseDecreaseCHAAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intDefense = await GetSpellDefenseDecreaseCHAAsync(token).ConfigureAwait(false);
                int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                return intCounterspellingDice == 0
                    ? intDefense.ToString(GlobalSettings.CultureInfo)
                    : intDefense.ToString(GlobalSettings.CultureInfo) +
                      await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false) + "(" +
                      (intDefense + intCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                      + ")";
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string SpellDefenseDecreaseCHAToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (LockObject.EnterReadLock())
                {
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                              out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append(CHA.CurrentDisplayAbbrev, strSpace, '(')
                                  .Append(CHA.TotalValue.ToString(GlobalSettings.CultureInfo), ')', strSpace)
                                  .Append('+', strSpace).Append(WIL.CurrentDisplayAbbrev, strSpace, '(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo), ')');

                        int intCounterspellingDice = CurrentCounterspellingDice;
                        if (intCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace, '+', strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice"), strSpace)
                                      .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DecreaseCHAResist)).StandardRound();

                        if (intModifiers != 0)
                        {
                            using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.DecreaseCHAResist))
                            {
                                FormatImprovementModifiers(
                                    sbdToolTip,
                                    aParams,
                                    strSpace,
                                    intModifiers);
                            }
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        public async Task<string> GetSpellDefenseDecreaseCHAToolTipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                CharacterAttrib objCha = await GetAttributeAsync("CHA", token: token).ConfigureAwait(false);
                CharacterAttrib objWil = await GetAttributeAsync("WIL", token: token).ConfigureAwait(false);
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(await objCha.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false)).Append(strSpace, '(')
                        .Append((await objCha.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')')
                        .Append(strSpace, '+', strSpace)
                        .Append(await objWil.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false)).Append(strSpace, '(')
                        .Append((await objWil.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')');

                    int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                    if (intCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace, '+', strSpace)
                                  .Append(await LanguageManager.GetStringAsync("Label_CounterspellingDice", token: token).ConfigureAwait(false), strSpace)
                                  .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                    int intModifiers
                        = (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpellResistance, token: token).ConfigureAwait(false)
                           + await ImprovementManager.ValueOfAsync(
                               this, Improvement.ImprovementType.DecreaseCHAResist, token: token).ConfigureAwait(false)).StandardRound();

                    if (intModifiers != 0)
                    {
                        using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.DecreaseCHAResist))
                        {
                            await FormatImprovementModifiersAsync(
                                sbdToolTip,
                                aParams,
                                strSpace,
                                intModifiers, token).ConfigureAwait(false);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public int SpellDefenseDecreaseINT
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return INT.TotalValue + WIL.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.DecreaseINTResist))
                                          .StandardRound();
            }
        }

        public async Task<int> GetSpellDefenseDecreaseINTAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await (await GetAttributeAsync("INT", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                       + await (await GetAttributeAsync("WIL", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                       + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpellResistance, token: token).ConfigureAwait(false)
                          + await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.DecreaseINTResist, token: token).ConfigureAwait(false))
                                         .StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplaySpellDefenseDecreaseINT
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    int intDefense = SpellDefenseDecreaseINT;
                    int intCounterspellingDice = CurrentCounterspellingDice;
                    return intCounterspellingDice == 0
                        ? intDefense.ToString(GlobalSettings.CultureInfo)
                        : intDefense.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + "(" +
                          (intDefense + intCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ")";
                }
            }
        }

        public async Task<string> GetDisplaySpellDefenseDecreaseINTAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intDefense = await GetSpellDefenseDecreaseINTAsync(token).ConfigureAwait(false);
                int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                return intCounterspellingDice == 0
                    ? intDefense.ToString(GlobalSettings.CultureInfo)
                    : intDefense.ToString(GlobalSettings.CultureInfo) +
                      await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false) + "(" +
                      (intDefense + intCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                      + ")";
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string SpellDefenseDecreaseINTToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (LockObject.EnterReadLock())
                {
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                              out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append(INT.CurrentDisplayAbbrev, strSpace, '(')
                                  .Append(INT.TotalValue.ToString(GlobalSettings.CultureInfo), ')', strSpace)
                                  .Append('+', strSpace).Append(WIL.CurrentDisplayAbbrev, strSpace, '(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo), ')');

                        int intCounterspellingDice = CurrentCounterspellingDice;
                        if (intCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace, '+', strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice"), strSpace)
                                      .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DecreaseINTResist)).StandardRound();

                        if (intModifiers != 0)
                        {
                            using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.DecreaseINTResist))
                            {
                                FormatImprovementModifiers(
                                    sbdToolTip,
                                    aParams,
                                    strSpace,
                                    intModifiers);
                            }
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        public async Task<string> GetSpellDefenseDecreaseINTToolTipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                CharacterAttrib objInt = await GetAttributeAsync("INT", token: token).ConfigureAwait(false);
                CharacterAttrib objWil = await GetAttributeAsync("WIL", token: token).ConfigureAwait(false);
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(await objInt.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false)).Append(strSpace, '(')
                        .Append((await objInt.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')')
                        .Append(strSpace, '+', strSpace)
                        .Append(await objWil.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false)).Append(strSpace, '(')
                        .Append((await objWil.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')');

                    int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                    if (intCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace, '+', strSpace)
                                  .Append(await LanguageManager.GetStringAsync("Label_CounterspellingDice", token: token).ConfigureAwait(false), strSpace)
                                  .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                    int intModifiers
                        = (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpellResistance, token: token).ConfigureAwait(false)
                           + await ImprovementManager.ValueOfAsync(
                               this, Improvement.ImprovementType.DecreaseINTResist, token: token).ConfigureAwait(false)).StandardRound();

                    if (intModifiers != 0)
                    {
                        using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.DecreaseINTResist))
                        {
                            await FormatImprovementModifiersAsync(
                                sbdToolTip,
                                aParams,
                                strSpace,
                                intModifiers, token).ConfigureAwait(false);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public int SpellDefenseDecreaseLOG
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return LOG.TotalValue + WIL.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.DecreaseLOGResist))
                                          .StandardRound();
            }
        }

        public async Task<int> GetSpellDefenseDecreaseLOGAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await (await GetAttributeAsync("LOG", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                       + await (await GetAttributeAsync("WIL", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                       + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpellResistance, token: token).ConfigureAwait(false)
                          + await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.DecreaseLOGResist, token: token).ConfigureAwait(false))
                                         .StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplaySpellDefenseDecreaseLOG
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    int intDefense = SpellDefenseDecreaseLOG;
                    int intCounterspellingDice = CurrentCounterspellingDice;
                    return intCounterspellingDice == 0
                        ? intDefense.ToString(GlobalSettings.CultureInfo)
                        : intDefense.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + "(" +
                          (intDefense + intCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ")";
                }
            }
        }

        public async Task<string> GetDisplaySpellDefenseDecreaseLOGAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intDefense = await GetSpellDefenseDecreaseLOGAsync(token).ConfigureAwait(false);
                int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                return intCounterspellingDice == 0
                    ? intDefense.ToString(GlobalSettings.CultureInfo)
                    : intDefense.ToString(GlobalSettings.CultureInfo) +
                      await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false) + "(" +
                      (intDefense + intCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                      + ")";
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string SpellDefenseDecreaseLOGToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (LockObject.EnterReadLock())
                {
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                              out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append(LOG.CurrentDisplayAbbrev, strSpace, '(')
                                  .Append(LOG.TotalValue.ToString(GlobalSettings.CultureInfo), ')', strSpace)
                                  .Append('+', strSpace).Append(WIL.CurrentDisplayAbbrev, strSpace, '(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo), ')');

                        int intCounterspellingDice = CurrentCounterspellingDice;
                        if (intCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace, '+', strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice"), strSpace)
                                      .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DecreaseLOGResist)).StandardRound();

                        if (intModifiers != 0)
                        {
                            using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.DecreaseLOGResist))
                            {
                                FormatImprovementModifiers(
                                    sbdToolTip,
                                    aParams,
                                    strSpace,
                                    intModifiers);
                            }
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        public async Task<string> GetSpellDefenseDecreaseLOGToolTipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                CharacterAttrib objLog = await GetAttributeAsync("LOG", token: token).ConfigureAwait(false);
                CharacterAttrib objWil = await GetAttributeAsync("WIL", token: token).ConfigureAwait(false);
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(await objLog.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false)).Append(strSpace, '(')
                        .Append((await objLog.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')')
                        .Append(strSpace, '+', strSpace)
                        .Append(await objWil.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false)).Append(strSpace, '(')
                        .Append((await objWil.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')');

                    int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                    if (intCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace, '+', strSpace)
                                  .Append(await LanguageManager.GetStringAsync("Label_CounterspellingDice", token: token).ConfigureAwait(false), strSpace)
                                  .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                    int intModifiers
                        = (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpellResistance, token: token).ConfigureAwait(false)
                           + await ImprovementManager.ValueOfAsync(
                               this, Improvement.ImprovementType.DecreaseLOGResist, token: token).ConfigureAwait(false)).StandardRound();

                    if (intModifiers != 0)
                    {
                        using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.DecreaseLOGResist))
                        {
                            await FormatImprovementModifiersAsync(
                                sbdToolTip,
                                aParams,
                                strSpace,
                                intModifiers, token).ConfigureAwait(false);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public int SpellDefenseDecreaseWIL
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return 2 * WIL.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.DecreaseWILResist))
                                          .StandardRound();
            }
        }

        public async Task<int> GetSpellDefenseDecreaseWILAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return 2 * await (await GetAttributeAsync("WIL", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                       + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpellResistance, token: token).ConfigureAwait(false)
                          + await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.DecreaseWILResist, token: token).ConfigureAwait(false))
                                         .StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplaySpellDefenseDecreaseWIL
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    int intDefense = SpellDefenseDecreaseWIL;
                    int intCounterspellingDice = CurrentCounterspellingDice;
                    return intCounterspellingDice == 0
                        ? intDefense.ToString(GlobalSettings.CultureInfo)
                        : intDefense.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + "(" +
                          (intDefense + intCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ")";
                }
            }
        }

        public async Task<string> GetDisplaySpellDefenseDecreaseWILAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intDefense = await GetSpellDefenseDecreaseWILAsync(token).ConfigureAwait(false);
                int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                return intCounterspellingDice == 0
                    ? intDefense.ToString(GlobalSettings.CultureInfo)
                    : intDefense.ToString(GlobalSettings.CultureInfo) +
                      await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false) + "(" +
                      (intDefense + intCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                      + ")";
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string SpellDefenseDecreaseWILToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (LockObject.EnterReadLock())
                {
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                              out StringBuilder sbdToolTip))
                    {
                        string strAbbrev = WIL.CurrentDisplayAbbrev;
                        string strValue = WIL.TotalValue.ToString(GlobalSettings.CultureInfo);
                        sbdToolTip.Append(strAbbrev, strSpace, '(')
                                  .Append(strValue, ')', strSpace)
                                  .Append('+', strSpace, strAbbrev).Append(strSpace, '(')
                                  .Append(strValue, ')');

                        int intCounterspellingDice = CurrentCounterspellingDice;
                        if (intCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace, '+', strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice"), strSpace)
                                      .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DecreaseWILResist)).StandardRound();

                        if (intModifiers != 0)
                        {
                            using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.DecreaseWILResist))
                            {
                                FormatImprovementModifiers(
                                    sbdToolTip,
                                    aParams,
                                    strSpace,
                                    intModifiers);
                            }
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        public async Task<string> GetSpellDefenseDecreaseWILToolTipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                CharacterAttrib objWil = await GetAttributeAsync("WIL", token: token).ConfigureAwait(false);
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(await objWil.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false)).Append(strSpace, '(')
                        .Append((await objWil.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')')
                        .Append(strSpace, '+', strSpace)
                        .Append(await objWil.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false)).Append(strSpace, '(')
                        .Append((await objWil.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')');

                    int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                    if (intCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace, '+', strSpace)
                                  .Append(await LanguageManager.GetStringAsync("Label_CounterspellingDice", token: token).ConfigureAwait(false), strSpace)
                                  .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                    int intModifiers
                        = (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpellResistance, token: token).ConfigureAwait(false)
                           + await ImprovementManager.ValueOfAsync(
                               this, Improvement.ImprovementType.DecreaseWILResist, token: token).ConfigureAwait(false)).StandardRound();

                    if (intModifiers != 0)
                    {
                        using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.DecreaseWILResist))
                        {
                            await FormatImprovementModifiersAsync(
                                sbdToolTip,
                                aParams,
                                strSpace,
                                intModifiers, token).ConfigureAwait(false);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        #endregion Decrease Attributes

        public int SpellDefenseIllusionMana
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return LOG.TotalValue + WIL.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.ManaIllusionResist))
                                          .StandardRound();
            }
        }

        public async Task<int> GetSpellDefenseIllusionManaAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await (await GetAttributeAsync("LOG", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                       + await (await GetAttributeAsync("WIL", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                       + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpellResistance, token: token).ConfigureAwait(false)
                          + await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.ManaIllusionResist, token: token).ConfigureAwait(false))
                                         .StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplaySpellDefenseIllusionMana
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    int intDefense = SpellDefenseIllusionMana;
                    int intCounterspellingDice = CurrentCounterspellingDice;
                    return intCounterspellingDice == 0
                        ? intDefense.ToString(GlobalSettings.CultureInfo)
                        : intDefense.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + "(" +
                          (intDefense + intCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ")";
                }
            }
        }

        public async Task<string> GetDisplaySpellDefenseIllusionManaAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intDefense = await GetSpellDefenseIllusionManaAsync(token).ConfigureAwait(false);
                int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                return intCounterspellingDice == 0
                    ? intDefense.ToString(GlobalSettings.CultureInfo)
                    : intDefense.ToString(GlobalSettings.CultureInfo) +
                      await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false) + "(" +
                      (intDefense + intCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                      + ")";
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string SpellDefenseIllusionManaToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (LockObject.EnterReadLock())
                {
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append(LOG.CurrentDisplayAbbrev, strSpace, '(')
                                  .Append(LOG.TotalValue.ToString(GlobalSettings.CultureInfo), ')', strSpace)
                                  .Append('+', strSpace).Append(WIL.CurrentDisplayAbbrev, strSpace, '(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo), ')');

                        int intCounterspellingDice = CurrentCounterspellingDice;
                        if (intCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace, '+', strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice"), strSpace)
                                      .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                        int intModifiers = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                            + ImprovementManager.ValueOf(
                                                this, Improvement.ImprovementType.ManaIllusionResist))
                            .StandardRound();

                        if (intModifiers != 0)
                        {
                            using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.ManaIllusionResist))
                            {
                                FormatImprovementModifiers(
                                    sbdToolTip,
                                    aParams,
                                    strSpace,
                                    intModifiers);
                            }
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        public async Task<string> GetSpellDefenseIllusionManaToolTipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                CharacterAttrib objLog = await GetAttributeAsync("LOG", token: token).ConfigureAwait(false);
                CharacterAttrib objWil = await GetAttributeAsync("WIL", token: token).ConfigureAwait(false);
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(await objLog.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false)).Append(strSpace, '(')
                        .Append((await objLog.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')')
                        .Append(strSpace, '+', strSpace)
                        .Append(await objWil.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false)).Append(strSpace, '(')
                        .Append((await objWil.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')');

                    int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                    if (intCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace, '+', strSpace)
                                  .Append(await LanguageManager.GetStringAsync("Label_CounterspellingDice", token: token).ConfigureAwait(false), strSpace)
                                  .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                    int intModifiers
                        = (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpellResistance, token: token).ConfigureAwait(false)
                           + await ImprovementManager.ValueOfAsync(
                               this, Improvement.ImprovementType.ManaIllusionResist, token: token).ConfigureAwait(false)).StandardRound();

                    if (intModifiers != 0)
                    {
                        using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.ManaIllusionResist))
                        {
                            await FormatImprovementModifiersAsync(
                                sbdToolTip,
                                aParams,
                                strSpace,
                                intModifiers, token).ConfigureAwait(false);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public int SpellDefenseIllusionPhysical
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    return LOG.TotalValue + INT.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.PhysicalIllusionResist))
                                          .StandardRound();
                }
            }
        }

        public async Task<int> GetSpellDefenseIllusionPhysicalAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await (await GetAttributeAsync("LOG", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                       + await (await GetAttributeAsync("INT", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                       + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpellResistance, token: token).ConfigureAwait(false)
                          + await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.PhysicalIllusionResist, token: token).ConfigureAwait(false))
                                         .StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplaySpellDefenseIllusionPhysical
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    int intDefense = SpellDefenseIllusionPhysical;
                    int intCounterspellingDice = CurrentCounterspellingDice;
                    return intCounterspellingDice == 0
                        ? intDefense.ToString(GlobalSettings.CultureInfo)
                        : intDefense.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + "(" +
                          (intDefense + intCounterspellingDice).ToString(
                              GlobalSettings.CultureInfo)
                          + ")";
                }
            }
        }

        public async Task<string> GetDisplaySpellDefenseIllusionPhysicalAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intDefense = await GetSpellDefenseIllusionPhysicalAsync(token).ConfigureAwait(false);
                int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                return intCounterspellingDice == 0
                    ? intDefense.ToString(GlobalSettings.CultureInfo)
                    : intDefense.ToString(GlobalSettings.CultureInfo) +
                      await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false) + "(" +
                      (intDefense + intCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                      + ")";
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string SpellDefenseIllusionPhysicalToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (LockObject.EnterReadLock())
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(LOG.CurrentDisplayAbbrev, strSpace, '(')
                              .Append(LOG.TotalValue.ToString(GlobalSettings.CultureInfo), ')', strSpace)
                              .Append('+', strSpace).Append(INT.CurrentDisplayAbbrev, strSpace, '(')
                              .Append(INT.TotalValue.ToString(GlobalSettings.CultureInfo), ')');

                    int intCounterspellingDice = CurrentCounterspellingDice;
                    if (intCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace, '+', strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice"), strSpace)
                                      .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                    int intModifiers = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                        + ImprovementManager.ValueOf(
                                            this, Improvement.ImprovementType.PhysicalIllusionResist)).StandardRound();

                    if (intModifiers != 0)
                    {
                        using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.PhysicalIllusionResist))
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                aParams,
                                strSpace,
                                intModifiers);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public async Task<string> GetSpellDefenseIllusionPhysicalToolTipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                CharacterAttrib objLog = await GetAttributeAsync("LOG", token: token).ConfigureAwait(false);
                CharacterAttrib objInt = await GetAttributeAsync("INT", token: token).ConfigureAwait(false);
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(await objLog.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false)).Append(strSpace, '(')
                        .Append((await objLog.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')')
                        .Append(strSpace, '+', strSpace)
                        .Append(await objInt.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false)).Append(strSpace, '(')
                        .Append((await objInt.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')');

                    int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                    if (intCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace, '+', strSpace)
                                  .Append(await LanguageManager.GetStringAsync("Label_CounterspellingDice", token: token).ConfigureAwait(false), strSpace)
                                  .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                    int intModifiers
                        = (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpellResistance, token: token).ConfigureAwait(false)
                           + await ImprovementManager.ValueOfAsync(
                               this, Improvement.ImprovementType.PhysicalIllusionResist, token: token).ConfigureAwait(false)).StandardRound();

                    if (intModifiers != 0)
                    {
                        using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.PhysicalIllusionResist))
                        {
                            await FormatImprovementModifiersAsync(
                                sbdToolTip,
                                aParams,
                                strSpace,
                                intModifiers, token).ConfigureAwait(false);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public int SpellDefenseManipulationMental
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return LOG.TotalValue + WIL.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.MentalManipulationResist))
                                          .StandardRound();
            }
        }

        public async Task<int> GetSpellDefenseManipulationMentalAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await (await GetAttributeAsync("LOG", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                       + await (await GetAttributeAsync("WIL", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                       + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpellResistance, token: token).ConfigureAwait(false)
                          + await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.MentalManipulationResist, token: token).ConfigureAwait(false))
                                         .StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplaySpellDefenseManipulationMental
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    int intDefense = SpellDefenseManipulationMental;
                    int intCounterspellingDice = CurrentCounterspellingDice;
                    return intCounterspellingDice == 0
                        ? intDefense.ToString(GlobalSettings.CultureInfo)
                        : intDefense.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + "(" +
                          (intDefense + intCounterspellingDice).ToString(
                              GlobalSettings.CultureInfo)
                          + ")";
                }
            }
        }

        public async Task<string> GetDisplaySpellDefenseManipulationMentalAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intDefense = await GetSpellDefenseManipulationMentalAsync(token).ConfigureAwait(false);
                int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                return intCounterspellingDice == 0
                    ? intDefense.ToString(GlobalSettings.CultureInfo)
                    : intDefense.ToString(GlobalSettings.CultureInfo) +
                      await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false) + "(" +
                      (intDefense + intCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                      + ")";
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string SpellDefenseManipulationMentalToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (LockObject.EnterReadLock())
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(LOG.CurrentDisplayAbbrev, strSpace, '(')
                              .Append(LOG.TotalValue.ToString(GlobalSettings.CultureInfo), ')', strSpace)
                              .Append('+', strSpace).Append(WIL.CurrentDisplayAbbrev, strSpace, '(')
                              .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo), ')');

                    int intCounterspellingDice = CurrentCounterspellingDice;
                    if (intCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace, '+', strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice"), strSpace)
                                      .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                    int intModifiers = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                        + ImprovementManager.ValueOf(
                                            this, Improvement.ImprovementType.MentalManipulationResist))
                        .StandardRound();

                    if (intModifiers != 0)
                    {
                        using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.MentalManipulationResist))
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                aParams,
                                strSpace,
                                intModifiers);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public async Task<string> GetSpellDefenseManipulationMentalToolTipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                CharacterAttrib objLog = await GetAttributeAsync("LOG", token: token).ConfigureAwait(false);
                CharacterAttrib objWil = await GetAttributeAsync("WIL", token: token).ConfigureAwait(false);
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(await objLog.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false)).Append(strSpace, '(')
                        .Append((await objLog.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')')
                        .Append(strSpace, '+', strSpace)
                        .Append(await objWil.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false)).Append(strSpace, '(')
                        .Append((await objWil.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')');

                    int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                    if (intCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace, '+', strSpace)
                                  .Append(await LanguageManager.GetStringAsync("Label_CounterspellingDice", token: token).ConfigureAwait(false), strSpace)
                                  .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                    int intModifiers
                        = (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpellResistance, token: token).ConfigureAwait(false)
                           + await ImprovementManager.ValueOfAsync(
                               this, Improvement.ImprovementType.MentalManipulationResist, token: token).ConfigureAwait(false)).StandardRound();

                    if (intModifiers != 0)
                    {
                        using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.MentalManipulationResist))
                        {
                            await FormatImprovementModifiersAsync(
                                sbdToolTip,
                                aParams,
                                strSpace,
                                intModifiers, token).ConfigureAwait(false);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public int SpellDefenseManipulationPhysical
        {
            get
            {
                int intAttributes = 0;
                using (LockObject.EnterReadLock())
                {
                    if (IsAI)
                    {
                        if (HomeNode is Vehicle objVehicle)
                            intAttributes = objVehicle.TotalBody * 2;
                    }
                    else
                        intAttributes = BOD.TotalValue + STR.TotalValue;

                    return intAttributes +
                           (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance) +
                            ImprovementManager.ValueOf(this, Improvement.ImprovementType.PhysicalManipulationResist))
                           .StandardRound();
                }
            }
        }

        public async Task<int> GetSpellDefenseManipulationPhysicalAsync(CancellationToken token = default)
        {
            int intAttributes = 0;
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    if (await GetHomeNodeAsync(token).ConfigureAwait(false) is Vehicle objVehicle)
                        intAttributes = 2 * await objVehicle.GetTotalBodyAsync(token).ConfigureAwait(false);
                }
                else
                    intAttributes = await (await GetAttributeAsync("BOD", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false)
                        + await (await GetAttributeAsync("STR", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false);

                return intAttributes
                    + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpellResistance, token: token).ConfigureAwait(false)
                            + await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.DecreaseBODResist, token: token).ConfigureAwait(false))
                                            .StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplaySpellDefenseManipulationPhysical
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    int intDefense = SpellDefenseManipulationPhysical;
                    int intCounterspellingDice = CurrentCounterspellingDice;
                    return intCounterspellingDice == 0
                        ? intDefense.ToString(GlobalSettings.CultureInfo)
                        : intDefense.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + "(" +
                          (intDefense + intCounterspellingDice).ToString(
                              GlobalSettings.CultureInfo) + ")";
                }
            }
        }

        public async Task<string> GetDisplaySpellDefenseManipulationPhysicalAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intDefense = await GetSpellDefenseManipulationPhysicalAsync(token).ConfigureAwait(false);
                int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                return intCounterspellingDice == 0
                    ? intDefense.ToString(GlobalSettings.CultureInfo)
                    : intDefense.ToString(GlobalSettings.CultureInfo) +
                      await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false) + "(" +
                      (intDefense + intCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                      + ")";
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string SpellDefenseManipulationPhysicalToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (LockObject.EnterReadLock())
                {
                    int intBody;
                    int intStrength;
                    string strBodyAbbrev;
                    string strStrengthAbbrev;
                    if (IsAI)
                    {
                        intBody = intStrength = HomeNode is Vehicle objVehicle ? objVehicle.TotalBody : 0;
                        strBodyAbbrev = strStrengthAbbrev = LanguageManager.GetString("String_VehicleBody");
                    }
                    else
                    {
                        intBody = BOD.TotalValue;
                        intStrength = STR.TotalValue;
                        strBodyAbbrev = BOD.CurrentDisplayAbbrev;
                        strStrengthAbbrev = STR.CurrentDisplayAbbrev;
                    }

                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append(strBodyAbbrev, strSpace, '(')
                                  .Append(intBody.ToString(GlobalSettings.CultureInfo), ')', strSpace)
                                  .Append('+', strSpace).Append(strStrengthAbbrev, strSpace)
                                  .Append('(', intStrength.ToString(GlobalSettings.CultureInfo), ')');

                        int intCounterspellingDice = CurrentCounterspellingDice;
                        if (intCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace, '+', strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice"), strSpace)
                                      .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance) +
                               ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.PhysicalManipulationResist))
                            .StandardRound();

                        if (intModifiers != 0)
                        {
                            using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.PhysicalManipulationResist))
                            {
                                FormatImprovementModifiers(
                                    sbdToolTip,
                                    aParams,
                                    strSpace,
                                    intModifiers);
                            }
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        public async Task<string> GetSpellDefenseManipulationPhysicalToolTipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intBody;
                int intStrength;
                string strBodyAbbrev;
                string strStrengthAbbrev;
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    intBody = intStrength = await GetHomeNodeAsync(token).ConfigureAwait(false) is Vehicle objVehicle ? await objVehicle.GetTotalBodyAsync(token).ConfigureAwait(false) : 0;
                    strBodyAbbrev = strStrengthAbbrev = await LanguageManager.GetStringAsync("String_VehicleBody", token: token).ConfigureAwait(false);
                }
                else
                {
                    CharacterAttrib objBod = await GetAttributeAsync("BOD", token: token).ConfigureAwait(false);
                    CharacterAttrib objStr = await GetAttributeAsync("STR", token: token).ConfigureAwait(false);
                    intBody = await objBod.GetTotalValueAsync(token).ConfigureAwait(false);
                    intStrength = await objStr.GetTotalValueAsync(token).ConfigureAwait(false);
                    strBodyAbbrev = await objBod.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false);
                    strStrengthAbbrev = await objStr.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false);
                }
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(strBodyAbbrev).Append(strSpace, '(')
                        .Append(intBody.ToString(GlobalSettings.CultureInfo), ')')
                        .Append(strSpace, '+', strSpace)
                        .Append(strStrengthAbbrev).Append(strSpace, '(')
                        .Append(intStrength.ToString(GlobalSettings.CultureInfo), ')');

                    int intCounterspellingDice = await GetCurrentCounterspellingDiceAsync(token).ConfigureAwait(false);
                    if (intCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace, '+', strSpace)
                                  .Append(await LanguageManager.GetStringAsync("Label_CounterspellingDice", token: token).ConfigureAwait(false), strSpace)
                                  .Append('(', intCounterspellingDice.ToString(GlobalSettings.CultureInfo), ')');

                    int intModifiers
                        = (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SpellResistance, token: token).ConfigureAwait(false)
                           + await ImprovementManager.ValueOfAsync(
                               this, Improvement.ImprovementType.PhysicalManipulationResist, token: token).ConfigureAwait(false)).StandardRound();

                    if (intModifiers != 0)
                    {
                        using (TemporaryArray<Improvement.ImprovementType> aParams = new TemporaryArray<Improvement.ImprovementType>(Improvement.ImprovementType.SpellResistance, Improvement.ImprovementType.PhysicalManipulationResist))
                        {
                            await FormatImprovementModifiersAsync(
                                sbdToolTip,
                                aParams,
                                strSpace,
                                intModifiers, token).ConfigureAwait(false);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        #endregion Spell Defense

        /// <summary>
        /// Surprise test (REA + INT).
        /// </summary>
        public int Surprise
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return REA.TotalValue + INT.TotalValue
                                          + ImprovementManager.ValueOf(this, Improvement.ImprovementType.Surprise)
                                                              .StandardRound()
                                          + WoundModifier
                                          + SustainingPenalty;
            }
        }

        /// <summary>
        /// Surprise test (REA + INT).
        /// </summary>
        public async Task<int> GetSurpriseAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await (await GetAttributeAsync("REA", token: token).ConfigureAwait(false))
                           .GetTotalValueAsync(token).ConfigureAwait(false) +
                       await (await GetAttributeAsync("INT", token: token).ConfigureAwait(false))
                           .GetTotalValueAsync(token)
                           .ConfigureAwait(false) +
                       (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.Surprise, token: token)
                           .ConfigureAwait(false)).StandardRound() +
                       await GetWoundModifierAsync(token).ConfigureAwait(false) +
                       await GetSustainingPenaltyAsync(token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string SurpriseToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (LockObject.EnterReadLock())
                {
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                              out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append(REA.CurrentDisplayAbbrev, strSpace)
                            .Append('(', REA.TotalValue.ToString(GlobalSettings.CultureInfo), ')')
                            .Append(strSpace, '+')
                            .Append(strSpace, INT.CurrentDisplayAbbrev, strSpace)
                            .Append('(', INT.TotalValue.ToString(GlobalSettings.CultureInfo), ')');
                        int intWoundModifier = WoundModifier;
                        if (intWoundModifier != 0)
                            sbdToolTip.Append(strSpace, '+').Append(strSpace, LanguageManager.GetString("Tip_Skill_Wounds"), strSpace)
                                .Append('(', intWoundModifier.ToString(GlobalSettings.CultureInfo), ')');
                        int intSustainingPenalty = SustainingPenalty;
                        if (intSustainingPenalty != 0)
                            sbdToolTip.Append(strSpace, '+').Append(strSpace, LanguageManager.GetString("Tip_Skill_Sustain"), strSpace)
                                .Append('(', intSustainingPenalty.ToString(GlobalSettings.CultureInfo), ')');

                        int intModifiers = ImprovementManager.ValueOf(this, Improvement.ImprovementType.Surprise)
                                                             .StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                Improvement.ImprovementType.Surprise,
                                strSpace,
                                intModifiers);
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        public async Task<string> GetSurpriseToolTipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                       out StringBuilder sbdToolTip))
                {
                    CharacterAttrib objRea = await GetAttributeAsync("REA", token: token).ConfigureAwait(false);
                    CharacterAttrib objInt = await GetAttributeAsync("INT", token: token).ConfigureAwait(false);
                    sbdToolTip.Append(await objRea.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false), strSpace)
                        .Append('(', (await objRea.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')')
                        .Append(strSpace, '+').Append(strSpace, await objInt.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false), strSpace)
                        .Append('(', (await objInt.GetTotalValueAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo), ')');
                    int intWoundModifier = await GetWoundModifierAsync(token).ConfigureAwait(false);
                    if (intWoundModifier != 0)
                        sbdToolTip.Append(strSpace, '+').Append(strSpace, await LanguageManager.GetStringAsync("Tip_Skill_Wounds", token: token).ConfigureAwait(false), strSpace)
                            .Append('(', intWoundModifier.ToString(GlobalSettings.CultureInfo), ')');
                    int intSustainingPenalty = await GetSustainingPenaltyAsync(token).ConfigureAwait(false);
                    if (intSustainingPenalty != 0)
                        sbdToolTip.Append(strSpace, '+').Append(strSpace, await LanguageManager.GetStringAsync("Tip_Skill_Sustain", token: token).ConfigureAwait(false), strSpace)
                            .Append('(', intSustainingPenalty.ToString(GlobalSettings.CultureInfo), ')');

                    int intModifiers = (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.Surprise, token: token).ConfigureAwait(false))
                        .StandardRound();

                    if (intModifiers != 0)
                    {
                        await FormatImprovementModifiersAsync(
                            sbdToolTip,
                            Improvement.ImprovementType.Surprise,
                            strSpace,
                            intModifiers, token).ConfigureAwait(false);
                    }

                    return sbdToolTip.ToString();
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private int _intCachedTotalArmorRating = int.MinValue;
        private int _intCachedTotalFireArmorRating = int.MinValue;
        private int _intCachedTotalColdArmorRating = int.MinValue;
        private int _intCachedTotalElectricityArmorRating = int.MinValue;
        private int _intCachedTotalAcidArmorRating = int.MinValue;
        private int _intCachedTotalFallingArmorRating = int.MinValue;

        /// <summary>
        /// The Character's total Armor Rating.
        /// </summary>
        [HubTag]
        public int TotalArmorRating
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (_intCachedTotalArmorRating == int.MinValue)
                        _intCachedTotalArmorRating = GetArmorRating();
                    return _intCachedTotalArmorRating;
                }
            }
        }

        /// <summary>
        /// The Character's total Armor Rating.
        /// </summary>
        public async Task<int> GetTotalArmorRatingAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_intCachedTotalArmorRating == int.MinValue)
                    _intCachedTotalArmorRating = await GetArmorRatingAsync(token: token).ConfigureAwait(false);
                return _intCachedTotalArmorRating;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string TotalArmorRatingToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (LockObject.EnterReadLock())
                {
                    int intArmor
                        = GetArmorRatingWithImprovement(Improvement.ImprovementType.Armor,
                                                        out int intFromHighestArmorImprovements,
                                                        out List<Improvement> lstUsedImprovements)
                          - ImprovementManager.ValueOf(this, Improvement.ImprovementType.Armor).StandardRound()
                          + intFromHighestArmorImprovements;

                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append(LanguageManager.GetString("Tip_Armor")).Append(strSpace, '(')
                                  .Append(intArmor.ToString(GlobalSettings.CultureInfo), ')');
                        foreach (Improvement objLoopImprovement in lstUsedImprovements)
                        {
                            if (objLoopImprovement.ImproveSource != Improvement.ImprovementSource.Armor
                                && objLoopImprovement.ImproveSource != Improvement.ImprovementSource.ArmorMod)
                            {
                                sbdToolTip.Append(strSpace, '+', strSpace)
                                          .Append(GetObjectName(objLoopImprovement), strSpace)
                                          .Append('(', objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo), ')');
                            }
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        public async Task<string> GetTotalArmorRatingToolTipAsync(CancellationToken token = default)
        {
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                (int intArmor, int intFromHighestArmorImprovements, List<Improvement> lstUsedImprovements)
                    = await GetArmorRatingWithImprovementAsync(Improvement.ImprovementType.Armor, token)
                        .ConfigureAwait(false);
                intArmor -= (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.Armor,
                                token: token).ConfigureAwait(false)).StandardRound()
                            - intFromHighestArmorImprovements;

                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                           out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(await LanguageManager.GetStringAsync("Tip_Armor", token: token)
                            .ConfigureAwait(false)).Append(strSpace, '(')
                        .Append(intArmor.ToString(GlobalSettings.CultureInfo), ')');
                    foreach (Improvement objLoopImprovement in lstUsedImprovements)
                    {
                        if (objLoopImprovement.ImproveSource != Improvement.ImprovementSource.Armor
                            && objLoopImprovement.ImproveSource != Improvement.ImprovementSource.ArmorMod)
                        {
                            sbdToolTip.Append(strSpace, '+', strSpace)
                                .Append(await GetObjectNameAsync(objLoopImprovement, token: token).ConfigureAwait(false), strSpace)
                                .Append('(', objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo), ')');
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against Fire attacks.
        /// </summary>
        public int TotalFireArmorRating
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    return _intCachedTotalFireArmorRating == int.MinValue
                        ? _intCachedTotalFireArmorRating = GetArmorRating(Improvement.ImprovementType.FireArmor)
                        : _intCachedTotalFireArmorRating;
                }
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against Fire attacks.
        /// </summary>
        public async Task<int> GetTotalFireArmorRatingAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _intCachedTotalFireArmorRating == int.MinValue
                    ? _intCachedTotalFireArmorRating =
                        await GetArmorRatingAsync(Improvement.ImprovementType.FireArmor, token: token)
                            .ConfigureAwait(false)
                    : _intCachedTotalFireArmorRating;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against Cold attacks.
        /// </summary>
        public int TotalColdArmorRating
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    return _intCachedTotalColdArmorRating == int.MinValue
                        ? _intCachedTotalColdArmorRating = GetArmorRating(Improvement.ImprovementType.ColdArmor)
                        : _intCachedTotalColdArmorRating;
                }
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against Cold attacks.
        /// </summary>
        public async Task<int> GetTotalColdArmorRatingAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _intCachedTotalColdArmorRating == int.MinValue
                    ? _intCachedTotalColdArmorRating =
                        await GetArmorRatingAsync(Improvement.ImprovementType.ColdArmor, token: token)
                            .ConfigureAwait(false)
                    : _intCachedTotalColdArmorRating;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against Electricity attacks.
        /// </summary>
        public int TotalElectricityArmorRating
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    return _intCachedTotalElectricityArmorRating == int.MinValue
                        ? _intCachedTotalElectricityArmorRating
                            = GetArmorRating(Improvement.ImprovementType.ElectricityArmor)
                        : _intCachedTotalElectricityArmorRating;
                }
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against Electricity attacks.
        /// </summary>
        public async Task<int> GetTotalElectricityArmorRatingAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _intCachedTotalElectricityArmorRating == int.MinValue
                    ? _intCachedTotalElectricityArmorRating =
                        await GetArmorRatingAsync(Improvement.ImprovementType.ElectricityArmor, token: token)
                            .ConfigureAwait(false)
                    : _intCachedTotalElectricityArmorRating;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against Acid attacks.
        /// </summary>
        public int TotalAcidArmorRating
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    return _intCachedTotalAcidArmorRating == int.MinValue
                        ? _intCachedTotalAcidArmorRating = GetArmorRating(Improvement.ImprovementType.AcidArmor)
                        : _intCachedTotalAcidArmorRating;
                }
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against Acid attacks.
        /// </summary>
        public async Task<int> GetTotalAcidArmorRatingAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _intCachedTotalAcidArmorRating == int.MinValue
                    ? _intCachedTotalAcidArmorRating =
                        await GetArmorRatingAsync(Improvement.ImprovementType.AcidArmor, token: token)
                            .ConfigureAwait(false)
                    : _intCachedTotalAcidArmorRating;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against falling damage (AP -4 not factored in).
        /// </summary>
        public int TotalFallingArmorRating
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    return _intCachedTotalFallingArmorRating == int.MinValue
                        ? _intCachedTotalFallingArmorRating = GetArmorRating(Improvement.ImprovementType.FallingArmor)
                        : _intCachedTotalFallingArmorRating;
                }
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against falling damage (AP -4 not factored in).
        /// </summary>
        public async Task<int> GetTotalFallingArmorRatingAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _intCachedTotalFallingArmorRating == int.MinValue
                    ? _intCachedTotalFallingArmorRating =
                        await GetArmorRatingAsync(Improvement.ImprovementType.FallingArmor, token: token)
                            .ConfigureAwait(false)
                    : _intCachedTotalFallingArmorRating;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// The Character's total bonus to Dodge Rating (to add on top of REA + INT).
        /// </summary>
        public int TotalBonusDodgeRating => ImprovementManager.ValueOf(this, Improvement.ImprovementType.Dodge).StandardRound();

        /// <summary>
        /// The Character's total bonus to Dodge Rating (to add on top of REA + INT).
        /// </summary>
        public async Task<int> GetTotalBonusDodgeRatingAsync(CancellationToken token = default) =>
            (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.Dodge, token: token)
                .ConfigureAwait(false)).StandardRound();

        /// <summary>
        /// Encumbrance modifier for carrying more stuff than carry limit
        /// </summary>
        public int Encumbrance
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    decimal decCarryLimit = CarryLimit;

                    decimal decCarriedWeight = TotalCarriedWeight;

                    return decCarriedWeight > decCarryLimit
                        ? -((decCarriedWeight - decCarryLimit) / EncumbranceInterval).StandardRound()
                        : 0;
                }
            }
        }

        /// <summary>
        /// Encumbrance modifier for carrying more stuff than carry limit
        /// </summary>
        public async Task<int> GetEncumbranceAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                decimal decCarryLimit = await GetCarryLimitAsync(token).ConfigureAwait(false);

                decimal decCarriedWeight = await GetTotalCarriedWeightAsync(token).ConfigureAwait(false);

                return decCarriedWeight > decCarryLimit
                    ? -((decCarriedWeight - decCarryLimit) / await GetEncumbranceIntervalAsync(token).ConfigureAwait(false)).StandardRound()
                    : 0;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Total amount of stuff the character is currently carrying on their person (via Equipped)
        /// </summary>
        public decimal TotalCarriedWeight
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    decimal decReturn = _decCachedTotalCarriedWeight;
                    if (decReturn != decimal.MinValue)
                        return decReturn;
                    return _decCachedTotalCarriedWeight = Armor.SumParallel(x => x.Equipped, x => x.TotalWeight)
                                                          + Weapons.SumParallel(x => x.Equipped, x => x.TotalWeight)
                                                          + Gear.SumParallel(x => x.Equipped, x => x.TotalWeight)
                                                          + Cyberware.SumParallel(
                                                              x => x.IsModularCurrentlyEquipped, x => x.TotalWeight);
                }
            }
        }

        /// <summary>
        /// Total amount of stuff the character is currently carrying on their person (via Equipped)
        /// </summary>
        public async Task<decimal> GetTotalCarriedWeightAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                decimal decReturn = _decCachedTotalCarriedWeight;
                if (decReturn != decimal.MinValue)
                    return decReturn;
                return _decCachedTotalCarriedWeight =
                    await Armor.SumParallelAsync(x => x.Equipped, x => x.TotalWeight, token: token).ConfigureAwait(false)
                    + await Weapons.SumParallelAsync(x => x.Equipped, x => x.TotalWeight, token: token).ConfigureAwait(false)
                    + await Gear.SumParallelAsync(x => x.Equipped, x => x.TotalWeight, token: token).ConfigureAwait(false)
                    + await Cyberware.SumParallelAsync(
                        x => x.GetIsModularCurrentlyEquippedAsync(token), x => x.TotalWeight, token: token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// String used to show the current carried weight status in the toolstrip of character forms
        /// </summary>
        public string DisplayTotalCarriedWeight
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (LockObject.EnterReadLock())
                    return TotalCarriedWeight.ToString(Settings.WeightFormat, GlobalSettings.CultureInfo) + strSpace
                        + "kg"
                        + strSpace + "/" + strSpace
                        + CarryLimit.ToString(Settings.WeightFormat, GlobalSettings.CultureInfo) + strSpace + "kg";
            }
        }

        /// <summary>
        /// String used to show the current carried weight status in the toolstrip of character forms
        /// </summary>
        public async Task<string> GetDisplayTotalCarriedWeightAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                string strFormat = await (await GetSettingsAsync(token).ConfigureAwait(false))
                    .GetWeightFormatAsync(token).ConfigureAwait(false);
                return (await GetTotalCarriedWeightAsync(token).ConfigureAwait(false)).ToString(strFormat,
                        GlobalSettings.CultureInfo) + strSpace
                                                    + "kg"
                                                    + strSpace + "/" + strSpace
                                                    + (await GetCarryLimitAsync(token).ConfigureAwait(false)).ToString(
                                                        strFormat, GlobalSettings.CultureInfo) + strSpace + "kg";
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Armor Encumbrance modifier from Armor.
        /// </summary>
        public int ArmorEncumbrance
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (Settings.NoArmorEncumbrance)
                        return 0;
                    List<Armor> lstArmorsToConsider = Armor.Where(objArmor => objArmor.Equipped).ToList();
                    if (lstArmorsToConsider.Count == 0 || lstArmorsToConsider.TrueForAll(objArmor => !objArmor.Encumbrance))
                        return 0;
                    int intAverageStrength = STR?.TotalValue ?? 0;
                    // Run through the list of Armor currently worn and look at armors that start with '+' since they stack with the highest Armor, but only up to STR.
                    Dictionary<Armor, ValueTuple<int, int>> dicArmorStackingValues
                        = lstArmorsToConsider.ToDictionary(x => x, y => new ValueTuple<int, int>(0, 0));
                    int intNakedEncumbranceValue = 0;
                    foreach (Armor objArmor in lstArmorsToConsider)
                    {
                        if (!objArmor.ArmorValue.StartsWith('+')
                            && !objArmor.ArmorValue.StartsWith('-')
                            && !objArmor.ArmorOverrideValue.StartsWith('+')
                            && !objArmor.ArmorOverrideValue.StartsWith('-'))
                            continue;
                        string strCustomFitName = objArmor.ArmorMods.FirstOrDefault(x => x.Name == "Custom Fit (Stack)" && x.Equipped)?.Extra ?? string.Empty;

                        int intLoopStack = objArmor.ArmorValue.StartsWith('+') || objArmor.ArmorValue.StartsWith('-')
                            ? objArmor.GetTotalArmor()
                            : 0;
                        int intLoopEncumbrance = objArmor.GetTotalArmor(true);
                        foreach (Armor objInnerArmor in lstArmorsToConsider)
                        {
                            if (objInnerArmor == objArmor
                                || objInnerArmor.ArmorValue.StartsWith('+')
                                || objInnerArmor.ArmorValue.StartsWith('-'))
                                continue;
                            if (string.IsNullOrEmpty(strCustomFitName) || strCustomFitName != objInnerArmor.Name)
                            {
                                (int intI, int intJ) = dicArmorStackingValues[objInnerArmor];
                                if (objArmor.Encumbrance)
                                    dicArmorStackingValues[objInnerArmor]
                                        = new ValueTuple<int, int>(intI + intLoopStack, intJ + intLoopEncumbrance);
                                else
                                    dicArmorStackingValues[objInnerArmor]
                                        = new ValueTuple<int, int>(intI + intLoopStack, intJ);
                            }
                            else if (objArmor.ArmorOverrideValue.StartsWith('+') || objArmor.ArmorOverrideValue.StartsWith('-'))
                            {
                                int intLoopCustomFitStack = objArmor.GetTotalOverrideArmor();
                                (int intI, int intJ) = dicArmorStackingValues[objInnerArmor];
                                if (objArmor.Encumbrance)
                                {
                                    int intLoopCustomFitEncumbrance = objArmor.GetTotalOverrideArmor(true);
                                    dicArmorStackingValues[objInnerArmor]
                                        = new ValueTuple<int, int>(intI + intLoopCustomFitStack,
                                                              intJ + intLoopCustomFitEncumbrance);
                                }
                                else
                                    dicArmorStackingValues[objInnerArmor] = new ValueTuple<int, int>(intI + intLoopCustomFitStack, intJ);
                            }
                        }

                        if (objArmor.Encumbrance)
                            intNakedEncumbranceValue += intLoopEncumbrance;
                    }

                    // Run through list of Armor again to cap off any whose stacking bonuses are greater than STR
                    if (!Settings.UncappedArmorAccessoryBonuses)
                    {
                        foreach (Armor objArmor in lstArmorsToConsider)
                        {
                            if (dicArmorStackingValues.TryGetValue(objArmor, out ValueTuple<int, int> tupStack)
                                && tupStack.Item1 > intAverageStrength)
                                dicArmorStackingValues[objArmor]
                                    = new ValueTuple<int, int>(intAverageStrength, tupStack.Item2);
                        }
                    }

                    Armor objHighestArmor = null;
                    int intHighest = 0;
                    int intLowestEncumbrance = int.MaxValue;
                    // Run through the list of Armor a third time to retrieve the highest total Armor rating.
                    foreach (Armor objArmor in lstArmorsToConsider)
                    {
                        if (objArmor.ArmorValue.StartsWith('+')
                            || objArmor.ArmorValue.StartsWith('-'))
                            continue;
                        (int intLoopStack, int intLoopEncumbrance) = dicArmorStackingValues[objArmor];
                        int intLoopTotal = objArmor.GetTotalArmor() + intLoopStack;
                        if (intLoopTotal >= intHighest && (intLoopTotal > intHighest || intLoopEncumbrance < intLowestEncumbrance))
                        {
                            intHighest = intLoopTotal;
                            intLowestEncumbrance = intLoopEncumbrance;
                            objHighestArmor = objArmor;
                        }
                    }

                    if (objHighestArmor == null)
                        intLowestEncumbrance = intNakedEncumbranceValue;

                    // calculate armor encumbrance
                    if (intLowestEncumbrance > intAverageStrength + 1)
                        return (intAverageStrength - intLowestEncumbrance) / 2; // a negative number is expected
                    return 0;
                }
            }
        }

        /// <summary>
        /// Armor Encumbrance modifier from Armor.
        /// </summary>
        public async Task<int> GetArmorEncumbranceAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetNoArmorEncumbranceAsync(token).ConfigureAwait(false))
                    return 0;
                List<Armor> lstArmorsToConsider = await Armor.ToListAsync(objArmor => objArmor.Equipped, token: token).ConfigureAwait(false);
                if (lstArmorsToConsider.Count == 0 || lstArmorsToConsider.TrueForAll(objArmor => !objArmor.Encumbrance))
                    return 0;
                CharacterAttrib objStrength = await GetAttributeAsync("STR", token: token).ConfigureAwait(false);
                int intAverageStrength = objStrength != null ? await objStrength.GetTotalValueAsync(token).ConfigureAwait(false) : 0;
                // Run through the list of Armor currently worn and look at armors that start with '+' since they stack with the highest Armor, but only up to STR.
                Dictionary<Armor, ValueTuple<int, int>> dicArmorStackingValues
                    = lstArmorsToConsider.ToDictionary(x => x, y => new ValueTuple<int, int>(0, 0));
                int intNakedEncumbranceValue = 0;
                foreach (Armor objArmor in lstArmorsToConsider)
                {
                    if (!objArmor.ArmorValue.StartsWith('+')
                        && !objArmor.ArmorValue.StartsWith('-')
                        && !objArmor.ArmorOverrideValue.StartsWith('+')
                        && !objArmor.ArmorOverrideValue.StartsWith('-'))
                        continue;
                    string strCustomFitName = (await objArmor.ArmorMods.FirstOrDefaultAsync(x => x.Name == "Custom Fit (Stack)" && x.Equipped, token: token).ConfigureAwait(false))?.Extra ?? string.Empty;

                    int intLoopStack = objArmor.ArmorValue.StartsWith('+') || objArmor.ArmorValue.StartsWith('-')
                        ? await objArmor.GetTotalArmorAsync(false, token).ConfigureAwait(false)
                        : 0;
                    int intLoopEncumbrance = await objArmor.GetTotalArmorAsync(true, token).ConfigureAwait(false);
                    foreach (Armor objInnerArmor in lstArmorsToConsider)
                    {
                        if (objInnerArmor == objArmor
                            || objInnerArmor.ArmorValue.StartsWith('+')
                            || objInnerArmor.ArmorValue.StartsWith('-'))
                            continue;
                        if (string.IsNullOrEmpty(strCustomFitName) || strCustomFitName != objInnerArmor.Name)
                        {
                            (int intI, int intJ) = dicArmorStackingValues[objInnerArmor];
                            if (objArmor.Encumbrance)
                                dicArmorStackingValues[objInnerArmor]
                                    = new ValueTuple<int, int>(intI + intLoopStack, intJ + intLoopEncumbrance);
                            else
                                dicArmorStackingValues[objInnerArmor]
                                    = new ValueTuple<int, int>(intI + intLoopStack, intJ);
                        }
                        else if (objArmor.ArmorOverrideValue.StartsWith('+')
                                 || objArmor.ArmorOverrideValue.StartsWith('-'))
                        {
                            int intLoopCustomFitStack = await objArmor.GetTotalOverrideArmorAsync(false, token).ConfigureAwait(false);
                            (int intI, int intJ) = dicArmorStackingValues[objInnerArmor];
                            if (objArmor.Encumbrance)
                            {
                                int intLoopCustomFitEncumbrance = await objArmor.GetTotalOverrideArmorAsync(false, token).ConfigureAwait(false);
                                dicArmorStackingValues[objInnerArmor]
                                    = new ValueTuple<int, int>(intI + intLoopCustomFitStack,
                                                          intJ + intLoopCustomFitEncumbrance);
                            }
                            else
                                dicArmorStackingValues[objInnerArmor]
                                    = new ValueTuple<int, int>(intI + intLoopCustomFitStack, intJ);
                        }
                    }

                    if (objArmor.Encumbrance)
                        intNakedEncumbranceValue += intLoopEncumbrance;
                }

                // Run through list of Armor again to cap off any whose stacking bonuses are greater than STR
                if (!await (await GetSettingsAsync(token).ConfigureAwait(false)).GetUncappedArmorAccessoryBonusesAsync(token).ConfigureAwait(false))
                {
                    foreach (Armor objArmor in lstArmorsToConsider)
                    {
                        if (dicArmorStackingValues.TryGetValue(objArmor, out ValueTuple<int, int> tupStack)
                            && tupStack.Item1 > intAverageStrength)
                            dicArmorStackingValues[objArmor]
                                = new ValueTuple<int, int>(intAverageStrength, tupStack.Item2);
                    }
                }

                Armor objHighestArmor = null;
                int intHighest = 0;
                int intLowestEncumbrance = int.MaxValue;
                // Run through the list of Armor a third time to retrieve the highest total Armor rating.
                foreach (Armor objArmor in lstArmorsToConsider)
                {
                    if (objArmor.ArmorValue.StartsWith('+')
                        || objArmor.ArmorValue.StartsWith('-'))
                        continue;
                    (int intLoopStack, int intLoopEncumbrance) = dicArmorStackingValues[objArmor];
                    int intLoopTotal = await objArmor.GetTotalArmorAsync(token: token).ConfigureAwait(false) + intLoopStack;
                    if (intLoopTotal >= intHighest
                        && (intLoopTotal > intHighest || intLoopEncumbrance < intLowestEncumbrance))
                    {
                        intHighest = intLoopTotal;
                        intLowestEncumbrance = intLoopEncumbrance;
                        objHighestArmor = objArmor;
                    }
                }

                if (objHighestArmor == null)
                    intLowestEncumbrance = intNakedEncumbranceValue;

                // calculate armor encumbrance
                if (intLowestEncumbrance > intAverageStrength + 1)
                    return (intAverageStrength - intLowestEncumbrance) / 2; // a negative number is expected
                return 0;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        #endregion Armor Properties

        /// <summary>
        /// Custom Drugs created by the character.
        /// </summary>
        public ThreadSafeObservableCollection<Drug> Drugs
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstDrugs;
            }
        }

        /// <summary>
        /// Custom Drugs created by the character.
        /// </summary>
        public async Task<ThreadSafeObservableCollection<Drug>> GetDrugsAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstDrugs;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        #region Condition Monitors

        /// <summary>
        /// Number of Physical Condition Monitor boxes.
        /// </summary>
        public int PhysicalCM
        {
            get
            {
                int intCMPhysical = 8;
                using (LockObject.EnterReadLock())
                {
                    if (IsAI)
                    {
                        if (HomeNode is Vehicle objVehicle)
                        {
                            return objVehicle.PhysicalCM;
                        }

                        if (DEP != null)
                            // A.I.s use Core Condition Monitors instead of Physical Condition Monitors if they are not in a vehicle or drone.
                            intCMPhysical += DEP.TotalValue.DivAwayFromZero(2);
                    }
                    else
                    {
                        if (BOD != null)
                            intCMPhysical += BOD.TotalValue.DivAwayFromZero(2);
                    }

                    // Include Improvements in the Condition Monitor values.
                    intCMPhysical += ImprovementManager.ValueOf(this, Improvement.ImprovementType.PhysicalCM)
                                                       .StandardRound();
                }

                return intCMPhysical;
            }
        }

        /// <summary>
        /// Number of Physical Condition Monitor boxes.
        /// </summary>
        public async Task<int> GetPhysicalCMAsync(CancellationToken token = default)
        {
            int intCMPhysical = 8;
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    if (await GetHomeNodeAsync(token).ConfigureAwait(false) is Vehicle objVehicle)
                    {
                        return objVehicle.PhysicalCM;
                    }

                    CharacterAttrib objDepth = await GetAttributeAsync("BOD", token: token).ConfigureAwait(false);
                    if (objDepth != null)
                        // A.I.s use Core Condition Monitors instead of Physical Condition Monitors if they are not in a vehicle or drone.
                        intCMPhysical += (await objDepth.GetTotalValueAsync(token)).DivAwayFromZero(2);
                }
                else
                {
                    CharacterAttrib objBody = await GetAttributeAsync("BOD", token: token).ConfigureAwait(false);
                    if (objBody != null)
                        intCMPhysical += (await objBody.GetTotalValueAsync(token).ConfigureAwait(false)).DivAwayFromZero(2);
                }

                // Include Improvements in the Condition Monitor values.
                intCMPhysical += (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.PhysicalCM, token: token).ConfigureAwait(false))
                                                   .StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }

            return intCMPhysical;
        }

        public string PhysicalCMLabelText
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return IsAI
                        ? LanguageManager.GetString(HomeNode is Vehicle ? "Label_OtherPhysicalCM" : "Label_OtherCoreCM")
                        : LanguageManager.GetString("Label_OtherPhysicalCM");
            }
        }

        public async Task<string> GetPhysicalCMLabelTextAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await GetIsAIAsync(token).ConfigureAwait(false)
                    ? await LanguageManager
                        .GetStringAsync(
                            await GetHomeNodeAsync(token).ConfigureAwait(false) is Vehicle
                                ? "Label_OtherPhysicalCM"
                                : "Label_OtherCoreCM",
                            token: token).ConfigureAwait(false)
                    : await LanguageManager.GetStringAsync("Label_OtherPhysicalCM", token: token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string PhysicalCMToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                string strModifiers = LanguageManager.GetString("Tip_Modifiers");
                string strCM;
                using (LockObject.EnterReadLock())
                {
                    int intBonus;
                    if (IsAI)
                    {
                        if (HomeNode is Vehicle objVehicleHomeNode)
                        {
                            strCM = objVehicleHomeNode.BasePhysicalBoxes.ToString(GlobalSettings.CultureInfo) + strSpace
                                +
                                "+" + strSpace + "(" + LanguageManager.GetString("String_VehicleBody") + "÷" + 2.ToString(GlobalSettings.CultureInfo)
                                +
                                ")" + strSpace + "(" +
                                (objVehicleHomeNode.TotalBody.DivAwayFromZero(2)).ToString(GlobalSettings.CultureInfo) + ")";

                            intBonus = objVehicleHomeNode.Mods.Sum(objMod => objMod.ConditionMonitor);
                            if (intBonus != 0)
                                strCM += strSpace + "+" + strSpace + strModifiers + strSpace + "("
                                         + intBonus.ToString(GlobalSettings.CultureInfo) + ")";
                        }
                        else
                        {
                            strCM = 8.ToString(GlobalSettings.CultureInfo) + strSpace + "+" + strSpace + "(" +
                                    DEP.CurrentDisplayAbbrev + "÷" + 2.ToString(GlobalSettings.CultureInfo) + ")" + strSpace
                                    + "(" +
                                    (DEP.TotalValue.DivAwayFromZero(2)).ToString(GlobalSettings.CultureInfo) + ")";

                            intBonus = ImprovementManager.ValueOf(this, Improvement.ImprovementType.PhysicalCM)
                                                         .StandardRound();
                            if (intBonus != 0)
                                strCM += strSpace + "+" + strSpace + strModifiers + strSpace + "("
                                         + intBonus.ToString(GlobalSettings.CultureInfo) + ")";
                        }
                    }
                    else
                    {
                        strCM = 8.ToString(GlobalSettings.CultureInfo) + strSpace + "+" + strSpace + "(" +
                                BOD.CurrentDisplayAbbrev + "÷" + 2.ToString(GlobalSettings.CultureInfo) + ")" + strSpace + "("
                                +
                                (BOD.TotalValue.DivAwayFromZero(2)).ToString(GlobalSettings.CultureInfo) + ")";

                        intBonus = ImprovementManager.ValueOf(this, Improvement.ImprovementType.PhysicalCM)
                                                     .StandardRound();
                        if (intBonus != 0)
                            strCM += strSpace + "+" + strSpace + strModifiers + strSpace + "("
                                     + intBonus.ToString(GlobalSettings.CultureInfo) + ")";
                    }
                }

                return strCM;
            }
        }

        public async Task<string> GetPhysicalCMToolTipAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            string strModifiers =
                await LanguageManager.GetStringAsync("Tip_Modifiers", token: token).ConfigureAwait(false);
            string strCM;
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intBonus;
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    if (await GetHomeNodeAsync(token).ConfigureAwait(false) is Vehicle objVehicleHomeNode)
                    {
                        strCM = objVehicleHomeNode.BasePhysicalBoxes.ToString(GlobalSettings.CultureInfo) + strSpace +
                                "+" + strSpace + "(" + await LanguageManager.GetStringAsync("String_VehicleBody", token: token).ConfigureAwait(false) +
                                "÷" + 2.ToString(GlobalSettings.CultureInfo) + ")" + strSpace + "(" +
                                ((await objVehicleHomeNode.GetTotalBodyAsync(token).ConfigureAwait(false)).DivAwayFromZero(2)).ToString(GlobalSettings.CultureInfo) + ")";

                        intBonus = await objVehicleHomeNode.Mods.SumAsync(objMod => objMod.ConditionMonitor,
                            token: token).ConfigureAwait(false);
                        if (intBonus != 0)
                            strCM += strSpace + "+" + strSpace + strModifiers + strSpace + "("
                                     + intBonus.ToString(GlobalSettings.CultureInfo) + ")";
                    }
                    else
                    {
                        CharacterAttrib objDep = await GetAttributeAsync("DEP", token: token).ConfigureAwait(false);
                        strCM = 8.ToString(GlobalSettings.CultureInfo) + strSpace + "+" + strSpace + "(" +
                                await objDep.GetCurrentDisplayAbbrevAsync(token)
                                    .ConfigureAwait(false) + "÷" +
                                2.ToString(GlobalSettings.CultureInfo) + ")" + strSpace
                                + "(" + ((await objDep.GetTotalValueAsync(token).ConfigureAwait(false)).DivAwayFromZero(2))
                                .ToString(
                                    GlobalSettings.CultureInfo) + ")";

                        intBonus = (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.PhysicalCM,
                                token: token).ConfigureAwait(false))
                            .StandardRound();
                        if (intBonus != 0)
                            strCM += strSpace + "+" + strSpace + strModifiers + strSpace + "("
                                     + intBonus.ToString(GlobalSettings.CultureInfo) + ")";
                    }
                }
                else
                {
                    CharacterAttrib objBod = await GetAttributeAsync("BOD", token: token).ConfigureAwait(false);
                    strCM = 8.ToString(GlobalSettings.CultureInfo) + strSpace + "+" + strSpace + "(" +
                            await objBod.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false) +
                            "÷" + 2.ToString(GlobalSettings.CultureInfo) + ")" + strSpace + "("
                            + ((await objBod.GetTotalValueAsync(token).ConfigureAwait(false)).DivAwayFromZero(2)).ToString(
                                GlobalSettings.CultureInfo) + ")";

                    intBonus = (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.PhysicalCM,
                            token: token).ConfigureAwait(false))
                        .StandardRound();
                    if (intBonus != 0)
                        strCM += strSpace + "+" + strSpace + strModifiers + strSpace + "("
                                 + intBonus.ToString(GlobalSettings.CultureInfo) + ")";
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }

            return strCM;
        }

        /// <summary>
        /// Number of Stun Condition Monitor boxes as meant to displayed for the UI.
        /// It's a hacky work-around for visibility data bindings messing up ther data bindings
        /// </summary>
        public string DisplayStunCM
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    return IsAI && HomeNode == null ? string.Empty : StunCM.ToString(GlobalSettings.CultureInfo);
                }
            }
        }

        /// <summary>
        /// Number of Stun Condition Monitor boxes as meant to displayed for the UI.
        /// It's a hacky work-around for visibility data bindings messing up ther data bindings
        /// </summary>
        public async Task<string> GetDisplayStunCMAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await GetIsAIAsync(token).ConfigureAwait(false) && await GetHomeNodeAsync(token).ConfigureAwait(false) == null
                    ? string.Empty
                    : (await GetStunCMAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Number of Stun Condition Monitor boxes.
        /// </summary>
        public int StunCM
        {
            get
            {
                int intCMStun = 0;
                using (LockObject.EnterReadLock())
                {
                    if (IsAI)
                    {
                        // A.I. do not have a Stun Condition Monitor, but they do have a Matrix Condition Monitor if they are in their home node.
                        if (HomeNode != null)
                        {
                            intCMStun = HomeNode.MatrixCM;
                        }
                    }
                    else
                    {
                        intCMStun = 8 + WIL.TotalValue.DivAwayFromZero(2);
                        // Include Improvements in the Condition Monitor values.
                        intCMStun += ImprovementManager.ValueOf(this, Improvement.ImprovementType.StunCM)
                                                       .StandardRound();
                    }
                }

                return intCMStun;
            }
        }

        /// <summary>
        /// Number of Stun Condition Monitor boxes.
        /// </summary>
        public async Task<int> GetStunCMAsync(CancellationToken token = default)
        {
            int intCMStun = 0;
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    // A.I. do not have a Stun Condition Monitor, but they do have a Matrix Condition Monitor if they are in their home node.
                    IHasMatrixAttributes objHomeNode = await GetHomeNodeAsync(token).ConfigureAwait(false);
                    if (objHomeNode != null)
                    {
                        intCMStun = objHomeNode.MatrixCM;
                    }
                }
                else
                {
                    intCMStun = 8;
                    CharacterAttrib objWillpower = await GetAttributeAsync("WIL", token: token).ConfigureAwait(false);
                    if (objWillpower != null)
                        intCMStun += (await objWillpower.GetTotalValueAsync(token).ConfigureAwait(false)).DivAwayFromZero(2);
                    // Include Improvements in the Condition Monitor values.
                    intCMStun += (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.StunCM, token: token).ConfigureAwait(false))
                                                   .StandardRound();
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }

            return intCMStun;
        }

        public string StunCMLabelText
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (IsAI)
                    {
                        return HomeNode == null ? string.Empty : LanguageManager.GetString("Label_OtherMatrixCM");
                    }

                    return LanguageManager.GetString("Label_OtherStunCM");
                }
            }
        }

        public async Task<string> GetStunCMLabelTextAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    return await GetHomeNodeAsync(token).ConfigureAwait(false) != null
                        ? await LanguageManager.GetStringAsync("Label_OtherMatrixCM", token: token)
                                               .ConfigureAwait(false)
                        : string.Empty;
                }

                return await LanguageManager.GetStringAsync("Label_OtherStunCM", token: token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string StunCMToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                string strModifiers = LanguageManager.GetString("Tip_Modifiers");
                string strCM;
                using (LockObject.EnterReadLock())
                {
                    int intBonus;
                    if (IsAI)
                    {
                        if (HomeNode == null)
                            return string.Empty;
                        strCM = 8.ToString(GlobalSettings.CultureInfo) + strSpace + "+" + strSpace + "(" +
                                LanguageManager.GetString("String_DeviceRating") + "÷" +
                                2.ToString(GlobalSettings.CultureInfo) + ")" + strSpace + "(" +
                                ((HomeNode.GetTotalMatrixAttribute("Device Rating")).DivAwayFromZero(2)).ToString(GlobalSettings
                                    .CultureInfo) + ")";

                        intBonus = HomeNode.TotalBonusMatrixBoxes;
                        if (intBonus != 0)
                            strCM += strSpace + "+" + strSpace + strModifiers + strSpace + "(" +
                                     intBonus.ToString(GlobalSettings.CultureInfo) + ")";
                    }
                    else
                    {
                        strCM = 8.ToString(GlobalSettings.CultureInfo) + strSpace + "+" + strSpace + "(" +
                                WIL.CurrentDisplayAbbrev + "÷" + 2.ToString(GlobalSettings.CultureInfo) + ")" + strSpace + "("
                                +
                                (WIL.TotalValue.DivAwayFromZero(2)).ToString(GlobalSettings.CultureInfo) + ")";

                        intBonus = ImprovementManager.ValueOf(this, Improvement.ImprovementType.StunCM).StandardRound();
                        if (intBonus != 0)
                            strCM += strSpace + "+" + strSpace + strModifiers + strSpace + "(" +
                                     intBonus.ToString(GlobalSettings.CultureInfo) + ")";
                    }
                }

                return strCM;
            }
        }

        public async Task<string> GetStunCMToolTipAsync(CancellationToken token = default)
        {
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            string strModifiers
                = await LanguageManager.GetStringAsync("Tip_Modifiers", token: token).ConfigureAwait(false);
            string strCM;
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intBonus;
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    IHasMatrixAttributes objHomeNode = await GetHomeNodeAsync(token).ConfigureAwait(false);
                    if (objHomeNode == null)
                        return string.Empty;
                    strCM = 8.ToString(GlobalSettings.CultureInfo) + strSpace + "+" + strSpace + "("
                            + await LanguageManager.GetStringAsync("String_DeviceRating", token: token)
                                                   .ConfigureAwait(false) + "÷" + 2.ToString(GlobalSettings.CultureInfo)
                            + ")" + strSpace + "("
                            + ((await objHomeNode.GetTotalMatrixAttributeAsync("Device Rating", token).ConfigureAwait(false)).DivAwayFromZero(2)).ToString(
                                GlobalSettings.CultureInfo) + ")";
                    intBonus = objHomeNode.TotalBonusMatrixBoxes;
                    if (intBonus != 0)
                        strCM += strSpace + "+" + strSpace + strModifiers + strSpace + "("
                                 + intBonus.ToString(GlobalSettings.CultureInfo) + ")";
                }
                else
                {
                    CharacterAttrib objWil = await GetAttributeAsync("WIL", token: token).ConfigureAwait(false);
                    strCM = 8.ToString(GlobalSettings.CultureInfo) + strSpace + "+" + strSpace + "("
                            + await objWil.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false)
                            + "÷" + 2.ToString(GlobalSettings.CultureInfo) + ")" + strSpace + "("
                            + ((await objWil.GetTotalValueAsync(token).ConfigureAwait(false)).DivAwayFromZero(2)).ToString(
                                GlobalSettings.CultureInfo) + ")";
                    intBonus = (await ImprovementManager
                                      .ValueOfAsync(this, Improvement.ImprovementType.StunCM, token: token)
                                      .ConfigureAwait(false)).StandardRound();
                    if (intBonus != 0)
                        strCM += strSpace + "+" + strSpace + strModifiers + strSpace + "(" +
                                 intBonus.ToString(GlobalSettings.CultureInfo) + ")";
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }

            return strCM;
        }

        /// <summary>
        /// Number of Condition Monitor boxes are needed to reach a Condition Monitor Threshold.
        /// </summary>
        public int CMThreshold
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    int intCMThreshold = 3 + ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMThreshold)
                                                               .StandardRound();
                    return intCMThreshold;
                }
            }
        }

        /// <summary>
        /// Number of Condition Monitor boxes are needed to reach a Condition Monitor Threshold.
        /// </summary>
        public async Task<int> GetCMThresholdAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intCMThreshold = 3 + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.CMThreshold, token: token).ConfigureAwait(false))
                                                           .StandardRound();
                return intCMThreshold;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Returns PhysicalCMThresholdOffset and StunCMThresholdOffset as a pair.
        /// </summary>
        public ValueTuple<int, int> CMThresholdOffsets
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return new ValueTuple<int, int>(PhysicalCMThresholdOffset, StunCMThresholdOffset);
            }
        }

        /// <summary>
        /// Returns PhysicalCMThresholdOffset and StunCMThresholdOffset as a pair.
        /// </summary>
        public async Task<ValueTuple<int, int>> GetCMThresholdOffsetsAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return new ValueTuple<int, int>(await GetPhysicalCMThresholdOffsetAsync(token).ConfigureAwait(false), await GetStunCMThresholdOffsetAsync(token).ConfigureAwait(false));
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Number of additional boxes appear before the first Physical Condition Monitor penalty.
        /// </summary>
        public int PhysicalCMThresholdOffset
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (ImprovementManager
                        .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.IgnoreCMPenaltyPhysical)
                        .Count
                        > 0)
                        return int.MaxValue;
                    if (IsAI || ImprovementManager
                                .GetCachedImprovementListForValueOf(
                                    this, Improvement.ImprovementType.IgnoreCMPenaltyStun)
                                .Count > 0)
                        return (ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMThresholdOffset) +
                                ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMSharedThresholdOffset))
                            .StandardRound();

                    decimal decCMThresholdOffset =
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMThresholdOffset);
                    // We're subtracting CM Threshold from the amount of CM boxes filled because you only need to ignore wounds up to your first wound threshold, not all wounds
                    decimal decCMSharedThresholdOffset = decCMThresholdOffset +
                                                         ImprovementManager.ValueOf(this,
                                                             Improvement.ImprovementType.CMSharedThresholdOffset) -
                                                         Math.Max(StunCMFilled - CMThreshold - decCMThresholdOffset, 0);
                    return Math.Max(decCMThresholdOffset, decCMSharedThresholdOffset).StandardRound();
                }
            }
        }

        /// <summary>
        /// Number of additional boxes appear before the first Physical Condition Monitor penalty.
        /// </summary>
        public async Task<int> GetPhysicalCMThresholdOffsetAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if ((await ImprovementManager
                           .GetCachedImprovementListForValueOfAsync(this, Improvement.ImprovementType.IgnoreCMPenaltyPhysical, token: token).ConfigureAwait(false))
                    .Count
                    > 0)
                    return int.MaxValue;
                if (await GetIsAIAsync(token).ConfigureAwait(false) || (await ImprovementManager
                                                                              .GetCachedImprovementListForValueOfAsync(
                                                                                  this, Improvement.ImprovementType.IgnoreCMPenaltyStun, token: token).ConfigureAwait(false))
                            .Count > 0)
                    return (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.CMThresholdOffset, token: token).ConfigureAwait(false) +
                            await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.CMSharedThresholdOffset, token: token).ConfigureAwait(false))
                        .StandardRound();

                decimal decCMThresholdOffset =
                    await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.CMThresholdOffset, token: token).ConfigureAwait(false);
                // We're subtracting CM Threshold from the amount of CM boxes filled because you only need to ignore wounds up to your first wound threshold, not all wounds
                decimal decCMSharedThresholdOffset = decCMThresholdOffset +
                                                     await ImprovementManager.ValueOfAsync(this,
                                                         Improvement.ImprovementType.CMSharedThresholdOffset, token: token).ConfigureAwait(false) -
                                                     Math.Max(StunCMFilled - await GetCMThresholdAsync(token).ConfigureAwait(false) - decCMThresholdOffset, 0);
                return Math.Max(decCMThresholdOffset, decCMSharedThresholdOffset).StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Number of additional boxes appear before the first Stun Condition Monitor penalty.
        /// </summary>
        public int StunCMThresholdOffset
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    // A.I.s don't get wound penalties from Matrix damage
                    if (IsAI)
                        return int.MaxValue;
                    if (ImprovementManager
                        .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.IgnoreCMPenaltyStun)
                        .Count > 0)
                        return int.MaxValue;
                    if (ImprovementManager
                        .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.IgnoreCMPenaltyPhysical)
                        .Count
                        > 0)
                        return (ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMThresholdOffset) +
                                ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMSharedThresholdOffset))
                            .StandardRound();

                    decimal decCMThresholdOffset =
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMThresholdOffset);
                    // We're subtracting CM Threshold from the amount of CM boxes filled because you only need to ignore wounds up to your first wound threshold, not all wounds
                    decimal decCMSharedThresholdOffset = decCMThresholdOffset +
                                                         ImprovementManager.ValueOf(this,
                                                             Improvement.ImprovementType.CMSharedThresholdOffset) -
                                                         Math.Max(PhysicalCMFilled - CMThreshold - decCMThresholdOffset,
                                                                  0);
                    return Math.Max(decCMThresholdOffset, decCMSharedThresholdOffset).StandardRound();
                }
            }
        }

        /// <summary>
        /// Number of additional boxes appear before the first Stun Condition Monitor penalty.
        /// </summary>
        public async Task<int> GetStunCMThresholdOffsetAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                // A.I.s don't get wound penalties from Matrix damage
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                    return int.MaxValue;
                if ((await ImprovementManager
                           .GetCachedImprovementListForValueOfAsync(this, Improvement.ImprovementType.IgnoreCMPenaltyStun, token: token).ConfigureAwait(false))
                    .Count > 0)
                    return int.MaxValue;
                if ((await ImprovementManager
                           .GetCachedImprovementListForValueOfAsync(this, Improvement.ImprovementType.IgnoreCMPenaltyPhysical, token: token).ConfigureAwait(false))
                    .Count
                    > 0)
                    return (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.CMThresholdOffset, token: token).ConfigureAwait(false) +
                            await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.CMSharedThresholdOffset, token: token).ConfigureAwait(false))
                        .StandardRound();

                decimal decCMThresholdOffset =
                    await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.CMThresholdOffset, token: token).ConfigureAwait(false);
                // We're subtracting CM Threshold from the amount of CM boxes filled because you only need to ignore wounds up to your first wound threshold, not all wounds
                decimal decCMSharedThresholdOffset = decCMThresholdOffset +
                                                     await ImprovementManager.ValueOfAsync(this,
                                                         Improvement.ImprovementType.CMSharedThresholdOffset, token: token).ConfigureAwait(false) -
                                                     Math.Max(PhysicalCMFilled - await GetCMThresholdAsync(token).ConfigureAwait(false) - decCMThresholdOffset,
                                                              0);
                return Math.Max(decCMThresholdOffset, decCMSharedThresholdOffset).StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Number of Overflow Condition Monitor boxes.
        /// </summary>
        public int CMOverflow
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    int intCMOverflow = 0;
                    // A.I. do not have an Overflow Condition Monitor.
                    if (!IsAI)
                    {
                        // Characters get a number of overflow boxes equal to their BOD (plus any Improvements). One more boxes is added to mark the character as dead.
                        intCMOverflow = BOD.TotalValue +
                                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMOverflow)
                                                          .StandardRound() + 1;
                    }

                    return intCMOverflow;
                }
            }
        }

        /// <summary>
        /// Number of Overflow Condition Monitor boxes.
        /// </summary>
        public async Task<int> GetCMOverflowAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intCMOverflow = 0;
                // A.I. do not have an Overflow Condition Monitor.
                if (!await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    // Characters get a number of overflow boxes equal to their BOD (plus any Improvements). One more boxes is added to mark the character as dead.
                    intCMOverflow = await (await GetAttributeAsync("BOD", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false) +
                                    (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.CMOverflow, token: token).ConfigureAwait(false))
                                                      .StandardRound() + 1;
                }

                return intCMOverflow;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        #endregion Condition Monitors

        #region Build Properties

        /// <summary>
        /// Method being used to build the character.
        /// </summary>
        public CharacterBuildMethod EffectiveBuildMethod
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return IsCritter ? CharacterBuildMethod.Karma : Settings.BuildMethod;
            }
        }

        /// <summary>
        /// Method being used to build the character.
        /// </summary>
        public async Task<CharacterBuildMethod> GetEffectiveBuildMethodAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await GetIsCritterAsync(token).ConfigureAwait(false)
                    ? CharacterBuildMethod.Karma
                    : await (await GetSettingsAsync(token).ConfigureAwait(false)).GetBuildMethodAsync(token)
                        .ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public bool EffectiveBuildMethodUsesPriorityTables => EffectiveBuildMethod.UsesPriorityTables();

        public async Task<bool>
            GetEffectiveBuildMethodUsesPriorityTablesAsync(CancellationToken token = default) =>
            (await GetEffectiveBuildMethodAsync(token).ConfigureAwait(false)).UsesPriorityTables();

        public bool EffectiveBuildMethodIsLifeModule => EffectiveBuildMethod == CharacterBuildMethod.LifeModule;

        public async Task<bool> GetEffectiveBuildMethodIsLifeModuleAsync(CancellationToken token = default) =>
            await GetEffectiveBuildMethodAsync(token).ConfigureAwait(false) == CharacterBuildMethod.LifeModule;

        public bool EnableAutomaticStoryButton
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return EffectiveBuildMethodIsLifeModule && Settings.AutomaticBackstory;
            }
        }

        public async Task<bool> GetEnableAutomaticStoryButtonAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await GetEffectiveBuildMethodIsLifeModuleAsync(token).ConfigureAwait(false) &&
                       await (await GetSettingsAsync(token).ConfigureAwait(false)).GetAutomaticBackstoryAsync(token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Amount of Nuyen the character has.
        /// </summary>
        public decimal Nuyen
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _decNuyen;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (_decNuyen == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _decNuyen = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Amount of Nuyen the character has.
        /// </summary>
        public async Task<decimal> GetNuyenAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _decNuyen;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Amount of Nuyen the character has.
        /// </summary>
        public async Task SetNuyenAsync(decimal value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_decNuyen == value)
                    return;
                IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    _decNuyen = value;
                    await OnPropertyChangedAsync(nameof(Nuyen), token).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Amount of Nuyen the character has.
        /// </summary>
        public async Task ModifyNuyenAsync(decimal value, CancellationToken token = default)
        {
            if (value == 0)
                return;
            IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                _decNuyen += value;
                await OnPropertyChangedAsync(nameof(Nuyen), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplayNuyen
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return Nuyen.ToString(Settings.NuyenFormat, GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol");
            }
        }

        public async Task<string> GetDisplayNuyenAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                string strNuyenFormat = await (await GetSettingsAsync(token).ConfigureAwait(false)).GetNuyenFormatAsync(token).ConfigureAwait(false);
                return (await GetNuyenAsync(token).ConfigureAwait(false)).ToString(strNuyenFormat,
                    GlobalSettings.CultureInfo) + await LanguageManager
                    .GetStringAsync("String_NuyenSymbol", token: token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Amount of Nuyen the character started with via the priority system.
        /// </summary>
        public decimal StartingNuyen
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _decStartingNuyen;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (_decStartingNuyen == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _decStartingNuyen = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Amount of Nuyen the character started with via the priority system.
        /// </summary>
        public async Task<decimal> GetStartingNuyenAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _decStartingNuyen;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Amount of Nuyen the character started with via the priority system.
        /// </summary>
        public async Task SetStartingNuyenAsync(decimal value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_decStartingNuyen == value)
                    return;
                IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    _decStartingNuyen = value;
                    await OnPropertyChangedAsync(nameof(StartingNuyen), token).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private decimal _decCachedTotalStartingNuyen = decimal.MinValue;

        public decimal TotalStartingNuyen
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    decimal decReturn = _decCachedTotalStartingNuyen;
                    if (decReturn != decimal.MinValue)
                        return decReturn;
                    decimal decFromKarma
                        = CalculateStartingNuyenFromKarma(Math.Min(NuyenBP, TotalNuyenMaximumBP), StartingNuyen);
                    return _decCachedTotalStartingNuyen = decFromKarma +
                                                          ImprovementManager.ValueOf(
                                                              this, Improvement.ImprovementType.Nuyen) -
                                                          ImprovementManager.ValueOf(
                                                              this, Improvement.ImprovementType.Nuyen,
                                                              strImprovedName: "Stolen");
                }
            }
        }

        public async Task<decimal> GetTotalStartingNuyenAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                decimal decReturn = _decCachedTotalStartingNuyen;
                if (decReturn != decimal.MinValue)
                    return decReturn;
                decimal decFromKarma
                    = await CalculateStartingNuyenFromKarmaAsync(
                        Math.Min(await GetNuyenBPAsync(token).ConfigureAwait(false), await GetTotalNuyenMaximumBPAsync(token).ConfigureAwait(false)),
                        await GetStartingNuyenAsync(token).ConfigureAwait(false), token).ConfigureAwait(false);
                return _decCachedTotalStartingNuyen = decFromKarma +
                                               await ImprovementManager.ValueOfAsync(
                                                   this, Improvement.ImprovementType.Nuyen, token: token).ConfigureAwait(false) -
                                               await ImprovementManager.ValueOfAsync(
                                                   this, Improvement.ImprovementType.Nuyen,
                                                   strImprovedName: "Stolen", token: token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private decimal CalculateStartingNuyenFromKarma(decimal decKarma, decimal decStartingNuyen)
        {
            using (LockObject.EnterReadLock())
            {
                string strExpression = Settings.ChargenKarmaToNuyenExpression
                                               .Replace("{Karma}",
                                                        decKarma.ToString(GlobalSettings.InvariantCultureInfo))
                                               .Replace("{PriorityNuyen}",
                                                        decStartingNuyen.ToString(GlobalSettings.InvariantCultureInfo));
                if (strExpression.DoesNeedXPathProcessingToBeConvertedToNumber(out decimal decFromKarma))
                {
                    strExpression = ProcessAttributesInXPath(strExpression);
                    (bool blnIsSuccess, object objProcess) =
                            CommonFunctions.EvaluateInvariantXPath(strExpression);
                    if (blnIsSuccess)
                        decFromKarma = Convert.ToDecimal((double)objProcess);
                }

                return decFromKarma;
            }
        }

        private async Task<decimal> CalculateStartingNuyenFromKarmaAsync(decimal decKarma, decimal decStartingNuyen, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                string strExpression = (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetChargenKarmaToNuyenExpressionAsync(token).ConfigureAwait(false))
                                       .Replace("{Karma}",
                                                decKarma.ToString(GlobalSettings.InvariantCultureInfo))
                                       .Replace("{PriorityNuyen}",
                                                decStartingNuyen.ToString(GlobalSettings.InvariantCultureInfo));
                if (strExpression.DoesNeedXPathProcessingToBeConvertedToNumber(out decimal decFromKarma))
                {
                    strExpression = await ProcessAttributesInXPathAsync(strExpression, token: token).ConfigureAwait(false);
                    (bool blnIsSuccess, object objProcess)
                            = await CommonFunctions.EvaluateInvariantXPathAsync(strExpression, token).ConfigureAwait(false);
                    if (blnIsSuccess)
                        decFromKarma = Convert.ToDecimal((double)objProcess);
                }

                return decFromKarma;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplayTotalStartingNuyen
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return "=" + LanguageManager.GetString("String_Space") +
                           TotalStartingNuyen.ToString(Settings.NuyenFormat, GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol");
            }
        }

        public async Task<string> GetDisplayTotalStartingNuyenAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return "=" + await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false) +
                       (await GetTotalStartingNuyenAsync(token).ConfigureAwait(false)).ToString(await (await GetSettingsAsync(token).ConfigureAwait(false)).GetNuyenFormatAsync(token).ConfigureAwait(false),
                           GlobalSettings.CultureInfo) +
                       await LanguageManager.GetStringAsync("String_NuyenSymbol", token: token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Calculate the amount of Nuyen the character has remaining in Create mode.
        /// </summary>
        public ValueTuple<decimal, decimal> CalculateNuyenCreateMode(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            decimal decDeductions = 0;
            decimal decStolenDeductions = 0;
            using (LockObject.EnterReadLock(token))
            {
                decimal decStolenNuyenAllowance
                    = ImprovementManager.ValueOf(CharacterObject, Improvement.ImprovementType.Nuyen,
                        strImprovedName: "Stolen", token: token);
                //If the character has the Stolen Gear quality or something similar, we need to handle the nuyen a little differently.
                if (decStolenNuyenAllowance != 0)
                {
                    decDeductions
                        += Cyberware.SumParallel(x => x.NonStolenTotalCost, token)
                           + Armor.SumParallel(x => x.NonStolenTotalCost, token)
                           + Weapons.SumParallel(x => x.NonStolenTotalCost, token)
                           + Gear.SumParallel(x => x.NonStolenTotalCost, token)
                           + Vehicles.SumParallel(x => x.NonStolenTotalCost, token)
                           + Drugs.SumParallel(x => x.NonStolenTotalCost, token);
                    decStolenDeductions
                        += Cyberware.SumParallel(x => x.StolenTotalCost, token)
                           + Armor.SumParallel(x => x.StolenTotalCost, token)
                           + Weapons.SumParallel(x => x.StolenTotalCost, token)
                           + Gear.SumParallel(x => x.StolenTotalCost, token)
                           + Vehicles.SumParallel(x => x.StolenTotalCost, token)
                           + Drugs.SumParallel(x => x.StolenTotalCost, token);
                }
                else
                {
                    decDeductions += Cyberware.SumParallel(x => x.TotalCost, token)
                                     + Armor.SumParallel(x => x.TotalCost, token)
                                     + Weapons.SumParallel(x => x.TotalCost, token)
                                     + Gear.SumParallel(x => x.TotalCost, token)
                                     + Vehicles.SumParallel(x => x.TotalCost, token)
                                     + Drugs.SumParallel(x => x.TotalCost, token);
                }

                token.ThrowIfCancellationRequested();
                // Initiation Grade cost.
                decDeductions += Lifestyles.SumParallel(x => x.TotalCost, token)
                                 + 10000 * InitiationGrades.Count(x => x.Schooling, token);
                token.ThrowIfCancellationRequested();
                decimal decReturn = TotalStartingNuyen - decDeductions;
                return new ValueTuple<decimal, decimal>(decReturn, decStolenNuyenAllowance - decStolenDeductions);
            }
        }

        /// <summary>
        /// Calculate the amount of Nuyen the character has remaining in Create mode.
        /// </summary>
        public async Task<ValueTuple<decimal, decimal>> CalculateNuyenCreateModeAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            decimal decDeductions = 0;
            decimal decStolenDeductions = 0;
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token)
                .ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                decimal decStolenNuyenAllowance
                    = await ImprovementManager.ValueOfAsync(CharacterObject, Improvement.ImprovementType.Nuyen,
                        strImprovedName: "Stolen", token: token).ConfigureAwait(false);
                ThreadSafeObservableCollection<Cyberware> lstCyberware
                    = await GetCyberwareAsync(token).ConfigureAwait(false);
                ThreadSafeObservableCollection<Armor> lstArmor
                    = await GetArmorAsync(token).ConfigureAwait(false);
                ThreadSafeObservableCollection<Weapon> lstWeapons
                    = await GetWeaponsAsync(token).ConfigureAwait(false);
                ThreadSafeObservableCollection<Gear> lstGear
                    = await GetGearAsync(token).ConfigureAwait(false);
                ThreadSafeObservableCollection<Vehicle> lstVehicles
                    = await GetVehiclesAsync(token).ConfigureAwait(false);
                ThreadSafeObservableCollection<Drug> lstDrugs
                    = await GetDrugsAsync(token).ConfigureAwait(false);
                //If the character has the Stolen Gear quality or something similar, we need to handle the nuyen a little differently.
                if (decStolenNuyenAllowance != 0)
                {
                    decDeductions
                        += await lstCyberware.SumParallelAsync(x => x.GetNonStolenTotalCostAsync(token), token)
                               .ConfigureAwait(false)
                           + await lstArmor.SumParallelAsync(x => x.GetNonStolenTotalCostAsync(token), token)
                               .ConfigureAwait(false)
                           + await lstWeapons.SumParallelAsync(x => x.GetNonStolenTotalCostAsync(token), token)
                               .ConfigureAwait(false)
                           + await lstGear.SumParallelAsync(x => x.GetNonStolenTotalCostAsync(token), token)
                               .ConfigureAwait(false)
                           + await lstVehicles.SumParallelAsync(x => x.GetNonStolenTotalCostAsync(token), token)
                               .ConfigureAwait(false)
                           + await lstDrugs.SumParallelAsync(x => x.GetNonStolenTotalCostAsync(token), token)
                               .ConfigureAwait(false);
                    decStolenDeductions
                        += await lstCyberware.SumParallelAsync(x => x.GetStolenTotalCostAsync(token), token)
                               .ConfigureAwait(false)
                           + await lstArmor.SumParallelAsync(x => x.GetStolenTotalCostAsync(token), token)
                               .ConfigureAwait(false)
                           + await lstWeapons.SumParallelAsync(x => x.GetStolenTotalCostAsync(token), token)
                               .ConfigureAwait(false)
                           + await lstGear.SumParallelAsync(x => x.GetStolenTotalCostAsync(token), token)
                               .ConfigureAwait(false)
                           + await lstVehicles.SumParallelAsync(x => x.GetStolenTotalCostAsync(token), token)
                               .ConfigureAwait(false)
                           + await lstDrugs.SumParallelAsync(x => x.GetStolenTotalCostAsync(token), token)
                               .ConfigureAwait(false);
                }
                else
                {
                    decDeductions += await lstCyberware.SumParallelAsync(x => x.GetTotalCostAsync(token), token)
                                         .ConfigureAwait(false)
                                     + await lstArmor.SumParallelAsync(x => x.GetTotalCostAsync(token), token)
                                         .ConfigureAwait(false)
                                     + await lstWeapons.SumParallelAsync(x => x.GetTotalCostAsync(token), token)
                                         .ConfigureAwait(false)
                                     + await lstGear.SumParallelAsync(x => x.GetTotalCostAsync(token), token)
                                         .ConfigureAwait(false)
                                     + await lstVehicles.SumParallelAsync(x => x.GetTotalCostAsync(token), token)
                                         .ConfigureAwait(false)
                                     + await lstDrugs.SumParallelAsync(x => x.GetTotalCostAsync(token), token)
                                         .ConfigureAwait(false);
                }

                token.ThrowIfCancellationRequested();
                // Initiation Grade cost.
                decDeductions += await (await GetLifestylesAsync(token).ConfigureAwait(false))
                                     .SumParallelAsync(x => x.GetTotalCostAsync(token), token)
                                     .ConfigureAwait(false)
                                 + 10000 * await (await GetInitiationGradesAsync(token)
                                         .ConfigureAwait(false))
                                     .CountAsync(x => x.Schooling, token).ConfigureAwait(false);
                token.ThrowIfCancellationRequested();
                decimal decReturn = await GetTotalStartingNuyenAsync(token).ConfigureAwait(false)
                                    - decDeductions;
                return new ValueTuple<decimal, decimal>(decReturn, decStolenNuyenAllowance - decStolenDeductions);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// The amount of nuyen the character currently has available to be spent
        /// </summary>
        public decimal GetAvailableNuyen(bool blnStolenGear = false)
        {
            if (Created)
                return Nuyen;
            ValueTuple<decimal, decimal> tupReturn = CalculateNuyenCreateMode();
            return blnStolenGear ? tupReturn.Item2 : tupReturn.Item1;
        }

        /// <summary>
        /// The amount of nuyen the character currently has available to be spent
        /// </summary>
        public async Task<decimal> GetAvailableNuyenAsync(bool blnStolenGear = false, CancellationToken token = default)
        {
            if (await GetCreatedAsync(token).ConfigureAwait(false))
                return await GetNuyenAsync(token).ConfigureAwait(false);
            ValueTuple<decimal, decimal> tupReturn = await CalculateNuyenCreateModeAsync(token).ConfigureAwait(false);
            return blnStolenGear ? tupReturn.Item2 : tupReturn.Item1;
        }

        /// <summary>
        /// Number of Build Points put into Nuyen.
        /// </summary>
        public decimal NuyenBP
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _decNuyenBP;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    value = Math.Max(Math.Min(value, TotalNuyenMaximumBP), 0);
                    if (_decNuyenBP == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _decNuyenBP = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Number of Build Points put into Nuyen.
        /// </summary>
        public async Task<decimal> GetNuyenBPAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _decNuyenBP;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Number of Build Points put into Nuyen.
        /// </summary>
        public async Task SetNuyenBPAsync(decimal value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                value = Math.Max(Math.Min(value, await GetTotalNuyenMaximumBPAsync(token).ConfigureAwait(false)), 0);
                if (_decNuyenBP == value)
                    return;
                IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    _decNuyenBP = value;
                    await OnPropertyChangedAsync(nameof(NuyenBP), token).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Number of Build Points put into Nuyen.
        /// </summary>
        public async Task ModifyNuyenBPAsync(decimal value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (value == 0)
                return;
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                decimal decNewValue = Math.Max(Math.Min(_decNuyenBP + value, await GetTotalNuyenMaximumBPAsync(token).ConfigureAwait(false)), 0);
                if (_decNuyenBP == decNewValue)
                    return;
                IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    _decNuyenBP = decNewValue;
                    await OnPropertyChangedAsync(nameof(NuyenBP), token).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public decimal TotalNuyenMaximumBP
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    const decimal decMaxValue = int.MaxValue;
                    // If UnrestrictedNuyen is enabled, return the maximum possible value
                    if (IgnoreRules || Settings.UnrestrictedNuyen)
                    {
                        return decMaxValue;
                    }

                    return Math.Max(Math.Min(decMaxValue,
                                             Settings.NuyenMaximumBP
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.NuyenMaxBP)), 0);
                }
            }
        }

        /// <summary>
        /// Number of Build Points put into Nuyen.
        /// </summary>
        public async Task<decimal> GetTotalNuyenMaximumBPAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                const decimal decMaxValue = int.MaxValue;
                // If UnrestrictedNuyen is enabled, return the maximum possible value
                if (await GetIgnoreRulesAsync(token).ConfigureAwait(false))
                {
                    return decMaxValue;
                }

                CharacterSettings objSettings = await GetSettingsAsync(token).ConfigureAwait(false);
                if (await objSettings.GetUnrestrictedNuyenAsync(token).ConfigureAwait(false))
                {
                    return decMaxValue;
                }

                return Math.Max(Math.Min(decMaxValue,
                                         await objSettings.GetNuyenMaximumBPAsync(token).ConfigureAwait(false)
                                         + await ImprovementManager.ValueOfAsync(
                                             this, Improvement.ImprovementType.NuyenMaxBP, token: token).ConfigureAwait(false)), 0);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether the character has any stolen nuyen at character creation.
        /// </summary>
        public bool HasStolenNuyen => ImprovementManager
            .ValueOf(this, Improvement.ImprovementType.Nuyen, strImprovedName: "Stolen") != 0;

        /// <summary>
        /// Whether the character has any stolen nuyen at character creation.
        /// </summary>
        public async Task<bool> GetHasStolenNuyenAsync(CancellationToken token = default) =>
            await ImprovementManager.ValueOfAsync(this,
                Improvement.ImprovementType.Nuyen, strImprovedName: "Stolen", token: token).ConfigureAwait(false) > 0;

        /// <summary>
        /// The calculated Astral Limit.
        /// </summary>
        public int LimitAstral
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return Math.Max(LimitMental, LimitSocial);
            }
        }

        /// <summary>
        /// The calculated Astral Limit.
        /// </summary>
        public async Task<int> GetLimitAstralAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return Math.Max(await GetLimitMentalAsync(token).ConfigureAwait(false),
                    await GetLimitSocialAsync(token).ConfigureAwait(false));
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string LimitAstralToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (LockObject.EnterReadLock())
                    return LanguageManager.GetString("Label_Options_Maximum") +
                        strSpace + "(" + LanguageManager.GetString("String_LimitMentalShort") +
                        strSpace + "[" + LimitMental.ToString(GlobalSettings.CultureInfo) + "]," +
                        strSpace + LanguageManager.GetString("String_LimitSocialShort") +
                        strSpace + "[" + LimitSocial.ToString(GlobalSettings.CultureInfo) + "])";
            }
        }

        public async Task<string> GetLimitAstralToolTipAsync(CancellationToken token = default)
        {
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await LanguageManager.GetStringAsync("Label_Options_Maximum", token: token).ConfigureAwait(false) +
                    strSpace + "(" + await LanguageManager.GetStringAsync("String_LimitMentalShort", token: token).ConfigureAwait(false) +
                    strSpace + "[" + (await GetLimitMentalAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo) + "]," +
                    strSpace + await LanguageManager.GetStringAsync("String_LimitSocialShort", token: token).ConfigureAwait(false) +
                    strSpace + "[" + (await GetLimitSocialAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo) + "])";
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// The calculated Physical Limit.
        /// </summary>
        public int LimitPhysical
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (IsAI)
                    {
                        Vehicle objHomeNodeVehicle = HomeNode as Vehicle;
                        return objHomeNodeVehicle?.Handling ?? 0;
                    }

                    int intLimit = (STR.TotalValue * 2 + BOD.TotalValue + REA.TotalValue).DivAwayFromZero(3);
                    return intLimit + ImprovementManager.ValueOf(this, Improvement.ImprovementType.PhysicalLimit)
                                                        .StandardRound();
                }
            }
        }

        /// <summary>
        /// The calculated Physical Limit.
        /// </summary>
        public async Task<int> GetLimitPhysicalAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    Vehicle objHomeNodeVehicle = await GetHomeNodeAsync(token).ConfigureAwait(false) as Vehicle;
                    return objHomeNodeVehicle?.Handling ?? 0;
                }

                int intStr = await STR.GetTotalValueAsync(token).ConfigureAwait(false);
                int intBod = await BOD.GetTotalValueAsync(token).ConfigureAwait(false);
                int intRea = await REA.GetTotalValueAsync(token).ConfigureAwait(false);
                int intLimit = (intStr * 2 + intBod + intRea).DivAwayFromZero(3);
                return intLimit + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.PhysicalLimit, token: token).ConfigureAwait(false))
                    .StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string LimitPhysicalToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (LockObject.EnterReadLock())
                {
                    if (IsAI)
                    {
                        Vehicle objHomeNodeVehicle = HomeNode as Vehicle;
                        return LanguageManager.GetString("String_Handling").ConcatFast(strSpace, "[",
                                             (objHomeNodeVehicle?.Handling ?? 0).ToString(GlobalSettings.CultureInfo), "]");
                    }

                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append('(', STR.CurrentDisplayAbbrev, strSpace)
                                  .Append('[', STR.TotalValue.ToString(GlobalSettings.CultureInfo), ']')
                                  .Append(strSpace, '×', strSpace)
                                  .Append(2.ToString(GlobalSettings.CultureInfo), strSpace, '+')
                                  .Append(strSpace, BOD.CurrentDisplayAbbrev, strSpace)
                                  .Append('[', BOD.TotalValue.ToString(GlobalSettings.CultureInfo), ']')
                                  .Append(strSpace, '+', strSpace).Append(REA.CurrentDisplayAbbrev, strSpace, '[')
                                  .Append(REA.TotalValue.ToString(GlobalSettings.CultureInfo), "])", strSpace)
                                  .Append('/', strSpace, 3.ToString(GlobalSettings.CultureInfo));
                        foreach (Improvement objLoopImprovement in
                                 ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.PhysicalLimit))
                        {
                            sbdToolTip.Append(strSpace, '+').Append(strSpace, GetObjectName(objLoopImprovement), strSpace)
                                .Append('(', objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo), ')');
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        public async Task<string> GetLimitPhysicalToolTipAsync(CancellationToken token = default)
        {
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    Vehicle objHomeNodeVehicle = await GetHomeNodeAsync(token).ConfigureAwait(false) as Vehicle;
                    return (await LanguageManager.GetStringAsync("String_Handling", token: token).ConfigureAwait(false)).ConcatFast(strSpace, "[",
                        (objHomeNodeVehicle?.Handling ?? 0).ToString(GlobalSettings.CultureInfo), "]");
                }

                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                           out StringBuilder sbdToolTip))
                {
                    int intStr = await STR.GetTotalValueAsync(token).ConfigureAwait(false);
                    int intBod = await BOD.GetTotalValueAsync(token).ConfigureAwait(false);
                    int intRea = await REA.GetTotalValueAsync(token).ConfigureAwait(false);
                    sbdToolTip.Append('(', await STR.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false), strSpace)
                        .Append('[', intStr.ToString(GlobalSettings.CultureInfo), ']')
                        .Append(strSpace, '×', strSpace)
                        .Append(2.ToString(GlobalSettings.CultureInfo), strSpace, '+')
                        .Append(strSpace, await BOD.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false), strSpace)
                        .Append('[', intBod.ToString(GlobalSettings.CultureInfo), ']')
                        .Append(strSpace, '+', strSpace)
                        .Append(await REA.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false), strSpace, '[')
                        .Append(intRea.ToString(GlobalSettings.CultureInfo), "])", strSpace)
                        .Append('/', strSpace, 3.ToString(GlobalSettings.CultureInfo));
                    foreach (Improvement objLoopImprovement in
                             await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                 this, Improvement.ImprovementType.PhysicalLimit, token: token).ConfigureAwait(false))
                    {
                        sbdToolTip.Append(strSpace, '+').Append(strSpace, await GetObjectNameAsync(objLoopImprovement, token: token).ConfigureAwait(false), strSpace)
                            .Append('(', objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo), ')');
                    }

                    return sbdToolTip.ToString();
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// The calculated Mental Limit.
        /// </summary>
        public int LimitMental
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    int intLimit = (LOG.TotalValue * 2 + INT.TotalValue + WIL.TotalValue).DivAwayFromZero(3);
                    if (IsAI && HomeNode != null)
                    {
                        if (HomeNode is Vehicle objHomeNodeVehicle)
                        {
                            int intHomeNodeSensor = objHomeNodeVehicle.CalculatedSensor;
                            if (intHomeNodeSensor > intLimit)
                            {
                                intLimit = intHomeNodeSensor;
                            }
                        }

                        int intHomeNodeDP = HomeNode.GetTotalMatrixAttribute("Data Processing");
                        if (intHomeNodeDP > intLimit)
                        {
                            intLimit = intHomeNodeDP;
                        }
                    }

                    return intLimit + ImprovementManager.ValueOf(this, Improvement.ImprovementType.MentalLimit)
                                                        .StandardRound();
                }
            }
        }

        /// <summary>
        /// The calculated Mental Limit.
        /// </summary>
        public async Task<int> GetLimitMentalAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intLog = await LOG.GetTotalValueAsync(token).ConfigureAwait(false);
                int intInt = await INT.GetTotalValueAsync(token).ConfigureAwait(false);
                int intWil = await WIL.GetTotalValueAsync(token).ConfigureAwait(false);
                int intLimit = (intLog * 2 + intInt + intWil).DivAwayFromZero(3);
                if (await GetIsAIAsync(token).ConfigureAwait(false) && await GetHomeNodeAsync(token).ConfigureAwait(false) is IHasMatrixAttributes objHomeNode)
                {
                    if (objHomeNode is Vehicle objHomeNodeVehicle)
                    {
                        int intHomeNodeSensor = await objHomeNodeVehicle.GetCalculatedSensorAsync(token).ConfigureAwait(false);
                        if (intHomeNodeSensor > intLimit)
                        {
                            intLimit = intHomeNodeSensor;
                        }
                    }

                    int intHomeNodeDP = await objHomeNode.GetTotalMatrixAttributeAsync("Data Processing", token).ConfigureAwait(false);
                    if (intHomeNodeDP > intLimit)
                    {
                        intLimit = intHomeNodeDP;
                    }
                }

                return intLimit + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.MentalLimit, token: token).ConfigureAwait(false))
                    .StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string LimitMentalToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (LockObject.EnterReadLock())
                {
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append('(', LOG.CurrentDisplayAbbrev, strSpace)
                                  .Append('[', LOG.TotalValue.ToString(GlobalSettings.CultureInfo), ']')
                                  .Append(strSpace, '×', strSpace)
                                  .Append(2.ToString(GlobalSettings.CultureInfo), strSpace, '+')
                                  .Append(strSpace, INT.CurrentDisplayAbbrev, strSpace)
                                  .Append('[', INT.TotalValue.ToString(GlobalSettings.CultureInfo), ']')
                                  .Append(strSpace, '+', strSpace)
                                  .Append(WIL.CurrentDisplayAbbrev, strSpace, '[')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo), "])", strSpace)
                                  .Append('/', strSpace, 3.ToString(GlobalSettings.CultureInfo));

                        if (IsAI && HomeNode != null)
                        {
                            int intLimit = (LOG.TotalValue * 2 + INT.TotalValue + WIL.TotalValue).DivAwayFromZero(3);
                            if (HomeNode is Vehicle objHomeNodeVehicle)
                            {
                                int intHomeNodeSensor = objHomeNodeVehicle.CalculatedSensor;
                                if (intHomeNodeSensor > intLimit)
                                {
                                    intLimit = intHomeNodeSensor;
                                    sbdToolTip.Clear();
                                    sbdToolTip.Append(LanguageManager.GetString("String_Sensor"), strSpace)
                                              .Append('[', intLimit.ToString(GlobalSettings.CultureInfo), ']');
                                }
                            }

                            int intHomeNodeDP = HomeNode.GetTotalMatrixAttribute("Data Processing");
                            if (intHomeNodeDP > intLimit)
                            {
                                intLimit = intHomeNodeDP;
                                sbdToolTip.Clear();
                                sbdToolTip.Append(LanguageManager.GetString("String_DataProcessing"), strSpace)
                                          .Append('[', intLimit.ToString(GlobalSettings.CultureInfo), ']');
                            }
                        }

                        foreach (Improvement objLoopImprovement in
                                 ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.MentalLimit))
                        {
                            sbdToolTip.Append(strSpace, '+').Append(strSpace, GetObjectName(objLoopImprovement), strSpace)
                                .Append('(', objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo), ')');
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        public async Task<string> GetLimitMentalToolTipAsync(CancellationToken token = default)
        {
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    int intLog = await LOG.GetTotalValueAsync(token).ConfigureAwait(false);
                    int intInt = await INT.GetTotalValueAsync(token).ConfigureAwait(false);
                    int intWil = await WIL.GetTotalValueAsync(token).ConfigureAwait(false);
                    sbdToolTip.Append('(', await LOG.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false), strSpace)
                              .Append('[', intLog.ToString(GlobalSettings.CultureInfo), ']')
                              .Append(strSpace, '×', strSpace)
                              .Append(2.ToString(GlobalSettings.CultureInfo), strSpace, '+')
                              .Append(strSpace, await INT.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false), strSpace)
                              .Append('[', intInt.ToString(GlobalSettings.CultureInfo), ']')
                              .Append(strSpace, '+', strSpace)
                              .Append(await WIL.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false), strSpace, '[')
                              .Append(intWil.ToString(GlobalSettings.CultureInfo), "])", strSpace)
                              .Append('/', strSpace, 3.ToString(GlobalSettings.CultureInfo));

                    if (await GetIsAIAsync(token).ConfigureAwait(false) && await GetHomeNodeAsync(token).ConfigureAwait(false) is IHasMatrixAttributes objHomeNode)
                    {
                        int intLimit = (intLog * 2 + intInt + intWil).DivAwayFromZero(3);
                        if (objHomeNode is Vehicle objHomeNodeVehicle)
                        {
                            int intHomeNodeSensor = await objHomeNodeVehicle.GetCalculatedSensorAsync(token).ConfigureAwait(false);
                            if (intHomeNodeSensor > intLimit)
                            {
                                intLimit = intHomeNodeSensor;
                                sbdToolTip.Clear();
                                sbdToolTip.Append(await LanguageManager.GetStringAsync("String_Sensor", token: token).ConfigureAwait(false), strSpace)
                                          .Append('[', intLimit.ToString(GlobalSettings.CultureInfo), ']');
                            }
                        }

                        int intHomeNodeDP = await objHomeNode.GetTotalMatrixAttributeAsync("Data Processing", token).ConfigureAwait(false);
                        if (intHomeNodeDP > intLimit)
                        {
                            intLimit = intHomeNodeDP;
                            sbdToolTip.Clear();
                            sbdToolTip.Append(await LanguageManager.GetStringAsync("String_DataProcessing", token: token).ConfigureAwait(false), strSpace)
                                      .Append('[', intLimit.ToString(GlobalSettings.CultureInfo), ']');
                        }
                    }

                    foreach (Improvement objLoopImprovement in
                             await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                 this, Improvement.ImprovementType.MentalLimit, token: token).ConfigureAwait(false))
                    {
                        sbdToolTip.Append(strSpace, '+').Append(strSpace, await GetObjectNameAsync(objLoopImprovement, token: token).ConfigureAwait(false), strSpace)
                            .Append('(', objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo), ')');
                    }

                    return sbdToolTip.ToString();
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// The calculated Social Limit.
        /// </summary>
        public int LimitSocial
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    int intLimit = CHA.TotalValue;
                    if (IsAI && HomeNode != null)
                    {
                        int intHomeNodeDP = HomeNode.GetTotalMatrixAttribute("Data Processing");

                        if (HomeNode is Vehicle objHomeNodeVehicle)
                        {
                            int intHomeNodePilot = objHomeNodeVehicle.Pilot;
                            if (intHomeNodePilot > intHomeNodeDP)
                                intHomeNodeDP = intHomeNodePilot;
                        }

                        intLimit += intHomeNodeDP;
                    }
                    else
                        intLimit *= 2;

                    intLimit = (intLimit + WIL.TotalValue + Essence().StandardRound()).DivAwayFromZero(3);

                    return intLimit + ImprovementManager.ValueOf(this, Improvement.ImprovementType.SocialLimit)
                        .StandardRound();
                }
            }
        }

        /// <summary>
        /// The calculated Social Limit.
        /// </summary>
        public async Task<int> GetLimitSocialAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intWil = await WIL.GetTotalValueAsync(token).ConfigureAwait(false);
                int intEss = (await EssenceAsync(token: token).ConfigureAwait(false)).StandardRound();
                int intLimit = await CHA.GetTotalValueAsync(token).ConfigureAwait(false);
                if (await GetIsAIAsync(token).ConfigureAwait(false) &&
                    await GetHomeNodeAsync(token).ConfigureAwait(false) is IHasMatrixAttributes objHomeNode)
                {
                    int intHomeNodeDP = await objHomeNode.GetTotalMatrixAttributeAsync("Data Processing", token)
                        .ConfigureAwait(false);

                    if (objHomeNode is Vehicle objHomeNodeVehicle)
                    {
                        int intHomeNodePilot = await objHomeNodeVehicle.GetPilotAsync(token).ConfigureAwait(false);
                        if (intHomeNodePilot > intHomeNodeDP)
                            intHomeNodeDP = intHomeNodePilot;
                    }

                    intLimit += intHomeNodeDP;
                }
                else
                    intLimit *= 2;

                intLimit = (intLimit + intWil + intEss).DivAwayFromZero(3);

                return intLimit + (await ImprovementManager
                        .ValueOfAsync(this, Improvement.ImprovementType.SocialLimit, token: token)
                        .ConfigureAwait(false))
                    .StandardRound();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string LimitSocialToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (LockObject.EnterReadLock())
                {
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append('(', CHA.CurrentDisplayAbbrev, strSpace)
                            .Append('[', CHA.TotalValue.ToString(GlobalSettings.CultureInfo), ']');
                        if (IsAI && HomeNode != null)
                        {
                            int intHomeNodeDP = HomeNode.GetTotalMatrixAttribute("Data Processing");
                            string strDPString = LanguageManager.GetString("String_DataProcessing");
                            if (HomeNode is Vehicle objHomeNodeVehicle)
                            {
                                int intHomeNodePilot = objHomeNodeVehicle.Pilot;
                                if (intHomeNodePilot > intHomeNodeDP)
                                {
                                    intHomeNodeDP = intHomeNodePilot;
                                    strDPString = LanguageManager.GetString("String_Pilot");
                                }
                            }

                            sbdToolTip.Append(strSpace, '+').Append(strSpace, strDPString, strSpace)
                                      .Append('[', intHomeNodeDP.ToString(GlobalSettings.CultureInfo), ']');
                        }
                        else
                        {
                            sbdToolTip.Append(strSpace, '×').Append(strSpace, 2.ToString(GlobalSettings.CultureInfo));
                        }

                        sbdToolTip.Append(strSpace, '+', strSpace)
                                  .Append(WIL.CurrentDisplayAbbrev, strSpace, '[')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo), ']', strSpace)
                                  .Append('+', strSpace, ESS.CurrentDisplayAbbrev)
                                  .Append(strSpace, '[', DisplayEssence).Append("])", strSpace, '/')
                                  .Append(strSpace, 3.ToString(GlobalSettings.CultureInfo));

                        foreach (Improvement objLoopImprovement in
                                 ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.SocialLimit))
                        {
                            sbdToolTip.Append(strSpace, '+').Append(strSpace, GetObjectName(objLoopImprovement), strSpace)
                                .Append('(', objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo), ')');
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        public async Task<string> GetLimitSocialToolTipAsync(CancellationToken token = default)
        {
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    int intCha = await CHA.GetTotalValueAsync(token).ConfigureAwait(false);
                    int intWil = await WIL.GetTotalValueAsync(token).ConfigureAwait(false);
                    sbdToolTip.Append('(', await CHA.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false), strSpace)
                        .Append('[', intCha.ToString(GlobalSettings.CultureInfo), ']');
                    if (await GetIsAIAsync(token).ConfigureAwait(false) && await GetHomeNodeAsync(token).ConfigureAwait(false) is IHasMatrixAttributes objHomeNode)
                    {
                        int intHomeNodeDP = await objHomeNode.GetTotalMatrixAttributeAsync("Data Processing", token).ConfigureAwait(false);
                        string strDPString = await LanguageManager.GetStringAsync("String_DataProcessing", token: token).ConfigureAwait(false);
                        if (objHomeNode is Vehicle objHomeNodeVehicle)
                        {
                            int intHomeNodePilot = await objHomeNodeVehicle.GetPilotAsync(token).ConfigureAwait(false);
                            if (intHomeNodePilot > intHomeNodeDP)
                            {
                                intHomeNodeDP = intHomeNodePilot;
                                strDPString = await LanguageManager.GetStringAsync("String_Pilot", token: token).ConfigureAwait(false);
                            }
                        }

                        sbdToolTip.Append(strSpace, '+').Append(strSpace, strDPString, strSpace)
                                  .Append('[', intHomeNodeDP.ToString(GlobalSettings.CultureInfo), ']');
                    }
                    else
                    {
                        sbdToolTip.Append(strSpace, '×').Append(strSpace, 2.ToString(GlobalSettings.CultureInfo));
                    }

                    sbdToolTip.Append(strSpace, '+', strSpace)
                        .Append(await WIL.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false), strSpace, '[')
                        .Append(intWil.ToString(GlobalSettings.CultureInfo), ']', strSpace)
                        .Append('+', strSpace, await ESS.GetCurrentDisplayAbbrevAsync(token).ConfigureAwait(false))
                        .Append(strSpace, '[', await GetDisplayEssenceAsync(token).ConfigureAwait(false))
                        .Append("])", strSpace, '/')
                        .Append(strSpace, 3.ToString(GlobalSettings.CultureInfo));

                    foreach (Improvement objLoopImprovement in
                             await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                 this, Improvement.ImprovementType.SocialLimit, token: token).ConfigureAwait(false))
                    {
                        sbdToolTip.Append(strSpace, '+', strSpace).Append(await GetObjectNameAsync(objLoopImprovement, token: token).ConfigureAwait(false), strSpace)
                            .Append('(', objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo), ')');
                    }

                    return sbdToolTip.ToString();
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public bool HasMentorSpirit
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return MentorSpirits.Count > 0;
            }
        }

        public async Task<bool> GetHasMentorSpiritAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await (await GetMentorSpiritsAsync(token).ConfigureAwait(false)).GetCountAsync(token).ConfigureAwait(false) > 0;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string FirstMentorSpiritDisplayName
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return MentorSpirits.Count > 0
                        ? MentorSpirits[0].CurrentDisplayNameShort
                        : string.Empty;
            }
        }

        public async Task<string> GetFirstMentorSpiritDisplayNameAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                ThreadSafeObservableCollection<MentorSpirit> lstMentors = await GetMentorSpiritsAsync(token).ConfigureAwait(false);
                return await lstMentors.GetCountAsync(token).ConfigureAwait(false) > 0
                    ? await (await lstMentors.GetValueAtAsync(0, token).ConfigureAwait(false))
                        .GetCurrentDisplayNameShortAsync(token).ConfigureAwait(false)
                    : string.Empty;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string FirstMentorSpiritDisplayInformation
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (MentorSpirits.Count == 0)
                        return string.Empty;

                    MentorSpirit objMentorSpirit = MentorSpirits[0];
                    string strSpace = LanguageManager.GetString("String_Space");
                    string strAdvantage = objMentorSpirit.DisplayAdvantage(GlobalSettings.Language);
                    if (string.IsNullOrWhiteSpace(strAdvantage))
                        strAdvantage = LanguageManager.GetString("String_None");
                    string strDisadvantage = objMentorSpirit.DisplayDisadvantage(GlobalSettings.Language);
                    if (string.IsNullOrWhiteSpace(strDisadvantage))
                        strDisadvantage = LanguageManager.GetString("String_None");
                    string strReturn = LanguageManager.GetString("Label_SelectMentorSpirit_Advantage") + strSpace +
                                       strAdvantage + Environment.NewLine + Environment.NewLine +
                                       LanguageManager.GetString("Label_SelectMentorSpirit_Disadvantage") + strSpace +
                                       strDisadvantage;
                    string strExtraReturn = objMentorSpirit.DisplayExtras(GlobalSettings.Language);
                    if (!string.IsNullOrEmpty(strExtraReturn))
                    {
                        strReturn += Environment.NewLine + Environment.NewLine +
                                     LanguageManager.GetString("Label_SelectMentorSpirit_Choices") +
                                     Environment.NewLine +
                                     strExtraReturn;
                    }
                    return strReturn.WordWrap();
                }
            }
        }

        public async Task<string> GetFirstMentorSpiritDisplayInformationAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await MentorSpirits.GetCountAsync(token).ConfigureAwait(false) == 0)
                    return string.Empty;

                MentorSpirit objMentorSpirit = await MentorSpirits.GetValueAtAsync(0, token).ConfigureAwait(false);
                string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
                string strAdvantage = await objMentorSpirit.DisplayAdvantageAsync(GlobalSettings.Language, token).ConfigureAwait(false);
                if (string.IsNullOrWhiteSpace(strAdvantage))
                    strAdvantage = await LanguageManager.GetStringAsync("String_None", token: token).ConfigureAwait(false);
                string strDisadvantage = await objMentorSpirit.DisplayDisadvantageAsync(GlobalSettings.Language, token).ConfigureAwait(false);
                if (string.IsNullOrWhiteSpace(strDisadvantage))
                    strDisadvantage = await LanguageManager.GetStringAsync("String_None", token: token).ConfigureAwait(false);
                string strReturn =
                    await LanguageManager.GetStringAsync("Label_SelectMentorSpirit_Advantage", token: token).ConfigureAwait(false) +
                    strSpace + strAdvantage + Environment.NewLine + Environment.NewLine +
                    await LanguageManager.GetStringAsync("Label_SelectMentorSpirit_Disadvantage", token: token).ConfigureAwait(false) +
                    strSpace + strDisadvantage;
                string strExtraReturn = await objMentorSpirit.DisplayExtrasAsync(GlobalSettings.Language, token).ConfigureAwait(false);
                if (!string.IsNullOrEmpty(strExtraReturn))
                {
                    strReturn += Environment.NewLine + Environment.NewLine +
                                 await LanguageManager.GetStringAsync("Label_SelectMentorSpirit_Choices",
                                     token: token).ConfigureAwait(false) + Environment.NewLine + strExtraReturn;
                }
                return strReturn.WordWrap();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        #endregion Build Properties

        #region Metatype/Metavariant Information

        /// <summary>
        /// Character's Metatype.
        /// </summary>
        public string Metatype
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _strMetatype;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _strMetatype, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Metatype.
        /// </summary>
        public async Task<string> GetMetatypeAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _strMetatype;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public Guid MetatypeGuid
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _guiMetatype;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (_guiMetatype == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _guiMetatype = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// The name of the metatype as it should appear on printouts (translated name only).
        /// </summary>
        public string DisplayMetatype(string strLanguage)
        {
            using (LockObject.EnterReadLock())
            {
                if (strLanguage.Equals(GlobalSettings.DefaultLanguage, StringComparison.OrdinalIgnoreCase))
                    return Metatype;

                return GetNodeXPath(true, strLanguage)?.SelectSingleNodeAndCacheExpression("translate")?.Value
                       ?? Metatype;
            }
        }

        /// <summary>
        /// The name of the metatype as it should appear on printouts (translated name only).
        /// </summary>
        public async Task<string> DisplayMetatypeAsync(string strLanguage, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (strLanguage.Equals(GlobalSettings.DefaultLanguage, StringComparison.OrdinalIgnoreCase))
                    return Metatype;

                XPathNavigator objNode = await GetNodeXPathAsync(true, strLanguage, token).ConfigureAwait(false);
                return objNode != null
                    ? objNode.SelectSingleNodeAndCacheExpression("translate", token: token)
                    ?.Value ?? Metatype
                    : Metatype;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's Metavariant.
        /// </summary>
        public string Metavariant
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _strMetavariant;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _strMetavariant, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Metavariant.
        /// </summary>
        public async Task<string> GetMetavariantAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _strMetavariant;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public Guid MetavariantGuid
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _guiMetavariant;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (_guiMetavariant == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _guiMetavariant = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        public async Task<Guid> GetMetavariantGuidAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _guiMetavariant;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// The name of the metatype as it should appear on printouts (translated name only).
        /// </summary>
        public string DisplayMetavariant(string strLanguage)
        {
            using (LockObject.EnterReadLock())
            {
                if (strLanguage.Equals(GlobalSettings.DefaultLanguage, StringComparison.OrdinalIgnoreCase))
                    return Metavariant;

                return GetNodeXPath(false, strLanguage)?.SelectSingleNodeAndCacheExpression("translate")?.Value
                       ?? Metavariant;
            }
        }

        /// <summary>
        /// The name of the metatype as it should appear on printouts (translated name only).
        /// </summary>
        public async Task<string> DisplayMetavariantAsync(string strLanguage, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (strLanguage.Equals(GlobalSettings.DefaultLanguage, StringComparison.OrdinalIgnoreCase))
                    return Metavariant;

                XPathNavigator objNode = await GetNodeXPathAsync(false, strLanguage, token).ConfigureAwait(false);
                return objNode != null
                    ? objNode.SelectSingleNodeAndCacheExpression("translate", token: token)
                             ?.Value ?? Metavariant
                    : Metavariant;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string FormattedMetatype => FormattedMetatypeMethod(GlobalSettings.Language);

        public Task<string> GetFormattedMetatypeAsync(CancellationToken token = default) =>
            FormattedMetatypeMethodAsync(GlobalSettings.Language, token);

        /// <summary>
        /// The metatype, including metavariant if any, in an appropriate language.
        /// </summary>
        /// <param name="strLanguage">Language to be used. Defaults to GlobalSettings.Language</param>
        public string FormattedMetatypeMethod(string strLanguage = "")
        {
            using (LockObject.EnterReadLock())
            {
                if (string.IsNullOrEmpty(strLanguage))
                    strLanguage = GlobalSettings.Language;
                string strMetatype = DisplayMetatype(strLanguage);

                if (MetavariantGuid != Guid.Empty)
                {
                    strMetatype += LanguageManager.GetString("String_Space") + "(" + DisplayMetavariant(strLanguage)
                                   + ")";
                }

                return strMetatype;
            }
        }

        /// <summary>
        /// The metatype, including metavariant if any, in an appropriate language.
        /// </summary>
        /// <param name="strLanguage">Language to be used. Defaults to GlobalSettings.Language</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public async Task<string> FormattedMetatypeMethodAsync(string strLanguage = "", CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (string.IsNullOrEmpty(strLanguage))
                    strLanguage = GlobalSettings.Language;
                string strMetatype = await DisplayMetatypeAsync(strLanguage, token).ConfigureAwait(false);

                if (await GetMetavariantGuidAsync(token).ConfigureAwait(false) != Guid.Empty)
                {
                    strMetatype += await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false) + "("
                        + await DisplayMetavariantAsync(strLanguage, token).ConfigureAwait(false) + ")";
                }

                return strMetatype;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Metatype Category.
        /// </summary>
        public string MetatypeCategory
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _strMetatypeCategory;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    string strOldValue = Interlocked.Exchange(ref _strMetatypeCategory, value);
                    if (strOldValue == value)
                        return;
                    if (strOldValue == "Cyberzombie" || value == "Cyberzombie")
                        this.OnMultiplePropertyChanged(nameof(MetatypeCategory),
                            nameof(EssenceAtSpecialStart)); // Proxy for refreshing Essence loss improvements
                    else
                        OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Metatype Category.
        /// </summary>
        public async Task<string> GetMetatypeCategoryAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _strMetatypeCategory;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Metatype Category.
        /// </summary>
        public async Task SetMetatypeCategoryAsync(string value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                string strOldValue = Interlocked.Exchange(ref _strMetatypeCategory, value);
                if (strOldValue == value)
                    return;
                if (strOldValue == "Cyberzombie" || value == "Cyberzombie")
                    await this.OnMultiplePropertyChangedAsync(token, nameof(MetatypeCategory),
                        nameof(EssenceAtSpecialStart)).ConfigureAwait(false); // Proxy for refreshing Essence loss improvements
                else
                    await OnPropertyChangedAsync(nameof(MetatypeCategory), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public int LimbCount(string strLimbSlot = "")
        {
            using (LockObject.EnterReadLock())
            {
                if (string.IsNullOrEmpty(strLimbSlot))
                {
                    return Settings.LimbCount + ImprovementManager.ValueOf(this, Improvement.ImprovementType.AddLimb)
                                                                  .StandardRound();
                }

                int intReturn =
                    1 + ImprovementManager.ValueOf(this, Improvement.ImprovementType.AddLimb, false, strLimbSlot)
                                          .StandardRound();
                if (strLimbSlot == "arm" || strLimbSlot == "leg")
                    ++intReturn;
                return intReturn;
            }
        }

        public async Task<int> LimbCountAsync(string strLimbSlot = "", CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (string.IsNullOrEmpty(strLimbSlot))
                {
                    return await (await GetSettingsAsync(token).ConfigureAwait(false)).GetLimbCountAsync(token).ConfigureAwait(false) + (await ImprovementManager
                            .ValueOfAsync(this, Improvement.ImprovementType.AddLimb, token: token)
                            .ConfigureAwait(false))
                        .StandardRound();
                }

                int intReturn =
                    1 + (await ImprovementManager
                        .ValueOfAsync(this, Improvement.ImprovementType.AddLimb, false, strLimbSlot, token: token)
                        .ConfigureAwait(false))
                    .StandardRound();
                if (strLimbSlot == "arm" || strLimbSlot == "leg")
                    ++intReturn;
                return intReturn;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplayMovement => GetMovement(GlobalSettings.CultureInfo, GlobalSettings.Language);

        public Task<string> GetDisplayMovementAsync(CancellationToken token = default) =>
            GetMovementAsync(GlobalSettings.CultureInfo, GlobalSettings.Language, token);

        /// <summary>
        /// Character's Movement rate (Culture-dependent).
        /// </summary>
        public string GetMovement(CultureInfo objCulture, string strLanguage)
        {
            using (LockObject.EnterReadLock())
                // Don't attempt to do anything if the character's Movement is "Special" (typically for A.I.s).
                return Movement == "Special"
                    ? LanguageManager.GetString("String_ModeSpecial", strLanguage)
                    : CalculatedMovement("Ground", true, objCulture, strLanguage);
        }

        /// <summary>
        /// Character's Movement rate (Culture-dependent).
        /// </summary>
        public async Task<string> GetMovementAsync(CultureInfo objCulture, string strLanguage, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            // Don't attempt to do anything if the character's Movement is "Special" (typically for A.I.s).
            {
                token.ThrowIfCancellationRequested();
                return await GetMovementAsync(token).ConfigureAwait(false) == "Special"
                    ? await LanguageManager.GetStringAsync("String_ModeSpecial", strLanguage, token: token).ConfigureAwait(false)
                    : await CalculatedMovementAsync("Ground", true, objCulture, strLanguage, token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's Movement rate data string.
        /// </summary>
        public string Movement
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (string.IsNullOrWhiteSpace(_strMovement))
                    {
                        return _strMovement = this.GetNodeXPath()?.SelectSingleNodeAndCacheExpression("movement")?.Value
                                       ?? GetNodeXPath(true)?.SelectSingleNodeAndCacheExpression("movement")?.Value
                                       ?? string.Empty;
                    }

                    return _strMovement;
                }
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _strMovement, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Movement rate data string.
        /// </summary>
        public async Task<string> GetMovementAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (string.IsNullOrWhiteSpace(_strMovement))
                {
                    XPathNavigator xmlDataNode = await this.GetNodeXPathAsync(token: token).ConfigureAwait(false);
                    if (xmlDataNode != null)
                        _strMovement
                            = xmlDataNode.SelectSingleNodeAndCacheExpression("movement", token: token)?.Value
                              ?? string.Empty;
                    if (xmlDataNode == null || string.IsNullOrEmpty(_strMovement))
                    {
                        xmlDataNode = await GetNodeXPathAsync(true, token: token).ConfigureAwait(false);
                        if (xmlDataNode != null)
                            return _strMovement
                                = xmlDataNode.SelectSingleNodeAndCacheExpression("movement", token: token)?.Value
                                  ?? string.Empty;
                        else
                            return _strMovement = string.Empty;
                    }
                }

                return _strMovement;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's Run rate data string.
        /// </summary>
        public string RunString
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (string.IsNullOrWhiteSpace(_strRun))
                    {
                        return _strRun = this.GetNodeXPath()?.SelectSingleNodeAndCacheExpression("run")?.Value
                                  ?? GetNodeXPath(true)?.SelectSingleNodeAndCacheExpression("run")?.Value
                                  ?? string.Empty;
                    }

                    return _strRun;
                }
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _strRun, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Run rate data string.
        /// </summary>
        public async Task<string> GetRunStringAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (string.IsNullOrWhiteSpace(_strRun))
                {
                    XPathNavigator xmlDataNode = await this.GetNodeXPathAsync(token: token).ConfigureAwait(false);
                    if (xmlDataNode != null)
                        _strRun
                            = xmlDataNode.SelectSingleNodeAndCacheExpression("run", token: token)?.Value
                              ?? string.Empty;
                    if (xmlDataNode == null || string.IsNullOrEmpty(_strRun))
                    {
                        xmlDataNode = await GetNodeXPathAsync(true, token: token).ConfigureAwait(false);
                        if (xmlDataNode != null)
                            return _strRun
                                = xmlDataNode.SelectSingleNodeAndCacheExpression("run", token: token)?.Value
                                  ?? string.Empty;
                        else
                            return _strRun = string.Empty;
                    }
                }

                return _strRun;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's Alternate Run rate data string.
        /// </summary>
        public string RunAltString
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (string.IsNullOrWhiteSpace(_strRunAlt))
                    {
                        return _strRunAlt = this.GetNodeXPath()?.SelectSingleNodeAndCacheExpression("run")
                                         ?.GetAttribute("alt", string.Empty)
                                     ?? GetNodeXPath(true)?.SelectSingleNodeAndCacheExpression("run")
                                                          ?.GetAttribute("alt", string.Empty)
                                     ?? string.Empty;
                    }

                    return _strRunAlt;
                }
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _strRunAlt, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Alternate Run rate data string.
        /// </summary>
        public async Task<string> GetRunAltStringAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (string.IsNullOrWhiteSpace(_strRunAlt))
                {
                    XPathNavigator xmlDataNode = await this.GetNodeXPathAsync(token: token).ConfigureAwait(false);
                    if (xmlDataNode != null)
                        _strRunAlt
                            = xmlDataNode.SelectSingleNodeAndCacheExpression("run", token: token)?.GetAttribute("alt", string.Empty)
                              ?? string.Empty;
                    if (xmlDataNode == null || string.IsNullOrEmpty(_strRunAlt))
                    {
                        xmlDataNode = await GetNodeXPathAsync(true, token: token).ConfigureAwait(false);
                        return xmlDataNode != null
                            ? _strRunAlt
                                = xmlDataNode.SelectSingleNodeAndCacheExpression("run", token: token)
                                      ?.GetAttribute("alt", string.Empty)
                                  ?? string.Empty
                            : _strRunAlt = string.Empty;
                    }
                }

                return _strRunAlt;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's Walk rate data string.
        /// </summary>
        public string WalkString
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (string.IsNullOrWhiteSpace(_strWalk))
                    {
                        return _strWalk = this.GetNodeXPath()?.SelectSingleNodeAndCacheExpression("walk")?.Value
                                   ?? GetNodeXPath(true)?.SelectSingleNodeAndCacheExpression("walk")?.Value
                                   ?? string.Empty;
                    }

                    return _strWalk;
                }
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _strWalk, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Walk rate data string.
        /// </summary>
        public async Task<string> GetWalkStringAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (string.IsNullOrWhiteSpace(_strWalk))
                {
                    XPathNavigator xmlDataNode = await this.GetNodeXPathAsync(token: token).ConfigureAwait(false);
                    if (xmlDataNode != null)
                        _strWalk
                            = xmlDataNode.SelectSingleNodeAndCacheExpression("walk", token: token)?.Value
                              ?? string.Empty;
                    if (xmlDataNode == null || string.IsNullOrEmpty(_strWalk))
                    {
                        xmlDataNode = await GetNodeXPathAsync(true, token: token).ConfigureAwait(false);
                        if (xmlDataNode != null)
                            return _strWalk
                                = xmlDataNode.SelectSingleNodeAndCacheExpression("walk", token: token)?.Value
                                  ?? string.Empty;
                        else
                            return _strWalk = string.Empty;
                    }
                }

                return _strWalk;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's Alternate Walk rate data string.
        /// </summary>
        public string WalkAltString
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (string.IsNullOrWhiteSpace(_strWalkAlt))
                    {
                        return _strWalkAlt = this.GetNodeXPath()?.SelectSingleNodeAndCacheExpression("walk")
                                          ?.GetAttribute("alt", string.Empty)
                                      ?? GetNodeXPath(true)?.SelectSingleNodeAndCacheExpression("walk")
                                                           ?.GetAttribute("alt", string.Empty)
                                      ?? string.Empty;
                    }

                    return _strWalkAlt;
                }
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _strWalkAlt, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Alternate Walk rate data string.
        /// </summary>
        public async Task<string> GetWalkAltStringAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (string.IsNullOrWhiteSpace(_strWalkAlt))
                {
                    XPathNavigator xmlDataNode = await this.GetNodeXPathAsync(token: token).ConfigureAwait(false);
                    if (xmlDataNode != null)
                        _strWalkAlt
                            = xmlDataNode.SelectSingleNodeAndCacheExpression("walk", token: token)?.GetAttribute("alt", string.Empty)
                              ?? string.Empty;
                    if (xmlDataNode == null || string.IsNullOrEmpty(_strWalkAlt))
                    {
                        xmlDataNode = await GetNodeXPathAsync(true, token: token).ConfigureAwait(false);
                        if (xmlDataNode != null)
                            return _strWalkAlt
                                = xmlDataNode.SelectSingleNodeAndCacheExpression("walk", token: token)?.GetAttribute("alt", string.Empty)
                                  ?? string.Empty;
                        else
                            return _strWalkAlt = string.Empty;
                    }
                }

                return _strWalkAlt;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's Sprint rate data string.
        /// </summary>
        public string SprintString
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (string.IsNullOrWhiteSpace(_strSprint))
                    {
                        return _strSprint = this.GetNodeXPath()?.SelectSingleNodeAndCacheExpression("sprint")?.Value
                                     ?? GetNodeXPath(true)?.SelectSingleNodeAndCacheExpression("sprint")?.Value
                                     ?? string.Empty;
                    }

                    return _strSprint;
                }
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _strSprint, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Spring rate data string.
        /// </summary>
        public async Task<string> GetSprintStringAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (string.IsNullOrWhiteSpace(_strSprint))
                {
                    XPathNavigator xmlDataNode = await this.GetNodeXPathAsync(token: token).ConfigureAwait(false);
                    if (xmlDataNode != null)
                        _strSprint
                            = xmlDataNode.SelectSingleNodeAndCacheExpression("sprint", token: token)?.Value
                              ?? string.Empty;
                    if (xmlDataNode == null || string.IsNullOrEmpty(_strSprint))
                    {
                        xmlDataNode = await GetNodeXPathAsync(true, token: token).ConfigureAwait(false);
                        if (xmlDataNode != null)
                            return _strSprint
                                = xmlDataNode.SelectSingleNodeAndCacheExpression("sprint", token: token)?.Value
                                  ?? string.Empty;
                        else
                            return _strSprint = string.Empty;
                    }
                }

                return _strSprint;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's Alternate Sprint rate data string.
        /// </summary>
        public string SprintAltString
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (string.IsNullOrWhiteSpace(_strSprintAlt))
                    {
                        return _strSprintAlt = this.GetNodeXPath()?.SelectSingleNodeAndCacheExpression("sprint")
                                            ?.GetAttribute("alt", string.Empty)
                                        ?? GetNodeXPath(true)?.SelectSingleNodeAndCacheExpression("sprint")
                                                             ?.GetAttribute("alt", string.Empty)
                                        ?? string.Empty;
                    }

                    return _strSprintAlt;
                }
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _strSprintAlt, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Alternate Sprint rate data string.
        /// </summary>
        public async Task<string> GetSprintAltStringAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (string.IsNullOrWhiteSpace(_strSprintAlt))
                {
                    XPathNavigator xmlDataNode = await this.GetNodeXPathAsync(token: token).ConfigureAwait(false);
                    if (xmlDataNode != null)
                        _strSprintAlt
                            = xmlDataNode.SelectSingleNodeAndCacheExpression("sprint", token: token)?.GetAttribute("alt", string.Empty)
                              ?? string.Empty;
                    if (xmlDataNode == null || string.IsNullOrEmpty(_strSprintAlt))
                    {
                        xmlDataNode = await GetNodeXPathAsync(true, token: token).ConfigureAwait(false);
                        if (xmlDataNode != null)
                            return _strSprintAlt
                                = xmlDataNode.SelectSingleNodeAndCacheExpression("sprint", token: token)?.GetAttribute("alt", string.Empty)
                                  ?? string.Empty;
                        else
                            return _strSprintAlt = string.Empty;
                    }
                }

                return _strSprintAlt;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string CurrentWalkingRateString
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return AttributeSection.AttributeCategory == AttributeCategory.Standard
                        ? WalkString
                        : WalkAltString;
            }
        }

        public string CurrentRunningRateString
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return AttributeSection.AttributeCategory == AttributeCategory.Standard
                        ? RunString
                        : RunAltString;
            }
        }

        public string CurrentSprintingRateString
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return AttributeSection.AttributeCategory == AttributeCategory.Standard
                        ? SprintString
                        : SprintAltString;
            }
        }

        public async Task<string> GetCurrentWalkingRateStringAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await (await GetAttributeSectionAsync(token).ConfigureAwait(false))
                             .GetAttributeCategoryAsync(token).ConfigureAwait(false)
                       != AttributeCategory.Standard
                    ? await GetWalkAltStringAsync(token).ConfigureAwait(false)
                    : await GetWalkStringAsync(token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public async Task<string> GetCurrentRunningRateStringAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await (await GetAttributeSectionAsync(token).ConfigureAwait(false))
                             .GetAttributeCategoryAsync(token).ConfigureAwait(false)
                       != AttributeCategory.Standard
                    ? await GetRunAltStringAsync(token).ConfigureAwait(false)
                    : await GetRunStringAsync(token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public async Task<string> GetCurrentSprintingRateStringAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await (await GetAttributeSectionAsync(token).ConfigureAwait(false))
                             .GetAttributeCategoryAsync(token).ConfigureAwait(false)
                       != AttributeCategory.Standard
                    ? await GetSprintAltStringAsync(token).ConfigureAwait(false)
                    : await GetSprintStringAsync(token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's running Movement rate.
        /// <param name="strType">Takes one of three parameters: Ground, 2 for Swim, 3 for Fly. Returns 0 if the requested type isn't found.</param>
        /// </summary>
        public decimal WalkingRate(string strType = "Ground")
        {
            using (LockObject.EnterReadLock())
            {
                decimal decTmp = decimal.MinValue;
                foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                             this, Improvement.ImprovementType.WalkSpeed, strType))
                    decTmp = Math.Max(decTmp, objImprovement.Value);

                if (decTmp != decimal.MinValue)
                    return decTmp;

                int intIndexToGet = 0;
                switch (strType.ToUpperInvariant())
                {
                    case "FLY":
                        intIndexToGet = 2;
                        break;

                    case "SWIM":
                        intIndexToGet = 1;
                        break;
                }

                string strReturn = CurrentWalkingRateString.SplitNoAlloc('/', StringSplitOptions.RemoveEmptyEntries)
                                                           .ElementAtOrDefaultBetter(intIndexToGet);
                if (strReturn != null)
                    decimal.TryParse(strReturn, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                     out decTmp);
                return decTmp;
            }
        }

        /// <summary>
        /// Character's running Movement rate.
        /// <param name="strType">Takes one of three parameters: Ground, 2 for Swim, 3 for Fly. Returns 0 if the requested type isn't found.</param>
        /// </summary>
        public async Task<decimal> WalkingRateAsync(string strType = "Ground", CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                decimal decTmp = decimal.MinValue;
                foreach (Improvement objImprovement in await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                             this, Improvement.ImprovementType.WalkSpeed, strType, token: token).ConfigureAwait(false))
                    decTmp = Math.Max(decTmp, objImprovement.Value);

                if (decTmp != decimal.MinValue)
                    return decTmp;

                int intIndexToGet = 0;
                switch (strType.ToUpperInvariant())
                {
                    case "FLY":
                        intIndexToGet = 2;
                        break;

                    case "SWIM":
                        intIndexToGet = 1;
                        break;
                }

                string strReturn = (await GetCurrentWalkingRateStringAsync(token).ConfigureAwait(false))
                                   .SplitNoAlloc('/', StringSplitOptions.RemoveEmptyEntries)
                                   .ElementAtOrDefaultBetter(intIndexToGet);
                if (strReturn != null)
                    decimal.TryParse(strReturn, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                     out decTmp);
                return decTmp;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's running Movement rate.
        /// <param name="strType">Takes one of three parameters: Ground, 2 for Swim, 3 for Fly. Returns 0 if the requested type isn't found.</param>
        /// </summary>
        public decimal RunningRate(string strType = "Ground")
        {
            using (LockObject.EnterReadLock())
            {
                decimal decTmp = decimal.MinValue;
                foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                             this, Improvement.ImprovementType.RunSpeed, strType))
                    decTmp = Math.Max(decTmp, objImprovement.Value);

                if (decTmp != decimal.MinValue)
                    return decTmp;

                int intIndexToGet = 0;
                switch (strType.ToUpperInvariant())
                {
                    case "FLY":
                        intIndexToGet = 2;
                        break;

                    case "SWIM":
                        intIndexToGet = 1;
                        break;
                }

                string strReturn = CurrentRunningRateString.SplitNoAlloc('/', StringSplitOptions.RemoveEmptyEntries)
                                                           .ElementAtOrDefaultBetter(intIndexToGet);
                if (strReturn != null)
                    decimal.TryParse(strReturn, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                     out decTmp);
                return decTmp;
            }
        }

        /// <summary>
        /// Character's running Movement rate.
        /// <param name="strType">Takes one of three parameters: Ground, 2 for Swim, 3 for Fly. Returns 0 if the requested type isn't found.</param>
        /// </summary>
        public async Task<decimal> RunningRateAsync(string strType = "Ground", CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                decimal decTmp = decimal.MinValue;
                foreach (Improvement objImprovement in await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                             this, Improvement.ImprovementType.RunSpeed, strType, token: token).ConfigureAwait(false))
                    decTmp = Math.Max(decTmp, objImprovement.Value);

                if (decTmp != decimal.MinValue)
                    return decTmp;

                int intIndexToGet = 0;
                switch (strType.ToUpperInvariant())
                {
                    case "FLY":
                        intIndexToGet = 2;
                        break;

                    case "SWIM":
                        intIndexToGet = 1;
                        break;
                }

                string strReturn = (await GetCurrentRunningRateStringAsync(token).ConfigureAwait(false))
                                   .SplitNoAlloc('/', StringSplitOptions.RemoveEmptyEntries)
                                   .ElementAtOrDefaultBetter(intIndexToGet);
                if (strReturn != null)
                    decimal.TryParse(strReturn, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                     out decTmp);
                return decTmp;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's sprinting Movement rate (meters per hit).
        /// <param name="strType">Takes one of three parameters: Ground, 2 for Swim, 3 for Fly. Returns 0 if the requested type isn't found.</param>
        /// </summary>
        public decimal SprintingRate(string strType = "Ground")
        {
            using (LockObject.EnterReadLock())
            {
                decimal decTmp = decimal.MinValue;
                foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                             this, Improvement.ImprovementType.SprintSpeed, strType))
                    decTmp = Math.Max(decTmp, objImprovement.Value / 100.0m);

                if (decTmp != decimal.MinValue)
                    return decTmp;

                int intIndexToGet = 0;
                switch (strType.ToUpperInvariant())
                {
                    case "FLY":
                        intIndexToGet = 2;
                        break;

                    case "SWIM":
                        intIndexToGet = 1;
                        break;
                }

                string strReturn = CurrentSprintingRateString.SplitNoAlloc('/', StringSplitOptions.RemoveEmptyEntries)
                                                             .ElementAtOrDefaultBetter(intIndexToGet);
                if (strReturn != null)
                    decimal.TryParse(strReturn, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                     out decTmp);
                return decTmp;
            }
        }

        /// <summary>
        /// Character's sprinting Movement rate (meters per hit).
        /// <param name="strType">Takes one of three parameters: Ground, 2 for Swim, 3 for Fly. Returns 0 if the requested type isn't found.</param>
        /// </summary>
        public async Task<decimal> SprintingRateAsync(string strType = "Ground", CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                decimal decTmp = decimal.MinValue;
                foreach (Improvement objImprovement in await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                             this, Improvement.ImprovementType.SprintSpeed, strType, token: token).ConfigureAwait(false))
                    decTmp = Math.Max(decTmp, objImprovement.Value / 100.0m);

                if (decTmp != decimal.MinValue)
                    return decTmp;

                int intIndexToGet = 0;
                switch (strType.ToUpperInvariant())
                {
                    case "FLY":
                        intIndexToGet = 2;
                        break;

                    case "SWIM":
                        intIndexToGet = 1;
                        break;
                }

                string strReturn = (await GetCurrentSprintingRateStringAsync(token).ConfigureAwait(false))
                                   .SplitNoAlloc('/', StringSplitOptions.RemoveEmptyEntries)
                                   .ElementAtOrDefaultBetter(intIndexToGet);
                if (strReturn != null)
                    decimal.TryParse(strReturn, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                     out decTmp);
                return decTmp;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string CalculatedMovement(string strMovementType, bool blnUseCyberlegs = false,
            CultureInfo objCulture = null, string strLanguage = "")
        {
            using (LockObject.EnterReadLock())
            {
                decimal decSprint = SprintingRate(strMovementType) +
                                    ImprovementManager.ValueOf(this, Improvement.ImprovementType.SprintBonus, false,
                                                               strMovementType) / 100.0m;
                decimal decRun = RunningRate(strMovementType) + ImprovementManager.ValueOf(this,
                    Improvement.ImprovementType.RunMultiplier, false, strMovementType);
                decimal decWalk = WalkingRate(strMovementType) + ImprovementManager.ValueOf(this,
                    Improvement.ImprovementType.WalkMultiplier, false, strMovementType);
                // Everything else after this just multiplies values, so zeroes can be checked for here
                if (decWalk == 0 && decRun == 0 && decSprint == 0)
                {
                    return "0";
                }

                decSprint *= 1.0m + ImprovementManager.ValueOf(this, Improvement.ImprovementType.SprintBonusPercent,
                                                               false,
                                                               strMovementType) / 100.0m;
                decRun *= 1.0m + ImprovementManager.ValueOf(this, Improvement.ImprovementType.RunMultiplierPercent,
                                                            false,
                                                            strMovementType) / 100.0m;
                decWalk *= 1.0m + ImprovementManager.ValueOf(this, Improvement.ImprovementType.WalkMultiplierPercent,
                                                             false,
                                                             strMovementType) / 100.0m;

                //Swimming uses all limbs
                bool blnIsSwimming = strMovementType == "Swim";
                int intAGI = blnIsSwimming ? AGI.TotalValue : AGI.CalculatedTotalValue(false);
                if (blnIsSwimming)
                {
                    int intSTR = STR.TotalValue;
                    decWalk *= (intAGI + intSTR) * 0.5m;
                    decRun *= (intAGI + intSTR) * 0.5m;
                }
                else
                {
                    if (Settings.CyberlegMovement && blnUseCyberlegs)
                    {
                        int intTempAGI = int.MaxValue;
                        int intLegs = Cyberware.Sum(x => x.LimbSlot == "leg", x =>
                        {
                            intTempAGI = Math.Min(intTempAGI, x.GetAttributeTotalValue("AGI"));
                            return x.LimbSlotCount;
                        });

                        if (intTempAGI != int.MaxValue && intLegs >= 2)
                        {
                            intAGI = intTempAGI;
                        }
                    }
                    decWalk *= intAGI;
                    decRun *= intAGI;
                }

                if (objCulture == null)
                    objCulture = GlobalSettings.CultureInfo;
                string strReturn = string.Empty;
                if (decWalk != 0)
                {
                    if (decRun != 0)
                        strReturn = decWalk.ToString("#,0.##", objCulture) + "/"
                                                                           + decRun.ToString("#,0.##", objCulture);
                    else
                        strReturn = decWalk.ToString("#,0.##", objCulture);
                }
                else if (decRun != 0 || decSprint != 0)
                    strReturn = decRun.ToString("#,0.##", objCulture);

                if (decSprint != 0)
                {
                    if (!string.IsNullOrEmpty(strReturn))
                        strReturn += ";" + LanguageManager.GetString("String_Space", strLanguage);
                    strReturn += decSprint.ToString("#,0.##", objCulture)
                                 + LanguageManager.GetString("String_MetersPerHit", strLanguage);
                }

                return strReturn;
            }
        }

        public async Task<string> CalculatedMovementAsync(string strMovementType, bool blnUseCyberlegs = false,
            CultureInfo objCulture = null, string strLanguage = "", CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                decimal decSprint = await SprintingRateAsync(strMovementType, token).ConfigureAwait(false)
                                    + await ImprovementManager.ValueOfAsync(
                                        this, Improvement.ImprovementType.SprintBonus, false, strMovementType,
                                        token: token).ConfigureAwait(false) / 100.0m;
                decimal decRun = await RunningRateAsync(strMovementType, token).ConfigureAwait(false)
                                 + await ImprovementManager.ValueOfAsync(
                                     this, Improvement.ImprovementType.RunMultiplier, false, strMovementType,
                                     token: token).ConfigureAwait(false);
                decimal decWalk = await WalkingRateAsync(strMovementType, token).ConfigureAwait(false)
                                  + await ImprovementManager.ValueOfAsync(
                                      this, Improvement.ImprovementType.WalkMultiplier, false, strMovementType,
                                      token: token).ConfigureAwait(false);
                // Everything else after this just multiplies values, so zeroes can be checked for here
                if (decWalk == 0 && decRun == 0 && decSprint == 0)
                {
                    return "0";
                }

                decSprint *= 1.0m + await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SprintBonusPercent,
                                                                          false,
                                                                          strMovementType, token: token).ConfigureAwait(false) / 100.0m;
                decRun *= 1.0m + await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.RunMultiplierPercent,
                                                                       false,
                                                                       strMovementType, token: token).ConfigureAwait(false) / 100.0m;
                decWalk *= 1.0m + await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.WalkMultiplierPercent,
                                                                        false,
                                                                        strMovementType, token: token).ConfigureAwait(false) / 100.0m;

                //Swimming uses all limbs
                bool blnIsSwimming = strMovementType == "Swim";
                CharacterAttrib objAgi = await GetAttributeAsync("AGI", token: token).ConfigureAwait(false);
                int intAGI = blnIsSwimming ? await objAgi.GetTotalValueAsync(token).ConfigureAwait(false) : await objAgi.CalculatedTotalValueAsync(false, token).ConfigureAwait(false);
                if (blnIsSwimming)
                {
                    int intSTR = await (await GetAttributeAsync("STR", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false);
                    decWalk *= (intAGI + intSTR) * 0.5m;
                    decRun *= (intAGI + intSTR) * 0.5m;
                }
                else
                {
                    if (blnUseCyberlegs && await (await GetSettingsAsync(token).ConfigureAwait(false)).GetCyberlegMovementAsync(token).ConfigureAwait(false))
                    {
                        int intTempAGI = int.MaxValue;
                        int intLegs = await (await GetCyberwareAsync(token).ConfigureAwait(false)).SumAsync(
                            x => x.LimbSlot == "leg", async objCyber =>
                            {
                                intTempAGI = Math.Min(intTempAGI,
                                    await objCyber.GetAttributeTotalValueAsync("AGI", token).ConfigureAwait(false));
                                return await objCyber.GetLimbSlotCountAsync(token).ConfigureAwait(false);
                            }, token).ConfigureAwait(false);

                        if (intTempAGI != int.MaxValue && intLegs >= 2)
                        {
                            intAGI = intTempAGI;
                        }
                    }
                    decWalk *= intAGI;
                    decRun *= intAGI;
                }

                if (objCulture == null)
                    objCulture = GlobalSettings.CultureInfo;
                string strReturn = string.Empty;
                if (decWalk != 0)
                {
                    if (decRun != 0)
                        strReturn = decWalk.ToString("#,0.##", objCulture) + "/"
                                                                           + decRun.ToString("#,0.##", objCulture);
                    else
                        strReturn = decWalk.ToString("#,0.##", objCulture);
                }
                else if (decRun != 0 || decSprint != 0)
                    strReturn = decRun.ToString("#,0.##", objCulture);

                if (decSprint != 0)
                {
                    if (!string.IsNullOrEmpty(strReturn))
                        strReturn += ";" + await LanguageManager.GetStringAsync("String_Space", strLanguage, token: token).ConfigureAwait(false);
                    strReturn += decSprint.ToString("#,0.##", objCulture)
                                 + await LanguageManager.GetStringAsync("String_MetersPerHit", strLanguage, token: token).ConfigureAwait(false);
                }

                return strReturn;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplaySwim => GetSwim(GlobalSettings.CultureInfo, GlobalSettings.Language);

        public Task<string> GetDisplaySwimAsync(CancellationToken token = default) => GetSwimAsync(GlobalSettings.CultureInfo, GlobalSettings.Language, token);

        /// <summary>
        /// Character's Swim rate.
        /// </summary>
        public string GetSwim(CultureInfo objCulture, string strLanguage)
        {
            using (LockObject.EnterReadLock())
                // Don't attempt to do anything if the character's Movement is "Special" (typically for A.I.s).
                return Movement == "Special"
                    ? LanguageManager.GetString("String_ModeSpecial", strLanguage)
                    : CalculatedMovement("Swim", false, objCulture, strLanguage);
        }

        /// <summary>
        /// Character's Swim rate.
        /// </summary>
        public async Task<string> GetSwimAsync(CultureInfo objCulture, string strLanguage, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            // Don't attempt to do anything if the character's Movement is "Special" (typically for A.I.s).
            {
                token.ThrowIfCancellationRequested();
                return await GetMovementAsync(token).ConfigureAwait(false) == "Special"
                    ? await LanguageManager.GetStringAsync("String_ModeSpecial", strLanguage, token: token).ConfigureAwait(false)
                    : await CalculatedMovementAsync("Swim", false, objCulture, strLanguage, token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplayFly => GetFly(GlobalSettings.CultureInfo, GlobalSettings.Language);

        public Task<string> GetDisplayFlyAsync(CancellationToken token = default) => GetFlyAsync(GlobalSettings.CultureInfo, GlobalSettings.Language, token);

        /// <summary>
        /// Character's Fly rate.
        /// </summary>
        public string GetFly(CultureInfo objCulture, string strLanguage)
        {
            using (LockObject.EnterReadLock())
                // Don't attempt to do anything if the character's Movement is "Special" (typically for A.I.s).
                return Movement == "Special"
                    ? LanguageManager.GetString("String_ModeSpecial", strLanguage)
                    : CalculatedMovement("Fly", false, objCulture, strLanguage);
        }

        /// <summary>
        /// Character's Fly rate.
        /// </summary>
        public async Task<string> GetFlyAsync(CultureInfo objCulture, string strLanguage, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            // Don't attempt to do anything if the character's Movement is "Special" (typically for A.I.s).
            {
                token.ThrowIfCancellationRequested();
                return await GetMovementAsync(token).ConfigureAwait(false) == "Special"
                    ? await LanguageManager.GetStringAsync("String_ModeSpecial", strLanguage, token: token).ConfigureAwait(false)
                    : await CalculatedMovementAsync("Fly", false, objCulture, strLanguage, token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Full Movement (Movement, Swim, and Fly) for printouts.
        /// </summary>
        private string FullMovement(CultureInfo objCulture, string strLanguage)
        {
            string strSpace = LanguageManager.GetString("String_Space");
            using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdReturn))
            {
                using (LockObject.EnterReadLock())
                {
                    string strGroundMovement = GetMovement(objCulture, strLanguage);
                    string strSwimMovement = GetSwim(objCulture, strLanguage);
                    string strFlyMovement = GetFly(objCulture, strLanguage);
                    if (!string.IsNullOrEmpty(strGroundMovement) && strGroundMovement != "0")
                        sbdReturn.Append(strGroundMovement, ',', strSpace);
                    if (!string.IsNullOrEmpty(strSwimMovement) && strSwimMovement != "0")
                        sbdReturn.Append(LanguageManager.GetString("Label_OtherSwim", strLanguage), strSpace)
                                 .Append(strSwimMovement, ',', strSpace);
                    if (!string.IsNullOrEmpty(strFlyMovement) && strFlyMovement != "0")
                        sbdReturn.Append(LanguageManager.GetString("Label_OtherFly", strLanguage), strSpace)
                                 .Append(strFlyMovement, ',', strSpace);
                }

                // Remove the trailing ", ".
                if (sbdReturn.Length > 0)
                    sbdReturn.Length -= 2;

                return sbdReturn.ToString();
            }
        }

        /// <summary>
        /// Full Movement (Movement, Swim, and Fly) for printouts.
        /// </summary>
        private async Task<string> FullMovementAsync(CultureInfo objCulture, string strLanguage, CancellationToken token = default)
        {
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdReturn))
            {
                IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    string strGroundMovement = await GetMovementAsync(objCulture, strLanguage, token).ConfigureAwait(false);
                    string strSwimMovement = await GetSwimAsync(objCulture, strLanguage, token).ConfigureAwait(false);
                    string strFlyMovement = await GetFlyAsync(objCulture, strLanguage, token).ConfigureAwait(false);
                    if (!string.IsNullOrEmpty(strGroundMovement) && strGroundMovement != "0")
                        sbdReturn.Append(strGroundMovement, ',', strSpace);
                    if (!string.IsNullOrEmpty(strSwimMovement) && strSwimMovement != "0")
                        sbdReturn.Append(await LanguageManager.GetStringAsync("Label_OtherSwim", strLanguage, token: token).ConfigureAwait(false), strSpace)
                                 .Append(strSwimMovement, ',', strSpace);
                    if (!string.IsNullOrEmpty(strFlyMovement) && strFlyMovement != "0")
                        sbdReturn.Append(await LanguageManager.GetStringAsync("Label_OtherFly", strLanguage, token: token).ConfigureAwait(false), strSpace)
                                 .Append(strFlyMovement, ',', strSpace);
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }

                // Remove the trailing ", ".
                if (sbdReturn.Length > 0)
                    sbdReturn.Length -= 2;

                return sbdReturn.ToString();
            }
        }

        /// <summary>
        /// BP cost of character's Metatype.
        /// </summary>
        public int MetatypeBP
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _intMetatypeBP;
            }
            set
            {
                using (LockObject.EnterReadLock())
                {
                    if (_intMetatypeBP == value)
                        return;
                }
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _intMetatypeBP, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        public async Task<int> GetMetatypeBPAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _intMetatypeBP;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public async Task SetMetatypeBPAsync(int value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_intMetatypeBP == value)
                    return;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
            objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _intMetatypeBP, value) == value)
                    return;
                await OnPropertyChangedAsync(nameof(MetatypeBP), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// MetatypeBP as a string, including Karma string and multiplied by options as relevant.
        /// TODO: Belongs in a viewmodel for frmCreate rather than the main character class?
        /// </summary>
        public string DisplayMetatypeBP
        {
            get
            {
                string strReturn = string.Empty;
                using (LockObject.EnterReadLock())
                {
                    switch (EffectiveBuildMethod)
                    {
                        case CharacterBuildMethod.Karma:
                        case CharacterBuildMethod.LifeModule:
                            strReturn = (MetatypeBP * Settings.MetatypeCostsKarmaMultiplier).ToString(
                                GlobalSettings.CultureInfo);
                            break;

                        case CharacterBuildMethod.Priority:
                        case CharacterBuildMethod.SumtoTen:
                            strReturn = MetatypeBP.ToString(GlobalSettings.CultureInfo);
                            break;
                    }
                }

                return strReturn + LanguageManager.GetString("String_Space") + LanguageManager.GetString("String_Karma");
            }
        }

        /// <summary>
        /// MetatypeBP as a string, including Karma string and multiplied by options as relevant.
        /// TODO: Belongs in a viewmodel for frmCreate rather than the main character class?
        /// </summary>
        public async Task<string> GetDisplayMetatypeBPAsync(CancellationToken token = default)
        {
            string strReturn = string.Empty;
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                switch (await GetEffectiveBuildMethodAsync(token).ConfigureAwait(false))
                {
                    case CharacterBuildMethod.Karma:
                    case CharacterBuildMethod.LifeModule:
                        strReturn = (await GetMetatypeBPAsync(token).ConfigureAwait(false)
                            * await (await GetSettingsAsync(token).ConfigureAwait(false))
                                .GetMetatypeCostsKarmaMultiplierAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo);
                        break;

                    case CharacterBuildMethod.Priority:
                    case CharacterBuildMethod.SumtoTen:
                        strReturn = (await GetMetatypeBPAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo);
                        break;
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }

            return strReturn + await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false) + await LanguageManager.GetStringAsync("String_Karma", token: token).ConfigureAwait(false);
        }

        /// <summary>
        /// Whether the character is a non-Free Sprite.
        /// </summary>
        public bool IsSprite
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return MetatypeCategory.EndsWith("Sprites", StringComparison.Ordinal) && !IsFreeSprite;
            }
        }

        /// <summary>
        /// Whether the character is a Free Sprite.
        /// </summary>
        public bool IsFreeSprite
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return MetatypeCategory == "Free Sprite";
            }
        }

        /// <summary>
        /// Whether the character is a Free Sprite.
        /// </summary>
        public async Task<bool> GetIsFreeSpriteAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return MetatypeCategory == "Free Sprite";
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        #endregion Metatype/Metavariant Information

        #region Special Functions and Enabled Check Properties

        /// <summary>
        /// Whether Adept options are enabled.
        /// </summary>
        public bool AdeptEnabled
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _blnAdeptEnabled;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (_blnAdeptEnabled == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnAdeptEnabled = value;
                        if (!value)
                            ClearAdeptPowers();
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Whether Adept options are enabled.
        /// </summary>
        public async Task<bool> GetAdeptEnabledAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _blnAdeptEnabled;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether Adept options are enabled.
        /// </summary>
        public async Task SetAdeptEnabledAsync(bool value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_blnAdeptEnabled == value)
                    return;
                IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    _blnAdeptEnabled = value;
                    if (!value)
                        await ClearAdeptPowersAsync(token).ConfigureAwait(false);
                    await OnPropertyChangedAsync(nameof(AdeptEnabled), token).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether Magician options are enabled.
        /// </summary>
        public bool MagicianEnabled
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _blnMagicianEnabled;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (_blnMagicianEnabled == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnMagicianEnabled = value;
                        if (!value)
                            ClearMagic(AdeptEnabled);
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Whether Magician options are enabled.
        /// </summary>
        public async Task<bool> GetMagicianEnabledAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _blnMagicianEnabled;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether Magician options are enabled.
        /// </summary>
        public async Task SetMagicianEnabledAsync(bool value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_blnMagicianEnabled == value)
                    return;
                IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    _blnMagicianEnabled = value;
                    if (!value)
                        await ClearMagicAsync(await GetAdeptEnabledAsync(token).ConfigureAwait(false), token).ConfigureAwait(false);
                    await OnPropertyChangedAsync(nameof(MagicianEnabled), token).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether Technomancer options are enabled.
        /// </summary>
        public bool TechnomancerEnabled
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _blnTechnomancerEnabled;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (_blnTechnomancerEnabled == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnTechnomancerEnabled = value;
                        if (!value)
                            ClearResonance();
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Whether Technomancer options are enabled.
        /// </summary>
        public async Task<bool> GetTechnomancerEnabledAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _blnTechnomancerEnabled;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether Technomancer options are enabled.
        /// </summary>
        public async Task SetTechnomancerEnabledAsync(bool value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_blnTechnomancerEnabled == value)
                    return;
                IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    _blnTechnomancerEnabled = value;
                    if (!value)
                        await ClearResonanceAsync(token).ConfigureAwait(false);
                    await OnPropertyChangedAsync(nameof(TechnomancerEnabled), token).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether the Drug Psyche is active
        /// </summary>
        public bool PsycheActive
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _blnPsycheActive;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (_blnPsycheActive == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnPsycheActive = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Whether the Drug Psyche is active
        /// </summary>
        public async Task<bool> GetPsycheActiveAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _blnPsycheActive;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether the Drug Psyche is active
        /// </summary>
        public async Task SetPsycheActiveAsync(bool value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_blnPsycheActive == value)
                    return;
                IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    _blnPsycheActive = value;
                    await OnPropertyChangedAsync(nameof(PsycheActive), token).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether Advanced Program options are enabled.
        /// </summary>
        public bool AdvancedProgramsEnabled
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _blnAdvancedProgramsEnabled;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (_blnAdvancedProgramsEnabled == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnAdvancedProgramsEnabled = value;
                        if (!value)
                            ClearAdvancedPrograms();
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Whether Advanced Program options are enabled.
        /// </summary>
        public async Task<bool> GetAdvancedProgramsEnabledAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _blnAdvancedProgramsEnabled;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether Advanced Program options are enabled.
        /// </summary>
        public async Task SetAdvancedProgramsEnabledAsync(bool value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_blnAdvancedProgramsEnabled == value)
                    return;
                IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    _blnAdvancedProgramsEnabled = value;
                    if (!value)
                        await ClearAdvancedProgramsAsync(token).ConfigureAwait(false);
                    await OnPropertyChangedAsync(nameof(AdvancedProgramsEnabled), token).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether Cyberware options are disabled.
        /// </summary>
        public bool CyberwareDisabled
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _blnCyberwareDisabled;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (_blnCyberwareDisabled == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnCyberwareDisabled = value;
                        if (value)
                            ClearCyberwareTab();
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Whether Cyberware options are disabled.
        /// </summary>
        public async Task<bool> GetCyberwareDisabledAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _blnCyberwareDisabled;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether Cyberware options are disabled.
        /// </summary>
        public async Task SetCyberwareDisabledAsync(bool value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_blnCyberwareDisabled == value)
                    return;
                IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    _blnCyberwareDisabled = value;
                    if (value)
                        await ClearCyberwareTabAsync(token).ConfigureAwait(false);
                    await OnPropertyChangedAsync(nameof(CyberwareDisabled), token).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public bool AddCyberwareEnabled
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return !CyberwareDisabled && !IsAI
                                              && ImprovementManager
                                                 .GetCachedImprovementListForValueOf(
                                                     this, Improvement.ImprovementType.DisableCyberware)
                                                 .Count == 0;
            }
        }

        public async Task<bool> GetAddCyberwareEnabledAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return !await GetCyberwareDisabledAsync(token).ConfigureAwait(false) && !await GetIsAIAsync(token).ConfigureAwait(false)
                                                               && (await ImprovementManager
                                                                   .GetCachedImprovementListForValueOfAsync(
                                                                       this, Improvement.ImprovementType.DisableCyberware, token: token).ConfigureAwait(false))
                                                               .Count == 0;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public bool AddBiowareEnabled
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return !CyberwareDisabled && !IsAI
                                              && ImprovementManager
                                                 .GetCachedImprovementListForValueOf(
                                                     this, Improvement.ImprovementType.DisableBioware)
                                                 .Count == 0;
            }
        }

        public async Task<bool> GetAddBiowareEnabledAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return !await GetCyberwareDisabledAsync(token).ConfigureAwait(false) && !await GetIsAIAsync(token).ConfigureAwait(false)
                                          && (await ImprovementManager
                                              .GetCachedImprovementListForValueOfAsync(
                                                  this, Improvement.ImprovementType.DisableBioware, token: token).ConfigureAwait(false))
                                              .Count == 0;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private int _intCachedInitiationEnabled = int.MinValue;

        /// <summary>
        /// Whether the Initiation tab should be shown (override for BP mode).
        /// </summary>
        public bool InitiationEnabled
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (_intCachedInitiationEnabled < 0)
                    {
                        _intCachedInitiationEnabled = (!InitiationForceDisabled && (MAGEnabled || RESEnabled)).ToInt32();
                    }

                    return _intCachedInitiationEnabled > 0;
                }
            }
        }

        /// <summary>
        /// Whether the Initiation tab should be shown (override for BP mode).
        /// </summary>
        public async Task<bool> GetInitiationEnabledAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_intCachedInitiationEnabled < 0)
                {
                    _intCachedInitiationEnabled = (!await GetInitiationForceDisabledAsync(token).ConfigureAwait(false) && (await GetMAGEnabledAsync(token).ConfigureAwait(false) || await GetRESEnabledAsync(token).ConfigureAwait(false))).ToInt32();
                }

                return _intCachedInitiationEnabled > 0;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public bool InitiationForceDisabled
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _blnInitiationDisabled;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (_blnInitiationDisabled == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnInitiationDisabled = value;
                        if (value)
                            ClearInitiations();
                        OnPropertyChanged();
                    }
                }
            }
        }

        public async Task<bool> GetInitiationForceDisabledAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _blnInitiationDisabled;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public async Task SetInitiationForceDisabledAsync(bool value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_blnInitiationDisabled == value)
                    return;
                IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    _blnInitiationDisabled = value;
                    if (value)
                        await ClearInitiationsAsync(token).ConfigureAwait(false);
                    await OnPropertyChangedAsync(nameof(InitiationForceDisabled), token).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether Critter options are enabled.
        /// </summary>
        public bool CritterEnabled
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _blnCritterEnabled;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (_blnCritterEnabled == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnCritterEnabled = value;
                        if (!value)
                            ClearCritterPowers();
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Whether Critter options are enabled.
        /// </summary>
        public async Task<bool> GetCritterEnabledAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _blnCritterEnabled;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether Critter options are enabled.
        /// </summary>
        public async Task SetCritterEnabledAsync(bool value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_blnCritterEnabled == value)
                    return;
                IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    _blnCritterEnabled = value;
                    if (!value)
                        await ClearCritterPowersAsync(token).ConfigureAwait(false);
                    await OnPropertyChangedAsync(nameof(CritterEnabled), token).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether Black Market Discount is enabled.
        /// </summary>
        public bool DealerConnectionDiscount => ImprovementManager
                                                .GetCachedImprovementListForValueOf(
                                                    this, Improvement.ImprovementType.DealerConnection).Count > 0;

        /// <summary>
        /// Whether Black Market Discount is enabled.
        /// </summary>
        public async Task<bool> GetDealerConnectionDiscountAsync(CancellationToken token = default)
        {
            return (await ImprovementManager
                       .GetCachedImprovementListForValueOfAsync(
                           this, Improvement.ImprovementType.DealerConnection, token: token).ConfigureAwait(false)).Count
                   > 0;
        }

        public void RefreshDealerConnectionDiscounts(CancellationToken token = default)
        {
            // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
            if (IsLoading)
                return;
            using (LockObject.EnterUpgradeableReadLock(token))
            {
                if (Created)
                    return; // Don't need to refresh properties in Career mode because costs are calculated immediately upon purchasing stuff

                if (DealerConnectionDiscount)
                    return;

                using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                out HashSet<string> setDealerConnectionMaps))
                {
                    foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                 this, Improvement.ImprovementType.DealerConnection, token: token))
                    {
                        token.ThrowIfCancellationRequested();
                        setDealerConnectionMaps.Add(objImprovement.UniqueName);
                    }

                    foreach (Vehicle objVehicle in Vehicles)
                    {
                        token.ThrowIfCancellationRequested();
                        objVehicle.DealerConnectionDiscount = objVehicle.DealerConnectionDiscount
                                                              && Vehicle.DoesDealerConnectionApply(
                                                                  setDealerConnectionMaps, objVehicle.Category);
                    }
                }
            }
        }

        public async Task RefreshDealerConnectionDiscountsAsync(CancellationToken token = default)
        {
            // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
            if (IsLoading)
                return;
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();

                if (await GetCreatedAsync(token).ConfigureAwait(false))
                    return; // Don't need to refresh properties in Career mode because costs are calculated immediately upon purchasing stuff

                if (await GetDealerConnectionDiscountAsync(token).ConfigureAwait(false))
                    return;

                using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                           out HashSet<string> setDealerConnectionMaps))
                {
                    foreach (Improvement objImprovement in await ImprovementManager
                                 .GetCachedImprovementListForValueOfAsync(
                                     this, Improvement.ImprovementType.DealerConnection, token: token)
                                 .ConfigureAwait(false))
                    {
                        token.ThrowIfCancellationRequested();
                        setDealerConnectionMaps.Add(objImprovement.UniqueName);
                    }

                    await Vehicles.ForEachAsync(objVehicle =>
                    {
                        objVehicle.DealerConnectionDiscount = objVehicle.DealerConnectionDiscount
                                                              && Vehicle.DoesDealerConnectionApply(
                                                                  setDealerConnectionMaps, objVehicle.Category);
                    }, token).ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether Black Market Discount is enabled.
        /// </summary>
        public bool BlackMarketDiscount => ImprovementManager
                                           .GetCachedImprovementListForValueOf(
                                               this, Improvement.ImprovementType.BlackMarketDiscount).Count
                                           > 0;

        /// <summary>
        /// Whether Black Market Discount is enabled.
        /// </summary>
        public async Task<bool> GetBlackMarketDiscountAsync(CancellationToken token = default)
        {
            return (await ImprovementManager
                          .GetCachedImprovementListForValueOfAsync(
                              this, Improvement.ImprovementType.BlackMarketDiscount, token: token).ConfigureAwait(false)).Count
                   > 0;
        }

        public void RefreshBlackMarketDiscounts(CancellationToken token = default)
        {
            // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
            if (IsLoading)
                return;
            using (LockObject.EnterUpgradeableReadLock(token))
            {
                if (Created)
                    return; // Don't need to refresh properties in Career mode because costs are calculated immediately upon purchasing stuff

                if (BlackMarketDiscount)
                {
                    using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                               out HashSet<string> setArmorBlackMarketMaps))
                    using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                               out HashSet<string> setArmorModBlackMarketMaps))
                    using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                               out HashSet<string> setBiowareBlackMarketMaps))
                    using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                               out HashSet<string> setCyberwareBlackMarketMaps))
                    using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                               out HashSet<string> setGearBlackMarketMaps))
                    using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                               out HashSet<string> setVehicleBlackMarketMaps))
                    using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                               out HashSet<string> setVehicleModBlackMarketMaps))
                    using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                               out HashSet<string> setWeaponMountBlackMarketMaps))
                    using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                               out HashSet<string> setWeaponBlackMarketMaps))
                    {
                        setArmorBlackMarketMaps.AddRange(GenerateBlackMarketMappings(
                            LoadDataXPath("armor.xml", token: token)
                                .SelectSingleNodeAndCacheExpression("/chummer", token), token));
                        setArmorModBlackMarketMaps.AddRange(GenerateBlackMarketMappings(
                            LoadDataXPath("armor.xml", token: token)
                                .SelectSingleNodeAndCacheExpression(
                                    "/chummer/modcategories", token), token));
                        setBiowareBlackMarketMaps.AddRange(GenerateBlackMarketMappings(
                            LoadDataXPath("bioware.xml", token: token)
                                .SelectSingleNodeAndCacheExpression("/chummer", token), token));
                        setCyberwareBlackMarketMaps.AddRange(GenerateBlackMarketMappings(
                            LoadDataXPath("cyberware.xml", token: token)
                                .SelectSingleNodeAndCacheExpression("/chummer", token), token));
                        setGearBlackMarketMaps.AddRange(GenerateBlackMarketMappings(
                            LoadDataXPath("gear.xml", token: token)
                                .SelectSingleNodeAndCacheExpression("/chummer", token), token));
                        setVehicleBlackMarketMaps.AddRange(GenerateBlackMarketMappings(
                            LoadDataXPath("vehicles.xml", token: token)
                                .SelectSingleNodeAndCacheExpression("/chummer", token), token));
                        setVehicleModBlackMarketMaps.AddRange(GenerateBlackMarketMappings(
                            LoadDataXPath("vehicles.xml", token: token)
                                .SelectSingleNodeAndCacheExpression(
                                    "/chummer/modcategories", token), token));
                        setWeaponMountBlackMarketMaps.AddRange(GenerateBlackMarketMappings(
                            LoadDataXPath("vehicles.xml", token: token)
                                .SelectSingleNodeAndCacheExpression(
                                    "/chummer/weaponmountcategories", token), token));
                        setWeaponBlackMarketMaps.AddRange(GenerateBlackMarketMappings(
                            LoadDataXPath("weapons.xml", token: token)
                                .SelectSingleNodeAndCacheExpression("/chummer", token), token));

                        Armor.AsEnumerableWithSideEffects().ForEach(objArmor =>
                        {
                            objArmor.DiscountCost
                                = objArmor.DiscountCost && setArmorBlackMarketMaps.Contains(objArmor.Category);
                            objArmor.ArmorMods.AsEnumerableWithSideEffects().ForEach(objMod =>
                            {
                                objMod.DiscountCost = objMod.DiscountCost
                                                      && setArmorModBlackMarketMaps.Contains(objMod.Category);
                                foreach (Gear objGear in objMod.GearChildren.AsEnumerableWithSideEffects()
                                             .GetAllDescendants(x => x.Children.AsEnumerableWithSideEffects()))
                                {
                                    token.ThrowIfCancellationRequested();
                                    objGear.DiscountCost = objGear.DiscountCost
                                                           && setGearBlackMarketMaps.Contains(objGear.Category);
                                }
                            }, token);

                            foreach (Gear objGear in objArmor.GearChildren.AsEnumerableWithSideEffects()
                                         .GetAllDescendants(x => x.Children.AsEnumerableWithSideEffects()))
                            {
                                token.ThrowIfCancellationRequested();
                                objGear.DiscountCost
                                    = objGear.DiscountCost && setGearBlackMarketMaps.Contains(objGear.Category);
                            }
                        }, token);

                        foreach (Cyberware objCyberware in Cyberware.AsEnumerableWithSideEffects()
                                     .GetAllDescendants(x => x.Children.AsEnumerableWithSideEffects()))
                        {
                            token.ThrowIfCancellationRequested();
                            if (objCyberware.DiscountCost)
                            {
                                objCyberware.DiscountCost
                                    = (objCyberware.SourceType == Improvement.ImprovementSource.Bioware
                                        ? setBiowareBlackMarketMaps
                                        : setCyberwareBlackMarketMaps).Contains(objCyberware.Category);
                            }

                            foreach (Gear objGear in objCyberware.GearChildren.AsEnumerableWithSideEffects()
                                         .GetAllDescendants(x => x.Children.AsEnumerableWithSideEffects()))
                            {
                                token.ThrowIfCancellationRequested();
                                objGear.DiscountCost
                                    = objGear.DiscountCost && setGearBlackMarketMaps.Contains(objGear.Category);
                            }
                        }

                        foreach (Gear objGear in Gear.AsEnumerableWithSideEffects()
                                     .GetAllDescendants(x => x.Children.AsEnumerableWithSideEffects()))
                        {
                            token.ThrowIfCancellationRequested();
                            objGear.DiscountCost
                                = objGear.DiscountCost && setGearBlackMarketMaps.Contains(objGear.Category);
                        }

                        Vehicles.AsEnumerableWithSideEffects().ForEach(objVehicle =>
                        {
                            objVehicle.DiscountCost = objVehicle.DiscountCost
                                                      && setVehicleBlackMarketMaps.Contains(objVehicle.Category);
                            foreach (Gear objGear in objVehicle.GearChildren.AsEnumerableWithSideEffects()
                                         .GetAllDescendants(x => x.Children.AsEnumerableWithSideEffects()))
                            {
                                token.ThrowIfCancellationRequested();
                                objGear.DiscountCost
                                    = objGear.DiscountCost && setGearBlackMarketMaps.Contains(objGear.Category);
                            }

                            objVehicle.Mods.AsEnumerableWithSideEffects().ForEach(objMod =>
                            {
                                objMod.DiscountCost = objMod.DiscountCost
                                                      && setVehicleModBlackMarketMaps.Contains(objMod.Category);
                                foreach (Cyberware objCyberware in objMod.Cyberware.AsEnumerableWithSideEffects()
                                             .GetAllDescendants(
                                                 x => x.Children.AsEnumerableWithSideEffects()))
                                {
                                    token.ThrowIfCancellationRequested();
                                    if (objCyberware.DiscountCost)
                                    {
                                        objCyberware.DiscountCost
                                            = (objCyberware.SourceType == Improvement.ImprovementSource.Bioware
                                                ? setBiowareBlackMarketMaps
                                                : setCyberwareBlackMarketMaps).Contains(objCyberware.Category);
                                    }

                                    foreach (Gear objGear in objCyberware.GearChildren.AsEnumerableWithSideEffects()
                                                 .GetAllDescendants(
                                                     x => x.Children.AsEnumerableWithSideEffects()))
                                    {
                                        token.ThrowIfCancellationRequested();
                                        objGear.DiscountCost = objGear.DiscountCost
                                                               && setGearBlackMarketMaps.Contains(objGear.Category);
                                    }
                                }
                            }, token);

                            foreach (Weapon objWeapon in objVehicle.Weapons.AsEnumerableWithSideEffects()
                                         .GetAllDescendants(x => x.Children.AsEnumerableWithSideEffects()))
                            {
                                token.ThrowIfCancellationRequested();
                                objWeapon.DiscountCost = objWeapon.DiscountCost
                                                         && setWeaponBlackMarketMaps.Contains(objWeapon.Category);
                                objWeapon.WeaponAccessories.AsEnumerableWithSideEffects().ForEach(objAccessory =>
                                {
                                    objAccessory.DiscountCost = objAccessory.DiscountCost
                                                                && setWeaponBlackMarketMaps
                                                                    .Contains(objWeapon.Category);
                                    foreach (Gear objGear in objAccessory.GearChildren.AsEnumerableWithSideEffects()
                                                 .GetAllDescendants(
                                                     x => x.Children.AsEnumerableWithSideEffects()))
                                    {
                                        token.ThrowIfCancellationRequested();
                                        objGear.DiscountCost = objGear.DiscountCost
                                                               && setGearBlackMarketMaps.Contains(objGear.Category);
                                    }
                                }, token);
                            }

                            objVehicle.WeaponMounts.AsEnumerableWithSideEffects().ForEach(objMount =>
                            {
                                objMount.DiscountCost = objMount.DiscountCost
                                                        && setWeaponMountBlackMarketMaps
                                                            .Contains(objMount.Category);
                                objMount.Mods.AsEnumerableWithSideEffects().ForEach(objMod =>
                                {
                                    objMod.DiscountCost = objMod.DiscountCost
                                                          && setVehicleModBlackMarketMaps.Contains(objMod.Category);
                                    foreach (Cyberware objCyberware in objMod.Cyberware.AsEnumerableWithSideEffects()
                                                 .GetAllDescendants(
                                                     x => x.Children.AsEnumerableWithSideEffects()))
                                    {
                                        token.ThrowIfCancellationRequested();
                                        if (objCyberware.DiscountCost)
                                        {
                                            objCyberware.DiscountCost
                                                = (objCyberware.SourceType == Improvement.ImprovementSource.Bioware
                                                    ? setBiowareBlackMarketMaps
                                                    : setCyberwareBlackMarketMaps).Contains(objCyberware.Category);
                                        }

                                        foreach (Gear objGear in objCyberware.GearChildren.AsEnumerableWithSideEffects()
                                                     .GetAllDescendants(
                                                         x => x.Children.AsEnumerableWithSideEffects()))
                                        {
                                            token.ThrowIfCancellationRequested();
                                            objGear.DiscountCost = objGear.DiscountCost
                                                                   && setGearBlackMarketMaps.Contains(
                                                                       objGear.Category);
                                        }
                                    }
                                }, token);

                                foreach (Weapon objWeapon in objMount.Weapons.AsEnumerableWithSideEffects()
                                             .GetAllDescendants(x => x.Children.AsEnumerableWithSideEffects()))
                                {
                                    token.ThrowIfCancellationRequested();
                                    objWeapon.DiscountCost = objWeapon.DiscountCost
                                                             && setWeaponBlackMarketMaps.Contains(
                                                                 objWeapon.Category);
                                    objWeapon.WeaponAccessories.AsEnumerableWithSideEffects().ForEach(objAccessory =>
                                    {
                                        objAccessory.DiscountCost = objAccessory.DiscountCost
                                                                    && setWeaponBlackMarketMaps
                                                                        .Contains(objWeapon.Category);
                                        foreach (Gear objGear in objAccessory.GearChildren.AsEnumerableWithSideEffects()
                                                     .GetAllDescendants(
                                                         x => x.Children.AsEnumerableWithSideEffects()))
                                        {
                                            token.ThrowIfCancellationRequested();
                                            objGear.DiscountCost = objGear.DiscountCost
                                                                   && setGearBlackMarketMaps.Contains(
                                                                       objGear.Category);
                                        }
                                    }, token);
                                }
                            }, token);
                        }, token);

                        foreach (Weapon objWeapon in Weapons.AsEnumerableWithSideEffects()
                                     .GetAllDescendants(x => x.Children.AsEnumerableWithSideEffects()))
                        {
                            token.ThrowIfCancellationRequested();
                            objWeapon.DiscountCost = objWeapon.DiscountCost
                                                     && setWeaponBlackMarketMaps.Contains(objWeapon.Category);
                            objWeapon.WeaponAccessories.AsEnumerableWithSideEffects().ForEach(objAccessory =>
                            {
                                objAccessory.DiscountCost = objAccessory.DiscountCost
                                                            && setWeaponBlackMarketMaps
                                                                .Contains(objWeapon.Category);
                                foreach (Gear objGear in objAccessory.GearChildren.GetAllDescendants(
                                             x => x.Children, token))
                                {
                                    token.ThrowIfCancellationRequested();
                                    objGear.DiscountCost = objGear.DiscountCost
                                                           && setGearBlackMarketMaps.Contains(objGear.Category);
                                }
                            }, token);
                        }
                    }
                }
                else
                {
                    // Forcefully disable all Black Market Discounts that don't apply.
                    Armor.AsEnumerableWithSideEffects().ForEach(objArmor =>
                    {
                        objArmor.DiscountCost = false;
                        objArmor.ArmorMods.AsEnumerableWithSideEffects().ForEach(objMod =>
                        {
                            objMod.DiscountCost = false;
                            foreach (Gear objGear in objMod.GearChildren.AsEnumerableWithSideEffects()
                                         .GetAllDescendants(x => x.Children.AsEnumerableWithSideEffects()))
                            {
                                token.ThrowIfCancellationRequested();
                                objGear.DiscountCost = false;
                            }
                        }, token);

                        foreach (Gear objGear in objArmor.GearChildren.AsEnumerableWithSideEffects()
                                     .GetAllDescendants(x => x.Children.AsEnumerableWithSideEffects()))
                        {
                            token.ThrowIfCancellationRequested();
                            objGear.DiscountCost = false;
                        }
                    }, token);

                    foreach (Cyberware objCyberware in Cyberware.AsEnumerableWithSideEffects()
                                 .GetAllDescendants(x => x.Children.AsEnumerableWithSideEffects()))
                    {
                        token.ThrowIfCancellationRequested();
                        objCyberware.DiscountCost = false;
                        foreach (Gear objGear in objCyberware.GearChildren.AsEnumerableWithSideEffects()
                                     .GetAllDescendants(x => x.Children.AsEnumerableWithSideEffects()))
                        {
                            token.ThrowIfCancellationRequested();
                            objGear.DiscountCost = false;
                        }
                    }

                    foreach (Gear objGear in Gear.AsEnumerableWithSideEffects()
                                 .GetAllDescendants(x => x.Children.AsEnumerableWithSideEffects()))
                    {
                        token.ThrowIfCancellationRequested();
                        objGear.DiscountCost = false;
                    }

                    Vehicles.AsEnumerableWithSideEffects().ForEach(objVehicle =>
                    {
                        objVehicle.DiscountCost = false;
                        foreach (Gear objGear in objVehicle.GearChildren.AsEnumerableWithSideEffects()
                                     .GetAllDescendants(x => x.Children.AsEnumerableWithSideEffects()))
                        {
                            token.ThrowIfCancellationRequested();
                            objGear.DiscountCost = false;
                        }

                        objVehicle.Mods.AsEnumerableWithSideEffects().ForEach(objMod =>
                        {
                            objMod.DiscountCost = false;
                            foreach (Cyberware objCyberware in objMod.Cyberware.AsEnumerableWithSideEffects()
                                         .GetAllDescendants(
                                             x => x.Children.AsEnumerableWithSideEffects()))
                            {
                                token.ThrowIfCancellationRequested();
                                objCyberware.DiscountCost = false;
                                foreach (Gear objGear in objCyberware.GearChildren.AsEnumerableWithSideEffects()
                                             .GetAllDescendants(
                                                 x => x.Children.AsEnumerableWithSideEffects()))
                                {
                                    token.ThrowIfCancellationRequested();
                                    objGear.DiscountCost = false;
                                }
                            }
                        }, token);

                        foreach (Weapon objWeapon in objVehicle.Weapons.AsEnumerableWithSideEffects()
                                     .GetAllDescendants(x => x.Children.AsEnumerableWithSideEffects()))
                        {
                            token.ThrowIfCancellationRequested();
                            objWeapon.DiscountCost = false;
                            objWeapon.WeaponAccessories.AsEnumerableWithSideEffects().ForEach(objAccessory =>
                            {
                                objAccessory.DiscountCost = false;
                                foreach (Gear objGear in objAccessory.GearChildren.GetAllDescendants(
                                             x => x.Children, token))
                                {
                                    token.ThrowIfCancellationRequested();
                                    objGear.DiscountCost = false;
                                }
                            }, token);
                        }

                        objVehicle.WeaponMounts.AsEnumerableWithSideEffects().ForEach(objMount =>
                        {
                            objMount.DiscountCost = false;
                            objMount.Mods.AsEnumerableWithSideEffects().ForEach(objMod =>
                            {
                                objMod.DiscountCost = false;
                                foreach (Cyberware objCyberware in objMod.Cyberware.AsEnumerableWithSideEffects()
                                             .GetAllDescendants(
                                                 x => x.Children.AsEnumerableWithSideEffects()))
                                {
                                    token.ThrowIfCancellationRequested();
                                    objCyberware.DiscountCost = false;
                                    foreach (Gear objGear in objCyberware.GearChildren.AsEnumerableWithSideEffects()
                                                 .GetAllDescendants(
                                                     x => x.Children.AsEnumerableWithSideEffects()))
                                    {
                                        token.ThrowIfCancellationRequested();
                                        objGear.DiscountCost = false;
                                    }
                                }
                            }, token);

                            foreach (Weapon objWeapon in objMount.Weapons.AsEnumerableWithSideEffects()
                                         .GetAllDescendants(
                                             x => x.Children.AsEnumerableWithSideEffects()))
                            {
                                token.ThrowIfCancellationRequested();
                                objWeapon.DiscountCost = false;
                                objWeapon.WeaponAccessories.AsEnumerableWithSideEffects().ForEach(objAccessory =>
                                {
                                    objAccessory.DiscountCost = false;
                                    foreach (Gear objGear in objAccessory.GearChildren.AsEnumerableWithSideEffects()
                                                 .GetAllDescendants(
                                                     x => x.Children.AsEnumerableWithSideEffects()))
                                    {
                                        token.ThrowIfCancellationRequested();
                                        objGear.DiscountCost = false;
                                    }
                                }, token);
                            }
                        }, token);
                    }, token);

                    foreach (Weapon objWeapon in Weapons.AsEnumerableWithSideEffects()
                                 .GetAllDescendants(x => x.Children.AsEnumerableWithSideEffects()))
                    {
                        token.ThrowIfCancellationRequested();
                        objWeapon.DiscountCost = false;
                        objWeapon.WeaponAccessories.AsEnumerableWithSideEffects().ForEach(objAccessory =>
                        {
                            objAccessory.DiscountCost = false;
                            foreach (Gear objGear in objAccessory.GearChildren.AsEnumerableWithSideEffects()
                                         .GetAllDescendants(
                                             x => x.Children.AsEnumerableWithSideEffects()))
                            {
                                token.ThrowIfCancellationRequested();
                                objGear.DiscountCost = false;
                            }
                        }, token);
                    }
                }
            }
        }

        public async Task RefreshBlackMarketDiscountsAsync(CancellationToken token = default)
        {
            // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
            if (IsLoading)
                return;
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();

                if (await GetCreatedAsync(token).ConfigureAwait(false))
                    return; // Don't need to refresh properties in Career mode because costs are calculated immediately upon purchasing stuff

                if (await GetBlackMarketDiscountAsync(token).ConfigureAwait(false))
                {
                    using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                               out HashSet<string> setArmorBlackMarketMaps))
                    using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                               out HashSet<string> setArmorModBlackMarketMaps))
                    using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                               out HashSet<string> setBiowareBlackMarketMaps))
                    using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                               out HashSet<string> setCyberwareBlackMarketMaps))
                    using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                               out HashSet<string> setGearBlackMarketMaps))
                    using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                               out HashSet<string> setVehicleBlackMarketMaps))
                    using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                               out HashSet<string> setVehicleModBlackMarketMaps))
                    using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                               out HashSet<string> setWeaponMountBlackMarketMaps))
                    using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                               out HashSet<string> setWeaponBlackMarketMaps))
                    {
                        setArmorBlackMarketMaps.AddRange(await GenerateBlackMarketMappingsAsync(
                            (await LoadDataXPathAsync("armor.xml", token: token).ConfigureAwait(false))
                                .SelectSingleNodeAndCacheExpression("/chummer", token),
                            token).ConfigureAwait(false));
                        setArmorModBlackMarketMaps.AddRange(await GenerateBlackMarketMappingsAsync(
                                (await LoadDataXPathAsync("armor.xml", token: token).ConfigureAwait(false))
                                    .SelectSingleNodeAndCacheExpression(
                                        "/chummer/modcategories", token), token)
                            .ConfigureAwait(false));
                        setBiowareBlackMarketMaps.AddRange(await GenerateBlackMarketMappingsAsync(
                            (await LoadDataXPathAsync("bioware.xml", token: token).ConfigureAwait(false))
                                .SelectSingleNodeAndCacheExpression("/chummer", token),
                            token).ConfigureAwait(false));
                        setCyberwareBlackMarketMaps.AddRange(await GenerateBlackMarketMappingsAsync(
                            (await LoadDataXPathAsync("cyberware.xml", token: token).ConfigureAwait(false))
                                .SelectSingleNodeAndCacheExpression("/chummer", token),
                            token).ConfigureAwait(false));
                        setGearBlackMarketMaps.AddRange(await GenerateBlackMarketMappingsAsync(
                            (await LoadDataXPathAsync("gear.xml", token: token).ConfigureAwait(false))
                                .SelectSingleNodeAndCacheExpression("/chummer", token),
                            token).ConfigureAwait(false));
                        setVehicleBlackMarketMaps.AddRange(await GenerateBlackMarketMappingsAsync(
                            (await LoadDataXPathAsync("vehicles.xml", token: token).ConfigureAwait(false))
                                .SelectSingleNodeAndCacheExpression("/chummer", token),
                            token).ConfigureAwait(false));
                        setVehicleModBlackMarketMaps.AddRange(await GenerateBlackMarketMappingsAsync(
                                (await LoadDataXPathAsync("vehicles.xml", token: token).ConfigureAwait(false))
                                    .SelectSingleNodeAndCacheExpression(
                                        "/chummer/modcategories", token), token)
                            .ConfigureAwait(false));
                        setWeaponMountBlackMarketMaps.AddRange(await GenerateBlackMarketMappingsAsync(
                                (await LoadDataXPathAsync("vehicles.xml", token: token).ConfigureAwait(false))
                                    .SelectSingleNodeAndCacheExpression(
                                        "/chummer/weaponmountcategories", token), token)
                            .ConfigureAwait(false));
                        setWeaponBlackMarketMaps.AddRange(await GenerateBlackMarketMappingsAsync(
                            (await LoadDataXPathAsync("weapons.xml", token: token).ConfigureAwait(false))
                                .SelectSingleNodeAndCacheExpression("/chummer", token),
                            token).ConfigureAwait(false));

                        await Armor.ForEachWithSideEffectsAsync(async objArmor =>
                        {
                            objArmor.DiscountCost
                                = objArmor.DiscountCost && setArmorBlackMarketMaps.Contains(objArmor.Category);
                            await objArmor.ArmorMods.ForEachWithSideEffectsAsync(async objMod =>
                            {
                                objMod.DiscountCost = objMod.DiscountCost
                                                      && setArmorModBlackMarketMaps.Contains(objMod.Category);
                                foreach (Gear objGear in await objMod.GearChildren
                                             .GetAllDescendantsAsync(x => x.Children, token).ConfigureAwait(false))
                                {
                                    token.ThrowIfCancellationRequested();
                                    objGear.DiscountCost = objGear.DiscountCost
                                                           && setGearBlackMarketMaps.Contains(objGear.Category);
                                }
                            }, token).ConfigureAwait(false);

                            foreach (Gear objGear in await objArmor.GearChildren
                                         .GetAllDescendantsAsync(x => x.Children, token).ConfigureAwait(false))
                            {
                                token.ThrowIfCancellationRequested();
                                objGear.DiscountCost
                                    = objGear.DiscountCost && setGearBlackMarketMaps.Contains(objGear.Category);
                            }
                        }, token).ConfigureAwait(false);

                        foreach (Cyberware objCyberware in await Cyberware
                                     .GetAllDescendantsAsync(x => x.GetChildrenAsync(token), token).ConfigureAwait(false))
                        {
                            token.ThrowIfCancellationRequested();
                            if (await objCyberware.GetDiscountCostAsync(token).ConfigureAwait(false))
                            {
                                await objCyberware.SetDiscountCostAsync(
                                    (objCyberware.SourceType == Improvement.ImprovementSource.Bioware
                                        ? setBiowareBlackMarketMaps
                                        : setCyberwareBlackMarketMaps).Contains(objCyberware.Category), token).ConfigureAwait(false);
                            }

                            foreach (Gear objGear in await objCyberware.GearChildren
                                         .GetAllDescendantsAsync(x => x.Children, token).ConfigureAwait(false))
                            {
                                token.ThrowIfCancellationRequested();
                                objGear.DiscountCost
                                    = objGear.DiscountCost && setGearBlackMarketMaps.Contains(objGear.Category);
                            }
                        }

                        foreach (Gear objGear in await Gear.GetAllDescendantsAsync(x => x.Children, token)
                                     .ConfigureAwait(false))
                        {
                            token.ThrowIfCancellationRequested();
                            objGear.DiscountCost
                                = objGear.DiscountCost && setGearBlackMarketMaps.Contains(objGear.Category);
                        }

                        await Vehicles.ForEachWithSideEffectsAsync(async objVehicle =>
                        {
                            objVehicle.DiscountCost = objVehicle.DiscountCost
                                                      && setVehicleBlackMarketMaps.Contains(objVehicle.Category);
                            foreach (Gear objGear in await objVehicle.GearChildren
                                         .GetAllDescendantsAsync(x => x.Children, token).ConfigureAwait(false))
                            {
                                token.ThrowIfCancellationRequested();
                                objGear.DiscountCost
                                    = objGear.DiscountCost && setGearBlackMarketMaps.Contains(objGear.Category);
                            }

                            await objVehicle.Mods.ForEachWithSideEffectsAsync(async objMod =>
                            {
                                objMod.DiscountCost = objMod.DiscountCost
                                                      && setVehicleModBlackMarketMaps.Contains(objMod.Category);
                                foreach (Cyberware objCyberware in await objMod.Cyberware.GetAllDescendantsAsync(
                                             x => x.GetChildrenAsync(token), token).ConfigureAwait(false))
                                {
                                    token.ThrowIfCancellationRequested();
                                    if (await objCyberware.GetDiscountCostAsync(token).ConfigureAwait(false))
                                    {
                                        await objCyberware.SetDiscountCostAsync(
                                            (objCyberware.SourceType == Improvement.ImprovementSource.Bioware
                                                ? setBiowareBlackMarketMaps
                                                : setCyberwareBlackMarketMaps).Contains(objCyberware.Category), token).ConfigureAwait(false);
                                    }

                                    foreach (Gear objGear in await objCyberware.GearChildren.GetAllDescendantsAsync(
                                                 x => x.Children, token).ConfigureAwait(false))
                                    {
                                        token.ThrowIfCancellationRequested();
                                        objGear.DiscountCost = objGear.DiscountCost
                                                               && setGearBlackMarketMaps.Contains(objGear.Category);
                                    }
                                }
                            }, token).ConfigureAwait(false);

                            foreach (Weapon objWeapon in await objVehicle.Weapons
                                         .GetAllDescendantsAsync(x => x.Children, token).ConfigureAwait(false))
                            {
                                token.ThrowIfCancellationRequested();
                                objWeapon.DiscountCost = objWeapon.DiscountCost
                                                         && setWeaponBlackMarketMaps.Contains(objWeapon.Category);
                                await objWeapon.WeaponAccessories.ForEachWithSideEffectsAsync(async objAccessory =>
                                {
                                    objAccessory.DiscountCost = objAccessory.DiscountCost
                                                                && setWeaponBlackMarketMaps
                                                                    .Contains(objWeapon.Category);
                                    foreach (Gear objGear in await objAccessory.GearChildren.GetAllDescendantsAsync(
                                                 x => x.Children, token).ConfigureAwait(false))
                                    {
                                        token.ThrowIfCancellationRequested();
                                        objGear.DiscountCost = objGear.DiscountCost
                                                               && setGearBlackMarketMaps.Contains(objGear.Category);
                                    }
                                }, token).ConfigureAwait(false);
                            }

                            await objVehicle.WeaponMounts.ForEachWithSideEffectsAsync(async objMount =>
                            {
                                objMount.DiscountCost = objMount.DiscountCost
                                                        && setWeaponMountBlackMarketMaps
                                                            .Contains(objMount.Category);
                                await objMount.Mods.ForEachWithSideEffectsAsync(async objMod =>
                                {
                                    objMod.DiscountCost = objMod.DiscountCost
                                                          && setVehicleModBlackMarketMaps.Contains(objMod.Category);
                                    foreach (Cyberware objCyberware in await objMod.Cyberware.GetAllDescendantsAsync(
                                                 x => x.GetChildrenAsync(token), token).ConfigureAwait(false))
                                    {
                                        token.ThrowIfCancellationRequested();
                                        if (objCyberware.DiscountCost)
                                        {
                                            objCyberware.DiscountCost
                                                = (objCyberware.SourceType == Improvement.ImprovementSource.Bioware
                                                    ? setBiowareBlackMarketMaps
                                                    : setCyberwareBlackMarketMaps).Contains(objCyberware.Category);
                                        }

                                        foreach (Gear objGear in await objCyberware.GearChildren.GetAllDescendantsAsync(
                                                     x => x.Children, token).ConfigureAwait(false))
                                        {
                                            token.ThrowIfCancellationRequested();
                                            objGear.DiscountCost = objGear.DiscountCost
                                                                   && setGearBlackMarketMaps.Contains(
                                                                       objGear.Category);
                                        }
                                    }
                                }, token).ConfigureAwait(false);

                                foreach (Weapon objWeapon in await objMount.Weapons
                                             .GetAllDescendantsAsync(x => x.Children, token).ConfigureAwait(false))
                                {
                                    token.ThrowIfCancellationRequested();
                                    objWeapon.DiscountCost = objWeapon.DiscountCost
                                                             && setWeaponBlackMarketMaps.Contains(
                                                                 objWeapon.Category);
                                    await objWeapon.WeaponAccessories.ForEachWithSideEffectsAsync(async objAccessory =>
                                    {
                                        token.ThrowIfCancellationRequested();
                                        objAccessory.DiscountCost = objAccessory.DiscountCost
                                                                    && setWeaponBlackMarketMaps
                                                                        .Contains(objWeapon.Category);
                                        foreach (Gear objGear in await objAccessory.GearChildren.GetAllDescendantsAsync(
                                                     x => x.Children, token).ConfigureAwait(false))
                                        {
                                            token.ThrowIfCancellationRequested();
                                            objGear.DiscountCost = objGear.DiscountCost
                                                                   && setGearBlackMarketMaps.Contains(
                                                                       objGear.Category);
                                        }
                                    }, token).ConfigureAwait(false);
                                }
                            }, token).ConfigureAwait(false);
                        }, token).ConfigureAwait(false);

                        foreach (Weapon objWeapon in await Weapons.GetAllDescendantsAsync(x => x.Children, token)
                                     .ConfigureAwait(false))
                        {
                            token.ThrowIfCancellationRequested();
                            objWeapon.DiscountCost = objWeapon.DiscountCost
                                                     && setWeaponBlackMarketMaps.Contains(objWeapon.Category);
                            await objWeapon.WeaponAccessories.ForEachWithSideEffectsAsync(async objAccessory =>
                            {
                                token.ThrowIfCancellationRequested();
                                objAccessory.DiscountCost = objAccessory.DiscountCost
                                                            && setWeaponBlackMarketMaps
                                                                .Contains(objWeapon.Category);
                                foreach (Gear objGear in await objAccessory.GearChildren.GetAllDescendantsAsync(
                                             x => x.Children, token).ConfigureAwait(false))
                                {
                                    token.ThrowIfCancellationRequested();
                                    objGear.DiscountCost = objGear.DiscountCost
                                                           && setGearBlackMarketMaps.Contains(objGear.Category);
                                }
                            }, token).ConfigureAwait(false);
                        }
                    }
                }
                else
                {
                    // Forcefully disable all Black Market Discounts that don't apply.
                    await Armor.ForEachWithSideEffectsAsync(async objArmor =>
                    {
                        objArmor.DiscountCost = false;
                        await objArmor.ArmorMods.ForEachWithSideEffectsAsync(async objMod =>
                        {
                            objMod.DiscountCost = false;
                            foreach (Gear objGear in await objMod.GearChildren
                                         .GetAllDescendantsAsync(x => x.Children, token).ConfigureAwait(false))
                            {
                                token.ThrowIfCancellationRequested();
                                objGear.DiscountCost = false;
                            }
                        }, token).ConfigureAwait(false);

                        foreach (Gear objGear in await objArmor.GearChildren
                                     .GetAllDescendantsAsync(x => x.Children, token).ConfigureAwait(false))
                        {
                            token.ThrowIfCancellationRequested();
                            objGear.DiscountCost = false;
                        }
                    }, token).ConfigureAwait(false);

                    foreach (Cyberware objCyberware in await (await GetCyberwareAsync(token).ConfigureAwait(false)).GetAllDescendantsAsync(x => x.Children, token)
                                 .ConfigureAwait(false))
                    {
                        token.ThrowIfCancellationRequested();
                        objCyberware.DiscountCost = false;
                        foreach (Gear objGear in await objCyberware.GearChildren
                                     .GetAllDescendantsAsync(x => x.Children, token).ConfigureAwait(false))
                        {
                            token.ThrowIfCancellationRequested();
                            objGear.DiscountCost = false;
                        }
                    }

                    foreach (Gear objGear in await Gear.GetAllDescendantsAsync(x => x.Children, token)
                                 .ConfigureAwait(false))
                    {
                        token.ThrowIfCancellationRequested();
                        objGear.DiscountCost = false;
                    }

                    await Vehicles.ForEachWithSideEffectsAsync(async objVehicle =>
                    {
                        objVehicle.DiscountCost = false;
                        foreach (Gear objGear in await objVehicle.GearChildren
                                     .GetAllDescendantsAsync(x => x.Children, token).ConfigureAwait(false))
                        {
                            token.ThrowIfCancellationRequested();
                            objGear.DiscountCost = false;
                        }

                        await objVehicle.Mods.ForEachWithSideEffectsAsync(async objMod =>
                        {
                            objMod.DiscountCost = false;
                            foreach (Cyberware objCyberware in await objMod.Cyberware
                                         .GetAllDescendantsAsync(x => x.Children, token).ConfigureAwait(false))
                            {
                                token.ThrowIfCancellationRequested();
                                objCyberware.DiscountCost = false;
                                foreach (Gear objGear in await objCyberware.GearChildren.GetAllDescendantsAsync(
                                             x => x.Children, token).ConfigureAwait(false))
                                {
                                    token.ThrowIfCancellationRequested();
                                    objGear.DiscountCost = false;
                                }
                            }
                        }, token).ConfigureAwait(false);

                        foreach (Weapon objWeapon in await objVehicle.Weapons
                                     .GetAllDescendantsAsync(x => x.Children, token).ConfigureAwait(false))
                        {
                            token.ThrowIfCancellationRequested();
                            objWeapon.DiscountCost = false;
                            await objWeapon.WeaponAccessories.ForEachWithSideEffectsAsync(async objAccessory =>
                            {
                                objAccessory.DiscountCost = false;
                                foreach (Gear objGear in await objAccessory.GearChildren.GetAllDescendantsAsync(
                                             x => x.Children, token).ConfigureAwait(false))
                                {
                                    token.ThrowIfCancellationRequested();
                                    objGear.DiscountCost = false;
                                }
                            }, token).ConfigureAwait(false);
                        }

                        await objVehicle.WeaponMounts.ForEachWithSideEffectsAsync(async objMount =>
                        {
                            objMount.DiscountCost = false;
                            await objMount.Mods.ForEachWithSideEffectsAsync(async objMod =>
                            {
                                objMod.DiscountCost = false;
                                foreach (Cyberware objCyberware in await objMod.Cyberware.GetAllDescendantsAsync(
                                             x => x.GetChildrenAsync(token), token).ConfigureAwait(false))
                                {
                                    token.ThrowIfCancellationRequested();
                                    objCyberware.DiscountCost = false;
                                    foreach (Gear objGear in await (await objCyberware.GetGearChildrenAsync(token).ConfigureAwait(false)).GetAllDescendantsAsync(
                                                 x => x.Children, token).ConfigureAwait(false))
                                    {
                                        token.ThrowIfCancellationRequested();
                                        objGear.DiscountCost = false;
                                    }
                                }
                            }, token).ConfigureAwait(false);

                            foreach (Weapon objWeapon in await objMount.Weapons
                                         .GetAllDescendantsAsync(x => x.Children, token).ConfigureAwait(false))
                            {
                                token.ThrowIfCancellationRequested();
                                objWeapon.DiscountCost = false;
                                await objWeapon.WeaponAccessories.ForEachWithSideEffectsAsync(async objAccessory =>
                                {
                                    objAccessory.DiscountCost = false;
                                    foreach (Gear objGear in await objAccessory.GearChildren.GetAllDescendantsAsync(
                                                 x => x.Children, token).ConfigureAwait(false))
                                    {
                                        token.ThrowIfCancellationRequested();
                                        objGear.DiscountCost = false;
                                    }
                                }, token).ConfigureAwait(false);
                            }
                        }, token).ConfigureAwait(false);
                    }, token).ConfigureAwait(false);

                    foreach (Weapon objWeapon in await Weapons.GetAllDescendantsAsync(x => x.Children, token)
                                 .ConfigureAwait(false))
                    {
                        token.ThrowIfCancellationRequested();
                        objWeapon.DiscountCost = false;
                        await objWeapon.WeaponAccessories.ForEachWithSideEffectsAsync(async objAccessory =>
                        {
                            objAccessory.DiscountCost = false;
                            foreach (Gear objGear in await objAccessory.GearChildren.GetAllDescendantsAsync(
                                         x => x.Children, token).ConfigureAwait(false))
                            {
                                token.ThrowIfCancellationRequested();
                                objGear.DiscountCost = false;
                            }
                        }, token).ConfigureAwait(false);
                    }
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether this character can quicken spells.
        /// </summary>
        public bool QuickeningEnabled =>
            ImprovementManager
                .GetCachedImprovementListForValueOf(
                    this, Improvement.ImprovementType.QuickeningMetamagic).Count > 0;

        /// <summary>
        /// Whether this character can quicken spells.
        /// </summary>
        public async Task<bool> GetQuickeningEnabledAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            return (await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                    this, Improvement.ImprovementType.QuickeningMetamagic, token: token).ConfigureAwait(false)).Count > 0;
        }

        /// <summary>
        /// Whether user is getting free bioware from Prototype Transhuman.
        /// </summary>
        public decimal PrototypeTranshuman
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _decPrototypeTranshuman;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (_decPrototypeTranshuman == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _decPrototypeTranshuman = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Whether user is getting free bioware from Prototype Transhuman.
        /// </summary>
        public async Task<decimal> GetPrototypeTranshumanAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _decPrototypeTranshuman;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether user is getting free bioware from Prototype Transhuman.
        /// </summary>
        public async Task SetPrototypeTranshumanAsync(decimal value, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_decPrototypeTranshuman == value)
                    return;
                IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    _decPrototypeTranshuman = value;
                    await OnPropertyChangedAsync(nameof(PrototypeTranshuman), token).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether user is getting free bioware from Prototype Transhuman.
        /// </summary>
        public async Task ModifyPrototypeTranshumanAsync(decimal value, CancellationToken token = default)
        {
            if (value == 0)
                return;
            IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                _decPrototypeTranshuman += value;
                await OnPropertyChangedAsync(nameof(PrototypeTranshuman), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public bool IsPrototypeTranshuman => PrototypeTranshuman > 0;

        public async Task<bool> GetIsPrototypeTranshumanAsync(CancellationToken token = default) =>
            await GetPrototypeTranshumanAsync(token).ConfigureAwait(false) > 0;

        /// <summary>
        /// Whether Friends in High Places is enabled.
        /// </summary>
        public bool FriendsInHighPlaces => ImprovementManager
                                           .GetCachedImprovementListForValueOf(
                                               this, Improvement.ImprovementType.FriendsInHighPlaces).Count > 0;

        /// <summary>
        /// Whether Friends in High Places is enabled.
        /// </summary>
        public async Task<bool> GetFriendsInHighPlacesAsync(CancellationToken token = default)
        {
            return (await ImprovementManager
                          .GetCachedImprovementListForValueOfAsync(
                              this, Improvement.ImprovementType.FriendsInHighPlaces, token: token).ConfigureAwait(false)).Count > 0;
        }

        /// <summary>
        /// Whether ExCon is enabled.
        /// </summary>
        public bool ExCon => ImprovementManager
                             .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.ExCon).Count > 0;

        /// <summary>
        /// Whether ExCon is enabled.
        /// </summary>
        public async Task<bool> GetExConAsync(CancellationToken token = default)
        {
            return (await ImprovementManager
                          .GetCachedImprovementListForValueOfAsync(
                              this, Improvement.ImprovementType.ExCon, token: token).ConfigureAwait(false)).Count > 0;
        }

        private int _intCachedTrustFund = int.MinValue;

        /// <summary>
        /// Value of the Trust Fund quality.
        /// </summary>
        public int TrustFund
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (_intCachedTrustFund != int.MinValue)
                        return _intCachedTrustFund;

                    List<Improvement> lstTrustFundImprovements = ImprovementManager
                        .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.TrustFund);
                    return _intCachedTrustFund = lstTrustFundImprovements.Count > 0
                        ? lstTrustFundImprovements.Max(x => x.Value).StandardRound()
                        : 0;
                }
            }
        }

        /// <summary>
        /// Value of the Trust Fund quality.
        /// </summary>
        public async Task<int> GetTrustFundAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_intCachedTrustFund != int.MinValue)
                    return _intCachedTrustFund;

                List<Improvement> lstTrustFundImprovements = await ImprovementManager
                    .GetCachedImprovementListForValueOfAsync(this, Improvement.ImprovementType.TrustFund, token: token)
                    .ConfigureAwait(false);
                return _intCachedTrustFund = lstTrustFundImprovements.Count > 0
                    ? lstTrustFundImprovements.Max(x => x.Value).StandardRound()
                    : 0;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private int _intCachedRestrictedGear = int.MinValue;

        /// <summary>
        /// The maximum availability for Restricted Gear if this character has it. If they do not, this is 0.
        /// </summary>
        public int RestrictedGear
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (_intCachedRestrictedGear < 0)
                    {
                        foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.RestrictedGear))
                        {
                            _intCachedRestrictedGear
                                = Math.Max(_intCachedRestrictedGear, objImprovement.Value.StandardRound());
                        }
                    }

                    return _intCachedRestrictedGear;
                }
            }
        }

        /// <summary>
        /// The maximum availability for Restricted Gear if this character has it. If they do not, this is 0.
        /// </summary>
        public async Task<int> GetRestrictedGearAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_intCachedRestrictedGear < 0)
                {
                    foreach (Improvement objImprovement in await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                 this, Improvement.ImprovementType.RestrictedGear, token: token).ConfigureAwait(false))
                    {
                        _intCachedRestrictedGear
                            = Math.Max(_intCachedRestrictedGear, objImprovement.Value.StandardRound());
                    }
                }

                return _intCachedRestrictedGear;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether Overclocker is enabled.
        /// </summary>
        public bool Overclocker => ImprovementManager
                                   .GetCachedImprovementListForValueOf(
                                       this, Improvement.ImprovementType.Overclocker).Count > 0;

        /// <summary>
        /// Whether Overclocker is enabled.
        /// </summary>
        public async Task<bool> GetOverclockerAsync(CancellationToken token = default) =>
            (await ImprovementManager.GetCachedImprovementListForValueOfAsync(this,
                Improvement.ImprovementType.Overclocker, token: token).ConfigureAwait(false)).Count > 0;

        /// <summary>
        /// Whether Made Man is enabled.
        /// </summary>
        public bool MadeMan => ImprovementManager
                               .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.MadeMan).Count > 0;

        /// <summary>
        /// Whether Made Man is enabled.
        /// </summary>
        public async Task<bool> GetMadeManAsync(CancellationToken token = default) =>
            (await ImprovementManager.GetCachedImprovementListForValueOfAsync(this,
                Improvement.ImprovementType.MadeMan, token: token).ConfigureAwait(false)).Count > 0;

        /// <summary>
        /// Whether Fame is enabled.
        /// </summary>
        public bool Fame => ImprovementManager
                            .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Fame).Count
                            > 0;

        /// <summary>
        /// Whether Fame is enabled.
        /// </summary>
        public async Task<bool> GetFameAsync(CancellationToken token = default) =>
            (await ImprovementManager.GetCachedImprovementListForValueOfAsync(this,
                Improvement.ImprovementType.Fame, token: token).ConfigureAwait(false)).Count > 0;

        /// <summary>
        /// Whether Erased is enabled.
        /// </summary>
        public bool Erased => ImprovementManager
                              .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Erased).Count
                              > 0;

        /// <summary>
        /// Whether Erased is enabled.
        /// </summary>
        public async Task<bool> GetErasedAsync(CancellationToken token = default) =>
            (await ImprovementManager.GetCachedImprovementListForValueOfAsync(this,
                Improvement.ImprovementType.Erased, token: token).ConfigureAwait(false)).Count > 0;

        /// <summary>
        /// Whether the character is allowed to Fetter sprites. See Kill Code 91 (Sprite Pet)
        /// </summary>
        public bool AllowSpriteFettering => ImprovementManager
                                            .GetCachedImprovementListForValueOf(
                                                this, Improvement.ImprovementType.AllowSpriteFettering).Count
                                            > 0;

        /// <summary>
        /// Whether the character is allowed to Fetter sprites. See Kill Code 91 (Sprite Pet)
        /// </summary>
        public async Task<bool> GetAllowSpriteFetteringAsync(CancellationToken token = default) =>
            (await ImprovementManager.GetCachedImprovementListForValueOfAsync(this,
                Improvement.ImprovementType.AllowSpriteFettering, token: token).ConfigureAwait(false)).Count > 0;

        /// <summary>
        /// Extended Availability Test information for an item based on the character's Negotiate Skill.
        /// </summary>
        /// <param name="decCost">Item's cost.</param>
        /// <param name="strAvail">Item's Availability.</param>
        public string AvailTest(decimal decCost, string strAvail)
        {
            if (string.IsNullOrEmpty(strAvail))
                return LanguageManager.GetString("String_None");
            bool blnShowTest = false;
            string strTestSuffix = LanguageManager.GetString("String_AvailRestricted");
            if (strAvail.EndsWith(strTestSuffix, StringComparison.Ordinal))
            {
                blnShowTest = true;
                strAvail = strAvail.TrimEndOnce(strTestSuffix, true);
            }
            else
            {
                strTestSuffix = LanguageManager.GetString("String_AvailForbidden");
                if (strAvail.EndsWith(strTestSuffix, StringComparison.Ordinal))
                {
                    blnShowTest = true;
                    strAvail = strAvail.TrimEndOnce(strTestSuffix, true);
                }
            }

            if (int.TryParse(strAvail, out int intAvail) && (intAvail != 0 || blnShowTest))
            {
                return GetAvailTestString(decCost, intAvail);
            }

            return LanguageManager.GetString("String_None");
        }

        /// <summary>
        /// Extended Availability Test information for an item based on the character's Negotiate Skill.
        /// </summary>
        /// <param name="decCost">Item's cost.</param>
        /// <param name="objAvailability">Item's Availability.</param>
        public string AvailTest(decimal decCost, AvailabilityValue objAvailability)
        {
            if (objAvailability.Value != 0 || objAvailability.Suffix == 'R' || objAvailability.Suffix == 'F')
            {
                return GetAvailTestString(decCost, objAvailability.Value);
            }

            return LanguageManager.GetString("String_None");
        }

        /// <summary>
        /// Extended Availability Test information for an item based on the character's Negotiate Skill.
        /// </summary>
        /// <param name="decCost">Item's cost.</param>
        /// <param name="strAvail">Item's Availability.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public async Task<string> AvailTestAsync(decimal decCost, string strAvail, CancellationToken token = default)
        {
            if (string.IsNullOrEmpty(strAvail))
                return await LanguageManager.GetStringAsync("String_None", token: token).ConfigureAwait(false);
            bool blnShowTest = false;
            string strTestSuffix = await LanguageManager.GetStringAsync("String_AvailRestricted", token: token).ConfigureAwait(false);
            if (strAvail.EndsWith(strTestSuffix, StringComparison.Ordinal))
            {
                blnShowTest = true;
                strAvail = strAvail.TrimEndOnce(strTestSuffix, true);
            }
            else
            {
                strTestSuffix = await LanguageManager.GetStringAsync("String_AvailForbidden", token: token).ConfigureAwait(false);
                if (strAvail.EndsWith(strTestSuffix, StringComparison.Ordinal))
                {
                    blnShowTest = true;
                    strAvail = strAvail.TrimEndOnce(strTestSuffix, true);
                }
            }

            if (int.TryParse(strAvail, out int intAvail) && (intAvail != 0 || blnShowTest))
            {
                return await GetAvailTestStringAsync(decCost, intAvail, token).ConfigureAwait(false);
            }

            return await LanguageManager.GetStringAsync("String_None", token: token).ConfigureAwait(false);
        }

        /// <summary>
        /// Extended Availability Test information for an item based on the character's Negotiate Skill.
        /// </summary>
        /// <param name="decCost">Item's cost.</param>
        /// <param name="objAvailability">Item's Availability.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public async Task<string> AvailTestAsync(decimal decCost, AvailabilityValue objAvailability, CancellationToken token = default)
        {
            if (objAvailability.Suffix == 'R' || objAvailability.Suffix == 'F' || await objAvailability.GetValueAsync(token).ConfigureAwait(false) != 0)
            {
                return await GetAvailTestStringAsync(decCost, await objAvailability.GetValueAsync(token).ConfigureAwait(false), token);
            }

            return await LanguageManager.GetStringAsync("String_None", token: token);
        }

        private readonly AsyncFriendlyReaderWriterLock _objAvailabilityMapLock;

        private string GetAvailTestString(decimal decCost, int intAvailValue)
        {
            string strSpace = LanguageManager.GetString("String_Space");
            using (LockObject.EnterReadLock())
            {
                // Find the character's Negotiation total.
                int intPool = SkillsSection.GetActiveSkill("Negotiation")?.Pool ?? 0;
                KeyValuePair<decimal, ValueTuple<string, string>> item = default;
                if (GlobalSettings.LiveCustomData)
                {
                    SortedDictionary<decimal, ValueTuple<string, string>> dicAvailabilityMap
                        = new SortedDictionary<decimal, ValueTuple<string, string>>();
                    foreach (XPathNavigator objNode in LoadDataXPath("options.xml")
                                 .SelectAndCacheExpression("/chummer/availmap/avail"))
                    {
                        decimal decValue = 0;
                        if (objNode.TryGetDecFieldQuickly("value", ref decValue)
                            && !dicAvailabilityMap.ContainsKey(decValue))
                        {
                            dicAvailabilityMap.Add(
                                decValue,
                                new ValueTuple<string, string>(
                                    objNode.SelectSingleNodeAndCacheExpression("duration").Value,
                                    objNode.SelectSingleNodeAndCacheExpression("interval")
                                        .Value));
                        }
                    }

                    item = dicAvailabilityMap.FirstOrDefault(
                        x => decCost < x.Key); //Assumes that the keys are sorted lowest to highest. Maybe not safe for custom content?
                }
                else
                {
                    bool blnDoCache = false;
                    using (_objAvailabilityMapLock.EnterReadLock())
                    {
                        if (_dicAvailabilityMap != null)
                            item = _dicAvailabilityMap.FirstOrDefault(
                                x => decCost
                                     < x.Key); //Assumes that the keys are sorted lowest to highest. Maybe not safe for custom content?
                        else
                            blnDoCache = true;
                    }

                    if (blnDoCache)
                    {
                        using (_objAvailabilityMapLock.EnterUpgradeableReadLock())
                        {
                            if (_dicAvailabilityMap == null)
                            {
                                using (_objAvailabilityMapLock.EnterWriteLock())
                                {
                                    SortedDictionary<decimal, ValueTuple<string, string>> dicAvailabilityMap
                                        = _dicAvailabilityMap
                                          ?? new SortedDictionary<decimal, ValueTuple<string, string>>();
                                    dicAvailabilityMap.Clear();
                                    foreach (XPathNavigator objNode in LoadDataXPath("options.xml")
                                                 .SelectAndCacheExpression("/chummer/availmap/avail"))
                                    {
                                        decimal decValue = 0;
                                        if (objNode.TryGetDecFieldQuickly("value", ref decValue)
                                            && !dicAvailabilityMap.ContainsKey(decValue))
                                        {
                                            dicAvailabilityMap.Add(
                                                decValue,
                                                new ValueTuple<string, string>(
                                                    objNode.SelectSingleNodeAndCacheExpression("duration").Value,
                                                    objNode.SelectSingleNodeAndCacheExpression("interval")
                                                        .Value));
                                        }
                                    }

                                    _dicAvailabilityMap = dicAvailabilityMap;
                                }
                            }

                            item = _dicAvailabilityMap.FirstOrDefault(
                                x => decCost <
                                     x.Key); //Assumes that the keys are sorted lowest to highest. Maybe not safe for custom content?
                        }
                    }
                }

                // Determine the interval based on the item's price.
                string strInterval = item.Value.Item1 + strSpace + LanguageManager.GetString(item.Value.Item2);

                return intPool.ToString(GlobalSettings.CultureInfo) + strSpace + "("
                       + intAvailValue.ToString(GlobalSettings.CultureInfo) + "," + strSpace + strInterval + ")";
            }
        }

        private async Task<string> GetAvailTestStringAsync(decimal decCost, int intAvailValue, CancellationToken token = default)
        {
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                // Find the character's Negotiation total.
                Skill objSkill = await (await GetSkillsSectionAsync(token).ConfigureAwait(false)).GetActiveSkillAsync("Negotiation", token).ConfigureAwait(false);
                int intPool = objSkill != null ? await objSkill.GetPoolAsync(token).ConfigureAwait(false) : 0;
                KeyValuePair<decimal, ValueTuple<string, string>> item = default;
                if (GlobalSettings.LiveCustomData)
                {
                    SortedDictionary<decimal, ValueTuple<string, string>> dicAvailabilityMap
                        = new SortedDictionary<decimal, ValueTuple<string, string>>();
                    foreach (XPathNavigator objNode in (await LoadDataXPathAsync(
                                 "options.xml", token: token).ConfigureAwait(false))
                             .SelectAndCacheExpression("/chummer/availmap/avail", token))
                    {
                        decimal decValue = 0;
                        if (objNode.TryGetDecFieldQuickly("value", ref decValue)
                            && !dicAvailabilityMap.ContainsKey(decValue))
                        {
                            dicAvailabilityMap.Add(
                                decValue,
                                new ValueTuple<string, string>(
                                    objNode.SelectSingleNodeAndCacheExpression("duration", token).Value,
                                    objNode.SelectSingleNodeAndCacheExpression("interval", token).Value));
                        }
                    }
                    item = dicAvailabilityMap.FirstOrDefault(
                        x => decCost
                             < x.Key); //Assumes that the keys are sorted lowest to highest. Maybe not safe for custom content?
                }
                else
                {
                    bool blnDoCache = false;
                    IAsyncDisposable objLocker2 = await _objAvailabilityMapLock.EnterReadLockAsync(token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        if (_dicAvailabilityMap != null)
                            item = _dicAvailabilityMap.FirstOrDefault(
                                x => decCost
                                     < x.Key); //Assumes that the keys are sorted lowest to highest. Maybe not safe for custom content?
                        else
                            blnDoCache = true;
                    }
                    finally
                    {
                        await objLocker2.DisposeAsync().ConfigureAwait(false);
                    }

                    if (blnDoCache)
                    {
                        objLocker2 = await _objAvailabilityMapLock.EnterUpgradeableReadLockAsync(token)
                            .ConfigureAwait(false);
                        try
                        {
                            token.ThrowIfCancellationRequested();
                            if (_dicAvailabilityMap == null)
                            {
                                IAsyncDisposable objLocker3
                                    = await _objAvailabilityMapLock.EnterWriteLockAsync(token).ConfigureAwait(false);
                                try
                                {
                                    token.ThrowIfCancellationRequested();
                                    SortedDictionary<decimal, ValueTuple<string, string>> dicAvailabilityMap
                                        = _dicAvailabilityMap
                                          ?? new SortedDictionary<decimal, ValueTuple<string, string>>();
                                    dicAvailabilityMap.Clear();
                                    foreach (XPathNavigator objNode in (await LoadDataXPathAsync(
                                                 "options.xml", token: token).ConfigureAwait(false))
                                             .SelectAndCacheExpression("/chummer/availmap/avail", token))
                                    {
                                        decimal decValue = 0;
                                        if (objNode.TryGetDecFieldQuickly("value", ref decValue)
                                            && !dicAvailabilityMap.ContainsKey(decValue))
                                        {
                                            dicAvailabilityMap.Add(
                                                decValue,
                                                new ValueTuple<string, string>(
                                                    objNode.SelectSingleNodeAndCacheExpression("duration", token).Value,
                                                    objNode.SelectSingleNodeAndCacheExpression("interval", token).Value));
                                        }
                                    }

                                    _dicAvailabilityMap = dicAvailabilityMap;
                                }
                                finally
                                {
                                    await objLocker3.DisposeAsync().ConfigureAwait(false);
                                }
                            }

                            item = _dicAvailabilityMap.FirstOrDefault(
                                x => decCost
                                     < x.Key); //Assumes that the keys are sorted lowest to highest. Maybe not safe for custom content?
                        }
                        finally
                        {
                            await objLocker2.DisposeAsync().ConfigureAwait(false);
                        }
                    }
                }

                // Determine the interval based on the item's price.
                string strInterval = item.Value.Item1 + strSpace + await LanguageManager.GetStringAsync(item.Value.Item2, token: token).ConfigureAwait(false);

                return intPool.ToString(GlobalSettings.CultureInfo) + strSpace + "("
                       + intAvailValue.ToString(GlobalSettings.CultureInfo) + "," + strSpace + strInterval + ")";
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether Adapsin is enabled.
        /// </summary>
        public bool AdapsinEnabled =>
            ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Adapsin)
                              .Count > 0;

        /// <summary>
        /// Whether Adapsin is enabled.
        /// </summary>
        public async Task<bool> GetAdapsinEnabledAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            return (await ImprovementManager.GetCachedImprovementListForValueOfAsync(this, Improvement.ImprovementType.Adapsin, token: token))
                              .Count > 0;
        }

        /// <summary>
        /// Whether Burnout's Way is enabled.
        /// </summary>
        public bool BurnoutsWayEnabled =>
            ImprovementManager
                .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.BurnoutsWay)
                .Count > 0;

        /// <summary>
        /// Whether Burnout's Way is enabled.
        /// </summary>
        public async Task<bool> GetBurnoutsWayEnabledAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            return (await ImprovementManager.GetCachedImprovementListForValueOfAsync(this, Improvement.ImprovementType.BurnoutsWay, token: token))
                              .Count > 0;
        }

        #endregion Special Functions and Enabled Check Properties

        #region Application Properties

        private readonly ConcurrentHashSet<Character> _lstLinkedCharacters = new ConcurrentHashSet<Character>();

        /// <summary>
        /// Characters referenced by some member of this character (usually a contact).
        /// </summary>
        public ConcurrentHashSet<Character> LinkedCharacters
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _lstLinkedCharacters;
            }
        }

        /// <summary>
        /// Characters referenced by some member of this character (usually a contact).
        /// </summary>
        public async Task<ConcurrentHashSet<Character>> GetLinkedCharactersAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _lstLinkedCharacters;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        #endregion Application Properties

        #region Old Quality Conversion Code

        /// <summary>
        /// Convert Qualities that are still saved in the old format.
        /// </summary>
        private void ConvertOldQualities(XmlNodeList objXmlQualityList)
        {
            using (LockObject.EnterUpgradeableReadLock())
            {
                XmlNode xmlRootQualitiesNode = LoadData("qualities.xml").SelectSingleNode("/chummer/qualities");

                if (xmlRootQualitiesNode != null)
                {
                    // Convert the old Qualities.
                    foreach (XmlNode objXmlQuality in objXmlQualityList)
                    {
                        if (objXmlQuality["name"] == null)
                        {
                            XmlNode objXmlQualityNode =
                                xmlRootQualitiesNode.TryGetNodeByNameOrId(
                                    "quality", GetQualityName(objXmlQuality.InnerTextViaPool()));

                            if (objXmlQualityNode != null)
                            {
                                string strForceValue = string.Empty;
                                // Re-create the bonuses for the Quality.
                                if (objXmlQualityNode.HasChildWithName("bonus"))
                                {
                                    // Look for the existing Improvement.
                                    string strXmlQualityInnerText = objXmlQuality.InnerTextViaPool();
                                    Improvement objExistingImprovement = Improvements.FirstOrDefault(x =>
                                        x.ImproveSource == Improvement.ImprovementSource.Quality &&
                                        x.SourceName == strXmlQualityInnerText
                                        && x.Enabled);
                                    if (objExistingImprovement != null)
                                    {
                                        strForceValue = objExistingImprovement.ImprovedName;
                                        using (LockObject.EnterWriteLock())
                                        {
                                            Improvements.Remove(objExistingImprovement);
                                        }
                                    }
                                }

                                using (LockObject.EnterWriteLock())
                                {
                                    // Convert the item to the new Quality class.
                                    Quality objQuality = new Quality(this);
                                    try
                                    {
                                        objQuality.Create(objXmlQualityNode, QualitySource.Selected, _lstWeapons,
                                                          strForceValue);
                                        Qualities.Add(objQuality);
                                    }
                                    catch
                                    {
                                        objQuality.DeleteQuality();
                                        throw;
                                    }
                                }
                            }
                        }
                    }

                    // Take care of the Metatype information.
                    XmlNode objXmlMetatype = LoadData("metatypes.xml").TryGetNodeByNameOrId("/chummer/metatypes/metatype", Metatype) ??
                                             LoadData("critters.xml").TryGetNodeByNameOrId("/chummer/metatypes/metatype", Metatype);

                    if (objXmlMetatype != null)
                    {
                        // Positive Qualities.
                        using (XmlNodeList xmlMetatypeQualityList =
                               objXmlMetatype.SelectNodes("qualities/positive/quality"))
                        {
                            if (xmlMetatypeQualityList != null)
                            {
                                foreach (XmlNode objXmlMetatypeQuality in xmlMetatypeQualityList)
                                {
                                    bool blnFound = false;
                                    string strInnerText = objXmlMetatypeQuality.InnerTextViaPool();
                                    // See if the Quality already exists in the character.
                                    foreach (Quality objCharacterQuality in _lstQualities)
                                    {
                                        if (objCharacterQuality.Name == strInnerText)
                                        {
                                            blnFound = true;
                                            break;
                                        }
                                    }

                                    // If the Quality was not found, create it.
                                    if (!blnFound)
                                    {
                                        string strForceValue =
                                            objXmlMetatypeQuality.Attributes?["select"]?.InnerTextViaPool() ?? string.Empty;
                                        XmlNode objXmlQuality =
                                            xmlRootQualitiesNode.TryGetNodeByNameOrId("quality", strInnerText);
                                        using (LockObject.EnterWriteLock())
                                        {
                                            Quality objQuality = new Quality(this);
                                            try
                                            {
                                                objQuality.Create(objXmlQuality, QualitySource.Metatype, _lstWeapons,
                                                                  strForceValue);
                                                Qualities.Add(objQuality);
                                            }
                                            catch
                                            {
                                                objQuality.DeleteQuality();
                                                throw;
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        // Negative Qualities.
                        using (XmlNodeList xmlMetatypeQualityList =
                               objXmlMetatype.SelectNodes("qualities/negative/quality"))
                        {
                            if (xmlMetatypeQualityList != null)
                            {
                                foreach (XmlNode objXmlMetatypeQuality in xmlMetatypeQualityList)
                                {
                                    bool blnFound = false;
                                    string strInnerText = objXmlMetatypeQuality.InnerTextViaPool();
                                    // See if the Quality already exists in the character.
                                    foreach (Quality objCharacterQuality in _lstQualities)
                                    {
                                        if (objCharacterQuality.Name == strInnerText)
                                        {
                                            blnFound = true;
                                            break;
                                        }
                                    }

                                    // If the Quality was not found, create it.
                                    if (!blnFound)
                                    {
                                        string strForceValue =
                                            objXmlMetatypeQuality.Attributes?["select"]?.InnerTextViaPool() ?? string.Empty;
                                        XmlNode objXmlQuality =
                                            xmlRootQualitiesNode.TryGetNodeByNameOrId("quality", strInnerText);
                                        using (LockObject.EnterWriteLock())
                                        {
                                            Quality objQuality = new Quality(this);
                                            try
                                            {
                                                objQuality.Create(objXmlQuality, QualitySource.Metatype, _lstWeapons,
                                                                  strForceValue);
                                                Qualities.Add(objQuality);
                                            }
                                            catch
                                            {
                                                objQuality.DeleteQuality();
                                                throw;
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        // Do it all over again for Metavariants.
                        if (!string.IsNullOrEmpty(Metavariant))
                        {
                            objXmlMetatype =
                                objXmlMetatype.TryGetNodeByNameOrId("metavariants/metavariant", Metavariant);

                            if (objXmlMetatype != null)
                            {
                                // Positive Qualities.
                                using (XmlNodeList xmlMetatypeQualityList =
                                       objXmlMetatype.SelectNodes("qualities/positive/quality"))
                                {
                                    if (xmlMetatypeQualityList != null)
                                    {
                                        foreach (XmlNode objXmlMetatypeQuality in xmlMetatypeQualityList)
                                        {
                                            bool blnFound = false;
                                            // See if the Quality already exists in the character.
                                            foreach (Quality objCharacterQuality in _lstQualities)
                                            {
                                                if (objCharacterQuality.Name == objXmlMetatypeQuality.InnerTextViaPool())
                                                {
                                                    blnFound = true;
                                                    break;
                                                }
                                            }

                                            // If the Quality was not found, create it.
                                            if (!blnFound)
                                            {
                                                string strForceValue =
                                                    objXmlMetatypeQuality.Attributes?["select"]?.InnerTextViaPool()
                                                    ?? string.Empty;
                                                XmlNode objXmlQuality =
                                                    xmlRootQualitiesNode.TryGetNodeByNameOrId("quality", objXmlMetatypeQuality.InnerTextViaPool());
                                                using (LockObject.EnterWriteLock())
                                                {
                                                    Quality objQuality = new Quality(this);
                                                    try
                                                    {
                                                        objQuality.Create(objXmlQuality, QualitySource.Metatype,
                                                                          _lstWeapons,
                                                                          strForceValue);
                                                        Qualities.Add(objQuality);
                                                    }
                                                    catch
                                                    {
                                                        objQuality.DeleteQuality();
                                                        throw;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }

                                // Negative Qualities.
                                using (XmlNodeList xmlMetatypeQualityList =
                                       objXmlMetatype.SelectNodes("qualities/negative/quality"))
                                {
                                    if (xmlMetatypeQualityList != null)
                                    {
                                        foreach (XmlNode objXmlMetatypeQuality in xmlMetatypeQualityList)
                                        {
                                            bool blnFound = false;
                                            // See if the Quality already exists in the character.
                                            foreach (Quality objCharacterQuality in _lstQualities)
                                            {
                                                if (objCharacterQuality.Name == objXmlMetatypeQuality.InnerTextViaPool())
                                                {
                                                    blnFound = true;
                                                    break;
                                                }
                                            }

                                            // If the Quality was not found, create it.
                                            if (!blnFound)
                                            {
                                                string strForceValue =
                                                    objXmlMetatypeQuality.Attributes?["select"]?.InnerTextViaPool()
                                                    ?? string.Empty;
                                                XmlNode objXmlQuality =
                                                    xmlRootQualitiesNode.TryGetNodeByNameOrId("quality", objXmlMetatypeQuality.InnerTextViaPool());
                                                using (LockObject.EnterWriteLock())
                                                {
                                                    Quality objQuality = new Quality(this);
                                                    try
                                                    {
                                                        objQuality.Create(objXmlQuality, QualitySource.Metatype,
                                                                          _lstWeapons,
                                                                          strForceValue);
                                                        Qualities.Add(objQuality);
                                                    }
                                                    catch
                                                    {
                                                        objQuality.DeleteQuality();
                                                        throw;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Convert Qualities that are still saved in the old format.
        /// </summary>
        private async Task ConvertOldQualitiesAsync(XmlNodeList objXmlQualityList, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                XmlNode xmlRootQualitiesNode = (await LoadDataAsync("qualities.xml", token: token).ConfigureAwait(false)).SelectSingleNode("/chummer/qualities");

                if (xmlRootQualitiesNode != null)
                {
                    // Convert the old Qualities.
                    foreach (XmlNode objXmlQuality in objXmlQualityList)
                    {
                        if (objXmlQuality["name"] == null)
                        {
                            string strInnerText = objXmlQuality.InnerTextViaPool(token);
                            XmlNode objXmlQualityNode =
                                xmlRootQualitiesNode.TryGetNodeByNameOrId(
                                    "quality", GetQualityName(strInnerText));

                            if (objXmlQualityNode != null)
                            {
                                string strForceValue = string.Empty;
                                // Re-create the bonuses for the Quality.
                                if (objXmlQualityNode.HasChildWithName("bonus"))
                                {
                                    // Look for the existing Improvement.
                                    Improvement objExistingImprovement = await Improvements.FirstOrDefaultAsync(x =>
                                        x.ImproveSource == Improvement.ImprovementSource.Quality &&
                                        x.SourceName == strInnerText
                                        && x.Enabled, token: token).ConfigureAwait(false);
                                    if (objExistingImprovement != null)
                                    {
                                        strForceValue = objExistingImprovement.ImprovedName;
                                        IAsyncDisposable objLocker3 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                                        try
                                        {
                                            token.ThrowIfCancellationRequested();
                                            await Improvements.RemoveAsync(objExistingImprovement, token).ConfigureAwait(false);
                                        }
                                        finally
                                        {
                                            await objLocker3.DisposeAsync().ConfigureAwait(false);
                                        }
                                    }
                                }

                                IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                                try
                                {
                                    token.ThrowIfCancellationRequested();
                                    // Convert the item to the new Quality class.
                                    Quality objQuality = new Quality(this);
                                    try
                                    {
                                        await objQuality.CreateAsync(objXmlQualityNode, QualitySource.Selected, _lstWeapons,
                                            strForceValue, token: token).ConfigureAwait(false);
                                        await Qualities.AddAsync(objQuality, token).ConfigureAwait(false);
                                    }
                                    catch
                                    {
                                        await objQuality.DeleteQualityAsync(token: CancellationToken.None).ConfigureAwait(false);
                                        throw;
                                    }
                                }
                                finally
                                {
                                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                                }
                            }
                        }
                    }

                    // Take care of the Metatype information.
                    XmlNode objXmlMetatype =
                        (await LoadDataAsync("metatypes.xml", token: token).ConfigureAwait(false)).TryGetNodeByNameOrId("/chummer/metatypes/metatype", Metatype) ??
                        (await LoadDataAsync("critters.xml", token: token).ConfigureAwait(false)).TryGetNodeByNameOrId("/chummer/metatypes/metatype", Metatype);

                    if (objXmlMetatype != null)
                    {
                        // Positive Qualities.
                        using (XmlNodeList xmlMetatypeQualityList =
                               objXmlMetatype.SelectNodes("qualities/positive/quality"))
                        {
                            if (xmlMetatypeQualityList != null)
                            {
                                foreach (XmlNode objXmlMetatypeQuality in xmlMetatypeQualityList)
                                {
                                    string strInnerText = objXmlMetatypeQuality.InnerTextViaPool(token);
                                    // See if the Quality already exists in the character.
                                    // If the Quality was not found, create it.
                                    if (!await _lstQualities.AnyAsync(async x => await x.GetNameAsync(token).ConfigureAwait(false) == strInnerText, token: token).ConfigureAwait(false))
                                    {
                                        string strForceValue =
                                            objXmlMetatypeQuality.Attributes?["select"]?.InnerTextViaPool(token) ?? string.Empty;
                                        XmlNode objXmlQuality =
                                            xmlRootQualitiesNode.TryGetNodeByNameOrId("quality",
                                                strInnerText);
                                        IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                                        try
                                        {
                                            token.ThrowIfCancellationRequested();
                                            Quality objQuality = new Quality(this);
                                            try
                                            {
                                                await objQuality.CreateAsync(objXmlQuality, QualitySource.Metatype, _lstWeapons,
                                                    strForceValue, token: token).ConfigureAwait(false);
                                                await Qualities.AddAsync(objQuality, token).ConfigureAwait(false);
                                            }
                                            catch
                                            {
                                                await objQuality.DeleteQualityAsync(token: CancellationToken.None).ConfigureAwait(false);
                                                throw;
                                            }
                                        }
                                        finally
                                        {
                                            await objLocker2.DisposeAsync().ConfigureAwait(false);
                                        }
                                    }
                                }
                            }
                        }

                        // Negative Qualities.
                        using (XmlNodeList xmlMetatypeQualityList =
                               objXmlMetatype.SelectNodes("qualities/negative/quality"))
                        {
                            if (xmlMetatypeQualityList != null)
                            {
                                foreach (XmlNode objXmlMetatypeQuality in xmlMetatypeQualityList)
                                {
                                    // See if the Quality already exists in the character.
                                    // If the Quality was not found, create it.
                                    if (!await _lstQualities.AnyAsync(async x => await x.GetNameAsync(token).ConfigureAwait(false) == objXmlMetatypeQuality.InnerTextViaPool(token), token: token).ConfigureAwait(false))
                                    {
                                        string strForceValue =
                                            objXmlMetatypeQuality.Attributes?["select"]?.InnerTextViaPool(token) ?? string.Empty;
                                        XmlNode objXmlQuality =
                                            xmlRootQualitiesNode.TryGetNodeByNameOrId("quality",
                                                objXmlMetatypeQuality.InnerTextViaPool(token));
                                        IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                                        try
                                        {
                                            token.ThrowIfCancellationRequested();
                                            Quality objQuality = new Quality(this);
                                            try
                                            {
                                                await objQuality.CreateAsync(objXmlQuality, QualitySource.Metatype, _lstWeapons,
                                                    strForceValue, token: token).ConfigureAwait(false);
                                                await Qualities.AddAsync(objQuality, token).ConfigureAwait(false);
                                            }
                                            catch
                                            {
                                                await objQuality.DeleteQualityAsync(token: CancellationToken.None).ConfigureAwait(false);
                                                throw;
                                            }
                                        }
                                        finally
                                        {
                                            await objLocker2.DisposeAsync().ConfigureAwait(false);
                                        }
                                    }
                                }
                            }
                        }

                        // Do it all over again for Metavariants.
                        if (!string.IsNullOrEmpty(Metavariant))
                        {
                            objXmlMetatype =
                                objXmlMetatype.TryGetNodeByNameOrId("metavariants/metavariant", Metavariant);

                            if (objXmlMetatype != null)
                            {
                                // Positive Qualities.
                                using (XmlNodeList xmlMetatypeQualityList =
                                       objXmlMetatype.SelectNodes("qualities/positive/quality"))
                                {
                                    if (xmlMetatypeQualityList != null)
                                    {
                                        foreach (XmlNode objXmlMetatypeQuality in xmlMetatypeQualityList)
                                        {
                                            // See if the Quality already exists in the character.
                                            // If the Quality was not found, create it.
                                            if (!await _lstQualities.AnyAsync(async x => await x.GetNameAsync(token).ConfigureAwait(false) == objXmlMetatypeQuality.InnerTextViaPool(token), token: token).ConfigureAwait(false))
                                            {
                                                string strForceValue =
                                                    objXmlMetatypeQuality.Attributes?["select"]?.InnerTextViaPool(token)
                                                    ?? string.Empty;
                                                XmlNode objXmlQuality =
                                                    xmlRootQualitiesNode.TryGetNodeByNameOrId("quality",
                                                        objXmlMetatypeQuality.InnerTextViaPool(token));
                                                IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                                                try
                                                {
                                                    token.ThrowIfCancellationRequested();
                                                    Quality objQuality = new Quality(this);
                                                    try
                                                    {
                                                        await objQuality.CreateAsync(objXmlQuality, QualitySource.Metatype,
                                                            _lstWeapons,
                                                            strForceValue, token: token).ConfigureAwait(false);
                                                        await Qualities.AddAsync(objQuality, token).ConfigureAwait(false);
                                                    }
                                                    catch
                                                    {
                                                        await objQuality.DeleteQualityAsync(token: CancellationToken.None).ConfigureAwait(false);
                                                        throw;
                                                    }
                                                }
                                                finally
                                                {
                                                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                                                }
                                            }
                                        }
                                    }
                                }

                                // Negative Qualities.
                                using (XmlNodeList xmlMetatypeQualityList =
                                       objXmlMetatype.SelectNodes("qualities/negative/quality"))
                                {
                                    if (xmlMetatypeQualityList != null)
                                    {
                                        foreach (XmlNode objXmlMetatypeQuality in xmlMetatypeQualityList)
                                        {
                                            // See if the Quality already exists in the character.
                                            // If the Quality was not found, create it.
                                            if (!await _lstQualities.AnyAsync(async x => await x.GetNameAsync(token).ConfigureAwait(false) == objXmlMetatypeQuality.InnerTextViaPool(token), token: token).ConfigureAwait(false))
                                            {
                                                string strForceValue =
                                                    objXmlMetatypeQuality.Attributes?["select"]?.InnerTextViaPool(token)
                                                    ?? string.Empty;
                                                XmlNode objXmlQuality =
                                                    xmlRootQualitiesNode.TryGetNodeByNameOrId("quality",
                                                        objXmlMetatypeQuality.InnerTextViaPool(token));
                                                IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                                                try
                                                {
                                                    token.ThrowIfCancellationRequested();
                                                    Quality objQuality = new Quality(this);
                                                    try
                                                    {
                                                        await objQuality.CreateAsync(objXmlQuality, QualitySource.Metatype,
                                                            _lstWeapons,
                                                            strForceValue, token: token).ConfigureAwait(false);
                                                        await Qualities.AddAsync(objQuality, token).ConfigureAwait(false);
                                                    }
                                                    catch
                                                    {
                                                        await objQuality.DeleteQualityAsync(token: CancellationToken.None).ConfigureAwait(false);
                                                        throw;
                                                    }
                                                }
                                                finally
                                                {
                                                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Get the name of a Quality by parsing out its BP cost.
        /// </summary>
        /// <param name="strQuality">String to parse.</param>
        private static string GetQualityName(string strQuality)
        {
            int intPos = strQuality.IndexOf('[');
            if (intPos != -1)
                strQuality = strQuality.Substring(0, intPos - 1);
            return strQuality;
        }

        private static ValueTuple<XmlNode, int> CorrectedUnleveledQualityCommon(string strName, XmlNode xmlRootQualitiesNode)
        {
            XmlNode xmlNewQuality = null;
            int intRanks = 0;
            switch (strName)
            {
                case "Focused Concentration (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Focused Concentration\"]");
                        intRanks = 1;
                        break;
                    }
                case "Focused Concentration (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Focused Concentration\"]");
                        intRanks = 2;
                        break;
                    }
                case "Focused Concentration (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Focused Concentration\"]");
                        intRanks = 3;
                        break;
                    }
                case "Focused Concentration (Rating 4)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Focused Concentration\"]");
                        intRanks = 4;
                        break;
                    }
                case "Focused Concentration (Rating 5)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Focused Concentration\"]");
                        intRanks = 5;
                        break;
                    }
                case "Focused Concentration (Rating 6)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Focused Concentration\"]");
                        intRanks = 6;
                        break;
                    }
                case "High Pain Tolerance (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"High Pain Tolerance\"]");
                        intRanks = 1;
                        break;
                    }
                case "High Pain Tolerance (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"High Pain Tolerance\"]");
                        intRanks = 2;
                        break;
                    }
                case "High Pain Tolerance (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"High Pain Tolerance\"]");
                        intRanks = 3;
                        break;
                    }
                case "Magic Resistance (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Magic Resistance\"]");
                        intRanks = 1;
                        break;
                    }
                case "Magic Resistance (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Magic Resistance\"]");
                        intRanks = 2;
                        break;
                    }
                case "Magic Resistance (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Magic Resistance\"]");
                        intRanks = 3;
                        break;
                    }
                case "Magic Resistance (Rating 4)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Magic Resistance\"]");
                        intRanks = 4;
                        break;
                    }
                case "Will to Live (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Will to Live\"]");
                        intRanks = 1;
                        break;
                    }
                case "Will to Live (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Will to Live\"]");
                        intRanks = 2;
                        break;
                    }
                case "Will to Live (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Will to Live\"]");
                        intRanks = 3;
                        break;
                    }
                case "Gremlins (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Gremlins\"]");
                        intRanks = 1;
                        break;
                    }
                case "Gremlins (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Gremlins\"]");
                        intRanks = 2;
                        break;
                    }
                case "Gremlins (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Gremlins\"]");
                        intRanks = 3;
                        break;
                    }
                case "Gremlins (Rating 4)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Gremlins\"]");
                        intRanks = 4;
                        break;
                    }
                case "Aged (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Aged\"]");
                        intRanks = 1;
                        break;
                    }
                case "Aged (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Aged\"]");
                        intRanks = 2;
                        break;
                    }
                case "Aged (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Aged\"]");
                        intRanks = 3;
                        break;
                    }
                case "Illness (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Illness\"]");
                        intRanks = 1;
                        break;
                    }
                case "Illness (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Illness\"]");
                        intRanks = 2;
                        break;
                    }
                case "Illness (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Illness\"]");
                        intRanks = 3;
                        break;
                    }
                case "Perceptive I":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Perceptive\"]");
                        intRanks = 1;
                        break;
                    }
                case "Perceptive II":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Perceptive\"]");
                        intRanks = 2;
                        break;
                    }
                case "Spike Resistance I":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Spike Resistance\"]");
                        intRanks = 1;
                        break;
                    }
                case "Spike Resistance II":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Spike Resistance\"]");
                        intRanks = 2;
                        break;
                    }
                case "Spike Resistance III":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Spike Resistance\"]");
                        intRanks = 3;
                        break;
                    }
                case "Tough as Nails Physical I":
                    {
                        xmlNewQuality =
                            xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Tough as Nails (Physical)\"]");
                        intRanks = 1;
                        break;
                    }
                case "Tough as Nails Physical II":
                    {
                        xmlNewQuality =
                            xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Tough as Nails (Physical)\"]");
                        intRanks = 2;
                        break;
                    }
                case "Tough as Nails Physical III":
                    {
                        xmlNewQuality =
                            xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Tough as Nails (Physical)\"]");
                        intRanks = 3;
                        break;
                    }
                case "Tough as Nails Stun I":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Tough as Nails (Stun)\"]");
                        intRanks = 1;
                        break;
                    }
                case "Tough as Nails Stun II":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Tough as Nails (Stun)\"]");
                        intRanks = 2;
                        break;
                    }
                case "Tough as Nails Stun III":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Tough as Nails (Stun)\"]");
                        intRanks = 3;
                        break;
                    }
                case "Dimmer Bulb I":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Dimmer Bulb\"]");
                        intRanks = 1;
                        break;
                    }
                case "Dimmer Bulb II":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Dimmer Bulb\"]");
                        intRanks = 2;
                        break;
                    }
                case "Dimmer Bulb III":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Dimmer Bulb\"]");
                        intRanks = 3;
                        break;
                    }
                case "In Debt I":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 1;
                        break;
                    }
                case "In Debt II":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 2;
                        break;
                    }
                case "In Debt III":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 3;
                        break;
                    }
                case "In Debt IV":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 4;
                        break;
                    }
                case "In Debt V":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 5;
                        break;
                    }
                case "In Debt VI":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 6;
                        break;
                    }
                case "In Debt VII":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 7;
                        break;
                    }
                case "In Debt VIII":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 8;
                        break;
                    }
                case "In Debt IX":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 9;
                        break;
                    }
                case "In Debt X":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 10;
                        break;
                    }
                case "In Debt XI":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 11;
                        break;
                    }
                case "In Debt XII":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 12;
                        break;
                    }
                case "In Debt XIII":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 13;
                        break;
                    }
                case "In Debt XIV":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 14;
                        break;
                    }
                case "In Debt XV":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 15;
                        break;
                    }
                case "Infirm I":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Infirm\"]");
                        intRanks = 1;
                        break;
                    }
                case "Infirm II":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Infirm\"]");
                        intRanks = 2;
                        break;
                    }
                case "Infirm III":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Infirm\"]");
                        intRanks = 3;
                        break;
                    }
                case "Infirm IV":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Infirm\"]");
                        intRanks = 4;
                        break;
                    }
                case "Infirm V":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Infirm\"]");
                        intRanks = 5;
                        break;
                    }
                case "Shiva Arms (1 Pair)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Shiva Arms (Pair)\"]");
                        intRanks = 1;
                        break;
                    }
                case "Shiva Arms (2 Pair)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Shiva Arms (Pair)\"]");
                        intRanks = 2;
                        break;
                    }
                case "Arcane Arrester I":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Arcane Arrester\"]");
                        intRanks = 1;
                        break;
                    }
                case "Arcane Arrester II":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Arcane Arrester\"]");
                        intRanks = 2;
                        break;
                    }
                case "Pilot Origins (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Pilot Origins\"]");
                        intRanks = 1;
                        break;
                    }
                case "Pilot Origins (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Pilot Origins\"]");
                        intRanks = 2;
                        break;
                    }
                case "Pilot Origins (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Pilot Origins\"]");
                        intRanks = 3;
                        break;
                    }
                case "Social Appearance Anxiety (Rating 1)":
                    {
                        xmlNewQuality =
                            xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Social Appearance Anxiety\"]");
                        intRanks = 1;
                        break;
                    }
                case "Social Appearance Anxiety (Rating 2)":
                    {
                        xmlNewQuality =
                            xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Social Appearance Anxiety\"]");
                        intRanks = 2;
                        break;
                    }
                case "Social Appearance Anxiety (Rating 3)":
                    {
                        xmlNewQuality =
                            xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Social Appearance Anxiety\"]");
                        intRanks = 3;
                        break;
                    }
            }

            return new ValueTuple<XmlNode, int>(xmlNewQuality, intRanks);
        }

        /// <summary>
        /// Check for older instances of certain qualities that were manually numbered to be replaced with multiple instances of the first level quality (so that it works with the level system)
        /// Returns true if it's a corrected quality, false otherwise
        /// </summary>
        private bool CorrectedUnleveledQuality(XmlNode xmlOldQuality, XmlNode xmlRootQualitiesNode, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            (XmlNode xmlNewQuality, int intRanks) = CorrectedUnleveledQualityCommon(xmlOldQuality["name"]?.InnerTextViaPool(token), xmlRootQualitiesNode);
            token.ThrowIfCancellationRequested();
            if (intRanks > 0)
            {
                using (LockObject.EnterWriteLock(token))
                {
                    for (int i = 0; i < intRanks; ++i)
                    {
                        token.ThrowIfCancellationRequested();
                        Quality objQuality = new Quality(this);
                        try
                        {
                            if (i == 0 && xmlOldQuality.TryGetField("guid", Guid.TryParse, out Guid guidOld))
                            {
                                ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Quality,
                                                                      guidOld.ToString(), token);
                                objQuality.SetGUID(guidOld);
                            }

                            QualitySource objQualitySource =
                                Quality.ConvertToQualitySource(xmlOldQuality["qualitysource"]?.InnerTextViaPool(token));
                            objQuality.Create(xmlNewQuality, objQualitySource, _lstWeapons,
                                              xmlOldQuality["extra"]?.InnerTextViaPool(token), token: token);
                            if (xmlOldQuality["bp"] != null
                                && int.TryParse(xmlOldQuality["bp"].InnerTextViaPool(token), out int intOldBP))
                                objQuality.BP = intOldBP / intRanks;

                            Qualities.Add(objQuality);
                        }
                        catch
                        {
                            objQuality.DeleteQuality(token: CancellationToken.None);
                            throw;
                        }
                    }
                }

                return true;
            }

            return false;
        }

        /// <summary>
        /// Check for older instances of certain qualities that were manually numbered to be replaced with multiple instances of the first level quality (so that it works with the level system)
        /// Returns true if it's a corrected quality, false otherwise
        /// </summary>
        private async Task<bool> CorrectedUnleveledQualityAsync(XmlNode xmlOldQuality, XmlNode xmlRootQualitiesNode, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            (XmlNode xmlNewQuality, int intRanks) = CorrectedUnleveledQualityCommon(xmlOldQuality["name"]?.InnerTextViaPool(token), xmlRootQualitiesNode);
            token.ThrowIfCancellationRequested();
            if (intRanks > 0)
            {
                IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    for (int i = 0; i < intRanks; ++i)
                    {
                        token.ThrowIfCancellationRequested();
                        Quality objQuality = new Quality(this);
                        try
                        {
                            if (i == 0 && xmlOldQuality.TryGetField("guid", Guid.TryParse, out Guid guidOld))
                            {
                                await ImprovementManager.RemoveImprovementsAsync(this, Improvement.ImprovementSource.Quality,
                                    guidOld.ToString(), token).ConfigureAwait(false);
                                objQuality.SetGUID(guidOld);
                            }

                            QualitySource objQualitySource =
                                Quality.ConvertToQualitySource(xmlOldQuality["qualitysource"]?.InnerTextViaPool(token));
                            await objQuality.CreateAsync(xmlNewQuality, objQualitySource, _lstWeapons,
                                xmlOldQuality["extra"]?.InnerTextViaPool(token), token: token).ConfigureAwait(false);
                            if (xmlOldQuality["bp"] != null
                                && int.TryParse(xmlOldQuality["bp"].InnerTextViaPool(token), out int intOldBP))
                                await objQuality.SetBPAsync(intOldBP / intRanks, token).ConfigureAwait(false);

                            await Qualities.AddAsync(objQuality, token).ConfigureAwait(false);
                        }
                        catch
                        {
                            await objQuality.DeleteQualityAsync(token: CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }

                return true;
            }

            return false;
        }

        #endregion Old Quality Conversion Code

        #region Temporary Properties : Dashboard

        // This region is for properties that are applicable to the Dashboard
        /// <summary>
        /// The Current Initiative roll result including base Initiative
        /// <note>Dashboard</note>
        /// </summary>
        public int InitRoll { get; set; }

        /// <summary>
        /// The Initiative Passes that the player has
        /// <note>Dashboard</note>
        /// </summary>
        public int InitPasses
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    Interlocked.CompareExchange(ref _intInitPasses, InitiativeDice, int.MinValue);
                    return _intInitPasses;
                }
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _intInitPasses, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        private int _intInitPasses = int.MinValue;

        /// <summary>
        /// True iff the character is currently delaying an action
        /// <note>Dashboard</note>
        /// </summary>
        public bool Delayed { get; set; }

        /// <summary>
        /// The current name and initiative of the character
        /// </summary>
        public string DisplayInit
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return Name + " : " + InitRoll.ToString(GlobalSettings.CultureInfo);
            }
        }

        /// <summary>
        /// The initial Initiative of the character
        /// <note>Dashboard</note>
        /// </summary>
        public int InitialInit { get; set; }

        #endregion Temporary Properties : Dashboard

        //Can't be at improvementmanager due reasons
        private readonly Lazy<ConcurrentStack<string>> _stkPushText = new Lazy<ConcurrentStack<string>>();
        
        // Enhanced PushText system for quality group filtering
        private readonly Lazy<ConcurrentDictionary<string, ConcurrentStack<string>>> _dicQualityGroupPushText = 
            new Lazy<ConcurrentDictionary<string, ConcurrentStack<string>>>();
        
        // Store multiple instances of qualities for the same level
        private readonly Lazy<ConcurrentDictionary<string, ConcurrentDictionary<int, List<string>>>> _dicQualityGroupInstances = 
            new Lazy<ConcurrentDictionary<string, ConcurrentDictionary<int, List<string>>>>();

        /// <summary>
        /// Push a value that will be used instead of dialog instead in next <selecttext />
        /// </summary>
        public ConcurrentStack<string> PushText
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _stkPushText.Value;
            }
        }

        /// <summary>
        /// Push a value that will be used instead of dialog instead in next <selecttext />
        /// </summary>
        public async Task<ConcurrentStack<string>> GetPushTextAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _stkPushText.Value;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Push a value for a specific quality group that will be used instead of dialog in next <selecttext />
        /// </summary>
        public void PushTextForQualityGroup(string strQualityGroup, string strText)
        {
            if (string.IsNullOrEmpty(strQualityGroup) || string.IsNullOrEmpty(strText))
                return;
                
            using (LockObject.EnterReadLock())
            {
                ConcurrentStack<string> stkPushText = _dicQualityGroupPushText.Value.GetOrAdd(strQualityGroup, 
                    _ => new ConcurrentStack<string>());
                stkPushText.Push(strText);
            }
        }

        /// <summary>
        /// Push a value for a specific quality group that will be used instead of dialog in next <selecttext />
        /// </summary>
        public async Task PushTextForQualityGroupAsync(string strQualityGroup, string strText, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (string.IsNullOrEmpty(strQualityGroup) || string.IsNullOrEmpty(strText))
                return;

            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                ConcurrentStack<string> stkPushText = _dicQualityGroupPushText.Value.GetOrAdd(strQualityGroup,
                    _ => new ConcurrentStack<string>());
                stkPushText.Push(strText);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Get the push text stack for a specific quality group
        /// </summary>
        public async Task<ConcurrentStack<string>> GetPushTextForQualityGroupAsync(string strQualityGroup, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _dicQualityGroupPushText.Value.GetOrAdd(strQualityGroup, 
                    _ => new ConcurrentStack<string>());
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Try to pop text for a specific quality group
        /// </summary>
        public bool TryPopTextForQualityGroup(string strQualityGroup, out string strText)
        {
            strText = null;
            if (string.IsNullOrEmpty(strQualityGroup))
                return false;
                
            using (LockObject.EnterReadLock())
            {
                if (_dicQualityGroupPushText.Value.TryGetValue(strQualityGroup, out ConcurrentStack<string> stkPushText))
                {
                    return stkPushText.TryPop(out strText);
                }
            }
            return false;
        }

        /// <summary>
        /// Store an instance of a quality for a specific group and level
        /// </summary>
        public void StoreQualityInstance(string strQualityGroup, int intLevel, string strInstanceText)
        {
            if (string.IsNullOrEmpty(strQualityGroup) || string.IsNullOrEmpty(strInstanceText))
                return;
                
            using (LockObject.EnterReadLock())
            {
                ConcurrentDictionary<int, List<string>> dicLevels = _dicQualityGroupInstances.Value.GetOrAdd(strQualityGroup, 
                    _ => new ConcurrentDictionary<int, List<string>>());
                List<string> lstInstances = dicLevels.GetOrAdd(intLevel, _ => new List<string>());
                
                if (!lstInstances.Contains(strInstanceText))
                {
                    lstInstances.Add(strInstanceText);
                }
            }
        }

        /// <summary>
        /// Get all instances for a specific quality group and level
        /// </summary>
        public List<string> GetQualityInstances(string strQualityGroup, int intLevel)
        {
            if (string.IsNullOrEmpty(strQualityGroup))
                return new List<string>();
                
            using (LockObject.EnterReadLock())
            {
                if (_dicQualityGroupInstances.Value.TryGetValue(strQualityGroup, out ConcurrentDictionary<int, List<string>> dicLevels))
                {
                    if (dicLevels.TryGetValue(intLevel, out List<string> lstInstances))
                    {
                        return new List<string>(lstInstances);
                    }
                }
            }
            return new List<string>();
        }

        /// <summary>
        /// Clear all instances for a specific quality group and level
        /// </summary>
        public void ClearQualityInstances(string strQualityGroup, int intLevel)
        {
            if (string.IsNullOrEmpty(strQualityGroup))
                return;
                
            using (LockObject.EnterReadLock())
            {
                if (_dicQualityGroupInstances.Value.TryGetValue(strQualityGroup, out ConcurrentDictionary<int, List<string>> dicLevels))
                {
                    dicLevels.TryRemove(intLevel, out _);
                }
            }
        }

        private IHasMatrixAttributes _objActiveCommlink;

        /// <summary>
        /// The Active Commlink of the character. Returns null if character has no active commlink.
        /// </summary>
        public IHasMatrixAttributes ActiveCommlink
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _objActiveCommlink;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _objActiveCommlink, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// The Active Commlink of the character. Returns null if character has no active commlink.
        /// </summary>
        public async Task<IHasMatrixAttributes> GetActiveCommlinkAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _objActiveCommlink;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// The Active Commlink of the character. Returns null if character has no active commlink.
        /// </summary>
        public async Task SetActiveCommlinkAsync(IHasMatrixAttributes value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _objActiveCommlink, value) == value)
                    return;
                await OnPropertyChangedAsync(nameof(ActiveCommlink), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private IHasMatrixAttributes _objHomeNode;

        /// <summary>
        /// Home Node. Returns null if home node is not set to any item.
        /// </summary>
        public IHasMatrixAttributes HomeNode
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _objHomeNode;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _objHomeNode, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Home Node. Returns null if home node is not set to any item.
        /// </summary>
        public async Task<IHasMatrixAttributes> GetHomeNodeAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _objHomeNode;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Home Node. Returns null if home node is not set to any item.
        /// </summary>
        public async Task SetHomeNodeAsync(IHasMatrixAttributes value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (Interlocked.Exchange(ref _objHomeNode, value) == value)
                    return;
                await OnPropertyChangedAsync(nameof(HomeNode), token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        [HubTag]
        public SkillsSection SkillsSection
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _objSkillsSection;
            }
        }

        public async Task<SkillsSection> GetSkillsSectionAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _objSkillsSection;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public int RedlinerBonus
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (_intCachedRedlinerBonus == int.MinValue)
                    {
                        List<string> lstSeekerAttributes = ImprovementManager
                            .GetCachedImprovementListForValueOf(
                                this, Improvement.ImprovementType.Seeker)
                            .ConvertAll(objImprovement => objImprovement.ImprovedName);
                        lstSeekerAttributes.RemoveAll(x =>
                            x != "BOX" && !AttributeSection.AttributeStrings.Contains(x));
                        //if neither contains anything, it is safe to exit
                        if (lstSeekerAttributes.Count == 0)
                        {
                            return _intCachedRedlinerBonus = 0;
                        }

                        //Calculate bonus from cyberlimbs
                        int intCount = Math.Min(Cyberware.Sum(x => x.GetCyberlimbCount(Settings.RedlinerExcludes)) / 2,
                            2);

                        return _intCachedRedlinerBonus = lstSeekerAttributes.Exists(x => x == "STR" || x == "AGI")
                            ? intCount
                            : 0;
                    }

                    return _intCachedRedlinerBonus;
                }
            }
        }

        public async Task<int> GetRedlinerBonusAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_intCachedRedlinerBonus == int.MinValue)
                {
                    List<string> lstSeekerAttributes = (await ImprovementManager
                            .GetCachedImprovementListForValueOfAsync(
                                this, Improvement.ImprovementType.Seeker, token: token).ConfigureAwait(false))
                        .ConvertAll(objImprovement => objImprovement.ImprovedName);
                    lstSeekerAttributes.RemoveAll(x => x != "BOX" && !AttributeSection.AttributeStrings.Contains(x));
                    //if neither contains anything, it is safe to exit
                    if (lstSeekerAttributes.Count == 0)
                    {
                        return _intCachedRedlinerBonus = 0;
                    }

                    //Calculate bonus from cyberlimbs
                    int intCount =
                        Math.Min(
                            await Cyberware.SumAsync(x => x.GetCyberlimbCountAsync(Settings.RedlinerExcludes, token),
                                token: token).ConfigureAwait(false) / 2, 2);

                    return _intCachedRedlinerBonus = lstSeekerAttributes.Exists(x => x == "STR" || x == "AGI")
                        ? intCount
                        : 0;
                }

                return _intCachedRedlinerBonus;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private bool RefreshRedlinerImprovements(CancellationToken token = default)
        {
            if (IsLoading) // If we are in the middle of loading, just queue a single refresh to happen at the end of the process
            {
                EnqueuePostLoadMethod(RefreshRedlinerImprovements, token);
                return true;
            }

            using (LockObject.EnterUpgradeableReadLock(token))
            {
                //Get attributes affected by redliner/cyber singularity seeker
                List<Improvement> lstSeekerImprovements = new List<Improvement>(Improvements.Count);
                List<string> lstSeekerAttributes = new List<string>(AttributeSection.AttributeStrings.Count);
                bool blnCreated = Created;
                Improvements.ForEach(objImprovement =>
                {
                    if (objImprovement.ImproveType == Improvement.ImprovementType.Attribute
                        || objImprovement.ImproveType == Improvement.ImprovementType.PhysicalCM)
                    {
                        if (objImprovement.SourceName.Contains("SEEKER"))
                            lstSeekerImprovements.Add(objImprovement);
                    }
                    else if (objImprovement.ImproveType == Improvement.ImprovementType.Seeker
                             && objImprovement.Enabled
                             && (string.IsNullOrEmpty(objImprovement.Condition)
                                 || (objImprovement.Condition == "career") == blnCreated
                                 || (objImprovement.Condition == "create") != blnCreated))
                    {
                        string strImprovedName = objImprovement.ImprovedName;
                        if (strImprovedName == "BOX" || AttributeSection.AttributeStrings.Contains(strImprovedName))
                            lstSeekerAttributes.Add(strImprovedName);
                    }
                }, token);
                //if neither contains anything, it is safe to exit
                if (lstSeekerImprovements.Count == 0 && lstSeekerAttributes.Count == 0)
                {
                    if (_intCachedRedlinerBonus != 0)
                    {
                        using (LockObject.EnterWriteLock(token))
                            _intCachedRedlinerBonus = 0;
                    }

                    return true;
                }

                bool blnDoHasRedliner = lstSeekerAttributes.Exists(x => x == "STR" || x == "AGI");

                //Calculate bonus from cyberlimbs
                int intCount = Math.Min(Cyberware.Sum(x => x.GetCyberlimbCount(Settings.RedlinerExcludes)) / 2, 2);

                for (int i = lstSeekerAttributes.Count - 1; i >= 0; --i)
                {
                    string strSeekerAttribute = "SEEKER_" + lstSeekerAttributes[i];
                    int intCountToTarget = strSeekerAttribute == "SEEKER_BOX" ? intCount * -3 : intCount;
                    Improvement objImprovement
                        = lstSeekerImprovements.Find(x => x.SourceName == strSeekerAttribute
                                                          && x.Value == intCountToTarget
                                                          && x.Enabled);
                    if (objImprovement != null)
                    {
                        lstSeekerAttributes.RemoveAt(i);
                        lstSeekerImprovements.Remove(objImprovement);
                    }
                }

                if (lstSeekerImprovements.Count == 0 && lstSeekerAttributes.Count == 0)
                {
                    int intNewCachedValue = blnDoHasRedliner ? intCount : 0;
                    if (_intCachedRedlinerBonus != intNewCachedValue)
                    {
                        using (LockObject.EnterWriteLock(token))
                            _intCachedRedlinerBonus = intNewCachedValue;
                    }
                    return true;
                }

                using (LockObject.EnterWriteLock(token))
                {
                    _intCachedRedlinerBonus = blnDoHasRedliner ? intCount : 0;

                    //Improvement manager defines the functions needed to manipulate improvements
                    //When the locals (someday) gets moved to this class, this can be removed and use
                    //the local

                    // Remove which qualities have been removed or which values have changed
                    ImprovementManager.RemoveImprovements(this, lstSeekerImprovements, token: token);

                    try
                    {
                        token.ThrowIfCancellationRequested();
                        // Add new improvements or old improvements with new values
                        foreach (string strAttribute in lstSeekerAttributes)
                        {
                            if (strAttribute == "BOX")
                            {
                                ImprovementManager.CreateImprovement(this, strAttribute,
                                    Improvement.ImprovementSource.Quality,
                                    "SEEKER_BOX",
                                    Improvement.ImprovementType.PhysicalCM,
                                    Guid.NewGuid()
                                        .ToString(
                                            "D", GlobalSettings.InvariantCultureInfo),
                                    intCount * -3, token: token);
                            }
                            else
                            {
                                ImprovementManager.CreateImprovement(this, strAttribute,
                                    Improvement.ImprovementSource.Quality,
                                    "SEEKER_" + strAttribute,
                                    Improvement.ImprovementType.Attribute,
                                    Guid.NewGuid()
                                        .ToString(
                                            "D", GlobalSettings.InvariantCultureInfo),
                                    intCount, 1, 0, 0,
                                    intCount, token: token);
                            }
                        }
                    }
                    catch
                    {
                        ImprovementManager.Rollback(this, CancellationToken.None);
                        throw;
                    }

                    ImprovementManager.Commit(this, token);
                    return true;
                }
            }
        }

        private async Task<bool> RefreshRedlinerImprovementsAsync(CancellationToken token = default)
        {
            if (IsLoading) // If we are in the middle of loading, just queue a single refresh to happen at the end of the process
            {
                await EnqueuePostLoadAsyncMethodAsync(RefreshRedlinerImprovementsAsync, token).ConfigureAwait(false);
                return true;
            }
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();

                //Get attributes affected by redliner/cyber singularity seeker
                List<Improvement> lstSeekerImprovements = new List<Improvement>(Improvements.Count);
                List<string> lstSeekerAttributes = new List<string>(AttributeSection.AttributeStrings.Count);
                bool blnCreated = await GetCreatedAsync(token).ConfigureAwait(false);
                await Improvements.ForEachAsync(objImprovement =>
                {
                    if (objImprovement.ImproveType == Improvement.ImprovementType.Attribute
                        || objImprovement.ImproveType == Improvement.ImprovementType.PhysicalCM)
                    {
                        if (objImprovement.SourceName.Contains("SEEKER"))
                            lstSeekerImprovements.Add(objImprovement);
                    }
                    else if (objImprovement.ImproveType == Improvement.ImprovementType.Seeker
                             && objImprovement.Enabled
                             && (string.IsNullOrEmpty(objImprovement.Condition)
                                 || (objImprovement.Condition == "career") == blnCreated
                                 || (objImprovement.Condition == "create") != blnCreated))
                    {
                        string strImprovedName = objImprovement.ImprovedName;
                        if (strImprovedName == "BOX" || AttributeSection.AttributeStrings.Contains(strImprovedName))
                            lstSeekerAttributes.Add(strImprovedName);
                    }
                }, token).ConfigureAwait(false);
                //if neither contains anything, it is safe to exit
                if (lstSeekerImprovements.Count == 0 && lstSeekerAttributes.Count == 0)
                {
                    if (_intCachedRedlinerBonus != 0)
                    {
                        IAsyncDisposable objLocker3 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                        try
                        {
                            token.ThrowIfCancellationRequested();
                            _intCachedRedlinerBonus = 0;
                        }
                        finally
                        {
                            await objLocker3.DisposeAsync().ConfigureAwait(false);
                        }
                    }

                    return true;
                }

                bool blnDoHasRedliner = lstSeekerAttributes.Exists(x => x == "STR" || x == "AGI");

                //Calculate bonus from cyberlimbs
                int intCount =
                    Math.Min(
                        await Cyberware.SumAsync(x => x.GetCyberlimbCountAsync(Settings.RedlinerExcludes, token), token)
                            .ConfigureAwait(false) / 2, 2);

                for (int i = lstSeekerAttributes.Count - 1; i >= 0; --i)
                {
                    string strSeekerAttribute = "SEEKER_" + lstSeekerAttributes[i];
                    int intCountToTarget = strSeekerAttribute == "SEEKER_BOX" ? intCount * -3 : intCount;
                    Improvement objImprovement
                        = lstSeekerImprovements.Find(x => x.SourceName == strSeekerAttribute
                                                          && x.Value == intCountToTarget
                                                          && x.Enabled);
                    if (objImprovement != null)
                    {
                        lstSeekerAttributes.RemoveAt(i);
                        lstSeekerImprovements.Remove(objImprovement);
                    }
                }

                if (lstSeekerImprovements.Count == 0 && lstSeekerAttributes.Count == 0)
                {
                    int intNewCachedValue = blnDoHasRedliner ? intCount : 0;
                    if (_intCachedRedlinerBonus != intNewCachedValue)
                    {
                        IAsyncDisposable objLocker3 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                        try
                        {
                            token.ThrowIfCancellationRequested();
                            _intCachedRedlinerBonus = intNewCachedValue;
                        }
                        finally
                        {
                            await objLocker3.DisposeAsync().ConfigureAwait(false);
                        }
                    }

                    return true;
                }

                IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    _intCachedRedlinerBonus = blnDoHasRedliner ? intCount : 0;

                    //Improvement manager defines the functions needed to manipulate improvements
                    //When the locals (someday) gets moved to this class, this can be removed and use
                    //the local

                    // Remove which qualities have been removed or which values have changed
                    await ImprovementManager.RemoveImprovementsAsync(this, lstSeekerImprovements, token: token)
                        .ConfigureAwait(false);

                    try
                    {
                        token.ThrowIfCancellationRequested();
                        // Add new improvements or old improvements with new values
                        foreach (string strAttribute in lstSeekerAttributes)
                        {
                            if (strAttribute == "BOX")
                            {
                                await ImprovementManager.CreateImprovementAsync(this, strAttribute,
                                    Improvement.ImprovementSource.Quality,
                                    "SEEKER_BOX",
                                    Improvement.ImprovementType.PhysicalCM,
                                    Guid.NewGuid()
                                        .ToString(
                                            "D", GlobalSettings.InvariantCultureInfo),
                                    intCount * -3, token: token).ConfigureAwait(false);
                            }
                            else
                            {
                                await ImprovementManager.CreateImprovementAsync(this, strAttribute,
                                    Improvement.ImprovementSource.Quality,
                                    "SEEKER_" + strAttribute,
                                    Improvement.ImprovementType.Attribute,
                                    Guid.NewGuid()
                                        .ToString(
                                            "D", GlobalSettings.InvariantCultureInfo),
                                    intCount, 1, 0, 0,
                                    intCount, token: token).ConfigureAwait(false);
                            }
                        }
                    }
                    catch
                    {
                        await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                        throw;
                    }

                    await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);

                    return true;
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public void RefreshEssenceLossImprovements(CancellationToken token = default)
        {
            // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
            if (IsLoading)
                return;
            using (LockObject.EnterUpgradeableReadLock(token))
            {
                // Only worry about essence loss attribute modifiers if this character actually has any attributes that would be affected by essence loss
                // (which means EssenceAtSpecialStart is not set to decimal.MinValue)
                if (EssenceAtSpecialStart != decimal.MinValue)
                {
                    decimal decSpecialAttBurnMultiplier = 1.0m;
                    decimal decTotalSpecialAttBurnMultiplier = 1.0m;
                    List<Improvement> lstUsedImprovements =
                        ImprovementManager.GetCachedImprovementListForValueOf(
                            this, Improvement.ImprovementType.SpecialAttBurn, token: token);
                    if (lstUsedImprovements.Count != 0)
                    {
                        foreach (Improvement objImprovement in lstUsedImprovements)
                            decSpecialAttBurnMultiplier -= 1m - objImprovement.Value / 100m;
                    }

                    List<Improvement> lstUsedImprovements2 =
                        ImprovementManager.GetCachedImprovementListForValueOf(
                            this, Improvement.ImprovementType.SpecialAttTotalBurnMultiplier, token: token);
                    if (lstUsedImprovements2.Count != 0)
                    {
                        foreach (Improvement objImprovement in lstUsedImprovements2)
                            decTotalSpecialAttBurnMultiplier *= objImprovement.Value / 100m;
                    }

                    decimal decESSMag = Essence(true, "MAG", token);
                    decimal decESSRes = Essence(true, "RES", token);
                    decimal decESSDep = Essence(true, "DEP", token);
                    if (!Settings.DontRoundEssenceInternally)
                    {
                        int intESSDecimals = Settings.EssenceDecimals;
                        decESSMag = decimal.Round(decESSMag, intESSDecimals, MidpointRounding.AwayFromZero);
                        decESSRes = decimal.Round(decESSRes, intESSDecimals, MidpointRounding.AwayFromZero);
                        decESSDep = decimal.Round(decESSDep, intESSDecimals, MidpointRounding.AwayFromZero);
                    }

                    // Reduce a character's MAG and RES from Essence Loss.
                    decimal decMetatypeMaximumESS = ESS.MetatypeMaximum;
                    int intMagMaxReduction
                        = ((decMetatypeMaximumESS - decESSMag) * decSpecialAttBurnMultiplier
                                                               * decTotalSpecialAttBurnMultiplier).StandardRound();
                    int intResMaxReduction
                        = ((decMetatypeMaximumESS - decESSRes) * decSpecialAttBurnMultiplier
                                                               * decTotalSpecialAttBurnMultiplier).StandardRound();
                    int intDepMaxReduction
                        = ((decMetatypeMaximumESS - decESSDep) * decSpecialAttBurnMultiplier
                                                               * decTotalSpecialAttBurnMultiplier).StandardRound();
                    // Character has the option set where essence loss just acts as an augmented malus, so just replace old essence loss improvements with new ones that apply an augmented malus
                    // equal to the amount by which the attribute's maximum would normally be reduced.
                    if (Settings.SpecialKarmaCostBasedOnShownValue)
                    {
                        Improvement.ImprovementSource eEssenceLossSource = Created
                            ? Improvement.ImprovementSource.EssenceLoss
                            : Improvement.ImprovementSource.EssenceLossChargen;
                        using (LockObject.EnterWriteLock(token))
                        {
                            using (TemporaryArray<Improvement.ImprovementSource> aParams = new TemporaryArray<Improvement.ImprovementSource>(
                                Improvement.ImprovementSource.EssenceLossChargen, Improvement.ImprovementSource.EssenceLoss,
                                // With this house rule, Cyberadept Daemon just negates a penalty from Essence based on Grade instead of restoring Resonance, so delete all old improvements
                                Improvement.ImprovementSource.CyberadeptDaemon))
                            {
                                ImprovementManager.RemoveImprovements(this, aParams, token: token);
                            }
                            try
                            {
                                token.ThrowIfCancellationRequested();
                                if (intMagMaxReduction != 0)
                                {
                                    ImprovementManager.CreateImprovement(this, "MAG", eEssenceLossSource, string.Empty,
                                                                         Improvement.ImprovementType.Attribute,
                                                                         string.Empty, 0,
                                                                         1, 0, 0, -intMagMaxReduction, token: token);
                                    ImprovementManager.CreateImprovement(
                                        this, "MAGAdept", eEssenceLossSource, string.Empty,
                                        Improvement.ImprovementType.Attribute,
                                        string.Empty, 0,
                                        1, 0, 0, -intMagMaxReduction, token: token);
                                    // If this is a Mystic Adept using special Mystic Adept PP rules (i.e. no second MAG attribute), Mystic Adepts lose PPs even if they have fewer PPs than their MAG
                                    if (UseMysticAdeptPPs)
                                        ImprovementManager.CreateImprovement(this, string.Empty, eEssenceLossSource,
                                                                             string.Empty,
                                                                             Improvement.ImprovementType
                                                                                 .AdeptPowerPoints,
                                                                             string.Empty, -intMagMaxReduction,
                                                                             token: token);
                                }

                                if (intResMaxReduction != 0)
                                {
                                    int intRESReduction = intResMaxReduction;
                                    if (TechnomancerEnabled && SubmersionGrade > 0 && ImprovementManager
                                            .GetCachedImprovementListForValueOf(this,
                                                Improvement.ImprovementType
                                                           .CyberadeptDaemon, token: token)
                                            .Count > 0)
                                    {
                                        decimal decNonCyberwareEssence = BiowareEssence + EssenceHole;
                                        int intMaxCyberadeptDaemonBonus = Math.Ceiling(decNonCyberwareEssence) ==
                                                                          Math.Floor(decNonCyberwareEssence)
                                            ? (int)Math.Ceiling(CyberwareEssence)
                                            : (int)Math.Floor(CyberwareEssence);
                                        int intCyberadeptDaemonBonus = 0;
                                        for (int i = 1; i <= SubmersionGrade; ++i)
                                        {
                                            intCyberadeptDaemonBonus += i.DivAwayFromZero(2);
                                        }

                                        intRESReduction
                                            -= Math.Min(intCyberadeptDaemonBonus, intMaxCyberadeptDaemonBonus);
                                        if (intRESReduction < 0)
                                            intRESReduction = 0;
                                    }

                                    if (intRESReduction != 0)
                                        ImprovementManager.CreateImprovement(
                                            this, "RES", eEssenceLossSource, string.Empty,
                                            Improvement.ImprovementType.Attribute,
                                            string.Empty, 0, 1, 0, 0, -intRESReduction, token: token);
                                }

                                if (intDepMaxReduction != 0)
                                {
                                    ImprovementManager.CreateImprovement(this, "DEP", eEssenceLossSource, string.Empty,
                                                                         Improvement.ImprovementType.Attribute,
                                                                         string.Empty, 0,
                                                                         1, 0, 0, -intDepMaxReduction, token: token);
                                }
                            }
                            catch
                            {
                                ImprovementManager.Rollback(this, CancellationToken.None);
                                throw;
                            }

                            if (intMagMaxReduction != 0 || intResMaxReduction != 0 || intDepMaxReduction != 0)
                                ImprovementManager.Commit(this, token);
                        }
                    }
                    // RAW Career mode: complicated. Similar to RAW Create mode, but with the extra possibility of burning current karma levels and/or PPs instead of pure minima reduction,
                    // plus the need to account for cases where a character will burn "past" 0 (i.e. to a current value that should be negative), but then upgrade to 1 afterwards.
                    else if (Created)
                    {
                        // "Base" minimum reduction. This is the amount by which the character's special attribute minima would be reduced across career and create modes if there wasn't any funny business
                        int intMagMinReduction
                            = ((EssenceAtSpecialStart - decESSMag) * decSpecialAttBurnMultiplier
                                                                   * decTotalSpecialAttBurnMultiplier)
                            .StandardRound();
                        int intResMinReduction
                            = ((EssenceAtSpecialStart - decESSRes) * decSpecialAttBurnMultiplier
                                                                   * decTotalSpecialAttBurnMultiplier)
                            .StandardRound();
                        int intDepMinReduction
                            = ((EssenceAtSpecialStart - decESSDep) * decSpecialAttBurnMultiplier
                                                                   * decTotalSpecialAttBurnMultiplier)
                            .StandardRound();

                        // This extra code is needed for legacy shims, to convert proper attribute values for characters who would end up having a higher level than their total attribute maxima
                        // They are extra amounts by which the relevant attributes' karma levels should be burned
                        int intExtraRESBurn = Math.Max(0,
                                                       Math.Max(
                                                           RES.Base + RES.FreeBase + RES.RawMinimum
                                                           + RES.AttributeValueModifiers,
                                                           RES.TotalMinimum) + RES.Karma - RES.TotalMaximum);
                        int intExtraDEPBurn = Math.Max(0,
                                                       Math.Max(
                                                           DEP.Base + DEP.FreeBase + DEP.RawMinimum
                                                           + DEP.AttributeValueModifiers,
                                                           DEP.TotalMinimum) + DEP.Karma - DEP.TotalMaximum);
                        int intExtraMAGBurn = Math.Max(0,
                                                       Math.Max(
                                                           MAG.Base + MAG.FreeBase + MAG.RawMinimum
                                                           + MAG.AttributeValueModifiers,
                                                           MAG.TotalMinimum) + MAG.Karma - MAG.TotalMaximum);
                        int intExtraMAGAdeptBurn = Math.Max(0,
                                                            Math.Max(
                                                                MAGAdept.Base + MAGAdept.FreeBase
                                                                              + MAGAdept.RawMinimum +
                                                                              MAGAdept.AttributeValueModifiers,
                                                                MAGAdept.TotalMinimum) + MAGAdept.Karma
                                                            - MAGAdept.TotalMaximum);
                        // Old values for minimum reduction from essence loss in career mode. These are used to determine if any karma needs to get burned.
                        int intOldRESCareerMinimumReduction = 0;
                        int intOldDEPCareerMinimumReduction = 0;
                        int intOldMAGCareerMinimumReduction = 0;
                        int intOldMAGAdeptCareerMinimumReduction = 0;
                        foreach (Improvement objImprovement in
                                 ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.Attribute, token: token))
                        {
                            if (objImprovement.ImproveSource == Improvement.ImprovementSource.EssenceLoss)
                            {
                                // Values get subtracted because negative modifier = positive reduction, positive modifier = negative reduction
                                // Augmented values also get factored in in case the character is switching off the option to treat essence loss as an augmented malus
                                switch (objImprovement.ImprovedName.ToUpperInvariant())
                                {
                                    case "RES":
                                        intOldRESCareerMinimumReduction -=
                                            objImprovement.Minimum + objImprovement.Augmented.StandardRound();
                                        break;

                                    case "DEP":
                                        intOldDEPCareerMinimumReduction -=
                                            objImprovement.Minimum + objImprovement.Augmented.StandardRound();
                                        break;

                                    case "MAG":
                                        intOldMAGCareerMinimumReduction -=
                                            objImprovement.Minimum + objImprovement.Augmented.StandardRound();
                                        break;

                                    case "MAGADEPT":
                                        intOldMAGAdeptCareerMinimumReduction -=
                                            objImprovement.Minimum + objImprovement.Augmented.StandardRound();
                                        break;
                                }
                            }
                        }

                        using (LockObject.EnterWriteLock(token))
                        {
                            // Remove any Improvements from MAG, RES, and DEP from Essence Loss that were added in career.
                            ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.EssenceLoss, token: token);

                            // Career Minimum and Maximum reduction relies on whether there's any extra reduction since chargen.
                            // This is the step where create mode attribute loss regarding attribute maximum loss gets factored out.
                            int intMAGMaximumReduction
                                = intMagMaxReduction + MAG.TotalMaximum - MAG.MaximumNoEssenceLoss();
                            int intMAGAdeptMaximumReduction = intMagMaxReduction + MAGAdept.TotalMaximum
                                                              - MAGAdept.MaximumNoEssenceLoss();
                            int intRESMaximumReduction
                                = intResMaxReduction + RES.TotalMaximum - RES.MaximumNoEssenceLoss();
                            int intDEPMaximumReduction
                                = intDepMaxReduction + DEP.TotalMaximum - DEP.MaximumNoEssenceLoss();

                            if (intMagMaxReduction > 0
                                || intMagMinReduction > 0
                                || intMAGMaximumReduction != 0
                                || intMAGAdeptMaximumReduction != 0)
                            {
                                // This is the step where create mode attribute loss regarding attribute minimum loss gets factored out.
                                int intMAGMinimumReduction;
                                int intMAGAdeptMinimumReduction;
                                // If only maxima would be reduced, use the attribute's current total value instead of its current maximum, as this makes sure minima will only get reduced if the maximum reduction would eat into the current value
                                if (Settings.ESSLossReducesMaximumOnly)
                                {
                                    intMAGMinimumReduction = Math.Max(0,
                                                                      intMagMinReduction + MAG.TotalValue
                                                                      - MAG.MaximumNoEssenceLoss(true));
                                    intMAGAdeptMinimumReduction = Math.Max(0,
                                                                           intMagMinReduction + MAGAdept.TotalValue
                                                                           - MAGAdept.MaximumNoEssenceLoss(true));
                                }
                                else
                                {
                                    intMAGMinimumReduction =
                                        intMagMinReduction + MAG.TotalMaximum - MAG.MaximumNoEssenceLoss(true);
                                    intMAGAdeptMinimumReduction =
                                        intMagMinReduction + MAGAdept.TotalMaximum
                                        - MAGAdept.MaximumNoEssenceLoss(true);
                                }

                                // If the new MAG reduction is greater than the old one...
                                int intMAGMinimumReductionDelta
                                    = intMAGMinimumReduction - intOldMAGCareerMinimumReduction;
                                if (intMAGMinimumReductionDelta > 0)
                                {
                                    // ... and adding minimum reducing-improvements wouldn't do anything, start burning karma.
                                    if (intMAGMinimumReduction >
                                        MAG.Base + MAG.FreeBase + MAG.RawMinimum + MAG.AttributeValueModifiers)
                                    {
                                        // intMAGMinimumReduction is not actually reduced so that karma doesn't get burned away each time this function is called.
                                        // Besides, this only fires if intMAGMinimumReduction is already at a level where increasing it any more wouldn't have any effect on the character.
                                        intExtraMAGBurn += Math.Min(MAG.Karma, intMAGMinimumReductionDelta);
                                        MAG.Karma -= intExtraMAGBurn;
                                    }

                                    // Mystic Adept PPs may need to be burned away based on the change of our MAG attribute
                                    if (UseMysticAdeptPPs)
                                    {
                                        // First burn away PPs gained during chargen...
                                        int intChargenPPBurn =
                                            Math.Min(MysticAdeptPowerPoints, intMAGMinimumReductionDelta);
                                        MysticAdeptPowerPoints -= intChargenPPBurn;
                                        // ... now burn away PPs gained from initiations.
                                        decimal decPPBurn = Math.Min(intMAGMinimumReductionDelta - intChargenPPBurn,
                                                                     ImprovementManager.ValueOf(
                                                                         this,
                                                                         Improvement.ImprovementType.AdeptPowerPoints, token: token));
                                        // Source needs to be EssenceLossChargen so that it doesn't get wiped in career mode.
                                        if (decPPBurn != 0)
                                        {
                                            try
                                            {
                                                token.ThrowIfCancellationRequested();
                                                ImprovementManager.CreateImprovement(this, string.Empty,
                                                    Improvement.ImprovementSource
                                                               .EssenceLossChargen, string.Empty,
                                                    Improvement.ImprovementType
                                                               .AdeptPowerPoints, string.Empty,
                                                    -decPPBurn, token: token);
                                            }
                                            catch
                                            {
                                                ImprovementManager.Rollback(this, CancellationToken.None);
                                                throw;
                                            }

                                            ImprovementManager.Commit(this, token);
                                        }
                                    }
                                }
                                // If the new MAG reduction is less than our old one, the character doesn't actually get any new values back
                                else
                                {
                                    intMAGMinimumReduction = intOldMAGCareerMinimumReduction;
                                }

                                // Make sure we only attempt to burn MAGAdept karma levels if it's actually a separate attribute from MAG
                                if (MAGAdept != MAG)
                                {
                                    // If the new MAGAdept reduction is greater than the old one...
                                    int intMAGAdeptMinimumReductionDelta =
                                        intMAGAdeptMinimumReduction - intOldMAGAdeptCareerMinimumReduction;
                                    if (intMAGAdeptMinimumReductionDelta > 0)
                                    {
                                        // ... and adding minimum reducing-improvements wouldn't do anything, start burning karma.
                                        if (intMAGAdeptMinimumReduction > MAGAdept.Base + MAGAdept.FreeBase +
                                            MAGAdept.RawMinimum + MAGAdept.AttributeValueModifiers)
                                        {
                                            // intMAGAdeptMinimumReduction is not actually reduced so that karma doesn't get burned away each time this function is called.
                                            // Besides, this only fires if intMAGAdeptMinimumReduction is already at a level where increasing it any more wouldn't have any effect on the character.
                                            intExtraMAGAdeptBurn += Math.Min(MAGAdept.Karma,
                                                                             intMAGAdeptMinimumReductionDelta);
                                            MAGAdept.Karma -= intExtraMAGAdeptBurn;
                                        }
                                    }
                                    // If the new MAGAdept reduction is less than our old one, the character doesn't actually get any new values back
                                    else
                                    {
                                        intMAGAdeptMinimumReduction = intOldMAGAdeptCareerMinimumReduction;
                                    }
                                }
                                // Otherwise make sure that if the new MAGAdept reduction is less than our old one, the character doesn't actually get any new values back
                                else if (intMAGAdeptMinimumReduction < intOldMAGAdeptCareerMinimumReduction)
                                {
                                    intMAGAdeptMinimumReduction = intOldMAGAdeptCareerMinimumReduction;
                                }

                                // Create Improvements
                                try
                                {
                                    token.ThrowIfCancellationRequested();
                                    if (intMAGMinimumReduction != 0 || intMAGMaximumReduction != 0)
                                        ImprovementManager.CreateImprovement(this, "MAG",
                                                                             Improvement.ImprovementSource.EssenceLoss,
                                                                             string.Empty,
                                                                             Improvement.ImprovementType.Attribute,
                                                                             string.Empty, 0, 1,
                                                                             -intMAGMinimumReduction,
                                                                             -intMAGMaximumReduction, token: token);
                                    if (intMAGAdeptMinimumReduction != 0 || intMAGAdeptMaximumReduction != 0)
                                        ImprovementManager.CreateImprovement(this, "MAGAdept",
                                                                             Improvement.ImprovementSource.EssenceLoss,
                                                                             string.Empty,
                                                                             Improvement.ImprovementType.Attribute,
                                                                             string.Empty, 0, 1,
                                                                             -intMAGAdeptMinimumReduction,
                                                                             -intMAGAdeptMaximumReduction,
                                                                             token: token);
                                }
                                catch
                                {
                                    ImprovementManager.Rollback(this, CancellationToken.None);
                                    throw;
                                }

                                if (intMAGMinimumReduction != 0 || intMAGMaximumReduction != 0 ||
                                    intMAGAdeptMinimumReduction != 0 || intMAGAdeptMaximumReduction != 0)
                                    ImprovementManager.Commit(this, token);
                            }

                            // Create the Essence Loss (or gain, in case of essence restoration and increasing maxima) Improvements.
                            if (intResMaxReduction > 0
                                || intResMinReduction > 0
                                || intRESMaximumReduction != 0)
                            {
                                // This is the step where create mode attribute loss regarding attribute minimum loss gets factored out.
                                int intRESMinimumReduction;
                                // If only maxima would be reduced, use the attribute's current total value instead of its current maximum, as this makes sure minima will only get reduced if the maximum reduction would eat into the current value
                                if (Settings.ESSLossReducesMaximumOnly)
                                {
                                    intRESMinimumReduction = Math.Max(0,
                                                                      intResMinReduction + RES.TotalValue
                                                                      - RES.MaximumNoEssenceLoss(true));
                                }
                                else
                                {
                                    intRESMinimumReduction =
                                        intResMinReduction + RES.TotalMaximum - RES.MaximumNoEssenceLoss(true);
                                }

                                // If the new RES reduction is greater than the old one...
                                int intRESMinimumReductionDelta
                                    = intRESMinimumReduction - intOldRESCareerMinimumReduction;
                                if (intRESMinimumReductionDelta > 0)
                                {
                                    // ... and adding minimum reducing-improvements wouldn't do anything, start burning karma.
                                    if (intRESMinimumReduction >
                                        RES.Base + RES.FreeBase + RES.RawMinimum + RES.AttributeValueModifiers)
                                    {
                                        // intRESMinimumReduction is not actually reduced so that karma doesn't get burned away each time this function is called.
                                        // Besides, this only fires if intRESMinimumReduction is already at a level where increasing it any more wouldn't have any effect on the character.
                                        intExtraRESBurn += Math.Min(RES.Karma, intRESMinimumReductionDelta);
                                        RES.Karma -= intExtraRESBurn;
                                    }
                                }
                                // If the new RES reduction is less than our old one, the character doesn't actually get any new values back
                                else
                                {
                                    intRESMinimumReduction = intOldRESCareerMinimumReduction;
                                }

                                // Create Improvements
                                if (intRESMinimumReduction != 0 || intRESMaximumReduction != 0)
                                {
                                    try
                                    {
                                        token.ThrowIfCancellationRequested();
                                        ImprovementManager.CreateImprovement(this, "RES",
                                                                             Improvement.ImprovementSource.EssenceLoss,
                                                                             string.Empty,
                                                                             Improvement.ImprovementType.Attribute,
                                                                             string.Empty, 0, 1,
                                                                             -intRESMinimumReduction,
                                                                             -intRESMaximumReduction, token: token);
                                    }
                                    catch
                                    {
                                        ImprovementManager.Rollback(this, CancellationToken.None);
                                        throw;
                                    }
                                    ImprovementManager.Commit(this, token);
                                }
                            }

                            if (intDepMaxReduction > 0
                                || intDepMinReduction > 0
                                || intDEPMaximumReduction != 0)
                            {
                                // This is the step where create mode attribute loss regarding attribute minimum loss gets factored out.
                                int intDEPMinimumReduction;
                                // If only maxima would be reduced, use the attribute's current total value instead of its current maximum, as this makes sure minima will only get reduced if the maximum reduction would eat into the current value
                                if (Settings.ESSLossReducesMaximumOnly)
                                {
                                    intDEPMinimumReduction = Math.Max(0,
                                                                      intDepMinReduction + DEP.TotalValue
                                                                      - DEP.MaximumNoEssenceLoss(true));
                                }
                                else
                                {
                                    intDEPMinimumReduction =
                                        intDepMinReduction + DEP.TotalMaximum - DEP.MaximumNoEssenceLoss(true);
                                }

                                // If the new DEP reduction is greater than the old one...
                                int intDEPMinimumReductionDelta
                                    = intDEPMinimumReduction - intOldDEPCareerMinimumReduction;
                                if (intDEPMinimumReductionDelta > 0)
                                {
                                    // ... and adding minimum reducing-improvements wouldn't do anything, start burning karma.
                                    if (intDEPMinimumReduction >
                                        DEP.Base + DEP.FreeBase + DEP.RawMinimum + DEP.AttributeValueModifiers)
                                    {
                                        // intDEPMinimumReduction is not actually reduced so that karma doesn't get burned away each time this function is called.
                                        // Besides, this only fires if intDEPMinimumReduction is already at a level where increasing it any more wouldn't have any effect on the character.
                                        intExtraDEPBurn += Math.Min(DEP.Karma, intDEPMinimumReductionDelta);
                                        DEP.Karma -= intExtraDEPBurn;
                                    }
                                }
                                // If the new DEP reduction is less than our old one, the character doesn't actually get any new values back
                                else
                                {
                                    intDEPMinimumReduction = intOldDEPCareerMinimumReduction;
                                }

                                // Create Improvements
                                if (intDEPMinimumReduction != 0 || intDEPMaximumReduction != 0)
                                {
                                    try
                                    {
                                        token.ThrowIfCancellationRequested();
                                        ImprovementManager.CreateImprovement(this, "DEP",
                                                                             Improvement.ImprovementSource.EssenceLoss,
                                                                             string.Empty,
                                                                             Improvement.ImprovementType.Attribute,
                                                                             string.Empty, 0, 1,
                                                                             -intDEPMinimumReduction,
                                                                             -intDEPMaximumReduction, token: token);
                                    }
                                    catch
                                    {
                                        ImprovementManager.Rollback(this, CancellationToken.None);
                                        throw;
                                    }

                                    ImprovementManager.Commit(this, token);
                                }
                            }
                        }
                    }
                    // RAW Create mode: Reduce maxima based on max ESS - current ESS, reduce minima based on their essence from the most optimal way in which they could have gotten access to special attributes
                    else
                    {
                        int intMagMinReduction
                            = ((EssenceAtSpecialStart - decESSMag) * decSpecialAttBurnMultiplier
                                                                   * decTotalSpecialAttBurnMultiplier)
                            .StandardRound();
                        int intResMinReduction
                            = ((EssenceAtSpecialStart - decESSRes) * decSpecialAttBurnMultiplier
                                                                   * decTotalSpecialAttBurnMultiplier)
                            .StandardRound();
                        int intDepMinReduction
                            = ((EssenceAtSpecialStart - decESSDep) * decSpecialAttBurnMultiplier
                                                                   * decTotalSpecialAttBurnMultiplier)
                            .StandardRound();
                        int intRESMinimumReduction = intResMinReduction;
                        int intDEPMinimumReduction = intDepMinReduction;
                        int intMAGMinimumReduction = intMagMinReduction;
                        int intMAGAdeptMinimumReduction = intMagMinReduction;
                        if (Settings.ESSLossReducesMaximumOnly)
                        {
                            (int iI, int iJ) = MAG.MinimumMaximumNoEssenceLoss();
                            intMAGMinimumReduction = Math.Max(0, intMagMinReduction + iI - iJ);
                            (iI, iJ) = MAGAdept.MinimumMaximumNoEssenceLoss();
                            intMAGAdeptMinimumReduction = Math.Max(0, intMagMinReduction + iI - iJ);
                            (iI, iJ) = RES.MinimumMaximumNoEssenceLoss();
                            intRESMinimumReduction = Math.Max(0, intResMinReduction + iI - iJ);
                            (iI, iJ) = DEP.MinimumMaximumNoEssenceLoss();
                            intDEPMinimumReduction = Math.Max(0, intDepMinReduction + iI - iJ);
                        }

                        using (LockObject.EnterWriteLock(token))
                        {
                            using (TemporaryArray<Improvement.ImprovementSource> aParams = new TemporaryArray<Improvement.ImprovementSource>(
                                Improvement.ImprovementSource.EssenceLossChargen, Improvement.ImprovementSource.EssenceLoss))
                            {
                                ImprovementManager.RemoveImprovements(this, aParams, token: token);
                            }

                            try
                            {
                                token.ThrowIfCancellationRequested();
                                if (intMagMaxReduction != 0 || intMAGMinimumReduction != 0
                                                            || intMAGAdeptMinimumReduction != 0)
                                {
                                    ImprovementManager.CreateImprovement(this, "MAG",
                                        Improvement.ImprovementSource.EssenceLossChargen,
                                        string.Empty,
                                        Improvement.ImprovementType.Attribute,
                                        string.Empty, 0, 1, -intMAGMinimumReduction,
                                        -intMagMaxReduction, token: token);
                                    ImprovementManager.CreateImprovement(this, "MAGAdept",
                                        Improvement.ImprovementSource.EssenceLossChargen,
                                        string.Empty,
                                        Improvement.ImprovementType.Attribute,
                                        string.Empty, 0, 1, -intMAGAdeptMinimumReduction,
                                        -intMagMaxReduction, token: token);
                                }

                                if (intResMaxReduction != 0 || intRESMinimumReduction != 0)
                                {
                                    ImprovementManager.CreateImprovement(this, "RES",
                                                                         Improvement.ImprovementSource
                                                                             .EssenceLossChargen,
                                                                         string.Empty,
                                                                         Improvement.ImprovementType.Attribute,
                                                                         string.Empty, 0, 1, -intRESMinimumReduction,
                                                                         -intResMaxReduction, token: token);
                                }

                                if (intDepMaxReduction != 0 || intDEPMinimumReduction != 0)
                                {
                                    ImprovementManager.CreateImprovement(this, "DEP",
                                                                         Improvement.ImprovementSource
                                                                             .EssenceLossChargen,
                                                                         string.Empty,
                                                                         Improvement.ImprovementType.Attribute,
                                                                         string.Empty, 0, 1, -intDEPMinimumReduction,
                                                                         -intDepMaxReduction, token: token);
                                }
                            }
                            catch
                            {
                                ImprovementManager.Rollback(this, CancellationToken.None);
                                throw;
                            }

                            ImprovementManager.Commit(this, token);
                        }

                        // If the character is in Career mode, it is possible for them to be forced to burn out.
                        if (Created)
                        {
                            // If the CharacterAttribute reaches 0, the character has burned out.
                            if (MAGEnabled)
                            {
                                if (Settings.SpecialKarmaCostBasedOnShownValue)
                                {
                                    if (Settings.MysAdeptSecondMAGAttribute && IsMysticAdept)
                                    {
                                        if (intMagMaxReduction >= MAG.TotalMaximum)
                                        {
                                            MAG.AssignBaseKarmaLimits(MAGAdept.Base, MAGAdept.Karma,
                                                                      MAGAdept.RawMetatypeMinimum,
                                                                      MAGAdept.RawMetatypeMaximum,
                                                                      MAGAdept.RawMetatypeAugmentedMaximum);
                                            MAGAdept.AssignBaseKarmaLimits(0, 0, 0, 0, 0);

                                            MagicianEnabled = false;
                                        }

                                        if (intMagMaxReduction >= MAGAdept.TotalMaximum)
                                        {
                                            MAGAdept.AssignBaseKarmaLimits(0, 0, 0, 0, 0);

                                            AdeptEnabled = false;
                                        }

                                        if (!MagicianEnabled && !AdeptEnabled)
                                            MAGEnabled = false;
                                    }
                                    else if (intMagMaxReduction >= MAG.TotalMaximum)
                                    {
                                        MAG.AssignBaseKarmaLimits(0, 0, 0, 0, 0);

                                        MagicianEnabled = false;
                                        AdeptEnabled = false;
                                        MAGEnabled = false;
                                    }
                                }
                                else if (Settings.MysAdeptSecondMAGAttribute && IsMysticAdept)
                                {
                                    if (MAG.TotalMaximum < 1)
                                    {
                                        MAG.AssignBaseKarmaLimits(MAGAdept.Base, MAGAdept.Karma,
                                                                  MAGAdept.RawMetatypeMinimum,
                                                                  MAGAdept.RawMetatypeMaximum,
                                                                  MAGAdept.RawMetatypeAugmentedMaximum);
                                        MAGAdept.AssignBaseKarmaLimits(0, 0, 0, 0, 0);

                                        MagicianEnabled = false;
                                    }

                                    if (MAGAdept.TotalMaximum < 1)
                                    {
                                        MAGAdept.AssignBaseKarmaLimits(0, 0, 0, 0, 0);

                                        AdeptEnabled = false;
                                    }

                                    if (!MagicianEnabled && !AdeptEnabled)
                                        MAGEnabled = false;
                                }
                                else if (MAG.TotalMaximum < 1)
                                {
                                    MAG.AssignBaseKarmaLimits(0, 0, 0, 0, 0);

                                    MagicianEnabled = false;
                                    AdeptEnabled = false;
                                    MAGEnabled = false;
                                }
                            }

                            if (RESEnabled
                                && (Settings.SpecialKarmaCostBasedOnShownValue
                                    && intResMaxReduction >= RES.TotalMaximum
                                    || !Settings.SpecialKarmaCostBasedOnShownValue
                                    && RES.TotalMaximum < 1))
                            {
                                RES.AssignBaseKarmaLimits(0, 0, 0, 0, 0);

                                RESEnabled = false;
                                TechnomancerEnabled = false;
                            }
                        }
                    }
                }
                // Otherwise any essence loss improvements that might have been left need to be deleted (e.g. character is in create mode and had access to special attributes, but that access was removed)
                else
                {
                    using (TemporaryArray<Improvement.ImprovementSource> aParams = new TemporaryArray<Improvement.ImprovementSource>(
                                Improvement.ImprovementSource.EssenceLossChargen, Improvement.ImprovementSource.EssenceLoss))
                    {
                        ImprovementManager.RemoveImprovements(this, aParams, token: token);
                    }
                }

                // If the character is Cyberzombie, adjust their Attributes based on their Essence.
                if (MetatypeCategory == "Cyberzombie")
                {
                    int intESSModifier = (-Essence(token: token)).StandardRound();
                    using (LockObject.EnterWriteLock(token))
                    {
                        ImprovementManager.RemoveImprovements(this,
                                                              Improvements.Where(x =>
                                                                  x.ImproveSource == Improvement
                                                                      .ImprovementSource
                                                                      .Cyberzombie &&
                                                                  x.ImproveType == Improvement
                                                                      .ImprovementType
                                                                      .Attribute).ToList(), token: token);
                        if (intESSModifier != 0)
                        {
                            try
                            {
                                token.ThrowIfCancellationRequested();
                                ImprovementManager.CreateImprovement(this, "BOD",
                                                                     Improvement.ImprovementSource.Cyberzombie,
                                                                     string.Empty,
                                                                     Improvement.ImprovementType.Attribute,
                                                                     string.Empty, 0, 1, 0, intESSModifier,
                                                                     token: token);
                                ImprovementManager.CreateImprovement(this, "AGI",
                                                                     Improvement.ImprovementSource.Cyberzombie,
                                                                     string.Empty,
                                                                     Improvement.ImprovementType.Attribute,
                                                                     string.Empty, 0, 1, 0, intESSModifier,
                                                                     token: token);
                                ImprovementManager.CreateImprovement(this, "REA",
                                                                     Improvement.ImprovementSource.Cyberzombie,
                                                                     string.Empty,
                                                                     Improvement.ImprovementType.Attribute,
                                                                     string.Empty, 0, 1, 0, intESSModifier,
                                                                     token: token);
                                ImprovementManager.CreateImprovement(this, "STR",
                                                                     Improvement.ImprovementSource.Cyberzombie,
                                                                     string.Empty,
                                                                     Improvement.ImprovementType.Attribute,
                                                                     string.Empty, 0, 1, 0, intESSModifier,
                                                                     token: token);
                                ImprovementManager.CreateImprovement(this, "CHA",
                                                                     Improvement.ImprovementSource.Cyberzombie,
                                                                     string.Empty,
                                                                     Improvement.ImprovementType.Attribute,
                                                                     string.Empty, 0, 1, 0, intESSModifier,
                                                                     token: token);
                                ImprovementManager.CreateImprovement(this, "INT",
                                                                     Improvement.ImprovementSource.Cyberzombie,
                                                                     string.Empty,
                                                                     Improvement.ImprovementType.Attribute,
                                                                     string.Empty, 0, 1, 0, intESSModifier,
                                                                     token: token);
                                ImprovementManager.CreateImprovement(this, "LOG",
                                                                     Improvement.ImprovementSource.Cyberzombie,
                                                                     string.Empty,
                                                                     Improvement.ImprovementType.Attribute,
                                                                     string.Empty, 0, 1, 0, intESSModifier,
                                                                     token: token);
                                ImprovementManager.CreateImprovement(this, "WIL",
                                                                     Improvement.ImprovementSource.Cyberzombie,
                                                                     string.Empty,
                                                                     Improvement.ImprovementType.Attribute,
                                                                     string.Empty, 0, 1, 0, intESSModifier,
                                                                     token: token);
                            }
                            catch
                            {
                                ImprovementManager.Rollback(this, CancellationToken.None);
                                throw;
                            }

                            ImprovementManager.Commit(this, token);
                        }
                    }
                }
            }
        }

        public async Task RefreshEssenceLossImprovementsAsync(CancellationToken token = default)
        {
            // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
            if (IsLoading)
                return;
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();

                // Only worry about essence loss attribute modifiers if this character actually has any attributes that would be affected by essence loss
                // (which means EssenceAtSpecialStart is not set to decimal.MinValue)
                if (await GetEssenceAtSpecialStartAsync(token).ConfigureAwait(false) != decimal.MinValue)
                {
                    decimal decSpecialAttBurnMultiplier = 1.0m;
                    decimal decTotalSpecialAttBurnMultiplier = 1.0m;
                    List<Improvement> lstUsedImprovements =
                        await ImprovementManager
                            .GetCachedImprovementListForValueOfAsync(
                                this, Improvement.ImprovementType.SpecialAttBurn, token: token)
                            .ConfigureAwait(false);
                    if (lstUsedImprovements.Count != 0)
                    {
                        foreach (Improvement objImprovement in lstUsedImprovements)
                            decSpecialAttBurnMultiplier -= 1m - objImprovement.Value / 100m;
                    }

                    List<Improvement> lstUsedImprovements2 =
                        await ImprovementManager
                            .GetCachedImprovementListForValueOfAsync(
                                this, Improvement.ImprovementType.SpecialAttTotalBurnMultiplier, token: token)
                            .ConfigureAwait(false);
                    if (lstUsedImprovements2.Count != 0)
                    {
                        foreach (Improvement objImprovement in lstUsedImprovements2)
                            decTotalSpecialAttBurnMultiplier *= objImprovement.Value / 100m;
                    }

                    decimal decESSMag = await EssenceAsync(true, "MAG", token).ConfigureAwait(false);
                    decimal decESSRes = await EssenceAsync(true, "RES", token).ConfigureAwait(false);
                    decimal decESSDep = await EssenceAsync(true, "DEP", token).ConfigureAwait(false);
                    if (!await (await GetSettingsAsync(token).ConfigureAwait(false)).GetDontRoundEssenceInternallyAsync(token).ConfigureAwait(false))
                    {
                        int intESSDecimals = await (await GetSettingsAsync(token).ConfigureAwait(false)).GetEssenceDecimalsAsync(token).ConfigureAwait(false);
                        decESSMag = decimal.Round(decESSMag, intESSDecimals, MidpointRounding.AwayFromZero);
                        decESSRes = decimal.Round(decESSRes, intESSDecimals, MidpointRounding.AwayFromZero);
                        decESSDep = decimal.Round(decESSDep, intESSDecimals, MidpointRounding.AwayFromZero);
                    }

                    // Reduce a character's MAG and RES from Essence Loss.
                    decimal decMetatypeMaximumESS = await ESS.GetMetatypeMaximumAsync(token).ConfigureAwait(false);
                    int intMagMaxReduction
                        = ((decMetatypeMaximumESS - decESSMag) * decSpecialAttBurnMultiplier
                                                               * decTotalSpecialAttBurnMultiplier).StandardRound();
                    int intResMaxReduction
                        = ((decMetatypeMaximumESS - decESSRes) * decSpecialAttBurnMultiplier
                                                               * decTotalSpecialAttBurnMultiplier).StandardRound();
                    int intDepMaxReduction
                        = ((decMetatypeMaximumESS - decESSDep) * decSpecialAttBurnMultiplier
                                                               * decTotalSpecialAttBurnMultiplier).StandardRound();
                    // Character has the option set where essence loss just acts as an augmented malus, so just replace old essence loss improvements with new ones that apply an augmented malus
                    // equal to the amount by which the attribute's maximum would normally be reduced.
                    if (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetSpecialKarmaCostBasedOnShownValueAsync(token).ConfigureAwait(false))
                    {
                        Improvement.ImprovementSource eEssenceLossSource = await GetCreatedAsync(token).ConfigureAwait(false)
                            ? Improvement.ImprovementSource.EssenceLoss
                            : Improvement.ImprovementSource.EssenceLossChargen;
                        IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                        try
                        {
                            token.ThrowIfCancellationRequested();
                            using (TemporaryArray<Improvement.ImprovementSource> aParams = new TemporaryArray<Improvement.ImprovementSource>(
                                Improvement.ImprovementSource.EssenceLossChargen, Improvement.ImprovementSource.EssenceLoss,
                                // With this house rule, Cyberadept Daemon just negates a penalty from Essence based on Grade instead of restoring Resonance, so delete all old improvements
                                Improvement.ImprovementSource.CyberadeptDaemon))
                            {
                                await ImprovementManager.RemoveImprovementsAsync(this, aParams, token: token).ConfigureAwait(false);
                            }

                            try
                            {
                                token.ThrowIfCancellationRequested();
                                if (intMagMaxReduction != 0)
                                {
                                    await ImprovementManager.CreateImprovementAsync(
                                        this, "MAG", eEssenceLossSource, string.Empty,
                                        Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, 0,
                                        -intMagMaxReduction, token: token).ConfigureAwait(false);
                                    await ImprovementManager.CreateImprovementAsync(
                                        this, "MAGAdept", eEssenceLossSource, string.Empty,
                                        Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, 0,
                                        -intMagMaxReduction, token: token).ConfigureAwait(false);
                                    // If this is a Mystic Adept using special Mystic Adept PP rules (i.e. no second MAG attribute), Mystic Adepts lose PPs even if they have fewer PPs than their MAG
                                    if (await GetUseMysticAdeptPPsAsync(token).ConfigureAwait(false))
                                        await ImprovementManager.CreateImprovementAsync(
                                            this, string.Empty, eEssenceLossSource,
                                            string.Empty,
                                            Improvement.ImprovementType.AdeptPowerPoints, string.Empty,
                                            -intMagMaxReduction,
                                            token: token).ConfigureAwait(false);
                                }

                                if (intResMaxReduction != 0)
                                {
                                    int intRESReduction = intResMaxReduction;
                                    if (await GetTechnomancerEnabledAsync(token).ConfigureAwait(false) && (await ImprovementManager
                                            .GetCachedImprovementListForValueOfAsync(this,
                                                Improvement.ImprovementType
                                                    .CyberadeptDaemon, token: token).ConfigureAwait(false))
                                        .Count > 0)
                                    {
                                        int intSubmersionGrade = await GetSubmersionGradeAsync(token).ConfigureAwait(false);
                                        if (intSubmersionGrade > 0)
                                        {
                                            decimal decNonCyberwareEssence = await GetBiowareEssenceAsync(token).ConfigureAwait(false) + await GetEssenceHoleAsync(token).ConfigureAwait(false);
                                            int intMaxCyberadeptDaemonBonus = Math.Ceiling(decNonCyberwareEssence) ==
                                                                              Math.Floor(decNonCyberwareEssence)
                                                ? (int)Math.Ceiling(await GetCyberwareEssenceAsync(token).ConfigureAwait(false))
                                                : (int)Math.Floor(await GetCyberwareEssenceAsync(token).ConfigureAwait(false));
                                            int intCyberadeptDaemonBonus = 0;
                                            for (int i = 1; i <= intSubmersionGrade; ++i)
                                            {
                                                intCyberadeptDaemonBonus += i.DivAwayFromZero(2);
                                            }

                                            intRESReduction
                                                -= Math.Min(intCyberadeptDaemonBonus, intMaxCyberadeptDaemonBonus);
                                            if (intRESReduction < 0)
                                                intRESReduction = 0;
                                        }
                                    }

                                    if (intRESReduction != 0)
                                        await ImprovementManager.CreateImprovementAsync(
                                            this, "RES", eEssenceLossSource, string.Empty,
                                            Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, 0,
                                            -intRESReduction, token: token).ConfigureAwait(false);
                                }

                                if (intDepMaxReduction != 0)
                                {
                                    await ImprovementManager.CreateImprovementAsync(
                                        this, "DEP", eEssenceLossSource, string.Empty,
                                        Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, 0,
                                        -intDepMaxReduction, token: token).ConfigureAwait(false);
                                }
                            }
                            catch
                            {
                                await ImprovementManager.RollbackAsync(this, CancellationToken.None)
                                    .ConfigureAwait(false);
                                throw;
                            }

                            if (intMagMaxReduction != 0 || intResMaxReduction != 0 || intDepMaxReduction != 0)
                                await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);
                        }
                        finally
                        {
                            await objLocker2.DisposeAsync().ConfigureAwait(false);
                        }
                    }
                    // RAW Career mode: complicated. Similar to RAW Create mode, but with the extra possibility of burning current karma levels and/or PPs instead of pure minima reduction,
                    // plus the need to account for cases where a character will burn "past" 0 (i.e. to a current value that should be negative), but then upgrade to 1 afterwards.
                    else if (await GetCreatedAsync(token).ConfigureAwait(false))
                    {
                        // "Base" minimum reduction. This is the amount by which the character's special attribute minima would be reduced across career and create modes if there wasn't any funny business
                        int intMagMinReduction
                            = ((await GetEssenceAtSpecialStartAsync(token).ConfigureAwait(false) - decESSMag) * decSpecialAttBurnMultiplier
                                                                   * decTotalSpecialAttBurnMultiplier)
                            .StandardRound();
                        int intResMinReduction
                            = ((await GetEssenceAtSpecialStartAsync(token).ConfigureAwait(false) - decESSRes) * decSpecialAttBurnMultiplier
                                                                   * decTotalSpecialAttBurnMultiplier)
                            .StandardRound();
                        int intDepMinReduction
                            = ((await GetEssenceAtSpecialStartAsync(token).ConfigureAwait(false) - decESSDep) * decSpecialAttBurnMultiplier
                                                                   * decTotalSpecialAttBurnMultiplier)
                            .StandardRound();

                        // This extra code is needed for legacy shims, to convert proper attribute values for characters who would end up having a higher level than their total attribute maxima
                        // They are extra amounts by which the relevant attributes' karma levels should be burned
                        int intExtraRESBurn = Math.Max(0,
                            Math.Max(
                                await RES.GetBaseAsync(token).ConfigureAwait(false) + await RES.GetFreeBaseAsync(token)
                                             .ConfigureAwait(false)
                                         + await RES.GetRawMinimumAsync(token)
                                             .ConfigureAwait(false)
                                         + await RES.GetAttributeValueModifiersAsync(
                                                 token)
                                             .ConfigureAwait(false),
                                await RES.GetTotalMinimumAsync(token)
                                    .ConfigureAwait(false)) + await RES.GetKarmaAsync(token).ConfigureAwait(false)
                            - await RES.GetTotalMaximumAsync(token)
                                .ConfigureAwait(false));
                        int intExtraDEPBurn = Math.Max(0,
                            Math.Max(
                                await DEP.GetBaseAsync(token).ConfigureAwait(false) + await DEP.GetFreeBaseAsync(token)
                                             .ConfigureAwait(false)
                                         + await DEP.GetRawMinimumAsync(token)
                                             .ConfigureAwait(false)
                                         + await DEP.GetAttributeValueModifiersAsync(
                                                 token)
                                             .ConfigureAwait(false),
                                await DEP.GetTotalMinimumAsync(token)
                                    .ConfigureAwait(false)) + await DEP.GetKarmaAsync(token).ConfigureAwait(false)
                            - await DEP.GetTotalMaximumAsync(token)
                                .ConfigureAwait(false));
                        int intExtraMAGBurn = Math.Max(0,
                            Math.Max(
                                await MAG.GetBaseAsync(token).ConfigureAwait(false) + await MAG.GetFreeBaseAsync(token)
                                             .ConfigureAwait(false)
                                         + await MAG.GetRawMinimumAsync(token)
                                             .ConfigureAwait(false)
                                         + await MAG.GetAttributeValueModifiersAsync(
                                                 token)
                                             .ConfigureAwait(false),
                                await MAG.GetTotalMinimumAsync(token)
                                    .ConfigureAwait(false)) + await MAG.GetKarmaAsync(token).ConfigureAwait(false)
                            - await MAG.GetTotalMaximumAsync(token)
                                .ConfigureAwait(false));
                        int intExtraMAGAdeptBurn = MAG == MAGAdept
                            ? intExtraMAGBurn
                            : Math.Max(0,
                                Math.Max(
                                    await MAGAdept.GetBaseAsync(token).ConfigureAwait(false)
                                    + await MAGAdept.GetFreeBaseAsync(token).ConfigureAwait(false)
                                    + await MAGAdept.GetRawMinimumAsync(token).ConfigureAwait(false)
                                    +
                                    await MAGAdept.GetAttributeValueModifiersAsync(token)
                                        .ConfigureAwait(false),
                                    await MAGAdept.GetTotalMinimumAsync(token).ConfigureAwait(false))
                                + await MAGAdept.GetKarmaAsync(token).ConfigureAwait(false)
                                - await MAGAdept.GetTotalMaximumAsync(token).ConfigureAwait(false));
                        // Old values for minimum reduction from essence loss in career mode. These are used to determine if any karma needs to get burned.
                        int intOldRESCareerMinimumReduction = 0;
                        int intOldDEPCareerMinimumReduction = 0;
                        int intOldMAGCareerMinimumReduction = 0;
                        int intOldMAGAdeptCareerMinimumReduction = 0;
                        foreach (Improvement objImprovement in await ImprovementManager
                                     .GetCachedImprovementListForValueOfAsync(
                                         this,
                                         Improvement.ImprovementType.Attribute,
                                         token: token).ConfigureAwait(false))
                        {
                            if (objImprovement.ImproveSource == Improvement.ImprovementSource.EssenceLoss)
                            {
                                // Values get subtracted because negative modifier = positive reduction, positive modifier = negative reduction
                                // Augmented values also get factored in in case the character is switching off the option to treat essence loss as an augmented malus
                                switch (objImprovement.ImprovedName.ToUpperInvariant())
                                {
                                    case "RES":
                                        intOldRESCareerMinimumReduction -=
                                            objImprovement.Minimum + objImprovement.Augmented.StandardRound();
                                        break;

                                    case "DEP":
                                        intOldDEPCareerMinimumReduction -=
                                            objImprovement.Minimum + objImprovement.Augmented.StandardRound();
                                        break;

                                    case "MAG":
                                        intOldMAGCareerMinimumReduction -=
                                            objImprovement.Minimum + objImprovement.Augmented.StandardRound();
                                        break;

                                    case "MAGADEPT":
                                        intOldMAGAdeptCareerMinimumReduction -=
                                            objImprovement.Minimum + objImprovement.Augmented.StandardRound();
                                        break;
                                }
                            }
                        }

                        IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                        try
                        {
                            token.ThrowIfCancellationRequested();
                            // Remove any Improvements from MAG, RES, and DEP from Essence Loss that were added in career.
                            await ImprovementManager.RemoveImprovementsAsync(
                                    this, Improvement.ImprovementSource.EssenceLoss,
                                    token: token)
                                .ConfigureAwait(false);

                            // Career Minimum and Maximum reduction relies on whether there's any extra reduction since chargen.
                            // This is the step where create mode attribute loss regarding attribute maximum loss gets factored out.
                            int intMAGMaximumReduction
                                = intMagMaxReduction + await MAG.GetTotalMaximumAsync(token).ConfigureAwait(false)
                                  - await MAG.MaximumNoEssenceLossAsync(token: token).ConfigureAwait(false);
                            int intMAGAdeptMaximumReduction =
                                intMagMaxReduction
                                + await MAGAdept.GetTotalMaximumAsync(token: token).ConfigureAwait(false)
                                - await MAGAdept.MaximumNoEssenceLossAsync(token: token).ConfigureAwait(false);
                            int intRESMaximumReduction
                                = intResMaxReduction + await RES.GetTotalMaximumAsync(token).ConfigureAwait(false)
                                  - await RES.MaximumNoEssenceLossAsync(token: token).ConfigureAwait(false);
                            int intDEPMaximumReduction
                                = intDepMaxReduction + await DEP.GetTotalMaximumAsync(token).ConfigureAwait(false)
                                  - await DEP.MaximumNoEssenceLossAsync(token: token).ConfigureAwait(false);

                            // Create the Essence Loss (or gain, in case of essence restoration and increasing maxima) Improvements.

                            if (intMagMaxReduction > 0
                                || intMagMinReduction > 0
                                || intMAGMaximumReduction != 0
                                || intMAGAdeptMaximumReduction != 0)
                            {
                                // This is the step where create mode attribute loss regarding attribute minimum loss gets factored out.
                                int intMAGMinimumReduction;
                                int intMAGAdeptMinimumReduction;
                                // If only maxima would be reduced, use the attribute's current total value instead of its current maximum, as this makes sure minima will only get reduced if the maximum reduction would eat into the current value
                                if (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetESSLossReducesMaximumOnlyAsync(token).ConfigureAwait(false))
                                {
                                    intMAGMinimumReduction = Math.Max(0,
                                        intMagMinReduction
                                        + await MAG.GetTotalValueAsync(token)
                                            .ConfigureAwait(false)
                                        - await MAG.MaximumNoEssenceLossAsync(
                                                true, token)
                                            .ConfigureAwait(false));
                                    intMAGAdeptMinimumReduction = Math.Max(0,
                                        intMagMinReduction
                                        + await MAGAdept
                                            .GetTotalValueAsync(token)
                                            .ConfigureAwait(false)
                                        - await MAGAdept
                                            .MaximumNoEssenceLossAsync(
                                                true, token)
                                            .ConfigureAwait(false));
                                }
                                else
                                {
                                    intMAGMinimumReduction =
                                        intMagMinReduction
                                        + await MAG.GetTotalMaximumAsync(token).ConfigureAwait(false)
                                        - await MAG.MaximumNoEssenceLossAsync(true, token).ConfigureAwait(false);
                                    intMAGAdeptMinimumReduction =
                                        intMagMinReduction
                                        + await MAGAdept.GetTotalMaximumAsync(token).ConfigureAwait(false)
                                        - await MAGAdept.MaximumNoEssenceLossAsync(true, token)
                                            .ConfigureAwait(false);
                                }

                                // If the new MAG reduction is greater than the old one...
                                int intMAGMinimumReductionDelta
                                    = intMAGMinimumReduction - intOldMAGCareerMinimumReduction;
                                if (intMAGMinimumReductionDelta > 0)
                                {
                                    // ... and adding minimum reducing-improvements wouldn't do anything, start burning karma.
                                    if (intMAGMinimumReduction >
                                        await MAG.GetBaseAsync(token).ConfigureAwait(false)
                                        + await MAG.GetFreeBaseAsync(token).ConfigureAwait(false)
                                        + await MAG.GetRawMinimumAsync(token).ConfigureAwait(false)
                                        + await MAG.GetAttributeValueModifiersAsync(token)
                                            .ConfigureAwait(false))
                                    {
                                        // intMAGMinimumReduction is not actually reduced so that karma doesn't get burned away each time this function is called.
                                        // Besides, this only fires if intMAGMinimumReduction is already at a level where increasing it any more wouldn't have any effect on the character.
                                        intExtraMAGBurn += Math.Min(await MAG.GetKarmaAsync(token).ConfigureAwait(false), intMAGMinimumReductionDelta);
                                        await MAG.ModifyKarmaAsync(-intExtraMAGBurn, token).ConfigureAwait(false);
                                    }

                                    // Mystic Adept PPs may need to be burned away based on the change of our MAG attribute
                                    if (await GetUseMysticAdeptPPsAsync(token).ConfigureAwait(false))
                                    {
                                        // First burn away PPs gained during chargen...
                                        int intChargenPPBurn =
                                            Math.Min(await GetMysticAdeptPowerPointsAsync(token).ConfigureAwait(false), intMAGMinimumReductionDelta);
                                        await ModifyMysticAdeptPowerPointsAsync(-intChargenPPBurn, token).ConfigureAwait(false);
                                        // ... now burn away PPs gained from initiations.
                                        decimal decPPBurn = Math.Min(intMAGMinimumReductionDelta - intChargenPPBurn,
                                            await ImprovementManager.ValueOfAsync(
                                                this,
                                                Improvement.ImprovementType
                                                    .AdeptPowerPoints,
                                                token: token).ConfigureAwait(false));
                                        // Source needs to be EssenceLossChargen so that it doesn't get wiped in career mode.
                                        if (decPPBurn != 0)
                                        {
                                            try
                                            {
                                                token.ThrowIfCancellationRequested();
                                                await ImprovementManager.CreateImprovementAsync(this, string.Empty,
                                                    Improvement.ImprovementSource.EssenceLossChargen, string.Empty,
                                                    Improvement.ImprovementType.AdeptPowerPoints, string.Empty,
                                                    -decPPBurn,
                                                    token: token).ConfigureAwait(false);
                                            }
                                            catch
                                            {
                                                await ImprovementManager.RollbackAsync(this, CancellationToken.None)
                                                    .ConfigureAwait(false);
                                                throw;
                                            }

                                            await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);
                                        }
                                    }
                                }
                                // If the new MAG reduction is less than our old one, the character doesn't actually get any new values back
                                else
                                {
                                    intMAGMinimumReduction = intOldMAGCareerMinimumReduction;
                                }

                                // Make sure we only attempt to burn MAGAdept karma levels if it's actually a separate attribute from MAG
                                if (MAGAdept != MAG)
                                {
                                    // If the new MAGAdept reduction is greater than the old one...
                                    int intMAGAdeptMinimumReductionDelta =
                                        intMAGAdeptMinimumReduction - intOldMAGAdeptCareerMinimumReduction;
                                    if (intMAGAdeptMinimumReductionDelta > 0)
                                    {
                                        // ... and adding minimum reducing-improvements wouldn't do anything, start burning karma.
                                        if (intMAGAdeptMinimumReduction > await MAGAdept.GetBaseAsync(token).ConfigureAwait(false)
                                            + await MAGAdept.GetFreeBaseAsync(token).ConfigureAwait(false) +
                                            await MAGAdept.GetRawMinimumAsync(token).ConfigureAwait(false)
                                            + await MAGAdept.GetAttributeValueModifiersAsync(token)
                                                .ConfigureAwait(false))
                                        {
                                            // intMAGAdeptMinimumReduction is not actually reduced so that karma doesn't get burned away each time this function is called.
                                            // Besides, this only fires if intMAGAdeptMinimumReduction is already at a level where increasing it any more wouldn't have any effect on the character.
                                            intExtraMAGAdeptBurn += Math.Min(await MAGAdept.GetKarmaAsync(token).ConfigureAwait(false),
                                                intMAGAdeptMinimumReductionDelta);
                                            await MAGAdept.ModifyKarmaAsync(-intExtraMAGAdeptBurn, token).ConfigureAwait(false);
                                        }
                                    }
                                    // If the new MAGAdept reduction is less than our old one, the character doesn't actually get any new values back
                                    else
                                    {
                                        intMAGAdeptMinimumReduction = intOldMAGAdeptCareerMinimumReduction;
                                    }
                                }
                                // Otherwise make sure that if the new MAGAdept reduction is less than our old one, the character doesn't actually get any new values back
                                else if (intMAGAdeptMinimumReduction < intOldMAGAdeptCareerMinimumReduction)
                                {
                                    intMAGAdeptMinimumReduction = intOldMAGAdeptCareerMinimumReduction;
                                }

                                // Create Improvements
                                try
                                {
                                    token.ThrowIfCancellationRequested();
                                    if (intMAGMinimumReduction != 0 || intMAGMaximumReduction != 0)
                                        await ImprovementManager.CreateImprovementAsync(this, "MAG",
                                                Improvement.ImprovementSource.EssenceLoss,
                                                string.Empty, Improvement.ImprovementType.Attribute,
                                                string.Empty, 0, 1,
                                                -intMAGMinimumReduction, -intMAGMaximumReduction,
                                                token: token)
                                            .ConfigureAwait(false);
                                    if (intMAGAdeptMinimumReduction != 0 || intMAGAdeptMaximumReduction != 0)
                                        await ImprovementManager.CreateImprovementAsync(this, "MAGAdept",
                                            Improvement.ImprovementSource.EssenceLoss, string.Empty,
                                            Improvement.ImprovementType.Attribute, string.Empty, 0, 1,
                                            -intMAGAdeptMinimumReduction,
                                            -intMAGAdeptMaximumReduction, token: token).ConfigureAwait(false);
                                }
                                catch
                                {
                                    await ImprovementManager.RollbackAsync(this, CancellationToken.None)
                                        .ConfigureAwait(false);
                                    throw;
                                }

                                if (intMAGMinimumReduction != 0 || intMAGMaximumReduction != 0 ||
                                    intMAGAdeptMinimumReduction != 0 || intMAGAdeptMaximumReduction != 0)
                                    await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);
                            }

                            if (intResMaxReduction > 0
                                || intResMinReduction > 0
                                || intRESMaximumReduction != 0)
                            {
                                // This is the step where create mode attribute loss regarding attribute minimum loss gets factored out.
                                int intRESMinimumReduction;
                                // If only maxima would be reduced, use the attribute's current total value instead of its current maximum, as this makes sure minima will only get reduced if the maximum reduction would eat into the current value
                                if (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetESSLossReducesMaximumOnlyAsync(token).ConfigureAwait(false))
                                {
                                    intRESMinimumReduction = Math.Max(0,
                                        intResMinReduction
                                        + await RES.GetTotalValueAsync(token)
                                            .ConfigureAwait(false)
                                        - await RES.MaximumNoEssenceLossAsync(
                                                true, token)
                                            .ConfigureAwait(false));
                                }
                                else
                                {
                                    intRESMinimumReduction =
                                        intResMinReduction
                                        + await RES.GetTotalMaximumAsync(token).ConfigureAwait(false)
                                        - await RES.MaximumNoEssenceLossAsync(true, token).ConfigureAwait(false);
                                }

                                // If the new RES reduction is greater than the old one...
                                int intRESMinimumReductionDelta
                                    = intRESMinimumReduction - intOldRESCareerMinimumReduction;
                                if (intRESMinimumReductionDelta > 0)
                                {
                                    // ... and adding minimum reducing-improvements wouldn't do anything, start burning karma.
                                    if (intRESMinimumReduction >
                                        await RES.GetBaseAsync(token).ConfigureAwait(false) + await RES.GetFreeBaseAsync(token).ConfigureAwait(false)
                                                 + await RES.GetRawMinimumAsync(token).ConfigureAwait(false)
                                                 + await RES.GetAttributeValueModifiersAsync(token)
                                                     .ConfigureAwait(false))
                                    {
                                        // intRESMinimumReduction is not actually reduced so that karma doesn't get burned away each time this function is called.
                                        // Besides, this only fires if intRESMinimumReduction is already at a level where increasing it any more wouldn't have any effect on the character.
                                        intExtraRESBurn += Math.Min(await RES.GetKarmaAsync(token).ConfigureAwait(false), intRESMinimumReductionDelta);
                                        await RES.ModifyKarmaAsync(-intExtraRESBurn, token).ConfigureAwait(false);
                                    }
                                }
                                // If the new RES reduction is less than our old one, the character doesn't actually get any new values back
                                else
                                {
                                    intRESMinimumReduction = intOldRESCareerMinimumReduction;
                                }

                                // Create Improvements
                                if (intRESMinimumReduction != 0 || intRESMaximumReduction != 0)
                                {
                                    try
                                    {
                                        token.ThrowIfCancellationRequested();
                                        await ImprovementManager.CreateImprovementAsync(this, "RES",
                                                Improvement.ImprovementSource.EssenceLoss,
                                                string.Empty, Improvement.ImprovementType.Attribute,
                                                string.Empty, 0, 1,
                                                -intRESMinimumReduction, -intRESMaximumReduction,
                                                token: token)
                                            .ConfigureAwait(false);
                                    }
                                    catch
                                    {
                                        await ImprovementManager.RollbackAsync(this, CancellationToken.None)
                                            .ConfigureAwait(false);
                                        throw;
                                    }

                                    await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);
                                }
                            }

                            if (intDepMaxReduction > 0
                                || intDepMinReduction > 0
                                || intDEPMaximumReduction != 0)
                            {
                                // This is the step where create mode attribute loss regarding attribute minimum loss gets factored out.
                                int intDEPMinimumReduction;
                                // If only maxima would be reduced, use the attribute's current total value instead of its current maximum, as this makes sure minima will only get reduced if the maximum reduction would eat into the current value
                                if (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetESSLossReducesMaximumOnlyAsync(token).ConfigureAwait(false))
                                {
                                    intDEPMinimumReduction = Math.Max(0,
                                        intDepMinReduction
                                        + await DEP.GetTotalValueAsync(token)
                                            .ConfigureAwait(false)
                                        - await DEP.MaximumNoEssenceLossAsync(
                                                true, token)
                                            .ConfigureAwait(false));
                                }
                                else
                                {
                                    intDEPMinimumReduction =
                                        intDepMinReduction
                                        + await DEP.GetTotalMaximumAsync(token).ConfigureAwait(false)
                                        - await DEP.MaximumNoEssenceLossAsync(true, token).ConfigureAwait(false);
                                }

                                // If the new DEP reduction is greater than the old one...
                                int intDEPMinimumReductionDelta
                                    = intDEPMinimumReduction - intOldDEPCareerMinimumReduction;
                                if (intDEPMinimumReductionDelta > 0)
                                {
                                    // ... and adding minimum reducing-improvements wouldn't do anything, start burning karma.
                                    if (intDEPMinimumReduction >
                                        await DEP.GetBaseAsync(token).ConfigureAwait(false) + await DEP.GetFreeBaseAsync(token).ConfigureAwait(false)
                                                 + await DEP.GetRawMinimumAsync(token).ConfigureAwait(false)
                                                 + await DEP.GetAttributeValueModifiersAsync(token)
                                                     .ConfigureAwait(false))
                                    {
                                        // intDEPMinimumReduction is not actually reduced so that karma doesn't get burned away each time this function is called.
                                        // Besides, this only fires if intDEPMinimumReduction is already at a level where increasing it any more wouldn't have any effect on the character.
                                        intExtraDEPBurn += Math.Min(await DEP.GetKarmaAsync(token).ConfigureAwait(false), intDEPMinimumReductionDelta);
                                        await DEP.ModifyKarmaAsync(-intExtraDEPBurn, token).ConfigureAwait(false);
                                    }
                                }
                                // If the new DEP reduction is less than our old one, the character doesn't actually get any new values back
                                else
                                {
                                    intDEPMinimumReduction = intOldDEPCareerMinimumReduction;
                                }

                                // Create Improvements
                                if (intDEPMinimumReduction != 0 || intDEPMaximumReduction != 0)
                                {
                                    try
                                    {
                                        token.ThrowIfCancellationRequested();
                                        await ImprovementManager.CreateImprovementAsync(this, "DEP",
                                                Improvement.ImprovementSource.EssenceLoss,
                                                string.Empty, Improvement.ImprovementType.Attribute,
                                                string.Empty, 0, 1,
                                                -intDEPMinimumReduction, -intDEPMaximumReduction,
                                                token: token)
                                            .ConfigureAwait(false);
                                    }
                                    catch
                                    {
                                        await ImprovementManager.RollbackAsync(this, CancellationToken.None)
                                            .ConfigureAwait(false);
                                        throw;
                                    }

                                    await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);
                                }
                            }
                        }
                        finally
                        {
                            await objLocker2.DisposeAsync().ConfigureAwait(false);
                        }
                    }
                    // RAW Create mode: Reduce maxima based on max ESS - current ESS, reduce minima based on their essence from the most optimal way in which they could have gotten access to special attributes
                    else
                    {
                        int intMagMinReduction
                            = ((await GetEssenceAtSpecialStartAsync(token).ConfigureAwait(false) - decESSMag) * decSpecialAttBurnMultiplier
                                                                   * decTotalSpecialAttBurnMultiplier)
                            .StandardRound();
                        int intResMinReduction
                            = ((await GetEssenceAtSpecialStartAsync(token).ConfigureAwait(false) - decESSRes) * decSpecialAttBurnMultiplier
                                                                   * decTotalSpecialAttBurnMultiplier)
                            .StandardRound();
                        int intDepMinReduction
                            = ((await GetEssenceAtSpecialStartAsync(token).ConfigureAwait(false) - decESSDep) * decSpecialAttBurnMultiplier
                                                                   * decTotalSpecialAttBurnMultiplier)
                            .StandardRound();
                        int intMAGMinimumReduction = intMagMinReduction;
                        int intMAGAdeptMinimumReduction = intMagMinReduction;
                        int intRESMinimumReduction = intResMinReduction;
                        int intDEPMinimumReduction = intDepMinReduction;
                        if (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetESSLossReducesMaximumOnlyAsync(token).ConfigureAwait(false))
                        {
                            (int iI, int iJ) = await MAG.MinimumMaximumNoEssenceLossAsync(token: token).ConfigureAwait(false);
                            intMAGMinimumReduction = Math.Max(0, intMagMinReduction + iI - iJ);
                            (iI, iJ) = await MAGAdept.MinimumMaximumNoEssenceLossAsync(token: token).ConfigureAwait(false);
                            intMAGAdeptMinimumReduction = Math.Max(0, intMagMinReduction + iI - iJ);
                            (iI, iJ) = await RES.MinimumMaximumNoEssenceLossAsync(token: token).ConfigureAwait(false);
                            intRESMinimumReduction = Math.Max(0, intResMinReduction + iI - iJ);
                            (iI, iJ) = await DEP.MinimumMaximumNoEssenceLossAsync(token: token).ConfigureAwait(false);
                            intDEPMinimumReduction = Math.Max(0, intDepMinReduction + iI - iJ);
                        }

                        IAsyncDisposable objLocker2
                            = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                        try
                        {
                            token.ThrowIfCancellationRequested();
                            using (TemporaryArray<Improvement.ImprovementSource> aParams = new TemporaryArray<Improvement.ImprovementSource>(
                                Improvement.ImprovementSource.EssenceLossChargen, Improvement.ImprovementSource.EssenceLoss))
                            {
                                await ImprovementManager.RemoveImprovementsAsync(this, aParams, token: token).ConfigureAwait(false);
                            }

                            try
                            {
                                token.ThrowIfCancellationRequested();
                                if (intMagMaxReduction != 0 || intMAGMinimumReduction != 0
                                                            || intMAGAdeptMinimumReduction != 0)
                                {
                                    await ImprovementManager.CreateImprovementAsync(this, "MAG",
                                        Improvement.ImprovementSource
                                            .EssenceLossChargen, string.Empty,
                                        Improvement.ImprovementType.Attribute,
                                        string.Empty, 0, 1, -intMAGMinimumReduction,
                                        -intMagMaxReduction, token: token).ConfigureAwait(false);
                                    await ImprovementManager.CreateImprovementAsync(this, "MAGAdept",
                                        Improvement.ImprovementSource
                                            .EssenceLossChargen, string.Empty,
                                        Improvement.ImprovementType.Attribute,
                                        string.Empty, 0, 1,
                                        -intMAGAdeptMinimumReduction,
                                        -intMagMaxReduction, token: token).ConfigureAwait(false);
                                }

                                if (intResMaxReduction != 0 || intRESMinimumReduction != 0)
                                {
                                    await ImprovementManager.CreateImprovementAsync(this, "RES",
                                        Improvement.ImprovementSource
                                            .EssenceLossChargen, string.Empty,
                                        Improvement.ImprovementType.Attribute,
                                        string.Empty, 0, 1, -intRESMinimumReduction,
                                        -intResMaxReduction, token: token).ConfigureAwait(false);
                                }

                                if (intDepMaxReduction != 0 || intDEPMinimumReduction != 0)
                                {
                                    await ImprovementManager.CreateImprovementAsync(this, "DEP",
                                        Improvement.ImprovementSource
                                            .EssenceLossChargen, string.Empty,
                                        Improvement.ImprovementType.Attribute,
                                        string.Empty, 0, 1, -intDEPMinimumReduction,
                                        -intDepMaxReduction, token: token).ConfigureAwait(false);
                                }
                            }
                            catch
                            {
                                await ImprovementManager.RollbackAsync(this, CancellationToken.None)
                                    .ConfigureAwait(false);
                                throw;
                            }

                            await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);

                            // If the character is in Career mode, it is possible for them to be forced to burn out.
                            if (await GetCreatedAsync(token).ConfigureAwait(false))
                            {
                                // If the CharacterAttribute reaches 0, the character has burned out.
                                if (await GetMAGEnabledAsync(token).ConfigureAwait(false))
                                {
                                    if (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetSpecialKarmaCostBasedOnShownValueAsync(token).ConfigureAwait(false))
                                    {
                                        if (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetMysAdeptSecondMAGAttributeAsync(token).ConfigureAwait(false) && await GetIsMysticAdeptAsync(token).ConfigureAwait(false))
                                        {
                                            if (intMagMaxReduction
                                                >= await MAG.GetTotalMaximumAsync(token).ConfigureAwait(false))
                                            {
                                                await MAG.AssignBaseKarmaLimitsAsync(
                                                        await MAGAdept.GetBaseAsync(token).ConfigureAwait(false),
                                                        await MAGAdept.GetKarmaAsync(token).ConfigureAwait(false),
                                                        await MAGAdept.GetRawMetatypeMinimumAsync(token).ConfigureAwait(false),
                                                        await MAGAdept.GetRawMetatypeMaximumAsync(token).ConfigureAwait(false),
                                                        await MAGAdept.GetRawMetatypeAugmentedMaximumAsync(token).ConfigureAwait(false),
                                                        token)
                                                    .ConfigureAwait(false);
                                                await MAGAdept.AssignBaseKarmaLimitsAsync(0, 0, 0, 0, 0, token)
                                                    .ConfigureAwait(false);

                                                await SetMagicianEnabledAsync(false, token).ConfigureAwait(false);
                                            }

                                            if (intMagMaxReduction
                                                >= await MAGAdept.GetTotalMaximumAsync(token).ConfigureAwait(false))
                                            {
                                                await MAGAdept.AssignBaseKarmaLimitsAsync(0, 0, 0, 0, 0, token)
                                                    .ConfigureAwait(false);

                                                await SetAdeptEnabledAsync(false, token).ConfigureAwait(false);
                                            }

                                            if (!await GetMagicianEnabledAsync(token).ConfigureAwait(false) && !await GetAdeptEnabledAsync(token).ConfigureAwait(false))
                                                await SetMAGEnabledAsync(false, token).ConfigureAwait(false);
                                        }
                                        else if (intMagMaxReduction
                                                 >= await MAG.GetTotalMaximumAsync(token).ConfigureAwait(false))
                                        {
                                            await MAG.AssignBaseKarmaLimitsAsync(0, 0, 0, 0, 0, token)
                                                .ConfigureAwait(false);

                                            await SetMagicianEnabledAsync(false, token).ConfigureAwait(false);
                                            await SetAdeptEnabledAsync(false, token).ConfigureAwait(false);
                                            await SetMAGEnabledAsync(false, token).ConfigureAwait(false);
                                        }
                                    }
                                    else if (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetMysAdeptSecondMAGAttributeAsync(token).ConfigureAwait(false) && await GetIsMysticAdeptAsync(token).ConfigureAwait(false))
                                    {
                                        if (await MAG.GetTotalMaximumAsync(token).ConfigureAwait(false) < 1)
                                        {
                                            await MAG.AssignBaseKarmaLimitsAsync(
                                                    await MAGAdept.GetBaseAsync(token).ConfigureAwait(false),
                                                    await MAGAdept.GetKarmaAsync(token).ConfigureAwait(false),
                                                    await MAGAdept.GetRawMetatypeMinimumAsync(token).ConfigureAwait(false),
                                                    await MAGAdept.GetRawMetatypeMaximumAsync(token).ConfigureAwait(false),
                                                    await MAGAdept.GetRawMetatypeAugmentedMaximumAsync(token).ConfigureAwait(false),
                                                    token)
                                                .ConfigureAwait(false);
                                            await MAGAdept.AssignBaseKarmaLimitsAsync(0, 0, 0, 0, 0, token)
                                                .ConfigureAwait(false);

                                            await SetMagicianEnabledAsync(false, token).ConfigureAwait(false);
                                        }

                                        if (await MAGAdept.GetTotalMaximumAsync(token).ConfigureAwait(false) < 1)
                                        {
                                            await MAGAdept.AssignBaseKarmaLimitsAsync(0, 0, 0, 0, 0, token)
                                                .ConfigureAwait(false);

                                            await SetAdeptEnabledAsync(false, token).ConfigureAwait(false);
                                        }

                                        if (!await GetMagicianEnabledAsync(token).ConfigureAwait(false) && !await GetAdeptEnabledAsync(token).ConfigureAwait(false))
                                            await SetMAGEnabledAsync(false, token).ConfigureAwait(false);
                                    }
                                    else if (await MAG.GetTotalMaximumAsync(token).ConfigureAwait(false) < 1)
                                    {
                                        await MAG.AssignBaseKarmaLimitsAsync(0, 0, 0, 0, 0, token)
                                            .ConfigureAwait(false);

                                        await SetMagicianEnabledAsync(false, token).ConfigureAwait(false);
                                        await SetAdeptEnabledAsync(false, token).ConfigureAwait(false);
                                        await SetMAGEnabledAsync(false, token).ConfigureAwait(false);
                                    }
                                }

                                if (await GetRESEnabledAsync(token).ConfigureAwait(false))
                                {
                                    int intResTotalMaximum
                                        = await RES.GetTotalMaximumAsync(token).ConfigureAwait(false);
                                    if (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetSpecialKarmaCostBasedOnShownValueAsync(token).ConfigureAwait(false)
                                        && intResMaxReduction >= intResTotalMaximum
                                        || !await (await GetSettingsAsync(token).ConfigureAwait(false)).GetSpecialKarmaCostBasedOnShownValueAsync(token).ConfigureAwait(false)
                                        && intResTotalMaximum < 1)
                                    {
                                        await RES.AssignBaseKarmaLimitsAsync(0, 0, 0, 0, 0, token)
                                            .ConfigureAwait(false);

                                        await SetRESEnabledAsync(false, token).ConfigureAwait(false);
                                        await SetTechnomancerEnabledAsync(false, token).ConfigureAwait(false);
                                    }
                                }
                            }
                        }
                        finally
                        {
                            await objLocker2.DisposeAsync().ConfigureAwait(false);
                        }
                    }
                }
                // Otherwise any essence loss improvements that might have been left need to be deleted (e.g. character is in create mode and had access to special attributes, but that access was removed)
                else
                {
                    using (TemporaryArray<Improvement.ImprovementSource> aParams = new TemporaryArray<Improvement.ImprovementSource>(
                        Improvement.ImprovementSource.EssenceLossChargen, Improvement.ImprovementSource.EssenceLoss))
                    {
                        await ImprovementManager.RemoveImprovementsAsync(this, aParams, token: token).ConfigureAwait(false);
                    }
                }

                // If the character is Cyberzombie, adjust their Attributes based on their Essence.
                if (await GetMetatypeCategoryAsync(token).ConfigureAwait(false) == "Cyberzombie")
                {
                    int intESSModifier = (-await EssenceAsync(token: token).ConfigureAwait(false)).StandardRound();
                    IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await ImprovementManager.RemoveImprovementsAsync(
                            this,
                            await (await GetImprovementsAsync(token).ConfigureAwait(false)).ToListAsync(
                                    x => x.ImproveSource == Improvement.ImprovementSource.Cyberzombie
                                         && x.ImproveType == Improvement.ImprovementType.Attribute, token)
                                .ConfigureAwait(false), token: token).ConfigureAwait(false);
                        if (intESSModifier != 0)
                        {
                            try
                            {
                                token.ThrowIfCancellationRequested();
                                await ImprovementManager.CreateImprovementAsync(
                                    this, "BOD", Improvement.ImprovementSource.Cyberzombie,
                                    string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0,
                                    intESSModifier, token: token).ConfigureAwait(false);
                                await ImprovementManager.CreateImprovementAsync(
                                    this, "AGI", Improvement.ImprovementSource.Cyberzombie,
                                    string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0,
                                    intESSModifier, token: token).ConfigureAwait(false);
                                await ImprovementManager.CreateImprovementAsync(
                                    this, "REA", Improvement.ImprovementSource.Cyberzombie,
                                    string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0,
                                    intESSModifier, token: token).ConfigureAwait(false);
                                await ImprovementManager.CreateImprovementAsync(
                                    this, "STR", Improvement.ImprovementSource.Cyberzombie,
                                    string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0,
                                    intESSModifier, token: token).ConfigureAwait(false);
                                await ImprovementManager.CreateImprovementAsync(
                                    this, "CHA", Improvement.ImprovementSource.Cyberzombie,
                                    string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0,
                                    intESSModifier, token: token).ConfigureAwait(false);
                                await ImprovementManager.CreateImprovementAsync(
                                    this, "INT", Improvement.ImprovementSource.Cyberzombie,
                                    string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0,
                                    intESSModifier, token: token).ConfigureAwait(false);
                                await ImprovementManager.CreateImprovementAsync(
                                    this, "LOG", Improvement.ImprovementSource.Cyberzombie,
                                    string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0,
                                    intESSModifier, token: token).ConfigureAwait(false);
                                await ImprovementManager.CreateImprovementAsync(
                                    this, "WIL", Improvement.ImprovementSource.Cyberzombie,
                                    string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0,
                                    intESSModifier, token: token).ConfigureAwait(false);
                            }
                            catch
                            {
                                await ImprovementManager.RollbackAsync(this, CancellationToken.None)
                                    .ConfigureAwait(false);
                                throw;
                            }

                            await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        await objLocker2.DisposeAsync().ConfigureAwait(false);
                    }
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private async Task ProcessSettingsExpressionsForDependentProperties(List<string> lstPropertyChangedHolder, string strExpressionToFind, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                CharacterSettings objSettings = await GetSettingsAsync(token).ConfigureAwait(false);
                if (!await GetCreatedAsync(token).ConfigureAwait(false))
                {
                    if ((await objSettings.GetContactPointsExpressionAsync(token).ConfigureAwait(false)).Contains(strExpressionToFind))
                        lstPropertyChangedHolder.Add(nameof(ContactPoints));
                    if ((await objSettings.GetChargenKarmaToNuyenExpressionAsync(token).ConfigureAwait(false)).Contains(strExpressionToFind))
                        lstPropertyChangedHolder.Add(nameof(TotalStartingNuyen));
                }

                if ((await objSettings.GetCarryLimitExpressionAsync(token).ConfigureAwait(false)).Contains(strExpressionToFind))
                    lstPropertyChangedHolder.Add(nameof(BaseCarryLimit));
                if ((await objSettings.GetLiftLimitExpressionAsync(token).ConfigureAwait(false)).Contains(strExpressionToFind))
                    lstPropertyChangedHolder.Add(nameof(BaseLiftLimit));
                if ((await objSettings.GetBoundSpiritExpressionAsync(token).ConfigureAwait(false)).Contains(strExpressionToFind))
                    lstPropertyChangedHolder.Add(nameof(BoundSpiritLimit));
                if ((await objSettings.GetRegisteredSpriteExpressionAsync(token).ConfigureAwait(false)).Contains(strExpressionToFind))
                    lstPropertyChangedHolder.Add(nameof(RegisteredSpriteLimit));
                if ((await objSettings.GetEncumbranceIntervalExpressionAsync(token).ConfigureAwait(false)).Contains(strExpressionToFind))
                    lstPropertyChangedHolder.Add(nameof(EncumbranceInterval));
                if ((await objSettings.GetEssenceModifierPostExpressionAsync(token).ConfigureAwait(false)).Contains(strExpressionToFind))
                {
                    lstPropertyChangedHolder.Add(nameof(PrototypeTranshumanEssenceUsed));
                    lstPropertyChangedHolder.Add(nameof(BiowareEssence));
                    lstPropertyChangedHolder.Add(nameof(CyberwareEssence));
                    lstPropertyChangedHolder.Add(nameof(EssenceHole));
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public async Task RefreshBODDependentProperties(object sender, MultiplePropertiesChangedEventArgs e,
            CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            List<string> lstProperties = new List<string>(17);
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (e.PropertyNames.Contains(nameof(CharacterAttrib.TotalValue)))
                {
                    lstProperties.Add(nameof(LimitPhysical));
                    lstProperties.Add(nameof(DamageResistancePool));
                    lstProperties.Add(nameof(LiftAndCarry));
                    lstProperties.Add(nameof(FatigueResist));
                    lstProperties.Add(nameof(RadiationResist));
                    lstProperties.Add(nameof(PhysiologicalAddictionResistFirstTime));
                    lstProperties.Add(nameof(PhysiologicalAddictionResistAlreadyAddicted));
                    lstProperties.Add(nameof(StunCMNaturalRecovery));
                    lstProperties.Add(nameof(PhysicalCMNaturalRecovery));
                    lstProperties.Add(nameof(PhysicalCM));
                    lstProperties.Add(nameof(CMOverflow));
                    lstProperties.Add(nameof(SpellDefenseIndirectSoak));
                    lstProperties.Add(nameof(SpellDefenseDirectSoakPhysical));
                    lstProperties.Add(nameof(SpellDefenseDecreaseBOD));
                    lstProperties.Add(nameof(SpellDefenseManipulationPhysical));
                    await ProcessSettingsExpressionsForDependentProperties(lstProperties, "{BOD}", token)
                        .ConfigureAwait(false);
                }

                if (e.PropertyNames.Contains(nameof(CharacterAttrib.Value)))
                {
                    await ProcessSettingsExpressionsForDependentProperties(lstProperties, "{BODUnaug}", token)
                        .ConfigureAwait(false);
                }

                if (e.PropertyNames.Contains(nameof(CharacterAttrib.MetatypeMaximum)) &&
                    await GetDEPEnabledAsync(token).ConfigureAwait(false))
                {
                    lstProperties.Add(nameof(IsAI));
                }

                if (lstProperties.Count > 0)
                {
                    await OnMultiplePropertiesChangedAsync(lstProperties, token).ConfigureAwait(false);
                }

                if (!await GetCreatedAsync(token).ConfigureAwait(false) &&
                    ((e.PropertyNames.Contains(nameof(CharacterAttrib.TotalValue))
                      && (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKnowledgePointsExpressionAsync(token).ConfigureAwait(false)).Contains("{BOD}"))
                     || (e.PropertyNames.Contains(nameof(CharacterAttrib.Value))
                         && (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKnowledgePointsExpressionAsync(token).ConfigureAwait(false)).Contains("{BODUnaug}"))))
                {
                    await (await GetSkillsSectionAsync(token).ConfigureAwait(false))
                        .OnPropertyChangedAsync(nameof(SkillsSection.KnowledgeSkillPoints), token)
                        .ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public async Task RefreshAGIDependentProperties(object sender, MultiplePropertiesChangedEventArgs e, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            List<string> lstProperties = new List<string>(4);
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (e.PropertyNames.Contains(nameof(CharacterAttrib.TotalValue)))
                {
                    lstProperties.Add(nameof(SpellDefenseDecreaseAGI));
                    lstProperties.Add(nameof(CalculatedMovement));
                    await ProcessSettingsExpressionsForDependentProperties(lstProperties, "{AGI}", token)
                        .ConfigureAwait(false);
                }

                if (e.PropertyNames.Contains(nameof(CharacterAttrib.Value)))
                {
                    await ProcessSettingsExpressionsForDependentProperties(lstProperties, "{AGIUnaug}", token)
                        .ConfigureAwait(false);
                }

                if (lstProperties.Count > 0)
                {
                    await OnMultiplePropertiesChangedAsync(lstProperties, token).ConfigureAwait(false);
                }

                if (!await GetCreatedAsync(token).ConfigureAwait(false) &&
                    ((e.PropertyNames.Contains(nameof(CharacterAttrib.TotalValue))
                      && (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKnowledgePointsExpressionAsync(token).ConfigureAwait(false)).Contains("{AGI}"))
                     || (e.PropertyNames.Contains(nameof(CharacterAttrib.Value))
                         && (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKnowledgePointsExpressionAsync(token).ConfigureAwait(false)).Contains("{AGIUnaug}"))))
                {
                    await (await GetSkillsSectionAsync(token).ConfigureAwait(false))
                        .OnPropertyChangedAsync(nameof(SkillsSection.KnowledgeSkillPoints), token)
                        .ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public async Task RefreshREADependentProperties(object sender, MultiplePropertiesChangedEventArgs e, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            List<string> lstProperties = new List<string>(7);
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (e.PropertyNames.Contains(nameof(CharacterAttrib.TotalValue)))
                {
                    lstProperties.Add(nameof(LimitPhysical));
                    lstProperties.Add(nameof(InitiativeValue));
                    lstProperties.Add(nameof(Dodge));
                    lstProperties.Add(nameof(SpellDefenseDecreaseREA));
                    lstProperties.Add(nameof(Surprise));
                    await ProcessSettingsExpressionsForDependentProperties(lstProperties, "{REA}", token)
                        .ConfigureAwait(false);
                }

                if (e.PropertyNames.Contains(nameof(CharacterAttrib.Value)))
                {
                    await ProcessSettingsExpressionsForDependentProperties(lstProperties, "{REAUnaug}", token)
                        .ConfigureAwait(false);
                }

                if (lstProperties.Count > 0)
                {
                    await OnMultiplePropertiesChangedAsync(lstProperties, token).ConfigureAwait(false);
                }

                if (!await GetCreatedAsync(token).ConfigureAwait(false) &&
                    ((e.PropertyNames.Contains(nameof(CharacterAttrib.TotalValue))
                      && (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKnowledgePointsExpressionAsync(token).ConfigureAwait(false)).Contains("{REA}"))
                     || (e.PropertyNames.Contains(nameof(CharacterAttrib.Value))
                         && (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKnowledgePointsExpressionAsync(token).ConfigureAwait(false)).Contains("{REAUnaug}"))))
                {
                    await (await GetSkillsSectionAsync(token).ConfigureAwait(false))
                        .OnPropertyChangedAsync(nameof(SkillsSection.KnowledgeSkillPoints), token)
                        .ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public async Task RefreshSTRDependentProperties(object sender, MultiplePropertiesChangedEventArgs e, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            List<string> lstProperties = new List<string>(8);
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (e.PropertyNames.Contains(nameof(CharacterAttrib.TotalValue)))
                {
                    lstProperties.Add(nameof(LimitPhysical));
                    lstProperties.Add(nameof(LiftAndCarry));
                    lstProperties.Add(nameof(SpellDefenseDecreaseSTR));
                    lstProperties.Add(nameof(SpellDefenseManipulationPhysical));
                    lstProperties.Add(nameof(CalculatedMovement));
                    lstProperties.Add(nameof(ArmorEncumbrance));
                    await ProcessSettingsExpressionsForDependentProperties(lstProperties, "{STR}", token)
                        .ConfigureAwait(false);
                }

                if (e.PropertyNames.Contains(nameof(CharacterAttrib.Value)))
                {
                    await ProcessSettingsExpressionsForDependentProperties(lstProperties, "{STRUnaug}", token)
                        .ConfigureAwait(false);
                }

                if (lstProperties.Count > 0)
                {
                    await OnMultiplePropertiesChangedAsync(lstProperties, token).ConfigureAwait(false);
                }

                if (!await GetCreatedAsync(token).ConfigureAwait(false) &&
                    ((e.PropertyNames.Contains(nameof(CharacterAttrib.TotalValue))
                      && (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKnowledgePointsExpressionAsync(token).ConfigureAwait(false)).Contains("{STR}"))
                     || (e.PropertyNames.Contains(nameof(CharacterAttrib.Value))
                         && (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKnowledgePointsExpressionAsync(token).ConfigureAwait(false)).Contains("{STRUnaug}"))))
                {
                    await (await GetSkillsSectionAsync(token).ConfigureAwait(false))
                        .OnPropertyChangedAsync(nameof(SkillsSection.KnowledgeSkillPoints), token)
                        .ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public async Task RefreshCHADependentProperties(object sender, MultiplePropertiesChangedEventArgs e, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            List<string> lstProperties = new List<string>(7);
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (e.PropertyNames.Contains(nameof(CharacterAttrib.TotalValue)))
                {
                    lstProperties.Add(nameof(LimitSocial));
                    lstProperties.Add(nameof(Composure));
                    lstProperties.Add(nameof(JudgeIntentions));
                    lstProperties.Add(nameof(JudgeIntentionsResist));
                    lstProperties.Add(nameof(SpellDefenseDecreaseCHA));
                    await ProcessSettingsExpressionsForDependentProperties(lstProperties, "{CHA}", token)
                        .ConfigureAwait(false);
                }

                if (e.PropertyNames.Contains(nameof(CharacterAttrib.Value)))
                {
                    await ProcessSettingsExpressionsForDependentProperties(lstProperties, "{CHAUnaug}", token)
                        .ConfigureAwait(false);
                }

                if (lstProperties.Count > 0)
                {
                    await OnMultiplePropertiesChangedAsync(lstProperties, token).ConfigureAwait(false);
                }

                if (!await GetCreatedAsync(token).ConfigureAwait(false) &&
                    ((e.PropertyNames.Contains(nameof(CharacterAttrib.TotalValue))
                      && (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKnowledgePointsExpressionAsync(token).ConfigureAwait(false)).Contains("{CHA}"))
                     || (e.PropertyNames.Contains(nameof(CharacterAttrib.Value))
                         && (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKnowledgePointsExpressionAsync(token).ConfigureAwait(false)).Contains("{CHAUnaug}"))))
                {
                    await (await GetSkillsSectionAsync(token).ConfigureAwait(false))
                        .OnPropertyChangedAsync(nameof(SkillsSection.KnowledgeSkillPoints), token)
                        .ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public async Task RefreshINTDependentProperties(object sender, MultiplePropertiesChangedEventArgs e, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            List<string> lstProperties = new List<string>(13);
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (e.PropertyNames.Contains(nameof(CharacterAttrib.TotalValue)))
                {
                    lstProperties.Add(nameof(LimitMental));
                    lstProperties.Add(nameof(JudgeIntentions));
                    lstProperties.Add(nameof(InitiativeValue));
                    lstProperties.Add(nameof(AstralInitiativeValue));
                    lstProperties.Add(nameof(MatrixInitiativeValue));
                    lstProperties.Add(nameof(MatrixInitiativeColdValue));
                    lstProperties.Add(nameof(MatrixInitiativeHotValue));
                    lstProperties.Add(nameof(Dodge));
                    lstProperties.Add(nameof(SpellDefenseDecreaseINT));
                    lstProperties.Add(nameof(SpellDefenseIllusionPhysical));
                    lstProperties.Add(nameof(Surprise));
                    await ProcessSettingsExpressionsForDependentProperties(lstProperties, "{INT}", token)
                        .ConfigureAwait(false);
                }

                if (e.PropertyNames.Contains(nameof(CharacterAttrib.Value)))
                {
                    await ProcessSettingsExpressionsForDependentProperties(lstProperties, "{INTUnaug}", token)
                        .ConfigureAwait(false);
                }

                if (lstProperties.Count > 0)
                {
                    await OnMultiplePropertiesChangedAsync(lstProperties, token).ConfigureAwait(false);
                }

                if (!await GetCreatedAsync(token).ConfigureAwait(false) &&
                    ((e.PropertyNames.Contains(nameof(CharacterAttrib.TotalValue))
                      && (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKnowledgePointsExpressionAsync(token).ConfigureAwait(false)).Contains("{INT}"))
                     || (e.PropertyNames.Contains(nameof(CharacterAttrib.Value))
                         && (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKnowledgePointsExpressionAsync(token).ConfigureAwait(false)).Contains("{INTUnaug}"))))
                {
                    await (await GetSkillsSectionAsync(token).ConfigureAwait(false))
                        .OnPropertyChangedAsync(nameof(SkillsSection.KnowledgeSkillPoints), token)
                        .ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public async Task RefreshLOGDependentProperties(object sender, MultiplePropertiesChangedEventArgs e, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            List<string> lstProperties = new List<string>(12);
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (e.PropertyNames.Contains(nameof(CharacterAttrib.TotalValue)))
                {
                    lstProperties.Add(nameof(LimitMental));
                    lstProperties.Add(nameof(Memory));
                    lstProperties.Add(nameof(PsychologicalAddictionResistFirstTime));
                    lstProperties.Add(nameof(PsychologicalAddictionResistAlreadyAddicted));
                    lstProperties.Add(nameof(SpellDefenseDetection));
                    lstProperties.Add(nameof(SpellDefenseDecreaseLOG));
                    lstProperties.Add(nameof(SpellDefenseIllusionMana));
                    lstProperties.Add(nameof(SpellDefenseIllusionPhysical));
                    lstProperties.Add(nameof(SpellDefenseManipulationMental));
                    await ProcessSettingsExpressionsForDependentProperties(lstProperties, "{LOG}", token)
                        .ConfigureAwait(false);
                }

                if (e.PropertyNames.Contains(nameof(CharacterAttrib.Value)))
                {
                    await ProcessSettingsExpressionsForDependentProperties(lstProperties, "{LOGUnaug}", token)
                        .ConfigureAwait(false);
                }

                if (lstProperties.Count > 0)
                {
                    await OnMultiplePropertiesChangedAsync(lstProperties, token).ConfigureAwait(false);
                }

                if (!await GetCreatedAsync(token).ConfigureAwait(false) &&
                    ((e.PropertyNames.Contains(nameof(CharacterAttrib.TotalValue))
                      && (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKnowledgePointsExpressionAsync(token).ConfigureAwait(false)).Contains("{LOG}"))
                     || (e.PropertyNames.Contains(nameof(CharacterAttrib.Value))
                         && (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKnowledgePointsExpressionAsync(token).ConfigureAwait(false)).Contains("{LOGUnaug}"))))
                {
                    await (await GetSkillsSectionAsync(token).ConfigureAwait(false))
                        .OnPropertyChangedAsync(nameof(SkillsSection.KnowledgeSkillPoints), token)
                        .ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public async Task RefreshWILDependentProperties(object sender, MultiplePropertiesChangedEventArgs e, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            List<string> lstProperties = new List<string>(28);
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (e.PropertyNames.Contains(nameof(CharacterAttrib.TotalValue)))
                {
                    lstProperties.Add(nameof(LimitSocial));
                    lstProperties.Add(nameof(LimitMental));
                    lstProperties.Add(nameof(Composure));
                    lstProperties.Add(nameof(Memory));
                    lstProperties.Add(nameof(JudgeIntentionsResist));
                    lstProperties.Add(nameof(FatigueResist));
                    lstProperties.Add(nameof(SonicResist));
                    lstProperties.Add(nameof(RadiationResist));
                    lstProperties.Add(nameof(PhysiologicalAddictionResistFirstTime));
                    lstProperties.Add(nameof(PhysiologicalAddictionResistAlreadyAddicted));
                    lstProperties.Add(nameof(PsychologicalAddictionResistFirstTime));
                    lstProperties.Add(nameof(PsychologicalAddictionResistAlreadyAddicted));
                    lstProperties.Add(nameof(StunCMNaturalRecovery));
                    lstProperties.Add(nameof(StunCM));
                    lstProperties.Add(nameof(SpellDefenseDetection));
                    lstProperties.Add(nameof(SpellDefenseDecreaseBOD));
                    lstProperties.Add(nameof(SpellDefenseDecreaseAGI));
                    lstProperties.Add(nameof(SpellDefenseDecreaseREA));
                    lstProperties.Add(nameof(SpellDefenseDecreaseSTR));
                    lstProperties.Add(nameof(SpellDefenseDecreaseCHA));
                    lstProperties.Add(nameof(SpellDefenseDecreaseINT));
                    lstProperties.Add(nameof(SpellDefenseDecreaseLOG));
                    lstProperties.Add(nameof(SpellDefenseDecreaseWIL));
                    lstProperties.Add(nameof(SpellDefenseIllusionMana));
                    lstProperties.Add(nameof(SpellDefenseManipulationMental));
                    await ProcessSettingsExpressionsForDependentProperties(lstProperties, "{WIL}", token)
                        .ConfigureAwait(false);
                }

                if (e.PropertyNames.Contains(nameof(CharacterAttrib.Value)))
                {
                    await ProcessSettingsExpressionsForDependentProperties(lstProperties, "{WILUnaug}", token)
                        .ConfigureAwait(false);
                }

                if (lstProperties.Count > 0)
                {
                    await OnMultiplePropertiesChangedAsync(lstProperties, token).ConfigureAwait(false);
                }

                if (!await GetCreatedAsync(token).ConfigureAwait(false) &&
                    ((e.PropertyNames.Contains(nameof(CharacterAttrib.TotalValue))
                      && (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKnowledgePointsExpressionAsync(token).ConfigureAwait(false)).Contains("{WIL}"))
                     || (e.PropertyNames.Contains(nameof(CharacterAttrib.Value))
                         && (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKnowledgePointsExpressionAsync(token).ConfigureAwait(false)).Contains("{WILUnaug}"))))
                {
                    await (await GetSkillsSectionAsync(token).ConfigureAwait(false))
                        .OnPropertyChangedAsync(nameof(SkillsSection.KnowledgeSkillPoints), token)
                        .ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public async Task RefreshEDGDependentProperties(object sender, MultiplePropertiesChangedEventArgs e, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            List<string> lstProperties = new List<string>(3);
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (e.PropertyNames.Contains(nameof(CharacterAttrib.TotalValue)))
                {
                    await ProcessSettingsExpressionsForDependentProperties(lstProperties, "{EDG}", token)
                        .ConfigureAwait(false);
                    int intEdgeValue =
                        await (await GetAttributeAsync("EDG", token: token).ConfigureAwait(false))
                            .GetTotalValueAsync(token).ConfigureAwait(false);
                    if (await GetEdgeUsedAsync(token).ConfigureAwait(false) > intEdgeValue)
                        await SetEdgeUsedAsync(intEdgeValue, token).ConfigureAwait(false);
                    else
                        lstProperties.Add(nameof(EdgeRemaining));
                }

                if (e.PropertyNames.Contains(nameof(CharacterAttrib.Value)))
                {
                    await ProcessSettingsExpressionsForDependentProperties(lstProperties, "{EDGUnaug}", token)
                        .ConfigureAwait(false);
                }

                if (lstProperties.Count > 0)
                {
                    await OnMultiplePropertiesChangedAsync(lstProperties, token).ConfigureAwait(false);
                }

                if (!await GetCreatedAsync(token).ConfigureAwait(false) &&
                    ((e.PropertyNames.Contains(nameof(CharacterAttrib.TotalValue))
                      && (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKnowledgePointsExpressionAsync(token).ConfigureAwait(false)).Contains("{EDG}"))
                     || (e.PropertyNames.Contains(nameof(CharacterAttrib.Value))
                         && (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKnowledgePointsExpressionAsync(token).ConfigureAwait(false)).Contains("{EDGUnaug}"))))
                {
                    await (await GetSkillsSectionAsync(token).ConfigureAwait(false))
                        .OnPropertyChangedAsync(nameof(SkillsSection.KnowledgeSkillPoints), token)
                        .ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public async Task RefreshMAGDependentProperties(object sender, MultiplePropertiesChangedEventArgs e,
            CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            List<string> lstProperties = new List<string>(6);
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (e.PropertyNames.Contains(nameof(CharacterAttrib.TotalValue)))
                {
                    await ProcessSettingsExpressionsForDependentProperties(lstProperties, "{MAG}", token)
                        .ConfigureAwait(false);
                    CharacterAttrib objMag = await GetAttributeAsync("MAG", token: token).ConfigureAwait(false);
                    if (!IsLoading)
                    {
                        int intMysticAdeptPowerPoints =
                            await GetMysticAdeptPowerPointsAsync(token).ConfigureAwait(false);
                        if (intMysticAdeptPowerPoints > 0)
                        {
                            int intMAGTotalValue = await objMag.GetTotalValueAsync(token).ConfigureAwait(false);
                            if (intMysticAdeptPowerPoints > intMAGTotalValue)
                                await SetMysticAdeptPowerPointsAsync(intMAGTotalValue, token)
                                    .ConfigureAwait(false);
                        }
                    }

                    if (await (await GetSettingsAsync(token).ConfigureAwait(false))
                        .GetSpiritForceBasedOnTotalMAGAsync(token).ConfigureAwait(false))
                        lstProperties.Add(nameof(MaxSpiritForce));
                    if (await GetMysAdeptAllowPPCareerAsync(token).ConfigureAwait(false))
                        lstProperties.Add(nameof(CanAffordCareerPP));
                    if (!await GetUseMysticAdeptPPsAsync(token).ConfigureAwait(false)
                        && objMag == await GetAttributeAsync("MAGAdept", token: token).ConfigureAwait(false))
                        lstProperties.Add(nameof(PowerPointsTotal));
                    if (await GetAnyPowerAdeptWayDiscountEnabledAsync(token).ConfigureAwait(false))
                        lstProperties.Add(nameof(AllowAdeptWayPowerDiscount));
                }

                if (e.PropertyNames.Contains(nameof(CharacterAttrib.Value)))
                {
                    await ProcessSettingsExpressionsForDependentProperties(lstProperties, "{MAGUnaug}", token)
                        .ConfigureAwait(false);
                }

                if (lstProperties.Count > 0)
                {
                    await OnMultiplePropertiesChangedAsync(lstProperties, token).ConfigureAwait(false);
                }

                if (!await GetCreatedAsync(token).ConfigureAwait(false) &&
                    ((e.PropertyNames.Contains(nameof(CharacterAttrib.TotalValue))
                      && (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKnowledgePointsExpressionAsync(token).ConfigureAwait(false)).Contains("{MAG}"))
                     || (e.PropertyNames.Contains(nameof(CharacterAttrib.Value))
                         && (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKnowledgePointsExpressionAsync(token).ConfigureAwait(false)).Contains("{MAGUnaug}"))))
                {
                    await (await GetSkillsSectionAsync(token).ConfigureAwait(false))
                        .OnPropertyChangedAsync(nameof(SkillsSection.KnowledgeSkillPoints), token)
                        .ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public async Task RefreshMAGAdeptDependentProperties(object sender, MultiplePropertiesChangedEventArgs e, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                CharacterAttrib objMagAdept = await GetAttributeAsync("MAGAdept", token: token).ConfigureAwait(false);
                if (await GetAttributeAsync("MAG", token: token).ConfigureAwait(false) == objMagAdept)
                    return;

                List<string> lstProperties = new List<string>(3);
                if (e.PropertyNames.Contains(nameof(CharacterAttrib.TotalValue)))
                {
                    await ProcessSettingsExpressionsForDependentProperties(lstProperties, "{MAGAdept}", token)
                        .ConfigureAwait(false);
                    if (!await GetUseMysticAdeptPPsAsync(token).ConfigureAwait(false))
                        lstProperties.Add(nameof(MaxSpiritForce));
                }

                if (e.PropertyNames.Contains(nameof(CharacterAttrib.Value)))
                {
                    await ProcessSettingsExpressionsForDependentProperties(lstProperties, "{MAGAdeptUnaug}", token)
                        .ConfigureAwait(false);
                }

                if (lstProperties.Count > 0)
                {
                    await OnMultiplePropertiesChangedAsync(lstProperties, token).ConfigureAwait(false);
                }

                if (!await GetCreatedAsync(token).ConfigureAwait(false) &&
                    ((e.PropertyNames.Contains(nameof(CharacterAttrib.TotalValue))
                      && (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKnowledgePointsExpressionAsync(token).ConfigureAwait(false)).Contains("{MAGAdept}"))
                     || (e.PropertyNames.Contains(nameof(CharacterAttrib.Value))
                         && (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKnowledgePointsExpressionAsync(token).ConfigureAwait(false)).Contains("{MAGAdeptUnaug}"))))
                {
                    await (await GetSkillsSectionAsync(token).ConfigureAwait(false))
                        .OnPropertyChangedAsync(nameof(SkillsSection.KnowledgeSkillPoints), token)
                        .ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public async Task RefreshRESDependentProperties(object sender, MultiplePropertiesChangedEventArgs e, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            List<string> lstProperties = new List<string>(4);
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (e.PropertyNames.Contains(nameof(CharacterAttrib.TotalValue)))
                {
                    lstProperties.Add(nameof(MaxSpriteLevel));
                    await ProcessSettingsExpressionsForDependentProperties(lstProperties, "{RES}", token)
                        .ConfigureAwait(false);
                    if (!await GetUseMysticAdeptPPsAsync(token).ConfigureAwait(false))
                        lstProperties.Add(nameof(MaxSpiritForce));
                }

                if (e.PropertyNames.Contains(nameof(CharacterAttrib.Value)))
                {
                    await ProcessSettingsExpressionsForDependentProperties(lstProperties, "{RESUnaug}", token)
                        .ConfigureAwait(false);
                }

                if (lstProperties.Count > 0)
                {
                    await OnMultiplePropertiesChangedAsync(lstProperties, token).ConfigureAwait(false);
                }

                if (!await GetCreatedAsync(token).ConfigureAwait(false) &&
                    ((e.PropertyNames.Contains(nameof(CharacterAttrib.TotalValue))
                      && (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKnowledgePointsExpressionAsync(token).ConfigureAwait(false)).Contains("{RES}"))
                     || (e.PropertyNames.Contains(nameof(CharacterAttrib.Value))
                         && (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKnowledgePointsExpressionAsync(token).ConfigureAwait(false)).Contains("{RESUnaug}"))))
                {
                    await (await GetSkillsSectionAsync(token).ConfigureAwait(false))
                        .OnPropertyChangedAsync(nameof(SkillsSection.KnowledgeSkillPoints), token)
                        .ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public async Task RefreshDEPDependentProperties(object sender, MultiplePropertiesChangedEventArgs e, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            List<string> lstProperties = new List<string>(3);
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (e.PropertyNames.Contains(nameof(CharacterAttrib.TotalValue)))
                {
                    if (await GetIsAIAsync(token).ConfigureAwait(false))
                        await (await GetAttributeAsync("EDG", token: token).ConfigureAwait(false))
                            .OnPropertyChangedAsync(nameof(CharacterAttrib.MetatypeMaximum), token)
                            .ConfigureAwait(false);
                    await ProcessSettingsExpressionsForDependentProperties(lstProperties, "{DEP}", token)
                        .ConfigureAwait(false);
                    if (!await GetUseMysticAdeptPPsAsync(token).ConfigureAwait(false))
                        lstProperties.Add(nameof(MaxSpiritForce));
                }

                if (e.PropertyNames.Contains(nameof(CharacterAttrib.Value)))
                {
                    await ProcessSettingsExpressionsForDependentProperties(lstProperties, "{DEPUnaug}", token)
                        .ConfigureAwait(false);
                }

                if (lstProperties.Count > 0)
                {
                    await OnMultiplePropertiesChangedAsync(lstProperties, token).ConfigureAwait(false);
                }

                if (!await GetCreatedAsync(token).ConfigureAwait(false) &&
                    ((e.PropertyNames.Contains(nameof(CharacterAttrib.TotalValue))
                      && (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKnowledgePointsExpressionAsync(token).ConfigureAwait(false)).Contains("{DEP}"))
                     || (e.PropertyNames.Contains(nameof(CharacterAttrib.Value))
                         && (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKnowledgePointsExpressionAsync(token).ConfigureAwait(false)).Contains("{DEPUnaug}"))))
                {
                    await (await GetSkillsSectionAsync(token).ConfigureAwait(false))
                        .OnPropertyChangedAsync(nameof(SkillsSection.KnowledgeSkillPoints), token)
                        .ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public async Task RefreshESSDependentProperties(object sender, MultiplePropertiesChangedEventArgs e, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            List<string> lstProperties = new List<string>(7);
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (e.PropertyNames.Contains(nameof(CharacterAttrib.TotalValue)))
                {
                    if (await GetIsAIAsync(token).ConfigureAwait(false))
                        await (await GetAttributeAsync("EDG", token: token).ConfigureAwait(false))
                            .OnPropertyChangedAsync(nameof(CharacterAttrib.MetatypeMaximum), token)
                            .ConfigureAwait(false);
                    await ProcessSettingsExpressionsForDependentProperties(lstProperties, "{ESS}", token)
                        .ConfigureAwait(false);
                    if (!await GetUseMysticAdeptPPsAsync(token).ConfigureAwait(false))
                        lstProperties.Add(nameof(MaxSpiritForce));
                }

                if (e.PropertyNames.Contains(nameof(CharacterAttrib.Value)))
                {
                    await ProcessSettingsExpressionsForDependentProperties(lstProperties, "{ESSUnaug}", token)
                        .ConfigureAwait(false);
                }

                // Only ESS.MetatypeMaximum is used for the Essence method/property when it comes to attributes
                if (e.PropertyNames.Contains(nameof(CharacterAttrib.MetatypeMaximum)))
                {
                    lstProperties.Add(nameof(PrototypeTranshumanEssenceUsed));
                    lstProperties.Add(nameof(BiowareEssence));
                    lstProperties.Add(nameof(CyberwareEssence));
                    lstProperties.Add(nameof(EssenceHole));
                }

                if (lstProperties.Count > 0)
                {
                    await OnMultiplePropertiesChangedAsync(lstProperties, token).ConfigureAwait(false);
                }

                if (!await GetCreatedAsync(token).ConfigureAwait(false) &&
                    ((e.PropertyNames.Contains(nameof(CharacterAttrib.TotalValue))
                      && (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKnowledgePointsExpressionAsync(token).ConfigureAwait(false)).Contains("{ESS}"))
                     || (e.PropertyNames.Contains(nameof(CharacterAttrib.Value))
                         && (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKnowledgePointsExpressionAsync(token).ConfigureAwait(false)).Contains("{ESSUnaug}"))))
                {
                    await (await GetSkillsSectionAsync(token).ConfigureAwait(false))
                        .OnPropertyChangedAsync(nameof(SkillsSection.KnowledgeSkillPoints), token)
                        .ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public void RefreshEncumbrance(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
            if (IsLoading)
                return;
            using (LockObject.EnterWriteLock(token))
            {
                // Remove any Improvements from Armor Encumbrance.
                ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Encumbrance, token: token);
                if (!Settings.DoEncumbrancePenaltyPhysicalLimit
                    && !Settings.DoEncumbrancePenaltyMovementSpeed
                    && !Settings.DoEncumbrancePenaltyAgility
                    && !Settings.DoEncumbrancePenaltyReaction)
                    return;
                // Create the Encumbrance Improvements.
                int intEncumbrance = Encumbrance;
                if (intEncumbrance == 0)
                    return;
                token.ThrowIfCancellationRequested();
                try
                {
                    if (Settings.DoEncumbrancePenaltyPhysicalLimit)
                        ImprovementManager.CreateImprovement(this, "Physical",
                            Improvement.ImprovementSource.Encumbrance,
                            string.Empty,
                            Improvement.ImprovementType.PhysicalLimit,
                            "precedence-1",
                            intEncumbrance
                            * Settings.EncumbrancePenaltyPhysicalLimit,
                            token: token);
                    if (Settings.DoEncumbrancePenaltyMovementSpeed)
                    {
                        ImprovementManager.CreateImprovement(this, "Ground",
                            Improvement.ImprovementSource.Encumbrance,
                            string.Empty,
                            Improvement.ImprovementType.SprintBonusPercent,
                            "precedence-1",
                            intEncumbrance
                            * Settings.EncumbrancePenaltyMovementSpeed,
                            token: token);
                        ImprovementManager.CreateImprovement(this, "Fly", Improvement.ImprovementSource.Encumbrance,
                            string.Empty,
                            Improvement.ImprovementType.SprintBonusPercent,
                            "precedence-1",
                            intEncumbrance
                            * Settings.EncumbrancePenaltyMovementSpeed,
                            token: token);
                        ImprovementManager.CreateImprovement(this, "Swim",
                            Improvement.ImprovementSource.Encumbrance,
                            string.Empty,
                            Improvement.ImprovementType.SprintBonusPercent,
                            "precedence-1",
                            intEncumbrance
                            * Settings.EncumbrancePenaltyMovementSpeed,
                            token: token);
                        ImprovementManager.CreateImprovement(this, "Ground",
                            Improvement.ImprovementSource.Encumbrance,
                            string.Empty,
                            Improvement.ImprovementType.RunMultiplierPercent,
                            "precedence-1",
                            intEncumbrance
                            * Settings.EncumbrancePenaltyMovementSpeed,
                            token: token);
                        ImprovementManager.CreateImprovement(this, "Fly", Improvement.ImprovementSource.Encumbrance,
                            string.Empty,
                            Improvement.ImprovementType.RunMultiplierPercent,
                            "precedence-1",
                            intEncumbrance
                            * Settings.EncumbrancePenaltyMovementSpeed,
                            token: token);
                        ImprovementManager.CreateImprovement(this, "Swim",
                            Improvement.ImprovementSource.Encumbrance,
                            string.Empty,
                            Improvement.ImprovementType.RunMultiplierPercent,
                            "precedence-1",
                            intEncumbrance
                            * Settings.EncumbrancePenaltyMovementSpeed,
                            token: token);
                        ImprovementManager.CreateImprovement(this, "Ground",
                            Improvement.ImprovementSource.Encumbrance,
                            string.Empty,
                            Improvement.ImprovementType.WalkMultiplierPercent,
                            "precedence-1",
                            intEncumbrance
                            * Settings.EncumbrancePenaltyMovementSpeed,
                            token: token);
                        ImprovementManager.CreateImprovement(this, "Fly", Improvement.ImprovementSource.Encumbrance,
                            string.Empty,
                            Improvement.ImprovementType.WalkMultiplierPercent,
                            "precedence-1",
                            intEncumbrance
                            * Settings.EncumbrancePenaltyMovementSpeed,
                            token: token);
                        ImprovementManager.CreateImprovement(this, "Swim",
                            Improvement.ImprovementSource.Encumbrance,
                            string.Empty,
                            Improvement.ImprovementType.WalkMultiplierPercent,
                            "precedence-1",
                            intEncumbrance
                            * Settings.EncumbrancePenaltyMovementSpeed,
                            token: token);
                    }

                    if (Settings.DoEncumbrancePenaltyAgility)
                        ImprovementManager.CreateImprovement(this, "AGI", Improvement.ImprovementSource.Encumbrance,
                            string.Empty, Improvement.ImprovementType.Attribute,
                            "precedence-1", 0, 1, 0, 0,
                            intEncumbrance * Settings.EncumbrancePenaltyAgility,
                            token: token);
                    if (Settings.DoEncumbrancePenaltyReaction)
                        ImprovementManager.CreateImprovement(this, "REA", Improvement.ImprovementSource.Encumbrance,
                            string.Empty, Improvement.ImprovementType.Attribute,
                            "precedence-1", 0, 1, 0, 0,
                            intEncumbrance * Settings.EncumbrancePenaltyReaction,
                            token: token);
                }
                catch
                {
                    ImprovementManager.Rollback(this, CancellationToken.None);
                    throw;
                }

                ImprovementManager.Commit(this, token);
            }
        }

        public async Task RefreshEncumbranceAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
            if (IsLoading)
                return;
            IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                // Remove any Improvements from Armor Encumbrance.
                await ImprovementManager
                    .RemoveImprovementsAsync(this, Improvement.ImprovementSource.Encumbrance, token: token)
                    .ConfigureAwait(false);
                CharacterSettings objSettings = await GetSettingsAsync(token).ConfigureAwait(false);
                if (!await objSettings.GetDoEncumbrancePenaltyPhysicalLimitAsync(token).ConfigureAwait(false)
                    && !await objSettings.GetDoEncumbrancePenaltyMovementSpeedAsync(token).ConfigureAwait(false)
                    && !await objSettings.GetDoEncumbrancePenaltyAgilityAsync(token).ConfigureAwait(false)
                    && !await objSettings.GetDoEncumbrancePenaltyReactionAsync(token).ConfigureAwait(false))
                    return;
                // Create the Encumbrance Improvements.
                int intEncumbrance = await GetEncumbranceAsync(token).ConfigureAwait(false);
                if (intEncumbrance == 0)
                    return;
                token.ThrowIfCancellationRequested();
                try
                {
                    if (await objSettings.GetDoEncumbrancePenaltyPhysicalLimitAsync(token).ConfigureAwait(false))
                        await ImprovementManager.CreateImprovementAsync(
                                this, "Physical", Improvement.ImprovementSource.Encumbrance,
                                string.Empty, Improvement.ImprovementType.PhysicalLimit,
                                "precedence-1",
                                intEncumbrance * await objSettings.GetEncumbrancePenaltyPhysicalLimitAsync(token).ConfigureAwait(false),
                                token: token)
                            .ConfigureAwait(false);
                    if (await objSettings.GetDoEncumbrancePenaltyMovementSpeedAsync(token).ConfigureAwait(false))
                    {
                        await ImprovementManager.CreateImprovementAsync(
                                this, "Ground", Improvement.ImprovementSource.Encumbrance,
                                string.Empty, Improvement.ImprovementType.SprintBonusPercent,
                                "precedence-1",
                                intEncumbrance * await objSettings.GetEncumbrancePenaltyMovementSpeedAsync(token).ConfigureAwait(false),
                                token: token)
                            .ConfigureAwait(false);
                        await ImprovementManager.CreateImprovementAsync(
                                this, "Fly", Improvement.ImprovementSource.Encumbrance,
                                string.Empty, Improvement.ImprovementType.SprintBonusPercent,
                                "precedence-1",
                                intEncumbrance * await objSettings.GetEncumbrancePenaltyMovementSpeedAsync(token).ConfigureAwait(false),
                                token: token)
                            .ConfigureAwait(false);
                        await ImprovementManager.CreateImprovementAsync(
                                this, "Swim", Improvement.ImprovementSource.Encumbrance,
                                string.Empty, Improvement.ImprovementType.SprintBonusPercent,
                                "precedence-1",
                                intEncumbrance * await objSettings.GetEncumbrancePenaltyMovementSpeedAsync(token).ConfigureAwait(false),
                                token: token)
                            .ConfigureAwait(false);
                        await ImprovementManager.CreateImprovementAsync(
                                this, "Ground", Improvement.ImprovementSource.Encumbrance,
                                string.Empty, Improvement.ImprovementType.RunMultiplierPercent,
                                "precedence-1",
                                intEncumbrance * await objSettings.GetEncumbrancePenaltyMovementSpeedAsync(token).ConfigureAwait(false),
                                token: token)
                            .ConfigureAwait(false);
                        await ImprovementManager.CreateImprovementAsync(
                                this, "Fly", Improvement.ImprovementSource.Encumbrance,
                                string.Empty, Improvement.ImprovementType.RunMultiplierPercent,
                                "precedence-1",
                                intEncumbrance * await objSettings.GetEncumbrancePenaltyMovementSpeedAsync(token).ConfigureAwait(false),
                                token: token)
                            .ConfigureAwait(false);
                        await ImprovementManager.CreateImprovementAsync(
                                this, "Swim", Improvement.ImprovementSource.Encumbrance,
                                string.Empty, Improvement.ImprovementType.RunMultiplierPercent,
                                "precedence-1",
                                intEncumbrance * await objSettings.GetEncumbrancePenaltyMovementSpeedAsync(token).ConfigureAwait(false),
                                token: token)
                            .ConfigureAwait(false);
                        await ImprovementManager.CreateImprovementAsync(
                                this, "Ground", Improvement.ImprovementSource.Encumbrance,
                                string.Empty,
                                Improvement.ImprovementType.WalkMultiplierPercent,
                                "precedence-1",
                                intEncumbrance * await objSettings.GetEncumbrancePenaltyMovementSpeedAsync(token).ConfigureAwait(false),
                                token: token)
                            .ConfigureAwait(false);
                        await ImprovementManager.CreateImprovementAsync(
                                this, "Fly", Improvement.ImprovementSource.Encumbrance,
                                string.Empty,
                                Improvement.ImprovementType.WalkMultiplierPercent,
                                "precedence-1",
                                intEncumbrance * await objSettings.GetEncumbrancePenaltyMovementSpeedAsync(token).ConfigureAwait(false),
                                token: token)
                            .ConfigureAwait(false);
                        await ImprovementManager.CreateImprovementAsync(
                                this, "Swim", Improvement.ImprovementSource.Encumbrance,
                                string.Empty,
                                Improvement.ImprovementType.WalkMultiplierPercent,
                                "precedence-1",
                                intEncumbrance * await objSettings.GetEncumbrancePenaltyMovementSpeedAsync(token).ConfigureAwait(false),
                                token: token)
                            .ConfigureAwait(false);
                    }

                    if (await objSettings.GetDoEncumbrancePenaltyAgilityAsync(token).ConfigureAwait(false))
                        await ImprovementManager.CreateImprovementAsync(
                                this, "AGI", Improvement.ImprovementSource.Encumbrance,
                                string.Empty, Improvement.ImprovementType.Attribute,
                                "precedence-1", 0, 1, 0, 0,
                                intEncumbrance * await objSettings.GetEncumbrancePenaltyAgilityAsync(token).ConfigureAwait(false),
                                token: token)
                            .ConfigureAwait(false);
                    if (await objSettings.GetDoEncumbrancePenaltyReactionAsync(token).ConfigureAwait(false))
                        await ImprovementManager.CreateImprovementAsync(
                                this, "REA", Improvement.ImprovementSource.Encumbrance,
                                string.Empty, Improvement.ImprovementType.Attribute,
                                "precedence-1", 0, 1, 0, 0,
                                intEncumbrance * await objSettings.GetEncumbrancePenaltyReactionAsync(token).ConfigureAwait(false),
                                token: token)
                            .ConfigureAwait(false);
                }
                catch
                {
                    await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                    throw;
                }

                await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public void RefreshArmorEncumbrance(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
            if (IsLoading)
                return;
            using (LockObject.EnterWriteLock(token))
            {
                // Remove any Improvements from Armor Encumbrance.
                ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.ArmorEncumbrance,
                    token: token);
                // Create the Armor Encumbrance Improvements.
                int intEncumbrance = ArmorEncumbrance;
                if (intEncumbrance != 0)
                {
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        ImprovementManager.CreateImprovement(this, "AGI",
                            Improvement.ImprovementSource.ArmorEncumbrance,
                            string.Empty, Improvement.ImprovementType.Attribute,
                            "precedence-1", 0, 1, 0, 0,
                            intEncumbrance, token: token);
                        ImprovementManager.CreateImprovement(this, "REA",
                            Improvement.ImprovementSource.ArmorEncumbrance,
                            string.Empty, Improvement.ImprovementType.Attribute,
                            "precedence-1", 0, 1, 0, 0,
                            intEncumbrance, token: token);
                    }
                    catch
                    {
                        ImprovementManager.Rollback(this, CancellationToken.None);
                        throw;
                    }

                    ImprovementManager.Commit(this, token);
                }
            }
        }

        public async Task RefreshArmorEncumbranceAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
            if (IsLoading)
                return;
            IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                // Remove any Improvements from Armor Encumbrance.
                await ImprovementManager
                    .RemoveImprovementsAsync(this, Improvement.ImprovementSource.ArmorEncumbrance, token: token)
                    .ConfigureAwait(false);
                // Create the Armor Encumbrance Improvements.
                int intEncumbrance = await GetArmorEncumbranceAsync(token).ConfigureAwait(false);
                if (intEncumbrance != 0)
                {
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await ImprovementManager.CreateImprovementAsync(
                            this, "AGI", Improvement.ImprovementSource.ArmorEncumbrance,
                            string.Empty, Improvement.ImprovementType.Attribute,
                            "precedence-1", 0, 1, 0, 0,
                            intEncumbrance, token: token).ConfigureAwait(false);
                        await ImprovementManager.CreateImprovementAsync(
                            this, "REA", Improvement.ImprovementSource.ArmorEncumbrance,
                            string.Empty, Improvement.ImprovementType.Attribute,
                            "precedence-1", 0, 1, 0, 0,
                            intEncumbrance, token: token).ConfigureAwait(false);
                    }
                    catch
                    {
                        await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                        throw;
                    }

                    await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public void RefreshWoundPenalties(CancellationToken token = default)
        {
            // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
            if (IsLoading)
                return;
            using (LockObject.EnterWriteLock(token))
            {
                int intPhysicalCMFilled = Math.Min(PhysicalCMFilled, PhysicalCM);
                int intStunCMFilled = Math.Min(StunCMFilled, StunCM);
                int intCMThreshold = CMThreshold;
                int intStunCMPenalty = ImprovementManager
                                       .GetCachedImprovementListForValueOf(
                                           this, Improvement.ImprovementType.IgnoreCMPenaltyStun, token: token)
                                       .Count > 0
                    ? 0
                    : Math.Min(0, StunCMThresholdOffset - intStunCMFilled) / intCMThreshold;
                int intPhysicalCMPenalty = ImprovementManager
                                           .GetCachedImprovementListForValueOf(
                                               this, Improvement.ImprovementType.IgnoreCMPenaltyPhysical, token: token)
                                           .Count > 0
                    ? 0
                    : Math.Min(0, PhysicalCMThresholdOffset - intPhysicalCMFilled) / intCMThreshold;
                int intWoundModifier = intPhysicalCMPenalty + intStunCMPenalty;
                if (Settings.DoEncumbrancePenaltyWoundModifier)
                    intWoundModifier += Encumbrance * Settings.EncumbrancePenaltyWoundModifier;
                _intWoundModifier = intWoundModifier;
            }
        }

        public async Task RefreshWoundPenaltiesAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
            if (IsLoading)
                return;
            IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intPhysicalCMFilled =
                    Math.Min(PhysicalCMFilled, await GetPhysicalCMAsync(token).ConfigureAwait(false));
                int intStunCMFilled = Math.Min(StunCMFilled, await GetStunCMAsync(token).ConfigureAwait(false));
                int intCMThreshold = await GetCMThresholdAsync(token).ConfigureAwait(false);
                int intStunCMPenalty = (await ImprovementManager
                        .GetCachedImprovementListForValueOfAsync(
                            this, Improvement.ImprovementType.IgnoreCMPenaltyStun, token: token).ConfigureAwait(false))
                    .Count > 0
                        ? 0
                        : Math.Min(0,
                              await GetStunCMThresholdOffsetAsync(token).ConfigureAwait(false) - intStunCMFilled) /
                          intCMThreshold;
                int intPhysicalCMPenalty = (await ImprovementManager
                        .GetCachedImprovementListForValueOfAsync(
                            this, Improvement.ImprovementType.IgnoreCMPenaltyPhysical, token: token)
                        .ConfigureAwait(false))
                    .Count > 0
                        ? 0
                        : Math.Min(0,
                            await GetPhysicalCMThresholdOffsetAsync(token).ConfigureAwait(false) -
                            intPhysicalCMFilled) / intCMThreshold;
                int intWoundModifier = intPhysicalCMPenalty + intStunCMPenalty;
                CharacterSettings objSettings = await GetSettingsAsync(token).ConfigureAwait(false);
                if (await objSettings.GetDoEncumbrancePenaltyWoundModifierAsync(token).ConfigureAwait(false))
                {
                    intWoundModifier += await GetEncumbranceAsync(token).ConfigureAwait(false)
                        * await objSettings.GetEncumbrancePenaltyWoundModifierAsync(token).ConfigureAwait(false);
                }
                _intWoundModifier = intWoundModifier;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private int _intWoundModifier;

        /// <summary>
        /// Recalculates the Dicepool modifier for sustaining spells or complex forms
        /// </summary>
        public bool RefreshSustainingPenalties(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (IsLoading) // If we are in the middle of loading, just queue a single refresh to happen at the end of the process
            {
                EnqueuePostLoadMethod(RefreshSustainingPenalties, token);
                return true;
            }
            using (LockObject.EnterUpgradeableReadLock(token))
            {
                int intDicePenaltySustainedSpell = Settings.DicePenaltySustaining;

                //The sustaining of Critterpowers doesn't cause any penalties that's why they aren't counted there is no way to change them to self sustained anyway, but just to be sure
                List<SustainedObject> lstSustainedSpells =
                    SustainedCollection.Where(x => x.HasSustainingPenalty).ToList();
                List<Improvement> lstUsedImprovements
                    = ImprovementManager.GetCachedImprovementListForValueOf(
                        this, Improvement.ImprovementType.PenaltyFreeSustain, token: token);
                // Handling of bonuses that let characters sustain some objects for free requires special handling in order to best match the bonus ensemble to the sustained spells ensemble
                if (lstUsedImprovements.Count != 0)
                {
                    // Set up a dictionary where the key is the maximum force/level of the bonus and the value is the number of objects that can be sustained
                    SortedDictionary<decimal, int> dicPenaltyFreeSustains = new SortedDictionary<decimal, int>();
                    foreach (Improvement objImprovement in lstUsedImprovements)
                    {
                        token.ThrowIfCancellationRequested();
                        decimal decForce = objImprovement.Value;
                        if (dicPenaltyFreeSustains.TryGetValue(decForce, out int intExistingRating))
                            dicPenaltyFreeSustains[decForce] = intExistingRating + objImprovement.Rating;
                        else
                            dicPenaltyFreeSustains.Add(decForce, objImprovement.Rating);
                    }

                    // List of supported objects, sorted in descending order of Force
                    List<SustainedObject> lstSupportedObjects = new List<SustainedObject>(lstSustainedSpells.Count);
                    // Go from lowest maximum force/level bonus to highest (that's why we use SortedDictionary) and match each one to the highest possible objects for it.
                    foreach (KeyValuePair<decimal, int> kvpLoop in dicPenaltyFreeSustains)
                    {
                        token.ThrowIfCancellationRequested();
                        int intSupportedForce = kvpLoop.Key.StandardRound();
                        int intNumSupportsPossible = kvpLoop.Value;
                        lstSupportedObjects.Clear();
                        foreach (SustainedObject objLoopObject in lstSustainedSpells)
                        {
                            token.ThrowIfCancellationRequested();
                            int intLoopForce = objLoopObject.Force;
                            if (intLoopForce > intSupportedForce)
                                continue;
                            if (intLoopForce == intSupportedForce)
                            {
                                if (lstSupportedObjects.Count > 0 && lstSupportedObjects.Count + 1 > intNumSupportsPossible)
                                    // Remove the last element because we know it's the lowest
                                    lstSupportedObjects.RemoveAt(lstSupportedObjects.Count - 1);
                                // Safe to insert object at the top because we cannot get objects with more Force in the list
                                lstSupportedObjects.Insert(0, objLoopObject);
                                if (lstSupportedObjects.Count == intNumSupportsPossible &&
                                    lstSupportedObjects[lstSupportedObjects.Count - 1].Force == intSupportedForce)
                                    // The entire list at this point is saturated with objects with the maximum allowable force, so quit out early
                                    break;
                            }
                            else
                            {
                                if (lstSupportedObjects.Count > 0 && lstSupportedObjects.Count + 1 > intNumSupportsPossible)
                                {
                                    // Check against the last element because we know it'll be the lowest, only replace item if loop has a higher force than this one
                                    if (intLoopForce <= lstSupportedObjects[lstSupportedObjects.Count - 1].Force)
                                        continue;
                                    lstSupportedObjects.RemoveAt(lstSupportedObjects.Count - 1);
                                }

                                lstSupportedObjects.AddWithSort(objLoopObject,
                                                                (x, y) => y.Force.CompareTo(x.Force), token: token);
                            }
                        }

                        // Remove all sustained objects that supported as penalty-free
                        lstSustainedSpells.RemoveAll(x => lstSupportedObjects.Contains(x));
                        // If we have no more sustained objects in need of penalty removal, exit out early
                        if (lstSustainedSpells.Count == 0)
                            break;
                    }
                }

                int intModifierPerSpell = PsycheActive ? -1 : -intDicePenaltySustainedSpell;
                SustainingPenalty = lstSustainedSpells.Count * intModifierPerSpell;
            }
            return true;
        }

        /// <summary>
        /// Recalculates the Dicepool modifier for sustaining spells or complex forms
        /// </summary>
        public async Task<bool> RefreshSustainingPenaltiesAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (IsLoading) // If we are in the middle of loading, just queue a single refresh to happen at the end of the process
            {
                await EnqueuePostLoadAsyncMethodAsync(RefreshSustainingPenaltiesAsync, token).ConfigureAwait(false);
                return true;
            }
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();

                int intDicePenaltySustainedSpell = (await GetSettingsAsync(token).ConfigureAwait(false)).DicePenaltySustaining;

                //The sustaining of Critterpowers doesn't cause any penalties that's why they aren't counted there is no way to change them to self sustained anyway, but just to be sure
                List<SustainedObject> lstSustainedSpells =
                    await (await GetSustainedCollectionAsync(token).ConfigureAwait(false)).ToListAsync(x => x.GetHasSustainingPenaltyAsync(token), token: token)
                        .ConfigureAwait(false);
                List<Improvement> lstUsedImprovements
                    = await ImprovementManager
                        .GetCachedImprovementListForValueOfAsync(this, Improvement.ImprovementType.PenaltyFreeSustain,
                            token: token).ConfigureAwait(false);
                // Handling of bonuses that let characters sustain some objects for free requires special handling in order to best match the bonus ensemble to the sustained spells ensemble
                if (lstUsedImprovements.Count != 0)
                {
                    // Set up a dictionary where the key is the maximum force/level of the bonus and the value is the number of objects that can be sustained
                    SortedDictionary<decimal, int> dicPenaltyFreeSustains = new SortedDictionary<decimal, int>();
                    foreach (Improvement objImprovement in lstUsedImprovements)
                    {
                        decimal decForce = objImprovement.Value;
                        if (dicPenaltyFreeSustains.TryGetValue(decForce, out int intExistingRating))
                            dicPenaltyFreeSustains[decForce] = intExistingRating + objImprovement.Rating;
                        else
                            dicPenaltyFreeSustains.Add(decForce, objImprovement.Rating);
                    }

                    // List of supported objects, sorted in descending order of Force
                    List<SustainedObject> lstSupportedObjects = new List<SustainedObject>(lstSustainedSpells.Count);
                    // Go from lowest maximum force/level bonus to highest (that's why we use SortedDictionary) and match each one to the highest possible objects for it.
                    foreach (KeyValuePair<decimal, int> kvpLoop in dicPenaltyFreeSustains)
                    {
                        token.ThrowIfCancellationRequested();
                        int intSupportedForce = kvpLoop.Key.StandardRound();
                        int intNumSupportsPossible = kvpLoop.Value;
                        lstSupportedObjects.Clear();
                        foreach (SustainedObject objLoopObject in lstSustainedSpells)
                        {
                            token.ThrowIfCancellationRequested();
                            int intLoopForce = await objLoopObject.GetForceAsync(token).ConfigureAwait(false);
                            if (intLoopForce > intSupportedForce)
                                continue;
                            if (intLoopForce == intSupportedForce)
                            {
                                if (lstSupportedObjects.Count > 0 && lstSupportedObjects.Count + 1 > intNumSupportsPossible)
                                    // Remove the last element because we know it's the lowest
                                    lstSupportedObjects.RemoveAt(lstSupportedObjects.Count - 1);
                                // Safe to insert object at the top because we cannot get objects with more Force in the list
                                lstSupportedObjects.Insert(0, objLoopObject);
                                if (lstSupportedObjects.Count == intNumSupportsPossible &&
                                    await lstSupportedObjects[lstSupportedObjects.Count - 1].GetForceAsync(token).ConfigureAwait(false) == intSupportedForce)
                                    // The entire list at this point is saturated with objects with the maximum allowable force, so quit out early
                                    break;
                            }
                            else
                            {
                                if (lstSupportedObjects.Count > 0 && lstSupportedObjects.Count + 1 > intNumSupportsPossible)
                                {
                                    // Check against the last element because we know it'll be the lowest, only replace item if loop has a higher force than this one
                                    if (intLoopForce <= await lstSupportedObjects[lstSupportedObjects.Count - 1].GetForceAsync(token).ConfigureAwait(false))
                                        continue;
                                    lstSupportedObjects.RemoveAt(lstSupportedObjects.Count - 1);
                                }

                                await lstSupportedObjects.AddWithSortAsync(objLoopObject, async (x, y) => (await y.GetForceAsync(token).ConfigureAwait(false))
                                    .CompareTo(await x.GetForceAsync(token).ConfigureAwait(false)), token: token).ConfigureAwait(false);
                            }
                        }

                        // Remove all sustained objects that supported as penalty-free
                        lstSustainedSpells.RemoveAll(x => lstSupportedObjects.Contains(x));
                        // If we have no more sustained objects in need of penalty removal, exit out early
                        if (lstSustainedSpells.Count == 0)
                            break;
                    }
                }

                int intModifierPerSpell = PsycheActive ? -1 : -intDicePenaltySustainedSpell;
                SustainingPenalty = lstSustainedSpells.Count * intModifierPerSpell;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
            return true;
        }

        private int _intSustainingPenalty;

        /// <summary>
        /// Dicepool modifier the character has from wounds. Should be a non-positive number because wound modifiers are always penalties if they are not 0.
        /// </summary>
        public int WoundModifier
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _intWoundModifier;
            }
        }

        /// <summary>
        /// Dicepool modifier the character has from wounds. Should be a non-positive number because wound modifiers are always penalties if they are not 0.
        /// </summary>
        public async Task<int> GetWoundModifierAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _intWoundModifier;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Dicepool modified the character has from sustaining spells. Should be negative
        /// </summary>
        public int SustainingPenalty
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _intSustainingPenalty;
            }
            private set //Private set instead of read only, to allow inclusion of OnPropertyChanged
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _intSustainingPenalty, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Dicepool modified the character has from sustaining spells. Should be negative
        /// </summary>
        public async Task<int> GetSustainingPenaltyAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _intSustainingPenalty;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private bool _blnLoadAsDirty;

        /// <summary>
        /// Whether to immediately mark a character file as dirty when it is loaded in. Used if we're changing a character's settings on load.
        /// </summary>
        public bool LoadAsDirty
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _blnLoadAsDirty;
            }
            private set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (_blnLoadAsDirty == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnLoadAsDirty = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        public async Task<bool> GetLoadAsDirtyAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return _blnLoadAsDirty;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private async Task SetLoadAsDirtyAsync(bool value, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_blnLoadAsDirty == value)
                    return;
                IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    _blnLoadAsDirty = value;
                    await OnPropertyChangedAsync(nameof(LoadAsDirty), token).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public ValueVersion LastSavedVersion
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _verSavedVersion;
            }
        }

        /// <summary>
        /// Is the character a mystic adept (MagicianEnabled && AdeptEnabled)? Used for databinding properties.
        /// </summary>
        public bool IsMysticAdept
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return AdeptEnabled && MagicianEnabled;
            }
        }

        /// <summary>
        /// Is the character a mystic adept (MagicianEnabled && AdeptEnabled)? Used for databinding properties.
        /// </summary>
        public async Task<bool> GetIsMysticAdeptAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await GetAdeptEnabledAsync(token).ConfigureAwait(false) && await GetMagicianEnabledAsync(token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether this character is using special Mystic Adept PP rules (true) or calculate PPs from Mystic Adept's Adept MAG (false)
        /// </summary>
        public bool UseMysticAdeptPPs
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return IsMysticAdept && !Settings.MysAdeptSecondMAGAttribute;
            }
        }

        /// <summary>
        /// Whether this character is using special Mystic Adept PP rules (true) or calculate PPs from Mystic Adept's Adept MAG (false)
        /// </summary>
        public async Task<bool> GetUseMysticAdeptPPsAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await GetIsMysticAdeptAsync(token).ConfigureAwait(false) && !await (await GetSettingsAsync(token).ConfigureAwait(false)).GetMysAdeptSecondMAGAttributeAsync(token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether this character is a Mystic Adept uses PPs and can purchase PPs in career mode
        /// </summary>
        public bool MysAdeptAllowPPCareer
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return UseMysticAdeptPPs && Settings.MysAdeptAllowPpCareer;
            }
        }

        /// <summary>
        /// Whether this character is a Mystic Adept uses PPs and can purchase PPs in career mode
        /// </summary>
        public async Task<bool> GetMysAdeptAllowPPCareerAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await GetUseMysticAdeptPPsAsync(token).ConfigureAwait(false)
                       && await (await GetSettingsAsync(token).ConfigureAwait(false))
                           .GetMysAdeptAllowPpCareerAsync(token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Could this character buy Power Points in career mode if the optional/house rule is enabled
        /// </summary>
        public bool CanAffordCareerPP
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    return MysAdeptAllowPPCareer
                           && Karma >= Settings.KarmaMysticAdeptPowerPoint
                           && MAG.TotalValue > MysticAdeptPowerPoints;
                }
            }
        }

        /// <summary>
        /// Could this character buy Power Points in career mode if the optional/house rule is enabled
        /// </summary>
        public async Task<bool> GetCanAffordCareerPPAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                return await GetMysAdeptAllowPPCareerAsync(token).ConfigureAwait(false)
                       && await GetKarmaAsync(token).ConfigureAwait(false) >=
                       await (await GetSettingsAsync(token).ConfigureAwait(false))
                           .GetKarmaMysticAdeptPowerPointAsync(token).ConfigureAwait(false)
                       && await (await GetAttributeAsync("MAG", token: token).ConfigureAwait(false))
                           .GetTotalValueAsync(token).ConfigureAwait(false) >
                       await GetMysticAdeptPowerPointsAsync(token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Whether the character is allowed to gain free spells that are limited to the Touch range.
        /// </summary>
        public ValueTuple<bool, bool> AllowFreeSpells()
        {
            using (LockObject.EnterReadLock())
            {
                //Free Spells (typically from Dedicated Spellslinger or custom Improvements) are only handled manually
                //in Career Mode. Create mode manages itself.
                int intFreeGenericSpells = ImprovementManager.ValueOf(this, Improvement.ImprovementType.FreeSpells)
                    .StandardRound();
                int intFreeTouchOnlySpells = 0;
                foreach (Improvement imp in ImprovementManager.GetCachedImprovementListForValueOf(this,
                             Improvement.ImprovementType.FreeSpellsATT))
                {
                    int intAttValue = GetAttribute(imp.ImprovedName).TotalValue;
                    if (imp.UniqueName.Contains("half"))
                        intAttValue = intAttValue.DivAwayFromZero(2);
                    if (imp.UniqueName.Contains("touchonly"))
                        intFreeTouchOnlySpells += intAttValue;
                    else
                        intFreeGenericSpells += intAttValue;
                }

                foreach (Improvement imp in ImprovementManager.GetCachedImprovementListForValueOf(this,
                             Improvement.ImprovementType.FreeSpellsSkill))
                {
                    Skill skill = SkillsSection.GetActiveSkill(imp.ImprovedName);
                    int intSkillValue = SkillsSection.GetActiveSkill(imp.ImprovedName).TotalBaseRating;
                    if (imp.UniqueName.Contains("half"))
                        intSkillValue = intSkillValue.DivAwayFromZero(2);
                    if (imp.UniqueName.Contains("touchonly"))
                        intFreeTouchOnlySpells += intSkillValue;
                    else
                        intFreeGenericSpells += intSkillValue;
                    //TODO: I don't like this being hardcoded, even though I know full well CGL are never going to reuse this
                    intFreeGenericSpells += skill.Specializations.Count(spec =>
                        Spells.Any(spell => spell.Category == spec.Name && !spell.FreeBonus));
                }

                int intTotalFreeNonTouchSpellsCount = Spells.Count(spell =>
                    spell.FreeBonus && spell.Range != "T" && spell.Range != "T (A)");
                int intTotalFreeTouchOnlySpellsCount = Spells.Count(spell =>
                    spell.FreeBonus && (spell.Range == "T" || spell.Range == "T (A)"));
                return new ValueTuple<bool, bool>(intFreeTouchOnlySpells > intTotalFreeTouchOnlySpellsCount,
                    intFreeGenericSpells > intTotalFreeNonTouchSpellsCount +
                    Math.Max(intTotalFreeTouchOnlySpellsCount - intFreeTouchOnlySpells, 0));
            }
        }

        /// <summary>
        /// Whether the character is allowed to gain free spells that are limited to the Touch range.
        /// </summary>
        public async Task<ValueTuple<bool, bool>> AllowFreeSpellsAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                //Free Spells (typically from Dedicated Spellslinger or custom Improvements) are only handled manually
                //in Career Mode. Create mode manages itself.
                int intFreeGenericSpells = (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.FreeSpells, token: token).ConfigureAwait(false))
                    .StandardRound();
                int intFreeTouchOnlySpells = 0;
                foreach (Improvement imp in await ImprovementManager.GetCachedImprovementListForValueOfAsync(this,
                             Improvement.ImprovementType.FreeSpellsATT, token: token).ConfigureAwait(false))
                {
                    int intAttValue = await (await GetAttributeAsync(imp.ImprovedName, token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false);
                    if (imp.UniqueName.Contains("half"))
                        intAttValue = intAttValue.DivAwayFromZero(2);
                    if (imp.UniqueName.Contains("touchonly"))
                        intFreeTouchOnlySpells += intAttValue;
                    else
                        intFreeGenericSpells += intAttValue;
                }

                ThreadSafeObservableCollection<Spell> lstSpells = await GetSpellsAsync(token).ConfigureAwait(false);
                SkillsSection objSkillsSection = await GetSkillsSectionAsync(token).ConfigureAwait(false);
                foreach (Improvement imp in await ImprovementManager.GetCachedImprovementListForValueOfAsync(this,
                             Improvement.ImprovementType.FreeSpellsSkill, token: token).ConfigureAwait(false))
                {
                    Skill skill = await objSkillsSection.GetActiveSkillAsync(imp.ImprovedName, token).ConfigureAwait(false);
                    int intSkillValue = (await objSkillsSection.GetActiveSkillAsync(imp.ImprovedName, token).ConfigureAwait(false)).TotalBaseRating;
                    if (imp.UniqueName.Contains("half"))
                        intSkillValue = intSkillValue.DivAwayFromZero(2);
                    if (imp.UniqueName.Contains("touchonly"))
                        intFreeTouchOnlySpells += intSkillValue;
                    else
                        intFreeGenericSpells += intSkillValue;
                    //TODO: I don't like this being hardcoded, even though I know full well CGL are never going to reuse this
                    intFreeGenericSpells += await skill.Specializations.CountAsync(async spec =>
                    {
                        string strSpecName = await spec.GetNameAsync(token).ConfigureAwait(false);
                        return await lstSpells.AnyAsync(spell => spell.Category == strSpecName && !spell.FreeBonus,
                            token: token).ConfigureAwait(false);
                    }, token).ConfigureAwait(false);
                }

                int intTotalFreeNonTouchSpellsCount = await lstSpells.CountAsync(spell =>
                    spell.FreeBonus && spell.Range != "T" && spell.Range != "T (A)", token: token).ConfigureAwait(false);
                int intTotalFreeTouchOnlySpellsCount = await lstSpells.CountAsync(spell =>
                    spell.FreeBonus && (spell.Range == "T" || spell.Range == "T (A)"), token: token).ConfigureAwait(false);
                return new ValueTuple<bool, bool>(intFreeTouchOnlySpells > intTotalFreeTouchOnlySpellsCount,
                    intFreeGenericSpells > intTotalFreeNonTouchSpellsCount +
                    Math.Max(intTotalFreeTouchOnlySpellsCount - intFreeTouchOnlySpells, 0));
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;

        private readonly ConcurrentHashSet<PropertyChangedAsyncEventHandler> _setPropertyChangedAsync =
            new ConcurrentHashSet<PropertyChangedAsyncEventHandler>();

        public event PropertyChangedAsyncEventHandler PropertyChangedAsync
        {
            add => _setPropertyChangedAsync.TryAdd(value);
            remove => _setPropertyChangedAsync.Remove(value);
        }

        public event MultiplePropertiesChangedEventHandler MultiplePropertiesChanged;

        private readonly ConcurrentHashSet<MultiplePropertiesChangedAsyncEventHandler> _setMultiplePropertiesChangedAsync =
            new ConcurrentHashSet<MultiplePropertiesChangedAsyncEventHandler>();

        public event MultiplePropertiesChangedAsyncEventHandler MultiplePropertiesChangedAsync
        {
            add => _setMultiplePropertiesChangedAsync.TryAdd(value);
            remove => _setMultiplePropertiesChangedAsync.Remove(value);
        }

        // Kept separate for events that are meant to work off of changes to whatever settings the character even if they change
        public event PropertyChangedEventHandler SettingsPropertyChanged;

        private readonly List<PropertyChangedAsyncEventHandler> _lstSettingsPropertyChangedAsync =
            new List<PropertyChangedAsyncEventHandler>();

        public event PropertyChangedAsyncEventHandler SettingsPropertyChangedAsync
        {
            add
            {
                using (LockObject.EnterWriteLock())
                    _lstSettingsPropertyChangedAsync.Add(value);
            }
            remove
            {
                using (LockObject.EnterWriteLock())
                    _lstSettingsPropertyChangedAsync.Remove(value);
            }
        }

        public event MultiplePropertiesChangedEventHandler SettingsMultiplePropertiesChanged;

        private readonly List<MultiplePropertiesChangedAsyncEventHandler> _lstSettingsMultiplePropertiesChangedAsync =
            new List<MultiplePropertiesChangedAsyncEventHandler>();

        public event MultiplePropertiesChangedAsyncEventHandler SettingsMultiplePropertiesChangedAsync
        {
            add
            {
                using (LockObject.EnterWriteLock())
                    _lstSettingsMultiplePropertiesChangedAsync.Add(value);
            }
            remove
            {
                using (LockObject.EnterWriteLock())
                    _lstSettingsMultiplePropertiesChangedAsync.Remove(value);
            }
        }

        #region Static

        //A tree of dependencies. Once some of the properties are changed,
        //anything they depend on, also needs to raise OnChanged
        //This tree keeps track of dependencies
        private static readonly PropertyDependencyGraph<Character> s_CharacterDependencyGraph =
            new PropertyDependencyGraph<Character>(
                    new DependencyGraphNode<string, Character>(nameof(CurrentDisplayName),
                        new DependencyGraphNode<string, Character>(nameof(CharacterName),
                            new DependencyGraphNode<string, Character>(nameof(Alias)),
                            new DependencyGraphNode<string, Character>(nameof(Name), x => string.IsNullOrWhiteSpace(x.Alias), async (x, t) => string.IsNullOrWhiteSpace(await x.GetAliasAsync(t).ConfigureAwait(false)),
                                new DependencyGraphNode<string, Character>(nameof(Alias))
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayPowerPointsRemaining),
                        new DependencyGraphNode<string, Character>(nameof(PowerPointsTotal),
                            new DependencyGraphNode<string, Character>(nameof(UseMysticAdeptPPs),
                                new DependencyGraphNode<string, Character>(nameof(IsMysticAdept),
                                    new DependencyGraphNode<string, Character>(nameof(AdeptEnabled)),
                                    new DependencyGraphNode<string, Character>(nameof(MagicianEnabled))
                                )
                            ),
                            new DependencyGraphNode<string, Character>(nameof(MysticAdeptPowerPoints), x => x.UseMysticAdeptPPs, (x, t) => x.GetUseMysticAdeptPPsAsync(t),
                                new DependencyGraphNode<string, Character>(nameof(UseMysticAdeptPPs))
                            )
                        ),
                        new DependencyGraphNode<string, Character>(nameof(PowerPointsUsed))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(CanAffordCareerPP),
                        new DependencyGraphNode<string, Character>(nameof(MysAdeptAllowPPCareer),
                            new DependencyGraphNode<string, Character>(nameof(UseMysticAdeptPPs))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(MysticAdeptPowerPoints)),
                        new DependencyGraphNode<string, Character>(nameof(Karma))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(AddInitiationsAllowed),
                        new DependencyGraphNode<string, Character>(nameof(IgnoreRules)),
                        new DependencyGraphNode<string, Character>(nameof(Created))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(InitiationEnabled),
                        new DependencyGraphNode<string, Character>(nameof(MAGEnabled)),
                        new DependencyGraphNode<string, Character>(nameof(RESEnabled)),
                        new DependencyGraphNode<string, Character>(nameof(InitiationForceDisabled))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(InitiativeToolTip),
                        new DependencyGraphNode<string, Character>(nameof(Initiative),
                            new DependencyGraphNode<string, Character>(nameof(InitiativeDice)),
                            new DependencyGraphNode<string, Character>(nameof(InitiativeValue),
                                new DependencyGraphNode<string, Character>(nameof(WoundModifier))
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(AstralInitiativeToolTip),
                        new DependencyGraphNode<string, Character>(nameof(AstralInitiative),
                            new DependencyGraphNode<string, Character>(nameof(AstralInitiativeDice)),
                            new DependencyGraphNode<string, Character>(nameof(AstralInitiativeValue),
                                new DependencyGraphNode<string, Character>(nameof(WoundModifier))
                            )
                        ),
                        new DependencyGraphNode<string, Character>(nameof(MAGEnabled))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeToolTip),
                        new DependencyGraphNode<string, Character>(nameof(MatrixInitiative),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeDice),
                                new DependencyGraphNode<string, Character>(nameof(IsAI)),
                                new DependencyGraphNode<string, Character>(nameof(InitiativeDice), x => !x.IsAI, async (x, t) => !await x.GetIsAIAsync(t).ConfigureAwait(false),
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                )
                            ),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeValue),
                                new DependencyGraphNode<string, Character>(nameof(IsAI)),
                                new DependencyGraphNode<string, Character>(nameof(HomeNode), x => x.IsAI, (x, t) => x.GetIsAIAsync(t),
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                ),
                                new DependencyGraphNode<string, Character>(nameof(WoundModifier), x => x.IsAI, (x, t) => x.GetIsAIAsync(t),
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                ),
                                new DependencyGraphNode<string, Character>(nameof(InitiativeValue), x => !x.IsAI, async (x, t) => !await x.GetIsAIAsync(t).ConfigureAwait(false),
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                )
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeColdToolTip),
                        new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeCold),
                            new DependencyGraphNode<string, Character>(nameof(IsAI)),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiative), x => x.IsAI, (x, t) => x.GetIsAIAsync(t),
                                new DependencyGraphNode<string, Character>(nameof(IsAI))
                            ),
                            new DependencyGraphNode<string, Character>(nameof(ActiveCommlink), x => !x.IsAI, async (x, t) => !await x.GetIsAIAsync(t).ConfigureAwait(false),
                                new DependencyGraphNode<string, Character>(nameof(IsAI))
                            ),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeColdDice),
                                new DependencyGraphNode<string, Character>(nameof(IsAI)),
                                new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeDice), x => x.IsAI, (x, t) => x.GetIsAIAsync(t),
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                )
                            ),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeColdValue),
                                new DependencyGraphNode<string, Character>(nameof(ActiveCommlink), x => !x.IsAI, async (x, t) => !await x.GetIsAIAsync(t).ConfigureAwait(false),
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                ),
                                new DependencyGraphNode<string, Character>(nameof(IsAI)),
                                new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeValue), x => x.IsAI, (x, t) => x.GetIsAIAsync(t),
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                ),
                                new DependencyGraphNode<string, Character>(nameof(WoundModifier), x => !x.IsAI, async (x, t) => !await x.GetIsAIAsync(t).ConfigureAwait(false),
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                )
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeHotToolTip),
                        new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeHot),
                            new DependencyGraphNode<string, Character>(nameof(IsAI)),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiative), x => x.IsAI, (x, t) => x.GetIsAIAsync(t),
                                new DependencyGraphNode<string, Character>(nameof(IsAI))
                            ),
                            new DependencyGraphNode<string, Character>(nameof(ActiveCommlink), x => !x.IsAI, async (x, t) => !await x.GetIsAIAsync(t).ConfigureAwait(false),
                                new DependencyGraphNode<string, Character>(nameof(IsAI))
                            ),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeHotDice),
                                new DependencyGraphNode<string, Character>(nameof(IsAI)),
                                new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeDice), x => x.IsAI, (x, t) => x.GetIsAIAsync(t),
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                )
                            ),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeHotValue),
                                new DependencyGraphNode<string, Character>(nameof(ActiveCommlink), x => !x.IsAI, async (x, t) => !await x.GetIsAIAsync(t).ConfigureAwait(false),
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                ),
                                new DependencyGraphNode<string, Character>(nameof(IsAI)),
                                new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeValue), x => x.IsAI, (x, t) => x.GetIsAIAsync(t),
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                ),
                                new DependencyGraphNode<string, Character>(nameof(WoundModifier), x => !x.IsAI, async (x, t) => !await x.GetIsAIAsync(t).ConfigureAwait(false),
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                )
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(FormattedMetatype),
                        new DependencyGraphNode<string, Character>(nameof(DisplayMetatype),
                            new DependencyGraphNode<string, Character>(nameof(Metatype))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(MetavariantGuid)),
                        new DependencyGraphNode<string, Character>(nameof(DisplayMetavariant),
                            new DependencyGraphNode<string, Character>(nameof(Metavariant))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(IsSprite),
                        new DependencyGraphNode<string, Character>(nameof(IsFreeSprite),
                            new DependencyGraphNode<string, Character>(nameof(MetatypeCategory))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayMetatypeBP),
                        new DependencyGraphNode<string, Character>(nameof(MetatypeBP))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(PhysicalCMLabelText),
                        new DependencyGraphNode<string, Character>(nameof(IsAI)),
                        new DependencyGraphNode<string, Character>(nameof(HomeNode))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(PhysicalCMToolTip),
                        new DependencyGraphNode<string, Character>(nameof(PhysicalCM))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(StunCMToolTip),
                        new DependencyGraphNode<string, Character>(nameof(StunCM))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayStunCM),
                        new DependencyGraphNode<string, Character>(nameof(IsAI)),
                        new DependencyGraphNode<string, Character>(nameof(HomeNode)),
                        new DependencyGraphNode<string, Character>(nameof(StunCM), x => !x.IsAI || x.HomeNode != null, async (x, t) => !await x.GetIsAIAsync(t).ConfigureAwait(false) || await x.GetHomeNodeAsync(t).ConfigureAwait(false) != null)
                    ),
                    new DependencyGraphNode<string, Character>(nameof(StunCMLabelText),
                        new DependencyGraphNode<string, Character>(nameof(IsAI)),
                        new DependencyGraphNode<string, Character>(nameof(HomeNode))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SustainingPenalty),
                        new DependencyGraphNode<string, Character>(nameof(PsycheActive))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(WoundModifier),
                        new DependencyGraphNode<string, Character>(nameof(PhysicalCMFilled),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(PhysicalCM),
                            new DependencyGraphNode<string, Character>(nameof(IsAI)),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(StunCMFilled),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(StunCM),
                            new DependencyGraphNode<string, Character>(nameof(IsAI)),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(CMThreshold)),
                        new DependencyGraphNode<string, Character>(nameof(PhysicalCMThresholdOffset),
                            new DependencyGraphNode<string, Character>(nameof(StunCMFilled)),
                            new DependencyGraphNode<string, Character>(nameof(CMThreshold)),
                            new DependencyGraphNode<string, Character>(nameof(IsAI))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(StunCMThresholdOffset),
                            new DependencyGraphNode<string, Character>(nameof(PhysicalCMFilled)),
                            new DependencyGraphNode<string, Character>(nameof(CMThreshold)),
                            new DependencyGraphNode<string, Character>(nameof(IsAI))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(Encumbrance), x => x.Settings.DoEncumbrancePenaltyWoundModifier, async (x, t) =>
                            await (await x.GetSettingsAsync(t).ConfigureAwait(false)).GetDoEncumbrancePenaltyWoundModifierAsync(t).ConfigureAwait(false))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(CMThresholdOffsets),
                        new DependencyGraphNode<string, Character>(nameof(PhysicalCMThresholdOffset)),
                        new DependencyGraphNode<string, Character>(nameof(StunCMThresholdOffset))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(EffectiveBuildMethodUsesPriorityTables),
                        new DependencyGraphNode<string, Character>(nameof(EffectiveBuildMethod),
                            new DependencyGraphNode<string, Character>(nameof(IsCritter))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(EnableAutomaticStoryButton),
                        new DependencyGraphNode<string, Character>(nameof(EffectiveBuildMethodIsLifeModule),
                            new DependencyGraphNode<string, Character>(nameof(EffectiveBuildMethod))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DamageResistancePoolToolTip),
                        new DependencyGraphNode<string, Character>(nameof(DamageResistancePool),
                            new DependencyGraphNode<string, Character>(nameof(TotalArmorRating)),
                            new DependencyGraphNode<string, Character>(nameof(IsAI)),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode), x => x.IsAI, (x, t) => x.GetIsAIAsync(t),
                                new DependencyGraphNode<string, Character>(nameof(IsAI))
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(IsAI),
                        new DependencyGraphNode<string, Character>(nameof(DEPEnabled))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayDodge),
                        new DependencyGraphNode<string, Character>(nameof(Dodge),
                            new DependencyGraphNode<string, Character>(nameof(TotalBonusDodgeRating),
                                new DependencyGraphNode<string, Character>(nameof(WoundModifier)),
                                new DependencyGraphNode<string, Character>(nameof(SustainingPenalty))
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DodgeToolTip),
                        new DependencyGraphNode<string, Character>(nameof(DisplayDodge))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseIndirectDodgeToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIndirectDodge),
                            new DependencyGraphNode<string, Character>(nameof(Dodge))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseIndirectDodge),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIndirectDodge))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseIndirectSoakToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIndirectSoak),
                            new DependencyGraphNode<string, Character>(nameof(TotalArmorRating)),
                            new DependencyGraphNode<string, Character>(nameof(IsAI)),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode), x => x.IsAI, (x, t) => x.GetIsAIAsync(t),
                                new DependencyGraphNode<string, Character>(nameof(IsAI))
                            ),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseIndirectSoak),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIndirectSoak))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDirectSoakManaToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDirectSoakMana),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDirectSoakMana),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDirectSoakMana))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDirectSoakPhysicalToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDirectSoakPhysical),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDirectSoakPhysical),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDirectSoakPhysical))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDetectionToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDetection),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDetection),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDetection))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseBODToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseBOD),
                            new DependencyGraphNode<string, Character>(nameof(IsAI)),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode), x => x.IsAI, (x, t) => x.GetIsAIAsync(t),
                                new DependencyGraphNode<string, Character>(nameof(IsAI))
                            ),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseBOD),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseBOD))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseAGIToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseAGI),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseAGI),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseAGI))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseREAToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseREA),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseREA),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseREA))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseSTRToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseSTR),
                            new DependencyGraphNode<string, Character>(nameof(IsAI)),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode), x => x.IsAI, (x, t) => x.GetIsAIAsync(t),
                                new DependencyGraphNode<string, Character>(nameof(IsAI))
                            ),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseSTR),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseSTR))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseCHAToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseCHA),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseCHA),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseCHA))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseINTToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseINT),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseINT),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseINT))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseLOGToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseLOG),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseLOG),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseLOG))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseWILToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseWIL),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseWIL),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseWIL))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseIllusionManaToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIllusionMana),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseIllusionMana),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIllusionMana))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseIllusionPhysicalToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIllusionPhysical),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseIllusionPhysical),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIllusionPhysical))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseManipulationMentalToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseManipulationMental),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseManipulationMental),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseManipulationMental))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseManipulationPhysicalToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseManipulationPhysical),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance)),
                            new DependencyGraphNode<string, Character>(nameof(IsAI)),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode), x => x.IsAI, (x, t) => x.GetIsAIAsync(t),
                                new DependencyGraphNode<string, Character>(nameof(IsAI))
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseManipulationPhysical),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseManipulationPhysical))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(TotalArmorRatingToolTip),
                        new DependencyGraphNode<string, Character>(nameof(TotalArmorRating),
                            new DependencyGraphNode<string, Character>(nameof(GetArmorRating),
                                new DependencyGraphNode<string, Character>(nameof(GetArmorRatingWithImprovement))
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(TotalFireArmorRating),
                        new DependencyGraphNode<string, Character>(nameof(GetArmorRating))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(TotalColdArmorRating),
                        new DependencyGraphNode<string, Character>(nameof(GetArmorRating))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(TotalElectricityArmorRating),
                        new DependencyGraphNode<string, Character>(nameof(GetArmorRating))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(TotalAcidArmorRating),
                        new DependencyGraphNode<string, Character>(nameof(GetArmorRating))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(TotalFallingArmorRating),
                        new DependencyGraphNode<string, Character>(nameof(GetArmorRating))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayEssence),
                        new DependencyGraphNode<string, Character>(nameof(Essence),
                            new DependencyGraphNode<string, Character>(nameof(CyberwareEssence)),
                            new DependencyGraphNode<string, Character>(nameof(BiowareEssence)),
                            new DependencyGraphNode<string, Character>(nameof(PrototypeTranshumanEssenceUsed)),
                            new DependencyGraphNode<string, Character>(nameof(EssenceHole))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(ComposureToolTip),
                        new DependencyGraphNode<string, Character>(nameof(Composure),
                            new DependencyGraphNode<string, Character>(nameof(SustainingPenalty)),
                            new DependencyGraphNode<string, Character>(nameof(WoundModifier))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SurpriseToolTip),
                        new DependencyGraphNode<string, Character>(nameof(Surprise),
                            new DependencyGraphNode<string, Character>(nameof(WoundModifier)),
                            new DependencyGraphNode<string, Character>(nameof(SustainingPenalty))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(JudgeIntentionsToolTip),
                        new DependencyGraphNode<string, Character>(nameof(JudgeIntentions),
                            new DependencyGraphNode<string, Character>(nameof(WoundModifier)),
                            new DependencyGraphNode<string, Character>(nameof(SustainingPenalty))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(JudgeIntentionsResistToolTip),
                        new DependencyGraphNode<string, Character>(nameof(JudgeIntentionsResist))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(LiftAndCarryToolTip),
                        new DependencyGraphNode<string, Character>(nameof(LiftAndCarry),
                            new DependencyGraphNode<string, Character>(nameof(WoundModifier)),
                            new DependencyGraphNode<string, Character>(nameof(SustainingPenalty))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(MemoryToolTip),
                        new DependencyGraphNode<string, Character>(nameof(Memory),
                            new DependencyGraphNode<string, Character>(nameof(WoundModifier)),
                            new DependencyGraphNode<string, Character>(nameof(SustainingPenalty))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(LiftAndCarryLimits),
                        new DependencyGraphNode<string, Character>(nameof(LiftLimit),
                            new DependencyGraphNode<string, Character>(nameof(BaseLiftLimit)),
                            new DependencyGraphNode<string, Character>(nameof(CurrentLiftCarryHits))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(CarryLimit),
                            new DependencyGraphNode<string, Character>(nameof(BaseCarryLimit)),
                            new DependencyGraphNode<string, Character>(nameof(CurrentLiftCarryHits))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(Encumbrance),
                        new DependencyGraphNode<string, Character>(nameof(CarryLimit)),
                        new DependencyGraphNode<string, Character>(nameof(TotalCarriedWeight)),
                        new DependencyGraphNode<string, Character>(nameof(EncumbranceInterval))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayTotalCarriedWeight),
                        new DependencyGraphNode<string, Character>(nameof(CarryLimit)),
                        new DependencyGraphNode<string, Character>(nameof(TotalCarriedWeight))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayCyberwareEssence),
                        new DependencyGraphNode<string, Character>(nameof(CyberwareEssence))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayBiowareEssence),
                        new DependencyGraphNode<string, Character>(nameof(BiowareEssence))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayEssenceHole),
                        new DependencyGraphNode<string, Character>(nameof(EssenceHole))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayPrototypeTranshumanEssenceUsed),
                        new DependencyGraphNode<string, Character>(nameof(PrototypeTranshumanEssenceUsed)),
                        new DependencyGraphNode<string, Character>(nameof(PrototypeTranshuman))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(IsPrototypeTranshuman),
                        new DependencyGraphNode<string, Character>(nameof(PrototypeTranshuman))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayNuyen),
                        new DependencyGraphNode<string, Character>(nameof(Nuyen))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayKarma),
                        new DependencyGraphNode<string, Character>(nameof(Karma))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayTotalStartingNuyen),
                        new DependencyGraphNode<string, Character>(nameof(TotalStartingNuyen),
                            new DependencyGraphNode<string, Character>(nameof(StartingNuyen)),
                            new DependencyGraphNode<string, Character>(nameof(HasStolenNuyen)),
                            new DependencyGraphNode<string, Character>(nameof(NuyenBP)),
                            new DependencyGraphNode<string, Character>(nameof(TotalNuyenMaximumBP),
                                new DependencyGraphNode<string, Character>(nameof(IgnoreRules))
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(GetAvailableNuyen),
                        new DependencyGraphNode<string, Character>(nameof(CalculateNuyenCreateMode), x => !x.Created, async (x, t) => !await x.GetCreatedAsync(t).ConfigureAwait(false),
                            new DependencyGraphNode<string, Character>(nameof(TotalStartingNuyen))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(Nuyen), x => x.Created, (x, t) => x.GetCreatedAsync(t))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayCareerNuyen),
                        new DependencyGraphNode<string, Character>(nameof(CareerNuyen))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayCareerKarma),
                        new DependencyGraphNode<string, Character>(nameof(CareerKarma))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(StreetCredTooltip),
                        new DependencyGraphNode<string, Character>(nameof(TotalStreetCred),
                            new DependencyGraphNode<string, Character>(nameof(StreetCred)),
                            new DependencyGraphNode<string, Character>(nameof(CalculatedStreetCred),
                                new DependencyGraphNode<string, Character>(nameof(CareerKarma)),
                                new DependencyGraphNode<string, Character>(nameof(BurntStreetCred))
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(CanBurnStreetCred),
                        new DependencyGraphNode<string, Character>(nameof(TotalStreetCred))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(NotorietyTooltip),
                        new DependencyGraphNode<string, Character>(nameof(TotalNotoriety),
                            new DependencyGraphNode<string, Character>(nameof(Notoriety)),
                            new DependencyGraphNode<string, Character>(nameof(CalculatedNotoriety)),
                            new DependencyGraphNode<string, Character>(nameof(BurntStreetCred))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(PublicAwarenessTooltip),
                        new DependencyGraphNode<string, Character>(nameof(TotalPublicAwareness),
                            new DependencyGraphNode<string, Character>(nameof(Erased)),
                            new DependencyGraphNode<string, Character>(nameof(CalculatedPublicAwareness),
                                new DependencyGraphNode<string, Character>(nameof(PublicAwareness)),
                                new DependencyGraphNode<string, Character>(nameof(TotalStreetCred),
                                    x => x.Settings.UseCalculatedPublicAwareness, async (x, t) => await (await x.GetSettingsAsync(t).ConfigureAwait(false)).GetUseCalculatedPublicAwarenessAsync(t).ConfigureAwait(false)),
                                new DependencyGraphNode<string, Character>(nameof(TotalNotoriety),
                                    x => x.Settings.UseCalculatedPublicAwareness, async (x, t) => await (await x.GetSettingsAsync(t).ConfigureAwait(false)).GetUseCalculatedPublicAwarenessAsync(t).ConfigureAwait(false))
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(CareerDisplayStreetCred),
                        new DependencyGraphNode<string, Character>(nameof(TotalStreetCred))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(CareerDisplayNotoriety),
                        new DependencyGraphNode<string, Character>(nameof(TotalNotoriety))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(CareerDisplayPublicAwareness),
                        new DependencyGraphNode<string, Character>(nameof(TotalPublicAwareness))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(AddBiowareEnabled),
                        new DependencyGraphNode<string, Character>(nameof(CyberwareDisabled)),
                        new DependencyGraphNode<string, Character>(nameof(IsAI))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(AddCyberwareEnabled),
                        new DependencyGraphNode<string, Character>(nameof(CyberwareDisabled)),
                        new DependencyGraphNode<string, Character>(nameof(IsAI))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(HasMentorSpirit),
                        new DependencyGraphNode<string, Character>(nameof(MentorSpirits))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(CharacterGrammaticGender),
                        new DependencyGraphNode<string, Character>(nameof(Gender))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(FirstMentorSpiritDisplayName),
                        new DependencyGraphNode<string, Character>(nameof(MentorSpirits))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(FirstMentorSpiritDisplayInformation),
                        new DependencyGraphNode<string, Character>(nameof(MentorSpirits))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(LimitPhysicalToolTip),
                        new DependencyGraphNode<string, Character>(nameof(LimitPhysical),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(LimitMentalToolTip),
                        new DependencyGraphNode<string, Character>(nameof(LimitMental),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(LimitSocialToolTip),
                        new DependencyGraphNode<string, Character>(nameof(LimitSocial),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(LimitAstralToolTip),
                        new DependencyGraphNode<string, Character>(nameof(LimitAstral),
                            new DependencyGraphNode<string, Character>(nameof(LimitMental)),
                            new DependencyGraphNode<string, Character>(nameof(LimitSocial))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayMovement),
                        new DependencyGraphNode<string, Character>(nameof(GetMovement),
                            new DependencyGraphNode<string, Character>(nameof(Movement)),
                            new DependencyGraphNode<string, Character>(nameof(CalculatedMovement),
                                new DependencyGraphNode<string, Character>(nameof(WalkingRate),
                                    new DependencyGraphNode<string, Character>(nameof(CurrentWalkingRateString),
                                        new DependencyGraphNode<string, Character>(nameof(WalkString),
                                            x => x.AttributeSection.AttributeCategory ==
                                                 AttributeCategory.Standard,
                                            async (x, t) => await (await x.GetAttributeSectionAsync(t).ConfigureAwait(false)).GetAttributeCategoryAsync(t).ConfigureAwait(false) ==
                                                            AttributeCategory.Standard),
                                        new DependencyGraphNode<string, Character>(nameof(WalkAltString),
                                            x => x.AttributeSection.AttributeCategory !=
                                                 AttributeCategory.Standard,
                                            async (x, t) => await (await x.GetAttributeSectionAsync(t).ConfigureAwait(false)).GetAttributeCategoryAsync(t).ConfigureAwait(false) !=
                                                            AttributeCategory.Standard)
                                    )
                                ),
                                new DependencyGraphNode<string, Character>(nameof(RunningRate),
                                    new DependencyGraphNode<string, Character>(nameof(CurrentRunningRateString),
                                        new DependencyGraphNode<string, Character>(nameof(RunString),
                                            x => x.AttributeSection.AttributeCategory ==
                                                 AttributeCategory.Standard,
                                            async (x, t) => await (await x.GetAttributeSectionAsync(t).ConfigureAwait(false)).GetAttributeCategoryAsync(t).ConfigureAwait(false) ==
                                                            AttributeCategory.Standard),
                                        new DependencyGraphNode<string, Character>(nameof(RunAltString),
                                            x => x.AttributeSection.AttributeCategory !=
                                                 AttributeCategory.Standard,
                                            async (x, t) => await (await x.GetAttributeSectionAsync(t).ConfigureAwait(false)).GetAttributeCategoryAsync(t).ConfigureAwait(false) !=
                                                            AttributeCategory.Standard)
                                    )
                                ),
                                new DependencyGraphNode<string, Character>(nameof(SprintingRate),
                                    new DependencyGraphNode<string, Character>(nameof(CurrentSprintingRateString),
                                        new DependencyGraphNode<string, Character>(nameof(SprintString),
                                            x => x.AttributeSection.AttributeCategory ==
                                                 AttributeCategory.Standard,
                                            async (x, t) => await (await x.GetAttributeSectionAsync(t).ConfigureAwait(false)).GetAttributeCategoryAsync(t).ConfigureAwait(false) ==
                                                            AttributeCategory.Standard),
                                        new DependencyGraphNode<string, Character>(nameof(SprintAltString),
                                            x => x.AttributeSection.AttributeCategory !=
                                                 AttributeCategory.Standard,
                                            async (x, t) => await (await x.GetAttributeSectionAsync(t).ConfigureAwait(false)).GetAttributeCategoryAsync(t).ConfigureAwait(false) !=
                                                            AttributeCategory.Standard)
                                    )
                                )
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySwim),
                        new DependencyGraphNode<string, Character>(nameof(GetSwim),
                            new DependencyGraphNode<string, Character>(nameof(Movement)),
                            new DependencyGraphNode<string, Character>(nameof(CalculatedMovement))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayFly),
                        new DependencyGraphNode<string, Character>(nameof(GetFly),
                            new DependencyGraphNode<string, Character>(nameof(Movement)),
                            new DependencyGraphNode<string, Character>(nameof(CalculatedMovement))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayNegativeQualityKarma),
                        new DependencyGraphNode<string, Character>(nameof(NegativeQualityKarma),
                            new DependencyGraphNode<string, Character>(nameof(EnemyKarma)),
                            new DependencyGraphNode<string, Character>(nameof(Contacts)),
                            new DependencyGraphNode<string, Character>(nameof(Qualities))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(NegativeQualityLimitKarma),
                            new DependencyGraphNode<string, Character>(nameof(EnemyKarma)),
                            new DependencyGraphNode<string, Character>(nameof(Contacts)),
                            new DependencyGraphNode<string, Character>(nameof(Qualities))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayPositiveQualityKarma),
                        new DependencyGraphNode<string, Character>(nameof(PositiveQualityLimitKarma),
                            new DependencyGraphNode<string, Character>(nameof(Contacts)),
                            new DependencyGraphNode<string, Character>(nameof(Qualities))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(PositiveQualityKarma),
                            new DependencyGraphNode<string, Character>(nameof(Contacts)),
                            new DependencyGraphNode<string, Character>(nameof(Qualities))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayMetagenicQualityKarma),
                        new DependencyGraphNode<string, Character>(nameof(MetagenicPositiveQualityKarma),
                        new DependencyGraphNode<string, Character>(nameof(MetagenicNegativeQualityKarma),
                            new DependencyGraphNode<string, Character>(nameof(IsChangeling)),
                            new DependencyGraphNode<string, Character>(nameof(Qualities))
                        ))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(AstralReputationTooltip),
                        new DependencyGraphNode<string, Character>(nameof(TotalAstralReputation),
                            new DependencyGraphNode<string, Character>(nameof(AstralReputation))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(WildReputationTooltip),
                        new DependencyGraphNode<string, Character>(nameof(TotalWildReputation),
                            new DependencyGraphNode<string, Character>(nameof(WildReputation))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(EdgeRemainingString),
                        new DependencyGraphNode<string, Character>(nameof(EdgeRemaining),
                            new DependencyGraphNode<string, Character>(nameof(EdgeUsed))
                        )
                    )
                );

        #endregion Static

        [NotifyPropertyChangedInvocator]
        public void OnPropertyChanged([CallerMemberName] string strPropertyName = null)
        {
            this.OnMultiplePropertyChanged(strPropertyName);
        }

        public Task OnPropertyChangedAsync(string strPropertyName, CancellationToken token = default)
        {
            return this.OnMultiplePropertyChangedAsync(token, strPropertyName);
        }

        private static readonly HashSet<string> s_SetPropertyNamesWithCachedValues = new HashSet<string>
        {
            nameof(Created),
            nameof(CharacterGrammaticGender),
            nameof(TotalStartingNuyen),
            nameof(ContactPoints),
            nameof(BaseCarryLimit),
            nameof(BaseLiftLimit),
            nameof(EncumbranceInterval),
            nameof(TotalArmorRating),
            nameof(TotalFireArmorRating),
            nameof(TotalColdArmorRating),
            nameof(TotalElectricityArmorRating),
            nameof(TotalAcidArmorRating),
            nameof(TotalFallingArmorRating),
            nameof(TrustFund),
            nameof(RestrictedGear),
            nameof(TotalCarriedWeight),
            nameof(PowerPointsUsed),
            nameof(CyberwareEssence),
            nameof(BiowareEssence),
            nameof(EssenceHole),
            nameof(PrototypeTranshumanEssenceUsed),
            nameof(CareerNuyen),
            nameof(CareerKarma),
            nameof(BoundSpiritLimit),
            nameof(RegisteredSpriteLimit),
            nameof(InitiationEnabled),
            nameof(RedlinerBonus),
            nameof(EnemyKarma),
            nameof(Qualities),
            nameof(MetagenicLimit)
        };

        public void OnMultiplePropertiesChanged(IReadOnlyCollection<string> lstPropertyNames)
        {
            using (LockObject.EnterUpgradeableReadLock())
            {
                HashSet<string> setNamesOfChangedProperties = null;
                try
                {
                    foreach (string strPropertyName in lstPropertyNames)
                    {
                        if (setNamesOfChangedProperties == null)
                            setNamesOfChangedProperties
                                = s_CharacterDependencyGraph.GetWithAllDependents(this, strPropertyName, true);
                        else
                        {
                            foreach (string strLoopChangedProperty in s_CharacterDependencyGraph
                                         .GetWithAllDependentsEnumerable(
                                             this, strPropertyName))
                                setNamesOfChangedProperties.Add(strLoopChangedProperty);
                        }
                    }

                    if (setNamesOfChangedProperties == null || setNamesOfChangedProperties.Count == 0)
                        return;

                    if (setNamesOfChangedProperties.Overlaps(s_SetPropertyNamesWithCachedValues))
                    {
                        using (LockObject.EnterWriteLock())
                        {
                            if (setNamesOfChangedProperties.Contains(nameof(Created)))
                                ImprovementManager.ClearCachedValues(this);
                            if (setNamesOfChangedProperties.Contains(nameof(CharacterGrammaticGender)))
                                _strCachedCharacterGrammaticGender = string.Empty;
                            if (setNamesOfChangedProperties.Contains(nameof(TotalStartingNuyen)))
                                _decCachedTotalStartingNuyen = decimal.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(ContactPoints)))
                                _intCachedContactPoints = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(BaseCarryLimit)))
                                _decCachedBaseCarryLimit = decimal.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(BaseLiftLimit)))
                                _decCachedBaseLiftLimit = decimal.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(EncumbranceInterval)))
                                _decCachedEncumbranceInterval = decimal.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(TotalArmorRating)))
                                _intCachedTotalArmorRating = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(TotalFireArmorRating)))
                                _intCachedTotalFireArmorRating = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(TotalColdArmorRating)))
                                _intCachedTotalColdArmorRating = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(TotalElectricityArmorRating)))
                                _intCachedTotalElectricityArmorRating = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(TotalAcidArmorRating)))
                                _intCachedTotalAcidArmorRating = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(TotalFallingArmorRating)))
                                _intCachedTotalFallingArmorRating = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(TrustFund)))
                                _intCachedTrustFund = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(RestrictedGear)))
                                _intCachedRestrictedGear = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(TotalCarriedWeight)))
                                _decCachedTotalCarriedWeight = decimal.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(PowerPointsUsed)))
                                _decCachedPowerPointsUsed = decimal.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(CyberwareEssence)))
                                _decCachedCyberwareEssence = decimal.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(BiowareEssence))
                                || setNamesOfChangedProperties.Contains(nameof(PrototypeTranshumanEssenceUsed)))
                            {
                                _decCachedBiowareEssence = decimal.MinValue;
                                _decCachedPrototypeTranshumanEssenceUsed = decimal.MinValue;
                            }
                            if (setNamesOfChangedProperties.Contains(nameof(EssenceHole)))
                                _decCachedEssenceHole = decimal.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(CareerNuyen)))
                                _decCachedCareerNuyen = decimal.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(CareerKarma)))
                                _intCachedCareerKarma = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(BoundSpiritLimit)))
                                _intBoundSpiritLimit = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(RegisteredSpriteLimit)))
                                _intRegisteredSpriteLimit = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(InitiationEnabled)))
                                _intCachedInitiationEnabled = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(RedlinerBonus)))
                                _intCachedRedlinerBonus = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(HasAnyQualitiesWithQualityLevels)))
                                _intCachedHasAnyQualitiesWithQualityLevels = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(EnemyKarma)))
                                _intCachedEnemyKarma = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(Qualities)))
                            {
                                _intCachedNegativeQualities = int.MinValue;
                                _intCachedNegativeQualityLimitKarma = int.MinValue;
                                _intCachedPositiveQualityLimitKarma = int.MinValue;
                                _intCachedPositiveQualities = int.MinValue;
                                _intCachedMetagenicNegativeQualities = int.MinValue;
                                _intCachedMetagenicPositiveQualities = int.MinValue;
                            }
                            else if (setNamesOfChangedProperties.Contains(nameof(MetagenicLimit)))
                            {
                                _intCachedMetagenicNegativeQualities = int.MinValue;
                                _intCachedMetagenicPositiveQualities = int.MinValue;
                            }
                        }
                    }

                    if (setNamesOfChangedProperties.Contains(nameof(HasAnyQualitiesWithQualityLevels)))
                        ProcessQualityLevels(); // Has to be called first in case created qualities create more processing requirements
                    if (setNamesOfChangedProperties.Contains(nameof(DealerConnectionDiscount)))
                        RefreshDealerConnectionDiscounts();
                    if (setNamesOfChangedProperties.Contains(nameof(BlackMarketDiscount)))
                        RefreshBlackMarketDiscounts();
                    if (setNamesOfChangedProperties.Contains(nameof(RedlinerBonus)))
                        RefreshRedlinerImprovements();
                    if (setNamesOfChangedProperties.Contains(nameof(Essence)) ||
                        setNamesOfChangedProperties.Contains(nameof(EssenceAtSpecialStart)))
                    {
                        if (setNamesOfChangedProperties.Contains(nameof(Essence)))
                            ResetCachedEssence();
                        RefreshEssenceLossImprovements();
                    }
                    if (setNamesOfChangedProperties.Contains(nameof(Encumbrance)))
                        RefreshEncumbrance();
                    if (setNamesOfChangedProperties.Contains(nameof(ArmorEncumbrance)))
                        RefreshArmorEncumbrance();
                    if (setNamesOfChangedProperties.Contains(nameof(WoundModifier)))
                        RefreshWoundPenalties();
                    if (setNamesOfChangedProperties.Contains(nameof(SustainingPenalty)))
                        RefreshSustainingPenalties();
                    if (setNamesOfChangedProperties.Contains(nameof(TotalAstralReputation)))
                        RefreshAstralReputationImprovements();

                    if (_setMultiplePropertiesChangedAsync.Count > 0)
                    {
                        MultiplePropertiesChangedEventArgs objArgs =
                            new MultiplePropertiesChangedEventArgs(setNamesOfChangedProperties.ToArray());
                        List<Func<Task>> lstFuncs = new List<Func<Task>>(_setMultiplePropertiesChangedAsync.Count);
                        foreach (MultiplePropertiesChangedAsyncEventHandler objEvent in _setMultiplePropertiesChangedAsync)
                        {
                            lstFuncs.Add(() => objEvent.Invoke(this, objArgs));
                        }

                        Utils.RunWithoutThreadLock(lstFuncs);
                        if (MultiplePropertiesChanged != null)
                        {
                            Utils.RunOnMainThread(() =>
                            {
                                // ReSharper disable once AccessToModifiedClosure
                                MultiplePropertiesChanged?.Invoke(this, objArgs);
                            });
                        }
                    }
                    else if (MultiplePropertiesChanged != null)
                    {
                        MultiplePropertiesChangedEventArgs objArgs =
                            new MultiplePropertiesChangedEventArgs(setNamesOfChangedProperties.ToArray());
                        Utils.RunOnMainThread(() =>
                        {
                            // ReSharper disable once AccessToModifiedClosure
                            MultiplePropertiesChanged?.Invoke(this, objArgs);
                        });
                    }

                    if (_setPropertyChangedAsync.Count > 0)
                    {
                        List<PropertyChangedEventArgs> lstArgsList = setNamesOfChangedProperties.Select(x => new PropertyChangedEventArgs(x)).ToList();
                        List<Func<Task>> lstFuncs = new List<Func<Task>>(lstArgsList.Count * _setPropertyChangedAsync.Count);
                        foreach (PropertyChangedAsyncEventHandler objEvent in _setPropertyChangedAsync)
                        {
                            foreach (PropertyChangedEventArgs objArg in lstArgsList)
                                lstFuncs.Add(() => objEvent.Invoke(this, objArg));
                        }

                        Utils.RunWithoutThreadLock(lstFuncs);
                        if (PropertyChanged != null)
                        {
                            Utils.RunOnMainThread(() =>
                            {
                                if (PropertyChanged != null)
                                {
                                    // ReSharper disable once AccessToModifiedClosure
                                    foreach (PropertyChangedEventArgs objArgs in lstArgsList)
                                    {
                                        PropertyChanged.Invoke(this, objArgs);
                                    }
                                }
                            });
                        }
                    }
                    else if (PropertyChanged != null)
                    {
                        Utils.RunOnMainThread(() =>
                        {
                            if (PropertyChanged != null)
                            {
                                // ReSharper disable once AccessToModifiedClosure
                                foreach (string strPropertyToChange in setNamesOfChangedProperties)
                                {
                                    PropertyChanged.Invoke(this, new PropertyChangedEventArgs(strPropertyToChange));
                                }
                            }
                        });
                    }

                    if (!Created)
                    {
                        // If in create mode, update the Force for Spirits and Sprites (equal to Magician MAG Rating or RES Rating).
                        if (setNamesOfChangedProperties.Contains(nameof(MaxSpriteLevel)))
                        {
                            int intMaxLevel = MaxSpriteLevel;
                            if (setNamesOfChangedProperties.Contains(nameof(MaxSpiritForce)))
                            {
                                int intMaxForce = MaxSpiritForce;
                                foreach (Spirit objSpirit in Spirits)
                                {
                                    using (objSpirit.LockObject.EnterUpgradeableReadLock())
                                    {
                                        switch (objSpirit.EntityType)
                                        {
                                            case SpiritType.Sprite:
                                                objSpirit.Force = intMaxLevel;
                                                break;
                                            case SpiritType.Spirit:
                                                objSpirit.Force = intMaxForce;
                                                break;
                                        }
                                    }
                                }
                            }
                            else
                            {
                                foreach (Spirit objSpirit in Spirits)
                                {
                                    using (objSpirit.LockObject.EnterUpgradeableReadLock())
                                    {
                                        if (objSpirit.EntityType == SpiritType.Sprite)
                                            objSpirit.Force = intMaxLevel;
                                    }
                                }
                            }
                        }
                        else if (setNamesOfChangedProperties.Contains(nameof(MaxSpiritForce)))
                        {
                            int intMaxForce = MaxSpiritForce;
                            foreach (Spirit objSpirit in Spirits)
                            {
                                using (objSpirit.LockObject.EnterUpgradeableReadLock())
                                {
                                    if (objSpirit.EntityType == SpiritType.Spirit)
                                        objSpirit.Force = intMaxForce;
                                }
                            }
                        }
                    }
                }
                finally
                {
                    if (setNamesOfChangedProperties != null)
                        Utils.StringHashSetPool.Return(ref setNamesOfChangedProperties);
                }
            }
        }

        public async Task OnMultiplePropertiesChangedAsync(IReadOnlyCollection<string> lstPropertyNames, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                HashSet<string> setNamesOfChangedProperties = null;
                try
                {
                    token.ThrowIfCancellationRequested();
                    foreach (string strPropertyName in lstPropertyNames)
                    {
                        if (setNamesOfChangedProperties == null)
                            setNamesOfChangedProperties
                                = await s_CharacterDependencyGraph.GetWithAllDependentsAsync(this, strPropertyName, true, token).ConfigureAwait(false);
                        else
                        {
                            foreach (string strLoopChangedProperty in await s_CharacterDependencyGraph
                                         .GetWithAllDependentsEnumerableAsync(
                                             this, strPropertyName, token).ConfigureAwait(false))
                                setNamesOfChangedProperties.Add(strLoopChangedProperty);
                        }
                    }

                    if (setNamesOfChangedProperties == null || setNamesOfChangedProperties.Count == 0)
                        return;

                    if (setNamesOfChangedProperties.Overlaps(s_SetPropertyNamesWithCachedValues))
                    {
                        IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                        try
                        {
                            token.ThrowIfCancellationRequested();
                            if (setNamesOfChangedProperties.Contains(nameof(Created)))
                                ImprovementManager.ClearCachedValues(this, token);
                            if (setNamesOfChangedProperties.Contains(nameof(CharacterGrammaticGender)))
                                _strCachedCharacterGrammaticGender = string.Empty;
                            if (setNamesOfChangedProperties.Contains(nameof(TotalStartingNuyen)))
                                _decCachedTotalStartingNuyen = decimal.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(ContactPoints)))
                                _intCachedContactPoints = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(BaseCarryLimit)))
                                _decCachedBaseCarryLimit = decimal.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(BaseLiftLimit)))
                                _decCachedBaseLiftLimit = decimal.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(EncumbranceInterval)))
                                _decCachedEncumbranceInterval = decimal.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(TotalArmorRating)))
                                _intCachedTotalArmorRating = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(TotalFireArmorRating)))
                                _intCachedTotalFireArmorRating = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(TotalColdArmorRating)))
                                _intCachedTotalColdArmorRating = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(TotalElectricityArmorRating)))
                                _intCachedTotalElectricityArmorRating = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(TotalAcidArmorRating)))
                                _intCachedTotalAcidArmorRating = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(TotalFallingArmorRating)))
                                _intCachedTotalFallingArmorRating = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(TrustFund)))
                                _intCachedTrustFund = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(RestrictedGear)))
                                _intCachedRestrictedGear = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(TotalCarriedWeight)))
                                _decCachedTotalCarriedWeight = decimal.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(PowerPointsUsed)))
                                _decCachedPowerPointsUsed = decimal.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(CyberwareEssence)))
                                _decCachedCyberwareEssence = decimal.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(BiowareEssence))
                                || setNamesOfChangedProperties.Contains(nameof(PrototypeTranshumanEssenceUsed)))
                            {
                                _decCachedBiowareEssence = decimal.MinValue;
                                _decCachedPrototypeTranshumanEssenceUsed = decimal.MinValue;
                            }

                            if (setNamesOfChangedProperties.Contains(nameof(EssenceHole)))
                                _decCachedEssenceHole = decimal.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(CareerNuyen)))
                                _decCachedCareerNuyen = decimal.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(CareerKarma)))
                                _intCachedCareerKarma = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(BoundSpiritLimit)))
                                _intBoundSpiritLimit = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(RegisteredSpriteLimit)))
                                _intRegisteredSpriteLimit = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(InitiationEnabled)))
                                _intCachedInitiationEnabled = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(RedlinerBonus)))
                                _intCachedRedlinerBonus = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(HasAnyQualitiesWithQualityLevels)))
                                _intCachedHasAnyQualitiesWithQualityLevels = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(EnemyKarma)))
                                _intCachedEnemyKarma = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(Qualities)))
                            {
                                _intCachedNegativeQualities = int.MinValue;
                                _intCachedNegativeQualityLimitKarma = int.MinValue;
                                _intCachedPositiveQualityLimitKarma = int.MinValue;
                                _intCachedPositiveQualities = int.MinValue;
                                _intCachedMetagenicNegativeQualities = int.MinValue;
                                _intCachedMetagenicPositiveQualities = int.MinValue;
                            }
                            else if (setNamesOfChangedProperties.Contains(nameof(MetagenicLimit)))
                            {
                                _intCachedMetagenicNegativeQualities = int.MinValue;
                                _intCachedMetagenicPositiveQualities = int.MinValue;
                            }
                        }
                        finally
                        {
                            await objLocker2.DisposeAsync().ConfigureAwait(false);
                        }
                    }

                    if (setNamesOfChangedProperties.Contains(nameof(HasAnyQualitiesWithQualityLevels)))
                        await ProcessQualityLevelsAsync(token).ConfigureAwait(false); // Has to be called first in case created qualities create more processing requirements
                    if (setNamesOfChangedProperties.Contains(nameof(DealerConnectionDiscount)))
                        await RefreshDealerConnectionDiscountsAsync(token).ConfigureAwait(false);
                    if (setNamesOfChangedProperties.Contains(nameof(BlackMarketDiscount)))
                        await RefreshBlackMarketDiscountsAsync(token).ConfigureAwait(false);
                    if (setNamesOfChangedProperties.Contains(nameof(RedlinerBonus)))
                        await RefreshRedlinerImprovementsAsync(token).ConfigureAwait(false);
                    if (setNamesOfChangedProperties.Contains(nameof(Essence)) ||
                        setNamesOfChangedProperties.Contains(nameof(EssenceAtSpecialStart)))
                    {
                        if (setNamesOfChangedProperties.Contains(nameof(Essence)))
                            await ResetCachedEssenceAsync(token).ConfigureAwait(false);
                        await RefreshEssenceLossImprovementsAsync(token).ConfigureAwait(false);
                    }

                    if (setNamesOfChangedProperties.Contains(nameof(Encumbrance)))
                        await RefreshEncumbranceAsync(token).ConfigureAwait(false);
                    if (setNamesOfChangedProperties.Contains(nameof(ArmorEncumbrance)))
                        await RefreshArmorEncumbranceAsync(token).ConfigureAwait(false);
                    if (setNamesOfChangedProperties.Contains(nameof(WoundModifier)))
                        await RefreshWoundPenaltiesAsync(token).ConfigureAwait(false);
                    if (setNamesOfChangedProperties.Contains(nameof(SustainingPenalty)))
                        await RefreshSustainingPenaltiesAsync(token).ConfigureAwait(false);
                    if (setNamesOfChangedProperties.Contains(nameof(TotalAstralReputation)))
                        await RefreshAstralReputationImprovementsAsync(token).ConfigureAwait(false);

                    if (_setMultiplePropertiesChangedAsync.Count > 0)
                    {
                        MultiplePropertiesChangedEventArgs objArgs =
                            new MultiplePropertiesChangedEventArgs(setNamesOfChangedProperties.ToArray());
                        await ParallelExtensions.ForEachAsync(_setMultiplePropertiesChangedAsync, objEvent => objEvent.Invoke(this, objArgs, token), token).ConfigureAwait(false);

                        if (MultiplePropertiesChanged != null)
                        {
                            await Utils.RunOnMainThreadAsync(() =>
                            {
                                // ReSharper disable once AccessToModifiedClosure
                                MultiplePropertiesChanged?.Invoke(this, objArgs);
                            }, token: token).ConfigureAwait(false);
                        }
                    }
                    else if (MultiplePropertiesChanged != null)
                    {
                        MultiplePropertiesChangedEventArgs objArgs =
                            new MultiplePropertiesChangedEventArgs(setNamesOfChangedProperties.ToArray());
                        await Utils.RunOnMainThreadAsync(() =>
                        {
                            // ReSharper disable once AccessToModifiedClosure
                            MultiplePropertiesChanged?.Invoke(this, objArgs);
                        }, token: token).ConfigureAwait(false);
                    }

                    if (_setPropertyChangedAsync.Count > 0)
                    {
                        List<PropertyChangedEventArgs> lstArgsList = setNamesOfChangedProperties
                            .Select(x => new PropertyChangedEventArgs(x)).ToList();
                        List<ValueTuple<PropertyChangedAsyncEventHandler, PropertyChangedEventArgs>> lstAsyncEventsList
                            = new List<ValueTuple<PropertyChangedAsyncEventHandler, PropertyChangedEventArgs>>(lstArgsList.Count * _setPropertyChangedAsync.Count);
                        foreach (PropertyChangedAsyncEventHandler objEvent in _setPropertyChangedAsync)
                        {
                            foreach (PropertyChangedEventArgs objArg in lstArgsList)
                            {
                                lstAsyncEventsList.Add(new ValueTuple<PropertyChangedAsyncEventHandler, PropertyChangedEventArgs>(objEvent, objArg));
                            }
                        }
                        await ParallelExtensions.ForEachAsync(lstAsyncEventsList, tupEvent => tupEvent.Item1.Invoke(this, tupEvent.Item2, token), token).ConfigureAwait(false);

                        if (PropertyChanged != null)
                        {
                            await Utils.RunOnMainThreadAsync(() =>
                            {
                                if (PropertyChanged != null)
                                {
                                    // ReSharper disable once AccessToModifiedClosure
                                    foreach (PropertyChangedEventArgs objArgs in lstArgsList)
                                    {
                                        PropertyChanged.Invoke(this, objArgs);
                                    }
                                }
                            }, token).ConfigureAwait(false);
                        }
                    }
                    else if (PropertyChanged != null)
                    {
                        await Utils.RunOnMainThreadAsync(() =>
                        {
                            if (PropertyChanged != null)
                            {
                                // ReSharper disable once AccessToModifiedClosure
                                foreach (string strPropertyToChange in setNamesOfChangedProperties)
                                {
                                    PropertyChanged.Invoke(this, new PropertyChangedEventArgs(strPropertyToChange));
                                }
                            }
                        }, token).ConfigureAwait(false);
                    }

                    if (!await GetCreatedAsync(token).ConfigureAwait(false))
                    {
                        // If in create mode, update the Force for Spirits and Sprites (equal to Magician MAG Rating or RES Rating).
                        if (setNamesOfChangedProperties.Contains(nameof(MaxSpriteLevel)))
                        {
                            int intMaxLevel = await GetMaxSpriteLevelAsync(token).ConfigureAwait(false);
                            if (setNamesOfChangedProperties.Contains(nameof(MaxSpiritForce)))
                            {
                                int intMaxForce = await GetMaxSpiritForceAsync(token).ConfigureAwait(false);
                                await (await GetSpiritsAsync(token).ConfigureAwait(false)).ForEachAsync(
                                    async objSpirit =>
                                    {
                                        token.ThrowIfCancellationRequested();
                                        IAsyncDisposable objLocker2 = await objSpirit.LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
                                        try
                                        {
                                            token.ThrowIfCancellationRequested();
                                            switch (await objSpirit.GetEntityTypeAsync(token).ConfigureAwait(false))
                                            {
                                                case SpiritType.Sprite:
                                                    await objSpirit.SetForceAsync(intMaxLevel, token)
                                                        .ConfigureAwait(false);
                                                    break;
                                                case SpiritType.Spirit:
                                                    await objSpirit.SetForceAsync(intMaxForce, token)
                                                        .ConfigureAwait(false);
                                                    break;
                                            }
                                        }
                                        finally
                                        {
                                            await objLocker2.DisposeAsync().ConfigureAwait(false);
                                        }
                                    }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await (await GetSpiritsAsync(token).ConfigureAwait(false)).ForEachAsync(
                                    async objSpirit =>
                                    {
                                        token.ThrowIfCancellationRequested();
                                        IAsyncDisposable objLocker2 = await objSpirit.LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
                                        try
                                        {
                                            token.ThrowIfCancellationRequested();
                                            if (await objSpirit.GetEntityTypeAsync(token).ConfigureAwait(false) ==
                                                SpiritType.Sprite)
                                                await objSpirit.SetForceAsync(intMaxLevel, token).ConfigureAwait(false);
                                        }
                                        finally
                                        {
                                            await objLocker2.DisposeAsync().ConfigureAwait(false);
                                        }
                                    }, token).ConfigureAwait(false);
                            }
                        }
                        else if (setNamesOfChangedProperties.Contains(nameof(MaxSpiritForce)))
                        {
                            int intMaxForce = await GetMaxSpiritForceAsync(token).ConfigureAwait(false);
                            await (await GetSpiritsAsync(token).ConfigureAwait(false)).ForEachAsync(
                                async objSpirit =>
                                {
                                    token.ThrowIfCancellationRequested();
                                    IAsyncDisposable objLocker2 = await objSpirit.LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
                                    try
                                    {
                                        token.ThrowIfCancellationRequested();
                                        if (await objSpirit.GetEntityTypeAsync(token).ConfigureAwait(false) ==
                                            SpiritType.Spirit)
                                            await objSpirit.SetForceAsync(intMaxForce, token).ConfigureAwait(false);
                                    }
                                    finally
                                    {
                                        await objLocker2.DisposeAsync().ConfigureAwait(false);
                                    }
                                }, token).ConfigureAwait(false);
                        }
                    }
                }
                finally
                {
                    if (setNamesOfChangedProperties != null)
                        Utils.StringHashSetPool.Return(ref setNamesOfChangedProperties);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        #region Hero Lab Importing

        public static readonly ReadOnlyCollection<string> HeroLabPluginNodeNames = Array.AsReadOnly(new[]
            {"modifications", "accessories", "ammunition", "programs", "othergear"});

        /// <summary>
        /// Load the Character from an XML file.
        /// </summary>
        public bool LoadFromHeroLabFile(string strPorFile, string strCharacterId, string strSettingsKey = "")
        {
            return Utils.SafelyRunSynchronously(() => LoadFromHeroLabFileCoreAsync(true, strPorFile, strCharacterId, strSettingsKey));
        }

        /// <summary>
        /// Load the Character from an XML file.
        /// </summary>
        public Task<bool> LoadFromHeroLabFileAsync(string strPorFile, string strCharacterId, string strSettingsKey = "")
        {
            return LoadFromHeroLabFileCoreAsync(false, strPorFile, strCharacterId, strSettingsKey);
        }

        /// <summary>
        /// Load the Character from an XML file.
        /// </summary>
        public async Task<bool> LoadFromHeroLabFileCoreAsync(bool blnSync, string strPorFile, string strCharacterId, string strSettingsKey = "", CancellationToken token = default)
        {
            if (!File.Exists(strPorFile))
                return false;

            IDisposable objLocker = null;
            IAsyncDisposable objLockerAsync = null;
            if (blnSync)
                // ReSharper disable once MethodHasAsyncOverload
                objLocker = LockObject.EnterWriteLock(token);
            else
                objLockerAsync = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                Dictionary<string, Bitmap> dicImages = new Dictionary<string, Bitmap>(1);
                XPathNavigator xmlStatBlockDocument = null;
                XPathNavigator xmlLeadsDocument = null;
                List<string> lstTextStatBlockLines = null;
                using (CustomActivity op_load = Timekeeper.StartSyncron("LoadFromHeroLabFile", null,
                                                                        CustomActivity.OperationType
                                                                            .DependencyOperation, strPorFile))
                {
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        op_load.MyDependencyTelemetry.Type = "loadHeroLab";
                        op_load.MyDependencyTelemetry.Target = strPorFile;

                        try
                        {
                            token.ThrowIfCancellationRequested();
                            string strLeadsName = string.Empty;
                            using (ZipArchive zipArchive = ZipFile.Open(strPorFile, ZipArchiveMode.Read,
                                                                        Encoding.GetEncoding(850)))
                            {
                                token.ThrowIfCancellationRequested();
                                foreach (ZipArchiveEntry objEntry in zipArchive.Entries)
                                {
                                    token.ThrowIfCancellationRequested();
                                    string strEntryFullName = objEntry.FullName;
                                    string strKey = Path.GetFileName(strEntryFullName);
                                    if ((xmlStatBlockDocument == null && strEntryFullName.StartsWith(
                                            "statblocks_xml",
                                            StringComparison.OrdinalIgnoreCase)) ||
                                        (string.IsNullOrEmpty(strLeadsName) &&
                                         strEntryFullName.EndsWith("portfolio.xml",
                                                                   StringComparison.OrdinalIgnoreCase)) ||
                                        lstTextStatBlockLines == null && strEntryFullName.StartsWith(
                                            "statblocks_txt",
                                            StringComparison.OrdinalIgnoreCase))
                                    {
                                        if (strEntryFullName.EndsWith(".xml", StringComparison.OrdinalIgnoreCase))
                                        {
                                            try
                                            {
                                                token.ThrowIfCancellationRequested();
                                                if (blnSync)
                                                    DoLoadStatblocks();
                                                else
                                                    await TaskExtensions.RunWithoutEC(DoLoadStatblocks, token).ConfigureAwait(false);
                                                void DoLoadStatblocks()
                                                {
                                                    using (Stream objStream = objEntry.Open())
                                                    {
                                                        token.ThrowIfCancellationRequested();
                                                        using (StreamReader objStreamReader =
                                                               new StreamReader(objStream, true))
                                                        {
                                                            token.ThrowIfCancellationRequested();
                                                            using (XmlReader objReader = XmlReader.Create(
                                                                       objStreamReader,
                                                                       GlobalSettings.SafeXmlReaderSettings))
                                                            {
                                                                token.ThrowIfCancellationRequested();
                                                                XPathDocument xmlSourceDoc
                                                                    = new XPathDocument(objReader);
                                                                XPathNavigator objDummy
                                                                    = xmlSourceDoc.CreateNavigator();
                                                                if (strEntryFullName.StartsWith("statblocks_xml",
                                                                        StringComparison.Ordinal))
                                                                {
                                                                    if (objDummy.SelectSingleNode(
                                                                            "/document/public/character[@name = " +
                                                                            strCharacterId.CleanXPath() + "]") != null)
                                                                        xmlStatBlockDocument = objDummy;
                                                                }
                                                                else
                                                                {
                                                                    strLeadsName = objDummy.SelectSingleNode(
                                                                            "/document/portfolio/hero[@heroname = " +
                                                                            strCharacterId.CleanXPath() + "]/@leadfile")
                                                                        ?.Value;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            // If we run into any problems loading the character xml files, fail out early.
                                            catch (Exception e) when ((e is IOException) || (e is XmlException))
                                            {
                                                Log.Info(e);
                                                Utils.BreakIfDebug();
                                            }
                                        }
                                        else if (strEntryFullName.EndsWith(".txt",
                                                                           StringComparison.OrdinalIgnoreCase)
                                                 && !strKey.Contains('.'))
                                        {
                                            lstTextStatBlockLines = new List<string>(30);
                                            using (Stream objStream = objEntry.Open())
                                            {
                                                token.ThrowIfCancellationRequested();
                                                using (StreamReader objReader = new StreamReader(objStream))
                                                {
                                                    token.ThrowIfCancellationRequested();
                                                    for (string strLine = blnSync
                                                             // ReSharper disable once MethodHasAsyncOverload
                                                             ? objReader.ReadLine()
                                                             : await objReader.ReadLineAsync().ConfigureAwait(false);
                                                         strLine != null;
                                                         strLine = blnSync
                                                             // ReSharper disable once MethodHasAsyncOverload
                                                             ? objReader.ReadLine()
                                                             : await objReader.ReadLineAsync().ConfigureAwait(false))
                                                    {
                                                        token.ThrowIfCancellationRequested();
                                                        // Trim away the newlines and empty spaces at the beginning and end of lines
                                                        lstTextStatBlockLines.Add(strLine.Trim('\n', '\r', ' ').Trim());
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    else if (strEntryFullName.StartsWith("images", StringComparison.Ordinal) &&
                                             strEntryFullName.Contains('.'))
                                    {
                                        using (Stream objStream = objEntry.Open())
                                        {
                                            token.ThrowIfCancellationRequested();
                                            using (Bitmap bmpMugshot = new Bitmap(objStream, true))
                                            {
                                                token.ThrowIfCancellationRequested();
                                                Bitmap bmpNewMugshot =
                                                    bmpMugshot.PixelFormat == PixelFormat.Format32bppPArgb
                                                        ? bmpMugshot
                                                            .Clone() as Bitmap // Clone makes sure file handle is closed
                                                        : bmpMugshot.ConvertPixelFormat(PixelFormat.Format32bppPArgb);
                                                if (dicImages.TryGetValue(strKey, out Bitmap bmpExistingMugshot))
                                                {
                                                    bmpExistingMugshot.Dispose();
                                                    dicImages[strKey] = bmpNewMugshot;
                                                }
                                                else
                                                    dicImages.Add(strKey, bmpNewMugshot);
                                            }
                                        }
                                    }
                                }

                                if (!string.IsNullOrEmpty(strLeadsName))
                                {
                                    // Need a second sweep for the Leads file
                                    foreach (ZipArchiveEntry objEntry in zipArchive.Entries)
                                    {
                                        token.ThrowIfCancellationRequested();
                                        string strEntryFullName = objEntry.FullName;
                                        if (strEntryFullName.EndsWith(strLeadsName,
                                                                      StringComparison.OrdinalIgnoreCase))
                                        {
                                            try
                                            {
                                                token.ThrowIfCancellationRequested();
                                                if (blnSync)
                                                    DoLoadLeads();
                                                else
                                                    await TaskExtensions.RunWithoutEC(DoLoadLeads, token).ConfigureAwait(false);
                                                void DoLoadLeads()
                                                {
                                                    using (Stream objStream = objEntry.Open())
                                                    {
                                                        token.ThrowIfCancellationRequested();
                                                        using (StreamReader objStreamReader =
                                                               new StreamReader(objStream, true))
                                                        {
                                                            token.ThrowIfCancellationRequested();
                                                            using (XmlReader objReader = XmlReader.Create(
                                                                       objStreamReader,
                                                                       GlobalSettings.SafeXmlReaderSettings))
                                                            {
                                                                token.ThrowIfCancellationRequested();
                                                                XPathDocument xmlSourceDoc
                                                                    = new XPathDocument(objReader);
                                                                xmlLeadsDocument = xmlSourceDoc.CreateNavigator();
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            // If we run into any problems loading the character xml files, fail out early.
                                            catch (Exception e) when ((e is IOException) || (e is XmlException))
                                            {
                                                continue;
                                            }

                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        catch (Exception ex) when ((ex is IOException) || (ex is NotSupportedException) || (ex is UnauthorizedAccessException))
                        {
                            ex = ex.Demystify();
                            if (op_load != null)
                            {
                                op_load.SetSuccess(false);
                                op_load.AddBaggage(ex.GetType().Name, ex.Message);
                                Log.Error(ex);
                            }

                            if (blnSync)
                            {
                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                Program.ShowScrollableMessageBox(
                                    string.Format(GlobalSettings.CultureInfo,
                                        // ReSharper disable once MethodHasAsyncOverload
                                        LanguageManager.GetString("Message_FailedLoad", token: token),
                                        ex.Message),
                                    // ReSharper disable once MethodHasAsyncOverload
                                    LanguageManager.GetString("MessageTitle_FailedLoad", token: token),
                                    MessageBoxButtons.OK, MessageBoxIcon.Error);
                            }
                            else
                            {
                                await Program.ShowScrollableMessageBoxAsync(
                                    string.Format(GlobalSettings.CultureInfo,
                                        await LanguageManager.GetStringAsync("Message_FailedLoad", token: token)
                                            .ConfigureAwait(false),
                                        ex.Message),
                                    await LanguageManager.GetStringAsync("MessageTitle_FailedLoad", token: token)
                                        .ConfigureAwait(false),
                                    MessageBoxButtons.OK, MessageBoxIcon.Error, token: token).ConfigureAwait(false);
                            }

                            return false;
                        }

                        if (xmlLeadsDocument == null || xmlStatBlockDocument == null)
                        {
                            return false;
                        }

                        if (blnSync)
                            IsLoading = true;
                        else
                            await SetIsLoadingAsync(true, token).ConfigureAwait(false);
                        try
                        {
                            token.ThrowIfCancellationRequested();
                            XPathNavigator xmlStatBlockBaseNode;
                            XPathNavigator xmlLeadsBaseNode;

                            using (Timekeeper.StartSyncron("load_char_misc", op_load))
                            {
                                xmlStatBlockBaseNode =
                                    xmlStatBlockDocument.SelectSingleNode("/document/public/character[@name = " +
                                                                          strCharacterId.CleanXPath() + "]");
                                xmlLeadsBaseNode =
                                    xmlLeadsDocument.SelectSingleNode("/document/hero[@heroname = " +
                                                                      strCharacterId.CleanXPath() +
                                                                      "]");

                                _blnCreated =
                                    (xmlStatBlockBaseNode.SelectSingleNodeAndCacheExpression("karma/@total", token)?.Value ?? "0") !=
                                    "0";
                                if (!_blnCreated)
                                {
                                    XPathNodeIterator xmlJournalEntries = xmlStatBlockBaseNode.SelectAndCacheExpression("journals/journal", token);
                                    if (xmlJournalEntries.Count > 1
                                        || (xmlJournalEntries.Count == 1 &&
                                            xmlJournalEntries.Current.SelectSingleNodeAndCacheExpression("@name", token)
                                                ?.Value != "Title"))
                                    {
                                        _blnCreated = true;
                                    }
                                }

                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ResetCharacter(token);
                                else
                                    await ResetCharacterAsync(token).ConfigureAwait(false);

                                // Get the name of the settings file in use if possible.
                                if (!string.IsNullOrEmpty(strSettingsKey))
                                {
                                    if (blnSync
                                            ? !SettingsManager.LoadedCharacterSettings.ContainsKey(strSettingsKey)
                                            : !(await SettingsManager.GetLoadedCharacterSettingsAsync(token).ConfigureAwait(false)).ContainsKey(strSettingsKey))
                                        return false;

                                    if (blnSync)
                                        SettingsKey = strSettingsKey;
                                    else
                                        await SetSettingsKeyAsync(strSettingsKey, token).ConfigureAwait(false);
                                }

                                // Metatype information.
                                string strRaceString = xmlStatBlockBaseNode.SelectSingleNodeAndCacheExpression("race/@name", token)?.Value;
                                if (!string.IsNullOrEmpty(strRaceString))
                                {
                                    if (strRaceString == "Metasapient")
                                        strRaceString = "A.I.";
                                    if (blnSync)
                                    {
                                        // ReSharper disable MethodHasAsyncOverload
                                        foreach (XPathNavigator xmlMetatype in
                                                     LoadDataXPath("metatypes.xml", token: token)
                                                         .SelectAndCacheExpression("/chummer/metatypes/metatype", token))
                                        {
                                            string strMetatypeName
                                                = xmlMetatype.SelectSingleNodeAndCacheExpression("name", token).Value;
                                            if (strMetatypeName == strRaceString)
                                            {
                                                _strMetatype = strMetatypeName;
                                                _strMetatypeCategory = xmlMetatype
                                                                       .SelectSingleNodeAndCacheExpression("category", token)
                                                                       .Value;
                                                _strMetavariant = string.Empty;

                                                XPathNavigator objRunNode
                                                    = xmlMetatype.SelectSingleNodeAndCacheExpression("run", token);
                                                XPathNavigator objWalkNode
                                                    = xmlMetatype.SelectSingleNodeAndCacheExpression("walk", token);
                                                XPathNavigator objSprintNode
                                                    = xmlMetatype.SelectSingleNodeAndCacheExpression("sprint", token);

                                                _strMovement
                                                    = xmlMetatype.SelectSingleNodeAndCacheExpression("movement", token)?.Value
                                                      ??
                                                      string.Empty;
                                                _strRun = objRunNode?.Value ?? string.Empty;
                                                _strWalk = objWalkNode?.Value ?? string.Empty;
                                                _strSprint = objSprintNode?.Value ?? string.Empty;

                                                objRunNode = objRunNode?.SelectSingleNodeAndCacheExpression("@alt", token);
                                                objWalkNode = objWalkNode?.SelectSingleNodeAndCacheExpression("@alt", token);
                                                objSprintNode
                                                    = objSprintNode?.SelectSingleNodeAndCacheExpression("@alt", token);
                                                _strRunAlt = objRunNode?.Value ?? string.Empty;
                                                _strWalkAlt = objWalkNode?.Value ?? string.Empty;
                                                _strSprintAlt = objSprintNode?.Value ?? string.Empty;
                                                break;
                                            }

                                            foreach (XPathNavigator xmlMetavariant in xmlMetatype.Select(
                                                         "metavariants/metavariant"))
                                            {
                                                string strMetavariantName =
                                                    xmlMetavariant.SelectSingleNodeAndCacheExpression("name", token).Value;
                                                if (strMetavariantName == strRaceString)
                                                {
                                                    _strMetatype = strMetatypeName;
                                                    _strMetatypeCategory =
                                                        xmlMetatype.SelectSingleNodeAndCacheExpression("category", token)
                                                                   .Value;
                                                    _strMetavariant = strMetavariantName;

                                                    XPathNavigator objRunNode =
                                                        xmlMetavariant?.SelectSingleNodeAndCacheExpression("run", token) ??
                                                        xmlMetatype?.SelectSingleNodeAndCacheExpression("run", token);
                                                    XPathNavigator objWalkNode =
                                                        xmlMetavariant?.SelectSingleNodeAndCacheExpression("walk", token) ??
                                                        xmlMetatype?.SelectSingleNodeAndCacheExpression("walk", token);
                                                    XPathNavigator objSprintNode =
                                                        xmlMetavariant?.SelectSingleNodeAndCacheExpression("sprint", token) ??
                                                        xmlMetatype?.SelectSingleNodeAndCacheExpression("sprint", token);

                                                    _strMovement =
                                                        xmlMetavariant?.SelectSingleNodeAndCacheExpression("movement", token)
                                                                      ?.Value ??
                                                        xmlMetatype?.SelectSingleNodeAndCacheExpression("movement", token)
                                                                   ?.Value ??
                                                        string.Empty;
                                                    _strRun = objRunNode?.Value ?? string.Empty;
                                                    _strWalk = objWalkNode?.Value ?? string.Empty;
                                                    _strSprint = objSprintNode?.Value ?? string.Empty;

                                                    objRunNode = objRunNode?.SelectSingleNodeAndCacheExpression("@alt", token);
                                                    objWalkNode
                                                        = objWalkNode?.SelectSingleNodeAndCacheExpression("@alt", token);
                                                    objSprintNode
                                                        = objSprintNode?.SelectSingleNodeAndCacheExpression("@alt", token);
                                                    _strRunAlt = objRunNode?.Value ?? string.Empty;
                                                    _strWalkAlt = objWalkNode?.Value ?? string.Empty;
                                                    _strSprintAlt = objSprintNode?.Value ?? string.Empty;
                                                    break;
                                                }
                                            }
                                        }
                                        // ReSharper restore MethodHasAsyncOverload
                                    }
                                    else
                                    {
                                        foreach (XPathNavigator xmlMetatype in (await LoadDataXPathAsync("metatypes.xml", token: token)
                                                                 .ConfigureAwait(false))
                                                             .SelectAndCacheExpression(
                                                                 "/chummer/metatypes/metatype", token: token))
                                        {
                                            string strMetatypeName
                                                = xmlMetatype.SelectSingleNodeAndCacheExpression("name", token).Value;
                                            if (strMetatypeName == strRaceString)
                                            {
                                                _strMetatype = strMetatypeName;
                                                _strMetatypeCategory = xmlMetatype
                                                    .SelectSingleNodeAndCacheExpression("category", token)
                                                    .Value;
                                                _strMetavariant = string.Empty;

                                                XPathNavigator objRunNode
                                                    = xmlMetatype.SelectSingleNodeAndCacheExpression("run", token);
                                                XPathNavigator objWalkNode
                                                    = xmlMetatype.SelectSingleNodeAndCacheExpression("walk", token);
                                                XPathNavigator objSprintNode
                                                    = xmlMetatype.SelectSingleNodeAndCacheExpression("sprint", token);

                                                _strMovement
                                                    = xmlMetatype.SelectSingleNodeAndCacheExpression("movement", token)?.Value
                                                      ??
                                                      string.Empty;
                                                _strRun = objRunNode?.Value ?? string.Empty;
                                                _strWalk = objWalkNode?.Value ?? string.Empty;
                                                _strSprint = objSprintNode?.Value ?? string.Empty;

                                                objRunNode = objRunNode?.SelectSingleNodeAndCacheExpression("@alt", token);
                                                objWalkNode = objWalkNode?.SelectSingleNodeAndCacheExpression("@alt", token);
                                                objSprintNode
                                                    = objSprintNode?.SelectSingleNodeAndCacheExpression("@alt", token);
                                                _strRunAlt = objRunNode?.Value ?? string.Empty;
                                                _strWalkAlt = objWalkNode?.Value ?? string.Empty;
                                                _strSprintAlt = objSprintNode?.Value ?? string.Empty;
                                                break;
                                            }

                                            foreach (XPathNavigator xmlMetavariant in xmlMetatype.Select(
                                                         "metavariants/metavariant"))
                                            {
                                                string strMetavariantName =
                                                    xmlMetavariant.SelectSingleNodeAndCacheExpression("name", token).Value;
                                                if (strMetavariantName == strRaceString)
                                                {
                                                    _strMetatype = strMetatypeName;
                                                    _strMetatypeCategory =
                                                        xmlMetatype.SelectSingleNodeAndCacheExpression("category", token)
                                                            .Value;
                                                    _strMetavariant = strMetavariantName;

                                                    XPathNavigator objRunNode =
                                                        xmlMetavariant?.SelectSingleNodeAndCacheExpression("run", token) ??
                                                        xmlMetatype?.SelectSingleNodeAndCacheExpression("run", token);
                                                    XPathNavigator objWalkNode =
                                                        xmlMetavariant?.SelectSingleNodeAndCacheExpression("walk", token) ??
                                                        xmlMetatype?.SelectSingleNodeAndCacheExpression("walk", token);
                                                    XPathNavigator objSprintNode =
                                                        xmlMetavariant?.SelectSingleNodeAndCacheExpression("sprint", token) ??
                                                        xmlMetatype?.SelectSingleNodeAndCacheExpression("sprint", token);

                                                    _strMovement =
                                                        xmlMetavariant?.SelectSingleNodeAndCacheExpression("movement", token)
                                                            ?.Value ??
                                                        xmlMetatype?.SelectSingleNodeAndCacheExpression("movement", token)
                                                            ?.Value ??
                                                        string.Empty;
                                                    _strRun = objRunNode?.Value ?? string.Empty;
                                                    _strWalk = objWalkNode?.Value ?? string.Empty;
                                                    _strSprint = objSprintNode?.Value ?? string.Empty;

                                                    objRunNode = objRunNode?.SelectSingleNodeAndCacheExpression("@alt", token);
                                                    objWalkNode
                                                        = objWalkNode?.SelectSingleNodeAndCacheExpression("@alt", token);
                                                    objSprintNode
                                                        = objSprintNode?.SelectSingleNodeAndCacheExpression("@alt", token);
                                                    _strRunAlt = objRunNode?.Value ?? string.Empty;
                                                    _strWalkAlt = objWalkNode?.Value ?? string.Empty;
                                                    _strSprintAlt = objSprintNode?.Value ?? string.Empty;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }

                                // General character information.
                                int intAsIndex = strCharacterId.IndexOf(" as ", StringComparison.Ordinal);
                                if (intAsIndex != -1)
                                {
                                    _strName = strCharacterId.Substring(0, intAsIndex);
                                    _strAlias = strCharacterId.Substring(intAsIndex).TrimStart(" as ").Trim('\'');
                                }
                                else
                                {
                                    _strAlias = strCharacterId;
                                }

                                XPathNavigator xmlPersonalNode = xmlStatBlockBaseNode.SelectSingleNodeAndCacheExpression("personal", token);
                                if (xmlPersonalNode != null)
                                {
                                    _strBackground = xmlPersonalNode.SelectSingleNodeAndCacheExpression("description", token)?.Value;
                                    _strHeight = xmlPersonalNode.SelectSingleNodeAndCacheExpression("charheight/@text", token)?.Value;
                                    _strWeight = xmlPersonalNode.SelectSingleNodeAndCacheExpression("charweight/@text", token)?.Value;
                                    if (xmlPersonalNode.HasAttributes)
                                    {
                                        _strGender = xmlPersonalNode.SelectSingleNodeAndCacheExpression("@gender", token)?.Value;
                                        _strAge = xmlPersonalNode.SelectSingleNodeAndCacheExpression("@age", token)?.Value;
                                        _strHair = xmlPersonalNode.SelectSingleNodeAndCacheExpression("@hair", token)?.Value;
                                        _strEyes = xmlPersonalNode.SelectSingleNodeAndCacheExpression("@eyes", token)?.Value;
                                        _strSkin = xmlPersonalNode.SelectSingleNodeAndCacheExpression("@skin", token)?.Value;
                                    }
                                }

                                _strPlayerName
                                    = xmlStatBlockBaseNode.SelectSingleNodeAndCacheExpression("@playername", token)?.Value;

                                foreach (XPathNavigator xmlImageFileNameNode in xmlStatBlockBaseNode.SelectAndCacheExpression(
                                             "images/image/@filename", token))
                                {
                                    if (dicImages.TryGetValue(xmlImageFileNameNode.Value, out Bitmap objOutput))
                                    {
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstMugshots.Add(objOutput);
                                        else
                                            await _lstMugshots.AddAsync(objOutput, token).ConfigureAwait(false);
                                    }
                                }

                                if (_lstMugshots.Count > 0)
                                    _intMainMugshotIndex = 0;

                                if (string.IsNullOrEmpty(strSettingsKey))
                                {
                                    string strSettingsSummary =
                                        xmlStatBlockBaseNode.SelectSingleNodeAndCacheExpression(
                                            "settings/@summary", token)?.Value;
                                    if (!string.IsNullOrEmpty(strSettingsSummary))
                                    {
                                        int intCharCreationSystemsIndex =
                                            strSettingsSummary.IndexOf("Character Creation Systems:",
                                                                       StringComparison.OrdinalIgnoreCase);
                                        if (intCharCreationSystemsIndex != -1)
                                        {
                                            int intSemicolonIndex
                                                = strSettingsSummary.IndexOf(';', intCharCreationSystemsIndex);
                                            if (intCharCreationSystemsIndex + 28 <= intSemicolonIndex)
                                            {
                                                string strHeroLabSettingsName = strSettingsSummary.Substring(
                                                        intCharCreationSystemsIndex + 28,
                                                        strSettingsSummary.IndexOf(';', intCharCreationSystemsIndex)
                                                        - 28 - intCharCreationSystemsIndex)
                                                    .Trim();
                                                if (strHeroLabSettingsName == "Established Runners")
                                                    strHeroLabSettingsName = "Standard";

                                                if (strHeroLabSettingsName == "Standard")
                                                {
                                                    bool blnDoFullHouse = false;
                                                    int intSourcebooksIndex
                                                        = strSettingsSummary.IndexOf(
                                                            "Core Rulebooks:", StringComparison.OrdinalIgnoreCase);
                                                    if (intSourcebooksIndex != -1)
                                                    {
                                                        intSemicolonIndex
                                                            = strSettingsSummary.IndexOf(';', intSourcebooksIndex);
                                                        if (intSourcebooksIndex + 16 < intSemicolonIndex)
                                                        {
                                                            blnDoFullHouse
                                                                = true; // We probably have multiple books enabled, so use Full House instead
                                                        }
                                                    }

                                                    bool blnIsKarmaBased = xmlStatBlockBaseNode
                                                                           .SelectSingleNodeAndCacheExpression("creation/bp/@total", token)
                                                                           ?.ValueAsInt > 100;
                                                    if (blnDoFullHouse)
                                                    {
                                                        strHeroLabSettingsName = blnIsKarmaBased
                                                            ? "Full House (Point Buy)"
                                                            : "Full House";
                                                    }
                                                    else if (blnIsKarmaBased)
                                                        strHeroLabSettingsName = "Point Buy";
                                                }

                                                if (blnSync)
                                                {
                                                    CharacterSettings objHeroLabSettings =
                                                        SettingsManager.LoadedCharacterSettings.FirstOrDefault(
                                                            x => x.Value.Name == strHeroLabSettingsName).Value;
                                                    if (objHeroLabSettings != null)
                                                    {
                                                        strSettingsKey = objHeroLabSettings.DictionaryKey;
                                                        SettingsKey = strSettingsKey;
                                                    }
                                                }
                                                else
                                                {
                                                    CharacterSettings objHeroLabSettings =
                                                        (await SettingsManager.GetLoadedCharacterSettingsAsync(token)
                                                            .ConfigureAwait(false))
                                                        .FirstOrDefault(x =>
                                                            x.Value.Name == strHeroLabSettingsName).Value;
                                                    if (objHeroLabSettings != null)
                                                    {
                                                        strSettingsKey = await objHeroLabSettings
                                                                               .GetDictionaryKeyAsync(token)
                                                                               .ConfigureAwait(false);
                                                        await SetSettingsKeyAsync(strSettingsKey, token: token)
                                                            .ConfigureAwait(false);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }

                                if (string.IsNullOrEmpty(strSettingsKey))
                                {
                                    if (blnSync)
                                    {
                                        // ReSharper disable MethodHasAsyncOverload
                                        // ReSharper disable MethodHasAsyncOverloadWithCancellation
                                        if (Program.ShowScrollableMessageBox(
                                                string.Format(GlobalSettings.CultureInfo,
                                                    LanguageManager.GetString(
                                                        "Message_MissingGameplayOption", token: token),
                                                    SettingsKey),
                                                LanguageManager.GetString(
                                                    "Message_MissingGameplayOption_Title", token: token),
                                                MessageBoxButtons.OKCancel, MessageBoxIcon.Error)
                                            == DialogResult.OK)
                                        {
                                            using (ThreadSafeForm<SelectBuildMethod> frmPickBP
                                                   = ThreadSafeForm<SelectBuildMethod>.Get(
                                                       () => new SelectBuildMethod(this, true)))
                                            {
                                                if (frmPickBP.ShowDialogSafe(this, token) != DialogResult.OK)
                                                    return false;
                                            }
                                        }
                                        else
                                            return false;
                                        // ReSharper restore MethodHasAsyncOverloadWithCancellation
                                        // ReSharper restore MethodHasAsyncOverload
                                    }
                                    else if (await Program.ShowScrollableMessageBoxAsync(
                                                 string.Format(GlobalSettings.CultureInfo,
                                                     await LanguageManager
                                                         .GetStringAsync(
                                                             "Message_MissingGameplayOption", token: token)
                                                         .ConfigureAwait(false),
                                                     await GetSettingsKeyAsync(token).ConfigureAwait(false)),
                                                 await LanguageManager.GetStringAsync(
                                                         "Message_MissingGameplayOption_Title", token: token)
                                                     .ConfigureAwait(false),
                                                 MessageBoxButtons.OKCancel, MessageBoxIcon.Error, token: token).ConfigureAwait(false)
                                             == DialogResult.OK)
                                    {
                                        using (ThreadSafeForm<SelectBuildMethod> frmPickBP =
                                               await ThreadSafeForm<SelectBuildMethod>.GetAsync(
                                                       () => new SelectBuildMethod(this, true), token)
                                                   .ConfigureAwait(false))
                                        {
                                            if (await frmPickBP.ShowDialogSafeAsync(this, token)
                                                    .ConfigureAwait(false) != DialogResult.OK)
                                                return false;
                                        }
                                    }
                                    else
                                        return false;
                                }

                                if (EffectiveBuildMethodUsesPriorityTables)
                                {
                                    if (strRaceString == "A.I.")
                                        _strPriorityTalent = "AI";
                                    XPathNavigator xmlPriorityTalentPick =
                                        xmlLeadsBaseNode.SelectSingleNodeAndCacheExpression(
                                            "container/pick[starts-with(@thing, \"qu\") and @source = \"heritage\"]", token);
                                    if (xmlPriorityTalentPick != null)
                                    {
                                        switch (xmlPriorityTalentPick.SelectSingleNodeAndCacheExpression("@thing", token)?.Value)
                                        {
                                            case "quAware":
                                                _strPriorityTalent = "Aware";
                                                break;

                                            case "quEnchanter":
                                                _strPriorityTalent = "Enchanter";
                                                break;

                                            case "quExplorer":
                                                _strPriorityTalent = "Explorer";
                                                break;

                                            case "quApprentice":
                                                _strPriorityTalent = "Apprentice";
                                                break;

                                            case "quAspectedMagician":
                                                _strPriorityTalent = "Aspected Magician";
                                                break;

                                            case "quAdept":
                                                _strPriorityTalent = "Adept";
                                                break;

                                            case "quMagician":
                                                _strPriorityTalent = "Magician";
                                                break;

                                            case "quMysticAdept":
                                                _strPriorityTalent = "Mystic Adept";
                                                break;

                                            case "quTechnoma":
                                                _strPriorityTalent = "Technomancer";
                                                break;
                                        }

                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstPrioritySkills.Clear();
                                        else
                                            await _lstPrioritySkills.ClearAsync(token).ConfigureAwait(false);
                                        foreach (XPathNavigator xmlField in xmlPriorityTalentPick.SelectAndCacheExpression("field", token))
                                        {
                                            string strInnerText = xmlField.Value;
                                            if (!string.IsNullOrEmpty(strInnerText))
                                            {
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    _lstPrioritySkills.Add(strInnerText);
                                                else
                                                    await _lstPrioritySkills.AddAsync(strInnerText, token).ConfigureAwait(false);
                                            }
                                        }
                                    }

                                    if (blnSync)
                                    {
                                        // ReSharper disable MethodHasAsyncOverload
                                        // ReSharper disable MethodHasAsyncOverloadWithCancellation
                                        using (ThreadSafeForm<SelectMetatypePriority> frmSelectMetatype =
                                               ThreadSafeForm<SelectMetatypePriority>.Get(
                                                   () => new SelectMetatypePriority(this)))
                                        {
                                            if (frmSelectMetatype.ShowDialogSafe(this, token) != DialogResult.OK)
                                                return false;
                                        }
                                        // ReSharper restore MethodHasAsyncOverloadWithCancellation
                                        // ReSharper restore MethodHasAsyncOverload
                                    }
                                    else
                                    {
                                        using (ThreadSafeForm<SelectMetatypePriority> frmSelectMetatype =
                                               await ThreadSafeForm<SelectMetatypePriority>.GetAsync(
                                                   () => new SelectMetatypePriority(this), token).ConfigureAwait(false))
                                        {
                                            if (await frmSelectMetatype.ShowDialogSafeAsync(this, token).ConfigureAwait(false) != DialogResult.OK)
                                                return false;
                                        }
                                    }
                                }
                                else
                                {
                                    if (blnSync)
                                    {
                                        // ReSharper disable MethodHasAsyncOverload
                                        // ReSharper disable MethodHasAsyncOverloadWithCancellation
                                        using (ThreadSafeForm<SelectMetatypeKarma> frmSelectMetatype =
                                               ThreadSafeForm<SelectMetatypeKarma>.Get(
                                                   () => new SelectMetatypeKarma(this)))
                                        {
                                            if (frmSelectMetatype.ShowDialogSafe(this, token) != DialogResult.OK)
                                                return false;
                                        }
                                        // ReSharper restore MethodHasAsyncOverloadWithCancellation
                                        // ReSharper restore MethodHasAsyncOverload
                                    }
                                    else
                                    {
                                        using (ThreadSafeForm<SelectMetatypeKarma> frmSelectMetatype =
                                               await ThreadSafeForm<SelectMetatypeKarma>.GetAsync(
                                                   () => new SelectMetatypeKarma(this), token).ConfigureAwait(false))
                                        {
                                            if (await frmSelectMetatype.ShowDialogSafeAsync(this, token: token).ConfigureAwait(false) != DialogResult.OK)
                                                return false;
                                        }
                                    }
                                }

                                XPathNavigator xmlKarmaNode = xmlStatBlockBaseNode.SelectSingleNodeAndCacheExpression("karma", token);
                                if (xmlKarmaNode != null)
                                {
                                    int.TryParse(xmlKarmaNode.SelectSingleNodeAndCacheExpression("@left", token)?.Value, NumberStyles.Any,
                                                 GlobalSettings.InvariantCultureInfo, out _intKarma);
                                    int.TryParse(xmlKarmaNode.SelectSingleNodeAndCacheExpression("@total", token)?.Value, NumberStyles.Any,
                                                 GlobalSettings.InvariantCultureInfo, out _intTotalKarma);
                                }

                                XPathNavigator xmlReputationsNode =
                                    xmlStatBlockBaseNode.SelectSingleNodeAndCacheExpression("reputations", token);
                                if (xmlReputationsNode != null)
                                {
                                    int.TryParse(
                                        xmlReputationsNode
                                            .SelectSingleNodeAndCacheExpression("reputation[@name = \"Street Cred\"]/@value", token)
                                            .Value,
                                        NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                        out _intStreetCred);
                                    int.TryParse(
                                        xmlReputationsNode
                                            .SelectSingleNodeAndCacheExpression("reputation[@name = \"Notoriety\"]/@value", token)
                                            .Value,
                                        NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                        out _intNotoriety);
                                    int.TryParse(
                                        xmlReputationsNode
                                            .SelectSingleNodeAndCacheExpression("reputation[@name = \"Public Awareness\"]/@value", token)
                                            .Value, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                        out _intPublicAwareness);
                                }

                                if (Created)
                                {
                                    decimal.TryParse(xmlStatBlockBaseNode.SelectSingleNodeAndCacheExpression("cash/@total", token)?.Value,
                                                     NumberStyles.Any,
                                                     GlobalSettings.InvariantCultureInfo, out _decNuyen);
                                }

                                /* TODO: Initiation, Submersion Grades
                                objXmlCharacter.TryGetInt32FieldQuickly("initiategrade", ref _intInitiateGrade);
                                objXmlCharacter.TryGetInt32FieldQuickly("submersiongrade", ref _intSubmersionGrade);
                                */
                                //Timekeeper.Finish("load_char_misc");
                            }

                            List<Weapon> lstWeapons = new List<Weapon>(1);
                            List<Vehicle> lstVehicles = new List<Vehicle>(1);

                            using (Timekeeper.StartSyncron("load_char_quality", op_load))
                            {
                                string[] astrLevelLabels =
                                {
                                    " (0)",
                                    " (1)",
                                    " (2)",
                                    " (3)",
                                    " (4)",
                                    " (5)",
                                    " (6)",
                                    " (7)",
                                    " (8)",
                                    " (9)",
                                    " (10)",
                                    " (11)",
                                    " (12)",
                                    " (13)",
                                    " (14)",
                                    " (15)"
                                };
                                // Qualities
                                XmlDocument xmlQualitiesDocument = blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? LoadData("qualities.xml", token: token)
                                    : await LoadDataAsync("qualities.xml", token: token).ConfigureAwait(false);
                                foreach (XPathNavigator xmlQualityToImport in xmlStatBlockBaseNode
                                             .SelectAndCacheExpression(
                                                 "qualities/positive/quality[traitcost/@bp != \"0\"]", token))
                                {
                                    string strQualityName = xmlQualityToImport.SelectSingleNodeAndCacheExpression(
                                        "@name", token)?.Value;
                                    if (!string.IsNullOrEmpty(strQualityName))
                                    {
                                        int intDicepoolLabelIndex =
                                            strQualityName.LastIndexOf("dicepool", StringComparison.Ordinal);
                                        if (intDicepoolLabelIndex != -1)
                                        {
                                            int intCullIndex =
                                                strQualityName.LastIndexOf('(', intDicepoolLabelIndex);
                                            if (intCullIndex != -1)
                                                strQualityName = strQualityName.Substring(0, intCullIndex).Trim();
                                        }

                                        int intQuantity = 1;
                                        for (int i = 0; i < astrLevelLabels.Length; ++i)
                                        {
                                            string strLoopString = astrLevelLabels[i];
                                            if (strQualityName.EndsWith(strLoopString, StringComparison.Ordinal))
                                            {
                                                strQualityName = strQualityName.TrimEndOnce(strLoopString, true);
                                                intQuantity = i;
                                                break;
                                            }
                                        }

                                        string strForcedValue = string.Empty;
                                        XmlNode xmlQualityDataNode =
                                            xmlQualitiesDocument.TryGetNodeByNameOrId(
                                                "/chummer/qualities/quality", strQualityName);
                                        if (xmlQualityDataNode == null)
                                        {
                                            foreach (string strInner in strQualityName.SplitNoAlloc(':', StringSplitOptions.RemoveEmptyEntries))
                                            {
                                                string strName = strInner.Trim();
                                                if (xmlQualityDataNode != null)
                                                {
                                                    strForcedValue = strName;
                                                    break;
                                                }
                                                xmlQualityDataNode =
                                                    xmlQualitiesDocument.TryGetNodeByNameOrId(
                                                        "/chummer/qualities/quality", strName);
                                                if (xmlQualityDataNode == null)
                                                    break;
                                            }
                                        }

                                        if (xmlQualityDataNode == null)
                                        {
                                            foreach (string strInner in strQualityName.SplitNoAlloc(',', StringSplitOptions.RemoveEmptyEntries))
                                            {
                                                string strName = strInner.Trim();
                                                if (xmlQualityDataNode != null)
                                                {
                                                    strForcedValue = strName;
                                                    break;
                                                }
                                                xmlQualityDataNode =
                                                    xmlQualitiesDocument.TryGetNodeByNameOrId(
                                                        "/chummer/qualities/quality", strName);
                                                if (xmlQualityDataNode == null)
                                                    break;
                                            }
                                        }

                                        if (xmlQualityDataNode != null)
                                        {
                                            for (int i = 0; i < intQuantity; ++i)
                                            {
                                                Quality objQuality = new Quality(this);
                                                try
                                                {
                                                    token.ThrowIfCancellationRequested();
                                                    if (blnSync)
                                                    {
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        objQuality.Create(xmlQualityDataNode, QualitySource.Selected,
                                                            lstWeapons,
                                                            strForcedValue, token: token);
                                                        objQuality.Notes =
                                                            xmlQualityToImport
                                                                .SelectSingleNodeAndCacheExpression(
                                                                    "description", token)?.Value ??
                                                            string.Empty;
                                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                        _lstQualities.Add(objQuality);
                                                    }
                                                    else
                                                    {
                                                        await objQuality.CreateAsync(xmlQualityDataNode,
                                                            QualitySource.Selected,
                                                            lstWeapons,
                                                            strForcedValue, token: token).ConfigureAwait(false);
                                                        await objQuality.SetNotesAsync(xmlQualityToImport
                                                                .SelectSingleNodeAndCacheExpression(
                                                                    "description", token)?.Value ??
                                                            string.Empty, token).ConfigureAwait(false);
                                                        await _lstQualities.AddAsync(objQuality, token: token)
                                                            .ConfigureAwait(false);
                                                    }
                                                }
                                                catch
                                                {
                                                    if (blnSync)
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        objQuality.DeleteQuality(token: CancellationToken.None);
                                                    else
                                                        await objQuality.DeleteQualityAsync(token: CancellationToken.None).ConfigureAwait(false);
                                                    throw;
                                                }
                                            }
                                        }
                                    }
                                }

                                foreach (XPathNavigator xmlQualityToImport in xmlStatBlockBaseNode.SelectAndCacheExpression(
                                             "qualities/negative/quality[traitcost/@bp != \"0\"]", token))
                                {
                                    string strQualityName = xmlQualityToImport.SelectSingleNodeAndCacheExpression(
                                        "@name", token)?.Value;
                                    if (!string.IsNullOrEmpty(strQualityName))
                                    {
                                        int intDicepoolLabelIndex =
                                            strQualityName.LastIndexOf("dicepool", StringComparison.Ordinal);
                                        if (intDicepoolLabelIndex != -1)
                                        {
                                            int intCullIndex =
                                                strQualityName.LastIndexOf('(', intDicepoolLabelIndex);
                                            if (intCullIndex != -1)
                                                strQualityName = strQualityName.Substring(0, intCullIndex).Trim();
                                        }

                                        switch (strQualityName)
                                        {
                                            case "Reduced (hearing)":
                                                strQualityName = "Reduced Sense (Hearing)";
                                                break;

                                            case "Reduced (smell)":
                                                strQualityName = "Reduced Sense (Smell)";
                                                break;

                                            case "Reduced (taste)":
                                                strQualityName = "Reduced Sense (Taste)";
                                                break;

                                            case "Reduced (touch)":
                                                strQualityName = "Reduced Sense (Touch)";
                                                break;

                                            case "Reduced (sight)":
                                                strQualityName = "Reduced Sense (Sight)";
                                                break;
                                        }

                                        int intQuantity = 1;
                                        for (int i = 0; i < astrLevelLabels.Length; ++i)
                                        {
                                            string strLoopString = astrLevelLabels[i];
                                            if (strQualityName.EndsWith(strLoopString, StringComparison.Ordinal))
                                            {
                                                strQualityName = strQualityName.TrimEndOnce(strLoopString, true);
                                                intQuantity = i;
                                                break;
                                            }
                                        }

                                        string strForcedValue = string.Empty;
                                        XmlNode xmlQualityDataNode =
                                            xmlQualitiesDocument.TryGetNodeByNameOrId(
                                                "/chummer/qualities/quality", strQualityName);
                                        if (xmlQualityDataNode == null)
                                        {
                                            foreach (string strInner in strQualityName.SplitNoAlloc(':', StringSplitOptions.RemoveEmptyEntries))
                                            {
                                                string strName = strInner.Trim();
                                                if (xmlQualityDataNode != null)
                                                {
                                                    strForcedValue = strName;
                                                    break;
                                                }
                                                xmlQualityDataNode =
                                                    xmlQualitiesDocument.TryGetNodeByNameOrId(
                                                        "/chummer/qualities/quality", strName);
                                                if (xmlQualityDataNode == null)
                                                    break;
                                            }
                                        }

                                        if (xmlQualityDataNode == null)
                                        {
                                            foreach (string strInner in strQualityName.SplitNoAlloc(',', StringSplitOptions.RemoveEmptyEntries))
                                            {
                                                string strName = strInner.Trim();
                                                if (xmlQualityDataNode != null)
                                                {
                                                    strForcedValue = strName;
                                                    break;
                                                }
                                                xmlQualityDataNode =
                                                    xmlQualitiesDocument.TryGetNodeByNameOrId(
                                                        "/chummer/qualities/quality", strName);
                                                if (xmlQualityDataNode == null)
                                                    break;
                                            }
                                        }

                                        if (xmlQualityDataNode != null)
                                        {
                                            for (int i = 0; i < intQuantity; ++i)
                                            {
                                                Quality objQuality = new Quality(this);
                                                try
                                                {
                                                    token.ThrowIfCancellationRequested();
                                                    if (blnSync)
                                                    {
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        objQuality.Create(xmlQualityDataNode, QualitySource.Selected,
                                                            lstWeapons,
                                                            strForcedValue, token: token);
                                                        objQuality.Notes =
                                                            xmlQualityToImport
                                                                .SelectSingleNodeAndCacheExpression(
                                                                    "description", token)?.Value ??
                                                            string.Empty;
                                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                        _lstQualities.Add(objQuality);
                                                    }
                                                    else
                                                    {
                                                        await objQuality.CreateAsync(xmlQualityDataNode,
                                                            QualitySource.Selected,
                                                            lstWeapons,
                                                            strForcedValue, token: token).ConfigureAwait(false);
                                                        await objQuality.SetNotesAsync(xmlQualityToImport
                                                                .SelectSingleNodeAndCacheExpression(
                                                                    "description", token)?.Value ??
                                                            string.Empty, token).ConfigureAwait(false);
                                                        await _lstQualities.AddAsync(objQuality, token: token)
                                                            .ConfigureAwait(false);
                                                    }
                                                }
                                                catch
                                                {
                                                    if (blnSync)
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        objQuality.DeleteQuality(token: CancellationToken.None);
                                                    else
                                                        await objQuality.DeleteQualityAsync(token: CancellationToken.None).ConfigureAwait(false);
                                                    throw;
                                                }
                                            }
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_quality");
                            }

                            AttributeSection.LoadFromHeroLab(xmlStatBlockBaseNode, op_load, token);
                            using (Timekeeper.StartSyncron("load_char_misc2", op_load))
                            {
                                /* TODO: Find some way to get Mystic Adept PPs from Hero Lab files
                                // Attempt to load the split MAG CharacterAttribute information for Mystic Adepts.
                                if (_blnAdeptEnabled && _blnMagicianEnabled)
                                {
                                    xmlCharacterNavigator.TryGetInt32FieldQuickly("magsplitadept", ref _intMAGAdept);
                                    xmlCharacterNavigator.TryGetInt32FieldQuickly("magsplitmagician", ref _intMAGMagician);
                                }
                                */

                                // Attempt to load in the character's tradition
                                XPathNavigator xmlTemp
                                    = xmlStatBlockBaseNode.SelectSingleNodeAndCacheExpression(
                                        "magic/tradition", token);
                                if (xmlTemp != null)
                                {
                                    _objTradition.LoadFromHeroLab(xmlTemp);
                                }

                                // Attempt to load Condition Monitor Progress.
                                XPathNavigator xmlPhysicalCMFilledNode =
                                    xmlLeadsBaseNode.SelectSingleNodeAndCacheExpression(
                                        "usagepool[@id = \"DmgNet\" and @pickindex=\"5\"]/@quantity", token);
                                if (xmlPhysicalCMFilledNode != null)
                                    int.TryParse(xmlPhysicalCMFilledNode.Value, NumberStyles.Any,
                                                 GlobalSettings.InvariantCultureInfo, out _intPhysicalCMFilled);
                                XPathNavigator xmlStunCMFilledNode =
                                    xmlLeadsBaseNode.SelectSingleNodeAndCacheExpression(
                                        "usagepool[@id = \"DmgNet\" and @pickindex=\"6\"]/@quantity", token);
                                if (xmlStunCMFilledNode != null)
                                    int.TryParse(xmlStunCMFilledNode.Value, NumberStyles.Any,
                                                 GlobalSettings.InvariantCultureInfo, out _intStunCMFilled);
                                //Timekeeper.Finish("load_char_misc2");
                            }

                            using (CustomActivity op_load_char_skills = Timekeeper.StartSyncron("load_char_skills", op_load)) //slightly messy
                            {
                                SkillsSection.LoadFromHeroLab(xmlStatBlockBaseNode.SelectSingleNodeAndCacheExpression("skills", token),
                                    op_load_char_skills, token);

                                //Timekeeper.Finish("load_char_skills");
                            }

                            /* TODO: Add support for locations from HeroLab
                            Timekeeper.Start("load_char_loc");

                            // Locations.
                            XmlNodeList objXmlLocationList = objXmlCharacter.SelectNodes("gearlocations/gearlocation");
                            foreach (XmlNode objXmlLocation in objXmlLocationList)
                            {
                                Location objLocation = new Location(this, _lstGearLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }

                            objXmlLocationList = objXmlCharacter.SelectNodes("locations/location");
                            foreach (XmlNode objXmlLocation in objXmlLocationList)
                            {
                                Location objLocation = new Location(this, _lstGearLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }

                            objXmlLocationList = objXmlCharacter.SelectNodes("gearlocations/location");
                            foreach (XmlNode objXmlLocation in objXmlLocationList)
                            {
                                Location objLocation = new Location(this, _lstGearLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }

                            Timekeeper.Finish("load_char_loc");
                            Timekeeper.Start("load_char_abundle");

                            // Armor Bundles.
                            objXmlLocationList = objXmlCharacter.SelectNodes("armorbundles/armorbundle");
                            foreach (XmlNode objXmlLocation in objXmlLocationList)
                            {
                                Location objLocation = new Location(this, _lstArmorLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }

                            objXmlLocationList = objXmlCharacter.SelectNodes("armorlocations/armorlocation");
                            foreach (XmlNode objXmlLocation in objXmlLocationList)
                            {
                                Location objLocation = new Location(this, _lstArmorLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }

                            objXmlLocationList = objXmlCharacter.SelectNodes("armorlocations/location");
                            foreach (XmlNode objXmlLocation in objXmlLocationList)
                            {
                                Location objLocation = new Location(this, _lstArmorLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }

                            Timekeeper.Finish("load_char_abundle");
                            Timekeeper.Start("load_char_vloc");

                            // Vehicle Locations.
                            XmlNodeList objXmlVehicleLocationList = objXmlCharacter.SelectNodes("vehiclelocations/vehiclelocation");
                            foreach (XmlNode objXmlLocation in objXmlVehicleLocationList)
                            {
                                Location objLocation = new Location(this, _lstVehicleLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }

                            objXmlVehicleLocationList = objXmlCharacter.SelectNodes("vehiclelocations/location");
                            foreach (XmlNode objXmlLocation in objXmlVehicleLocationList)
                            {
                                Location objLocation = new Location(this, _lstVehicleLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }

                            Timekeeper.Finish("load_char_vloc");
                            Timekeeper.Start("load_char_wloc");

                            // Weapon Locations.
                            XmlNodeList objXmlWeaponLocationList = objXmlCharacter.SelectNodes("weaponlocations/weaponlocation");
                            foreach (XmlNode objXmlLocation in objXmlWeaponLocationList)
                            {
                                Location objLocation = new Location(this, _lstWeaponLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }

                            objXmlWeaponLocationList = objXmlCharacter.SelectNodes("weaponlocations/location");
                            foreach (XmlNode objXmlLocation in objXmlWeaponLocationList)
                            {
                                Location objLocation = new Location(this, _lstWeaponLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }

                            Timekeeper.Finish("load_char_wloc");
                            */
                            using (Timekeeper.StartSyncron("load_char_contacts", op_load))
                            {
                                // Contacts.
                                foreach (XPathNavigator xmlContactToImport in xmlStatBlockBaseNode.SelectAndCacheExpression(
                                             "contacts/contact[@useradded != \"no\"]", token))
                                {
                                    Contact objContact = new Contact(this);
                                    try
                                    {
                                        objContact.EntityType = ContactType.Contact;
                                        objContact.Name
                                            = xmlContactToImport.SelectSingleNodeAndCacheExpression("@name", token)
                                                ?.Value ?? string.Empty;
                                        objContact.Role
                                            = xmlContactToImport.SelectSingleNodeAndCacheExpression("@type", token)
                                                ?.Value ?? string.Empty;
                                        objContact.Connection =
                                            xmlContactToImport.SelectSingleNodeAndCacheExpression("@connection", token)
                                                ?.ValueAsInt ?? 1;
                                        objContact.Loyalty = xmlContactToImport
                                            .SelectSingleNodeAndCacheExpression("@loyalty", token)
                                            ?.ValueAsInt ?? 1;

                                        string strDescription =
                                            xmlContactToImport.SelectSingleNodeAndCacheExpression(
                                                "description", token)?.Value;
                                        using (new FetchSafelyFromObjectPool<StringBuilder>(
                                                   Utils.StringBuilderPool, out StringBuilder sbdNotes))
                                        {
                                            foreach (string strLine in strDescription.SplitNoAlloc('\n',
                                                         StringSplitOptions.RemoveEmptyEntries))
                                            {
                                                string[] astrLineColonSplit =
                                                    strLine.SplitFixedSizePooledArray(':', 2, StringSplitOptions.RemoveEmptyEntries);
                                                try
                                                {
                                                    switch (astrLineColonSplit[0])
                                                    {
                                                        case "Metatype":
                                                            objContact.Metatype = astrLineColonSplit[1].Trim();
                                                            break;

                                                        case "Gender":
                                                            objContact.Gender = astrLineColonSplit[1].Trim();
                                                            break;

                                                        case "Age":
                                                            objContact.Age = astrLineColonSplit[1].Trim();
                                                            break;

                                                        case "Preferred Payment Method":
                                                            objContact.PreferredPayment = astrLineColonSplit[1].Trim();
                                                            break;

                                                        case "Hobbies/Vice":
                                                            objContact.HobbiesVice = astrLineColonSplit[1].Trim();
                                                            break;

                                                        case "Personal Life":
                                                            objContact.PersonalLife = astrLineColonSplit[1].Trim();
                                                            break;

                                                        case "Type":
                                                            objContact.Type = astrLineColonSplit[1].Trim();
                                                            break;

                                                        default:
                                                            sbdNotes.AppendLine(strLine);
                                                            break;
                                                    }
                                                }
                                                finally
                                                {
                                                    ArrayPool<string>.Shared.Return(astrLineColonSplit);
                                                }
                                            }

                                            if (sbdNotes.Length > 0)
                                                sbdNotes.Length -= Environment.NewLine.Length;
                                            if (blnSync)
                                                objContact.Notes = sbdNotes.ToString();
                                            else
                                                await objContact.SetNotesAsync(sbdNotes.ToString(), token).ConfigureAwait(false);
                                        }

                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstContacts.Add(objContact);
                                        else
                                            await _lstContacts.AddAsync(objContact, token).ConfigureAwait(false);
                                    }
                                    catch
                                    {
                                        try
                                        {
                                            if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                _lstContacts.Remove(objContact);
                                            else
                                                await _lstContacts.RemoveAsync(objContact, CancellationToken.None).ConfigureAwait(false);
                                        }
                                        catch
                                        {
                                            //swallow this
                                        }
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverload
                                            objContact.Dispose();
                                        else
                                            await objContact.DisposeAsync().ConfigureAwait(false);
                                        throw;
                                    }
                                }

                                //Timekeeper.Finish("load_char_contacts");
                            }

                            XmlDocument xmlGearDocument;
                            using (Timekeeper.StartSyncron("load_char_armor", op_load))
                            {
                                // Armor.
                                xmlGearDocument = blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? LoadData("gear.xml", token: token)
                                    : await LoadDataAsync("gear.xml", token: token).ConfigureAwait(false);
                                XmlDocument xmlArmorDocument = blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? LoadData("armor.xml", token: token)
                                    : await LoadDataAsync("armor.xml", token: token).ConfigureAwait(false);
                                foreach (XPathNavigator xmlArmorToImport in xmlStatBlockBaseNode
                                             .SelectAndCacheExpression(
                                                 "gear/armor/item[@useradded != \"no\"]", token))
                                {
                                    string strArmorName = xmlArmorToImport.SelectSingleNodeAndCacheExpression(
                                        "@name", token)?.Value;
                                    if (!string.IsNullOrEmpty(strArmorName))
                                    {
                                        XmlNode xmlArmorData =
                                            xmlArmorDocument.TryGetNodeByNameOrId(
                                                "/chummer/armors/armor", strArmorName);
                                        if (xmlArmorData == null)
                                        {
                                            string strDummy = strArmorName.SplitNoAlloc(':', StringSplitOptions.RemoveEmptyEntries).FirstOrDefault()?.Trim() ?? string.Empty;
                                            if (!string.IsNullOrEmpty(strDummy))
                                            {
                                                xmlArmorData =
                                                    xmlArmorDocument.TryGetNodeByNameOrId(
                                                        "/chummer/armors/armor", strDummy);
                                            }

                                            if (xmlArmorData == null)
                                            {
                                                strDummy = strArmorName.SplitNoAlloc(',', StringSplitOptions.RemoveEmptyEntries).FirstOrDefault()?.Trim() ?? string.Empty;
                                                if (!string.IsNullOrEmpty(strDummy))
                                                {
                                                    xmlArmorData =
                                                        xmlArmorDocument.TryGetNodeByNameOrId(
                                                            "/chummer/armors/armor", strDummy);
                                                }
                                            }
                                        }

                                        if (xmlArmorData != null)
                                        {
                                            Armor objArmor = new Armor(this);
                                            if (blnSync)
                                            {
                                                try
                                                {
                                                    // ReSharper disable once MethodHasAsyncOverload
                                                    objArmor.Create(xmlArmorData,
                                                        xmlArmorToImport.SelectSingleNodeAndCacheExpression(
                                                                "@rating", token)
                                                            ?.ValueAsInt
                                                        ?? 0,
                                                        lstWeapons, token: token);
                                                    objArmor.Notes = xmlArmorToImport.SelectSingleNodeAndCacheExpression(
                                                            "description", token)
                                                        ?.Value;
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    _lstArmor.Add(objArmor);
                                                }
                                                catch
                                                {
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    objArmor.DeleteArmor();
                                                    throw;
                                                }
                                            }
                                            else
                                            {
                                                try
                                                {
                                                    await objArmor.CreateAsync(xmlArmorData,
                                                        xmlArmorToImport.SelectSingleNodeAndCacheExpression(
                                                                "@rating", token)
                                                            ?.ValueAsInt
                                                        ?? 0,
                                                        lstWeapons, token: token).ConfigureAwait(false);
                                                    await objArmor.SetNotesAsync(xmlArmorToImport.SelectSingleNodeAndCacheExpression(
                                                            "description", token)
                                                        ?.Value, token).ConfigureAwait(false);
                                                    await _lstArmor.AddAsync(objArmor, token).ConfigureAwait(false);
                                                }
                                                catch
                                                {
                                                    await objArmor.DeleteArmorAsync(token: CancellationToken.None).ConfigureAwait(false);
                                                    throw;
                                                }
                                            }
                                            foreach (string strName in HeroLabPluginNodeNames)
                                            {
                                                foreach (XPathNavigator xmlArmorModToImport in xmlArmorToImport
                                                             .Select(
                                                                 strName + "/item[@useradded != \"no\"]"))
                                                {
                                                    string strArmorModName =
                                                        xmlArmorModToImport.SelectSingleNodeAndCacheExpression(
                                                            "@name", token)?.Value;
                                                    if (!string.IsNullOrEmpty(strArmorModName))
                                                    {
                                                        XmlNode xmlArmorModData =
                                                            xmlArmorDocument.TryGetNodeByNameOrId(
                                                                "chummer/mods/mod", strArmorModName);
                                                        if (xmlArmorModData != null)
                                                        {
                                                            ArmorMod objArmorMod = new ArmorMod(this, objArmor);
                                                            if (blnSync)
                                                            {
                                                                try
                                                                {
                                                                    // ReSharper disable once MethodHasAsyncOverload
                                                                    objArmorMod.Create(xmlArmorModData,
                                                                        xmlArmorModToImport
                                                                            .SelectSingleNodeAndCacheExpression(
                                                                                "@rating", token)
                                                                                       ?.ValueAsInt ?? 0, lstWeapons, token: token);
                                                                    objArmorMod.Notes = xmlArmorModToImport
                                                                        .SelectSingleNodeAndCacheExpression(
                                                                            "description", token)
                                                                        ?.Value;
                                                                    objArmorMod.Parent = objArmor;
                                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                                    objArmor.ArmorMods.Add(objArmorMod);
                                                                }
                                                                catch
                                                                {
                                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                                    objArmorMod.DeleteArmorMod();
                                                                    throw;
                                                                }
                                                            }
                                                            else
                                                            {
                                                                try
                                                                {
                                                                    await objArmorMod.CreateAsync(xmlArmorModData,
                                                                        xmlArmorModToImport
                                                                            .SelectSingleNodeAndCacheExpression(
                                                                                "@rating", token)
                                                                            ?.ValueAsInt ?? 0, lstWeapons, token: token).ConfigureAwait(false);
                                                                    await objArmorMod.SetNotesAsync(xmlArmorModToImport
                                                                        .SelectSingleNodeAndCacheExpression(
                                                                            "description", token)
                                                                        ?.Value, token).ConfigureAwait(false);
                                                                    objArmorMod.Parent = objArmor;
                                                                    await objArmor.ArmorMods.AddAsync(objArmorMod, token)
                                                                                  .ConfigureAwait(false);
                                                                }
                                                                catch
                                                                {
                                                                    await objArmorMod.DeleteArmorModAsync(token: CancellationToken.None).ConfigureAwait(false);
                                                                    throw;
                                                                }
                                                            }

                                                            foreach (string strPluginNodeName in
                                                                     HeroLabPluginNodeNames)
                                                            {
                                                                foreach (XPathNavigator xmlPluginToAdd in
                                                                         xmlArmorModToImport
                                                                             .Select(strPluginNodeName +
                                                                                 "/item[@useradded != \"no\"]"))
                                                                {
                                                                    Gear objPlugin = new Gear(this);
                                                                    try
                                                                    {
                                                                        if (blnSync)
                                                                        {
                                                                            // ReSharper disable once MethodHasAsyncOverload
                                                                            if (objPlugin.ImportHeroLabGear(xmlPluginToAdd,
                                                                                    xmlArmorModData,
                                                                                    lstWeapons, token))
                                                                            {
                                                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                                                objArmorMod.GearChildren.Add(objPlugin);
                                                                            }
                                                                            else
                                                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                                                objPlugin.DeleteGear();
                                                                        }
                                                                        else
                                                                        {
                                                                            if (await objPlugin.ImportHeroLabGearAsync(
                                                                                        xmlPluginToAdd,
                                                                                        xmlArmorModData,
                                                                                        lstWeapons, token)
                                                                                    .ConfigureAwait(false))
                                                                                await objArmorMod.GearChildren
                                                                                    .AddAsync(objPlugin, token)
                                                                                    .ConfigureAwait(false);
                                                                            else
                                                                                await objPlugin.DeleteGearAsync(token: token)
                                                                                    .ConfigureAwait(false);
                                                                        }
                                                                    }
                                                                    catch
                                                                    {
                                                                        if (blnSync)
                                                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                                            objPlugin.DeleteGear();
                                                                        else
                                                                            await objPlugin.DeleteGearAsync(token: CancellationToken.None).ConfigureAwait(false);
                                                                        throw;
                                                                    }
                                                                }

                                                                foreach (XPathNavigator xmlPluginToAdd in
                                                                         xmlArmorModToImport
                                                                             .Select(strPluginNodeName +
                                                                                 "/item[@useradded = \"no\"]"))
                                                                {
                                                                    string strGearName = xmlPluginToAdd
                                                                        .SelectSingleNodeAndCacheExpression(
                                                                            "@name", token)?.Value;
                                                                    if (!string.IsNullOrEmpty(strGearName))
                                                                    {
                                                                        if (blnSync)
                                                                        {
                                                                            // ReSharper disable MethodHasAsyncOverload
                                                                            Gear objPlugin
                                                                                = objArmorMod.GearChildren
                                                                                    .FirstOrDefault(
                                                                                        x =>
                                                                                            x.IncludedInParent &&
                                                                                            (x.Name.Contains(
                                                                                                    strGearName) ||
                                                                                                strGearName.Contains(
                                                                                                    x.Name)));
                                                                            if (objPlugin != null)
                                                                            {
                                                                                objPlugin.Quantity = xmlPluginToAdd
                                                                                        .SelectSingleNodeAndCacheExpression(
                                                                                            "@quantity", token)
                                                                                        ?.ValueAsInt
                                                                                    ?? 1;
                                                                                objPlugin.Notes = xmlPluginToAdd
                                                                                    .SelectSingleNodeAndCacheExpression(
                                                                                        "description", token)?.Value;
                                                                                objPlugin.ProcessHeroLabGearPlugins(
                                                                                    xmlPluginToAdd,
                                                                                    lstWeapons, token);
                                                                            }
                                                                            // ReSharper restore MethodHasAsyncOverload
                                                                        }
                                                                        else
                                                                        {
                                                                            Gear objPlugin = await objArmorMod
                                                                                .GearChildren
                                                                                .FirstOrDefaultAsync(
                                                                                    x =>
                                                                                        x.IncludedInParent &&
                                                                                        (x.Name.Contains(strGearName) ||
                                                                                            strGearName.Contains(
                                                                                                x.Name)), token)
                                                                                .ConfigureAwait(false);
                                                                            if (objPlugin != null)
                                                                            {
                                                                                await objPlugin.SetQuantityAsync((xmlPluginToAdd
                                                                                        .SelectSingleNodeAndCacheExpression(
                                                                                            "@quantity", token))
                                                                                    ?.ValueAsInt ?? 1, token).ConfigureAwait(false);
                                                                                await objPlugin.SetNotesAsync(
                                                                                    (xmlPluginToAdd
                                                                                        .SelectSingleNodeAndCacheExpression(
                                                                                            "description", token))
                                                                                    ?.Value, token).ConfigureAwait(false);
                                                                                await objPlugin
                                                                                    .ProcessHeroLabGearPluginsAsync(
                                                                                        xmlPluginToAdd,
                                                                                        lstWeapons, token).ConfigureAwait(false);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        else
                                                        {
                                                            Gear objPlugin = new Gear(this);
                                                            try
                                                            {
                                                                if (blnSync)
                                                                {
                                                                    // ReSharper disable once MethodHasAsyncOverload
                                                                    if (objPlugin.ImportHeroLabGear(xmlArmorModToImport,
                                                                            xmlArmorData,
                                                                            lstWeapons, token))
                                                                    {
                                                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                                        objArmor.GearChildren.Add(objPlugin);
                                                                    }
                                                                    else
                                                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                                        objPlugin.DeleteGear();
                                                                }
                                                                else if (await objPlugin.ImportHeroLabGearAsync(xmlArmorModToImport,
                                                                             xmlArmorData,
                                                                             lstWeapons, token).ConfigureAwait(false))
                                                                {
                                                                    await objArmor.GearChildren
                                                                            .AddAsync(objPlugin, token)
                                                                            .ConfigureAwait(false);
                                                                }
                                                                else
                                                                    await objPlugin.DeleteGearAsync(token: CancellationToken.None).ConfigureAwait(false);
                                                            }
                                                            catch
                                                            {
                                                                if (blnSync)
                                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                                    objPlugin.DeleteGear();
                                                                else
                                                                    await objPlugin.DeleteGearAsync(token: CancellationToken.None).ConfigureAwait(false);
                                                                throw;
                                                            }
                                                        }
                                                    }
                                                }

                                                foreach (XPathNavigator xmlArmorModToImport in xmlArmorToImport
                                                             .Select(
                                                                 strName + "/item[@useradded = \"no\"]"))
                                                {
                                                    string strArmorModName =
                                                        xmlArmorModToImport.SelectSingleNodeAndCacheExpression(
                                                            "@name", token)?.Value;
                                                    if (!string.IsNullOrEmpty(strArmorModName))
                                                    {
                                                        ArmorMod objArmorMod = blnSync
                                                            ? objArmor.ArmorMods.FirstOrDefault(
                                                                x =>
                                                                    x.IncludedInArmor &&
                                                                    (x.Name.Contains(strArmorModName) ||
                                                                     strArmorModName.Contains(x.Name)))
                                                            : await objArmor.ArmorMods.FirstOrDefaultAsync(
                                                                                x =>
                                                                                    x.IncludedInArmor &&
                                                                                    (x.Name.Contains(strArmorModName) ||
                                                                                        strArmorModName
                                                                                            .Contains(x.Name)), token)
                                                                            .ConfigureAwait(false);
                                                        if (objArmorMod != null)
                                                        {
                                                            if (blnSync)
                                                            {
                                                                objArmorMod.Notes = xmlArmorModToImport
                                                                    .SelectSingleNodeAndCacheExpression(
                                                                        "description", token)
                                                                    ?.Value;
                                                            }
                                                            else
                                                            {
                                                                await objArmorMod.SetNotesAsync(xmlArmorModToImport
                                                                    .SelectSingleNodeAndCacheExpression(
                                                                        "description", token)
                                                                    ?.Value, token).ConfigureAwait(false);
                                                            }
                                                            foreach (string strPluginNodeName in
                                                                        HeroLabPluginNodeNames)
                                                            {
                                                                foreach (XPathNavigator xmlPluginToAdd in
                                                                            xmlArmorModToImport
                                                                                .Select(strPluginNodeName +
                                                                                    "/item[@useradded != \"no\"]"))
                                                                {
                                                                    Gear objPlugin = new Gear(this);
                                                                    try
                                                                    {
                                                                        if (blnSync)
                                                                        {
                                                                            // ReSharper disable once MethodHasAsyncOverload
                                                                            if (objPlugin.ImportHeroLabGear(xmlPluginToAdd,
                                                                                    // ReSharper disable once MethodHasAsyncOverload
                                                                                    objArmorMod.GetNode(token),
                                                                                    lstWeapons, token))
                                                                            {
                                                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                                                objArmorMod.GearChildren.Add(objPlugin);
                                                                            }
                                                                            else
                                                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                                                objPlugin.DeleteGear();
                                                                        }
                                                                        else if (await objPlugin.ImportHeroLabGearAsync(xmlPluginToAdd,
                                                                                        await objArmorMod.GetNodeAsync(token)
                                                                                            .ConfigureAwait(false),
                                                                                        lstWeapons, token).ConfigureAwait(false))
                                                                        {
                                                                            await objArmorMod.GearChildren
                                                                                .AddAsync(objPlugin, token)
                                                                                .ConfigureAwait(false);
                                                                        }
                                                                        else
                                                                            await objPlugin.DeleteGearAsync(token: token).ConfigureAwait(false);
                                                                    }
                                                                    catch
                                                                    {
                                                                        if (blnSync)
                                                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                                            objPlugin.DeleteGear();
                                                                        else
                                                                            await objPlugin.DeleteGearAsync(token: CancellationToken.None).ConfigureAwait(false);
                                                                        throw;
                                                                    }
                                                                }

                                                                foreach (XPathNavigator xmlPluginToAdd in
                                                                            xmlArmorModToImport
                                                                                .Select(strPluginNodeName +
                                                                                    "/item[@useradded = \"no\"]"))
                                                                {
                                                                    string strGearName = xmlPluginToAdd
                                                                        .SelectSingleNodeAndCacheExpression(
                                                                            "@name", token)?.Value;
                                                                    if (!string.IsNullOrEmpty(strGearName))
                                                                    {
                                                                        if (blnSync)
                                                                        {
                                                                            // ReSharper disable MethodHasAsyncOverload
                                                                            Gear objPlugin
                                                                                = objArmor.GearChildren.FirstOrDefault(
                                                                                    x =>
                                                                                        x.IncludedInParent &&
                                                                                        (x.Name.Contains(strGearName) ||
                                                                                            strGearName.Contains(
                                                                                                x.Name)));
                                                                            if (objPlugin != null)
                                                                            {
                                                                                objPlugin.Quantity = xmlPluginToAdd
                                                                                        .SelectSingleNodeAndCacheExpression(
                                                                                            "@quantity", token)
                                                                                        ?.ValueAsInt
                                                                                    ?? 1;
                                                                                objPlugin.Notes = xmlPluginToAdd
                                                                                    .SelectSingleNodeAndCacheExpression(
                                                                                        "description", token)?.Value;
                                                                                objPlugin.ProcessHeroLabGearPlugins(
                                                                                    xmlPluginToAdd,
                                                                                    lstWeapons, token);
                                                                            }
                                                                            // ReSharper restore MethodHasAsyncOverload
                                                                        }
                                                                        else
                                                                        {
                                                                            Gear objPlugin = await objArmor.GearChildren
                                                                                .FirstOrDefaultAsync(
                                                                                    x =>
                                                                                        x.IncludedInParent &&
                                                                                        (x.Name.Contains(strGearName) ||
                                                                                            strGearName.Contains(
                                                                                                x.Name)), token)
                                                                                .ConfigureAwait(false);
                                                                            if (objPlugin != null)
                                                                            {
                                                                                await objPlugin.SetQuantityAsync((xmlPluginToAdd
                                                                                        .SelectSingleNodeAndCacheExpression(
                                                                                            "@quantity", token))
                                                                                    ?.ValueAsInt ?? 1, token).ConfigureAwait(false);
                                                                                await objPlugin.SetNotesAsync(
                                                                                    (xmlPluginToAdd
                                                                                        .SelectSingleNodeAndCacheExpression(
                                                                                            "description", token))
                                                                                    ?.Value, token).ConfigureAwait(false);
                                                                                await objPlugin
                                                                                    .ProcessHeroLabGearPluginsAsync(
                                                                                        xmlPluginToAdd,
                                                                                        lstWeapons, token).ConfigureAwait(false);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        else if (blnSync)
                                                        {
                                                            // ReSharper disable MethodHasAsyncOverload
                                                            Gear objPlugin = objArmor.GearChildren.FirstOrDefault(
                                                                x =>
                                                                    x.IncludedInParent &&
                                                                    (x.Name.Contains(strArmorModName) ||
                                                                     strArmorModName.Contains(x.Name)));
                                                            if (objPlugin != null)
                                                            {
                                                                objPlugin.Quantity = xmlArmorModToImport
                                                                    .SelectSingleNodeAndCacheExpression(
                                                                        "@quantity", token)?.ValueAsInt ?? 1;
                                                                objPlugin.Notes = xmlArmorModToImport
                                                                    .SelectSingleNodeAndCacheExpression(
                                                                        "description", token)?.Value;
                                                                objPlugin.ProcessHeroLabGearPlugins(
                                                                    xmlArmorModToImport,
                                                                    lstWeapons, token);
                                                            }
                                                            // ReSharper restore MethodHasAsyncOverload
                                                        }
                                                        else
                                                        {
                                                            Gear objPlugin = await objArmor.GearChildren
                                                                .FirstOrDefaultAsync(
                                                                    x =>
                                                                        x.IncludedInParent &&
                                                                        (x.Name.Contains(strArmorModName) ||
                                                                         strArmorModName.Contains(x.Name)), token)
                                                                .ConfigureAwait(false);
                                                            if (objPlugin != null)
                                                            {
                                                                await objPlugin.SetQuantityAsync((xmlArmorModToImport
                                                                                        .SelectSingleNodeAndCacheExpression(
                                                                                            "@quantity", token))
                                                                                    ?.ValueAsInt ?? 1, token).ConfigureAwait(false);
                                                                await objPlugin.SetNotesAsync((xmlArmorModToImport
                                                                    .SelectSingleNodeAndCacheExpression(
                                                                        "description", token))?.Value, token).ConfigureAwait(false);
                                                                await objPlugin.ProcessHeroLabGearPluginsAsync(
                                                                    xmlArmorModToImport,
                                                                    lstWeapons, token).ConfigureAwait(false);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_armor");
                            }

                            using (Timekeeper.StartSyncron("load_char_weapons", op_load))
                            {
                                // Weapons.
                                foreach (XPathNavigator xmlWeaponToImport in xmlStatBlockBaseNode.Select(
                                             "gear/weapons/item[@useradded != \"no\"]"))
                                {
                                    Weapon objWeapon = new Weapon(this);
                                    try
                                    {
                                        if (objWeapon.ImportHeroLabWeapon(xmlWeaponToImport, lstWeapons))
                                        {
                                            if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                _lstWeapons.Add(objWeapon);
                                            else
                                                await _lstWeapons.AddAsync(objWeapon, token).ConfigureAwait(false);
                                        }
                                        else if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            objWeapon.DeleteWeapon();
                                        else
                                            await objWeapon.DeleteWeaponAsync(token: token).ConfigureAwait(false);
                                    }
                                    catch
                                    {
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            objWeapon.DeleteWeapon();
                                        else
                                            await objWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                                        throw;
                                    }
                                }

                                foreach (XPathNavigator xmlPluginToAdd in xmlStatBlockBaseNode.Select(
                                             "gear/weapons/item[@useradded = \"no\"]"))
                                {
                                    string strName
                                        = xmlPluginToAdd.SelectSingleNodeAndCacheExpression("@name", token)?.Value;
                                    if (!string.IsNullOrEmpty(strName))
                                    {
                                        Weapon objWeapon = _lstWeapons.FirstOrDefault(x =>
                                            !string.IsNullOrEmpty(x.ParentID) &&
                                            (x.Name.Contains(strName) || strName.Contains(x.Name)));
                                        if (objWeapon != null)
                                        {
                                            if (blnSync)
                                                objWeapon.Notes = xmlPluginToAdd.SelectSingleNodeAndCacheExpression(
                                                    "description", token)?.Value;
                                            else
                                                await objWeapon.SetNotesAsync(xmlPluginToAdd.SelectSingleNodeAndCacheExpression(
                                                    "description", token)?.Value, token).ConfigureAwait(false);
                                            objWeapon.ProcessHeroLabWeaponPlugins(xmlPluginToAdd, lstWeapons);
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_weapons");
                            }

                            using (Timekeeper.StartSyncron("load_char_ware", op_load))
                            {
                                // Cyberware/Bioware.
                                foreach (XPathNavigator xmlCyberwareToImport in xmlStatBlockBaseNode.Select(
                                             "gear/augmentations/cyberware/item[@useradded != \"no\"]"))
                                {
                                    Cyberware objCyberware = new Cyberware(this);
                                    try
                                    {
                                        if (objCyberware.ImportHeroLabCyberware(xmlCyberwareToImport, null, lstWeapons,
                                                                                lstVehicles))
                                        {
                                            if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                _lstCyberware.Add(objCyberware);
                                            else
                                                await _lstCyberware.AddAsync(objCyberware, token).ConfigureAwait(false);
                                        }
                                        else if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            objCyberware.DeleteCyberware();
                                        else
                                            await objCyberware.DeleteCyberwareAsync(token: token).ConfigureAwait(false);
                                    }
                                    catch
                                    {
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            objCyberware.DeleteCyberware();
                                        else
                                            await objCyberware.DeleteCyberwareAsync(token: CancellationToken.None).ConfigureAwait(false);
                                        throw;
                                    }
                                }

                                foreach (XPathNavigator xmlPluginToAdd in xmlStatBlockBaseNode.Select(
                                             "gear/augmentations/cyberware/item[@useradded = \"no\"]"))
                                {
                                    string strName
                                        = xmlPluginToAdd.SelectSingleNodeAndCacheExpression("@name", token)?.Value;
                                    if (!string.IsNullOrEmpty(strName))
                                    {
                                        Cyberware objPlugin = _lstCyberware.FirstOrDefault(x =>
                                            !string.IsNullOrEmpty(x.ParentID) &&
                                            (x.Name.Contains(strName) || strName.Contains(x.Name)));
                                        if (objPlugin != null)
                                        {
                                            objPlugin.Notes = xmlPluginToAdd.SelectSingleNodeAndCacheExpression(
                                                "description", token)?.Value;
                                            objPlugin.ProcessHeroLabCyberwarePlugins(xmlPluginToAdd,
                                                blnSync ? objPlugin.Grade : await objPlugin.GetGradeAsync(token).ConfigureAwait(false),
                                                lstWeapons,
                                                lstVehicles);
                                        }
                                    }
                                }

                                foreach (XPathNavigator xmlCyberwareToImport in xmlStatBlockBaseNode.Select(
                                             "gear/augmentations/bioware/item[@useradded != \"no\"]"))
                                {
                                    Cyberware objCyberware = new Cyberware(this);
                                    try
                                    {
                                        if (objCyberware.ImportHeroLabCyberware(xmlCyberwareToImport, null, lstWeapons,
                                                                                lstVehicles))
                                        {
                                            if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                _lstCyberware.Add(objCyberware);
                                            else
                                                await _lstCyberware.AddAsync(objCyberware, token).ConfigureAwait(false);
                                        }
                                        else if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            objCyberware.DeleteCyberware();
                                        else
                                            await objCyberware.DeleteCyberwareAsync(token: token).ConfigureAwait(false);
                                    }
                                    catch
                                    {
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            objCyberware.DeleteCyberware();
                                        else
                                            await objCyberware.DeleteCyberwareAsync(token: CancellationToken.None).ConfigureAwait(false);
                                        throw;
                                    }
                                }

                                foreach (XPathNavigator xmlPluginToAdd in xmlStatBlockBaseNode.Select(
                                             "gear/augmentations/bioware/item[@useradded = \"no\"]"))
                                {
                                    string strName
                                        = xmlPluginToAdd.SelectSingleNodeAndCacheExpression("@name", token)?.Value;
                                    if (!string.IsNullOrEmpty(strName))
                                    {
                                        Cyberware objPlugin = blnSync
                                            ? _lstCyberware.FirstOrDefault(x =>
                                                !string.IsNullOrEmpty(x.ParentID) &&
                                                (x.Name.Contains(strName) || strName.Contains(x.Name)))
                                            : await _lstCyberware.FirstOrDefaultAsync(x =>
                                                !string.IsNullOrEmpty(x.ParentID) &&
                                                (x.Name.Contains(strName) || strName.Contains(x.Name)), token).ConfigureAwait(false);
                                        if (objPlugin != null)
                                        {
                                            if (blnSync)
                                                objPlugin.Notes = xmlPluginToAdd.SelectSingleNodeAndCacheExpression(
                                                    "description", token)?.Value;
                                            else
                                                await objPlugin.SetNotesAsync(xmlPluginToAdd.SelectSingleNodeAndCacheExpression(
                                                    "description", token)?.Value, token).ConfigureAwait(false);
                                            objPlugin.ProcessHeroLabCyberwarePlugins(xmlPluginToAdd,
                                                blnSync ? objPlugin.Grade : await objPlugin.GetGradeAsync(token).ConfigureAwait(false),
                                                lstWeapons,
                                                lstVehicles);
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_ware");
                            }

                            XPathNodeIterator xmlNodeList;
                            using (Timekeeper.StartSyncron("load_char_spells", op_load))
                            {
                                // Spells.
                                xmlNodeList = xmlStatBlockBaseNode.SelectAndCacheExpression("magic/spells/spell", token);
                                XmlDocument xmlSpellDocument = blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? LoadData("spells.xml", token: token)
                                    : await LoadDataAsync("spells.xml", token: token).ConfigureAwait(false);
                                foreach (XPathNavigator xmlHeroLabSpell in xmlNodeList)
                                {
                                    string strSpellName
                                        = xmlHeroLabSpell.SelectSingleNodeAndCacheExpression("@name", token)?.Value;
                                    if (!string.IsNullOrEmpty(strSpellName))
                                    {
                                        bool blnIsLimited =
                                            strSpellName.EndsWith(" (limited)", StringComparison.Ordinal);
                                        if (blnIsLimited)
                                            strSpellName = strSpellName.TrimEndOnce(" (limited)");
                                        string strForcedValue = string.Empty;
                                        switch (strSpellName)
                                        {
                                            case "Increase Body":
                                                strForcedValue = "BOD";
                                                strSpellName = "Increase [Attribute]";
                                                break;

                                            case "Increase Agility":
                                                strForcedValue = "AGI";
                                                strSpellName = "Increase [Attribute]";
                                                break;

                                            case "Increase Reaction":
                                                strForcedValue = "REA";
                                                strSpellName = "Increase [Attribute]";
                                                break;

                                            case "Increase Strength":
                                                strForcedValue = "STR";
                                                strSpellName = "Increase [Attribute]";
                                                break;

                                            case "Increase Charisma":
                                                strForcedValue = "CHA";
                                                strSpellName = "Increase [Attribute]";
                                                break;

                                            case "Increase Intuition":
                                                strForcedValue = "INT";
                                                strSpellName = "Increase [Attribute]";
                                                break;

                                            case "Increase Logic":
                                                strForcedValue = "LOG";
                                                strSpellName = "Increase [Attribute]";
                                                break;

                                            case "Increase Willpower":
                                                strForcedValue = "WIL";
                                                strSpellName = "Increase [Attribute]";
                                                break;

                                            case "Decrease Body":
                                                strForcedValue = "BOD";
                                                strSpellName = "Decrease [Attribute]";
                                                break;

                                            case "Decrease Agility":
                                                strForcedValue = "AGI";
                                                strSpellName = "Decrease [Attribute]";
                                                break;

                                            case "Decrease Reaction":
                                                strForcedValue = "REA";
                                                strSpellName = "Decrease [Attribute]";
                                                break;

                                            case "Decrease Strength":
                                                strForcedValue = "STR";
                                                strSpellName = "Decrease [Attribute]";
                                                break;

                                            case "Decrease Charisma":
                                                strForcedValue = "CHA";
                                                strSpellName = "Decrease [Attribute]";
                                                break;

                                            case "Decrease Intuition":
                                                strForcedValue = "INT";
                                                strSpellName = "Decrease [Attribute]";
                                                break;

                                            case "Decrease Logic":
                                                strForcedValue = "LOG";
                                                strSpellName = "Decrease [Attribute]";
                                                break;

                                            case "Decrease Willpower":
                                                strForcedValue = "WIL";
                                                strSpellName = "Decrease [Attribute]";
                                                break;
                                        }

                                        if (strSpellName.StartsWith("Detect ", StringComparison.Ordinal) &&
                                            strSpellName != "Detect Life" &&
                                            strSpellName != "Detect Life, Extended" &&
                                            strSpellName != "Detect Magic" &&
                                            strSpellName != "Detect Magic, Extended" &&
                                            strSpellName != "Detect Enemies" &&
                                            strSpellName != "Detect Enemies, Extended" &&
                                            strSpellName != "Detect Individual" &&
                                            strSpellName != "Detect Life, Extended")
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Clean ")
                                                                         .TrimEndOnce(", Extended");
                                            if (xmlHeroLabSpell.SelectSingleNodeAndCacheExpression("@type", token)?.Value == "Physical")
                                                strSpellName = "Detect [Object]";
                                            else if (strSpellName.EndsWith(", Extended", StringComparison.Ordinal))
                                                strSpellName = "Detect [Life Form], Extended";
                                            else
                                                strSpellName = "Detect [Life Form]";
                                        }
                                        else if (strSpellName.StartsWith("Corrode ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Corrode ");
                                            strSpellName = "Corrode [Object]";
                                        }
                                        else if (strSpellName.StartsWith("Melt ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Melt ");
                                            strSpellName = "Melt [Object]";
                                        }
                                        else if (strSpellName.StartsWith("Sludge ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Sludge ");
                                            strSpellName = "Sludge [Object]";
                                        }
                                        else if (strSpellName.StartsWith("Disrupt ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Disrupt ");
                                            strSpellName = "Disrupt [Object]";
                                        }
                                        else if (strSpellName.StartsWith("Destroy ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Destroy ");
                                            strSpellName
                                                = xmlHeroLabSpell.SelectSingleNodeAndCacheExpression(
                                                      "@type", token)?.Value ==
                                                  "Physical"
                                                    ? "Destroy [Vehicle]"
                                                    : "Destroy [Free Spirit]";
                                        }
                                        else if (strSpellName.StartsWith("Insecticide ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Insecticide ");
                                            strSpellName = "Insecticide [Insect Spirit]";
                                        }
                                        else if (strSpellName.StartsWith("One Less ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("One Less ");
                                            strSpellName = "One Less [Metatype/Species]";
                                        }
                                        else if (strSpellName.StartsWith("Slay ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Slay ");
                                            strSpellName = "Slay [Metatype/Species]";
                                        }
                                        else if (strSpellName.StartsWith("Slaughter ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Slaughter ");
                                            strSpellName = "Slaughter [Metatype/Species]";
                                        }
                                        else if (strSpellName.StartsWith("Ram ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Ram ");
                                            strSpellName = "Ram [Object]";
                                        }
                                        else if (strSpellName.StartsWith("Wreck ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Wreck ");
                                            strSpellName = "Wreck [Object]";
                                        }
                                        else if (strSpellName.StartsWith("Demolish ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Demolish ");
                                            strSpellName = "Demolish [Object]";
                                        }
                                        else if (strSpellName.EndsWith(" Cryptesthesia", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimEndOnce(" Cryptesthesia");
                                            strSpellName = "[Sense] Cryptesthesia";
                                        }
                                        else if (strSpellName.EndsWith(" Removal", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Mass ")
                                                                         .TrimEndOnce(" Removal");
                                            strSpellName =
                                                strSpellName.StartsWith("Mass ", StringComparison.Ordinal)
                                                    ? "Mass [Sense] Removal"
                                                    : "[Sense] Removal";
                                        }
                                        else if (strSpellName.StartsWith("Alleviate ", StringComparison.Ordinal) &&
                                                 strSpellName != "Alleviate Addiction")
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Alleviate ");
                                            strSpellName = "Alleviate [Allergy]";
                                        }
                                        else if (strSpellName.StartsWith("Clean ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Clean ");
                                            strSpellName = "Clean [Element]";
                                        }
                                        else if (strSpellName.EndsWith(" Grenade", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimEndOnce(" Grenade");
                                            strSpellName = "[Element] Grenade";
                                        }
                                        else if (strSpellName.EndsWith(" Aura", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimEndOnce(" Aura");
                                            strSpellName = "[Element] Aura";
                                        }
                                        else if (strSpellName != "Napalm Wall" &&
                                                 strSpellName.EndsWith(" Wall", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimEndOnce(" Wall");
                                            strSpellName = "[Element] Wall";
                                        }
                                        else if (strSpellName.StartsWith("Shape ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Shape ");
                                            strSpellName = "Shape [Material]";
                                        }
                                        else if (strSpellName.EndsWith(" Form", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimEndOnce(" Form");
                                            strSpellName = "[Critter] Form";
                                        }
                                        else if (strSpellName.StartsWith("Calling ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Calling ");
                                            strSpellName = "Calling [Spirit Type]";
                                        }
                                        else if (strSpellName != "Symbolic Link" &&
                                                 strSpellName.EndsWith(" Link", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimEndOnce(" Link");
                                            strSpellName = "[Sense] Link";
                                        }

                                        string strSpellCategory =
                                            xmlHeroLabSpell.SelectSingleNodeAndCacheExpression("@category", token)?.Value;
                                        XmlNode xmlSpellData = xmlSpellDocument.TryGetNodeByNameOrId(
                                            "chummer/spells/spell", strSpellName,
                                            "category = " + strSpellCategory.CleanXPath());
                                        if (xmlSpellData == null)
                                        {
                                            string strDummy = strSpellName.SplitNoAlloc(':', StringSplitOptions.RemoveEmptyEntries).FirstOrDefault()?.Trim() ?? string.Empty;
                                            if (!string.IsNullOrEmpty(strDummy))
                                            {
                                                xmlSpellData = xmlSpellDocument.TryGetNodeByNameOrId(
                                                    "chummer/spells/spell", strDummy,
                                                    "category = " + strSpellCategory.CleanXPath());
                                            }

                                            if (xmlSpellData == null)
                                            {
                                                strDummy = strSpellName.SplitNoAlloc(',', StringSplitOptions.RemoveEmptyEntries).FirstOrDefault()?.Trim() ?? string.Empty;
                                                if (!string.IsNullOrEmpty(strDummy))
                                                {
                                                    xmlSpellData = xmlSpellDocument.TryGetNodeByNameOrId(
                                                        "chummer/spells/spell", strDummy,
                                                        "category = " + strSpellCategory.CleanXPath());
                                                }
                                            }
                                        }

                                        if (xmlSpellData != null)
                                        {
                                            Spell objSpell = new Spell(this);
                                            try
                                            {
                                                if (blnSync)
                                                {
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    objSpell.Create(xmlSpellData, strForcedValue, blnIsLimited);
                                                    objSpell.Notes = xmlHeroLabSpell.SelectSingleNodeAndCacheExpression(
                                                        "description", token)?.Value;
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    _lstSpells.Add(objSpell);
                                                }
                                                else
                                                {
                                                    await objSpell.CreateAsync(xmlSpellData, strForcedValue, blnIsLimited, token: token).ConfigureAwait(false);
                                                    await objSpell.SetNotesAsync(xmlHeroLabSpell.SelectSingleNodeAndCacheExpression(
                                                        "description", token)?.Value, token).ConfigureAwait(false);
                                                    await _lstSpells.AddAsync(objSpell, token).ConfigureAwait(false);
                                                }
                                            }
                                            catch
                                            {
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    objSpell.Remove(false);
                                                else
                                                    await objSpell.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                                                throw;
                                            }
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_spells");
                            }

                            using (Timekeeper.StartSyncron("load_char_powers", op_load))
                            {
                                // Powers.
                                xmlNodeList = xmlStatBlockBaseNode.SelectAndCacheExpression("magic/adeptpowers/adeptpower", token);
                                XmlDocument xmlPowersDocument = blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? LoadData("powers.xml", token: token)
                                    : await LoadDataAsync("powers.xml", token: token).ConfigureAwait(false);
                                foreach (XPathNavigator xmlHeroLabPower in xmlNodeList)
                                {
                                    string strPowerName = xmlHeroLabPower.SelectSingleNodeAndCacheExpression(
                                        "@name", token)?.Value;
                                    if (!string.IsNullOrEmpty(strPowerName))
                                    {
                                        int intRating = 1;
                                        string strForcedValue = string.Empty;
                                        XmlNode xmlPowerData =
                                            xmlPowersDocument.SelectSingleNode(
                                                "chummer/powers/power[contains(name, " + strPowerName.CleanXPath() +
                                                ")]");
                                        if (xmlPowerData == null)
                                        {
                                            string[] astrOriginalNameSplit =
                                                strPowerName.SplitFixedSizePooledArray(':', 2, StringSplitOptions.RemoveEmptyEntries);
                                            try
                                            {
                                                if (!string.IsNullOrEmpty(astrOriginalNameSplit[1]))
                                                {
                                                    string strName = astrOriginalNameSplit[0].Trim();
                                                    xmlPowerData =
                                                        xmlPowersDocument.SelectSingleNode(
                                                            "/chummer/powers/power[contains(name, " +
                                                            strName.CleanXPath() +
                                                            ")]");

                                                    strForcedValue = astrOriginalNameSplit[1].Trim();
                                                    int intForcedValueParenthesesStart = strForcedValue.IndexOf('(');
                                                    if (intForcedValueParenthesesStart != -1)
                                                        strForcedValue =
                                                            strForcedValue.Substring(0, intForcedValueParenthesesStart);
                                                }
                                            }
                                            finally
                                            {
                                                ArrayPool<string>.Shared.Return(astrOriginalNameSplit);
                                            }

                                            if (xmlPowerData == null)
                                            {
                                                astrOriginalNameSplit = strPowerName.SplitFixedSizePooledArray('(', 2,
                                                    StringSplitOptions.RemoveEmptyEntries);
                                                try
                                                {
                                                    if (!string.IsNullOrEmpty(astrOriginalNameSplit[1]))
                                                    {
                                                        string strName = astrOriginalNameSplit[0].Trim();
                                                        xmlPowerData =
                                                            xmlPowersDocument.SelectSingleNode(
                                                                "/chummer/powers/power[contains(name, " +
                                                                strName.CleanXPath() +
                                                                ")]");

                                                        string strSecondPart = astrOriginalNameSplit[1].Trim();
                                                        int intSecondPartParenthesesEnd = strSecondPart.IndexOf(')');
                                                        if (intSecondPartParenthesesEnd != -1
                                                            && !int.TryParse(
                                                                strSecondPart.Substring(0, intSecondPartParenthesesEnd),
                                                                out intRating))
                                                            intRating = 1;

                                                        string[] astrOriginalNameSplit2 = strSecondPart.SplitFixedSizePooledArray(':', 2,
                                                            StringSplitOptions.RemoveEmptyEntries);
                                                        try
                                                        {
                                                            if (!string.IsNullOrEmpty(astrOriginalNameSplit2[1]))
                                                            {
                                                                strForcedValue = astrOriginalNameSplit2[1].Trim();
                                                                int intForcedValueParenthesesStart =
                                                                    strForcedValue.IndexOf('(');
                                                                if (intForcedValueParenthesesStart != -1)
                                                                    strForcedValue =
                                                                        strForcedValue.Substring(0,
                                                                            intForcedValueParenthesesStart);
                                                            }
                                                        }
                                                        finally
                                                        {
                                                            ArrayPool<string>.Shared.Return(astrOriginalNameSplit2);
                                                        }
                                                    }
                                                }
                                                finally
                                                {
                                                    ArrayPool<string>.Shared.Return(astrOriginalNameSplit);
                                                }
                                            }
                                        }

                                        if (xmlPowerData != null)
                                        {
                                            Power objPower = new Power(this);
                                            if (blnSync)
                                            {
                                                try
                                                {
                                                    objPower.Extra = strForcedValue;
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    objPower.Create(xmlPowerData, intRating);
                                                    objPower.Notes = xmlHeroLabPower.SelectSingleNodeAndCacheExpression(
                                                        "description", token)?.Value;
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    _lstPowers.Add(objPower);
                                                }
                                                catch
                                                {
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    objPower.DeletePower();
                                                    throw;
                                                }
                                            }
                                            else
                                            {
                                                try
                                                {
                                                    await objPower.SetExtraAsync(strForcedValue, token).ConfigureAwait(false);
                                                    await objPower.CreateAsync(xmlPowerData, intRating, token: token).ConfigureAwait(false);
                                                    await objPower.SetNotesAsync(xmlHeroLabPower.SelectSingleNodeAndCacheExpression(
                                                        "description", token)?.Value, token).ConfigureAwait(false);
                                                    await _lstPowers.AddAsync(objPower, token).ConfigureAwait(false);
                                                }
                                                catch
                                                {
                                                    await objPower.DeletePowerAsync(CancellationToken.None).ConfigureAwait(false);
                                                    throw;
                                                }
                                            }
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_powers");
                            }

                            /* TODO: Spirit/Sprite Importing
                            Timekeeper.Start("load_char_spirits");

                            // Spirits/Sprites.
                            foreach (XPathNavigator xmlSpirit in xmlCharacterNavigator.SelectAndCacheExpression("spirits/spirit"))
                            {
                                Spirit objSpirit = new Spirit(this);
                                objSpirit.Load(xmlSpirit);
                                _lstSpirits.Add(objSpirit);
                            }

                            Timekeeper.Finish("load_char_spirits");
                            */
                            using (Timekeeper.StartSyncron("load_char_complex", op_load))
                            {
                                // Complex Forms/Technomancer Programs.
                                string strComplexFormsLine =
                                    lstTextStatBlockLines?.Find(x =>
                                        x.StartsWith(
                                            "Complex Forms:",
                                            StringComparison.Ordinal));
                                if (!string.IsNullOrEmpty(strComplexFormsLine))
                                {
                                    XmlDocument xmlComplexFormsDocument = blnSync
                                        // ReSharper disable once MethodHasAsyncOverload
                                        ? LoadData("complexforms.xml", token: token)
                                        : await LoadDataAsync("complexforms.xml", token: token).ConfigureAwait(false);
                                    foreach (string strComplexFormEntry in strComplexFormsLine.TrimStartOnce("Complex Forms:").Trim()
                                                           .SplitNoAlloc(',', StringSplitOptions.RemoveEmptyEntries))
                                    {
                                        string strComplexFormName = strComplexFormEntry.Trim();
                                        string strForcedValue = string.Empty;
                                        switch (strComplexFormName)
                                        {
                                            case "Diffusion of Attack":
                                                strComplexFormName = "Diffusion of [Matrix Attribute]";
                                                strForcedValue = "Attack";
                                                break;

                                            case "Diffusion of Sleaze":
                                                strComplexFormName = "Diffusion of [Matrix Attribute]";
                                                strForcedValue = "Sleaze";
                                                break;

                                            case "Diffusion of Data Processing":
                                                strComplexFormName = "Diffusion of [Matrix Attribute]";
                                                strForcedValue = "Data Processing";
                                                break;

                                            case "Diffusion of Firewall":
                                                strComplexFormName = "Diffusion of [Matrix Attribute]";
                                                strForcedValue = "Firewall";
                                                break;

                                            case "Infusion of Attack":
                                                strComplexFormName = "Infusion of [Matrix Attribute]";
                                                strForcedValue = "Attack";
                                                break;

                                            case "Infusion of Sleaze":
                                                strComplexFormName = "Infusion of [Matrix Attribute]";
                                                strForcedValue = "Sleaze";
                                                break;

                                            case "Infusion of Data Processing":
                                                strComplexFormName = "Infusion of [Matrix Attribute]";
                                                strForcedValue = "Data Processing";
                                                break;

                                            case "Infusion of Firewall":
                                                strComplexFormName = "Infusion of [Matrix Attribute]";
                                                strForcedValue = "Firewall";
                                                break;
                                        }

                                        XmlNode xmlComplexFormData =
                                            xmlComplexFormsDocument.TryGetNodeByNameOrId(
                                                "/chummer/complexforms/complexform", strComplexFormName);
                                        if (xmlComplexFormData == null)
                                        {
                                            string strDummy = strComplexFormName
                                                .SplitNoAlloc(':', StringSplitOptions.RemoveEmptyEntries).FirstOrDefault()?.Trim() ?? string.Empty;
                                            if (!string.IsNullOrEmpty(strDummy))
                                            {
                                                xmlComplexFormData =
                                                        xmlComplexFormsDocument.TryGetNodeByNameOrId(
                                                            "/chummer/complexforms/complexform", strDummy);
                                            }

                                            if (xmlComplexFormData == null)
                                            {
                                                strDummy = strComplexFormName
                                                    .SplitNoAlloc(',', StringSplitOptions.RemoveEmptyEntries).FirstOrDefault()?.Trim() ?? string.Empty;
                                                if (!string.IsNullOrEmpty(strDummy))
                                                {
                                                    xmlComplexFormData =
                                                            xmlComplexFormsDocument.TryGetNodeByNameOrId(
                                                                "/chummer/complexforms/complexform", strDummy);
                                                }
                                            }
                                        }

                                        if (xmlComplexFormData != null)
                                        {
                                            ComplexForm objComplexForm = new ComplexForm(this);
                                            try
                                            {
                                                if (blnSync)
                                                {
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    objComplexForm.Create(xmlComplexFormData, strForcedValue);
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    _lstComplexForms.Add(objComplexForm);
                                                }
                                                else
                                                {
                                                    await objComplexForm.CreateAsync(xmlComplexFormData, strForcedValue, token).ConfigureAwait(false);
                                                    await _lstComplexForms.AddAsync(objComplexForm, token).ConfigureAwait(false);
                                                }
                                            }
                                            catch
                                            {
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    objComplexForm.Remove(false);
                                                else
                                                    await objComplexForm.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                                                throw;
                                            }
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_complex");
                            }

                            /* TODO: AI Advanced Program Importing
                            Timekeeper.Start("load_char_aiprogram");

                            // AI Advanced Programs.
                            objXmlNodeList = objXmlCharacter.SelectNodes("aiprograms/aiprogram");
                            foreach (XmlNode xmlHeroLabProgram in xmlNodeList)
                            {
                                AIProgram objProgram = new AIProgram(this);
                                objProgram.Load(xmlHeroLabProgram);
                                _lstAIPrograms.Add(objProgram);
                            }

                            Timekeeper.Finish("load_char_aiprogram");
                            */
                            /* TODO: Martial Arts import, which are saved in TXT and HTML statblocks but not in XML statblock
                            Timekeeper.Start("load_char_marts");

                            // Martial Arts.
                            xmlNodeList = objXmlCharacter.SelectNodes("martialarts/martialart");
                            foreach (XmlNode xmlHeroLabArt in xmlNodeList)
                            {
                                MartialArt objMartialArt = new MartialArt(this);
                                objMartialArt.Load(xmlHeroLabArt);
                                _lstMartialArts.Add(objMartialArt);
                            }

                            Timekeeper.Finish("load_char_marts");
                            */
                            using (Timekeeper.StartSyncron("load_char_lifestyle", op_load))
                            {
                                // Lifestyles.
                                XmlNode xmlFakeSINDataNode =
                                    xmlGearDocument.SelectSingleNode("/chummer/gears/gear[name = 'Fake SIN']");
                                XmlNode xmlFakeLicenseDataNode =
                                    xmlGearDocument.SelectSingleNode("/chummer/gears/gear[name = 'Fake License']");
                                xmlNodeList = xmlStatBlockBaseNode.SelectAndCacheExpression("identities/identity", token);
                                foreach (XPathNavigator xmlHeroLabIdentity in xmlNodeList)
                                {
                                    string strIdentityName
                                        = xmlHeroLabIdentity.SelectSingleNodeAndCacheExpression("@name", token)
                                        ?.Value ?? string.Empty;
                                    int intIdentityNameParenthesesStart = strIdentityName.IndexOf('(');
                                    if (intIdentityNameParenthesesStart != -1)
                                        strIdentityName =
                                            strIdentityName.Substring(0, intIdentityNameParenthesesStart);
                                    XPathNavigator xmlHeroLabFakeSINNode =
                                        xmlHeroLabIdentity.SelectSingleNodeAndCacheExpression(
                                            "license[@name = \"Fake SIN\"]", token);
                                    if (xmlHeroLabFakeSINNode != null)
                                    {
                                        Gear objFakeSIN = new Gear(this);
                                        try
                                        {
                                            if (blnSync)
                                            {
                                                // ReSharper disable once MethodHasAsyncOverload
                                                objFakeSIN.Create(xmlFakeSINDataNode,
                                                    xmlHeroLabFakeSINNode
                                                        .SelectSingleNodeAndCacheExpression(
                                                            "@rating", token)
                                                        ?.ValueAsInt
                                                    ?? 1,
                                                    lstWeapons,
                                                    strIdentityName, token: token);
                                                foreach (XPathNavigator xmlHeroLabFakeLicenseNode in xmlHeroLabIdentity
                                                             .Select(
                                                                 "license[@name = \"Fake License\"]"))
                                                {
                                                    Gear objFakeLicense = new Gear(this);
                                                    try
                                                    {
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        objFakeLicense.Create(xmlFakeLicenseDataNode,
                                                            xmlHeroLabFakeLicenseNode
                                                                .SelectSingleNodeAndCacheExpression(
                                                                    "@rating", token)
                                                                ?.ValueAsInt ??
                                                            1,
                                                            lstWeapons,
                                                            xmlHeroLabFakeLicenseNode
                                                                .SelectSingleNodeAndCacheExpression(
                                                                    "@for", token)
                                                                ?.Value ?? string.Empty, token: token);
                                                        objFakeLicense.Parent = objFakeSIN;
                                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                        objFakeSIN.Children.Add(objFakeLicense);
                                                    }
                                                    catch
                                                    {
                                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                        objFakeLicense.DeleteGear();
                                                        throw;
                                                    }
                                                }
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                _lstGear.Add(objFakeSIN);
                                            }
                                            else
                                            {
                                                await objFakeSIN.CreateAsync(xmlFakeSINDataNode,
                                                    xmlHeroLabFakeSINNode
                                                        .SelectSingleNodeAndCacheExpression(
                                                            "@rating", token)
                                                        ?.ValueAsInt
                                                    ?? 1,
                                                    lstWeapons,
                                                    strIdentityName, token: token).ConfigureAwait(false);
                                                foreach (XPathNavigator xmlHeroLabFakeLicenseNode in xmlHeroLabIdentity
                                                             .Select(
                                                                 "license[@name = \"Fake License\"]"))
                                                {
                                                    Gear objFakeLicense = new Gear(this);
                                                    try
                                                    {
                                                        await objFakeLicense.CreateAsync(xmlFakeLicenseDataNode,
                                                            xmlHeroLabFakeLicenseNode
                                                                .SelectSingleNodeAndCacheExpression(
                                                                    "@rating", token)
                                                                ?.ValueAsInt ??
                                                            1,
                                                            lstWeapons,
                                                            xmlHeroLabFakeLicenseNode
                                                                .SelectSingleNodeAndCacheExpression(
                                                                    "@for", token)
                                                                ?.Value ?? string.Empty, token: token).ConfigureAwait(false);
                                                        await objFakeLicense.SetParentAsync(objFakeSIN, token)
                                                            .ConfigureAwait(false);
                                                        await objFakeSIN.Children.AddAsync(objFakeLicense, token)
                                                            .ConfigureAwait(false);
                                                    }
                                                    catch
                                                    {
                                                        await objFakeLicense.DeleteGearAsync(token: CancellationToken.None).ConfigureAwait(false);
                                                        throw;
                                                    }
                                                }
                                                await _lstGear.AddAsync(objFakeSIN, token).ConfigureAwait(false);
                                            }
                                        }
                                        catch
                                        {
                                            if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                objFakeSIN.DeleteGear();
                                            else
                                                await objFakeSIN.DeleteGearAsync(token: CancellationToken.None).ConfigureAwait(false);
                                            throw;
                                        }
                                    }

                                    XPathNavigator xmlHeroLabLifestyleNode = xmlHeroLabIdentity.SelectSingleNodeAndCacheExpression("lifestyle", token);
                                    if (xmlHeroLabLifestyleNode != null)
                                    {
                                        string strLifestyleType
                                            = xmlHeroLabLifestyleNode.SelectSingleNodeAndCacheExpression(
                                                    "@name", token)
                                              ?.Value
                                              .TrimEndOnce(" Lifestyle") ?? string.Empty;

                                        XmlNode xmlLifestyleDataNode =
                                            (blnSync
                                                // ReSharper disable once MethodHasAsyncOverload
                                                ? LoadData("lifestyles.xml", token: token)
                                                : await LoadDataAsync("lifestyles.xml", token: token).ConfigureAwait(false))
                                            .TryGetNodeByNameOrId("/chummer/lifestyles/lifestyle", strLifestyleType);

                                        if (xmlLifestyleDataNode != null)
                                        {
                                            Lifestyle objLifestyle = new Lifestyle(this);
                                            try
                                            {
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    objLifestyle.Create(xmlLifestyleDataNode);
                                                else
                                                    await objLifestyle.CreateAsync(xmlLifestyleDataNode, token).ConfigureAwait(false);
                                                if (int.TryParse(
                                                        xmlHeroLabLifestyleNode.SelectSingleNodeAndCacheExpression(
                                                                "@months", token)
                                                        ?.Value,
                                                        out int intMonths))
                                                {
                                                    if (blnSync)
                                                        objLifestyle.Increments = intMonths;
                                                    else
                                                        await objLifestyle.SetIncrementsAsync(intMonths, token).ConfigureAwait(false);
                                                }

                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    _lstLifestyles.Add(objLifestyle);
                                                else
                                                    await _lstLifestyles.AddAsync(objLifestyle, token)
                                                                        .ConfigureAwait(false);
                                            }
                                            catch
                                            {
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    objLifestyle.Remove(false);
                                                else
                                                    await objLifestyle.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                                                throw;
                                            }
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_lifestyle");
                            }

                            using (Timekeeper.StartSyncron("load_char_gear", op_load))
                            {
                                // <gears>
                                foreach (XPathNavigator xmlGearToImport in xmlStatBlockBaseNode.Select(
                                             "gear/equipment/item[@useradded != \"no\"]"))
                                {
                                    Gear objGear = new Gear(this);
                                    try
                                    {
                                        if (blnSync)
                                        {
                                            // ReSharper disable once MethodHasAsyncOverload
                                            if (objGear.ImportHeroLabGear(xmlGearToImport, null, lstWeapons, token))
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                _lstGear.Add(objGear);
                                            else
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                objGear.DeleteGear();
                                        }
                                        else if (await objGear.ImportHeroLabGearAsync(xmlGearToImport, null, lstWeapons, token).ConfigureAwait(false))
                                        {
                                            await _lstGear.AddAsync(objGear, token).ConfigureAwait(false);
                                        }
                                        else
                                            await objGear.DeleteGearAsync(token: token).ConfigureAwait(false);
                                    }
                                    catch
                                    {
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            objGear.DeleteGear();
                                        else
                                            await objGear.DeleteGearAsync(token: CancellationToken.None).ConfigureAwait(false);
                                        throw;
                                    }
                                }

                                if (blnSync)
                                {
                                    foreach (XPathNavigator xmlPluginToAdd in xmlStatBlockBaseNode
                                                 // ReSharper disable once MethodHasAsyncOverload
                                                 .SelectAndCacheExpression(
                                                     "gear/equipment/item[@useradded = \"no\"]", token))
                                    {
                                        // ReSharper disable once MethodHasAsyncOverload
                                        string strName = xmlPluginToAdd.SelectSingleNodeAndCacheExpression("@name", token)
                                                                       ?.Value;
                                        if (!string.IsNullOrEmpty(strName))
                                        {
                                            Gear objPlugin = _lstGear.FirstOrDefault(x =>
                                                x.IncludedInParent &&
                                                (x.Name.Contains(strName) || strName.Contains(x.Name)));
                                            if (objPlugin != null)
                                            {
                                                objPlugin.Quantity =
                                                    Convert.ToDecimal(
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        xmlPluginToAdd.SelectSingleNodeAndCacheExpression("@quantity", token)
                                                                      ?.Value ?? "1",
                                                        GlobalSettings.InvariantCultureInfo);
                                                objPlugin.Notes = xmlPluginToAdd
                                                                  // ReSharper disable once MethodHasAsyncOverload
                                                                  .SelectSingleNodeAndCacheExpression("description", token)
                                                                  ?.Value;
                                                // ReSharper disable once MethodHasAsyncOverload
                                                objPlugin.ProcessHeroLabGearPlugins(xmlPluginToAdd, lstWeapons, token);
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    foreach (XPathNavigator xmlPluginToAdd in xmlStatBlockBaseNode
                                                 .SelectAndCacheExpression(
                                                     "gear/equipment/item[@useradded = \"no\"]", token))
                                    {
                                        string strName = (xmlPluginToAdd
                                                                .SelectSingleNodeAndCacheExpression("@name", token))
                                            ?.Value;
                                        if (!string.IsNullOrEmpty(strName))
                                        {
                                            Gear objPlugin = await _lstGear.FirstOrDefaultAsync(x =>
                                                                               x.IncludedInParent &&
                                                                               (x.Name.Contains(strName)
                                                                                   || strName.Contains(x.Name)), token)
                                                                           .ConfigureAwait(false);
                                            if (objPlugin != null)
                                            {
                                                await objPlugin.SetQuantityAsync(Convert.ToDecimal(
                                                        (xmlPluginToAdd
                                                               .SelectSingleNodeAndCacheExpression(
                                                                   "@quantity", token))
                                                        ?.Value ?? "1",
                                                        GlobalSettings.InvariantCultureInfo), token).ConfigureAwait(false);
                                                await objPlugin.SetNotesAsync((xmlPluginToAdd
                                                                         .SelectSingleNodeAndCacheExpression(
                                                                             "description", token))
                                                    ?.Value, token).ConfigureAwait(false);
                                                await objPlugin
                                                      .ProcessHeroLabGearPluginsAsync(xmlPluginToAdd, lstWeapons, token)
                                                      .ConfigureAwait(false);
                                            }
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_gear");
                            }

                            using (Timekeeper.StartSyncron("load_char_car", op_load))
                            {
                                foreach (Vehicle objVehicle in lstVehicles)
                                {
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstVehicles.Add(objVehicle);
                                    else
                                        await _lstVehicles.AddAsync(objVehicle, token).ConfigureAwait(false);
                                }

                                /* TODO: Process HeroLab Vehicles entries, which are present in HTML and TXT statblocks but not in XML
                                // Vehicles.
                                xmlNodeList = objXmlCharacter.SelectNodes("vehicles/vehicle");
                                foreach (XmlNode xmlHeroLabVehicle in xmlNodeList)
                                {
                                    Vehicle objVehicle = new Vehicle(this);
                                    objVehicle.Load(xmlHeroLabVehicle);
                                    _lstVehicles.Add(objVehicle);
                                }
                                */
                                //Timekeeper.Finish("load_char_car");
                            }

                            /* TODO: Process HeroLab Initiation/Submersion and related entries
                            Timekeeper.Start("load_char_mmagic");
                            // Metamagics/Echoes.
                            xmlNodeList = objXmlCharacter.SelectNodes("metamagics/metamagic");
                            foreach (XmlNode xmlHeroLabMetamagic in xmlNodeList)
                            {
                                Metamagic objMetamagic = new Metamagic(this);
                                objMetamagic.Load(xmlHeroLabMetamagic);
                                _lstMetamagics.Add(objMetamagic);
                            }

                            Timekeeper.Finish("load_char_mmagic");
                            Timekeeper.Start("load_char_arts");

                            // Arts
                            xmlNodeList = objXmlCharacter.SelectNodes("arts/art");
                            foreach (XmlNode xmlHeroLabArt in xmlNodeList)
                            {
                                Art objArt = new Art(this);
                                objArt.Load(xmlHeroLabArt);
                                _lstArts.Add(objArt);
                            }

                            Timekeeper.Finish("load_char_arts");
                            Timekeeper.Start("load_char_ench");

                            // Enhancements
                            xmlNodeList = objXmlCharacter.SelectNodes("enhancements/enhancement");
                            foreach (XmlNode xmlHeroLabEnhancement in objXmlNodeList)
                            {
                                Enhancement objEnhancement = new Enhancement(this);
                                objEnhancement.Load(xmlHeroLabEnhancement);
                                _lstEnhancements.Add(objEnhancement);
                            }

                            Timekeeper.Finish("load_char_ench");
                            Timekeeper.Start("load_char_cpow");

                            // Critter Powers.
                            xmlNodeList = objXmlCharacter.SelectNodes("critterpowers/critterpower");
                            foreach (XmlNode xmlHeroLabPower in xmlNodeList)
                            {
                                CritterPower objPower = new CritterPower(this);
                                objPower.Load(xmlHeroLabPower);
                                _lstCritterPowers.Add(objPower);
                            }

                            Timekeeper.Finish("load_char_cpow");
                            Timekeeper.Start("load_char_foci");

                            // Foci.
                            xmlNodeList = objXmlCharacter.SelectNodes("foci/focus");
                            foreach (XmlNode xmlHeroLabFocus in xmlNodeList)
                            {
                                Focus objFocus = new Focus(this);
                                objFocus.Load(xmlHeroLabFocus);
                                _lstFoci.Add(objFocus);
                            }

                            Timekeeper.Finish("load_char_foci");
                            Timekeeper.Start("load_char_init");

                            // Initiation Grades.
                            xmlNodeList = objXmlCharacter.SelectNodes("initiationgrades/initiationgrade");
                            foreach (XmlNode xmlHeroLabGrade in xmlNodeList)
                            {
                                InitiationGrade objGrade = new InitiationGrade(this);
                                objGrade.Load(xmlHeroLabGrade);
                                _lstInitiationGrades.Add(objGrade);
                            }

                            Timekeeper.Finish("load_char_init");
                            */
                            /* TODO: Import HeroLab Expense Logs, which are different from Journal entries
                            Timekeeper.Start("load_char_elog");

                            // Expense Log Entries.
                            XmlNodeList xmlExpenseList = objXmlCharacter.SelectNodes("expenses/expense");
                            foreach (XmlNode xmlHeroLabExpense in xmlExpenseList)
                            {
                                ExpenseLogEntry objExpenseLogEntry = new ExpenseLogEntry(this);
                                objExpenseLogEntry.Load(xmlHeroLabExpense);
                                _lstExpenseLog.Add(objExpenseLogEntry);
                            }

                            Timekeeper.Finish("load_char_elog");
                            */
                            _lstWeapons.AddRange(lstWeapons);

                            using (Timekeeper.StartSyncron("load_char_unarmed", op_load))
                            {
                                // Look for the unarmed attack
                                bool blnFoundUnarmed = false;
                                foreach (Weapon objWeapon in _lstWeapons)
                                {
                                    if (objWeapon.Name == "Unarmed Attack")
                                    {
                                        blnFoundUnarmed = true;
                                        break;
                                    }
                                }

                                if (!blnFoundUnarmed)
                                {
                                    // Add the Unarmed Attack Weapon to the character.
                                    XmlDocument objXmlWeaponDoc = blnSync
                                        // ReSharper disable once MethodHasAsyncOverload
                                        ? LoadData("weapons.xml", token: token)
                                        : await LoadDataAsync("weapons.xml", token: token).ConfigureAwait(false);
                                    XmlNode objXmlWeapon =
                                        objXmlWeaponDoc.SelectSingleNode(
                                            "/chummer/weapons/weapon[name = \"Unarmed Attack\"]");
                                    if (objXmlWeapon != null)
                                    {
                                        Weapon objWeapon = new Weapon(this);
                                        try
                                        {
                                            if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverload
                                                objWeapon.Create(objXmlWeapon, _lstWeapons, token: token);
                                            else
                                                await objWeapon.CreateAsync(objXmlWeapon, _lstWeapons, token: token).ConfigureAwait(false);
                                            objWeapon.IncludedInWeapon = true; // Unarmed attack can never be removed
                                            if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                _lstWeapons.Add(objWeapon);
                                            else
                                                await _lstWeapons.AddAsync(objWeapon, token).ConfigureAwait(false);
                                        }
                                        catch
                                        {
                                            if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                objWeapon.DeleteWeapon();
                                            else
                                                await objWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                                            throw;
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_unarmed");
                            }
                        }
                        finally
                        {
                            if (blnSync)
                                IsLoading = false;
                            else
                                await SetIsLoadingAsync(false, token).ConfigureAwait(false);
                        }

                        // Refresh certain improvements
                        using (Timekeeper.StartSyncron("load_char_improvementrefreshers2", op_load))
                        {
                            // Process all events related to improvements
                            using (new FetchSafelyFromSafeObjectPool<
                                       Dictionary<INotifyMultiplePropertiesChangedAsync, HashSet<string>>>(
                                       Utils.DictionaryForMultiplePropertyChangedPool,
                                       out Dictionary<INotifyMultiplePropertiesChangedAsync, HashSet<string>>
                                           dicChangedProperties))
                            {
                                try
                                {
                                    token.ThrowIfCancellationRequested();
                                    HashSet<string> setAlwaysChangedProperties = Utils.StringHashSetPool.Get();
                                    dicChangedProperties.Add(this, setAlwaysChangedProperties);
                                    setAlwaysChangedProperties.Add(nameof(BlackMarketDiscount));
                                    setAlwaysChangedProperties.Add(nameof(DealerConnectionDiscount));
                                    setAlwaysChangedProperties.Add(nameof(Essence));
                                    setAlwaysChangedProperties.Add(nameof(WoundModifier));
                                    setAlwaysChangedProperties.Add(nameof(SustainingPenalty));
                                    setAlwaysChangedProperties.Add(nameof(Encumbrance));
                                    setAlwaysChangedProperties.Add(nameof(ArmorEncumbrance));

                                    if (blnSync)
                                    {
                                        foreach (Improvement objImprovement in Improvements)
                                        {
                                            if (!objImprovement.Enabled)
                                                continue;
                                            foreach ((INotifyMultiplePropertiesChangedAsync objItemToUpdate,
                                                         string strPropertyToUpdate) in objImprovement
                                                         .GetRelevantPropertyChangers())
                                            {
                                                if (!dicChangedProperties.TryGetValue(
                                                        objItemToUpdate, out HashSet<string> setChangedProperties))
                                                {
                                                    setChangedProperties = Utils.StringHashSetPool.Get();
                                                    dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                                }

                                                setChangedProperties.Add(strPropertyToUpdate);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        await Improvements.ForEachAsync(objImprovement =>
                                        {
                                            if (!objImprovement.Enabled)
                                                return;
                                            foreach ((INotifyMultiplePropertiesChangedAsync objItemToUpdate,
                                                         string strPropertyToUpdate) in objImprovement
                                                         .GetRelevantPropertyChangers())
                                            {
                                                if (!dicChangedProperties.TryGetValue(
                                                        objItemToUpdate, out HashSet<string> setChangedProperties))
                                                {
                                                    setChangedProperties = Utils.StringHashSetPool.Get();
                                                    dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                                }

                                                setChangedProperties.Add(strPropertyToUpdate);
                                            }
                                        }, token).ConfigureAwait(false);
                                    }

                                    foreach (KeyValuePair<INotifyMultiplePropertiesChangedAsync, HashSet<string>>
                                                 kvpToProcess in
                                             dicChangedProperties)
                                    {
                                        if (blnSync)
                                            kvpToProcess.Key.OnMultiplePropertiesChanged(kvpToProcess.Value);
                                        else
                                            await kvpToProcess.Key
                                                .OnMultiplePropertiesChangedAsync(kvpToProcess.Value, token)
                                                .ConfigureAwait(false);
                                    }
                                }
                                finally
                                {
                                    List<HashSet<string>> lstToReturn = dicChangedProperties.Values.ToList();
                                    for (int i = lstToReturn.Count - 1; i >= 0; --i)
                                    {
                                        HashSet<string> setLoop = lstToReturn[i];
                                        Utils.StringHashSetPool.Return(ref setLoop);
                                    }
                                }
                            }

                            // Curb Mystic Adept power points if the values that were loaded in would be illegal
                            if (blnSync)
                            {
                                if (MysticAdeptPowerPoints > 0)
                                {
                                    int intMAGTotalValue = MAG.TotalValue;
                                    if (MysticAdeptPowerPoints > intMAGTotalValue)
                                        MysticAdeptPowerPoints = intMAGTotalValue;
                                }
                            }
                            else
                            {
                                int intMysticAdeptPowerPoints = await GetMysticAdeptPowerPointsAsync(token).ConfigureAwait(false);
                                if (intMysticAdeptPowerPoints > 0)
                                {
                                    int intMAGTotalValue =
                                        await (await GetAttributeAsync("MAG", token: token).ConfigureAwait(false))
                                            .GetTotalValueAsync(token).ConfigureAwait(false);
                                    if (intMysticAdeptPowerPoints > intMAGTotalValue)
                                        await SetMysticAdeptPowerPointsAsync(intMAGTotalValue, token).ConfigureAwait(false);
                                }
                            }

                            if (blnSync)
                            {
                                if (!InitiationEnabled || !AddInitiationsAllowed)
                                {
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ClearInitiations(token);
                                }
                            }
                            else if (!await GetInitiationEnabledAsync(token).ConfigureAwait(false) || !await GetAddInitiationsAllowedAsync(token).ConfigureAwait(false))
                                await ClearInitiationsAsync(token).ConfigureAwait(false);
                            //Timekeeper.Finish("load_char_improvementrefreshers");
                        }
                    }
                    catch (Exception e)
                    {
                        op_load.SetSuccess(false);
                        TelemetryClient.TrackException(e);
                        Log.Error(e);
                    }
                }

                return true;
            }
            finally
            {
                if (blnSync)
                    // ReSharper disable once MethodHasAsyncOverload
                    objLocker.Dispose();
                else
                    await objLockerAsync.DisposeAsync().ConfigureAwait(false);
            }
        }

        #endregion Hero Lab Importing

        #region Karma Values

        private int _intCachedPositiveQualityLimitKarma = int.MinValue;

        /// <summary>
        /// Total value of positive qualities that count towards the maximum quality limit in create mode.
        /// </summary>
        public int PositiveQualityLimitKarma
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (_intCachedPositiveQualityLimitKarma != int.MinValue)
                        return _intCachedPositiveQualityLimitKarma;
                    int intNewValue
                        = Qualities.Sum(
                            objQuality => objQuality.Type == QualityType.Positive && objQuality.ContributeToLimit,
                            objQuality => objQuality.BP) * Settings.KarmaQuality;
                    // Group contacts are counted as positive qualities
                    intNewValue += Contacts.Sum(x => x.EntityType == ContactType.Contact && x.IsGroup && !x.Free,
                        x => x.ContactPoints) * Settings.KarmaContact;

                    // Deduct the amount for free Qualities.
                    intNewValue -=
                        (ImprovementManager.ValueOf(this, Improvement.ImprovementType.FreePositiveQualities) *
                         Settings.KarmaQuality).StandardRound();

                    // If the character is allowed to take as many Positive Qualities as they'd like but all costs in excess are doubled, add the excess to their point cost.
                    if (Settings.ExceedPositiveQualitiesCostDoubled)
                    {
                        int intPositiveQualityExcess = intNewValue - Settings.QualityKarmaLimit;
                        if (intPositiveQualityExcess > 0)
                        {
                            intNewValue += intPositiveQualityExcess;
                        }
                    }

                    return _intCachedPositiveQualityLimitKarma = intNewValue;
                }
            }
        }

        /// <summary>
        /// Total value of positive qualities that count towards the maximum quality limit in create mode.
        /// </summary>
        public async Task<int> GetPositiveQualityLimitKarmaAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_intCachedPositiveQualityLimitKarma != int.MinValue)
                    return _intCachedPositiveQualityLimitKarma;
                CharacterSettings objSettings = await GetSettingsAsync(token).ConfigureAwait(false);
                int intNewValue
                    = await Qualities.SumAsync(
                        async objQuality => await objQuality.GetTypeAsync(token).ConfigureAwait(false) == QualityType.Positive && objQuality.ContributeToLimit,
                        objQuality => objQuality.GetBPAsync(token), token).ConfigureAwait(false) * await objSettings.GetKarmaQualityAsync(token).ConfigureAwait(false);
                // Group contacts are counted as positive qualities
                intNewValue += await Contacts.SumAsync(async x => await x.GetEntityTypeAsync(token).ConfigureAwait(false) == ContactType.Contact && await x.GetIsGroupAsync(token).ConfigureAwait(false) && !await x.GetFreeAsync(token).ConfigureAwait(false),
                                                       x => x.GetContactPointsAsync(token), token).ConfigureAwait(false)
                    * await objSettings.GetKarmaContactAsync(token).ConfigureAwait(false);

                // Deduct the amount for free Qualities.
                intNewValue -=
                    (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.FreePositiveQualities, token: token).ConfigureAwait(false) *
                     await objSettings.GetKarmaQualityAsync(token).ConfigureAwait(false)).StandardRound();

                // If the character is allowed to take as many Positive Qualities as they'd like but all costs in excess are doubled, add the excess to their point cost.
                if (await objSettings.GetExceedPositiveQualitiesCostDoubledAsync(token).ConfigureAwait(false))
                {
                    int intPositiveQualityExcess = intNewValue - await objSettings.GetQualityKarmaLimitAsync(token).ConfigureAwait(false);
                    if (intPositiveQualityExcess > 0)
                    {
                        intNewValue += intPositiveQualityExcess;
                    }
                }

                return _intCachedPositiveQualityLimitKarma = intNewValue;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private int _intCachedPositiveQualities = int.MinValue;

        /// <summary>
        /// Total value of ALL positive qualities, including those that don't contribute to the quality limit during character creation.
        /// </summary>
        public int PositiveQualityKarma
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (_intCachedPositiveQualities != int.MinValue)
                        return _intCachedPositiveQualities;
                    // Qualities that count towards the Quality Limit are checked first to support the house rule allowing doubling of qualities over said limit.
                    int intNewValue
                        = Qualities.Sum(
                              objQuality => objQuality.Type == QualityType.Positive && objQuality.ContributeToBP
                                  && objQuality.ContributeToLimit, objQuality => objQuality.BP)
                          * Settings.KarmaQuality;
                    // Group contacts are counted as positive qualities
                    intNewValue += Contacts.Sum(x => x.EntityType == ContactType.Contact && x.IsGroup && !x.Free,
                        x => x.ContactPoints) * Settings.KarmaContact;

                    // Deduct the amount for free Qualities.
                    intNewValue -=
                        (ImprovementManager.ValueOf(this, Improvement.ImprovementType.FreePositiveQualities) *
                         Settings.KarmaQuality).StandardRound();

                    if (FreeSpells > 0)
                    {
                        // Factor in any qualities that can be bought with spell points at the end, but before doubled karma costs are calculated.
                        int intMasteryQualityKarmaUsed
                            = Qualities.Sum(objQuality => objQuality.CanBuyWithSpellPoints,
                                objQuality => objQuality.BP);
                        if (intMasteryQualityKarmaUsed != 0)
                        {
                            // Each spell costs KarmaSpell.
                            int spellCost = SpellKarmaCost("Spells");
                            // It is only karma-efficient to use spell points for Mastery qualities if real spell karma cost is not greater than unmodified spell karma cost
                            if (spellCost <= Settings.KarmaSpell)
                            {
                                // Assume that every [spell cost] karma spent on a Mastery quality is paid for with a priority-given spell point instead, as that is the most karma-efficient.
                                int intQualityKarmaToSpellPoints = Settings.KarmaSpell;
                                if (Settings.KarmaSpell != 0)
                                    intQualityKarmaToSpellPoints
                                        = Math.Min(FreeSpells,
                                            intMasteryQualityKarmaUsed * Settings.KarmaQuality
                                            / Settings.KarmaSpell);
                                // Add the karma paid for by spell points back into the available karma pool.
                                intNewValue -= intQualityKarmaToSpellPoints * Settings.KarmaSpell;
                            }
                        }
                    }

                    // If the character is allowed to take as many Positive Qualities as they'd like but all costs in excess are doubled, add the excess to their point cost.
                    if (Settings.ExceedPositiveQualitiesCostDoubled)
                    {
                        int intPositiveQualityExcess =
                            intNewValue - Settings.QualityKarmaLimit;
                        if (intPositiveQualityExcess > 0)
                        {
                            intNewValue += intPositiveQualityExcess;
                        }
                    }

                    // Qualities that don't count towards the cap are added afterwards.
                    intNewValue += Qualities.Sum(
                        objQuality => objQuality.Type == QualityType.Positive && objQuality.ContributeToBP
                                                                              && !objQuality.ContributeToLimit, objQuality => objQuality.BP) * Settings.KarmaQuality;

                    return _intCachedPositiveQualities = intNewValue;
                }
            }
        }

        /// <summary>
        /// Total value of ALL positive qualities, including those that don't contribute to the quality limit during character creation.
        /// </summary>
        public async Task<int> GetPositiveQualityKarmaAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_intCachedPositiveQualities != int.MinValue)
                    return _intCachedPositiveQualities;
                ThreadSafeObservableCollection<Quality> lstQualities = await GetQualitiesAsync(token).ConfigureAwait(false);
                CharacterSettings objSettings = await GetSettingsAsync(token).ConfigureAwait(false);
                int intKarmaQuality = await objSettings.GetKarmaQualityAsync(token).ConfigureAwait(false);
                // Qualities that count towards the Quality Limit are checked first to support the house rule allowing zeroing of qualities over said limit.
                int intNewValue
                    = await lstQualities.SumAsync(
                              async objQuality => await objQuality.GetTypeAsync(token).ConfigureAwait(false) == QualityType.Positive &&
                                                  await objQuality.GetContributeToBPAsync(token).ConfigureAwait(false)
                                                  && await objQuality.GetContributeToLimitAsync(token).ConfigureAwait(false),
                              objQuality => objQuality.GetBPAsync(token), token: token)
                          .ConfigureAwait(false)
                      * intKarmaQuality;
                // Group contacts are counted as positive qualities
                intNewValue += await (await GetContactsAsync(token).ConfigureAwait(false)).SumAsync(
                                   x => x.EntityType == ContactType.Contact && x.IsGroup && !x.Free,
                                   x => x.GetContactPointsAsync(token), token: token).ConfigureAwait(false)
                               * await objSettings.GetKarmaContactAsync(token).ConfigureAwait(false);

                // Deduct the amount for free Qualities.
                intNewValue -=
                    (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.FreePositiveQualities, token: token).ConfigureAwait(false) *
                     intKarmaQuality).StandardRound();

                // Factor in any qualities that can be bought with spell points at the end, but before doubled karma costs are calculated.
                int intMasteryQualityKarmaUsed
                    = await lstQualities.SumAsync(objQuality => objQuality.CanBuyWithSpellPoints,
                        objQuality => objQuality.BP, token: token).ConfigureAwait(false);
                if (intMasteryQualityKarmaUsed != 0)
                {
                    // Each spell costs KarmaSpell.
                    int spellCost = await SpellKarmaCostAsync("Spells", token).ConfigureAwait(false);
                    int intKarmaSpell = await objSettings.GetKarmaSpellAsync(token).ConfigureAwait(false);
                    int intFreeSpells = await GetFreeSpellsAsync(token).ConfigureAwait(false);
                    // It is only karma-efficient to use spell points for Mastery qualities if real spell karma cost is not greater than unmodified spell karma cost
                    if (spellCost <= intKarmaSpell && intFreeSpells > 0)
                    {
                        // Assume that every [spell cost] karma spent on a Mastery quality is paid for with a priority-given spell point instead, as that is the most karma-efficient.
                        int intQualityKarmaToSpellPoints = intKarmaSpell;
                        if (intKarmaSpell != 0)
                            intQualityKarmaToSpellPoints
                                = Math.Min(intFreeSpells,
                                    intMasteryQualityKarmaUsed * intKarmaQuality
                                    / intKarmaSpell);
                        // Add the karma paid for by spell points back into the available karma pool.
                        intNewValue -= intQualityKarmaToSpellPoints * intKarmaSpell;
                    }
                }

                // If the character is allowed to take as many Positive Qualities as they'd like but all costs in excess are doubled, add the excess to their point cost.
                if (await objSettings.GetExceedPositiveQualitiesCostDoubledAsync(token).ConfigureAwait(false))
                {
                    int intPositiveQualityExcess =
                        intNewValue - await objSettings.GetQualityKarmaLimitAsync(token).ConfigureAwait(false);
                    if (intPositiveQualityExcess > 0)
                    {
                        intNewValue += intPositiveQualityExcess;
                    }
                }

                // Qualities that don't count towards the cap are added afterwards.
                intNewValue += await lstQualities.SumAsync(
                    async objQuality => await objQuality.GetTypeAsync(token).ConfigureAwait(false) == QualityType.Positive &&
                                        await objQuality.GetContributeToBPAsync(token).ConfigureAwait(false)
                                        && !await objQuality.GetContributeToLimitAsync(token).ConfigureAwait(false),
                    objQuality => objQuality.GetBPAsync(token), token: token).ConfigureAwait(false) * intKarmaQuality;

                return _intCachedPositiveQualities = intNewValue;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplayPositiveQualityKarma
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (PositiveQualityLimitKarma != PositiveQualityKarma)
                    {
                        return string.Format(GlobalSettings.CultureInfo, "{0}/{1}{2}({3}){2}{4}",
                                             PositiveQualityLimitKarma,
                                             Settings.QualityKarmaLimit,
                                             LanguageManager.GetString("String_Space"),
                                             PositiveQualityKarma,
                                             LanguageManager.GetString("String_Karma"));
                    }

                    return string.Format(GlobalSettings.CultureInfo, "{0}/{1}{2}{3}",
                                         PositiveQualityLimitKarma,
                                         Settings.QualityKarmaLimit,
                                         LanguageManager.GetString("String_Space"),
                                         LanguageManager.GetString("String_Karma"));
                }
            }
        }

        public async Task<string> GetDisplayPositiveQualityKarmaAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intLimitKarma = await GetPositiveQualityLimitKarmaAsync(token).ConfigureAwait(false);
                int intQualityKarma = await GetPositiveQualityKarmaAsync(token).ConfigureAwait(false);
                int intQualityKarmaLimit = await (await GetSettingsAsync(token).ConfigureAwait(false)).GetQualityKarmaLimitAsync(token).ConfigureAwait(false);
                if (intLimitKarma != intQualityKarma)
                {
                    return string.Format(GlobalSettings.CultureInfo, "{0}/{1}{2}({3}){2}{4}",
                        intLimitKarma,
                        intQualityKarmaLimit,
                        await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false),
                        intQualityKarma,
                        await LanguageManager.GetStringAsync("String_Karma", token: token).ConfigureAwait(false));
                }

                return string.Format(GlobalSettings.CultureInfo, "{0}/{1}{2}{3}",
                    intLimitKarma,
                    intQualityKarmaLimit,
                    await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false),
                    await LanguageManager.GetStringAsync("String_Karma", token: token).ConfigureAwait(false));
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private int _intCachedNegativeQualities = int.MinValue;

        public int NegativeQualityKarma
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (_intCachedNegativeQualities != int.MinValue)
                        return _intCachedNegativeQualities;
                    // Qualities that count towards the Quality Limit are checked first to support the house rule allowing zeroing of qualities over said limit.
                    int intNewValue
                        = Qualities.Sum(
                              objQuality => objQuality.Type == QualityType.Negative && objQuality.ContributeToBP
                                  && objQuality.ContributeToLimit, objQuality => objQuality.BP)
                          * Settings.KarmaQuality;
                    // Group contacts are counted as positive qualities
                    intNewValue += EnemyKarma;

                    // Deduct the amount for free Qualities.
                    intNewValue -=
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.FreeNegativeQualities)
                            .StandardRound();

                    // If the character is only allowed to gain 25 BP from Negative Qualities but allowed to take as many as they'd like, limit their refunded points.
                    if (Settings.ExceedNegativeQualitiesNoBonus)
                    {
                        int intNegativeQualityLimit = -Settings.QualityKarmaLimit;
                        if (intNewValue < intNegativeQualityLimit)
                        {
                            intNewValue = intNegativeQualityLimit;
                        }
                    }

                    // Qualities that don't count towards the cap are added afterwards.
                    intNewValue += Qualities.Sum(
                        objQuality => objQuality.Type == QualityType.Negative && objQuality.ContributeToBP
                                                                              && !objQuality.ContributeToLimit, objQuality => objQuality.BP) * Settings.KarmaQuality;

                    return _intCachedNegativeQualities = -intNewValue;
                }
            }
        }

        public async Task<int> GetNegativeQualityKarmaAsync(bool blnApplyLimit = true, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_intCachedNegativeQualities != int.MinValue)
                    return _intCachedNegativeQualities;
                ThreadSafeObservableCollection<Quality> lstQualities =
                    await GetQualitiesAsync(token).ConfigureAwait(false);
                CharacterSettings objSettings = await GetSettingsAsync(token).ConfigureAwait(false);
                int intKarmaQuality = await objSettings.GetKarmaQualityAsync(token).ConfigureAwait(false);
                // Qualities that count towards the Quality Limit are checked first to support the house rule allowing zeroing of qualities over said limit.
                int intNewValue
                    = await lstQualities.SumAsync(
                          async objQuality =>
                              await objQuality.GetTypeAsync(token).ConfigureAwait(false) == QualityType.Negative &&
                              await objQuality.GetContributeToBPAsync(token).ConfigureAwait(false)
                              && await objQuality.GetContributeToLimitAsync(token).ConfigureAwait(false),
                          objQuality => objQuality.GetBPAsync(token), token: token).ConfigureAwait(false)
                      * intKarmaQuality;
                // Group contacts are counted as positive qualities
                intNewValue += await GetEnemyKarmaAsync(token).ConfigureAwait(false);

                // Deduct the amount for free Qualities.
                intNewValue -=
                    (await ImprovementManager
                        .ValueOfAsync(this, Improvement.ImprovementType.FreeNegativeQualities, token: token)
                        .ConfigureAwait(false) * intKarmaQuality)
                    .StandardRound();

                bool blnCacheValue = true;
                // If the character is only allowed to gain 25 BP from Negative Qualities but allowed to take as many as they'd like, limit their refunded points.
                if (await objSettings.GetExceedNegativeQualitiesNoBonusAsync(token).ConfigureAwait(false))
                {
                    int intNegativeQualityLimit =
                        -await objSettings.GetQualityKarmaLimitAsync(token).ConfigureAwait(false);
                    if (intNewValue < intNegativeQualityLimit)
                    {
                        if (blnApplyLimit)
                            intNewValue = intNegativeQualityLimit;
                        blnCacheValue = false;
                    }
                }

                // Qualities that don't count towards the cap are added afterwards.
                intNewValue += await lstQualities.SumAsync(
                                   async objQuality =>
                                       await objQuality.GetTypeAsync(token).ConfigureAwait(false) == QualityType.Negative &&
                                       await objQuality.GetContributeToBPAsync(token).ConfigureAwait(false) &&
                                       !await objQuality.GetContributeToLimitAsync(token).ConfigureAwait(false),
                                   objQuality => objQuality.GetBPAsync(token), token: token).ConfigureAwait(false) *
                               intKarmaQuality;

                return blnCacheValue ? _intCachedNegativeQualities = -intNewValue : -intNewValue;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private int _intCachedNegativeQualityLimitKarma = int.MinValue;

        /// <summary>
        /// Negative qualities that contribute to the character's Quality Limit during character creation.
        /// </summary>
        public int NegativeQualityLimitKarma
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (_intCachedNegativeQualityLimitKarma != int.MinValue)
                        return _intCachedNegativeQualityLimitKarma;
                    int intNewValue
                        = Qualities.Sum(
                            objQuality => objQuality.Type == QualityType.Negative && objQuality.ContributeToLimit,
                            objQuality => objQuality.BP) * Settings.KarmaQuality;
                    // Group contacts are counted as positive qualities
                    if (Settings.EnemyKarmaQualityLimit)
                        intNewValue += EnemyKarma;

                    // Deduct the amount for free Qualities.
                    intNewValue -=
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.FreeNegativeQualities)
                            .StandardRound();

                    // If the character is only allowed to gain 25 BP from Negative Qualities but allowed to take as many as they'd like, limit their refunded points.
                    if (Settings.ExceedNegativeQualitiesNoBonus)
                    {
                        int intNegativeQualityLimit = -Settings.QualityKarmaLimit;
                        if (intNewValue < intNegativeQualityLimit)
                        {
                            intNewValue = intNegativeQualityLimit;
                        }
                    }

                    return _intCachedNegativeQualityLimitKarma = -intNewValue;
                }
            }
        }

        /// <summary>
        /// Negative qualities that contribute to the character's Quality Limit during character creation.
        /// </summary>
        public async Task<int> GetNegativeQualityLimitKarmaAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_intCachedNegativeQualityLimitKarma != int.MinValue)
                    return _intCachedNegativeQualityLimitKarma;
                CharacterSettings objSettings = await GetSettingsAsync(token).ConfigureAwait(false);
                int intNewValue
                    = await Qualities.SumAsync(
                          async objQuality =>
                              await objQuality.GetTypeAsync(token).ConfigureAwait(false) == QualityType.Negative &&
                              await objQuality.GetContributeToLimitAsync(token).ConfigureAwait(false),
                          objQuality => objQuality.GetBPAsync(token), token: token).ConfigureAwait(false) *
                      await objSettings.GetKarmaQualityAsync(token).ConfigureAwait(false);
                // Group contacts are counted as positive qualities
                if (await objSettings.GetEnemyKarmaQualityLimitAsync(token).ConfigureAwait(false))
                    intNewValue += await GetEnemyKarmaAsync(token).ConfigureAwait(false);

                // Deduct the amount for free Qualities.
                intNewValue -=
                    (await ImprovementManager
                        .ValueOfAsync(this, Improvement.ImprovementType.FreeNegativeQualities, token: token)
                        .ConfigureAwait(false))
                    .StandardRound();

                // If the character is only allowed to gain 25 BP from Negative Qualities but allowed to take as many as they'd like, limit their refunded points.
                if (await objSettings.GetExceedNegativeQualitiesNoBonusAsync(token).ConfigureAwait(false))
                {
                    int intNegativeQualityLimit =
                        -await objSettings.GetQualityKarmaLimitAsync(token).ConfigureAwait(false);
                    if (intNewValue < intNegativeQualityLimit)
                    {
                        intNewValue = intNegativeQualityLimit;
                    }
                }

                return _intCachedNegativeQualityLimitKarma = -intNewValue;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplayNegativeQualityKarma
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (NegativeQualityLimitKarma != NegativeQualityKarma)
                    {
                        return string.Format(GlobalSettings.CultureInfo, "{0}/{1}{2}({3}){2}{4}",
                                             NegativeQualityLimitKarma,
                                             Settings.QualityKarmaLimit,
                                             LanguageManager.GetString("String_Space"),
                                             NegativeQualityKarma,
                                             LanguageManager.GetString("String_Karma"));
                    }

                    return string.Format(GlobalSettings.CultureInfo, "{0}/{1}{2}{3}",
                                         NegativeQualityLimitKarma,
                                         Settings.QualityKarmaLimit,
                                         LanguageManager.GetString("String_Space"),
                                         LanguageManager.GetString("String_Karma"));
                }
            }
        }

        public async Task<string> GetDisplayNegativeQualityKarmaAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intLimitKarma = await GetNegativeQualityLimitKarmaAsync(token).ConfigureAwait(false);
                int intQualityKarma = await GetNegativeQualityKarmaAsync(false, token: token).ConfigureAwait(false);
                int intQualityKarmaLimit = await (await GetSettingsAsync(token).ConfigureAwait(false)).GetQualityKarmaLimitAsync(token).ConfigureAwait(false);
                if (intLimitKarma != intQualityKarma)
                {
                    return string.Format(GlobalSettings.CultureInfo, "{0}/{1}{2}({3}){2}{4}",
                        intLimitKarma,
                        intQualityKarmaLimit,
                        await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false),
                        intQualityKarma,
                        await LanguageManager.GetStringAsync("String_Karma", token: token).ConfigureAwait(false));
                }

                return string.Format(GlobalSettings.CultureInfo, "{0}/{1}{2}{3}",
                    intLimitKarma,
                    intQualityKarmaLimit,
                    await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false),
                    await LanguageManager.GetStringAsync("String_Karma", token: token).ConfigureAwait(false));
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private int _intCachedMetagenicPositiveQualities = int.MinValue;

        public int MetagenicPositiveQualityKarma
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    return _intCachedMetagenicPositiveQualities != int.MinValue
                        ? _intCachedMetagenicPositiveQualities
                        : _intCachedMetagenicPositiveQualities = Qualities
                            .Sum(
                                objQuality =>
                                    objQuality.Type == QualityType.Positive && objQuality.ContributeToMetagenicLimit,
                                objQuality => objQuality.BP);
                }
            }
        }

        public async Task<int> GetMetagenicPositiveQualityKarmaAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_intCachedMetagenicPositiveQualities != int.MinValue)
                    return _intCachedMetagenicPositiveQualities;
                ThreadSafeObservableCollection<Quality> lstQualities = await GetQualitiesAsync(token).ConfigureAwait(false);
                return _intCachedMetagenicPositiveQualities = await lstQualities.SumAsync(async objQuality =>
                        await objQuality.GetTypeAsync(token).ConfigureAwait(false) == QualityType.Positive && await objQuality.GetContributeToMetagenicLimitAsync(token).ConfigureAwait(false),
                    objQuality => objQuality.GetBPAsync(token), token: token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private int _intCachedMetagenicNegativeQualities = int.MinValue;

        public int MetagenicNegativeQualityKarma
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (_intCachedMetagenicNegativeQualities != int.MinValue)
                        return _intCachedMetagenicNegativeQualities;
                    int intNewValue = Qualities
                        .Sum(
                            objQuality =>
                                objQuality.Type == QualityType.Negative && objQuality.ContributeToMetagenicLimit,
                            objQuality => objQuality.BP);

                    // Deduct the amount for free Qualities.
                    intNewValue -=
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.FreeNegativeQualities)
                            .StandardRound();

                    return _intCachedMetagenicNegativeQualities = intNewValue;
                }
            }
        }

        public async Task<int> GetMetagenicNegativeQualityKarmaAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_intCachedMetagenicNegativeQualities != int.MinValue) return _intCachedMetagenicNegativeQualities;
                ThreadSafeObservableCollection<Quality> lstQualities = await GetQualitiesAsync(token).ConfigureAwait(false);
                int intNewValue = await lstQualities.SumAsync(async objQuality =>
                        await objQuality.GetTypeAsync(token).ConfigureAwait(false) == QualityType.Negative && await objQuality.GetContributeToMetagenicLimitAsync(token).ConfigureAwait(false),
                    objQuality => objQuality.GetBPAsync(token), token: token).ConfigureAwait(false);
                // Deduct the amount for free Qualities.
                intNewValue -=
                    (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.FreeNegativeQualities, token: token).ConfigureAwait(false))
                    .StandardRound();

                return _intCachedMetagenicNegativeQualities = intNewValue;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplayMetagenicQualityKarma
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    string strReturn = string.Format(GlobalSettings.CultureInfo,
                        LanguageManager.GetString("Label_MetagenicKarmaValue"), MetagenicPositiveQualityKarma,
                        MetagenicNegativeQualityKarma, MetagenicLimit);
                    if (MetagenicPositiveQualityKarma + MetagenicNegativeQualityKarma == 1)
                        strReturn += LanguageManager.GetString("Label_MetagenicKarmaValueAppend");

                    return strReturn;
                }
            }
        }

        public async Task<string> GetDisplayMetagenicQualityKarmaAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                int intPositive = await GetMetagenicPositiveQualityKarmaAsync(token).ConfigureAwait(false);
                int intNegative = await GetMetagenicNegativeQualityKarmaAsync(token).ConfigureAwait(false);
                string strReturn = string.Format(GlobalSettings.CultureInfo,
                    await LanguageManager.GetStringAsync("Label_MetagenicKarmaValue", token: token)
                        .ConfigureAwait(false), intPositive, intNegative,
                    await GetMetagenicLimitAsync(token).ConfigureAwait(false));
                if (intPositive + intNegative == 1)
                    strReturn += await LanguageManager.GetStringAsync("Label_MetagenicKarmaValueAppend", token: token)
                        .ConfigureAwait(false);

                return strReturn;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private int _intCachedEnemyKarma = int.MinValue;

        public int EnemyKarma
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (_intCachedEnemyKarma != int.MinValue)
                        return _intCachedEnemyKarma;
                    return Settings.EnableEnemyTracking && Settings.KarmaEnemy > 0
                        ? _intCachedEnemyKarma
                            = Contacts.Sum(x => x.IsEnemy && !x.Free, x => x.Connection + x.Loyalty)
                              * Settings.KarmaEnemy
                        : _intCachedEnemyKarma = 0;
                }
            }
        }

        public async Task<int> GetEnemyKarmaAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_intCachedEnemyKarma != int.MinValue)
                    return _intCachedEnemyKarma;
                CharacterSettings objSettings = await GetSettingsAsync(token).ConfigureAwait(false);
                if (!await objSettings.GetEnableEnemyTrackingAsync(token).ConfigureAwait(false))
                    return _intCachedEnemyKarma = 0;
                int intKarmaEnemy = await objSettings.GetKarmaEnemyAsync(token).ConfigureAwait(false);
                return intKarmaEnemy > 0
                    ? _intCachedEnemyKarma
                        = await (await GetContactsAsync(token).ConfigureAwait(false)).SumAsync(
                                  async x => await x.GetIsEnemyAsync(token).ConfigureAwait(false) &&
                                             !await x.GetFreeAsync(token).ConfigureAwait(false),
                                  async x => await x.GetConnectionAsync(token).ConfigureAwait(false) +
                                             await x.GetLoyaltyAsync(token).ConfigureAwait(false), token: token)
                              .ConfigureAwait(false)
                          * intKarmaEnemy
                    : _intCachedEnemyKarma = 0;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string DisplayEnemyKarma =>
            EnemyKarma.ToString(GlobalSettings.CultureInfo)
            + LanguageManager.GetString("String_Space")
            + LanguageManager.GetString("String_Karma");

        public async Task<string> GetDisplayEnemyKarmaAsync(CancellationToken token = default)
        {
            return (await GetEnemyKarmaAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo)
                   + await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false)
                   + await LanguageManager.GetStringAsync("String_Karma", token: token).ConfigureAwait(false);
        }

        #endregion Karma Values

        #region Source

        private SourceString _objCachedSourceDetail;
        private readonly AsyncFriendlyReaderWriterLock _objCachedSourceDetailLock;
        private readonly SkillsSection _objSkillsSection;
        private readonly AttributeSection _objAttributeSection;
        private readonly ConcurrentHashSet<Func<CancellationToken, bool>> _setPostLoadMethods = new ConcurrentHashSet<Func<CancellationToken, bool>>();
        private readonly ConcurrentHashSet<Func<CancellationToken, Task<bool>>> _setPostLoadAsyncMethods = new ConcurrentHashSet<Func<CancellationToken, Task<bool>>>();

        public SourceString SourceDetail
        {
            get
            {
                using (_objCachedSourceDetailLock.EnterReadLock())
                {
                    if (_objCachedSourceDetail != default && _objCachedSourceDetail.Language == GlobalSettings.Language)
                        return _objCachedSourceDetail;
                }

                using (_objCachedSourceDetailLock.EnterUpgradeableReadLock())
                {
                    if (_objCachedSourceDetail != default && _objCachedSourceDetail.Language == GlobalSettings.Language)
                        return _objCachedSourceDetail;
                    using (_objCachedSourceDetailLock.EnterWriteLock())
                    {
                        return _objCachedSourceDetail = SourceString.GetSourceString(Source,
                            DisplayPage(GlobalSettings.Language), GlobalSettings.Language,
                            GlobalSettings.CultureInfo,
                            this);
                    }
                }
            }
        }

        public async Task<SourceString> GetSourceDetailAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await _objCachedSourceDetailLock.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                if (_objCachedSourceDetail != default && _objCachedSourceDetail.Language == GlobalSettings.Language)
                    return _objCachedSourceDetail;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }

            objLocker =
                await _objCachedSourceDetailLock.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_objCachedSourceDetail != default && _objCachedSourceDetail.Language == GlobalSettings.Language)
                    return _objCachedSourceDetail;
                IAsyncDisposable objLocker2 =
                    await _objCachedSourceDetailLock.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    return _objCachedSourceDetail = await SourceString.GetSourceStringAsync(Source,
                        await DisplayPageAsync(GlobalSettings.Language, token).ConfigureAwait(false),
                        GlobalSettings.Language,
                        GlobalSettings.CultureInfo,
                        this, token).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's Sourcebook.
        /// </summary>
        public string Source
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _strSource;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _strSource, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Sourcebook Page Number.
        /// </summary>
        public string Page
        {
            get
            {
                using (LockObject.EnterReadLock())
                    return _strPage;
            }
            set
            {
                using (LockObject.EnterUpgradeableReadLock())
                {
                    if (Interlocked.Exchange(ref _strPage, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        public bool AllowAdeptWayPowerDiscount
        {
            get
            {
                using (LockObject.EnterReadLock())
                {
                    if (!AnyPowerAdeptWayDiscountEnabled)
                        return false;

                    decimal decMAG;
                    if (IsMysticAdept && Settings.MysAdeptSecondMAGAttribute)
                    {
                        // If both Adept and Magician are enabled, this is a Mystic Adept, so use the MAG amount assigned to this portion.
                        decMAG = MAGAdept.TotalValue;
                    }
                    else
                    {
                        // The character is just an Adept, so use the full value.
                        decMAG = MAG.TotalValue;
                    }

                    return Powers.Count(p => p.DiscountedAdeptWay) < (decMAG / 2).ToInt32();
                }
            }
        }

        public async Task<bool> GetAllowAdeptWayPowerDiscountAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();

                if (!await GetAnyPowerAdeptWayDiscountEnabledAsync(token).ConfigureAwait(false))
                    return false;

                decimal decMAG;
                if (await GetIsMysticAdeptAsync(token).ConfigureAwait(false) &&
                    await (await GetSettingsAsync(token).ConfigureAwait(false))
                        .GetMysAdeptSecondMAGAttributeAsync(token).ConfigureAwait(false))
                {
                    // If both Adept and Magician are enabled, this is a Mystic Adept, so use the MAG amount assigned to this portion.
                    decMAG = await (await GetAttributeAsync("MAGAdept", token: token).ConfigureAwait(false))
                        .GetTotalValueAsync(token).ConfigureAwait(false);
                }
                else
                {
                    // The character is just an Adept, so use the full value.
                    decMAG = await (await GetAttributeAsync("MAG", token: token).ConfigureAwait(false))
                        .GetTotalValueAsync(token).ConfigureAwait(false);
                }

                return await Powers.CountAsync(p => p.GetDiscountedAdeptWayAsync(token), token: token)
                    .ConfigureAwait(false) < (decMAG / 2).ToInt32();
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Sourcebook Page Number using a given language file.
        /// Returns Page if not found or the string is empty.
        /// </summary>
        /// <param name="strLanguage">Language file keyword to use.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        /// <returns></returns>
        public string DisplayPage(string strLanguage, CancellationToken token = default)
        {
            using (LockObject.EnterReadLock(token))
            {
                if (strLanguage.Equals(GlobalSettings.DefaultLanguage, StringComparison.OrdinalIgnoreCase))
                    return Page;
                string s = this.GetNodeXPath(token)?.SelectSingleNodeAndCacheExpression("altpage", token)?.Value ?? Page;
                return !string.IsNullOrWhiteSpace(s) ? s : Page;
            }
        }

        /// <summary>
        /// Sourcebook Page Number using a given language file.
        /// Returns Page if not found or the string is empty.
        /// </summary>
        /// <param name="strLanguage">Language file keyword to use.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        /// <returns></returns>
        public async Task<string> DisplayPageAsync(string strLanguage, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (strLanguage.Equals(GlobalSettings.DefaultLanguage, StringComparison.OrdinalIgnoreCase))
                    return Page;
                string s = (await this.GetNodeXPathAsync(token).ConfigureAwait(false))?.SelectSingleNodeAndCacheExpression("altpage", token)?.Value ?? Page;
                return !string.IsNullOrWhiteSpace(s) ? s : Page;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Alias map for SourceDetail control text and tooltip assignation.
        /// </summary>
        /// <param name="sourceControl"></param>
        public void SetSourceDetail(Control sourceControl)
        {
            SourceDetail.SetControl(sourceControl);
        }

        public async Task SetSourceDetailAsync(Control sourceControl, CancellationToken token = default)
        {
            await (await GetSourceDetailAsync(token).ConfigureAwait(false)).SetControlAsync(sourceControl, token).ConfigureAwait(false);
        }

        #endregion Source

        #region Special Methods

        private List<ListItem> _lstCachedContactArchetypes;
        private string _strCachedXmlNodeLanguage = string.Empty;

        public List<ListItem> ContactArchetypes(string strLanguage = "")
        {
            if (string.IsNullOrEmpty(strLanguage))
                strLanguage = GlobalSettings.Language;
            using (LockObject.EnterReadLock())
            {
                if (_lstCachedContactArchetypes != null && strLanguage == _strCachedXmlNodeLanguage
                                                        && !GlobalSettings.LiveCustomData)
                    return _lstCachedContactArchetypes;
                List<ListItem> lstNew = Utils.ListItemListPool.Get();
                lstNew.Add(ListItem.Blank);
                XPathNavigator xmlContactsBaseNode = LoadDataXPath("contacts.xml", strLanguage)
                    .SelectSingleNodeAndCacheExpression("/chummer");
                if (xmlContactsBaseNode != null)
                {
                    foreach (XPathNavigator xmlNode in xmlContactsBaseNode.SelectAndCacheExpression("contacts/contact"))
                    {
                        string strName = xmlNode.Value;
                        lstNew.Add(
                            new ListItem(
                                strName, xmlNode.SelectSingleNodeAndCacheExpression("@translate")?.Value ?? strName));
                    }

                    lstNew.Sort(CompareListItems.CompareNames);
                }
                _strCachedXmlNodeLanguage = strLanguage;
                List<ListItem> lstOld = Interlocked.Exchange(ref _lstCachedContactArchetypes, lstNew);
                if (lstOld != null)
                    Utils.ListItemListPool.Return(ref lstOld);
                return _lstCachedContactArchetypes;
            }
        }

        public async Task<List<ListItem>> ContactArchetypesAsync(string strLanguage = "", CancellationToken token = default)
        {
            if (string.IsNullOrEmpty(strLanguage))
                strLanguage = GlobalSettings.Language;
            IAsyncDisposable objLocker = await LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_lstCachedContactArchetypes != null && strLanguage == _strCachedXmlNodeLanguage
                                                        && !GlobalSettings.LiveCustomData)
                    return _lstCachedContactArchetypes;
                List<ListItem> lstNew = Utils.ListItemListPool.Get();
                lstNew.Add(ListItem.Blank);
                XPathNavigator xmlContactsBaseNode = (await LoadDataXPathAsync("contacts.xml", strLanguage, token: token).ConfigureAwait(false))
                                                           .SelectSingleNodeAndCacheExpression("/chummer", token);
                if (xmlContactsBaseNode != null)
                {
                    foreach (XPathNavigator xmlNode in xmlContactsBaseNode.SelectAndCacheExpression("contacts/contact", token))
                    {
                        string strName = xmlNode.Value;
                        lstNew.Add(
                            new ListItem(
                                strName, (xmlNode.SelectSingleNodeAndCacheExpression("@translate", token))?.Value ?? strName));
                    }

                    lstNew.Sort(CompareListItems.CompareNames);
                }
                _strCachedXmlNodeLanguage = strLanguage;
                List<ListItem> lstOld = Interlocked.Exchange(ref _lstCachedContactArchetypes, lstNew);
                if (lstOld != null)
                    Utils.ListItemListPool.Return(ref lstOld);
                return _lstCachedContactArchetypes;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public async Task<bool> ConvertCyberzombie(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                bool blnEssence = true;
                string strMessage = await LanguageManager
                    .GetStringAsync("Message_CyberzombieRequirements", token: token).ConfigureAwait(false);

                // Make sure the character has an Essence lower than 0.
                decimal decEssence = await EssenceAsync(token: token).ConfigureAwait(false);
                if (decEssence >= 0)
                {
                    strMessage += Environment.NewLine + "\t" +
                                  await LanguageManager
                                      .GetStringAsync("Message_CyberzombieRequirementsEssence", token: token)
                                      .ConfigureAwait(false);
                    blnEssence = false;
                }

                bool blnEnabled = (await ImprovementManager
                    .GetCachedImprovementListForValueOfAsync(this, Improvement.ImprovementType.EnableCyberzombie,
                        token: token).ConfigureAwait(false)).Count > 0;

                if (!blnEnabled)
                    strMessage += Environment.NewLine + "\t" +
                                  await LanguageManager
                                      .GetStringAsync("Message_CyberzombieRequirementsImprovement", token: token)
                                      .ConfigureAwait(false);

                if (!blnEssence || !blnEnabled)
                {
                    await Program.ShowScrollableMessageBoxAsync(strMessage,
                        await LanguageManager.GetStringAsync("MessageTitle_CyberzombieRequirements", token: token)
                            .ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Error, token: token).ConfigureAwait(false);
                    return false;
                }

                if (await Program.ShowScrollableMessageBoxAsync(
                        await LanguageManager.GetStringAsync("Message_CyberzombieConfirm", token: token)
                            .ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_CyberzombieConfirm", token: token)
                            .ConfigureAwait(false),
                        MessageBoxButtons.YesNo, MessageBoxIcon.Question, token: token).ConfigureAwait(false) == DialogResult.No)
                    return false;

                int intWILResult;
                string strText = await LanguageManager.GetStringAsync("String_CyberzombieWILText", token: token)
                    .ConfigureAwait(false);
                string strDescription = await LanguageManager
                    .GetStringAsync("String_CyberzombieWILDescription", token: token).ConfigureAwait(false);
                int intDice = await WIL.GetTotalValueAsync(token).ConfigureAwait(false);
                // Get the player to roll Dice to make a WIL Test and record the result.
                using (ThreadSafeForm<SelectDiceHits> frmWILHits = await ThreadSafeForm<SelectDiceHits>.GetAsync(() =>
                           new SelectDiceHits
                           {
                               Text = strText,
                               Description = strDescription
                           }, token).ConfigureAwait(false))
                {
                    await frmWILHits.MyForm.SetDiceAsync(intDice, token).ConfigureAwait(false);
                    if (await frmWILHits.ShowDialogSafeAsync(this, token).ConfigureAwait(false) != DialogResult.OK)
                        return false;

                    intWILResult = frmWILHits.MyForm.Result;
                }

                // The character gains 10 + ((Threshold - Hits) * 10)BP worth of Negative Qualities.
                int intThreshold = 3 + (decEssence - await ESS.GetMetatypeMaximumAsync(token).ConfigureAwait(false))
                    .ToInt32();
                int intResult = 10;
                if (intWILResult < intThreshold)
                {
                    intResult = (intThreshold - intWILResult) * 10;
                }

                try
                {
                    token.ThrowIfCancellationRequested();
                    await ImprovementManager.CreateImprovementAsync(this, string.Empty,
                            Improvement.ImprovementSource.Cyberzombie,
                            string.Empty,
                            Improvement.ImprovementType.FreeNegativeQualities,
                            string.Empty, intResult * -1, token: token)
                        .ConfigureAwait(false);
                }
                catch
                {
                    await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                    throw;
                }

                await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);

                // Convert the character.
                // Characters lose access to Resonance.
                await SetRESEnabledAsync(false, token).ConfigureAwait(false);

                // Gain MAG that is permanently set to 1.
                await MAG.AssignBaseKarmaLimitsAsync(0, 0, 1, 1, 1, token).ConfigureAwait(false);

                // Add the Cyberzombie Lifestyle if it is not already taken.
                if (await Lifestyles.AllAsync(x => x.BaseLifestyle != "Cyberzombie Lifestyle Addition", token)
                        .ConfigureAwait(false))
                {
                    XmlDocument objXmlLifestyleDocument =
                        await LoadDataAsync("lifestyles.xml", token: token).ConfigureAwait(false);
                    XmlNode objXmlLifestyle =
                        objXmlLifestyleDocument.SelectSingleNode(
                            "/chummer/lifestyles/lifestyle[name = \"Cyberzombie Lifestyle Addition\"]");

                    if (objXmlLifestyle != null)
                    {
                        Lifestyle objLifestyle = new Lifestyle(this);
                        try
                        {
                            await objLifestyle.CreateAsync(objXmlLifestyle, token).ConfigureAwait(false);
                            await Lifestyles.AddAsync(objLifestyle, token).ConfigureAwait(false);
                        }
                        catch
                        {
                            await objLifestyle.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }
                    }
                }

                // Change the MetatypeCategory to Cyberzombie.
                await SetMetatypeCategoryAsync("Cyberzombie", token).ConfigureAwait(false);

                // Gain access to Critter Powers.
                CritterEnabled = true;

                // Gain the Dual Natured Critter Power if it does not yet exist.
                if (await CritterPowers.AllAsync(x => x.Name != "Dual Natured", token).ConfigureAwait(false))
                {
                    XmlNode objXmlPowerNode =
                        (await LoadDataAsync("critterpowers.xml", token: token).ConfigureAwait(false)).SelectSingleNode(
                            "/chummer/powers/power[name = \"Dual Natured\"]");

                    if (objXmlPowerNode != null)
                    {
                        CritterPower objCritterPower = new CritterPower(this);
                        await objCritterPower.CreateAsync(objXmlPowerNode, token: token).ConfigureAwait(false);
                        await CritterPowers.AddAsync(objCritterPower, token).ConfigureAwait(false);
                    }
                }

                // Gain the Immunity (Normal Weapons) Critter Power if it does not yet exist.
                if (!await CritterPowers.AnyAsync(x => x.Name == "Immunity" && x.Extra == "Normal Weapons", token)
                        .ConfigureAwait(false))
                {
                    XmlNode objXmlPowerNode =
                        (await LoadDataAsync("critterpowers.xml", token: token).ConfigureAwait(false)).SelectSingleNode(
                            "/chummer/powers/power[name = \"Immunity\"]");

                    if (objXmlPowerNode != null)
                    {
                        CritterPower objCritterPower = new CritterPower(this);
                        await objCritterPower.CreateAsync(objXmlPowerNode, 0, "Normal Weapons", token).ConfigureAwait(false);
                        await CritterPowers.AddAsync(objCritterPower, token).ConfigureAwait(false);
                    }
                }

                return true;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public string ProcessAttributesInXPath(string strInput, IReadOnlyDictionary<string, int> dicValueOverrides = null, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (string.IsNullOrEmpty(strInput))
                return string.Empty;
            if (!strInput.Contains('{'))
                return strInput;
            return AttributeSection.ProcessAttributesInXPath(strInput, dicValueOverrides, token);
        }

        public void ProcessAttributesInXPath(StringBuilder sbdInput, string strOriginal = "", IReadOnlyDictionary<string, int> dicValueOverrides = null, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (sbdInput == null || sbdInput.Length <= 0)
                return;
            if (!sbdInput.HasValuesNeedingReplacementForXPathProcessing(false))
                return;
            if (string.IsNullOrEmpty(strOriginal))
                strOriginal = sbdInput.ToString();
            AttributeSection.ProcessAttributesInXPath(sbdInput, strOriginal, dicValueOverrides, token);
        }

        public Task<string> ProcessAttributesInXPathAsync(string strInput, IReadOnlyDictionary<string, int> dicValueOverrides = null, CancellationToken token = default)
        {
            if (token.IsCancellationRequested)
                return Task.FromCanceled<string>(token);
            if (string.IsNullOrEmpty(strInput))
                return Task.FromResult(string.Empty);
            if (!strInput.Contains('{'))
                return Task.FromResult(strInput);
            return Inner();
            async Task<string> Inner()
            {
                return await (await GetAttributeSectionAsync(token).ConfigureAwait(false)).ProcessAttributesInXPathAsync(strInput, dicValueOverrides, token).ConfigureAwait(false);
            }
        }

        public Task ProcessAttributesInXPathAsync(StringBuilder sbdInput, string strOriginal = "", IReadOnlyDictionary<string, int> dicValueOverrides = null, CancellationToken token = default)
        {
            if (token.IsCancellationRequested)
                return Task.FromCanceled<string>(token);
            if (sbdInput == null || sbdInput.Length <= 0)
                return Task.CompletedTask;
            if (!sbdInput.HasValuesNeedingReplacementForXPathProcessing(false))
                return Task.CompletedTask;
            return Inner();
            async Task Inner()
            {
                await (await GetAttributeSectionAsync(token).ConfigureAwait(false)).ProcessAttributesInXPathAsync(sbdInput, strOriginal, dicValueOverrides, token).ConfigureAwait(false);
            }
        }

        public string ProcessAttributesInXPathForTooltip(string strInput, CultureInfo objCultureInfo = null, string strLanguage = "", bool blnShowValues = true, IReadOnlyDictionary<string, int> dicValueOverrides = null, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (string.IsNullOrEmpty(strInput))
                return string.Empty;
            if (!strInput.Contains('{'))
                return strInput;
            return AttributeSection.ProcessAttributesInXPathForTooltip(strInput, objCultureInfo, strLanguage, blnShowValues, dicValueOverrides, token);
        }

        public void ProcessAttributesInXPathForTooltip(StringBuilder sbdInput, string strOriginal = "", CultureInfo objCultureInfo = null, string strLanguage = "", bool blnShowValues = true, IReadOnlyDictionary<string, int> dicValueOverrides = null, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (sbdInput == null || sbdInput.Length <= 0)
                return;
            if (!sbdInput.HasValuesNeedingReplacementForXPathProcessing(false))
                return;
            AttributeSection.ProcessAttributesInXPathForTooltip(sbdInput, strOriginal, objCultureInfo, strLanguage, blnShowValues, dicValueOverrides, token);
        }

        public Task<string> ProcessAttributesInXPathForTooltipAsync(string strInput, CultureInfo objCultureInfo = null, string strLanguage = "", bool blnShowValues = true, IAsyncReadOnlyDictionary<string, int> dicValueOverrides = null, CancellationToken token = default)
        {
            if (token.IsCancellationRequested)
                return Task.FromCanceled<string>(token);
            if (string.IsNullOrEmpty(strInput))
                return Task.FromResult(string.Empty);
            if (!strInput.Contains('{'))
                return Task.FromResult(strInput);
            return Inner();
            async Task<string> Inner()
            {
                return await (await GetAttributeSectionAsync(token).ConfigureAwait(false)).ProcessAttributesInXPathForTooltipAsync(strInput, objCultureInfo, strLanguage, blnShowValues, dicValueOverrides, token).ConfigureAwait(false);
            }
        }

        public Task ProcessAttributesInXPathForTooltipAsync(StringBuilder sbdInput, string strOriginal = "",
            CultureInfo objCultureInfo = null, string strLanguage = "", bool blnShowValues = true,
            IAsyncReadOnlyDictionary<string, int> dicValueOverrides = null, CancellationToken token = default)
        {
            if (token.IsCancellationRequested)
                return Task.FromCanceled<string>(token);
            if (sbdInput == null || sbdInput.Length <= 0)
                return Task.CompletedTask;
            if (!sbdInput.HasValuesNeedingReplacementForXPathProcessing(false))
                return Task.CompletedTask;
            return Inner();
            async Task Inner()
            {
                await (await GetAttributeSectionAsync(token).ConfigureAwait(false)).ProcessAttributesInXPathForTooltipAsync(sbdInput, strOriginal, objCultureInfo, strLanguage, blnShowValues, dicValueOverrides, token).ConfigureAwait(false);
            }
        }

        #endregion Special Methods

        #region Quality Level Processing

        /// <summary>
        /// Property that triggers quality level processing when accessed.
        /// This follows the same pattern as RedlinerBonus.
        /// </summary>
        public bool HasAnyQualitiesWithQualityLevels
        {
            get
            {
                using (_objCachedHasAnyQualitiesWithQualityLevelsLock.EnterReadLock())
                {
                    if (_intCachedHasAnyQualitiesWithQualityLevels >= 0)
                        return _intCachedHasAnyQualitiesWithQualityLevels > 0;
                }
                using (_objCachedHasAnyQualitiesWithQualityLevelsLock.EnterUpgradeableReadLock())
                {
                    if (_intCachedHasAnyQualitiesWithQualityLevels < 0)
                    {
                        using (_objCachedHasAnyQualitiesWithQualityLevelsLock.EnterWriteLock())
                        {
                            _intCachedHasAnyQualitiesWithQualityLevels = ProcessQualityLevels() ? 1 : 0;
                        }
                    }
                    return _intCachedHasAnyQualitiesWithQualityLevels > 0;
                }
            }
        }

        /// <summary>
        /// Property that triggers quality level processing when accessed.
        /// This follows the same pattern as RedlinerBonus.
        /// </summary>
        public async Task<bool> GetHasAnyQualitiesWithQualityLevelsAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await _objCachedHasAnyQualitiesWithQualityLevelsLock.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_intCachedHasAnyQualitiesWithQualityLevels >= 0)
                    return _intCachedHasAnyQualitiesWithQualityLevels > 0;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
            objLocker = await _objCachedHasAnyQualitiesWithQualityLevelsLock.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (_intCachedHasAnyQualitiesWithQualityLevels < 0)
                {
                    IAsyncDisposable objLocker2 = await _objCachedHasAnyQualitiesWithQualityLevelsLock.EnterWriteLockAsync(token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        _intCachedHasAnyQualitiesWithQualityLevels = await ProcessQualityLevelsAsync(token).ConfigureAwait(false) ? 1 : 0;
                    }
                    finally
                    {
                        await objLocker2.DisposeAsync().ConfigureAwait(false);
                    }
                }
                return _intCachedHasAnyQualitiesWithQualityLevels > 0;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private int _intCachedHasAnyQualitiesWithQualityLevels = int.MinValue;
        private readonly AsyncFriendlyReaderWriterLock _objCachedHasAnyQualitiesWithQualityLevelsLock;

        public void RequestQualityLevelsReprocessing(CancellationToken token = default)
        {
            using (_objCachedHasAnyQualitiesWithQualityLevelsLock.EnterWriteLock(token))
                _intCachedHasAnyQualitiesWithQualityLevels = int.MinValue;
        }

        public async Task RequestQualityLevelsReprocessingAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await _objCachedHasAnyQualitiesWithQualityLevelsLock.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                _intCachedHasAnyQualitiesWithQualityLevels = int.MinValue;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Process quality levels from Life Modules and add the highest level quality for each group. Return value is if any qualities were created this way.
        /// This method should be called when the character is finalized.
        /// </summary>
        public bool ProcessQualityLevels(CancellationToken token = default)
        {
            return Utils.SafelyRunSynchronously(() => ProcessQualityLevelsCoreAsync(true, token), token);
        }

        /// <summary>
        /// Process quality levels from Life Modules and add the highest level quality for each group. Return value is if any qualities were created this way.
        /// This method should be called when the character is finalized.
        /// </summary>
        public Task<bool> ProcessQualityLevelsAsync(CancellationToken token = default)
        {
            return ProcessQualityLevelsCoreAsync(false, token);
        }

        private async Task<bool> ProcessQualityLevelsCoreAsync(bool blnSync, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IDisposable objLocker = null;
            IAsyncDisposable objLockerAsync = null;
            if (blnSync)
                objLocker = LockObject.EnterUpgradeableReadLock(token);
            else
                objLockerAsync = await LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                // Get all quality level improvements and group them by quality group
                Dictionary<string, ValueTuple<List<Improvement>, List<Quality>>> dicQualityGroups = new Dictionary<string, ValueTuple<List<Improvement>, List<Quality>>>();
                if (blnSync)
                {
                    foreach (Improvement objImprovement in Improvements)
                    {
                        if (objImprovement.ImproveType == Improvement.ImprovementType.QualityLevel && objImprovement.Enabled)
                        {
                            string strKey = objImprovement.ImprovedName;
                            List<Improvement> lstImprovements;
                            if (dicQualityGroups.TryGetValue(strKey, out ValueTuple<List<Improvement>, List<Quality>> tupLists))
                            {
                                lstImprovements = tupLists.Item1;
                            }
                            else
                            {
                                lstImprovements = new List<Improvement>(1) { objImprovement };
                                dicQualityGroups.Add(strKey, new ValueTuple<List<Improvement>, List<Quality>>(lstImprovements, new List<Quality>(1)));
                            }
                            lstImprovements.Add(objImprovement);
                        }
                    }
                }
                else
                {
                    await (await GetImprovementsAsync(token).ConfigureAwait(false)).ForEachAsync(objImprovement =>
                    {
                        if (objImprovement.ImproveType == Improvement.ImprovementType.QualityLevel && objImprovement.Enabled)
                        {
                            string strKey = objImprovement.ImprovedName;
                            List<Improvement> lstImprovements;
                            if (dicQualityGroups.TryGetValue(strKey, out ValueTuple<List<Improvement>, List<Quality>> tupLists))
                            {
                                lstImprovements = tupLists.Item1;
                            }
                            else
                            {
                                lstImprovements = new List<Improvement>(1) { objImprovement };
                                dicQualityGroups.Add(strKey, new ValueTuple<List<Improvement>, List<Quality>>(lstImprovements, new List<Quality>(1)));
                            }
                            lstImprovements.Add(objImprovement);
                        }
                    }, token).ConfigureAwait(false);
                }

                // Get all qualities with levels in their name and group them by the same group scheme
                Dictionary<string, List<Quality>> dicQualitiesGrouped = new Dictionary<string, List<Quality>>();
                if (blnSync)
                {
                    foreach (Quality objQuality in Qualities)
                    {
                        string strName = objQuality.Name;
                        int intLoopIndex = strName.IndexOf(" (", StringComparison.Ordinal);
                        if (intLoopIndex >= 0)
                        {
                            string strGroup = strName.Substring(0, intLoopIndex);
                            if (!dicQualitiesGrouped.TryGetValue(strGroup, out List<Quality> lstQualities))
                            {
                                lstQualities = new List<Quality>(1) { objQuality };
                                dicQualitiesGrouped.Add(strGroup, lstQualities);
                            }
                            lstQualities.Add(objQuality);
                        }
                    }
                }
                else
                {
                    await (await GetQualitiesAsync(token).ConfigureAwait(false)).ForEachAsync(async objQuality =>
                    {
                        string strName = await objQuality.GetNameAsync(token).ConfigureAwait(false);
                        int intLoopIndex = strName.IndexOf(" (", StringComparison.Ordinal);
                        if (intLoopIndex >= 0)
                        {
                            string strGroup = strName.Substring(0, intLoopIndex);
                            if (!dicQualitiesGrouped.TryGetValue(strGroup, out List<Quality> lstQualities))
                            {
                                lstQualities = new List<Quality>(1) { objQuality };
                                dicQualitiesGrouped.Add(strGroup, lstQualities);
                            }
                            lstQualities.Add(objQuality);
                        }
                    }, token).ConfigureAwait(false);
                }

                // Tie the two dictionaries together and delete all quality level-given qualities that no longer have an associated group
                foreach (KeyValuePair<string, List<Quality>> kvpQualities in dicQualitiesGrouped)
                {
                    string strGroup = kvpQualities.Key;
                    if (dicQualityGroups.TryGetValue(strGroup, out ValueTuple<List<Improvement>, List<Quality>> tupLists))
                    {
                        tupLists.Item2.AddRange(kvpQualities.Value);
                    }
                    else if (blnSync)
                    {
                        foreach (Quality objQuality in kvpQualities.Value)
                        {
                            if (objQuality.OriginSource == QualitySource.QualityLevelImprovement)
                                objQuality.DeleteQuality(token: token);
                        }
                    }
                    else
                    {
                        foreach (Quality objQuality in kvpQualities.Value)
                        {
                            if (await objQuality.GetOriginSourceAsync(token).ConfigureAwait(false) == QualitySource.QualityLevelImprovement)
                                await objQuality.DeleteQualityAsync(token: token).ConfigureAwait(false);
                        }
                    }
                }

                // Make sure we have at least one quality that calls for processing
                if (dicQualityGroups.Count == 0 || dicQualityGroups.All(x => x.Value.Item2.Count == 0))
                    return false;

                // Load quality level configuration
                XPathNavigator objXmlQualityLevels = blnSync
                    ? LoadDataXPath("qualitylevels.xml", token: token)
                    : await LoadDataXPathAsync("qualitylevels.xml", token: token).ConfigureAwait(false);
                if (objXmlQualityLevels == null)
                    return false;

                XmlDocument objXmlQualityDocument = blnSync
                    ? LoadData("qualities.xml", token: token)
                    : await LoadDataAsync("qualities.xml", token: token).ConfigureAwait(false);

                if (objXmlQualityDocument == null)
                    return false;

                bool blnReturn = false;

                Dictionary<string, string> dicQualityGroupText = new Dictionary<string, string>();

                IDisposable objLocker2 = null;
                IAsyncDisposable objLockerAsync2 = null;
                if (blnSync)
                    objLocker2 = LockObject.EnterWriteLock(token);
                else
                    objLockerAsync2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    foreach (KeyValuePair<string, ValueTuple<List<Improvement>, List<Quality>>> kvp in dicQualityGroups)
                    {
                        token.ThrowIfCancellationRequested();
                        string strGroup = kvp.Key;
                        (List<Improvement> lstGroupImprovements, List<Quality> lstGroupQualities) = kvp.Value;

                        // Get the quality name for this level from the configuration
                        XPathNavigator objXmlGroupNode = objXmlQualityLevels.SelectSingleNodeAndCacheExpression(
                            "/chummer/qualitygroups/qualitygroup[name = \"" + strGroup + "\"]", token);

                        if (objXmlGroupNode == null)
                            continue;

                        // Find the highest level for this group
                        int intHighestLevel = lstGroupImprovements.Max(x => x.Value.ToInt32());

                        XPathNavigator objXmlLevelNode = objXmlGroupNode.SelectSingleNodeAndCacheExpression(
                            "levels/level[@value = \"" + intHighestLevel.ToString(GlobalSettings.InvariantCultureInfo) + "\"]", token);

                        if (objXmlLevelNode == null)
                            continue;

                        // Determine what level the existing qualities are at
                        int intExistingLevel = -1;
                        if (lstGroupQualities.Count > 0)
                        {
                            // Find the level of existing qualities by checking against the configuration
                            foreach (Quality objExistingQuality in lstGroupQualities)
                            {
                                for (int i = 1; i <= 10; i++) // Check levels 1-10
                                {
                                    XPathNavigator objXmlExistingLevelNode = objXmlGroupNode.SelectSingleNodeAndCacheExpression(
                                        "levels/level[@value = \"" + i.ToString(GlobalSettings.InvariantCultureInfo) + "\"]", token);
                                    if (objXmlExistingLevelNode != null && objXmlExistingLevelNode.Value == objExistingQuality.Name)
                                    {
                                        intExistingLevel = Math.Max(intExistingLevel, i);
                                        break;
                                    }
                                }
                            }
                        }

                        // Check if we need to change anything
                        if (intExistingLevel == intHighestLevel
                            // Same level but multiple instances - need to resolve conflicts
                            && lstGroupQualities.Count < 2)
                            continue;

                        // Handle the change
                        if (intExistingLevel != intHighestLevel)
                        {
                            // Level change - remove all existing qualities and add the new one
                            foreach (Quality objQualityToRemove in lstGroupQualities)
                            {
                                token.ThrowIfCancellationRequested();
                                // Store the instance text before removing
                                string strExtra = blnSync ? objQualityToRemove.Extra : await objQualityToRemove.GetExtraAsync(token).ConfigureAwait(false);
                                if (!string.IsNullOrEmpty(strExtra))
                                {
                                    StoreQualityInstance(strGroup, intExistingLevel, strExtra);
                                }
                                if (blnSync)
                                    objQualityToRemove.DeleteQuality(token: token);
                                else
                                    await objQualityToRemove.DeleteQualityAsync(token: token).ConfigureAwait(false);
                            }

                            // Clear stored text for this group since we're changing levels
                            dicQualityGroupText.Remove(strGroup);
                        }
                        else if (lstGroupQualities.Count > 1)
                        {
                            // Same level but multiple instances - need to resolve conflicts
                            // Store all existing instances
                            foreach (Quality objExistingQuality in lstGroupQualities)
                            {
                                string strExtra = blnSync ? objExistingQuality.Extra : await objExistingQuality.GetExtraAsync(token).ConfigureAwait(false);
                                if (!string.IsNullOrEmpty(strExtra))
                                {
                                    StoreQualityInstance(strGroup, intExistingLevel, strExtra);
                                }
                            }

                            // Remove all existing qualities
                            if (blnSync)
                            {
                                foreach (Quality objQualityToRemove in lstGroupQualities)
                                {
                                    objQualityToRemove.DeleteQuality(token: token);
                                }
                            }
                            else
                            {
                                foreach (Quality objQualityToRemove in lstGroupQualities)
                                {
                                    await objQualityToRemove.DeleteQualityAsync(token: token).ConfigureAwait(false);
                                }
                            }
                        }

                        string strQualityName = objXmlLevelNode.Value;

                        // Add the new quality
                        XmlNode objXmlQuality = objXmlQualityDocument.SelectSingleNode(
                            "/chummer/qualities/quality[name = \"" + strQualityName + "\"]");

                        if (objXmlQuality != null)
                        {
                            // Check if we have multiple instances for this level
                            List<string> lstInstances = GetQualityInstances(strGroup, intHighestLevel);

                            if (lstInstances.Count > 1)
                            {
                                // Multiple instances available - prompt user to choose
                                using (ThreadSafeForm<SelectItem> frmSelectItem = blnSync
                                    ? ThreadSafeForm<SelectItem>.Get(() => new SelectItem())
                                    : await ThreadSafeForm<SelectItem>.GetAsync(() => new SelectItem(), token).ConfigureAwait(false))
                                {
                                    frmSelectItem.MyForm.SetGeneralItemsMode(lstInstances.Select(x => new ListItem(x, x)));
                                    DialogResult eResult = blnSync
                                        ? frmSelectItem.ShowDialogSafe(this, token)
                                        : await frmSelectItem.ShowDialogSafeAsync(this, token).ConfigureAwait(false);
                                    if (eResult == DialogResult.OK)
                                    {
                                        string strSelectedText = frmSelectItem.MyForm.SelectedItem;
                                        if (!string.IsNullOrEmpty(strSelectedText))
                                        {
                                            PushText.Push(strSelectedText);
                                        }
                                    }
                                }
                            }
                            else if (lstInstances.Count == 1)
                            {
                                // Single instance available - use it automatically
                                PushText.Push(lstInstances[0]);
                            }
                            else
                            {
                                // No instances available - try quality group-specific text
                                if (!TryPopTextForQualityGroup(strGroup, out string strGroupText))
                                {
                                    // Fall back to stored text for this quality group if available
                                    if (dicQualityGroupText.TryGetValue(strGroup, out string strStoredText) && !string.IsNullOrEmpty(strStoredText))
                                    {
                                        PushText.Push(strStoredText);
                                    }
                                }
                                else
                                {
                                    // Use the text from the quality group stack
                                    PushText.Push(strGroupText);
                                }
                            }

                            Quality objQuality = new Quality(this);
                            List<Weapon> lstWeapons = new List<Weapon>();
                            if (blnSync)
                            {
                                objQuality.Create(objXmlQuality, QualitySource.QualityLevelImprovement, lstWeapons, token: token);
                                Qualities.Add(objQuality);
                                // Add any weapons that were created
                                foreach (Weapon objWeapon in lstWeapons)
                                {
                                    Weapons.Add(objWeapon);
                                }
                            }
                            else
                            {
                                await objQuality.CreateAsync(objXmlQuality, QualitySource.QualityLevelImprovement, lstWeapons, token: token).ConfigureAwait(false);
                                await (await GetQualitiesAsync(token).ConfigureAwait(false)).AddAsync(objQuality, token).ConfigureAwait(false);
                                // Add any weapons that were created
                                foreach (Weapon objWeapon in lstWeapons)
                                {
                                    await (await GetWeaponsAsync(token).ConfigureAwait(false)).AddAsync(objWeapon, token).ConfigureAwait(false);
                                }
                            }

                            // Store the text that was used for this quality group
                            if (objQuality.Extra != null && !string.IsNullOrEmpty(objQuality.Extra))
                            {
                                dicQualityGroupText[strGroup] = objQuality.Extra;
                            }

                            blnReturn = true;
                        }
                    }

                    return blnReturn;
                }
                finally
                {
                    if (blnSync)
                        objLocker2.Dispose();
                    else
                        await objLockerAsync2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                if (blnSync)
                    objLocker.Dispose();
                else
                    await objLockerAsync.DisposeAsync().ConfigureAwait(false);
            }
        }

        #endregion Quality Level Processing
    }
}
