/*  This file is part of Chummer5a.
 *
 *  Chummer5a is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  Chummer5a is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with Chummer5a.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  You can obtain the full source code for Chummer5a at
 *  https://github.com/chummer5a/chummer5a
 */
using Chummer.Annotations;
using Chummer.Backend.Attributes;
using Chummer.Backend.Equipment;
using Chummer.Backend.Skills;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Xml;
using System.Xml.XPath;
using Chummer.Backend.Uniques;
using System.Xml.Serialization;
using System.Runtime.Serialization;
using System.Threading;
using Chummer.Plugins;
using Microsoft.ApplicationInsights;
using Newtonsoft.Json;
using NLog;
using Application = System.Windows.Forms.Application;
using Formatting = System.Xml.Formatting;

namespace Chummer
{
    /// <summary>
    /// Class that holds all of the information that makes up a complete Character.
    /// </summary>
    [DebuggerDisplay("{CharacterName} ({FileName})")]
    public sealed class Character : INotifyMultiplePropertyChanged, IHasMugshots, IHasName, IHasSource, IHasXmlDataNode
    {
        private static readonly TelemetryClient TelemetryClient = new TelemetryClient();
        private static Logger Log { get; } = LogManager.GetCurrentClassLogger();
        private XmlNode _oldSkillsBackup;
        private XmlNode _oldSkillGroupBackup;
        private string _strFileName = string.Empty;
        private string _strSettingsKey = GlobalSettings.DefaultCharacterSetting;
        private DateTime _dateFileLastWriteTime = DateTime.MinValue;
        private bool _blnIgnoreRules;
        private int _intKarma;
        private int _intTotalKarma;
        private int _intStreetCred;
        private int _intNotoriety;
        private int _intPublicAwareness;
        private int _intBurntStreetCred;
        private decimal _decNuyen;
        private decimal _decStolenNuyen;
        private decimal _decStartingNuyen;
        private decimal _decEssenceAtSpecialStart = decimal.MinValue;
        private int _intSpecial;
        private int _intTotalSpecial;
        private int _intAttributes;
        private int _intTotalAttributes;
        private int _intFreeSpells;
        private int _intCFPLimit;
        private int _intAINormalProgramLimit;
        private int _intAIAdvancedProgramLimit;
        private int _intCachedContactPoints = int.MinValue;
        private int _intContactPointsUsed;
        private int _intCachedRedlinerBonus = int.MinValue;
        private int _intCurrentCounterspellingDice;
        private int _intEdgeUsed;
        private int _intBoundSpiritLimit = int.MinValue;
        private int _intRegisteredSpriteLimit = int.MinValue;

        // General character info.
        private string _strName = string.Empty;
        private readonly List<Image> _lstMugshots = new List<Image>(1);
        private int _intMainMugshotIndex = -1;
        private string _strGender = string.Empty;
        private string _strAge = string.Empty;
        private string _strEyes = string.Empty;
        private string _strHeight = string.Empty;
        private string _strWeight = string.Empty;
        private string _strSkin = string.Empty;
        private string _strHair = string.Empty;
        private string _strDescription = string.Empty;
        private string _strBackground = string.Empty;
        private string _strConcept = string.Empty;
        private string _strNotes = string.Empty;
        private string _strAlias = string.Empty;
        private string _strPlayerName = string.Empty;
        private string _strGameNotes = string.Empty;
        private string _strPrimaryArm = "Right";

        public static readonly ReadOnlyCollection<string> LimbStrings = Array.AsReadOnly(new[]
            {"skull", "torso", "arm", "leg"});

        // AI Home Node

        // Active Commlink

        // If true, the Character creation has been finalized and is maintained through Karma.
        private bool _blnCreated;

        // Build Points
        private decimal _decNuyenBP;

        // Metatype Information.
        private string _strMetatype = "Human";
        private Guid _guiMetatype = Guid.Empty;
        private string _strMetavariant = string.Empty;
        private Guid _guiMetavariant = Guid.Empty;
        private string _strMetatypeCategory = "Metahuman";
        private string _strMovement = string.Empty;
        private string _strWalk = string.Empty;
        private string _strRun = string.Empty;
        private string _strSprint = string.Empty;
        private string _strWalkAlt = string.Empty;
        private string _strRunAlt = string.Empty;
        private string _strSprintAlt = string.Empty;
        private int _intMetatypeBP;
        private string _strSource;
        private string _strPage;
        private int _intInitiativeDice = 1;

        // Special Flags.

        private bool _blnAdeptEnabled;
        private bool _blnMagicianEnabled;
        private bool _blnTechnomancerEnabled;
        private bool _blnAdvancedProgramsEnabled;
        private bool _blnCyberwareDisabled;
        private bool _blnInitiationDisabled;
        private bool _blnCritterEnabled;
        private bool _blnIsCritter;
        private bool _blnPossessed;
        private decimal _decPrototypeTranshuman;
        private bool _blnMAGEnabled;
        private bool _blnRESEnabled;
        private bool _blnDEPEnabled;
        private bool _blnGroupMember;
        private string _strGroupName = string.Empty;
        private string _strGroupNotes = string.Empty;
        private int _intInitiateGrade;
        private int _intSubmersionGrade;
        private bool _blnPsycheActive;

        // Pseudo-Attributes use for Mystic Adepts.
        private int _intMAGMagician;
        private int _intMAGAdept;

        // Magic Tradition.
        private Tradition _objTradition;

        // Condition Monitor Progress.
        private int _intPhysicalCMFilled;
        private int _intStunCMFilled;

        // Spirit Reputation
        private int _intBaseAstralReputation;
        private int _intBaseWildReputation;

        // Priority Selections.
        private string _strPriorityMetatype = "A";
        private string _strPriorityAttributes = "B";
        private string _strPrioritySpecial = "C";
        private string _strPrioritySkills = "D";
        private string _strPriorityResources = "E";
        private string _strPriorityTalent = string.Empty;
        private readonly List<string> _lstPrioritySkills = new List<string>(3);

        // Lists.
        private readonly EnhancedObservableCollection<Improvement> _lstImprovements = new EnhancedObservableCollection<Improvement>();

        private readonly EnhancedObservableCollection<MentorSpirit>
            _lstMentorSpirits = new EnhancedObservableCollection<MentorSpirit>();

        private readonly EnhancedObservableCollection<Contact> _lstContacts = new EnhancedObservableCollection<Contact>();
        private readonly EnhancedObservableCollection<Spirit> _lstSpirits = new EnhancedObservableCollection<Spirit>();
        private readonly EnhancedObservableCollection<Spell> _lstSpells = new EnhancedObservableCollection<Spell>();

        private readonly EnhancedObservableCollection<SustainedObject> _lstSustainedObjects = new EnhancedObservableCollection<SustainedObject>();

        private readonly List<Focus> _lstFoci = new List<Focus>(5);
        private readonly List<StackedFocus> _lstStackedFoci = new List<StackedFocus>(5);
        private readonly CachedBindingList<Power> _lstPowers = new CachedBindingList<Power>();
        private readonly EnhancedObservableCollection<ComplexForm> _lstComplexForms = new EnhancedObservableCollection<ComplexForm>();
        private readonly EnhancedObservableCollection<AIProgram> _lstAIPrograms = new EnhancedObservableCollection<AIProgram>();
        private readonly EnhancedObservableCollection<MartialArt> _lstMartialArts = new EnhancedObservableCollection<MartialArt>();

        private readonly EnhancedObservableCollection<LimitModifier> _lstLimitModifiers =
            new EnhancedObservableCollection<LimitModifier>();

        private readonly EnhancedObservableCollection<Armor> _lstArmor = new EnhancedObservableCollection<Armor>();

        private readonly EnhancedObservableCollection<Cyberware> _lstCyberware = new EnhancedObservableCollection<Cyberware>();

        private readonly EnhancedObservableCollection<Weapon> _lstWeapons = new EnhancedObservableCollection<Weapon>();
        private readonly EnhancedObservableCollection<Quality> _lstQualities = new EnhancedObservableCollection<Quality>();
        private readonly EnhancedObservableCollection<Lifestyle> _lstLifestyles = new EnhancedObservableCollection<Lifestyle>();
        private readonly EnhancedObservableCollection<Gear> _lstGear = new EnhancedObservableCollection<Gear>();
        private readonly EnhancedObservableCollection<Vehicle> _lstVehicles = new EnhancedObservableCollection<Vehicle>();
        private readonly EnhancedObservableCollection<Metamagic> _lstMetamagics = new EnhancedObservableCollection<Metamagic>();
        private readonly EnhancedObservableCollection<Art> _lstArts = new EnhancedObservableCollection<Art>();
        private readonly EnhancedObservableCollection<Enhancement> _lstEnhancements = new EnhancedObservableCollection<Enhancement>();

        private readonly EnhancedObservableCollection<ExpenseLogEntry> _lstExpenseLog =
            new EnhancedObservableCollection<ExpenseLogEntry>();

        private readonly EnhancedObservableCollection<CritterPower>
            _lstCritterPowers = new EnhancedObservableCollection<CritterPower>();

        private readonly EnhancedObservableCollection<InitiationGrade> _lstInitiationGrades =
            new EnhancedObservableCollection<InitiationGrade>();

        private readonly EnhancedObservableCollection<Location> _lstGearLocations = new EnhancedObservableCollection<Location>();
        private readonly EnhancedObservableCollection<Location> _lstArmorLocations = new EnhancedObservableCollection<Location>();

        private readonly EnhancedObservableCollection<Location> _lstVehicleLocations = new EnhancedObservableCollection<Location>();

        private readonly EnhancedObservableCollection<Location> _lstWeaponLocations = new EnhancedObservableCollection<Location>();
        private readonly EnhancedObservableCollection<string> _lstImprovementGroups = new EnhancedObservableCollection<string>();
        private readonly BindingList<CalendarWeek> _lstCalendar = new BindingList<CalendarWeek>();

        private readonly EnhancedObservableCollection<Drug> _lstDrugs = new EnhancedObservableCollection<Drug>();

        //private readonly List<LifeModule> _lstLifeModules = new List<LifeModule>(10);
        private readonly List<string> _lstInternalIdsNeedingReapplyImprovements = new List<string>(1);

        // Character Version
        private string _strVersionCreated = Application.ProductVersion.FastEscapeOnceFromStart("0.0.");
        private Version _verSavedVersion = new Version();

        /// <summary>
        /// Set of unique methods to run after the character's Save() method is otherwise finished.
        /// Input is the character in question, output is if the code resolved without errors.
        /// </summary>
        [JsonIgnore]
        [XmlIgnore]
        [IgnoreDataMember]
        public LockingOrderedSet<Func<Character, bool>> DoOnSaveCompleted { get; } = new LockingOrderedSet<Func<Character, bool>>();

        #region Initialization, Save, Load, Print, and Reset Methods

        /// <summary>
        /// Character.
        /// </summary>
        public Character()
        {
            if (Utils.IsDesignerMode || Utils.IsRunningInVisualStudio)
                _objSettings = new CharacterSettings(); // Need this because ExpenseCharts is WPF and needs a Character in design mode.
            else if (!SettingsManager.LoadedCharacterSettings.TryGetValue(GlobalSettings.DefaultCharacterSetting, out _objSettings)
                     && !SettingsManager.LoadedCharacterSettings.TryGetValue(GlobalSettings.DefaultCharacterSettingDefaultValue, out _objSettings))
                _objSettings = SettingsManager.LoadedCharacterSettings.Values.First();

            Settings.PropertyChanged += OptionsOnPropertyChanged;
            AttributeSection = new AttributeSection(this);
            AttributeSection.Reset(true);
            AttributeSection.PropertyChanged += AttributeSectionOnPropertyChanged;

            SkillsSection = new SkillsSection(this);
            SkillsSection.Reset();

            _lstCyberware.CollectionChanged += CyberwareOnCollectionChanged;
            _lstArmor.CollectionChanged += ArmorOnCollectionChanged;
            _lstContacts.CollectionChanged += ContactsOnCollectionChanged;
            _lstExpenseLog.CollectionChanged += ExpenseLogOnCollectionChanged;
            _lstMentorSpirits.CollectionChanged += MentorSpiritsOnCollectionChanged;
            _lstPowers.ListChanged += PowersOnListChanged;
            _lstPowers.BeforeRemove += PowersOnBeforeRemove;
            _lstQualities.CollectionChanged += QualitiesCollectionChanged;
            _lstMartialArts.CollectionChanged += MartialArtsOnCollectionChanged;
            _lstMetamagics.CollectionChanged += MetamagicsOnCollectionChanged;
            _lstSpells.CollectionChanged += SpellsOnCollectionChanged;
            _lstSpells.BeforeClearCollectionChanged += SpellsOnBeforeClearCollectionChanged;
            _lstSpells.CollectionChanged += SustainableOnCollectionChanged;
            _lstComplexForms.CollectionChanged += SustainableOnCollectionChanged;
            _lstCritterPowers.CollectionChanged += SustainableOnCollectionChanged;
            _lstSustainedObjects.CollectionChanged += SustainedObjectsOnCollectionChanged;
            _lstInitiationGrades.CollectionChanged += InitiationGradesOnCollectionChanged;
            _lstLifestyles.CollectionChanged += LifestylesOnCollectionChanged;
            _lstLifestyles.BeforeClearCollectionChanged += LifestylesOnBeforeClearCollectionChanged;
            _objTradition = new Tradition(this);
        }

        private void LifestylesOnBeforeClearCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (IsLoading)
                return;
            foreach (Lifestyle objLifestyle in e.OldItems)
                objLifestyle.Dispose();
        }

        private void LifestylesOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (IsLoading)
                return;
            switch (e.Action)
            {
                case NotifyCollectionChangedAction.Remove:
                    foreach (Lifestyle objLifestyle in e.OldItems)
                        objLifestyle.Dispose();
                    break;
                case NotifyCollectionChangedAction.Replace:
                    List<Lifestyle> lstNewLifestyles = e.NewItems.OfType<Lifestyle>().ToList();
                    foreach (Lifestyle objLifestyle in e.OldItems)
                    {
                        if (!lstNewLifestyles.Contains(objLifestyle))
                            objLifestyle.Dispose();
                    }
                    break;
            }
        }

        private void SpellsOnBeforeClearCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (IsLoading)
                return;
            foreach (Spell objSpell in e.OldItems)
                objSpell.Dispose();
        }

        private void SpellsOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (IsLoading)
                return;
            switch (e.Action)
            {
                case NotifyCollectionChangedAction.Remove:
                    foreach (Spell objSpell in e.OldItems)
                        objSpell.Dispose();
                    break;
                case NotifyCollectionChangedAction.Replace:
                    List<Spell> lstNewSpells = e.NewItems.OfType<Spell>().ToList();
                    foreach (Spell objSpell in e.OldItems)
                    {
                        if (!lstNewSpells.Contains(objSpell))
                            objSpell.Dispose();
                    }
                    break;
            }
        }

        private bool _blnClearingInitiations;
        private void InitiationGradesOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (_blnClearingInitiations || IsLoading)
                return;
            switch (e.Action)
            {
                case NotifyCollectionChangedAction.Add:
                {
                    int intAddSubmersion = 0;
                    int intAddInitiation = 0;

                    foreach (InitiationGrade objItem in e.NewItems)
                    {
                        if (objItem.Technomancer)
                            ++intAddSubmersion;
                        else
                            ++intAddInitiation;
                    }

                    SubmersionGrade += intAddSubmersion;
                    InitiateGrade += intAddInitiation;
                    break;
                }
                case NotifyCollectionChangedAction.Remove:
                {
                    int intRemoveSubmersion = 0;
                    int intRemoveInitiation = 0;

                    foreach (InitiationGrade objItem in e.OldItems)
                    {
                        if (objItem.Technomancer)
                            ++intRemoveSubmersion;
                        else
                            ++intRemoveInitiation;
                    }

                    if (SubmersionGrade < intRemoveSubmersion)
                        SubmersionGrade = 0;
                    else
                        SubmersionGrade -= intRemoveSubmersion;
                    if (InitiateGrade < intRemoveInitiation)
                        InitiateGrade = 0;
                    else
                        InitiateGrade -= intRemoveInitiation;
                    break;
                }
                case NotifyCollectionChangedAction.Replace:
                {
                    int intAddSubmersion = 0;
                    int intAddInitiation = 0;

                    foreach (InitiationGrade objItem in e.OldItems)
                    {
                        if (objItem.Technomancer)
                            --intAddSubmersion;
                        else
                            --intAddInitiation;
                    }

                    foreach (InitiationGrade objItem in e.NewItems)
                    {
                        if (objItem.Technomancer)
                            ++intAddSubmersion;
                        else
                            ++intAddInitiation;
                    }

                    if (SubmersionGrade + intAddSubmersion < 0)
                        SubmersionGrade = 0;
                    else
                        SubmersionGrade += intAddSubmersion;
                    if (InitiateGrade + intAddInitiation < 0)
                        InitiateGrade = 0;
                    else
                        InitiateGrade += intAddInitiation;
                    break;
                }
                case NotifyCollectionChangedAction.Move:
                    return;
                case NotifyCollectionChangedAction.Reset:
                {
                    int intSubmersion = 0;
                    int intInitiation = 0;

                    foreach (InitiationGrade objItem in InitiationGrades)
                    {
                        if (objItem.Technomancer)
                            ++intSubmersion;
                        else
                            ++intInitiation;
                    }

                    SubmersionGrade = intSubmersion;
                    InitiateGrade = intInitiation;
                    break;
                }
            }
        }

        private void SustainableOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (SustainedCollection.Count == 0)
                return;
            switch (e.Action)
            {
                case NotifyCollectionChangedAction.Add:
                    break;
                case NotifyCollectionChangedAction.Remove:
                    foreach (IHasInternalId objItem in e.OldItems)
                    {
                        SustainedCollection.RemoveAll(x => ReferenceEquals(x.LinkedObject, objItem));
                    }
                    break;
                case NotifyCollectionChangedAction.Replace:
                    foreach (IHasInternalId objItem in e.OldItems)
                    {
                        SustainedCollection.RemoveAll(x => ReferenceEquals(x.LinkedObject, objItem));
                    }
                    break;
                case NotifyCollectionChangedAction.Move:
                    break;
                case NotifyCollectionChangedAction.Reset:
                    SustainedCollection.RemoveAll(x =>
                        !Spells.Contains(x.LinkedObject) && !ComplexForms.Contains(x.LinkedObject) &&
                        !CritterPowers.Contains(x.LinkedObject));
                    break;
            }
        }

        public XmlNode GetNode(string strLanguage)
        {
            return GetNode(false, strLanguage);
        }

        public XmlNode GetNode(bool blnReturnMetatypeOnly, string strLanguage = "")
        {
            XmlDocument xmlDoc = LoadData(IsCritter ? "critters.xml" : "metatypes.xml", strLanguage);
            XmlNode xmlMetatypeNode = xmlDoc.SelectSingleNode(MetatypeGuid == Guid.Empty
                                                                  ? "/chummer/metatypes/metatype[name = "
                                                                    + Metatype.CleanXPath() + ']'
                                                                  : "/chummer/metatypes/metatype[id = " +
                                                                    MetatypeGuid
                                                                        .ToString(
                                                                            "D", GlobalSettings.InvariantCultureInfo)
                                                                        .CleanXPath() + ']');
            if (blnReturnMetatypeOnly)
                return xmlMetatypeNode;
            if (MetavariantGuid == Guid.Empty || string.IsNullOrEmpty(Metavariant) || xmlMetatypeNode == null)
                return xmlMetatypeNode;
            XmlNode xmlMetavariantNode = xmlMetatypeNode.SelectSingleNode(MetavariantGuid == Guid.Empty
                                                                              ? "metavariants/metavariant[name = "
                                                                              + Metavariant.CleanXPath() + ']'
                                                                              : "metavariants/metavariant[id = " +
                                                                              MetavariantGuid
                                                                                  .ToString(
                                                                                      "D",
                                                                                      GlobalSettings
                                                                                          .InvariantCultureInfo)
                                                                                  .CleanXPath() + ']');
            if (xmlMetavariantNode == null && MetavariantGuid != Guid.Empty)
            {
                xmlMetavariantNode =
                    xmlMetatypeNode.SelectSingleNode("metavariants/metavariant[name = " + Metavariant.CleanXPath() +
                                                     ']');
            }
            return xmlMetavariantNode ?? xmlMetatypeNode;
        }

        public XPathNavigator GetNodeXPath(string strLanguage)
        {
            return GetNodeXPath(false, strLanguage);
        }

        public XPathNavigator GetNodeXPath(bool blnReturnMetatypeOnly, string strLanguage = "")
        {
            XPathNavigator xmlDoc = LoadDataXPath(IsCritter ? "critters.xml" : "metatypes.xml", strLanguage);
            XPathNavigator xmlMetatypeNode = xmlDoc.SelectSingleNode(MetatypeGuid == Guid.Empty
                ? "/chummer/metatypes/metatype[name = " + Metatype.CleanXPath() + ']'
                : "/chummer/metatypes/metatype[id = " +
                  MetatypeGuid.ToString("D", GlobalSettings.InvariantCultureInfo).CleanXPath() + ']');
            if (blnReturnMetatypeOnly)
                return xmlMetatypeNode;
            if (MetavariantGuid == Guid.Empty || string.IsNullOrEmpty(Metavariant) || xmlMetatypeNode == null)
                return xmlMetatypeNode;
            XPathNavigator xmlMetavariantNode = xmlMetatypeNode.SelectSingleNode(MetavariantGuid == Guid.Empty
                ? "metavariants/metavariant[name = " + Metavariant.CleanXPath() + ']'
                : "metavariants/metavariant[id = " +
                  MetavariantGuid.ToString("D", GlobalSettings.InvariantCultureInfo).CleanXPath() + ']');
            if (xmlMetavariantNode == null && MetavariantGuid != Guid.Empty)
            {
                xmlMetavariantNode =
                    xmlMetatypeNode.SelectSingleNode("metavariants/metavariant[name = " + Metavariant.CleanXPath() +
                                                     ']');
            }
            return xmlMetavariantNode ?? xmlMetatypeNode;
        }

        public void RefreshAttributeBindings()
        {
            // First remove all existing bindings
            foreach (CharacterAttrib objAttribute in AttributeSection.Attributes)
            {
                switch (objAttribute.Abbrev)
                {
                    case "BOD":
                        objAttribute.PropertyChanged -= RefreshBODDependentProperties;
                        break;
                    case "AGI":
                        objAttribute.PropertyChanged -= RefreshAGIDependentProperties;
                        break;
                    case "REA":
                        objAttribute.PropertyChanged -= RefreshREADependentProperties;
                        break;
                    case "STR":
                        objAttribute.PropertyChanged -= RefreshSTRDependentProperties;
                        break;
                    case "CHA":
                        objAttribute.PropertyChanged -= RefreshCHADependentProperties;
                        break;
                    case "INT":
                        objAttribute.PropertyChanged -= RefreshINTDependentProperties;
                        break;
                    case "LOG":
                        objAttribute.PropertyChanged -= RefreshLOGDependentProperties;
                        break;
                    case "WIL":
                        objAttribute.PropertyChanged -= RefreshWILDependentProperties;
                        break;
                    case "EDG":
                        objAttribute.PropertyChanged -= RefreshEDGDependentProperties;
                        break;
                    case "MAG":
                        objAttribute.PropertyChanged -= RefreshMAGDependentProperties;
                        break;
                    case "MAGAdept":
                        objAttribute.PropertyChanged -= RefreshMAGAdeptDependentProperties;
                        break;
                    case "RES":
                        objAttribute.PropertyChanged -= RefreshRESDependentProperties;
                        break;
                    case "DEP":
                        objAttribute.PropertyChanged -= RefreshDEPDependentProperties;
                        break;
                    case "ESS":
                        objAttribute.PropertyChanged -= RefreshESSDependentProperties;
                        break;
                }
            }
            BOD.PropertyChanged += RefreshBODDependentProperties;
            AGI.PropertyChanged += RefreshAGIDependentProperties;
            REA.PropertyChanged += RefreshREADependentProperties;
            STR.PropertyChanged += RefreshSTRDependentProperties;
            CHA.PropertyChanged += RefreshCHADependentProperties;
            INT.PropertyChanged += RefreshINTDependentProperties;
            LOG.PropertyChanged += RefreshLOGDependentProperties;
            WIL.PropertyChanged += RefreshWILDependentProperties;
            EDG.PropertyChanged += RefreshEDGDependentProperties;
            MAG.PropertyChanged += RefreshMAGDependentProperties;
            RES.PropertyChanged += RefreshRESDependentProperties;
            DEP.PropertyChanged += RefreshDEPDependentProperties;
            ESS.PropertyChanged += RefreshESSDependentProperties;
            // This needs to be explicitly set because a MAGAdept call could redirect to MAG, and we don't want that
            AttributeSection.GetAttributeByName("MAGAdept").PropertyChanged += RefreshMAGAdeptDependentProperties;
        }

        private void OptionsOnPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterSettings.UseCalculatedPublicAwareness):
                    OnPropertyChanged(nameof(CalculatedPublicAwareness));
                    break;
                case nameof(CharacterSettings.SpiritForceBasedOnTotalMAG):
                    OnPropertyChanged(nameof(MaxSpiritForce));
                    break;
                case nameof(CharacterSettings.CyberlegMovement):
                    OnPropertyChanged(nameof(Movement));
                    break;
                case nameof(CharacterSettings.AllowInitiationInCreateMode):
                    OnPropertyChanged(nameof(AddInitiationsAllowed));
                    break;
                case nameof(CharacterSettings.MysAdeptAllowPpCareer):
                    OnPropertyChanged(nameof(MysAdeptAllowPPCareer));
                    break;
                case nameof(CharacterSettings.MysAdeptSecondMAGAttribute):
                    this.OnMultiplePropertyChanged(nameof(UseMysticAdeptPPs), nameof(AllowAdeptWayPowerDiscount));
                    break;
                case nameof(CharacterSettings.ContactPointsExpression):
                    OnPropertyChanged(nameof(ContactPoints));
                    break;
                case nameof(CharacterSettings.SpecialKarmaCostBasedOnShownValue):
                    RefreshEssenceLossImprovements();
                    break;
                case nameof(CharacterSettings.NuyenFormat):
                    this.OnMultiplePropertyChanged(nameof(DisplayNuyen), nameof(DisplayCareerNuyen),
                                                   nameof(DisplayStolenNuyen));
                    break;
                case nameof(CharacterSettings.EssenceFormat):
                case nameof(CharacterSettings.DontRoundEssenceInternally):
                    this.OnMultiplePropertyChanged(nameof(PrototypeTranshumanEssenceUsed), nameof(BiowareEssence),
                                                   nameof(CyberwareEssence), nameof(EssenceHole));
                    break;
                case nameof(CharacterSettings.NuyenMaximumBP):
                case nameof(CharacterSettings.UnrestrictedNuyen):
                    OnPropertyChanged(nameof(TotalNuyenMaximumBP));
                    break;
                case nameof(CharacterSettings.KarmaMysticAdeptPowerPoint):
                    OnPropertyChanged(nameof(CanAffordCareerPP));
                    break;
                case nameof(CharacterSettings.BuildMethod):
                    OnPropertyChanged(nameof(EffectiveBuildMethod));
                    break;
                case nameof(CharacterSettings.AutomaticBackstory):
                    OnPropertyChanged(nameof(EnableAutomaticStoryButton));
                    break;
                case nameof(CharacterSettings.ChargenKarmaToNuyenExpression):
                    OnPropertyChanged(nameof(TotalStartingNuyen));
                    break;
                case nameof(CharacterSettings.LimbCount):
                    OnPropertyChanged(nameof(LimbCount));
                    break;
                case nameof(CharacterSettings.MetatypeCostsKarmaMultiplier):
                    OnPropertyChanged(nameof(DisplayMetatypeBP));
                    break;
                case nameof(CharacterSettings.RedlinerExcludes):
                    RefreshRedlinerImprovements();
                    break;
                case nameof(CharacterSettings.NoArmorEncumbrance):
                    RefreshEncumbrance();
                    break;
                case nameof(CharacterSettings.KarmaQuality):
                case nameof(CharacterSettings.QualityKarmaLimit):
                    this.OnMultiplePropertyChanged(nameof(PositiveQualityKarma), nameof(NegativeQualityKarma));
                    break;
                case nameof(CharacterSettings.ExceedPositiveQualitiesCostDoubled):
                    OnPropertyChanged(nameof(PositiveQualityKarma));
                    break;
                case nameof(CharacterSettings.EnemyKarmaQualityLimit):
                case nameof(CharacterSettings.ExceedNegativeQualitiesLimit):
                    OnPropertyChanged(nameof(NegativeQualityKarma));
                    break;
                case nameof(CharacterSettings.EnableEnemyTracking):
                case nameof(CharacterSettings.KarmaEnemy):
                    OnPropertyChanged(nameof(EnemyKarma));
                    break;
                case nameof(CharacterSettings.DicePenaltySustaining):
                    RefreshSustainingPenalties();
                    break;
                case nameof(CharacterSettings.KarmaSpell):
                    if (FreeSpells > 0)
                        OnPropertyChanged(nameof(PositiveQualityKarma));
                    break;
                case nameof(CharacterSettings.MinInitiativeDice):
                    if (this.GetNodeXPath()?.SelectSingleNodeAndCacheExpression("initiativedice") == null)
                    {
                        _intInitiativeDice = Settings.MinInitiativeDice;
                        OnPropertyChanged(nameof(InitiativeDice));
                    }
                    break;
                case nameof(CharacterSettings.MaxInitiativeDice):
                    OnPropertyChanged(nameof(InitiativeDice));
                    break;
                case nameof(CharacterSettings.MinAstralInitiativeDice):
                case nameof(CharacterSettings.MaxAstralInitiativeDice):
                    OnPropertyChanged(nameof(AstralInitiativeDice));
                    break;
                case nameof(CharacterSettings.MinColdSimInitiativeDice):
                case nameof(CharacterSettings.MaxColdSimInitiativeDice):
                    OnPropertyChanged(nameof(MatrixInitiativeColdDice));
                    break;
                case nameof(CharacterSettings.MinHotSimInitiativeDice):
                    if (IsAI)
                        this.OnMultiplePropertyChanged(nameof(MatrixInitiativeDice), nameof(MatrixInitiativeHotDice));
                    else
                        OnPropertyChanged(nameof(MatrixInitiativeHotDice));
                    break;
                case nameof(CharacterSettings.MaxHotSimInitiativeDice):
                    OnPropertyChanged(nameof(MatrixInitiativeHotDice));
                    break;
            }
        }

        private void AttributeSectionOnPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == nameof(AttributeSection.AttributeCategory))
            {
                this.OnMultiplePropertyChanged(nameof(CurrentWalkingRateString),
                                               nameof(CurrentRunningRateString),
                                               nameof(CurrentSprintingRateString));
            }
        }

        private void ContactsOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (e.Action != NotifyCollectionChangedAction.Move)
            {
                this.OnMultiplePropertyChanged(nameof(NegativeQualityKarma),
                                               nameof(NegativeQualityLimitKarma),
                                               nameof(PositiveQualityKarma),
                                               nameof(PositiveQualityKarmaTotal),
                                               nameof(EnemyKarma));
            }
        }

        private void PowersOnBeforeRemove(object sender, RemovingOldEventArgs e)
        {
            if (Powers[e.OldIndex].AdeptWayDiscountEnabled)
                this.OnMultiplePropertyChanged(nameof(AnyPowerAdeptWayDiscountEnabled), nameof(AllowAdeptWayPowerDiscount));
        }

        private void PowersOnListChanged(object sender, ListChangedEventArgs e)
        {
            using (new FetchSafelyFromPool<Dictionary<INotifyMultiplePropertyChanged, HashSet<string>>>(
                       Utils.DictionaryForMultiplePropertyChangedPool,
                       out Dictionary<INotifyMultiplePropertyChanged, HashSet<string>> dicChangedProperties))
            {
                try
                {
                    switch (e.ListChangedType)
                    {
                        case ListChangedType.Reset:
                        {
                            HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                            strTemp.Add(nameof(PowerPointsUsed));
                            strTemp.Add(nameof(AnyPowerAdeptWayDiscountEnabled));
                            strTemp.Add(nameof(AllowAdeptWayPowerDiscount));
                            dicChangedProperties.Add(this, strTemp);
                        }
                            break;
                        case ListChangedType.ItemAdded:
                        {
                            HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                            strTemp.Add(nameof(PowerPointsUsed));
                            dicChangedProperties.Add(this, strTemp);
                            Power objNewPower = Powers[e.NewIndex];
                            if (!IsLoading)
                            {
                                // Needed in order to properly process named sources where
                                // the tooltip was built before the object was added to the character
                                foreach (Improvement objImprovement in Improvements)
                                {
                                    if (objImprovement.SourceName != objNewPower.InternalId || !objImprovement.Enabled)
                                        continue;
                                    foreach ((INotifyMultiplePropertyChanged objItemToUpdate,
                                              string strPropertyToUpdate) in
                                             objImprovement.GetRelevantPropertyChangers())
                                    {
                                        if (dicChangedProperties.TryGetValue(objItemToUpdate,
                                                                             out HashSet<string> setChangedProperties))
                                            setChangedProperties.Add(strPropertyToUpdate);
                                        else
                                        {
                                            HashSet<string> strInnerTemp = Utils.StringHashSetPool.Get();
                                            strInnerTemp.Add(strPropertyToUpdate);
                                            dicChangedProperties.Add(objItemToUpdate, strInnerTemp);
                                        }
                                    }
                                }
                            }

                            if (objNewPower.AdeptWayDiscountEnabled)
                            {
                                strTemp.Add(nameof(AnyPowerAdeptWayDiscountEnabled));
                                strTemp.Add(nameof(AllowAdeptWayPowerDiscount));
                            }
                        }
                            break;
                        case ListChangedType.ItemDeleted:
                        {
                            HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                            strTemp.Add(nameof(PowerPointsUsed));
                            dicChangedProperties.Add(this, strTemp);
                        }
                            break;
                        case ListChangedType.ItemChanged:
                        {
                            if (e.PropertyDescriptor == null)
                            {
                                break;
                            }

                            switch (e.PropertyDescriptor.Name)
                            {
                                case nameof(Power.AdeptWayDiscountEnabled):
                                {
                                    HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                                    strTemp.Add(nameof(AnyPowerAdeptWayDiscountEnabled));
                                    strTemp.Add(nameof(AllowAdeptWayPowerDiscount));
                                    dicChangedProperties.Add(this, strTemp);
                                    break;
                                }
                                case nameof(Power.DiscountedAdeptWay):
                                {
                                    HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                                    strTemp.Add(nameof(PowerPointsUsed));
                                    strTemp.Add(nameof(AnyPowerAdeptWayDiscountEnabled));
                                    strTemp.Add(nameof(AllowAdeptWayPowerDiscount));
                                    dicChangedProperties.Add(this, strTemp);
                                    foreach (Power objPower in Powers)
                                    {
                                        HashSet<string> strInnerTemp = Utils.StringHashSetPool.Get();
                                        strInnerTemp.Add(nameof(Power.AdeptWayDiscountEnabled));
                                        dicChangedProperties.Add(objPower, strInnerTemp);
                                    }

                                    break;
                                }
                                case nameof(Power.PowerPoints):
                                {
                                    HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                                    strTemp.Add(nameof(PowerPointsUsed));
                                    dicChangedProperties.Add(this, strTemp);
                                    break;
                                }
                            }
                        }
                            break;
                    }

                    foreach (KeyValuePair<INotifyMultiplePropertyChanged, HashSet<string>> kvpToProcess in dicChangedProperties)
                    {
                        kvpToProcess.Key.OnMultiplePropertyChanged(kvpToProcess.Value);
                    }
                }
                finally
                {
                    foreach (HashSet<string> setToReturn in dicChangedProperties.Values)
                        Utils.StringHashSetPool.Return(setToReturn);
                }
            }
        }

        private void MentorSpiritsOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            using (new FetchSafelyFromPool<Dictionary<INotifyMultiplePropertyChanged, HashSet<string>>>(
                       Utils.DictionaryForMultiplePropertyChangedPool,
                       out Dictionary<INotifyMultiplePropertyChanged, HashSet<string>> dicChangedProperties))
            {
                try
                {
                    HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                    strTemp.Add(nameof(MentorSpirits));
                    dicChangedProperties.Add(this, strTemp);
                    if (e.Action == NotifyCollectionChangedAction.Add && !IsLoading)
                    {
                        foreach (MentorSpirit objNewItem in e.NewItems)
                        {
                            // Needed in order to properly process named sources where
                            // the tooltip was built before the object was added to the character
                            foreach (Improvement objImprovement in Improvements)
                            {
                                if (objImprovement.SourceName != objNewItem.InternalId || !objImprovement.Enabled)
                                    continue;
                                foreach ((INotifyMultiplePropertyChanged objItemToUpdate, string strPropertyToUpdate) in
                                         objImprovement.GetRelevantPropertyChangers())
                                {
                                    if (dicChangedProperties.TryGetValue(objItemToUpdate,
                                                                         out HashSet<string> setChangedProperties))
                                        setChangedProperties.Add(strPropertyToUpdate);
                                    else
                                    {
                                        HashSet<string> strInnerTemp = Utils.StringHashSetPool.Get();
                                        strInnerTemp.Add(strPropertyToUpdate);
                                        dicChangedProperties.Add(objItemToUpdate, strInnerTemp);
                                    }
                                }
                            }
                        }
                    }

                    foreach (KeyValuePair<INotifyMultiplePropertyChanged, HashSet<string>> kvpToProcess in dicChangedProperties)
                    {
                        kvpToProcess.Key.OnMultiplePropertyChanged(kvpToProcess.Value);
                    }
                }
                finally
                {
                    foreach (HashSet<string> setToReturn in dicChangedProperties.Values)
                        Utils.StringHashSetPool.Return(setToReturn);
                }
            }
        }

        private void QualitiesCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            using (new FetchSafelyFromPool<Dictionary<INotifyMultiplePropertyChanged, HashSet<string>>>(
                       Utils.DictionaryForMultiplePropertyChangedPool,
                       out Dictionary<INotifyMultiplePropertyChanged, HashSet<string>> dicChangedProperties))
            {
                try
                {
                    HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                    strTemp.Add(nameof(Qualities));
                    dicChangedProperties.Add(this, strTemp);
                    if (e.Action != NotifyCollectionChangedAction.Move)
                    {
                        foreach (Power objPower in Powers)
                        {
                            HashSet<string> strInnerTemp = Utils.StringHashSetPool.Get();
                            strInnerTemp.Add(nameof(Power.AdeptWayDiscountEnabled));
                            dicChangedProperties.Add(objPower, strInnerTemp);
                        }

                        if (!IsLoading)
                        {
                            switch (e.Action)
                            {
                                // Note: Removal is already handled through DeleteQuality
                                case NotifyCollectionChangedAction.Add:
                                {
                                    foreach (Quality objNewItem in e.NewItems)
                                    {
                                        // Needed in order to properly process named sources where
                                        // the tooltip was built before the object was added to the character
                                        foreach (Improvement objImprovement in Improvements)
                                        {
                                            if (objImprovement.SourceName != objNewItem.InternalId
                                                || !objImprovement.Enabled)
                                                continue;
                                            foreach ((INotifyMultiplePropertyChanged objItemToUpdate,
                                                      string strPropertyToUpdate) in
                                                     objImprovement.GetRelevantPropertyChangers())
                                            {
                                                if (dicChangedProperties.TryGetValue(objItemToUpdate,
                                                        out HashSet<string> setChangedProperties))
                                                    setChangedProperties.Add(strPropertyToUpdate);
                                                else
                                                {
                                                    HashSet<string> strInnerTemp = Utils.StringHashSetPool.Get();
                                                    strInnerTemp.Add(strPropertyToUpdate);
                                                    dicChangedProperties.Add(objItemToUpdate, strInnerTemp);
                                                }
                                            }
                                        }
                                    }

                                    break;
                                }
                                case NotifyCollectionChangedAction.Replace:
                                {
                                    foreach (Quality objNewItem in e.NewItems)
                                    {
                                        // Needed in order to properly process named sources where
                                        // the tooltip was built before the object was added to the character
                                        foreach (Improvement objImprovement in Improvements)
                                        {
                                            if (objImprovement.SourceName != objNewItem.InternalId
                                                || !objImprovement.Enabled)
                                                continue;
                                            foreach ((INotifyMultiplePropertyChanged objItemToUpdate,
                                                      string strPropertyToUpdate) in
                                                     objImprovement.GetRelevantPropertyChangers())
                                            {
                                                if (dicChangedProperties.TryGetValue(objItemToUpdate,
                                                        out HashSet<string> setChangedProperties))
                                                    setChangedProperties.Add(strPropertyToUpdate);
                                                else
                                                {
                                                    HashSet<string> strInnerTemp = Utils.StringHashSetPool.Get();
                                                    strInnerTemp.Add(strPropertyToUpdate);
                                                    dicChangedProperties.Add(objItemToUpdate, strInnerTemp);
                                                }
                                            }
                                        }
                                    }

                                    break;
                                }
                            }
                        }
                    }

                    foreach (KeyValuePair<INotifyMultiplePropertyChanged, HashSet<string>> kvpToProcess in dicChangedProperties)
                    {
                        kvpToProcess.Key.OnMultiplePropertyChanged(kvpToProcess.Value);
                    }
                }
                finally
                {
                    foreach (HashSet<string> setToReturn in dicChangedProperties.Values)
                        Utils.StringHashSetPool.Return(setToReturn);
                }
            }
        }

        private void MartialArtsOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (e.Action == NotifyCollectionChangedAction.Add && !IsLoading)
            {
                using (new FetchSafelyFromPool<Dictionary<INotifyMultiplePropertyChanged, HashSet<string>>>(
                           Utils.DictionaryForMultiplePropertyChangedPool,
                           out Dictionary<INotifyMultiplePropertyChanged, HashSet<string>> dicChangedProperties))
                {
                    try
                    {
                        foreach (MartialArt objNewItem in e.NewItems)
                        {
                            // Needed in order to properly process named sources where
                            // the tooltip was built before the object was added to the character
                            foreach (Improvement objImprovement in Improvements)
                            {
                                if (objImprovement.SourceName != objNewItem.InternalId || !objImprovement.Enabled)
                                    continue;
                                foreach ((INotifyMultiplePropertyChanged objItemToUpdate, string strPropertyToUpdate) in
                                         objImprovement.GetRelevantPropertyChangers())
                                {
                                    if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                                          out HashSet<string> setChangedProperties))
                                    {
                                        setChangedProperties = Utils.StringHashSetPool.Get();
                                        dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                    }

                                    setChangedProperties.Add(strPropertyToUpdate);
                                }
                            }
                        }

                        foreach (KeyValuePair<INotifyMultiplePropertyChanged, HashSet<string>> kvpToUpdate in
                                 dicChangedProperties)
                        {
                            kvpToUpdate.Key.OnMultiplePropertyChanged(kvpToUpdate.Value);
                        }
                    }
                    finally
                    {
                        foreach (HashSet<string> setToReturn in dicChangedProperties.Values)
                            Utils.StringHashSetPool.Return(setToReturn);
                    }
                }
            }
        }

        private void MetamagicsOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (IsLoading)
                return;
            List<Metamagic> lstImprovementSourcesToProcess = new List<Metamagic>(e.NewItems?.Count ?? 0 + e.OldItems?.Count ?? 0);
            switch (e.Action)
            {
                case NotifyCollectionChangedAction.Add:
                    if (e.NewItems?.Count > 0)
                    {
                        foreach (Metamagic objNewItem in e.NewItems)
                            lstImprovementSourcesToProcess.Add(objNewItem);
                    }

                    break;
                case NotifyCollectionChangedAction.Remove:
                    if (e.OldItems?.Count > 0)
                    {
                        foreach (Metamagic objOldItem in e.OldItems)
                            lstImprovementSourcesToProcess.Add(objOldItem);
                    }

                    break;
                case NotifyCollectionChangedAction.Replace:
                    if (e.OldItems?.Count > 0)
                    {
                        foreach (Metamagic objOldItem in e.OldItems)
                            lstImprovementSourcesToProcess.Add(objOldItem);
                    }

                    if (e.NewItems?.Count > 0)
                    {
                        foreach (Metamagic objNewItem in e.NewItems)
                            lstImprovementSourcesToProcess.Add(objNewItem);
                    }

                    break;
                case NotifyCollectionChangedAction.Reset:
                    break;
            }
            if (lstImprovementSourcesToProcess.Count > 0)
            {
                using (new FetchSafelyFromPool<Dictionary<INotifyMultiplePropertyChanged, HashSet<string>>>(
                           Utils.DictionaryForMultiplePropertyChangedPool,
                           out Dictionary<INotifyMultiplePropertyChanged, HashSet<string>> dicChangedProperties))
                {
                    try
                    {
                        foreach (Metamagic objNewItem in lstImprovementSourcesToProcess)
                        {
                            // Needed in order to properly process named sources where
                            // the tooltip was built before the object was added to the character
                            foreach (Improvement objImprovement in Improvements)
                            {
                                if (objImprovement.SourceName != objNewItem.InternalId || !objImprovement.Enabled)
                                    continue;
                                foreach ((INotifyMultiplePropertyChanged objItemToUpdate, string strPropertyToUpdate) in
                                         objImprovement.GetRelevantPropertyChangers())
                                {
                                    if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                                          out HashSet<string> setChangedProperties))
                                    {
                                        setChangedProperties = Utils.StringHashSetPool.Get();
                                        dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                    }

                                    setChangedProperties.Add(strPropertyToUpdate);
                                }
                            }
                        }

                        foreach (KeyValuePair<INotifyMultiplePropertyChanged, HashSet<string>> kvpToUpdate in
                                 dicChangedProperties)
                        {
                            kvpToUpdate.Key.OnMultiplePropertyChanged(kvpToUpdate.Value);
                        }
                    }
                    finally
                    {
                        foreach (HashSet<string> setToReturn in dicChangedProperties.Values)
                            Utils.StringHashSetPool.Return(setToReturn);
                    }
                }
            }
        }

        private void ExpenseLogOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                            out HashSet<string> setPropertiesToRefresh))
            {
                switch (e.Action)
                {
                    case NotifyCollectionChangedAction.Add:
                        foreach (ExpenseLogEntry objNewItem in e.NewItems)
                        {
                            if ((objNewItem.Amount > 0 || objNewItem.ForceCareerVisible) && !objNewItem.Refund)
                            {
                                setPropertiesToRefresh.Add(objNewItem.Type == ExpenseType.Nuyen
                                                               ? nameof(CareerNuyen)
                                                               : nameof(CareerKarma));
                            }
                        }

                        break;
                    case NotifyCollectionChangedAction.Remove:
                        foreach (ExpenseLogEntry objOldItem in e.OldItems)
                        {
                            if ((objOldItem.Amount > 0 || objOldItem.ForceCareerVisible) && !objOldItem.Refund)
                            {
                                setPropertiesToRefresh.Add(objOldItem.Type == ExpenseType.Nuyen
                                                               ? nameof(CareerNuyen)
                                                               : nameof(CareerKarma));
                            }
                        }

                        break;
                    case NotifyCollectionChangedAction.Replace:
                        foreach (ExpenseLogEntry objOldItem in e.OldItems)
                        {
                            if ((objOldItem.Amount > 0 || objOldItem.ForceCareerVisible) && !objOldItem.Refund)
                            {
                                setPropertiesToRefresh.Add(objOldItem.Type == ExpenseType.Nuyen
                                                               ? nameof(CareerNuyen)
                                                               : nameof(CareerKarma));
                            }
                        }

                        foreach (ExpenseLogEntry objNewItem in e.NewItems)
                        {
                            if ((objNewItem.Amount > 0 || objNewItem.ForceCareerVisible) && !objNewItem.Refund)
                            {
                                setPropertiesToRefresh.Add(objNewItem.Type == ExpenseType.Nuyen
                                                               ? nameof(CareerNuyen)
                                                               : nameof(CareerKarma));
                            }
                        }

                        break;
                    case NotifyCollectionChangedAction.Reset:
                        setPropertiesToRefresh.Add(nameof(CareerNuyen));
                        setPropertiesToRefresh.Add(nameof(CareerKarma));
                        break;
                }

                if (setPropertiesToRefresh.Count > 0)
                    OnMultiplePropertyChanged(setPropertiesToRefresh);
            }
        }

        private void ArmorOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            bool blnDoEncumbranceRefresh = false;
            using (new FetchSafelyFromPool<Dictionary<INotifyMultiplePropertyChanged, HashSet<string>>>(
                       Utils.DictionaryForMultiplePropertyChangedPool,
                       out Dictionary<INotifyMultiplePropertyChanged, HashSet<string>> dicChangedProperties))
            {
                try
                {
                    switch (e.Action)
                    {
                        case NotifyCollectionChangedAction.Add:
                            foreach (Armor objNewItem in e.NewItems)
                            {
                                if (objNewItem.Equipped && objNewItem.Encumbrance)
                                {
                                    blnDoEncumbranceRefresh = true;
                                }

                                if (!IsLoading)
                                {
                                    // Needed in order to properly process named sources where
                                    // the tooltip was built before the object was added to the character
                                    foreach (Improvement objImprovement in Improvements)
                                    {
                                        if (objImprovement.SourceName.TrimEndOnce("Wireless") == objNewItem.InternalId
                                            &&
                                            objImprovement.Enabled)
                                        {
                                            foreach ((INotifyMultiplePropertyChanged objItemToUpdate,
                                                      string strPropertyToUpdate) in
                                                     objImprovement.GetRelevantPropertyChangers())
                                            {
                                                if (dicChangedProperties.TryGetValue(objItemToUpdate,
                                                        out HashSet<string> setChangedProperties))
                                                    setChangedProperties.Add(strPropertyToUpdate);
                                                else
                                                {
                                                    HashSet<string> strInnerTemp = Utils.StringHashSetPool.Get();
                                                    strInnerTemp.Add(strPropertyToUpdate);
                                                    dicChangedProperties.Add(objItemToUpdate, strInnerTemp);
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            break;
                        case NotifyCollectionChangedAction.Remove:
                            foreach (Armor objOldItem in e.OldItems)
                            {
                                if (objOldItem.Equipped && objOldItem.Encumbrance)
                                {
                                    blnDoEncumbranceRefresh = true;
                                    break;
                                }
                            }

                            break;
                        case NotifyCollectionChangedAction.Replace:
                            foreach (Armor objOldItem in e.OldItems)
                            {
                                if (objOldItem.Equipped && objOldItem.Encumbrance)
                                {
                                    blnDoEncumbranceRefresh = true;
                                    break;
                                }
                            }

                            if (!blnDoEncumbranceRefresh)
                            {
                                foreach (Armor objNewItem in e.NewItems)
                                {
                                    if (objNewItem.Equipped && objNewItem.Encumbrance)
                                    {
                                        blnDoEncumbranceRefresh = true;
                                        break;
                                    }
                                }
                            }

                            break;
                        case NotifyCollectionChangedAction.Reset:
                            blnDoEncumbranceRefresh = true;
                            break;
                    }

                    if (blnDoEncumbranceRefresh)
                    {
                        if (dicChangedProperties.TryGetValue(this, out HashSet<string> setChangedProperties))
                            setChangedProperties.Add(nameof(GetArmorRating));
                        else
                        {
                            HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                            strTemp.Add(nameof(GetArmorRating));
                            dicChangedProperties.Add(this, strTemp);
                        }
                    }

                    foreach (KeyValuePair<INotifyMultiplePropertyChanged, HashSet<string>> kvpToProcess in dicChangedProperties)
                    {
                        kvpToProcess.Key.OnMultiplePropertyChanged(kvpToProcess.Value);
                    }
                }
                finally
                {
                    foreach (HashSet<string> setToReturn in dicChangedProperties.Values)
                        Utils.StringHashSetPool.Return(setToReturn);
                }
            }

            if (blnDoEncumbranceRefresh)
                RefreshEncumbrance();
        }

        private void CyberwareOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            bool blnDoCyberlimbAttributesRefresh = false;
            using (new FetchSafelyFromPool<Dictionary<INotifyMultiplePropertyChanged, HashSet<string>>>(
                       Utils.DictionaryForMultiplePropertyChangedPool,
                       out Dictionary<INotifyMultiplePropertyChanged, HashSet<string>> dicChangedProperties))
            {
                try
                {
                    switch (e.Action)
                    {
                        case NotifyCollectionChangedAction.Add:
                        {
                            HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                            strTemp.Add(nameof(RedlinerBonus));
                            dicChangedProperties.Add(this, strTemp);
                            foreach (Cyberware objNewItem in e.NewItems)
                            {
                                dicChangedProperties[this].Add(objNewItem.EssencePropertyName);
                                if (!IsLoading)
                                {
                                    // Needed in order to properly process named sources where
                                    // the tooltip was built before the object was added to the character
                                    foreach (Improvement objImprovement in Improvements)
                                    {
                                        if (objImprovement.SourceName.TrimEndOnce("Pair").TrimEndOnce("Wireless") ==
                                            objNewItem.InternalId && objImprovement.Enabled)
                                        {
                                            foreach ((INotifyMultiplePropertyChanged objItemToUpdate,
                                                      string strPropertyToUpdate) in
                                                     objImprovement.GetRelevantPropertyChangers())
                                            {
                                                if (dicChangedProperties.TryGetValue(objItemToUpdate,
                                                        out HashSet<string> setChangedProperties))
                                                    setChangedProperties.Add(strPropertyToUpdate);
                                                else
                                                {
                                                    HashSet<string> strInnerTemp = Utils.StringHashSetPool.Get();
                                                    strInnerTemp.Add(strPropertyToUpdate);
                                                    dicChangedProperties.Add(objItemToUpdate, strInnerTemp);
                                                }
                                            }
                                        }
                                    }
                                }

                                if (!blnDoCyberlimbAttributesRefresh && !Settings.DontUseCyberlimbCalculation &&
                                    objNewItem.Category == "Cyberlimb" && objNewItem.Parent == null &&
                                    objNewItem.ParentVehicle == null &&
                                    !string.IsNullOrWhiteSpace(objNewItem.LimbSlot) &&
                                    !Settings.ExcludeLimbSlot.Contains(objNewItem.LimbSlot))
                                {
                                    blnDoCyberlimbAttributesRefresh = true;
                                }
                            }

                            break;
                        }
                        case NotifyCollectionChangedAction.Remove:
                        {
                            HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                            strTemp.Add(nameof(RedlinerBonus));
                            dicChangedProperties.Add(this, strTemp);
                            foreach (Cyberware objOldItem in e.OldItems)
                            {
                                dicChangedProperties[this].Add(objOldItem.EssencePropertyName);
                                if (!blnDoCyberlimbAttributesRefresh && !Settings.DontUseCyberlimbCalculation &&
                                    objOldItem.Category == "Cyberlimb" && objOldItem.Parent == null &&
                                    objOldItem.ParentVehicle == null &&
                                    !string.IsNullOrWhiteSpace(objOldItem.LimbSlot) &&
                                    !Settings.ExcludeLimbSlot.Contains(objOldItem.LimbSlot))
                                {
                                    blnDoCyberlimbAttributesRefresh = true;
                                }
                            }

                            break;
                        }
                        case NotifyCollectionChangedAction.Replace:
                        {
                            HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                            strTemp.Add(nameof(RedlinerBonus));
                            dicChangedProperties.Add(this, strTemp);
                            if (!Settings.DontUseCyberlimbCalculation)
                            {
                                foreach (Cyberware objOldItem in e.OldItems)
                                {
                                    dicChangedProperties[this].Add(objOldItem.EssencePropertyName);
                                    if (!blnDoCyberlimbAttributesRefresh && !Settings.DontUseCyberlimbCalculation &&
                                        objOldItem.Category == "Cyberlimb" && objOldItem.Parent == null &&
                                        objOldItem.ParentVehicle == null &&
                                        !string.IsNullOrWhiteSpace(objOldItem.LimbSlot) &&
                                        !Settings.ExcludeLimbSlot.Contains(objOldItem.LimbSlot))
                                    {
                                        blnDoCyberlimbAttributesRefresh = true;
                                    }
                                }

                                foreach (Cyberware objNewItem in e.NewItems)
                                {
                                    dicChangedProperties[this].Add(objNewItem.EssencePropertyName);
                                    if (!blnDoCyberlimbAttributesRefresh && !Settings.DontUseCyberlimbCalculation &&
                                        objNewItem.Category == "Cyberlimb" && objNewItem.Parent == null &&
                                        objNewItem.ParentVehicle == null &&
                                        !string.IsNullOrWhiteSpace(objNewItem.LimbSlot) &&
                                        !Settings.ExcludeLimbSlot.Contains(objNewItem.LimbSlot))
                                    {
                                        blnDoCyberlimbAttributesRefresh = true;
                                    }
                                }
                            }

                            break;
                        }
                        case NotifyCollectionChangedAction.Reset:
                        {
                            blnDoCyberlimbAttributesRefresh = !Settings.DontUseCyberlimbCalculation;
                            HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                            strTemp.Add(nameof(RedlinerBonus));
                            strTemp.Add(nameof(PrototypeTranshumanEssenceUsed));
                            strTemp.Add(nameof(BiowareEssence));
                            strTemp.Add(nameof(CyberwareEssence));
                            strTemp.Add(nameof(EssenceHole));
                            dicChangedProperties.Add(this, strTemp);
                            break;
                        }
                    }

                    if (blnDoCyberlimbAttributesRefresh)
                    {
                        CharacterAttrib objAttribute = GetAttribute("AGI");
                        if (objAttribute != null)
                        {
                            HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                            strTemp.Add(nameof(CharacterAttrib.TotalValue));
                            dicChangedProperties.Add(objAttribute, strTemp);
                        }

                        objAttribute = GetAttribute("STR");
                        if (objAttribute != null)
                        {
                            HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                            strTemp.Add(nameof(CharacterAttrib.TotalValue));
                            dicChangedProperties.Add(objAttribute, strTemp);
                        }
                    }

                    foreach (KeyValuePair<INotifyMultiplePropertyChanged, HashSet<string>> kvpToProcess in dicChangedProperties)
                    {
                        kvpToProcess.Key.OnMultiplePropertyChanged(kvpToProcess.Value);
                    }
                }
                finally
                {
                    foreach (HashSet<string> setToReturn in dicChangedProperties.Values)
                        Utils.StringHashSetPool.Return(setToReturn);
                }
            }
        }

        private void SustainedObjectsOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            bool blnDoRefreshPenalties = false;
            switch (e.Action)
            {
                case NotifyCollectionChangedAction.Add:
                    blnDoRefreshPenalties =
                        e.NewItems.OfType<SustainedObject>().Any(objItem => objItem.HasSustainingPenalty);
                    break;
                case NotifyCollectionChangedAction.Remove:
                    blnDoRefreshPenalties =
                        e.OldItems.OfType<SustainedObject>().Any(objItem => objItem.HasSustainingPenalty);
                    break;
                case NotifyCollectionChangedAction.Replace:
                    blnDoRefreshPenalties =
                        e.OldItems.OfType<SustainedObject>().Any(objItem => objItem.HasSustainingPenalty) ||
                        e.NewItems.OfType<SustainedObject>().Any(objItem => objItem.HasSustainingPenalty);
                    break;
                case NotifyCollectionChangedAction.Move:
                    break;
                case NotifyCollectionChangedAction.Reset:
                    blnDoRefreshPenalties = true;
                    break;
            }
            if (blnDoRefreshPenalties)
                RefreshSustainingPenalties();
        }

        [HubTag] public AttributeSection AttributeSection { get; }

        public bool IsSaving { get; set; }

        #region Create, Save, Load and Print Methods

        /// <summary>
        /// Set up a character with a metatype and new attributes to match.
        /// </summary>
        public void Create(string strSelectedMetatypeCategory, string strMetatypeId, string strMetavariantId, XmlNode objXmlMetatype, int intForce, XmlNode xmlQualityDocumentQualitiesNode = null, XmlNode xmlCritterPowerDocumentPowersNode = null, XmlNode xmlSkillsDocumentKnowledgeSkillsNode = null, string strSelectedPossessionMethod = "")
        {
            if (objXmlMetatype == null)
                throw new ArgumentNullException(nameof(objXmlMetatype));
            // Remove any Improvements the character received from their Metatype.
            ImprovementManager.RemoveImprovements(this,
                Improvements.Where(objImprovement =>
                    objImprovement.ImproveSource == Improvement.ImprovementSource.Metatype
                    || objImprovement.ImproveSource == Improvement.ImprovementSource.Metavariant).ToList());

            // Remove any Qualities the character received from their Metatype, then remove the Quality.
            for (int i = Qualities.Count - 1; i >= 0; --i)
            {
                if (i >= Qualities.Count)
                    continue;
                Quality objQuality = Qualities[i];
                if (objQuality.OriginSource == QualitySource.Metatype ||
                    objQuality.OriginSource == QualitySource.MetatypeRemovable ||
                    objQuality.OriginSource == QualitySource.MetatypeRemovedAtChargen)
                    objQuality.DeleteQuality();
            }

            // If this is a Shapeshifter, a Metavariant must be selected. Default to Human if None is selected.
            if (strSelectedMetatypeCategory == "Shapeshifter" && strMetavariantId == Guid.Empty.ToString())
                strMetavariantId =
                    objXmlMetatype.SelectSingleNode("metavariants/metavariant[name = \"Human\"]/id")?.InnerText ??
                    string.Empty;
            XmlNode objXmlMetavariant =
                objXmlMetatype.SelectSingleNode("metavariants/metavariant[id = " + strMetavariantId.CleanXPath() + ']');

            // Set Metatype information.
            XmlNode charNode =
                strSelectedMetatypeCategory == "Shapeshifter" || strMetavariantId == Guid.Empty.ToString()
                    ? objXmlMetatype
                    : objXmlMetavariant ?? objXmlMetatype;
            AttributeSection.Create(charNode, intForce);
            MetatypeGuid = new Guid(strMetatypeId);
            Metatype = objXmlMetatype["name"]?.InnerText ?? "Human";
            MetatypeCategory = strSelectedMetatypeCategory;
            MetavariantGuid = string.IsNullOrEmpty(strMetavariantId) ? Guid.Empty : new Guid(strMetavariantId);
            Metavariant = MetavariantGuid != Guid.Empty ? objXmlMetavariant?["name"]?.InnerText ?? "None" : "None";
            // We only reverted to the base metatype to get the attributes.
            if (strSelectedMetatypeCategory == "Shapeshifter")
            {
                charNode = objXmlMetavariant ?? objXmlMetatype;
            }

            Source = charNode["source"]?.InnerText ?? "SR5";
            Page = charNode["page"]?.InnerText ?? "0";
            _intMetatypeBP = 0;
            charNode.TryGetInt32FieldQuickly("karma", ref _intMetatypeBP);
            _intInitiativeDice = Settings.MinInitiativeDice;
            charNode.TryGetInt32FieldQuickly("initiativedice", ref _intInitiativeDice);

            Movement = objXmlMetatype["movement"]?.InnerText ?? string.Empty;

            // Determine if the Metatype has any bonuses.
            XmlNode xmlBonusNode = charNode.SelectSingleNode("bonus");
            if (xmlBonusNode != null)
                ImprovementManager.CreateImprovements(this, Improvement.ImprovementSource.Metatype, strMetatypeId,
                    xmlBonusNode, 1, strMetatypeId);

            List<Weapon> lstWeapons = new List<Weapon>(1);
            // Create the Qualities that come with the Metatype.
            if (xmlQualityDocumentQualitiesNode == null)
                xmlQualityDocumentQualitiesNode = LoadData("qualities.xml").SelectSingleNode("/chummer/qualities");
            if (xmlQualityDocumentQualitiesNode != null)
            {
                using (XmlNodeList xmlQualityList = charNode.SelectNodes("qualities/*/quality"))
                {
                    if (xmlQualityList != null)
                    {
                        foreach (XmlNode objXmlQualityItem in xmlQualityList)
                        {
                            XmlNode objXmlQuality =
                                xmlQualityDocumentQualitiesNode.SelectSingleNode("quality[name = " +
                                    objXmlQualityItem.InnerText.CleanXPath() + ']');
                            Quality objQuality = new Quality(this);
                            string strForceValue = objXmlQualityItem.Attributes["select"]?.InnerText ?? string.Empty;
                            QualitySource objSource =
                                objXmlQualityItem.Attributes["removable"]?.InnerText == bool.TrueString
                                    ? QualitySource.MetatypeRemovable
                                    : QualitySource.Metatype;
                            objQuality.Create(objXmlQuality, objSource, lstWeapons, strForceValue);
                            objQuality.ContributeToLimit = false;
                            Qualities.Add(objQuality);
                        }
                    }
                }
            }

            //Load any critter powers the character has.
            if (xmlCritterPowerDocumentPowersNode == null)
                xmlCritterPowerDocumentPowersNode = LoadData("critterpowers.xml").SelectSingleNode("/chummer/powers");
            if (xmlCritterPowerDocumentPowersNode != null)
            {
                foreach (XmlNode objXmlPower in charNode.SelectNodes("powers/power"))
                {
                    XmlNode objXmlCritterPower =
                        xmlCritterPowerDocumentPowersNode.SelectSingleNode("power[name = " +
                                                                           objXmlPower.InnerText.CleanXPath() + ']');
                    CritterPower objPower = new CritterPower(this);
                    string strForcedValue = objXmlPower.Attributes["select"]?.InnerText ?? string.Empty;
                    int intRating =
                        CommonFunctions.ExpressionToInt(objXmlPower.Attributes["rating"]?.InnerText, intForce, 0, 0);

                    objPower.Create(objXmlCritterPower, intRating, strForcedValue);
                    objPower.CountTowardsLimit = false;
                    CritterPowers.Add(objPower);
                    ImprovementManager.CreateImprovement(this, objPower.InternalId,
                        Improvement.ImprovementSource.Metatype, string.Empty, Improvement.ImprovementType.CritterPower,
                        string.Empty);
                    ImprovementManager.Commit(this);
                }
            }

            //Load any natural weapons the character has.
            foreach (XmlNode objXmlNaturalWeapon in charNode.SelectNodes("naturalweapons/naturalweapon"))
            {
                Weapon objWeapon = new Weapon(this)
                {
                    Name = objXmlNaturalWeapon["name"].InnerText,
                    Category = LanguageManager.GetString("Tab_Critter"),
                    RangeType = "Melee",
                    Reach = CommonFunctions.ExpressionToInt(objXmlNaturalWeapon["reach"]?.InnerText, intForce, 0, 0),
                    Damage = objXmlNaturalWeapon["damage"]?.InnerText ?? "0S",
                    AP = objXmlNaturalWeapon["ap"]?.InnerText ?? "0",
                    Mode = "0",
                    RC = "0",
                    Concealability = 0,
                    Avail = "0",
                    Cost = "0",
                    UseSkill = objXmlNaturalWeapon["useskill"]?.InnerText,
                    Source = objXmlNaturalWeapon["source"].InnerText,
                    Page = objXmlNaturalWeapon["page"].InnerText
                };
                Weapons.Add(objWeapon);
            }

            // Add the Unarmed Attack Weapon to the character.
            if (Weapons.All(x => x.Name != "Unarmed Attack"))
            {
                XmlNode objXmlWeapon = LoadData("weapons.xml").SelectSingleNode("/chummer/weapons/weapon[name = \"Unarmed Attack\"]");
                if (objXmlWeapon != null)
                {
                    Weapon objWeapon = new Weapon(this);
                    objWeapon.Create(objXmlWeapon, lstWeapons);
                    objWeapon.ParentID =
                        Guid.NewGuid()
                            .ToString("D", GlobalSettings.InvariantCultureInfo); // Unarmed Attack can never be removed
                    Weapons.Add(objWeapon);
                }
            }

            //Set the Active Skill Ratings for the Critter.
            foreach (XmlNode xmlSkill in charNode.SelectNodes("skills/skill"))
            {
                string strRating = xmlSkill.Attributes?["rating"]?.InnerText;
                bool bImprovementAdded = false;
                if (!string.IsNullOrEmpty(strRating))
                {
                    ImprovementManager.CreateImprovement(this, xmlSkill.InnerText,
                        Improvement.ImprovementSource.Metatype, string.Empty, Improvement.ImprovementType.SkillLevel,
                        string.Empty,
                        CommonFunctions.ExpressionToInt(strRating, intForce, 0, 0));
                    ImprovementManager.Commit(this);
                    bImprovementAdded = true;
                }

                string strSkill = xmlSkill.InnerText;
                Skill objSkill = SkillsSection.GetActiveSkill(strSkill);
                if (objSkill == null)
                {
                    if (!bImprovementAdded)
                        continue;

                    //This skill does not yet exist but the datafile asks to improve it.
                    //We need to add it so it is not only improved but also shown on the skills tab.
                    SkillsSection.AddSkills(SkillsSection.FilterOption.Name, strSkill);
                    objSkill = SkillsSection.GetActiveSkill(strSkill);
                }
                if (objSkill != null) //More or less a safeguard only. Should not be empty at that point any longer.
                {
                    string strSpec = xmlSkill.Attributes?["spec"]?.InnerText ?? string.Empty;
                    if (string.IsNullOrEmpty(strSpec)) continue;
                    if (objSkill.Specializations.All(x => x.Name != strSpec))
                    {
                        SkillSpecialization objSpec = new SkillSpecialization(this, strSpec);
                        objSkill.Specializations.Add(objSpec);
                        ImprovementManager.CreateImprovement(this, strSkill, Improvement.ImprovementSource.Metatype,
                            string.Empty, Improvement.ImprovementType.SkillSpecialization, objSpec.InternalId);
                        ImprovementManager.Commit(this);
                    }
                }
            }

            //Set the Skill Group Ratings for the Critter.
            foreach (XmlNode xmlSkillGroup in charNode.SelectNodes("skills/group"))
            {
                string strRating = xmlSkillGroup.Attributes?["rating"]?.InnerText;
                if (!string.IsNullOrEmpty(strRating))
                {
                    ImprovementManager.CreateImprovement(this, xmlSkillGroup.InnerText,
                        Improvement.ImprovementSource.Metatype, string.Empty,
                        Improvement.ImprovementType.SkillGroupLevel, string.Empty,
                        CommonFunctions.ExpressionToInt(strRating, intForce, 0, 0));
                    ImprovementManager.Commit(this);
                }
            }

            //Set the Knowledge Skill Ratings for the Critter.
            if (xmlSkillsDocumentKnowledgeSkillsNode == null)
                xmlSkillsDocumentKnowledgeSkillsNode = LoadData("skills.xml").SelectSingleNode("/chummer/knowledgeskills");
            if (xmlSkillsDocumentKnowledgeSkillsNode != null)
            {
                foreach (XmlNode xmlSkill in charNode.SelectNodes("skills/knowledge"))
                {
                    string strName = xmlSkill.InnerText;
                    if (string.IsNullOrEmpty(strName))
                        continue;
                    string strRating = xmlSkill.Attributes?["rating"]?.InnerText;
                    if (string.IsNullOrEmpty(strRating))
                        continue;
                    if (SkillsSection.KnowledgeSkills.All(x => x.Name != strName))
                    {
                        XmlNode objXmlSkillNode =
                            xmlSkillsDocumentKnowledgeSkillsNode.SelectSingleNode("skill[name = " + strName.CleanXPath() + ']');
                        if (objXmlSkillNode != null)
                        {
                            Skill objUncastSkill = Skill.FromData(objXmlSkillNode, this, true);
                            if (objUncastSkill is KnowledgeSkill objSkill)
                                SkillsSection.KnowledgeSkills.Add(objSkill);
                            else
                            {
                                Utils.BreakIfDebug();
                                objUncastSkill.Dispose();
                            }
                        }
                        else
                        {
                            KnowledgeSkill objSkill = new KnowledgeSkill(this, strName, true)
                            {
                                Type = xmlSkill.Attributes?["category"]?.InnerText
                            };
                            SkillsSection.KnowledgeSkills.Add(objSkill);
                        }
                    }

                    ImprovementManager.CreateImprovement(this, strName,
                                                         Improvement.ImprovementSource.Metatype, string.Empty,
                                                         Improvement.ImprovementType.SkillLevel, string.Empty,
                                                         CommonFunctions.ExpressionToInt(strRating, intForce, 0, 0));
                    ImprovementManager.Commit(this);
                }
            }

            // Add any Complex Forms the Critter comes with (typically Sprites)
            XmlDocument xmlComplexFormDocument = LoadData("complexforms.xml");
            foreach (XmlNode xmlComplexForm in charNode.SelectNodes("complexforms/complexform"))
            {
                XmlNode xmlComplexFormData = xmlComplexFormDocument.SelectSingleNode(
                    "/chummer/complexforms/complexform[name = " + xmlComplexForm.InnerText.CleanXPath() + ']');
                if (xmlComplexFormData == null)
                    continue;

                ComplexForm objComplexform = new ComplexForm(this);
                objComplexform.Create(xmlComplexFormData);
                if (objComplexform.InternalId.IsEmptyGuid())
                    continue;
                objComplexform.Grade = -1;

                ComplexForms.Add(objComplexform);

                ImprovementManager.CreateImprovement(this, objComplexform.InternalId,
                    Improvement.ImprovementSource.Metatype, string.Empty, Improvement.ImprovementType.ComplexForm,
                    string.Empty);
                ImprovementManager.Commit(this);
            }

            //Load any cyberware the character has.
            XmlDocument xmlCyberwareDocument = LoadData("cyberware.xml");
            foreach (XmlNode node in charNode.SelectNodes("cyberwares/cyberware"))
            {
                XmlNode objXmlCyberwareNode =
                    xmlCyberwareDocument.SelectSingleNode("chummer/cyberwares/cyberware[name = " +
                                                          node.InnerText.CleanXPath() + ']');
                Cyberware objWare = new Cyberware(this);
                string strForcedValue = node.Attributes["select"]?.InnerText ?? string.Empty;
                int intRating = CommonFunctions.ExpressionToInt(node.Attributes["rating"]?.InnerText, intForce, 0, 0);

                objWare.Create(objXmlCyberwareNode,
                    GetGradeList(Improvement.ImprovementSource.Cyberware, true)
                        .FirstOrDefault(x => x.Name == "None"), Improvement.ImprovementSource.Metatype, intRating,
                    Weapons, Vehicles, true, true, strForcedValue);
                Cyberware.Add(objWare);
                ImprovementManager.CreateImprovement(this, objWare.InternalId, Improvement.ImprovementSource.Metatype,
                    string.Empty, Improvement.ImprovementType.FreeWare, string.Empty);
                ImprovementManager.Commit(this);
            }

            //Load any bioware the character has.
            XmlDocument xmlBiowareDocument = LoadData("bioware.xml");
            foreach (XmlNode node in charNode.SelectNodes("biowares/bioware"))
            {
                XmlNode objXmlCyberwareNode =
                    xmlBiowareDocument.SelectSingleNode("chummer/biowares/bioware[name = " +
                                                        node.InnerText.CleanXPath() + ']');
                Cyberware objWare = new Cyberware(this);
                string strForcedValue = node.Attributes["select"]?.InnerText ?? string.Empty;
                int intRating = CommonFunctions.ExpressionToInt(node.Attributes["rating"]?.InnerText, intForce, 0, 0);

                objWare.Create(objXmlCyberwareNode,
                    GetGradeList(Improvement.ImprovementSource.Bioware, true)
                        .FirstOrDefault(x => x.Name == "None"), Improvement.ImprovementSource.Metatype, intRating,
                    Weapons, Vehicles, true, true, strForcedValue);
                Cyberware.Add(objWare);
                ImprovementManager.CreateImprovement(this, objWare.InternalId, Improvement.ImprovementSource.Metatype,
                    string.Empty, Improvement.ImprovementType.FreeWare, string.Empty);
                ImprovementManager.Commit(this);
            }

            // Add any Advanced Programs the Critter comes with (typically A.I.s)
            XmlDocument xmlAIProgramDocument = LoadData("programs.xml");
            foreach (XmlNode xmlAIProgram in charNode.SelectNodes("programs/program"))
            {
                XmlNode xmlAIProgramData = xmlAIProgramDocument.SelectSingleNode("/chummer/programs/program[name = " +
                    xmlAIProgram.InnerText.CleanXPath() + ']');
                if (xmlAIProgramData == null)
                    continue;

                // Check for SelectText.
                string strExtra = xmlAIProgram.Attributes?["select"]?.InnerText ?? string.Empty;
                XmlNode xmlSelectText = xmlAIProgramData.SelectSingleNode("bonus/selecttext");
                if (xmlSelectText != null && !string.IsNullOrWhiteSpace(strExtra))
                {
                    using (SelectText frmPickText = new SelectText
                    {
                        Description = string.Format(GlobalSettings.CultureInfo,
                            LanguageManager.GetString("String_Improvement_SelectText"),
                            xmlAIProgramData["translate"]?.InnerText ?? xmlAIProgramData["name"].InnerText)
                    })
                    {
                        frmPickText.ShowDialogSafe(Program.GetFormForDialog(this));
                        // Make sure the dialogue window was not canceled.
                        if (frmPickText.DialogResult == DialogResult.Cancel)
                            continue;
                        strExtra = frmPickText.SelectedValue;
                    }
                }

                AIProgram objAIProgram = new AIProgram(this);
                objAIProgram.Create(xmlAIProgram, strExtra, false);
                if (objAIProgram.InternalId.IsEmptyGuid())
                    continue;

                AIPrograms.Add(objAIProgram);

                ImprovementManager.CreateImprovement(this, objAIProgram.InternalId,
                    Improvement.ImprovementSource.Metatype, string.Empty, Improvement.ImprovementType.AIProgram,
                    string.Empty);
                ImprovementManager.Commit(this);
            }

            // Add any Gear the Critter comes with (typically Programs for A.I.s)
            XmlDocument xmlGearDocument = LoadData("gear.xml");
            foreach (XmlNode xmlGear in charNode.SelectNodes("gears/gear"))
            {
                XmlNode xmlGearData = xmlGearDocument.SelectSingleNode("/chummer/gears/gear[name = " +
                                                                       xmlGear["name"].InnerText.CleanXPath() +
                                                                       " and category = " +
                                                                       xmlGear["category"].InnerText.CleanXPath() +
                                                                       "]");
                if (xmlGearData == null)
                    continue;

                int intRating = 1;
                if (xmlGear["rating"] != null)
                    intRating = CommonFunctions.ExpressionToInt(xmlGear["rating"].InnerText, intForce, 0, 0);
                decimal decQty = 1.0m;
                if (xmlGear["quantity"] != null)
                    decQty = CommonFunctions.ExpressionToDecimal(xmlGear["quantity"].InnerText, intForce);
                string strForceValue = xmlGear.Attributes?["select"]?.InnerText ?? string.Empty;

                Gear objGear = new Gear(this);
                objGear.Create(xmlGearData, intRating, lstWeapons, strForceValue);

                if (objGear.InternalId.IsEmptyGuid())
                    continue;

                objGear.Quantity = decQty;

                // If a Commlink has just been added, see if the character already has one. If not, make it the active Commlink.
                if (ActiveCommlink == null && objGear.IsCommlink)
                {
                    objGear.SetActiveCommlink(this, true);
                }

                objGear.Cost = "0";
                // Create any Weapons that came with this Gear.
                foreach (Weapon objWeapon in lstWeapons)
                    Weapons.Add(objWeapon);

                objGear.ParentID = Guid.NewGuid().ToString();

                Gear.Add(objGear);

                ImprovementManager.CreateImprovement(this, objGear.InternalId, Improvement.ImprovementSource.Metatype,
                    string.Empty, Improvement.ImprovementType.Gear, string.Empty);
                ImprovementManager.Commit(this);
            }

            // Add any created Weapons to the character.
            foreach (Weapon objWeapon in lstWeapons)
                Weapons.Add(objWeapon);

            // Sprites can never have Physical Attributes
            if (DEPEnabled || strSelectedMetatypeCategory?.EndsWith("Sprite", StringComparison.Ordinal) == true ||
                strSelectedMetatypeCategory?.EndsWith("Sprites", StringComparison.Ordinal) == true)
            {
                BOD.AssignLimits(0, 0, 0);
                AGI.AssignLimits(0, 0, 0);
                REA.AssignLimits(0, 0, 0);
                STR.AssignLimits(0, 0, 0);
                MAG.AssignLimits(0, 0, 0);
                MAGAdept.AssignLimits(0, 0, 0);
            }

            if (strSelectedMetatypeCategory == "Spirits")
            {
                XmlNode xmlOptionalPowersNode = charNode["optionalpowers"];
                if (xmlOptionalPowersNode != null && intForce >= 3)
                {
                    XmlDocument objDummyDocument = new XmlDocument {XmlResolver = null};
                    //For every 3 full points of Force a spirit has, it may gain one Optional Power.
                    for (int i = intForce - 3; i >= 0; i -= 3)
                    {
                        XmlNode bonusNode = objDummyDocument.CreateNode(XmlNodeType.Element, "bonus", null);
                        XmlNode powerNode = objDummyDocument.ImportNode(xmlOptionalPowersNode.CloneNode(true), true);
                        bonusNode.AppendChild(powerNode);
                        objDummyDocument.AppendChild(bonusNode);
                    }

                    foreach (XmlNode bonusNode in objDummyDocument.SelectNodes("/bonus"))
                        ImprovementManager.CreateImprovements(this, Improvement.ImprovementSource.Metatype,
                            strMetatypeId, bonusNode, 1, strMetatypeId);
                }

                // Remove the Critter's Materialization Power if they have it. Add the Possession or Inhabitation Power if the Possession-based Tradition checkbox is checked.
                if (xmlCritterPowerDocumentPowersNode != null)
                {
                    if (!string.IsNullOrEmpty(strSelectedPossessionMethod))
                    {
                        CritterPower objMaterializationPower =
                            CritterPowers.FirstOrDefault(x => x.Name == "Materialization");
                        if (objMaterializationPower != null)
                            CritterPowers.Remove(objMaterializationPower);

                        if (CritterPowers.All(x => !x.Name.Contains(strSelectedPossessionMethod)))
                        {
                            // Add the selected Power.
                            XmlNode objXmlCritterPower =
                                xmlCritterPowerDocumentPowersNode.SelectSingleNode("power[name = " +
                                    strSelectedPossessionMethod.CleanXPath() + ']');
                            if (objXmlCritterPower != null)
                            {
                                CritterPower objPower = new CritterPower(this);
                                objPower.Create(objXmlCritterPower, 0, string.Empty);
                                objPower.CountTowardsLimit = false;
                                CritterPowers.Add(objPower);

                                ImprovementManager.CreateImprovement(this, objPower.InternalId,
                                    Improvement.ImprovementSource.Metatype, string.Empty,
                                    Improvement.ImprovementType.CritterPower, string.Empty);
                                ImprovementManager.Commit(this);
                            }
                        }
                    }
                    else if (CritterPowers.All(x => x.Name != "Materialization" && !x.Name.Contains("Possession") && !x.Name.Contains("Inhabitation")))
                    {
                        // Add the Materialization Power.
                        XmlNode objXmlCritterPower =
                            xmlCritterPowerDocumentPowersNode.SelectSingleNode("power[name = \"Materialization\"]");
                        if (objXmlCritterPower != null)
                        {
                            CritterPower objPower = new CritterPower(this);
                            objPower.Create(objXmlCritterPower, 0, string.Empty);
                            objPower.CountTowardsLimit = false;
                            CritterPowers.Add(objPower);

                            ImprovementManager.CreateImprovement(this, objPower.InternalId,
                                Improvement.ImprovementSource.Metatype, string.Empty,
                                Improvement.ImprovementType.CritterPower, string.Empty);
                            ImprovementManager.Commit(this);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Save the Character to an XML file. Returns true if successful.
        /// </summary>
        public bool Save(string strFileName = "", bool addToMRU = true, bool callOnSaveCallBack = true)
        {
            if (IsSaving)
                return false;
            if (string.IsNullOrWhiteSpace(strFileName))
            {
                strFileName = _strFileName;
                if (string.IsNullOrWhiteSpace(strFileName))
                {
                    return false;
                }
            }

            bool blnErrorFree = true;
            IsSaving = true;
            using (MemoryStream objStream = new MemoryStream())
            {
                using (XmlTextWriter objWriter = new XmlTextWriter(objStream, Encoding.UTF8)
                {
                    Formatting = Formatting.Indented,
                    Indentation = 1,
                    IndentChar = '\t'
                })
                {
                    objWriter.WriteStartDocument();

                    // <character>
                    objWriter.WriteStartElement("character");

                    // <createdversion />
                    objWriter.WriteElementString("createdversion", _strVersionCreated);
                    // <minimumappversion />
                    objWriter.WriteElementString("minimumappversion", "5.214.1");
                    // <appversion />
                    objWriter.WriteElementString("appversion",
                        Application.ProductVersion.FastEscapeOnceFromStart("0.0."));
                    // <gameedition />
                    objWriter.WriteElementString("gameedition", "SR5");

                    // <settings />
                    objWriter.WriteElementString("settings", _strSettingsKey);
                    // <buildmethod />
                    objWriter.WriteElementString("buildmethod", Settings.BuildMethod.ToString());

                    // <sources>
                    objWriter.WriteStartElement("sources");
                    foreach (string strBook in Settings.Books)
                    {
                        objWriter.WriteElementString("source", strBook);
                    }

                    // </sources>
                    objWriter.WriteEndElement();

                    if (Settings.EnabledCustomDataDirectoryInfos.Count > 0)
                    {
                        // <customdatadirectorynames>
                        objWriter.WriteStartElement("customdatadirectorynames");
                        foreach (string strDirectoryName in Settings.EnabledCustomDataDirectoryInfos.Select(x => x.Name))
                        {
                            objWriter.WriteElementString("directoryname", strDirectoryName);
                        }

                        // </customdatadirectorynames>
                        objWriter.WriteEndElement();
                    }

                    // <metatype />
                    objWriter.WriteElementString("metatype", _strMetatype);
                    // <metatypeid />
                    objWriter.WriteElementString("metatypeid",
                        _guiMetatype.ToString("D", GlobalSettings.InvariantCultureInfo));
                    // <metatypebp />
                    objWriter.WriteElementString("metatypebp",
                        _intMetatypeBP.ToString(GlobalSettings.InvariantCultureInfo));
                    // <metavariant />
                    objWriter.WriteElementString("metavariant", _strMetavariant);
                    // <metavariantid />
                    objWriter.WriteElementString("metavariantid",
                        _guiMetavariant.ToString("D", GlobalSettings.InvariantCultureInfo));
                    // <metatypecategory />
                    objWriter.WriteElementString("metatypecategory", _strMetatypeCategory);
                    // <movement />
                    objWriter.WriteElementString("movement", _strMovement);
                    // <walk />
                    objWriter.WriteElementString("walk", _strWalk);
                    // <run />
                    objWriter.WriteElementString("run", _strRun);
                    // <sprint />
                    objWriter.WriteElementString("sprint", _strSprint);
                    // <walk />
                    objWriter.WriteElementString("walkalt", _strWalk);
                    // <run />
                    objWriter.WriteElementString("runalt", _strRun);
                    // <sprint />
                    objWriter.WriteElementString("sprintalt", _strSprint);
                    // <initiativedice />
                    objWriter.WriteElementString("initiativedice",
                        _intInitiativeDice.ToString(GlobalSettings.InvariantCultureInfo));

                    // <prioritymetatype />
                    objWriter.WriteElementString("prioritymetatype", _strPriorityMetatype);
                    // <priorityattributes />
                    objWriter.WriteElementString("priorityattributes", _strPriorityAttributes);
                    // <priorityspecial />
                    objWriter.WriteElementString("priorityspecial", _strPrioritySpecial);
                    // <priorityskills />
                    objWriter.WriteElementString("priorityskills", _strPrioritySkills);
                    // <priorityresources />
                    objWriter.WriteElementString("priorityresources", _strPriorityResources);
                    // <priorityresources />
                    objWriter.WriteElementString("prioritytalent", _strPriorityTalent);
                    // <priorityskills >
                    objWriter.WriteStartElement("priorityskills");
                    foreach (string strSkill in _lstPrioritySkills)
                    {
                        objWriter.WriteElementString("priorityskill", strSkill);
                    }

                    // </priorityskills>
                    objWriter.WriteEndElement();

                    // <essenceatspecialstart />
                    objWriter.WriteElementString("essenceatspecialstart",
                        _decEssenceAtSpecialStart.ToString(GlobalSettings.InvariantCultureInfo));

                    // <name />
                    objWriter.WriteElementString("name", _strName);
                    SaveMugshots(objWriter);

                    // <gender />
                    objWriter.WriteElementString("gender", _strGender);
                    // <age />
                    objWriter.WriteElementString("age", _strAge);
                    // <eyes />
                    objWriter.WriteElementString("eyes", _strEyes);
                    // <height />
                    objWriter.WriteElementString("height", _strHeight);
                    // <weight />
                    objWriter.WriteElementString("weight", _strWeight);
                    // <skin />
                    objWriter.WriteElementString("skin", _strSkin);
                    // <hair />
                    objWriter.WriteElementString("hair", _strHair);
                    // <description />
                    objWriter.WriteElementString("description", _strDescription);
                    // <background />
                    objWriter.WriteElementString("background", _strBackground);
                    // <concept />
                    objWriter.WriteElementString("concept", _strConcept);
                    // <notes />
                    objWriter.WriteElementString("notes",
                        System.Text.RegularExpressions.Regex.Replace(_strNotes,
                            @"[\u0000-\u0008\u000B\u000C\u000E-\u001F]", ""));
                    // <alias />
                    objWriter.WriteElementString("alias", _strAlias);
                    // <playername />
                    objWriter.WriteElementString("playername", _strPlayerName);
                    // <gamenotes />
                    objWriter.WriteElementString("gamenotes", _strGameNotes);
                    // <primaryarm />
                    objWriter.WriteElementString("primaryarm", _strPrimaryArm);

                    // <ignorerules />
                    if (_blnIgnoreRules)
                        objWriter.WriteElementString("ignorerules",
                            _blnIgnoreRules.ToString(GlobalSettings.InvariantCultureInfo));
                    // <iscritter />
                    if (_blnIsCritter)
                        objWriter.WriteElementString("iscritter",
                            _blnIsCritter.ToString(GlobalSettings.InvariantCultureInfo));
                    if (_blnPossessed)
                        objWriter.WriteElementString("possessed",
                            _blnPossessed.ToString(GlobalSettings.InvariantCultureInfo));
                    // <karma />
                    objWriter.WriteElementString("karma", _intKarma.ToString(GlobalSettings.InvariantCultureInfo));
                    // <special />
                    objWriter.WriteElementString("special", _intSpecial.ToString(GlobalSettings.InvariantCultureInfo));
                    // <totalspecial />
                    objWriter.WriteElementString("totalspecial",
                        _intTotalSpecial.ToString(GlobalSettings.InvariantCultureInfo));
                    // <totalattributes />
                    objWriter.WriteElementString("totalattributes",
                        _intTotalAttributes.ToString(GlobalSettings.InvariantCultureInfo));
                    // <edgeused />
                    objWriter.WriteElementString("edgeused", _intEdgeUsed.ToString(GlobalSettings.InvariantCultureInfo));
                    // <contactpoints />
                    objWriter.WriteElementString("contactpoints",
                        _intCachedContactPoints.ToString(GlobalSettings.InvariantCultureInfo));
                    // <contactpoints />
                    objWriter.WriteElementString("contactpointsused",
                        _intContactPointsUsed.ToString(GlobalSettings.InvariantCultureInfo));
                    // <spelllimit />
                    objWriter.WriteElementString("spelllimit",
                        _intFreeSpells.ToString(GlobalSettings.InvariantCultureInfo));
                    // <cfplimit />
                    objWriter.WriteElementString("cfplimit", _intCFPLimit.ToString(GlobalSettings.InvariantCultureInfo));
                    // <totalaiprogramlimit />
                    objWriter.WriteElementString("ainormalprogramlimit",
                        _intAINormalProgramLimit.ToString(GlobalSettings.InvariantCultureInfo));
                    // <aiadvancedprogramlimit />
                    objWriter.WriteElementString("aiadvancedprogramlimit",
                        _intAIAdvancedProgramLimit.ToString(GlobalSettings.InvariantCultureInfo));
                    // <currentcounterspellingdice />
                    objWriter.WriteElementString("currentcounterspellingdice",
                        _intCurrentCounterspellingDice.ToString(GlobalSettings.InvariantCultureInfo));
                    // <streetcred />
                    objWriter.WriteElementString("streetcred",
                        _intStreetCred.ToString(GlobalSettings.InvariantCultureInfo));
                    // <notoriety />
                    objWriter.WriteElementString("notoriety",
                        _intNotoriety.ToString(GlobalSettings.InvariantCultureInfo));
                    // <publicaware />
                    objWriter.WriteElementString("publicawareness",
                        _intPublicAwareness.ToString(GlobalSettings.InvariantCultureInfo));
                    // <burntstreetcred />
                    objWriter.WriteElementString("burntstreetcred",
                        _intBurntStreetCred.ToString(GlobalSettings.InvariantCultureInfo));
                    // <baseastralreputation />
                    objWriter.WriteElementString("baseastralreputation",
                        _intBaseAstralReputation.ToString(GlobalSettings.InvariantCultureInfo));
                    // <basewildreputation />
                    objWriter.WriteElementString("basewildreputation",
                        _intBaseWildReputation.ToString(GlobalSettings.InvariantCultureInfo));
                    // <created />
                    objWriter.WriteElementString("created", _blnCreated.ToString(GlobalSettings.InvariantCultureInfo));
                    // <nuyen />
                    objWriter.WriteElementString("nuyen", _decNuyen.ToString(GlobalSettings.InvariantCultureInfo));
                    // <startingnuyen />
                    objWriter.WriteElementString("startingnuyen",
                        _decStartingNuyen.ToString(GlobalSettings.InvariantCultureInfo));

                    // <nuyenbp />
                    objWriter.WriteElementString("nuyenbp", _decNuyenBP.ToString(GlobalSettings.InvariantCultureInfo));

                    // <adept />
                    objWriter.WriteElementString("adept",
                        _blnAdeptEnabled.ToString(GlobalSettings.InvariantCultureInfo));
                    // <magician />
                    objWriter.WriteElementString("magician",
                        _blnMagicianEnabled.ToString(GlobalSettings.InvariantCultureInfo));
                    // <technomancer />
                    objWriter.WriteElementString("technomancer",
                        _blnTechnomancerEnabled.ToString(GlobalSettings.InvariantCultureInfo));
                    // <ai />
                    objWriter.WriteElementString("ai",
                        _blnAdvancedProgramsEnabled.ToString(GlobalSettings.InvariantCultureInfo));
                    // <cyberwaredisabled />
                    objWriter.WriteElementString("cyberwaredisabled",
                        _blnCyberwareDisabled.ToString(GlobalSettings.InvariantCultureInfo));
                    // <initiationdisabled />
                    objWriter.WriteElementString("initiationdisabled",
                        _blnInitiationDisabled.ToString(GlobalSettings.InvariantCultureInfo));
                    // <critter />
                    objWriter.WriteElementString("critter",
                        _blnCritterEnabled.ToString(GlobalSettings.InvariantCultureInfo));

                    // <prototypetranshuman />
                    objWriter.WriteElementString("prototypetranshuman",
                        _decPrototypeTranshuman.ToString(GlobalSettings.InvariantCultureInfo));

                    // <attributes>
                    objWriter.WriteStartElement("attributes");
                    AttributeSection.Save(objWriter);
                    // </attributes>
                    objWriter.WriteEndElement();

                    // <magenabled />
                    objWriter.WriteElementString("magenabled",
                        _blnMAGEnabled.ToString(GlobalSettings.InvariantCultureInfo));
                    // <initiategrade />
                    objWriter.WriteElementString("initiategrade",
                        _intInitiateGrade.ToString(GlobalSettings.InvariantCultureInfo));
                    // <resenabled />
                    objWriter.WriteElementString("resenabled",
                        _blnRESEnabled.ToString(GlobalSettings.InvariantCultureInfo));
                    // <submersiongrade />
                    objWriter.WriteElementString("submersiongrade",
                        _intSubmersionGrade.ToString(GlobalSettings.InvariantCultureInfo));
                    // <depenabled />
                    objWriter.WriteElementString("depenabled",
                        _blnDEPEnabled.ToString(GlobalSettings.InvariantCultureInfo));
                    // <groupmember />
                    objWriter.WriteElementString("groupmember",
                        _blnGroupMember.ToString(GlobalSettings.InvariantCultureInfo));
                    // <groupname />
                    objWriter.WriteElementString("groupname", _strGroupName);
                    // <groupnotes />
                    objWriter.WriteElementString("groupnotes", _strGroupNotes);

                    // External reader friendly stuff.
                    objWriter.WriteElementString("totaless", Essence().ToString(GlobalSettings.InvariantCultureInfo));

                    // Write out the Mystic Adept MAG split info.
                    if (_blnAdeptEnabled && _blnMagicianEnabled)
                    {
                        objWriter.WriteElementString("magsplitadept",
                            _intMAGAdept.ToString(GlobalSettings.InvariantCultureInfo));
                        objWriter.WriteElementString("magsplitmagician",
                            _intMAGMagician.ToString(GlobalSettings.InvariantCultureInfo));
                    }

                    _objTradition?.Save(objWriter);

                    // Condition Monitor Progress.
                    // <physicalcmfilled />
                    objWriter.WriteElementString("physicalcmfilled",
                        _intPhysicalCMFilled.ToString(GlobalSettings.InvariantCultureInfo));
                    // <stuncmfilled />
                    objWriter.WriteElementString("stuncmfilled",
                        _intStunCMFilled.ToString(GlobalSettings.InvariantCultureInfo));

                    //<psyche />
                    objWriter.WriteElementString("psyche",
                        _blnPsycheActive.ToString(GlobalSettings.InvariantCultureInfo));

                    ///////////////////////////////////////////SKILLS

                    SkillsSection.Save(objWriter);

                    //Write copy of old skill groups, to not totally fuck a file if error
                    _oldSkillGroupBackup?.WriteTo(objWriter);
                    _oldSkillsBackup?.WriteTo(objWriter);

                    ///////////////////////////////////////////SKILLS

                    // <contacts>
                    objWriter.WriteStartElement("contacts");
                    foreach (Contact objContact in _lstContacts)
                    {
                        objContact.Save(objWriter);
                    }

                    // </contacts>
                    objWriter.WriteEndElement();

                    // <spells>
                    objWriter.WriteStartElement("spells");
                    foreach (Spell objSpell in _lstSpells)
                    {
                        objSpell.Save(objWriter);
                    }

                    // </spells>
                    objWriter.WriteEndElement();

                    // <foci>
                    objWriter.WriteStartElement("foci");
                    foreach (Focus objFocus in _lstFoci)
                    {
                        objFocus.Save(objWriter);
                    }

                    // </foci>
                    objWriter.WriteEndElement();

                    // <stackedfoci>
                    objWriter.WriteStartElement("stackedfoci");
                    foreach (StackedFocus objStack in _lstStackedFoci)
                    {
                        objStack.Save(objWriter);
                    }

                    // </stackedfoci>
                    objWriter.WriteEndElement();

                    // <powers>
                    objWriter.WriteStartElement("powers");
                    foreach (Power objPower in _lstPowers)
                    {
                        objPower.Save(objWriter);
                    }

                    // </powers>
                    objWriter.WriteEndElement();

                    // <spirits>
                    objWriter.WriteStartElement("spirits");
                    foreach (Spirit objSpirit in _lstSpirits)
                    {
                        objSpirit.Save(objWriter);
                    }

                    // </spirits>
                    objWriter.WriteEndElement();

                    // <complexforms>
                    objWriter.WriteStartElement("complexforms");
                    foreach (ComplexForm objComplexForm in _lstComplexForms)
                    {
                        objComplexForm.Save(objWriter);
                    }

                    // </complexforms>
                    objWriter.WriteEndElement();

                    // <aiprograms>
                    objWriter.WriteStartElement("aiprograms");
                    foreach (AIProgram objProgram in _lstAIPrograms)
                    {
                        objProgram.Save(objWriter);
                    }

                    // </aiprograms>
                    objWriter.WriteEndElement();

                    // <martialarts>
                    objWriter.WriteStartElement("martialarts");
                    foreach (MartialArt objMartialArt in _lstMartialArts)
                    {
                        objMartialArt.Save(objWriter);
                    }

                    // </martialarts>
                    objWriter.WriteEndElement();

                    // <limitmodifiers>
                    objWriter.WriteStartElement("limitmodifiers");
                    foreach (LimitModifier objLimitModifier in _lstLimitModifiers)
                    {
                        objLimitModifier.Save(objWriter);
                    }

                    // </limitmodifiers>
                    objWriter.WriteEndElement();

                    // <armors>
                    objWriter.WriteStartElement("armors");
                    foreach (Armor objArmor in _lstArmor)
                    {
                        objArmor.Save(objWriter);
                    }

                    // </armors>
                    objWriter.WriteEndElement();

                    // <weapons>
                    objWriter.WriteStartElement("weapons");
                    foreach (Weapon objWeapon in _lstWeapons)
                    {
                        objWeapon.Save(objWriter);
                    }

                    // </weapons>
                    objWriter.WriteEndElement();

                    // <cyberwares>
                    objWriter.WriteStartElement("cyberwares");
                    foreach (Cyberware objCyberware in _lstCyberware)
                    {
                        objCyberware.Save(objWriter);
                    }

                    // </cyberwares>
                    objWriter.WriteEndElement();

                    // <qualities>
                    objWriter.WriteStartElement("qualities");
                    foreach (Quality objQuality in _lstQualities)
                    {
                        objQuality.Save(objWriter);
                    }

                    // </qualities>
                    objWriter.WriteEndElement();

                    // <lifestyles>
                    objWriter.WriteStartElement("lifestyles");
                    foreach (Lifestyle objLifestyle in _lstLifestyles)
                    {
                        objLifestyle.Save(objWriter);
                    }

                    // </lifestyles>
                    objWriter.WriteEndElement();

                    // <gears>
                    objWriter.WriteStartElement("gears");
                    foreach (Gear objGear in _lstGear)
                    {
                        objGear.Save(objWriter);
                    }

                    // </gears>
                    objWriter.WriteEndElement();

                    // <vehicles>
                    objWriter.WriteStartElement("vehicles");
                    foreach (Vehicle objVehicle in _lstVehicles)
                    {
                        objVehicle.Save(objWriter);
                    }

                    // </vehicles>
                    objWriter.WriteEndElement();

                    // <metamagics>
                    objWriter.WriteStartElement("metamagics");
                    foreach (Metamagic objMetamagic in _lstMetamagics)
                    {
                        objMetamagic.Save(objWriter);
                    }

                    // </metamagics>
                    objWriter.WriteEndElement();

                    // <arts>
                    objWriter.WriteStartElement("arts");
                    foreach (Art objArt in _lstArts)
                    {
                        objArt.Save(objWriter);
                    }

                    // </arts>
                    objWriter.WriteEndElement();

                    // <enhancements>
                    objWriter.WriteStartElement("enhancements");
                    foreach (Enhancement objEnhancement in _lstEnhancements)
                    {
                        objEnhancement.Save(objWriter);
                    }

                    // </enhancements>
                    objWriter.WriteEndElement();

                    // <critterpowers>
                    objWriter.WriteStartElement("critterpowers");
                    foreach (CritterPower objPower in _lstCritterPowers)
                    {
                        objPower.Save(objWriter);
                    }

                    // </critterpowers>
                    objWriter.WriteEndElement();

                    // <initiationgrades>
                    objWriter.WriteStartElement("initiationgrades");
                    foreach (InitiationGrade objGrade in _lstInitiationGrades)
                    {
                        objGrade.Save(objWriter);
                    }

                    // </initiationgrades>
                    objWriter.WriteEndElement();

                    // <improvements>
                    objWriter.WriteStartElement("improvements");
                    foreach (Improvement objImprovement in _lstImprovements)
                    {
                        objImprovement.Save(objWriter);
                    }

                    // </improvements>
                    objWriter.WriteEndElement();

                    // <sustained>
                    objWriter.WriteStartElement("sustainedobjects");
                    foreach (SustainedObject objSustained in _lstSustainedObjects)
                    {
                        objSustained.Save(objWriter);
                    }

                    // </sustained>
                    objWriter.WriteEndElement();

                    // <drugs>
                    objWriter.WriteStartElement("drugs");
                    foreach (Drug objDrug in _lstDrugs)
                    {
                        objDrug.Save(objWriter);
                    }

                    // </drugs>
                    objWriter.WriteEndElement();

                    // <mentorspirits>
                    objWriter.WriteStartElement("mentorspirits");
                    foreach (MentorSpirit objMentor in _lstMentorSpirits)
                    {
                        objMentor.Save(objWriter);
                    }

                    // </mentorspirits>
                    objWriter.WriteEndElement();

                    // <expenses>
                    objWriter.WriteStartElement("expenses");
                    foreach (ExpenseLogEntry objExpenseLogEntry in _lstExpenseLog)
                    {
                        objExpenseLogEntry.Save(objWriter);
                    }

                    // </expenses>
                    objWriter.WriteEndElement();

                    // <locations>
                    objWriter.WriteStartElement("gearlocations");
                    foreach (Location objLocation in _lstGearLocations)
                    {
                        objLocation.Save(objWriter);
                    }

                    // </locations>
                    objWriter.WriteEndElement();

                    // <armorlocations>
                    objWriter.WriteStartElement("armorlocations");
                    foreach (Location objLocation in _lstArmorLocations)
                    {
                        objLocation.Save(objWriter);
                    }

                    // </armorlocations>
                    objWriter.WriteEndElement();

                    // <vehiclelocations>
                    objWriter.WriteStartElement("vehiclelocations");
                    foreach (Location objLocation in _lstVehicleLocations)
                    {
                        objLocation.Save(objWriter);
                    }

                    // </vehiclelocations>
                    objWriter.WriteEndElement();

                    // <weaponlocations>
                    objWriter.WriteStartElement("weaponlocations");
                    foreach (Location objLocation in _lstWeaponLocations)
                    {
                        objLocation.Save(objWriter);
                    }

                    // </weaponlocations>
                    objWriter.WriteEndElement();

                    // <improvementgroups>
                    objWriter.WriteStartElement("improvementgroups");
                    foreach (string strGroup in _lstImprovementGroups)
                    {
                        objWriter.WriteElementString("improvementgroup", strGroup);
                    }

                    // </improvementgroups>
                    objWriter.WriteEndElement();

                    // <calendar>
                    objWriter.WriteStartElement("calendar");
                    foreach (CalendarWeek objWeek in _lstCalendar)
                    {
                        objWeek.Save(objWriter);
                    }

                    objWriter.WriteEndElement();
                    // </calendar>

                    //Plugins
                    if (Program.PluginLoader?.MyActivePlugins?.Count > 0)
                    {
                        // <plugins>
                        objWriter.WriteStartElement("plugins");
                        foreach (IPlugin plugin in Program.PluginLoader.MyActivePlugins)
                        {
                            try
                            {
                                System.Reflection.Assembly pluginAssm = plugin.GetPluginAssembly();
                                objWriter.WriteStartElement(pluginAssm.GetName().Name);
                                objWriter.WriteAttributeString("version", pluginAssm.GetName().Version.ToString());
                                objWriter.WriteString(plugin.GetSaveToFileElement(this));
                                objWriter.WriteEndElement();
                            }
                            catch (Exception e)
                            {
                                Log.Warn(e, "Exception while writing saveFileElement for plugin " + plugin + ": ");
                            }
                        }

                        //</plugins>
                        objWriter.WriteEndElement();
                    }

                    //calculatedValues
                    objWriter.WriteStartElement("calculatedvalues");
                    objWriter.WriteComment(
                        "these values are not loaded and only stored here for third parties, who parse this files (to not have to calculate them themselves)");
                    objWriter.WriteElementString("physicalcm", PhysicalCM.ToString(GlobalSettings.InvariantCultureInfo));
                    objWriter.WriteElementString("physicalcmthresholdoffset",
                        PhysicalCMThresholdOffset.ToString(GlobalSettings.InvariantCultureInfo));
                    objWriter.WriteElementString("physicalcmoverflow",
                        CMOverflow.ToString(GlobalSettings.InvariantCultureInfo));
                    objWriter.WriteElementString("stuncm", StunCM.ToString(GlobalSettings.InvariantCultureInfo));
                    objWriter.WriteElementString("stuncmthresholdoffset",
                        StunCMThresholdOffset.ToString(GlobalSettings.InvariantCultureInfo));
                    objWriter.WriteEndElement();
                    // </calculatedValues>

                    // </character>
                    objWriter.WriteEndElement();

                    objWriter.WriteEndDocument();
                    objWriter.Flush();
                    objStream.Position = 0;

                    // Validate that the character can save properly. If there's no error, save the file to the listed file location.
                    try
                    {
                        XmlDocument objDoc = new XmlDocument {XmlResolver = null};
                        using (XmlReader objXmlReader =
                            XmlReader.Create(objStream, GlobalSettings.SafeXmlReaderSettings))
                            objDoc.Load(objXmlReader);
                        objDoc.Save(strFileName);
                    }
                    catch (IOException e)
                    {
                        Log.Error(e);
                        if (Utils.IsUnitTest)
                            throw;
                        Program.MainForm.ShowMessageBox(LanguageManager.GetString("Message_Save_Error_Warning"));
                        blnErrorFree = false;
                    }
                    catch (XmlException ex)
                    {
                        Log.Warn(ex);
                        if (Utils.IsUnitTest)
                            throw;
                        Program.MainForm.ShowMessageBox(LanguageManager.GetString("Message_Save_Error_Warning"));
                        blnErrorFree = false;
                    }
                    catch (UnauthorizedAccessException) when (!Utils.IsUnitTest)
                    {
                        Program.MainForm.ShowMessageBox(LanguageManager.GetString("Message_Save_Error_Warning"));
                        blnErrorFree = false;
                    }
                }
            }

            if (addToMRU)
                GlobalSettings.MostRecentlyUsedCharacters.Insert(0, FileName);

            IsSaving = false;
            _dateFileLastWriteTime = File.GetLastWriteTimeUtc(strFileName);

            if (callOnSaveCallBack)
            {
                // Cannot use foreach or LINQ because we need to be able to allow queued functions to add onto the queue
                // ReSharper disable once ForCanBeConvertedToForeach
                for (int i = 0; i < DoOnSaveCompleted.Count; ++i)
                {
                    Func<Character, bool> funcLoopToRun = DoOnSaveCompleted[i];
                    if (funcLoopToRun?.Invoke(this) != true)
                        blnErrorFree = false;
                }
            }
            return blnErrorFree;
        }

        /// <summary>
        /// Syntactic sugar for XmlManager.LoadXPath() where we use the current enabled custom data directory list from our options file.
        /// XPathDocuments are usually faster than XmlDocuments, but are read-only and take longer to load if live custom data is enabled
        /// Returns a new XPathNavigator associated with the XPathDocument so that multiple threads each get their own navigator if they're called on the same file
        /// </summary>
        /// <param name="strFileName">Name of the XML file to load.</param>
        /// <param name="strLanguage">Language in which to load the data document.</param>
        /// <param name="blnLoadFile">Whether to force reloading content even if the file already exists.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public XPathNavigator LoadDataXPath(string strFileName, string strLanguage = "", bool blnLoadFile = false)
        {
            return XmlManager.LoadXPath(strFileName, Settings.EnabledCustomDataDirectoryPaths, strLanguage, blnLoadFile);
        }

        /// <summary>
        /// Syntactic sugar for XmlManager.LoadXPathAsync() where we use the current enabled custom data directory list from our options file.
        /// XPathDocuments are usually faster than XmlDocuments, but are read-only and take longer to load if live custom data is enabled
        /// Returns a new XPathNavigator associated with the XPathDocument so that multiple threads each get their own navigator if they're called on the same file
        /// </summary>
        /// <param name="strFileName">Name of the XML file to load.</param>
        /// <param name="strLanguage">Language in which to load the data document.</param>
        /// <param name="blnLoadFile">Whether to force reloading content even if the file already exists.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Task<XPathNavigator> LoadDataXPathAsync(string strFileName, string strLanguage = "",
            bool blnLoadFile = false)
        {
            return XmlManager.LoadXPathAsync(strFileName, Settings.EnabledCustomDataDirectoryPaths, strLanguage,
                blnLoadFile);
        }

        /// <summary>
        /// Syntactic sugar for XmlManager.Load() where we use the current enabled custom data directory list from our options file.
        /// </summary>
        /// <param name="strFileName">Name of the XML file to load.</param>
        /// <param name="strLanguage">Language in which to load the data document.</param>
        /// <param name="blnLoadFile">Whether to force reloading content even if the file already exists.</param>
        [NotNull]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public XmlDocument LoadData(string strFileName, string strLanguage = "", bool blnLoadFile = false)
        {
            return XmlManager.Load(strFileName, Settings.EnabledCustomDataDirectoryPaths, strLanguage, blnLoadFile);
        }

        /// <summary>
        /// Syntactic sugar for XmlManager.LoadAsync() where we use the current enabled custom data directory list from our options file.
        /// </summary>
        /// <param name="strFileName">Name of the XML file to load.</param>
        /// <param name="strLanguage">Language in which to load the data document.</param>
        /// <param name="blnLoadFile">Whether to force reloading content even if the file already exists.</param>
        [NotNull]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Task<XmlDocument> LoadDataAsync(string strFileName, string strLanguage = "", bool blnLoadFile = false)
        {
            return XmlManager.LoadAsync(strFileName, Settings.EnabledCustomDataDirectoryPaths, strLanguage, blnLoadFile);
        }

        /// <summary>
        /// Set to true while data is being populated by the Load function
        /// </summary>
        public bool IsLoading { get; set; }

        /// <summary>
        /// Set to true while the Load method is running, makes sure we don't call (async) Load multiple times.
        /// </summary>
        public bool IsLoadMethodRunning { get; set; }

        /// <summary>
        /// Queue of methods to execute after loading has finished. Return value signals whether loading should continue after execution (True) or terminate/cancel (False).
        /// </summary>
        public Queue<Func<bool>> PostLoadMethods { get; } = new Queue<Func<bool>>();

        /// <summary>
        /// Load the Character from an XML file synchronously.
        /// </summary>
        /// <param name="frmLoadingForm">Instance of frmLoading to use to update with loading progress. frmLoading::PerformStep() is called 35 times within this method, so plan accordingly.</param>
        /// <param name="showWarnings">Whether warnings about book content and other character content should be loaded.</param>
        public bool Load(LoadingBar frmLoadingForm = null, bool showWarnings = true)
        {
            return LoadCoreAysnc(true, frmLoadingForm, showWarnings).GetAwaiter().GetResult();
        }

        /// <summary>
        /// Load the Character from an XML file asynchronously.
        /// </summary>
        /// <param name="frmLoadingForm">Instance of frmLoading to use to update with loading progress. frmLoading::PerformStep() is called 35 times within this method, so plan accordingly.</param>
        /// <param name="showWarnings">Whether warnings about book content and other character content should be loaded.</param>
        public Task<bool> LoadAsync(LoadingBar frmLoadingForm = null, bool showWarnings = true)
        {
            return LoadCoreAysnc(false, frmLoadingForm, showWarnings);
        }

        public const int NumLoadingSections = 37;

        /// <summary>
        /// Load the Character from an XML file.
        /// Uses flag hack method design outlined here to avoid locking:
        /// https://docs.microsoft.com/en-us/archive/msdn-magazine/2015/july/async-programming-brownfield-async-development
        /// </summary>
        /// <param name="blnSync">Flag for whether method should always use synchronous code or not.</param>
        /// <param name="frmLoadingForm">Instance of frmLoading to use to update with loading progress. frmLoading::PerformStep() is called NumLoadingSections times within this method, so plan accordingly.</param>
        /// <param name="showWarnings">Whether warnings about book content and other character content should be loaded.</param>
        private async Task<bool> LoadCoreAysnc(bool blnSync, LoadingBar frmLoadingForm = null, bool showWarnings = true)
        {
            if (!File.Exists(_strFileName))
                return false;
            while (IsLoadMethodRunning)
            {
                if (blnSync)
                    Utils.SafeSleep();
                else
                    await Utils.SafeSleepAsync();
            }

            IsLoadMethodRunning = true;
            LoadAsDirty = false;
            try
            {
                using (CustomActivity loadActivity = Timekeeper.StartSyncron("clsCharacter.Load", null,
                                                                             CustomActivity.OperationType.DependencyOperation, _strFileName))
                {
                    try
                    {
                        using (_ = Timekeeper.StartSyncron("upload_AI_options", loadActivity))
                        {
                            UploadObjectAsMetric.UploadObject(TelemetryClient, Settings);
                        }

                        XmlDocument objXmlDocument = new XmlDocument {XmlResolver = null};
                        XmlNode objXmlCharacter = null;
                        XPathNavigator xmlCharacterNavigator = null;
                        Quality objLivingPersonaQuality = null;

                        frmLoadingForm?.PerformStep("XML");

                        using (_ = Timekeeper.StartSyncron("load_xml", loadActivity))
                        {
                            if (!File.Exists(_strFileName))
                                return false;
                            bool blnKeepLoading = blnSync
                                ? LoadSaveFileDocument()
                                : await Task.Run(LoadSaveFileDocument);

                            bool LoadSaveFileDocument()
                            {
                                bool blnErrorCaught = false;
                                do
                                {
                                    try
                                    {
                                        objXmlDocument.LoadStandard(_strFileName, !blnErrorCaught);
                                        blnErrorCaught = false;
                                    }
                                    catch (XmlException ex)
                                    {
                                        if (System.Text.RegularExpressions.Regex.IsMatch(ex.Message,
                                            GlobalSettings.InvalidXmlCharacterRegex))
                                        {
                                            /*If we found a known control character that's preventing the character from
                                            being loaded (Expected to be notes ingested from PDF mostly) prompt the user whether to use unsafe methods.
                                            If yes, restart the load, explicitly ignoring invalid characters.*/

                                            if (Program.MainForm.ShowMessageBox(
                                                LanguageManager.GetString("Message_InvalidTextFound"),
                                                LanguageManager.GetString("Message_InvalidTextFound_Title"),
                                                MessageBoxButtons.YesNo, MessageBoxIcon.Warning) == DialogResult.No)
                                            {
                                                return false;
                                            }

                                            blnErrorCaught = true;
                                        }
                                        else
                                        {
                                            if (showWarnings)
                                            {
                                                Program.MainForm.ShowMessageBox(
                                                    string.Format(GlobalSettings.CultureInfo,
                                                        LanguageManager.GetString("Message_FailedLoad"), ex.Message),
                                                    string.Format(GlobalSettings.CultureInfo,
                                                        LanguageManager.GetString("MessageTitle_FailedLoad"),
                                                        ex.Message),
                                                    MessageBoxButtons.OK, MessageBoxIcon.Error);
                                            }

                                            return false;
                                        }
                                    }
                                } while (blnErrorCaught);

                                objXmlCharacter = objXmlDocument.SelectSingleNode("/character");
                                xmlCharacterNavigator =
                                    objXmlDocument.GetFastNavigator().SelectSingleNode("/character");
                                return true;
                            }

                            if (!blnKeepLoading || objXmlCharacter == null || xmlCharacterNavigator == null)
                            {
                                return false;
                            }

                            //Timekeeper.Finish("load_xml");
                        }

                        IsLoading = true;

                        try
                        {
                            frmLoadingForm?.PerformStep(
                                blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? LanguageManager.GetString("String_Settings")
                                    : await LanguageManager.GetStringAsync("String_Settings"));

                            using (_ = Timekeeper.StartSyncron("load_char_misc", loadActivity))
                            {
                                _dateFileLastWriteTime = File.GetLastWriteTimeUtc(_strFileName);

                                xmlCharacterNavigator.TryGetBoolFieldQuickly("ignorerules", ref _blnIgnoreRules);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("created", ref _blnCreated);

                                ResetCharacter();

                                // Get the game edition of the file if possible and make sure it's intended to be used with this version of the application.
                                string strGameEdition = string.Empty;
                                if (xmlCharacterNavigator.TryGetStringFieldQuickly("gameedition", ref strGameEdition) &&
                                    !string.IsNullOrEmpty(strGameEdition) && strGameEdition != "SR5" && showWarnings &&
                                    !Utils.IsUnitTest)
                                {
                                    Program.MainForm.ShowMessageBox(
                                        blnSync
                                            // ReSharper disable once MethodHasAsyncOverload
                                            ? LanguageManager.GetString("Message_IncorrectGameVersion_SR4")
                                            : await LanguageManager.GetStringAsync("Message_IncorrectGameVersion_SR4"),
                                        blnSync
                                            // ReSharper disable once MethodHasAsyncOverload
                                            ? LanguageManager.GetString("MessageTitle_IncorrectGameVersion")
                                            : await LanguageManager.GetStringAsync("MessageTitle_IncorrectGameVersion"),
                                        MessageBoxButtons.YesNo,
                                        MessageBoxIcon.Error);
                                    return false;
                                }

                                string strVersion = string.Empty;
                                //Check to see if the character was created in a version of Chummer later than the currently installed one.
                                if (xmlCharacterNavigator.TryGetStringFieldQuickly("appversion", ref strVersion) &&
                                    !string.IsNullOrEmpty(strVersion))
                                {
                                    strVersion = strVersion.TrimStartOnce("0.");

                                    if (!VersionExtensions.TryParse(strVersion, out _verSavedVersion))
                                    {
                                        _verSavedVersion = Utils.IsUnitTest
                                            ? new Version(int.MaxValue, int.MaxValue, int.MaxValue)
                                            : new Version();
                                    }
                                    // Check for typo in Corrupter quality and correct it
                                    else if (_verSavedVersion?.CompareTo(new Version(5, 188, 34)) == -1)
                                    {
                                        objXmlDocument.InnerXml =
                                            objXmlDocument.InnerXml.Replace("Corruptor", "Corrupter");
                                        xmlCharacterNavigator =
                                            objXmlDocument.GetFastNavigator().SelectSingleNode("/character");
                                        if (xmlCharacterNavigator == null)
                                            return false;
                                    }
                                }
#if !DEBUG
                                if (!Utils.IsUnitTest)
                                {
                                    string strMinimumVersion = string.Empty;
                                    // Check to see if a character has a minimum version set where they will not load properly on anything older
                                    if (xmlCharacterNavigator.TryGetStringFieldQuickly("minimumappversion", ref strMinimumVersion) &&
                                        !string.IsNullOrEmpty(strMinimumVersion))
                                    {
                                        strMinimumVersion = strMinimumVersion.TrimStartOnce("0.");
                                        if (Version.TryParse(strMinimumVersion, out Version objMinimumVersion) && objMinimumVersion > Program.CurrentVersion)
                                        {
                                            Program.MainForm.ShowMessageBox(
                                                string.Format(GlobalSettings.CultureInfo,
                                                    LanguageManager.GetString("Message_OlderThanChummerSaveMinimumVersion"),
                                                    objMinimumVersion, Program.CurrentVersion),
                                                LanguageManager.GetString("MessageTitle_OlderThanChummerSaveMinimumVersion"),
                                                MessageBoxButtons.OK,
                                                MessageBoxIcon.Error);
                                            return false;
                                        }
                                    }
                                    if (_verSavedVersion > Program.CurrentVersion && DialogResult.Yes != Program.MainForm.ShowMessageBox(
                                        string.Format(GlobalSettings.CultureInfo, LanguageManager.GetString("Message_OutdatedChummerSave"),
                                            _verSavedVersion, Program.CurrentVersion),
                                        LanguageManager.GetString("MessageTitle_OutdatedChummerSave"),
                                        MessageBoxButtons.YesNo,
                                        MessageBoxIcon.Warning))
                                    {
                                        return false;
                                    }
                                }
#endif

                                // Get the name of the settings file in use if possible.
                                xmlCharacterNavigator.TryGetStringFieldQuickly("settings", ref _strSettingsKey);

                                // Load the character's settings file.
                                string strDummy = string.Empty;
                                if (!xmlCharacterNavigator.TryGetStringFieldQuickly("buildmethod", ref strDummy)
                                    || !Enum.TryParse(strDummy, true, out CharacterBuildMethod eSavedBuildMethod))
                                {
                                    eSavedBuildMethod = SettingsManager.LoadedCharacterSettings.TryGetValue(
                                        GlobalSettings.DefaultCharacterSettingDefaultValue,
                                        out CharacterSettings objSettings) ? objSettings.BuildMethod : CharacterBuildMethod.Priority;
                                }

                                if (!SettingsManager.LoadedCharacterSettings.TryGetValue(
                                        GlobalSettings.DefaultCharacterSetting,
                                        out CharacterSettings objDefaultSettings)
                                    && !SettingsManager.LoadedCharacterSettings.TryGetValue(
                                        GlobalSettings.DefaultCharacterSettingDefaultValue, out objDefaultSettings))
                                    objDefaultSettings = SettingsManager.LoadedCharacterSettings.Values.First();

                                CharacterSettings objProspectiveSettings;
                                bool blnShowSelectBP = false;
                                using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                           out HashSet<string> setSavedBooks))
                                {
                                    foreach (XPathNavigator xmlBook in xmlCharacterNavigator.SelectAndCacheExpression(
                                                 "sources/source"))
                                    {
                                        if (!string.IsNullOrEmpty(xmlBook.Value))
                                            setSavedBooks.Add(xmlBook.Value);
                                    }

                                    if (setSavedBooks.Count == 0)
                                        setSavedBooks.AddRange(objDefaultSettings.Books);

                                    XPathNodeIterator xmlCustomDirectoryNames = xmlCharacterNavigator
                                        .SelectAndCacheExpression(
                                            "customdatadirectorynames/directoryname");
                                    List<string> lstSavedCustomDataDirectoryNames
                                        = new List<string>(xmlCustomDirectoryNames.Count);
                                    foreach (XPathNavigator xmlCustomDataDirectoryName in xmlCustomDirectoryNames)
                                    {
                                        if (!string.IsNullOrEmpty(xmlCustomDataDirectoryName.Value))
                                            lstSavedCustomDataDirectoryNames.Add(xmlCustomDataDirectoryName.Value);
                                    }

                                    decimal decLegacyMaxNuyen = objDefaultSettings.NuyenMaximumBP;
                                    xmlCharacterNavigator.TryGetDecFieldQuickly("maxnuyen", ref decLegacyMaxNuyen);
                                    int intLegacyMaxKarma = objDefaultSettings.BuildKarma;
                                    xmlCharacterNavigator.TryGetInt32FieldQuickly("maxkarma", ref intLegacyMaxKarma);

                                    // Calculate a score for a character option that roughly coincides with how suitable it is as a replacement for the current one the character save contains
                                    // Settings with a negative score should not be considered suitable at all
                                    int CalculateCharacterSettingsMatchScore(CharacterSettings objOptionsToCheck)
                                    {
                                        int intReturn = objOptionsToCheck.BuiltInOption ? 0 : 1;
                                        int intDummy = intLegacyMaxKarma - objOptionsToCheck.BuildKarma;
                                        intReturn -= intDummy.RaiseToPower(2);
                                        intDummy = decLegacyMaxNuyen.StandardRound() -
                                                   objOptionsToCheck.NuyenMaximumBP.StandardRound();
                                        intReturn -= intDummy.RaiseToPower(2);
                                        int intBaseline = decLegacyMaxNuyen.StandardRound().RaiseToPower(2) +
                                                          intLegacyMaxKarma.RaiseToPower(2);
                                        intDummy = setSavedBooks.Count *
                                                   (lstSavedCustomDataDirectoryNames.Count + 1) *
                                                   intBaseline;
                                        if (Created && eSavedBuildMethod != CharacterBuildMethod.LifeModule)
                                        {
                                            if (objOptionsToCheck.BuildMethod == eSavedBuildMethod)
                                            {
                                                intReturn += int.MaxValue / 2 + 4;
                                            }
                                            else if (objOptionsToCheck.BuildMethod.UsesPriorityTables() ==
                                                     eSavedBuildMethod.UsesPriorityTables())
                                            {
                                                intReturn += int.MaxValue / 2 + 2;
                                            }
                                            else
                                                intReturn += int.MaxValue / 2;
                                        }
                                        else if (objOptionsToCheck.BuildMethod == eSavedBuildMethod)
                                        {
                                            intReturn += int.MaxValue / 2 + intDummy.RaiseToPower(2);
                                        }
                                        else if (objOptionsToCheck.BuildMethod.UsesPriorityTables() ==
                                                 eSavedBuildMethod.UsesPriorityTables())
                                        {
                                            intReturn += int.MaxValue / 2 + intDummy.RaiseToPower(2) / 2;
                                        }

                                        for (int i = 0;
                                             i < objOptionsToCheck.EnabledCustomDataDirectoryInfos.Count;
                                             ++i)
                                        {
                                            string strLoopCustomDataName =
                                                objOptionsToCheck.EnabledCustomDataDirectoryInfos[i].Name;
                                            int intLoopIndex =
                                                lstSavedCustomDataDirectoryNames.IndexOf(strLoopCustomDataName);
                                            if (intLoopIndex < 0)
                                                intReturn -= objOptionsToCheck.EnabledCustomDataDirectoryInfos.Count
                                                                              .RaiseToPower(2) *
                                                             intBaseline;
                                            else
                                                intReturn -= (i - intLoopIndex).RaiseToPower(2) * intBaseline;
                                        }

                                        foreach (string strLoopCustomDataName in lstSavedCustomDataDirectoryNames)
                                        {
                                            if (objOptionsToCheck.EnabledCustomDataDirectoryInfos.All(
                                                    x => x.Name != strLoopCustomDataName))
                                                intReturn -= objOptionsToCheck.EnabledCustomDataDirectoryInfos.Count
                                                                              .RaiseToPower(2) *
                                                             intBaseline;
                                        }

                                        int intBookBaselineScore =
                                            (lstSavedCustomDataDirectoryNames.Count + 1) * intBaseline;
                                        using (new FetchSafelyFromPool<HashSet<string>>(
                                                   Utils.StringHashSetPool, out HashSet<string> setDummyBooks))
                                        {
                                            setDummyBooks.AddRange(setSavedBooks);
                                            setDummyBooks.IntersectWith(objOptionsToCheck.Books);
                                            intReturn -= ((setSavedBooks.Count - setDummyBooks.Count).RaiseToPower(4)
                                                          + (objOptionsToCheck.Books.Count - setDummyBooks.Count)
                                                          .RaiseToPower(2))
                                                         * intBookBaselineScore;
                                        }

                                        return intReturn;
                                    }

                                    if (!SettingsManager.LoadedCharacterSettings.TryGetValue(
                                            _strSettingsKey, out objProspectiveSettings))
                                    {
                                        // Prompt if we want to switch options or leave
                                        if (!Utils.IsUnitTest && showWarnings)
                                        {
                                            if (Program.MainForm.ShowMessageBox(
                                                    string.Format(GlobalSettings.CultureInfo,
                                                                  blnSync
                                                                      // ReSharper disable once MethodHasAsyncOverload
                                                                      ? LanguageManager.GetString("Message_CharacterOptions_CannotLoadSetting")
                                                                      : await LanguageManager.GetStringAsync("Message_CharacterOptions_CannotLoadSetting"),
                                                                  Path.GetFileNameWithoutExtension(_strSettingsKey)),
                                                    blnSync
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        ? LanguageManager.GetString("MessageTitle_CharacterOptions_CannotLoadSetting")
                                                        : await LanguageManager.GetStringAsync("MessageTitle_CharacterOptions_CannotLoadSetting"),
                                                    MessageBoxButtons.YesNo) == DialogResult.No)
                                            {
                                                return false;
                                            }

                                            blnShowSelectBP = true;
                                        }

                                        // Set up interim options for selection by build method
                                        string strReplacementSettingsKey = string.Empty;
                                        int intMostSuitable = 0;
                                        foreach (KeyValuePair<string, CharacterSettings> kvpLoopOptions in
                                                 SettingsManager
                                                     .LoadedCharacterSettings)
                                        {
                                            int intLoopScore
                                                = CalculateCharacterSettingsMatchScore(kvpLoopOptions.Value);
                                            if (intLoopScore > intMostSuitable)
                                            {
                                                intMostSuitable = intLoopScore;
                                                strReplacementSettingsKey = kvpLoopOptions.Key;
                                            }
                                        }

                                        if (string.IsNullOrEmpty(strReplacementSettingsKey)
                                            || !SettingsManager.LoadedCharacterSettings.TryGetValue(
                                                strReplacementSettingsKey, out objProspectiveSettings))
                                        {
                                            strReplacementSettingsKey
                                                = GlobalSettings.DefaultCharacterSettingDefaultValue;
                                            if (!SettingsManager.LoadedCharacterSettings.TryGetValue(
                                                    strReplacementSettingsKey, out objProspectiveSettings))
                                            {
                                                objProspectiveSettings
                                                    = SettingsManager.LoadedCharacterSettings.Values.First();
                                                strReplacementSettingsKey = objProspectiveSettings.DictionaryKey;
                                            }
                                        }

                                        _strSettingsKey = strReplacementSettingsKey;
                                        LoadAsDirty = true;
                                    }
                                    else if (!Created && objProspectiveSettings.BuildMethod != eSavedBuildMethod)
                                    {
                                        // Prompt if we want to switch options or leave
                                        if (!Utils.IsUnitTest && showWarnings)
                                        {
                                            if (Program.MainForm.ShowMessageBox(
                                                    string.Format(GlobalSettings.CultureInfo,
                                                                  blnSync
                                                                      // ReSharper disable once MethodHasAsyncOverload
                                                                      ? LanguageManager.GetString(
                                                                          "Message_CharacterOptions_DesyncBuildMethod")
                                                                      : await LanguageManager.GetStringAsync(
                                                                          "Message_CharacterOptions_DesyncBuildMethod"),
                                                                  Path.GetFileNameWithoutExtension(_strSettingsKey),
                                                                  blnSync
                                                                      // ReSharper disable once MethodHasAsyncOverload
                                                                      ? LanguageManager.GetString(
                                                                          "String_" + objProspectiveSettings
                                                                              .BuildMethod)
                                                                      : await LanguageManager.GetStringAsync(
                                                                          "String_" + objProspectiveSettings
                                                                              .BuildMethod),
                                                                  blnSync
                                                                      // ReSharper disable once MethodHasAsyncOverload
                                                                      ? LanguageManager.GetString(
                                                                          "String_" + eSavedBuildMethod)
                                                                      : await LanguageManager.GetStringAsync(
                                                                          "String_" + eSavedBuildMethod)),
                                                    blnSync
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        ? LanguageManager.GetString(
                                                            "MessageTitle_CharacterOptions_DesyncBuildMethod")
                                                        : await LanguageManager.GetStringAsync(
                                                            "MessageTitle_CharacterOptions_DesyncBuildMethod"),
                                                    MessageBoxButtons.YesNo) == DialogResult.No)
                                            {
                                                return false;
                                            }

                                            blnShowSelectBP = true;
                                        }

                                        // Set up interim options for selection by build method
                                        string strReplacementSettingsKey = string.Empty;
                                        int intMostSuitable = 0;
                                        foreach (KeyValuePair<string, CharacterSettings> kvpLoopOptions in
                                                 SettingsManager
                                                     .LoadedCharacterSettings)
                                        {
                                            int intLoopScore
                                                = CalculateCharacterSettingsMatchScore(kvpLoopOptions.Value);
                                            if (intLoopScore > intMostSuitable)
                                            {
                                                intMostSuitable = intLoopScore;
                                                strReplacementSettingsKey = kvpLoopOptions.Key;
                                            }
                                        }

                                        if (string.IsNullOrEmpty(strReplacementSettingsKey)
                                            || !SettingsManager.LoadedCharacterSettings.TryGetValue(
                                                strReplacementSettingsKey, out objProspectiveSettings))
                                        {
                                            strReplacementSettingsKey
                                                = GlobalSettings.DefaultCharacterSettingDefaultValue;
                                            if (!SettingsManager.LoadedCharacterSettings.TryGetValue(
                                                    strReplacementSettingsKey, out objProspectiveSettings))
                                            {
                                                objProspectiveSettings
                                                    = SettingsManager.LoadedCharacterSettings.Values.First();
                                                strReplacementSettingsKey = objProspectiveSettings.DictionaryKey;
                                            }
                                        }

                                        _strSettingsKey = strReplacementSettingsKey;
                                        LoadAsDirty = true;
                                    }
                                    // Legacy load stuff
                                    else if (!Utils.IsUnitTest && showWarnings &&
                                             (setSavedBooks.Count > 0 || lstSavedCustomDataDirectoryNames.Count > 0))
                                    {
                                        CharacterSettings objCurrentlyLoadedSettings = objProspectiveSettings;
                                        // More books is fine, so just test if the stored book list is a subset of the current option's book list
                                        bool blnPromptConfirmSetting =
                                            !setSavedBooks.IsSubsetOf(objCurrentlyLoadedSettings.Books);
                                        if (!blnPromptConfirmSetting)
                                        {
                                            // More custom data directories is not fine because additional ones might apply rules that weren't present before, so prompt
                                            blnPromptConfirmSetting = lstSavedCustomDataDirectoryNames.Count !=
                                                                      objCurrentlyLoadedSettings
                                                                          .EnabledCustomDataDirectoryInfos
                                                                          .Count;
                                            if (!blnPromptConfirmSetting)
                                            {
                                                // Check to make sure all the names are the same
                                                for (int i = 0; i < lstSavedCustomDataDirectoryNames.Count; ++i)
                                                {
                                                    if (lstSavedCustomDataDirectoryNames[i]
                                                        != objCurrentlyLoadedSettings.EnabledCustomDataDirectoryInfos[i]
                                                            .Name)
                                                    {
                                                        blnPromptConfirmSetting = true;
                                                        break;
                                                    }
                                                }
                                            }
                                        }

                                        if (blnPromptConfirmSetting)
                                        {
                                            DialogResult eShowBPResult = Program.MainForm.ShowMessageBox(string.Format(
                                                    GlobalSettings.CultureInfo,
                                                    blnSync
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        ? LanguageManager.GetString(
                                                            "Message_CharacterOptions_DesyncBooksOrCustomData")
                                                        : await LanguageManager.GetStringAsync(
                                                            "Message_CharacterOptions_DesyncBooksOrCustomData"),
                                                    objCurrentlyLoadedSettings.Name),
                                                blnSync
                                                    // ReSharper disable once MethodHasAsyncOverload
                                                    ? LanguageManager.GetString(
                                                        "MessageTitle_CharacterOptions_DesyncBooksOrCustomData")
                                                    : await LanguageManager.GetStringAsync(
                                                        "MessageTitle_CharacterOptions_DesyncBooksOrCustomData"),
                                                MessageBoxButtons.YesNoCancel);
                                            if (eShowBPResult == DialogResult.Cancel)
                                            {
                                                return false;
                                            }

                                            blnShowSelectBP = eShowBPResult == DialogResult.Yes;
                                        }
                                    }
                                }

                                Settings = objProspectiveSettings;

                                if (blnShowSelectBP)
                                {
                                    LoadAsDirty = true;
                                    DialogResult ePickBPResult;
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverload
                                        ePickBPResult = Program.MainForm.DoThreadSafeFunc(ShowBP);
                                    else
                                        ePickBPResult = await Program.MainForm.DoThreadSafeFuncAsync(ShowBP);
                                    DialogResult ShowBP()
                                    {
                                        using (SelectBuildMethod frmPickBP = new SelectBuildMethod(this, true))
                                        {
                                            frmPickBP.ShowDialogSafe(Program.GetFormForDialog(this));
                                            return frmPickBP.DialogResult;
                                        }
                                    }
                                    if (ePickBPResult != DialogResult.OK)
                                    {
                                        return false;
                                    }
                                }

                                if (xmlCharacterNavigator.TryGetDecFieldQuickly("essenceatspecialstart",
                                    ref _decEssenceAtSpecialStart) && _decEssenceAtSpecialStart > ESS.MetatypeMaximum)
                                {
                                    // fix to work around a mistake made when saving decimal values in previous versions.
                                    _decEssenceAtSpecialStart /= 10;
                                }

                                xmlCharacterNavigator.TryGetStringFieldQuickly("createdversion",
                                    ref _strVersionCreated);

                                // Metatype information.
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("iscritter", ref _blnIsCritter);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("metatype", ref _strMetatype);
                                if (!xmlCharacterNavigator.TryGetGuidFieldQuickly("metatypeid", ref _guiMetatype)
                                    && !Guid.TryParse(GetNodeXPath(true)?.SelectSingleNode("id")?.Value, out _guiMetatype))
                                {
                                    return false;
                                }

                                xmlCharacterNavigator.TryGetStringFieldQuickly("movement", ref _strMovement);

                                xmlCharacterNavigator.TryGetStringFieldQuickly("walk", ref _strWalk);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("run", ref _strRun);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("sprint", ref _strSprint);

                                _strRunAlt = xmlCharacterNavigator.SelectSingleNode("run/@alt")?.Value ?? string.Empty;
                                _strWalkAlt = xmlCharacterNavigator.SelectSingleNode("walk/@alt")?.Value ??
                                              string.Empty;
                                _strSprintAlt = xmlCharacterNavigator.SelectSingleNode("sprint/@alt")?.Value ??
                                                string.Empty;
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("initiativedice", ref _intInitiativeDice);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("metatypebp", ref _intMetatypeBP);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("metavariant", ref _strMetavariant);
                                //Shim for characters created prior to Run Faster Errata
                                if (_strMetavariant == "Cyclopean")
                                {
                                    _strMetavariant = "Cyclops";
                                }

                                //Shim for metavariants that were saved with an incorrect metatype string.
                                if (!string.IsNullOrEmpty(_strMetavariant) && _strMetatype == _strMetavariant)
                                {
                                    _strMetatype = GetNodeXPath(true).SelectSingleNode("name")?.Value ?? "Human";
                                }

                                if (!xmlCharacterNavigator.TryGetGuidFieldQuickly("metavariantid",
                                        ref _guiMetavariant) &&
                                    !string.IsNullOrEmpty(_strMetavariant))
                                {
                                    _guiMetavariant = Guid.Parse(this.GetNodeXPath()?.SelectSingleNode("id")?.Value);
                                }

                                bool blnDoSourceFetch =
                                    !xmlCharacterNavigator.TryGetStringFieldQuickly("source", ref _strSource) ||
                                    string.IsNullOrEmpty(_strSource);
                                // ReSharper disable once ConvertIfToOrExpression
                                if (!xmlCharacterNavigator.TryGetStringFieldQuickly("page", ref _strPage) ||
                                    string.IsNullOrEmpty(_strPage) || _strPage == "0")
                                    blnDoSourceFetch = true;
                                if (blnDoSourceFetch)
                                {
                                    XPathNavigator xmlCharNode = this.GetNodeXPath();
                                    if (xmlCharNode != null)
                                    {
                                        _strSource = xmlCharNode.SelectSingleNode("source")?.Value ?? _strSource;
                                        _strPage = xmlCharNode.SelectSingleNode("page")?.Value ?? _strPage;
                                    }
                                }

                                xmlCharacterNavigator.TryGetStringFieldQuickly("metatypecategory",
                                    ref _strMetatypeCategory);

                                // General character information.
                                xmlCharacterNavigator.TryGetStringFieldQuickly("name", ref _strName);
                                LoadMugshots(xmlCharacterNavigator);
                                if (!xmlCharacterNavigator.TryGetStringFieldQuickly("gender", ref _strGender))
                                    xmlCharacterNavigator.TryGetStringFieldQuickly("sex", ref _strGender);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("age", ref _strAge);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("eyes", ref _strEyes);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("height", ref _strHeight);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("weight", ref _strWeight);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("skin", ref _strSkin);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("hair", ref _strHair);
                                xmlCharacterNavigator.TryGetMultiLineStringFieldQuickly("description",
                                    ref _strDescription);
                                xmlCharacterNavigator.TryGetMultiLineStringFieldQuickly("background",
                                    ref _strBackground);
                                xmlCharacterNavigator.TryGetMultiLineStringFieldQuickly("concept", ref _strConcept);
                                xmlCharacterNavigator.TryGetMultiLineStringFieldQuickly("notes", ref _strNotes);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("alias", ref _strAlias);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("playername", ref _strPlayerName);
                                xmlCharacterNavigator.TryGetMultiLineStringFieldQuickly("gamenotes", ref _strGameNotes);
                                if (!xmlCharacterNavigator.TryGetStringFieldQuickly("primaryarm", ref _strPrimaryArm))
                                    _strPrimaryArm = "Right";

                                xmlCharacterNavigator.TryGetStringFieldQuickly("prioritymetatype",
                                    ref _strPriorityMetatype);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("priorityattributes",
                                    ref _strPriorityAttributes);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("priorityspecial",
                                    ref _strPrioritySpecial);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("priorityskills",
                                    ref _strPrioritySkills);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("priorityresources",
                                    ref _strPriorityResources);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("prioritytalent",
                                    ref _strPriorityTalent);
                                _lstPrioritySkills.Clear();
                                foreach (XPathNavigator xmlSkillName in xmlCharacterNavigator.SelectAndCacheExpression(
                                    "priorityskills/priorityskill")
                                )
                                {
                                    _lstPrioritySkills.Add(xmlSkillName.Value);
                                }

                                string strSkill1 = string.Empty;
                                string strSkill2 = string.Empty;
                                if (xmlCharacterNavigator.TryGetStringFieldQuickly("priorityskill1", ref strSkill1) &&
                                    !string.IsNullOrEmpty(strSkill1))
                                    _lstPrioritySkills.Add(strSkill1);
                                if (xmlCharacterNavigator.TryGetStringFieldQuickly("priorityskill2", ref strSkill2) &&
                                    !string.IsNullOrEmpty(strSkill2))
                                    _lstPrioritySkills.Add(strSkill2);

                                xmlCharacterNavigator.TryGetBoolFieldQuickly("possessed", ref _blnPossessed);

                                xmlCharacterNavigator.TryGetInt32FieldQuickly("contactpoints",
                                    ref _intCachedContactPoints);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("contactpointsused",
                                    ref _intContactPointsUsed);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("cfplimit", ref _intCFPLimit);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("ainormalprogramlimit",
                                    ref _intAINormalProgramLimit);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("aiadvancedprogramlimit",
                                    ref _intAIAdvancedProgramLimit);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("currentcounterspellingdice",
                                    ref _intCurrentCounterspellingDice);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("spelllimit", ref _intFreeSpells);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("karma", ref _intKarma);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("totalkarma", ref _intTotalKarma);

                                xmlCharacterNavigator.TryGetInt32FieldQuickly("special", ref _intSpecial);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("totalspecial", ref _intTotalSpecial);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("totalattributes",
                                    ref _intTotalAttributes);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("edgeused", ref _intEdgeUsed);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("contactpoints",
                                    ref _intCachedContactPoints);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("contactpointsused",
                                    ref _intContactPointsUsed);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("streetcred", ref _intStreetCred);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("notoriety", ref _intNotoriety);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("publicawareness",
                                    ref _intPublicAwareness);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("burntstreetcred",
                                    ref _intBurntStreetCred);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("baseastralreputation",
                                    ref _intBaseAstralReputation);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("basewildreputation",
                                    ref _intBaseWildReputation);
                                xmlCharacterNavigator.TryGetDecFieldQuickly("nuyen", ref _decNuyen);
                                xmlCharacterNavigator.TryGetDecFieldQuickly("startingnuyen", ref _decStartingNuyen);
                                xmlCharacterNavigator.TryGetDecFieldQuickly("nuyenbp", ref _decNuyenBP);

                                xmlCharacterNavigator.TryGetBoolFieldQuickly("adept", ref _blnAdeptEnabled);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("magician", ref _blnMagicianEnabled);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("technomancer",
                                    ref _blnTechnomancerEnabled);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("ai", ref _blnAdvancedProgramsEnabled);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("cyberwaredisabled",
                                    ref _blnCyberwareDisabled);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("initiationdisabled",
                                    ref _blnInitiationDisabled);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("critter", ref _blnCritterEnabled);

                                xmlCharacterNavigator.TryGetDecFieldQuickly("prototypetranshuman",
                                    ref _decPrototypeTranshuman);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("magenabled", ref _blnMAGEnabled);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("initiategrade", ref _intInitiateGrade);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("resenabled", ref _blnRESEnabled);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("submersiongrade",
                                    ref _intSubmersionGrade);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("depenabled", ref _blnDEPEnabled);
                                // Legacy shim
                                if (!_blnCreated && !_blnMAGEnabled && !_blnRESEnabled && !_blnDEPEnabled)
                                    _decEssenceAtSpecialStart = decimal.MinValue;
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("groupmember", ref _blnGroupMember);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("groupname", ref _strGroupName);
                                xmlCharacterNavigator.TryGetMultiLineStringFieldQuickly("groupnotes",
                                    ref _strGroupNotes);
                                //end load_char_misc
                            }

                            XmlNodeList objXmlNodeList;
                            XmlNodeList objXmlLocationList;
                            XmlNode xmlRootQualitiesNode;

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("String_MentorSpirit")
                                                            : await LanguageManager.GetStringAsync("String_MentorSpirit"));

                            using (_ = Timekeeper.StartSyncron("load_char_mentorspirit", loadActivity))
                            {
                                // Improvements.
                                objXmlNodeList = objXmlCharacter.SelectNodes("mentorspirits/mentorspirit");
                                foreach (XmlNode objXmlMentor in objXmlNodeList)
                                {
                                    MentorSpirit objMentor = new MentorSpirit(this, objXmlMentor);
                                    objMentor.Load(objXmlMentor);
                                    _lstMentorSpirits.Add(objMentor);
                                }

                                //using finish("load_char_mentorspirit");
                            }

                            List<Improvement> lstCyberadeptSweepGrades = new List<Improvement>(InitiationGrades.Count);
                            _lstInternalIdsNeedingReapplyImprovements.Clear();

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("Tab_Improvements")
                                                            : await LanguageManager.GetStringAsync("Tab_Improvements"));

                            using (_ = Timekeeper.StartSyncron("load_char_imp", loadActivity))
                            {
                                // Improvements.
                                objXmlNodeList = objXmlCharacter.SelectNodes("improvements/improvement");
                                string strCharacterInnerXml = objXmlCharacter.InnerXml;
                                bool blnRemoveImprovements = Utils.IsUnitTest;
                                foreach (XmlNode objXmlImprovement in objXmlNodeList)
                                {
                                    string strImprovementSource = objXmlImprovement["improvementsource"]?.InnerText;
                                    switch (strImprovementSource)
                                    {
                                        // Do not load condition monitor improvements from older versions of Chummer
                                        case "ConditionMonitor":
                                            continue;
                                        // Load Edge use improvements from older versions of Chummer directly into Character's Edge Use property
                                        case "EdgeUse":
                                            decimal decOldEdgeUsed = 0;
                                            if (objXmlImprovement.TryGetDecFieldQuickly("aug", ref decOldEdgeUsed))
                                                EdgeUsed = (-decOldEdgeUsed).StandardRound();
                                            continue;
                                        case "EssenceLoss":
                                        case "EssenceLossChargen":
                                            // Do not load essence loss improvements if this character does not have any attributes affected by essence loss
                                            if (_decEssenceAtSpecialStart == decimal.MinValue)
                                                continue;
                                            break;
                                    }

                                    string strLoopSourceName = objXmlImprovement["sourcename"]?.InnerText;
                                    if ((blnRemoveImprovements || showWarnings)
                                        && !string.IsNullOrEmpty(strLoopSourceName)
                                        && strLoopSourceName.IsGuid()
                                        && objXmlImprovement["custom"]?.InnerText != bool.TrueString)
                                    {
                                        // Hacky way to make sure this character isn't loading in any orphaned improvements.
                                        // SourceName ID will pop up minimum twice in the save if the improvement's source is actually present:
                                        // once in the improvement and once in the parent that added it.
                                        int intFirstIdIndex =
                                            strCharacterInnerXml.IndexOf(strLoopSourceName, StringComparison.Ordinal);
                                        int intLastIdIndex =
                                            strCharacterInnerXml.LastIndexOf(strLoopSourceName,
                                                StringComparison.Ordinal);
                                        // Catch orphaned improvements that used to have the same source parent by making sure that at least one of
                                        // the IDs found is not an improvement's `<sourcename>` node's contents.
                                        // Spans are faster than substrings because they do not make allocations, so that is why they are used
                                        if (intFirstIdIndex >= 12
                                            && strCharacterInnerXml.AsSpan(intFirstIdIndex - 12, 12) ==
                                            "<sourcename>".AsSpan())
                                        {
                                            while (intLastIdIndex > intFirstIdIndex
                                                   && strCharacterInnerXml.AsSpan(intLastIdIndex - 12, 12) ==
                                                   "<sourcename>".AsSpan())
                                            {
                                                intLastIdIndex =
                                                    strCharacterInnerXml.LastIndexOf(strLoopSourceName, intLastIdIndex,
                                                        StringComparison.Ordinal);
                                            }
                                        }

                                        if (intFirstIdIndex == intLastIdIndex)
                                        {
                                            //Utils.BreakIfDebug();
                                            if (blnRemoveImprovements
                                                || (Program.MainForm.ShowMessageBox(
                                                    blnSync
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        ? LanguageManager.GetString("Message_OrphanedImprovements")
                                                        : await LanguageManager.GetStringAsync("Message_OrphanedImprovements"),
                                                    blnSync
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        ? LanguageManager.GetString("MessageTitle_OrphanedImprovements")
                                                        : await LanguageManager.GetStringAsync("MessageTitle_OrphanedImprovements"),
                                                    MessageBoxButtons.YesNo, MessageBoxIcon.Error) == DialogResult.Yes))
                                            {
                                                blnRemoveImprovements = true;
                                                continue;
                                            }

                                            return false;
                                        }
                                    }

                                    Improvement objImprovement = new Improvement(this);
                                    try
                                    {
                                        objImprovement.Load(objXmlImprovement);
                                        // This is initially set to false make sure no property changers are triggered
                                        objImprovement.SetupComplete = true;
                                        _lstImprovements.Add(objImprovement);

                                        if (objImprovement.ImproveType == Improvement.ImprovementType.SkillsoftAccess &&
                                            objImprovement.Value == 0)
                                        {
                                            _lstInternalIdsNeedingReapplyImprovements.Add(objImprovement.SourceName);
                                        }
                                        // Cyberadept fix
                                        else if (LastSavedVersion <= new Version(5, 212, 78)
                                                 && objImprovement.ImproveSource == Improvement.ImprovementSource.Echo
                                                 && objImprovement.ImproveType == Improvement.ImprovementType.Attribute
                                                 && objImprovement.ImprovedName == "RESBase"
                                                 && objImprovement.Value > 0
                                                 && objImprovement.Value == objImprovement.Augmented)
                                        {
                                            // Cyberadept in these versions was an echo. It is no longer an echo, and so needs a more complicated reapplication
                                            if (Settings.SpecialKarmaCostBasedOnShownValue)
                                                _lstImprovements.Remove(objImprovement);
                                            else
                                                lstCyberadeptSweepGrades.Add(objImprovement);
                                        }
                                    }
                                    catch (ArgumentException)
                                    {
                                        _lstInternalIdsNeedingReapplyImprovements.Add(
                                            objXmlImprovement["sourcename"]?.InnerText);
                                    }
                                }

                                //Timekeeper.Finish("load_char_imp");
                            }

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("Label_Contacts")
                                                            : await LanguageManager.GetStringAsync("Label_Contacts"));

                            using (_ = Timekeeper.StartSyncron("load_char_contacts", loadActivity))
                            {
                                // Contacts.
                                foreach (XPathNavigator xmlContact in xmlCharacterNavigator.SelectAndCacheExpression("contacts/contact"))
                                {
                                    Contact objContact = new Contact(this);
                                    objContact.Load(xmlContact);
                                    _lstContacts.Add(objContact);
                                }

                                //Timekeeper.Finish("load_char_contacts");
                            }

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("String_Qualities")
                                                            : await LanguageManager.GetStringAsync("String_Qualities"));

                            using (_ = Timekeeper.StartSyncron("load_char_quality", loadActivity))
                            {
                                // Qualities

                                objXmlNodeList = objXmlCharacter.SelectNodes("qualities/quality");
                                bool blnHasOldQualities = false;
                                xmlRootQualitiesNode =
                                    (blnSync
                                        // ReSharper disable once MethodHasAsyncOverload
                                        ? LoadData("qualities.xml")
                                        : await LoadDataAsync("qualities.xml"))
                                    .SelectSingleNode("/chummer/qualities");
                                foreach (XmlNode objXmlQuality in objXmlNodeList)
                                {
                                    if (objXmlQuality["name"] != null)
                                    {
                                        if (!CorrectedUnleveledQuality(objXmlQuality, xmlRootQualitiesNode))
                                        {
                                            Quality objQuality = new Quality(this);
                                            objQuality.Load(objXmlQuality);
                                            // Corrects an issue arising from older versions of CorrectedUnleveledQuality()
                                            if (_lstQualities.Any(x => x.InternalId == objQuality.InternalId))
                                                objQuality.SetGUID(Guid.NewGuid());
                                            _lstQualities.Add(objQuality);
                                            if (objQuality.GetNodeXPath()?.SelectSingleNode("bonus/addgear/name")
                                                    ?.Value ==
                                                "Living Persona")
                                                objLivingPersonaQuality = objQuality;
                                            // Legacy shim
                                            if (LastSavedVersion <= new Version(5, 195, 1)
                                                && (objQuality.Name == "The Artisan's Way"
                                                    || objQuality.Name == "The Artist's Way"
                                                    || objQuality.Name == "The Athlete's Way"
                                                    || objQuality.Name == "The Burnout's Way"
                                                    || objQuality.Name == "The Invisible Way"
                                                    || objQuality.Name == "The Magician's Way"
                                                    || objQuality.Name == "The Speaker's Way"
                                                    || objQuality.Name == "The Warrior's Way")
                                                && objQuality.Bonus?.HasChildNodes == false)
                                            {
                                                ImprovementManager.RemoveImprovements(this,
                                                    Improvement.ImprovementSource.Quality,
                                                    objQuality.InternalId);
                                                XmlNode objNode = objQuality.GetNode();
                                                if (objNode != null)
                                                {
                                                    objQuality.Bonus = objNode["bonus"];
                                                    if (objQuality.Bonus != null)
                                                    {
                                                        ImprovementManager.ForcedValue = objQuality.Extra;
                                                        ImprovementManager.CreateImprovements(this,
                                                            Improvement.ImprovementSource.Quality,
                                                            objQuality.InternalId, objQuality.Bonus, 1,
                                                            objQuality.DisplayNameShort(GlobalSettings.Language));
                                                        if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                                        {
                                                            objQuality.Extra = ImprovementManager.SelectedValue;
                                                        }
                                                    }

                                                    objQuality.FirstLevelBonus = objNode["firstlevelbonus"];
                                                    if (objQuality.FirstLevelBonus?.HasChildNodes == true)
                                                    {
                                                        bool blnDoFirstLevel = true;
                                                        foreach (Quality objCheckQuality in Qualities)
                                                        {
                                                            if (objCheckQuality != objQuality &&
                                                                objCheckQuality.SourceIDString ==
                                                                objQuality.SourceIDString &&
                                                                objCheckQuality.Extra == objQuality.Extra &&
                                                                objCheckQuality.SourceName == objQuality.SourceName)
                                                            {
                                                                blnDoFirstLevel = false;
                                                                break;
                                                            }
                                                        }

                                                        if (blnDoFirstLevel)
                                                        {
                                                            ImprovementManager.ForcedValue = objQuality.Extra;
                                                            ImprovementManager.CreateImprovements(this,
                                                                Improvement.ImprovementSource.Quality,
                                                                objQuality.InternalId,
                                                                objQuality.FirstLevelBonus, 1,
                                                                objQuality.DisplayNameShort(GlobalSettings.Language));
                                                            if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                                            {
                                                                objQuality.Extra = ImprovementManager.SelectedValue;
                                                            }
                                                        }
                                                    }
                                                }
                                                else
                                                {
                                                    // Failed to re-apply the improvements immediately, so let's just add it for processing when the character is opened
                                                    _lstInternalIdsNeedingReapplyImprovements
                                                        .Add(objQuality.InternalId);
                                                }
                                            }

                                            if (LastSavedVersion <= new Version(5, 200, 0)
                                                && objQuality.Name == "Made Man"
                                                && objQuality.Bonus["selectcontact"] != null)
                                            {
                                                string selectedContactUniqueId = (Improvements.FirstOrDefault(x =>
                                                        x.SourceName == objQuality.InternalId &&
                                                        x.ImproveType == Improvement.ImprovementType
                                                            .ContactForcedLoyalty))
                                                    ?.ImprovedName;
                                                if (string.IsNullOrWhiteSpace(selectedContactUniqueId))
                                                {
                                                    selectedContactUniqueId =
                                                        Contacts.FirstOrDefault(x => x.Name == objQuality.Extra)
                                                            ?.UniqueId;
                                                }

                                                if (string.IsNullOrWhiteSpace(selectedContactUniqueId))
                                                {
                                                    // Populate the Magician Traditions list.
                                                    using (new FetchSafelyFromPool<List<ListItem>>(
                                                               Utils.ListItemListPool, out List<ListItem> lstContacts))
                                                    {
                                                        foreach (Contact objContact in Contacts)
                                                        {
                                                            if (objContact.IsGroup)
                                                                lstContacts.Add(new ListItem(objContact.Name,
                                                                    objContact.UniqueId));
                                                        }

                                                        if (lstContacts.Count > 1)
                                                        {
                                                            lstContacts.Sort(CompareListItems.CompareNames);
                                                        }

                                                        DialogResult ePickItemResult = DialogResult.Cancel;
                                                        if (blnSync)
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            Program.MainForm.DoThreadSafe(DoSelectItem);
                                                        else
                                                            await Program.MainForm.DoThreadSafeAsync(DoSelectItem);

                                                        void DoSelectItem()
                                                        {
                                                            using (SelectItem frmPickItem = new SelectItem())
                                                            {
                                                                frmPickItem.SetDropdownItemsMode(lstContacts);
                                                                frmPickItem.ShowDialogSafe(Program.GetFormForDialog(this));

                                                                ePickItemResult = frmPickItem.DialogResult;
                                                                selectedContactUniqueId = frmPickItem.SelectedItem;
                                                            }
                                                        }

                                                        // Make sure the dialogue window was not canceled.
                                                        if (ePickItemResult != DialogResult.OK)
                                                        {
                                                            return false;
                                                        }
                                                    }
                                                }

                                                objQuality.Bonus =
                                                    xmlRootQualitiesNode.SelectSingleNode(
                                                        "quality[name=\"Made Man\"]/bonus");
                                                objQuality.Extra = string.Empty;
                                                ImprovementManager.RemoveImprovements(this,
                                                    Improvement.ImprovementSource.Quality,
                                                    objQuality.InternalId);
                                                ImprovementManager.CreateImprovement(this, string.Empty,
                                                    Improvement.ImprovementSource.Quality, objQuality.InternalId,
                                                    Improvement.ImprovementType.MadeMan,
                                                    objQuality.DisplayNameShort(GlobalSettings.Language));
                                                ImprovementManager.CreateImprovement(this, selectedContactUniqueId,
                                                    Improvement.ImprovementSource.Quality, objQuality.InternalId,
                                                    Improvement.ImprovementType.AddContact,
                                                    objQuality.DisplayNameShort(GlobalSettings.Language));
                                                ImprovementManager.CreateImprovement(this, selectedContactUniqueId,
                                                    Improvement.ImprovementSource.Quality, objQuality.InternalId,
                                                    Improvement.ImprovementType.ContactForcedLoyalty,
                                                    objQuality.DisplayNameShort(GlobalSettings.Language));
                                                ImprovementManager.CreateImprovement(this, selectedContactUniqueId,
                                                    Improvement.ImprovementSource.Quality, objQuality.InternalId,
                                                    Improvement.ImprovementType.ContactForceGroup,
                                                    objQuality.DisplayNameShort(GlobalSettings.Language));
                                                ImprovementManager.CreateImprovement(this, selectedContactUniqueId,
                                                    Improvement.ImprovementSource.Quality, objQuality.InternalId,
                                                    Improvement.ImprovementType.ContactMakeFree,
                                                    objQuality.DisplayNameShort(GlobalSettings.Language));
                                                ImprovementManager.Commit(this);
                                            }

                                            if (LastSavedVersion <= new Version(5, 212, 43)
                                                && objQuality.Name == "Inspired"
                                                && objQuality.Source == "SASS"
                                                && objQuality.Bonus["selectexpertise"] == null)
                                            {
                                                // Old handling of SASS' Inspired quality was both hardcoded and wrong
                                                // Since SASS' Inspired requires the player to choose a specialization, we always need a prompt,
                                                // so add the quality to the list for processing when the character is opened.
                                                _lstInternalIdsNeedingReapplyImprovements.Add(objQuality.InternalId);
                                            }

                                            if (LastSavedVersion <= new Version(5, 212, 56)
                                                && objQuality.Name == "Chain Breaker"
                                                && objQuality.Bonus == null)
                                            {
                                                // Chain Breaker bonus requires manual selection of two spirit types, so we need a prompt.
                                                _lstInternalIdsNeedingReapplyImprovements.Add(objQuality.InternalId);
                                            }

                                            if (LastSavedVersion <= new Version(5, 212, 78)
                                                && objQuality.Name == "Resonant Stream: Cyberadept"
                                                && objQuality.Bonus == null)
                                            {
                                                objQuality.Bonus =
                                                    xmlRootQualitiesNode.SelectSingleNode(
                                                        "quality[name=\"Resonant Stream: Cyberadept\"]/bonus");
                                                ImprovementManager.RemoveImprovements(this,
                                                    Improvement.ImprovementSource.Quality,
                                                    objQuality.InternalId);
                                                ImprovementManager.CreateImprovement(this, string.Empty,
                                                    Improvement.ImprovementSource.Quality, objQuality.InternalId,
                                                    Improvement.ImprovementType.CyberadeptDaemon,
                                                    objQuality.DisplayNameShort(GlobalSettings.Language));
                                                ImprovementManager.Commit(this);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        // If the Quality does not have a name tag, it is in the old format. Set the flag to show that old Qualities are in use.
                                        blnHasOldQualities = true;
                                    }
                                }

                                // If old Qualities are in use, they need to be converted before loading can continue.
                                if (blnHasOldQualities)
                                    ConvertOldQualities(objXmlNodeList);
                                //Timekeeper.Finish("load_char_quality");
                            }

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("Label_Attributes")
                                                            : await LanguageManager.GetStringAsync("Label_Attributes"));

                            using (_ = Timekeeper.StartSyncron("load_char_attributes", loadActivity))
                            {
                                AttributeSection.Load(objXmlCharacter);
                            }

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("String_Tradition")
                                                            : await LanguageManager.GetStringAsync("String_Tradition"));

                            using (_ = Timekeeper.StartSyncron("load_char_misc2", loadActivity))
                            {
                                // Attempt to load the split MAG CharacterAttribute information for Mystic Adepts.
                                if (_blnAdeptEnabled && _blnMagicianEnabled)
                                {
                                    xmlCharacterNavigator.TryGetInt32FieldQuickly("magsplitadept", ref _intMAGAdept);
                                    xmlCharacterNavigator.TryGetInt32FieldQuickly("magsplitmagician",
                                        ref _intMAGMagician);
                                }

                                // Attempt to load in the character's tradition (or equivalent for Technomancers)
                                string strTemp = string.Empty;
                                if (xmlCharacterNavigator.TryGetStringFieldQuickly("stream", ref strTemp) &&
                                    !string.IsNullOrEmpty(strTemp) && RESEnabled)
                                {
                                    // Legacy load a Technomancer tradition
                                    XmlNode xmlTraditionListDataNode =
                                        (blnSync
                                            // ReSharper disable once MethodHasAsyncOverload
                                            ? LoadData("streams.xml")
                                            : await LoadDataAsync("streams.xml"))
                                        .SelectSingleNode("/chummer/traditions");
                                    if (xmlTraditionListDataNode != null)
                                    {
                                        XmlNode xmlTraditionDataNode =
                                            xmlTraditionListDataNode.SelectSingleNode("tradition[name = " +
                                                strTemp.CleanXPath() + ']');
                                        if (xmlTraditionDataNode != null)
                                        {
                                            if (!_objTradition.Create(xmlTraditionDataNode, true))
                                                _objTradition.ResetTradition();
                                        }
                                        else
                                        {
                                            xmlTraditionDataNode =
                                                xmlTraditionListDataNode.SelectSingleNode(
                                                    "tradition[name = \"Default\"]");
                                            if (xmlTraditionDataNode != null)
                                            {
                                                if (!_objTradition.Create(xmlTraditionDataNode, true))
                                                    _objTradition.ResetTradition();
                                            }
                                            else
                                            {
                                                xmlTraditionDataNode =
                                                    xmlTraditionListDataNode.SelectSingleNode("tradition");
                                                if (xmlTraditionDataNode != null &&
                                                    !_objTradition.Create(xmlTraditionDataNode, true))
                                                    _objTradition.ResetTradition();
                                            }
                                        }
                                    }

                                    if (_objTradition.Type != TraditionType.None)
                                    {
                                        _objTradition.LegacyLoad(xmlCharacterNavigator);
                                    }
                                }
                                else
                                {
                                    XPathNavigator xpathTraditionNavigator =
                                        xmlCharacterNavigator.SelectSingleNode("tradition");
                                    // Regular tradition load
                                    if (xpathTraditionNavigator?.SelectSingleNode("guid") != null ||
                                        xpathTraditionNavigator?.SelectSingleNode("id") != null)
                                    {
                                        _objTradition.Load(objXmlCharacter.SelectSingleNode("tradition"));
                                    }
                                    // Not null but doesn't have children -> legacy load a magical tradition
                                    else if (xpathTraditionNavigator != null && MAGEnabled)
                                    {
                                        XmlNode xmlTraditionListDataNode =
                                            (blnSync
                                                // ReSharper disable once MethodHasAsyncOverload
                                                ? LoadData("traditions.xml")
                                                : await LoadDataAsync("traditions.xml"))
                                            .SelectSingleNode("/chummer/traditions");
                                        if (xmlTraditionListDataNode != null)
                                        {
                                            xmlCharacterNavigator.TryGetStringFieldQuickly("tradition", ref strTemp);
                                            XmlNode xmlTraditionDataNode =
                                                xmlTraditionListDataNode.SelectSingleNode(
                                                    "tradition[name = " + strTemp.CleanXPath() + ']');
                                            if (xmlTraditionDataNode != null)
                                            {
                                                if (!_objTradition.Create(xmlTraditionDataNode))
                                                    _objTradition.ResetTradition();
                                            }
                                            else
                                            {
                                                xmlTraditionDataNode =
                                                    xmlTraditionListDataNode.SelectSingleNode(
                                                        "tradition[id = " +
                                                        Tradition.CustomMagicalTraditionGuid.CleanXPath() + ']');
                                                if (xmlTraditionDataNode != null &&
                                                    !_objTradition.Create(xmlTraditionDataNode))
                                                {
                                                    _objTradition.ResetTradition();
                                                }
                                            }
                                        }

                                        if (_objTradition.Type != TraditionType.None)
                                        {
                                            _objTradition.LegacyLoad(xmlCharacterNavigator);
                                        }
                                    }
                                }

                                // Attempt to load Condition Monitor Progress.
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("physicalcmfilled",
                                    ref _intPhysicalCMFilled);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("stuncmfilled", ref _intStunCMFilled);

                                xmlCharacterNavigator.TryGetBoolFieldQuickly("psyche", ref _blnPsycheActive);
                                //Timekeeper.Finish("load_char_misc2");
                            }

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("Tab_Skills")
                                                            : await LanguageManager.GetStringAsync("Tab_Skills"));

                            using (_ = Timekeeper.StartSyncron("load_char_skills", loadActivity)) //slightly messy
                            {
                                _oldSkillsBackup = objXmlCharacter.SelectSingleNode("skills")?.Clone();
                                _oldSkillGroupBackup = objXmlCharacter.SelectSingleNode("skillgroups")?.Clone();

                                XmlNode objSkillNode = objXmlCharacter.SelectSingleNode("newskills");
                                if (objSkillNode != null)
                                {
                                    SkillsSection.Load(objSkillNode, false, loadActivity);
                                }
                                else
                                {
                                    SkillsSection.Load(objXmlCharacter, true, loadActivity);
                                }

                                //Timekeeper.Finish("load_char_skills");
                            }

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("String_Locations")
                                                            : await LanguageManager.GetStringAsync("String_Locations"));

                            using (_ = Timekeeper.StartSyncron("load_char_loc", loadActivity))
                            {
                                // Locations.
                                objXmlLocationList = objXmlCharacter.SelectNodes("gearlocations/gearlocation");
                                foreach (XmlNode objXmlLocation in objXmlLocationList)
                                {
                                    Location objLocation = new Location(this, _lstGearLocations);
                                    objLocation.Load(objXmlLocation);
                                }

                                objXmlLocationList = objXmlCharacter.SelectNodes("locations/location");
                                foreach (XmlNode objXmlLocation in objXmlLocationList)
                                {
                                    Location objLocation = new Location(this, _lstGearLocations);
                                    objLocation.Load(objXmlLocation);
                                }

                                objXmlLocationList = objXmlCharacter.SelectNodes("gearlocations/location");
                                foreach (XmlNode objXmlLocation in objXmlLocationList)
                                {
                                    Location objLocation = new Location(this, _lstGearLocations);
                                    objLocation.Load(objXmlLocation);
                                }

                                //Timekeeper.Finish("load_char_loc");
                            }

                            using (_ = Timekeeper.StartSyncron("load_char_abundle", loadActivity))
                            {
                                // Armor Bundles.
                                objXmlLocationList = objXmlCharacter.SelectNodes("armorbundles/armorbundle");
                                foreach (XmlNode objXmlLocation in objXmlLocationList)
                                {
                                    Location objLocation = new Location(this, _lstArmorLocations);
                                    objLocation.Load(objXmlLocation);
                                }

                                objXmlLocationList = objXmlCharacter.SelectNodes("armorlocations/armorlocation");
                                foreach (XmlNode objXmlLocation in objXmlLocationList)
                                {
                                    Location objLocation = new Location(this, _lstArmorLocations);
                                    objLocation.Load(objXmlLocation);
                                }

                                objXmlLocationList = objXmlCharacter.SelectNodes("armorlocations/location");
                                foreach (XmlNode objXmlLocation in objXmlLocationList)
                                {
                                    Location objLocation = new Location(this, _lstArmorLocations);
                                    objLocation.Load(objXmlLocation);
                                }

                                //Timekeeper.Finish("load_char_abundle");
                            }

                            using (_ = Timekeeper.StartSyncron("load_char_vloc", loadActivity))
                            {
                                // Vehicle Locations.
                                XmlNodeList objXmlVehicleLocationList =
                                    objXmlCharacter.SelectNodes("vehiclelocations/vehiclelocation");
                                foreach (XmlNode objXmlLocation in objXmlVehicleLocationList)
                                {
                                    Location objLocation = new Location(this, _lstVehicleLocations);
                                    objLocation.Load(objXmlLocation);
                                }

                                objXmlVehicleLocationList = objXmlCharacter.SelectNodes("vehiclelocations/location");
                                foreach (XmlNode objXmlLocation in objXmlVehicleLocationList)
                                {
                                    Location objLocation = new Location(this, _lstVehicleLocations);
                                    objLocation.Load(objXmlLocation);
                                }

                                //Timekeeper.Finish("load_char_vloc");
                            }

                            using (_ = Timekeeper.StartSyncron("load_char_wloc", loadActivity))
                            {
                                // Weapon Locations.
                                XmlNodeList objXmlWeaponLocationList =
                                    objXmlCharacter.SelectNodes("weaponlocations/weaponlocation");
                                foreach (XmlNode objXmlLocation in objXmlWeaponLocationList)
                                {
                                    Location objLocation = new Location(this, _lstWeaponLocations);
                                    objLocation.Load(objXmlLocation);
                                }

                                objXmlWeaponLocationList = objXmlCharacter.SelectNodes("weaponlocations/location");
                                foreach (XmlNode objXmlLocation in objXmlWeaponLocationList)
                                {
                                    Location objLocation = new Location(this, _lstWeaponLocations);
                                    objLocation.Load(objXmlLocation);
                                }

                                //Timekeeper.Finish("load_char_wloc");
                            }

                            using (_ = Timekeeper.StartSyncron("load_char_sfoci", loadActivity))
                            {
                                // Stacked Foci.
                                objXmlNodeList = objXmlCharacter.SelectNodes("stackedfoci/stackedfocus");
                                foreach (XmlNode objXmlStack in objXmlNodeList)
                                {
                                    StackedFocus objStack = new StackedFocus(this);
                                    objStack.Load(objXmlStack);
                                    _lstStackedFoci.Add(objStack);
                                }

                                //Timekeeper.Finish("load_char_sfoci");
                            }

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("Tab_Armor")
                                                            : await LanguageManager.GetStringAsync("Tab_Armor"));

                            using (_ = Timekeeper.StartSyncron("load_char_armor", loadActivity))
                            {
                                // Armor.
                                objXmlNodeList = objXmlCharacter.SelectNodes("armors/armor");
                                foreach (XmlNode objXmlArmor in objXmlNodeList)
                                {
                                    Armor objArmor = new Armor(this);
                                    objArmor.Load(objXmlArmor);
                                    _lstArmor.Add(objArmor);
                                }

                                //Timekeeper.Finish("load_char_armor");
                            }

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("Tab_Weapons")
                                                            : await LanguageManager.GetStringAsync("Tab_Weapons"));

                            using (_ = Timekeeper.StartSyncron("load_char_weapons", loadActivity))
                            {
                                // Weapons.
                                objXmlNodeList = objXmlCharacter.SelectNodes("weapons/weapon");
                                foreach (XmlNode objXmlWeapon in objXmlNodeList)
                                {
                                    Weapon objWeapon = new Weapon(this);
                                    objWeapon.Load(objXmlWeapon);
                                    _lstWeapons.Add(objWeapon);
                                }

                                //Timekeeper.Finish("load_char_weapons");
                            }

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("Tab_Drugs")
                                                            : await LanguageManager.GetStringAsync("Tab_Drugs"));

                            using (_ = Timekeeper.StartSyncron("load_char_drugs", loadActivity))
                            {
                                // Drugs.
                                objXmlNodeList = objXmlDocument.SelectNodes("/character/drugs/drug");
                                foreach (XmlNode objXmlDrug in objXmlNodeList)
                                {
                                    Drug objDrug = new Drug(this);
                                    objDrug.Load(objXmlDrug);
                                    _lstDrugs.Add(objDrug);
                                }

                                //Timekeeper.Finish("load_char_drugs");
                            }

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("Tab_Cyberware")
                                                            : await LanguageManager.GetStringAsync("Tab_Cyberware"));

                            using (_ = Timekeeper.StartSyncron("load_char_ware", loadActivity))
                            {
                                // Cyberware/Bioware.
                                objXmlNodeList = objXmlCharacter.SelectNodes("cyberwares/cyberware");
                                // Dictionary for instantly re-applying outdated improvements for 'ware with pair bonuses in legacy shim
                                Dictionary<Cyberware, int> dicPairableCyberwares = new Dictionary<Cyberware, int>(objXmlNodeList.Count);
                                foreach (XmlNode objXmlCyberware in objXmlNodeList)
                                {
                                    Cyberware objCyberware = new Cyberware(this);
                                    objCyberware.Load(objXmlCyberware);
                                    _lstCyberware.Add(objCyberware);
                                    // Legacy shim #1
                                    if (objCyberware.Name == "Myostatin Inhibitor" &&
                                        LastSavedVersion <= new Version(5, 195, 1) &&
                                        !Improvements.Any(x =>
                                            x.SourceName == objCyberware.InternalId &&
                                            x.ImproveType == Improvement.ImprovementType.AttributeKarmaCost))
                                    {
                                        XmlNode objNode = objCyberware.GetNode();
                                        if (objNode != null)
                                        {
                                            ImprovementManager.RemoveImprovements(this, objCyberware.SourceType,
                                                objCyberware.InternalId);
                                            ImprovementManager.RemoveImprovements(this, objCyberware.SourceType,
                                                objCyberware.InternalId + "Pair");
                                            objCyberware.Bonus = objNode["bonus"];
                                            objCyberware.WirelessBonus = objNode["wirelessbonus"];
                                            objCyberware.PairBonus = objNode["pairbonus"];
                                            if (!string.IsNullOrEmpty(objCyberware.Forced) &&
                                                objCyberware.Forced != "Right" &&
                                                objCyberware.Forced != "Left")
                                                ImprovementManager.ForcedValue = objCyberware.Forced;
                                            if (objCyberware.Bonus != null)
                                            {
                                                ImprovementManager.CreateImprovements(this, objCyberware.SourceType,
                                                    objCyberware.InternalId, objCyberware.Bonus, objCyberware.Rating,
                                                    objCyberware.DisplayNameShort(GlobalSettings.Language));
                                                if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                                    objCyberware.Extra = ImprovementManager.SelectedValue;
                                            }

                                            if (objCyberware.WirelessOn && objCyberware.WirelessBonus != null)
                                            {
                                                ImprovementManager.CreateImprovements(this, objCyberware.SourceType,
                                                    objCyberware.InternalId, objCyberware.WirelessBonus,
                                                    objCyberware.Rating,
                                                    objCyberware.DisplayNameShort(GlobalSettings.Language));
                                                if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue) &&
                                                    string.IsNullOrEmpty(objCyberware.Extra))
                                                    objCyberware.Extra = ImprovementManager.SelectedValue;
                                            }

                                            if (!objCyberware.IsModularCurrentlyEquipped)
                                                objCyberware.ChangeModularEquip(false);
                                            else if (objCyberware.PairBonus != null)
                                            {
                                                Cyberware objMatchingCyberware =
                                                    dicPairableCyberwares.Keys.FirstOrDefault(
                                                        x =>
                                                            x.Name == objCyberware.Name &&
                                                            x.Extra == objCyberware.Extra);
                                                if (objMatchingCyberware != null)
                                                    ++dicPairableCyberwares[objMatchingCyberware];
                                                else
                                                    dicPairableCyberwares.Add(objCyberware, 1);
                                            }
                                        }
                                        else
                                        {
                                            _lstInternalIdsNeedingReapplyImprovements.Add(objCyberware.InternalId);
                                        }
                                    }
                                }

                                // Legacy Shim #2 (needed to be separate because we're dealing with PairBonuses here, and we don't know if something needs its PairBonus reapplied until all Cyberwares have been loaded)
                                if (LastSavedVersion <= new Version(5, 200, 0))
                                {
                                    foreach (Cyberware objCyberware in Cyberware)
                                    {
                                        if (objCyberware.PairBonus?.HasChildNodes == true &&
                                            !Cyberware.DeepAny(x => x.Children, x =>
                                            {
                                                if (!objCyberware.IncludePair.Contains(x.Name) ||
                                                    x.Extra != objCyberware.Extra ||
                                                    !x.IsModularCurrentlyEquipped)
                                                    return false;
                                                string strToMatch = x.InternalId + "Pair";
                                                return Improvements.Any(y => y.SourceName == strToMatch);
                                            }))
                                        {
                                            XmlNode objNode = objCyberware.GetNode();
                                            if (objNode != null)
                                            {
                                                ImprovementManager.RemoveImprovements(this, objCyberware.SourceType,
                                                    objCyberware.InternalId);
                                                ImprovementManager.RemoveImprovements(this, objCyberware.SourceType,
                                                    objCyberware.InternalId + "Pair");
                                                objCyberware.Bonus = objNode["bonus"];
                                                objCyberware.WirelessBonus = objNode["wirelessbonus"];
                                                objCyberware.PairBonus = objNode["pairbonus"];
                                                if (!string.IsNullOrEmpty(objCyberware.Forced) &&
                                                    objCyberware.Forced != "Right" &&
                                                    objCyberware.Forced != "Left")
                                                    ImprovementManager.ForcedValue = objCyberware.Forced;
                                                if (objCyberware.Bonus != null)
                                                {
                                                    ImprovementManager.CreateImprovements(this, objCyberware.SourceType,
                                                        objCyberware.InternalId, objCyberware.Bonus,
                                                        objCyberware.Rating,
                                                        objCyberware.DisplayNameShort(GlobalSettings.Language));
                                                    if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                                        objCyberware.Extra = ImprovementManager.SelectedValue;
                                                }

                                                if (objCyberware.WirelessOn && objCyberware.WirelessBonus != null)
                                                {
                                                    ImprovementManager.CreateImprovements(this, objCyberware.SourceType,
                                                        objCyberware.InternalId, objCyberware.WirelessBonus,
                                                        objCyberware.Rating,
                                                        objCyberware.DisplayNameShort(GlobalSettings.Language));
                                                    if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue) &&
                                                        string.IsNullOrEmpty(objCyberware.Extra))
                                                        objCyberware.Extra = ImprovementManager.SelectedValue;
                                                }

                                                if (!objCyberware.IsModularCurrentlyEquipped)
                                                    objCyberware.ChangeModularEquip(false);
                                                else if (objCyberware.PairBonus != null)
                                                {
                                                    Cyberware objMatchingCyberware =
                                                        dicPairableCyberwares.Keys.FirstOrDefault(
                                                            x =>
                                                                x.Name == objCyberware.Name &&
                                                                x.Extra == objCyberware.Extra);
                                                    if (objMatchingCyberware != null)
                                                        ++dicPairableCyberwares[objMatchingCyberware];
                                                    else
                                                        dicPairableCyberwares.Add(objCyberware, 1);
                                                }
                                            }
                                            else
                                            {
                                                _lstInternalIdsNeedingReapplyImprovements.Add(objCyberware.InternalId);
                                            }
                                        }
                                    }
                                }

                                // Separate Pass for PairBonuses
                                foreach (KeyValuePair<Cyberware, int> objItem in dicPairableCyberwares)
                                {
                                    Cyberware objCyberware = objItem.Key;
                                    int intCyberwaresCount = objItem.Value;
                                    List<Cyberware> lstPairableCyberwares = Cyberware.DeepWhere(x => x.Children,
                                        x => objCyberware.IncludePair.Contains(x.Name) &&
                                             x.Extra == objCyberware.Extra &&
                                             x.IsModularCurrentlyEquipped).ToList();
                                    // Need to use slightly different logic if this cyberware has a location (Left or Right) and only pairs with itself because Lefts can only be paired with Rights and Rights only with Lefts
                                    if (!string.IsNullOrEmpty(objCyberware.Location) &&
                                        objCyberware.IncludePair.All(x => x == objCyberware.Name))
                                    {
                                        int intMatchLocationCount = 0;
                                        int intNotMatchLocationCount = 0;
                                        foreach (Cyberware objPairableCyberware in lstPairableCyberwares)
                                        {
                                            if (objPairableCyberware.Location != objCyberware.Location)
                                                ++intNotMatchLocationCount;
                                            else
                                                ++intMatchLocationCount;
                                        }

                                        // Set the count to the total number of cyberwares in matching pairs, which would mean 2x the number of whichever location contains the fewest members (since every single one of theirs would have a pair)
                                        intCyberwaresCount = Math.Min(intNotMatchLocationCount, intMatchLocationCount) *
                                                             2;
                                    }

                                    if (intCyberwaresCount > 0)
                                    {
                                        foreach (Cyberware objLoopCyberware in lstPairableCyberwares)
                                        {
                                            if ((intCyberwaresCount & 1) == 0)
                                            {
                                                if (!string.IsNullOrEmpty(objCyberware.Forced) &&
                                                    objCyberware.Forced != "Right" &&
                                                    objCyberware.Forced != "Left")
                                                    ImprovementManager.ForcedValue = objCyberware.Forced;
                                                ImprovementManager.CreateImprovements(this, objLoopCyberware.SourceType,
                                                    objLoopCyberware.InternalId + "Pair", objLoopCyberware.PairBonus,
                                                    objLoopCyberware.Rating,
                                                    objLoopCyberware.DisplayNameShort(GlobalSettings.Language));
                                                if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue) &&
                                                    string.IsNullOrEmpty(objCyberware.Extra))
                                                    objCyberware.Extra = ImprovementManager.SelectedValue;
                                            }

                                            --intCyberwaresCount;
                                            if (intCyberwaresCount <= 0)
                                                break;
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_ware");
                            }

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("Label_SelectedSpells")
                                                            : await LanguageManager.GetStringAsync("Label_SelectedSpells"));

                            using (_ = Timekeeper.StartSyncron("load_char_spells", loadActivity))
                            {
                                // Spells.
                                objXmlNodeList = objXmlCharacter.SelectNodes("spells/spell");
                                foreach (XmlNode objXmlSpell in objXmlNodeList)
                                {
                                    Spell objSpell = new Spell(this);
                                    objSpell.Load(objXmlSpell);
                                    _lstSpells.Add(objSpell);
                                }
                                //Timekeeper.Finish("load_char_spells");
                            }

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("Tab_Adept")
                                                            : await LanguageManager.GetStringAsync("Tab_Adept"));

                            using (_ = Timekeeper.StartSyncron("load_char_powers", loadActivity))
                            {
                                // Powers.
                                objXmlNodeList = objXmlCharacter.SelectNodes("powers/power");
                                if (objXmlNodeList.Count > 0)
                                {
                                    using (new FetchSafelyFromPool<List<ListItem>>(
                                               Utils.ListItemListPool, out List<ListItem> lstPowerOrder))
                                    {
                                        bool blnDoEnhancedAccuracyRefresh = LastSavedVersion <= new Version(5, 198, 26);
                                        // Sort the Powers in alphabetical order.
                                        foreach (XmlNode xmlPower in objXmlNodeList)
                                        {
                                            string strGuid = xmlPower["guid"]?.InnerText;
                                            string strPowerName = xmlPower["name"]?.InnerText ?? string.Empty;
                                            if (blnDoEnhancedAccuracyRefresh
                                                && strPowerName == "Enhanced Accuracy (skill)")
                                            {
                                                _lstInternalIdsNeedingReapplyImprovements.Add(strGuid);
                                            }

                                            if (!string.IsNullOrEmpty(strGuid))
                                                lstPowerOrder.Add(new ListItem(strGuid,
                                                                               strPowerName
                                                                               + (xmlPower["extra"]?.InnerText
                                                                                   ?? string.Empty)));
                                            else
                                            {
                                                Power objPower = new Power(this);
                                                objPower.Load(xmlPower);
                                                _lstPowers.Add(objPower);
                                            }
                                        }

                                        lstPowerOrder.Sort(CompareListItems.CompareNames);

                                        foreach (ListItem objItem in lstPowerOrder)
                                        {
                                            XmlNode objNode =
                                                objXmlCharacter.SelectSingleNode(
                                                    "powers/power[guid = " + objItem.Value.ToString().CleanXPath()
                                                                           + ']');
                                            if (objNode != null)
                                            {
                                                Power objPower = new Power(this);
                                                objPower.Load(objNode);
                                                _lstPowers.Add(objPower);
                                            }
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_powers");
                            }

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("Label_Spirits")
                                                            : await LanguageManager.GetStringAsync("Label_Spirits"));

                            using (_ = Timekeeper.StartSyncron("load_char_spirits", loadActivity))
                            {
                                // Spirits/Sprites.
                                foreach (XPathNavigator xmlSpirit in xmlCharacterNavigator.SelectAndCacheExpression("spirits/spirit"))
                                {
                                    Spirit objSpirit = new Spirit(this);
                                    objSpirit.Load(xmlSpirit);
                                    _lstSpirits.Add(objSpirit);
                                }

                                if (!_lstSpirits.Any(s => s.Fettered) && Improvements.Any(imp =>
                                    imp.ImproveSource == Improvement.ImprovementSource.SpiritFettering))
                                {
                                    // If we don't have any Fettered spirits, make sure that we
                                    ImprovementManager.RemoveImprovements(this,
                                        Improvement.ImprovementSource.SpiritFettering);
                                }

                                //Timekeeper.Finish("load_char_spirits");
                            }

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("Label_ComplexForms")
                                                            : await LanguageManager.GetStringAsync("Label_ComplexForms"));

                            using (_ = Timekeeper.StartSyncron("load_char_complex", loadActivity))
                            {
                                // Compex Forms/Technomancer Programs.
                                objXmlNodeList = objXmlCharacter.SelectNodes("complexforms/complexform");
                                foreach (XmlNode objXmlComplexForm in objXmlNodeList)
                                {
                                    ComplexForm objComplexForm = new ComplexForm(this);
                                    objComplexForm.Load(objXmlComplexForm);
                                    _lstComplexForms.Add(objComplexForm);
                                }

                                //Timekeeper.Finish("load_char_complex");
                            }

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("Tab_AdvancedPrograms")
                                                            : await LanguageManager.GetStringAsync("Tab_AdvancedPrograms"));

                            using (_ = Timekeeper.StartSyncron("load_char_aiprogram", loadActivity))
                            {
                                // Compex Forms/Technomancer Programs.
                                objXmlNodeList = objXmlCharacter.SelectNodes("aiprograms/aiprogram");
                                foreach (XmlNode objXmlProgram in objXmlNodeList)
                                {
                                    AIProgram objProgram = new AIProgram(this);
                                    objProgram.Load(objXmlProgram);
                                    _lstAIPrograms.Add(objProgram);
                                }

                                //Timekeeper.Finish("load_char_aiprogram");
                            }

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("Tab_MartialArts")
                                                            : await LanguageManager.GetStringAsync("Tab_MartialArts"));

                            using (_ = Timekeeper.StartSyncron("load_char_marts", loadActivity))
                            {
                                // Martial Arts.
                                objXmlNodeList = objXmlCharacter.SelectNodes("martialarts/martialart");
                                foreach (XmlNode objXmlArt in objXmlNodeList)
                                {
                                    MartialArt objMartialArt = new MartialArt(this);
                                    objMartialArt.Load(objXmlArt);
                                    _lstMartialArts.Add(objMartialArt);
                                }

                                //Timekeeper.Finish("load_char_marts");
                            }

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("Tab_Limits")
                                                            : await LanguageManager.GetStringAsync("Tab_Limits"));

                            using (_ = Timekeeper.StartSyncron("load_char_mod", loadActivity))
                            {
                                // Limit Modifiers.
                                objXmlNodeList = objXmlCharacter.SelectNodes("limitmodifiers/limitmodifier");
                                foreach (XmlNode objXmlLimit in objXmlNodeList)
                                {
                                    LimitModifier obLimitModifier = new LimitModifier(this);
                                    obLimitModifier.Load(objXmlLimit);
                                    _lstLimitModifiers.Add(obLimitModifier);
                                }

                                //Timekeeper.Finish("load_char_mod");
                            }

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("String_SelectPACKSKit_Lifestyles")
                                                            : await LanguageManager.GetStringAsync("String_SelectPACKSKit_Lifestyles"));

                            using (_ = Timekeeper.StartSyncron("load_char_lifestyle", loadActivity))
                            {
                                // Lifestyles.
                                objXmlNodeList = objXmlCharacter.SelectNodes("lifestyles/lifestyle");
                                foreach (XmlNode objXmlLifestyle in objXmlNodeList)
                                {
                                    Lifestyle objLifestyle = new Lifestyle(this);
                                    objLifestyle.Load(objXmlLifestyle);
                                    _lstLifestyles.Add(objLifestyle);
                                }

                                //Timekeeper.Finish("load_char_lifestyle");
                            }

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("Tab_Gear")
                                                            : await LanguageManager.GetStringAsync("Tab_Gear"));

                            using (_ = Timekeeper.StartSyncron("load_char_gear", loadActivity))
                            {
                                // <gears>
                                objXmlNodeList = objXmlCharacter.SelectNodes("gears/gear");
                                foreach (XmlNode objXmlGear in objXmlNodeList)
                                {
                                    Gear objGear = new Gear(this);
                                    objGear.Load(objXmlGear);
                                    _lstGear.Add(objGear);
                                }

                                // If the character has a technomancer quality but no Living Persona commlink, its improvements get re-applied immediately
                                if (objLivingPersonaQuality != null && LastSavedVersion <= new Version(5, 195, 1))
                                {
                                    ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Quality,
                                        objLivingPersonaQuality.InternalId);

                                    XmlNode objNode = objLivingPersonaQuality.GetNode();
                                    if (objNode != null)
                                    {
                                        objLivingPersonaQuality.Bonus = objNode["bonus"];
                                        if (objLivingPersonaQuality.Bonus != null)
                                        {
                                            ImprovementManager.ForcedValue = objLivingPersonaQuality.Extra;
                                            ImprovementManager.CreateImprovements(this,
                                                Improvement.ImprovementSource.Quality,
                                                objLivingPersonaQuality.InternalId, objLivingPersonaQuality.Bonus, 1,
                                                objLivingPersonaQuality.DisplayNameShort(GlobalSettings.Language));
                                            if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                            {
                                                objLivingPersonaQuality.Extra = ImprovementManager.SelectedValue;
                                            }
                                        }

                                        objLivingPersonaQuality.FirstLevelBonus = objNode["firstlevelbonus"];
                                        if (objLivingPersonaQuality.FirstLevelBonus?.HasChildNodes == true)
                                        {
                                            bool blnDoFirstLevel = true;
                                            foreach (Quality objCheckQuality in Qualities)
                                            {
                                                if (objCheckQuality != objLivingPersonaQuality &&
                                                    objCheckQuality.SourceIDString ==
                                                    objLivingPersonaQuality.SourceIDString &&
                                                    objCheckQuality.Extra == objLivingPersonaQuality.Extra &&
                                                    objCheckQuality.SourceName == objLivingPersonaQuality.SourceName)
                                                {
                                                    blnDoFirstLevel = false;
                                                    break;
                                                }
                                            }

                                            if (blnDoFirstLevel)
                                            {
                                                ImprovementManager.ForcedValue = objLivingPersonaQuality.Extra;
                                                ImprovementManager.CreateImprovements(this,
                                                    Improvement.ImprovementSource.Quality,
                                                    objLivingPersonaQuality.InternalId,
                                                    objLivingPersonaQuality.FirstLevelBonus,
                                                    1,
                                                    objLivingPersonaQuality.DisplayNameShort(GlobalSettings.Language));
                                                if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                                {
                                                    objLivingPersonaQuality.Extra = ImprovementManager.SelectedValue;
                                                }
                                            }
                                        }
                                    }
                                    else
                                    {
                                        // Failed to re-apply the improvements immediately, so let's just add it for processing when the character is opened
                                        _lstInternalIdsNeedingReapplyImprovements.Add(
                                            objLivingPersonaQuality.InternalId);
                                    }
                                }

                                //Timekeeper.Finish("load_char_gear");
                            }

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("Label_Vehicles")
                                                            : await LanguageManager.GetStringAsync("Label_Vehicles"));

                            using (_ = Timekeeper.StartSyncron("load_char_car", loadActivity))
                            {
                                // Vehicles.
                                objXmlNodeList = objXmlCharacter.SelectNodes("vehicles/vehicle");
                                foreach (XmlNode objXmlVehicle in objXmlNodeList)
                                {
                                    Vehicle objVehicle = new Vehicle(this);
                                    objVehicle.Load(objXmlVehicle);
                                    _lstVehicles.Add(objVehicle);
                                }

                                //Timekeeper.Finish("load_char_car");
                            }

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("String_Metamagics")
                                                            : await LanguageManager.GetStringAsync("String_Metamagics"));

                            using (_ = Timekeeper.StartSyncron("load_char_mmagic", loadActivity))
                            {
                                // Metamagics/Echoes.
                                objXmlNodeList = objXmlCharacter.SelectNodes("metamagics/metamagic");
                                foreach (XmlNode objXmlMetamagic in objXmlNodeList)
                                {
                                    Metamagic objMetamagic = new Metamagic(this);
                                    objMetamagic.Load(objXmlMetamagic);
                                    _lstMetamagics.Add(objMetamagic);
                                }

                                //Timekeeper.Finish("load_char_mmagic");
                            }

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("String_Arts")
                                                            : await LanguageManager.GetStringAsync("String_Arts"));

                            using (_ = Timekeeper.StartSyncron("load_char_arts", loadActivity))
                            {
                                // Arts
                                objXmlNodeList = objXmlCharacter.SelectNodes("arts/art");
                                foreach (XmlNode objXmlArt in objXmlNodeList)
                                {
                                    Art objArt = new Art(this);
                                    objArt.Load(objXmlArt);
                                    _lstArts.Add(objArt);
                                }

                                //Timekeeper.Finish("load_char_arts");
                            }

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("String_Enhancements")
                                                            : await LanguageManager.GetStringAsync("String_Enhancements"));

                            using (_ = Timekeeper.StartSyncron("load_char_ench", loadActivity))
                            {
                                // Enhancements
                                objXmlNodeList = objXmlCharacter.SelectNodes("enhancements/enhancement");
                                foreach (XmlNode objXmlEnhancement in objXmlNodeList)
                                {
                                    Enhancement objEnhancement = new Enhancement(this);
                                    objEnhancement.Load(objXmlEnhancement);
                                    _lstEnhancements.Add(objEnhancement);
                                }

                                //Timekeeper.Finish("load_char_ench");
                            }

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("Tab_Critter")
                                                            : await LanguageManager.GetStringAsync("Tab_Critter"));

                            using (_ = Timekeeper.StartSyncron("load_char_cpow", loadActivity))
                            {
                                // Critter Powers.
                                objXmlNodeList = objXmlCharacter.SelectNodes("critterpowers/critterpower");
                                foreach (XmlNode objXmlPower in objXmlNodeList)
                                {
                                    CritterPower objPower = new CritterPower(this);
                                    objPower.Load(objXmlPower);
                                    _lstCritterPowers.Add(objPower);
                                }

                                //Timekeeper.Finish("load_char_cpow");
                            }

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("Label_SummaryFoci")
                                                            : await LanguageManager.GetStringAsync("Label_SummaryFoci"));

                            using (_ = Timekeeper.StartSyncron("load_char_foci", loadActivity))
                            {
                                // Foci.
                                objXmlNodeList = objXmlCharacter.SelectNodes("foci/focus");
                                foreach (XmlNode objXmlFocus in objXmlNodeList)
                                {
                                    Focus objFocus = new Focus(this);
                                    objFocus.Load(objXmlFocus);
                                    _lstFoci.Add(objFocus);
                                }

                                //Timekeeper.Finish("load_char_foci");
                            }

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("Label_SummaryInitiation")
                                                            : await LanguageManager.GetStringAsync("Label_SummaryInitiation"));

                            using (_ = Timekeeper.StartSyncron("load_char_init", loadActivity))
                            {
                                // Initiation Grades.
                                objXmlNodeList = objXmlCharacter.SelectNodes("initiationgrades/initiationgrade");
                                foreach (XmlNode objXmlGrade in objXmlNodeList)
                                {
                                    InitiationGrade objGrade = new InitiationGrade(this);
                                    objGrade.Load(objXmlGrade);
                                    _lstInitiationGrades.Add(objGrade);
                                }

                                //Timekeeper.Finish("load_char_init");
                            }

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("String_Expenses")
                                                            : await LanguageManager.GetStringAsync("String_Expenses"));
                            // While expenses are to be saved in create mode due to starting nuyen and starting karma being logged as expense log entries,
                            // they shouldn't get loaded in create mode because they shouldn't be there.
                            if (Created)
                            {
                                using (_ = Timekeeper.StartSyncron("load_char_elog", loadActivity))
                                {
                                    // Expense Log Entries.
                                    XmlNodeList objXmlExpenseList = objXmlCharacter.SelectNodes("expenses/expense");
                                    foreach (XmlNode objXmlExpense in objXmlExpenseList)
                                    {
                                        ExpenseLogEntry objExpenseLogEntry = new ExpenseLogEntry(this);
                                        objExpenseLogEntry.Load(objXmlExpense);
                                        _lstExpenseLog.AddWithSort(objExpenseLogEntry);
                                    }

                                    //Timekeeper.Finish("load_char_elog");
                                }
                            }
#if DEBUG
                            else
                            {
                                // There shouldn't be any expenses for a character loaded in create mode. This code is to help narrow down issues should expenses somehow be created.
                                XmlNodeList objXmlExpenseList = objXmlCharacter.SelectNodes("expenses/expense");
                                if (objXmlExpenseList?.Count > 0)
                                {
                                    Utils.BreakIfDebug();
                                }
                            }
#endif
                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("Tip_Skill_Sustain")
                                                            : await LanguageManager.GetStringAsync("Tip_Skill_Sustain"));

                            // Need to load these after everything else so that we can properly link them up during loading
                            using (_ = Timekeeper.StartSyncron("load_char_SustainedAbilities", loadActivity))
                            {
                                objXmlNodeList = objXmlCharacter.SelectNodes("sustainedobjects");
                                foreach (XmlNode objXmlSustained in objXmlNodeList)
                                {
                                    SustainedObject objSustained = new SustainedObject(this);
                                    objSustained.Load(objXmlSustained);
                                    if (objSustained.InternalId != Guid.Empty.ToString("D", GlobalSettings.InvariantCultureInfo))
                                        _lstSustainedObjects.Add(objSustained);
                                }
                            }

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("Tab_Improvements")
                                                            : await LanguageManager.GetStringAsync("Tab_Improvements"));

                            using (_ = Timekeeper.StartSyncron("load_char_igroup", loadActivity))
                            {
                                // Improvement Groups.
                                XmlNodeList objXmlGroupList =
                                    objXmlCharacter.SelectNodes("improvementgroups/improvementgroup");
                                foreach (XmlNode objXmlGroup in objXmlGroupList)
                                {
                                    _lstImprovementGroups.Add(objXmlGroup.InnerText);
                                }

                                //Timekeeper.Finish("load_char_igroup");
                            }

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("Tab_Calendar")
                                                            : await LanguageManager.GetStringAsync("Tab_Calendar"));

                            using (_ = Timekeeper.StartSyncron("load_char_calendar", loadActivity))
                            {
                                // Calendar.
                                XmlNodeList objXmlWeekList = objXmlCharacter.SelectNodes("calendar/week");
                                foreach (XmlNode objXmlWeek in objXmlWeekList)
                                {
                                    CalendarWeek objWeek = new CalendarWeek();
                                    objWeek.Load(objXmlWeek);
                                    _lstCalendar.AddWithSort(objWeek, (x, y) => y.CompareTo(x));
                                }

                                //Timekeeper.Finish("load_char_calendar");
                            }

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("String_LegacyFixes")
                                                            : await LanguageManager.GetStringAsync("String_LegacyFixes"));

                            using (_ = Timekeeper.StartSyncron("load_char_unarmed", loadActivity))
                            {
                                // Look for the unarmed attack
                                bool blnFoundUnarmed = false;
                                foreach (Weapon objWeapon in _lstWeapons)
                                {
                                    if (objWeapon.Name == "Unarmed Attack")
                                    {
                                        blnFoundUnarmed = true;
                                        break;
                                    }
                                }

                                if (!blnFoundUnarmed)
                                {
                                    // Add the Unarmed Attack Weapon to the character.
                                    XmlDocument objXmlWeaponDoc = blnSync
                                        // ReSharper disable once MethodHasAsyncOverload
                                        ? LoadData("weapons.xml")
                                        : await LoadDataAsync("weapons.xml");
                                    XmlNode objXmlWeapon =
                                        objXmlWeaponDoc.SelectSingleNode(
                                            "/chummer/weapons/weapon[name = \"Unarmed Attack\"]");
                                    if (objXmlWeapon != null)
                                    {
                                        Weapon objWeapon = new Weapon(this);
                                        objWeapon.Create(objXmlWeapon, _lstWeapons);
                                        objWeapon.IncludedInWeapon = true; // Unarmed attack can never be removed
                                        _lstWeapons.Add(objWeapon);
                                    }
                                }

                                //Timekeeper.Finish("load_char_unarmed");
                            }

                            using (_ = Timekeeper.StartSyncron("load_char_dwarffix", loadActivity))
                            {
                                // converting from old dwarven resistance to new dwarven resistance
                                if (Metatype.Equals("dwarf", StringComparison.OrdinalIgnoreCase))
                                {
                                    Quality objOldQuality =
                                        Qualities.FirstOrDefault(x =>
                                            x.Name.Equals("Resistance to Pathogens and Toxins",
                                                StringComparison.Ordinal));
                                    if (objOldQuality != null)
                                    {
                                        objOldQuality.DeleteQuality();
                                        if (Qualities.All(x =>
                                                !x.Name.Equals("Resistance to Pathogens/Toxins",
                                                    StringComparison.Ordinal))
                                            && Qualities.All(x =>
                                                !x.Name.Equals("Dwarf Resistance", StringComparison.Ordinal)))
                                        {
                                            XmlNode objXmlDwarfQuality =
                                                xmlRootQualitiesNode.SelectSingleNode(
                                                    "quality[name = \"Resistance to Pathogens/Toxins\"]") ??
                                                xmlRootQualitiesNode.SelectSingleNode(
                                                    "quality[name = \"Dwarf Resistance\"]");

                                            List<Weapon> lstWeapons = new List<Weapon>(1);
                                            Quality objQuality = new Quality(this);

                                            objQuality.Create(objXmlDwarfQuality, QualitySource.Metatype, lstWeapons);
                                            foreach (Weapon objWeapon in lstWeapons)
                                                Weapons.Add(objWeapon);
                                            Qualities.Add(objQuality);
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_dwarffix");
                            }

                            using (_ = Timekeeper.StartSyncron("load_char_cyberadeptfix", loadActivity))
                            {
                                //Sweep through grades if we have any cyberadept improvements that need reassignment
                                if (lstCyberadeptSweepGrades.Count > 0)
                                {
                                    foreach (Improvement objCyberadeptImprovement in lstCyberadeptSweepGrades)
                                    {
                                        InitiationGrade objBestGradeMatch = null;
                                        foreach (InitiationGrade objInitiationGrade in InitiationGrades)
                                        {
                                            if (!objInitiationGrade.Technomancer
                                                || objInitiationGrade.Grade.DivAwayFromZero(2) >
                                                objCyberadeptImprovement.Value
                                                || Metamagics.Any(x => x.Grade == objInitiationGrade.Grade)
                                                || lstCyberadeptSweepGrades.All(x =>
                                                    x.ImproveSource != Improvement.ImprovementSource.CyberadeptDaemon
                                                    || x.SourceName != objInitiationGrade.InternalId))
                                                continue;
                                            if (objBestGradeMatch == null ||
                                                objBestGradeMatch.Grade > objInitiationGrade.Grade)
                                                objBestGradeMatch = objInitiationGrade;
                                        }

                                        if (objBestGradeMatch != null)
                                        {
                                            objCyberadeptImprovement.ImproveSource =
                                                Improvement.ImprovementSource.CyberadeptDaemon;
                                            objCyberadeptImprovement.SourceName = objBestGradeMatch.InternalId;
                                        }
                                        else
                                            _lstImprovements.Remove(objCyberadeptImprovement);
                                    }
                                }

                                //Timekeeper.Finish("load_char_cyberadeptfix");
                            }

                            using (_ = Timekeeper.StartSyncron("load_char_mentorspiritfix", loadActivity))
                            {
                                Quality objMentorQuality = Qualities.FirstOrDefault(q => q.Name == "Mentor Spirit");
                                // This character doesn't have any improvements tied to a cached Mentor Spirit value, so re-apply the improvement that adds the Mentor spirit
                                if (objMentorQuality != null && !Improvements.Any(imp =>
                                    imp.ImproveType == Improvement.ImprovementType.MentorSpirit &&
                                    !string.IsNullOrEmpty(imp.ImprovedName)))
                                {
                                    // Selecting bonuses for a mentor spirit mid-load is confusing, so just show the error and let the player manually re-apply
                                    _lstInternalIdsNeedingReapplyImprovements.Add(objMentorQuality.InternalId);
                                }

                                //Timekeeper.Finish("load_char_mentorspiritfix");
                            }

                            using (_ = Timekeeper.StartSyncron("load_char_flechettefix", loadActivity))
                            {
                                //Fixes an issue where existing weapons could have been loaded with non-flechette ammunition
                                if (LastSavedVersion <= new Version(5, 212, 78))
                                {
                                    foreach (Weapon objWeapon in Weapons.GetAllDescendants(x => x.Children))
                                        objWeapon.DoFlechetteFix();
                                    foreach (Vehicle objVehicle in Vehicles)
                                    {
                                        foreach (Weapon objWeapon in objVehicle.Weapons.GetAllDescendants(x =>
                                            x.Children))
                                            objWeapon.DoFlechetteFix();
                                        foreach (WeaponMount objWeaponMount in objVehicle.WeaponMounts)
                                        {
                                            foreach (Weapon objWeapon in objWeaponMount.Weapons.GetAllDescendants(x =>
                                                x.Children))
                                                objWeapon.DoFlechetteFix();

                                            foreach (VehicleMod objMod in objWeaponMount.Mods)
                                            {
                                                foreach (Weapon objWeapon in objMod.Weapons.GetAllDescendants(x =>
                                                    x.Children))
                                                    objWeapon.DoFlechetteFix();
                                            }
                                        }

                                        foreach (VehicleMod objMod in objVehicle.Mods)
                                        {
                                            foreach (Weapon objWeapon in objMod.Weapons.GetAllDescendants(x =>
                                                x.Children))
                                                objWeapon.DoFlechetteFix();
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_flechettefix");
                            }

                            frmLoadingForm?.PerformStep(blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString("Tab_Options_Plugins")
                                                            : await LanguageManager.GetStringAsync("Tab_Options_Plugins"));

                            //Plugins
                            using (_ = Timekeeper.StartSyncron("load_plugins", loadActivity))
                            {
                                foreach (IPlugin plugin in Program.PluginLoader.MyActivePlugins)
                                {
                                    foreach (XmlNode objXmlPlugin in objXmlCharacter.SelectNodes("plugins/" +
                                        plugin.GetPluginAssembly().GetName().Name))
                                    {
                                        plugin.LoadFileElement(this, objXmlPlugin.InnerText);
                                    }
                                }

                                //Timekeeper.Finish("load_plugins");
                            }
                        }
                        finally
                        {
                            IsLoading = false;
                        }

                        frmLoadingForm?.PerformStep(blnSync
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        ? LanguageManager.GetString("String_GeneratedImprovements")
                                                        : await LanguageManager.GetStringAsync("String_GeneratedImprovements"));

                        // Refresh certain improvements
                        using (_ = Timekeeper.StartSyncron("load_char_improvementrefreshers1", loadActivity))
                        {
                            // Refresh Black Market Discounts
                            RefreshBlackMarketDiscounts();
                            // Refresh Dealer Connection discounts
                            RefreshDealerConnectionDiscounts();
                            // Refresh permanent attribute changes due to essence loss
                            RefreshEssenceLossImprovements();
                            // Refresh dicepool modifiers due to filled condition monitor boxes
                            RefreshWoundPenalties();
                            // Refresh dicepool modifiers due to sustained spells
                            RefreshSustainingPenalties();
                            // Refresh encumbrance penalties
                            RefreshEncumbrance();
                            // Curb Mystic Adept power points if the values that were loaded in would be illegal
                            if (MysticAdeptPowerPoints > 0)
                            {
                                int intMAGTotalValue = MAG.TotalValue;
                                if (MysticAdeptPowerPoints > intMAGTotalValue)
                                    MysticAdeptPowerPoints = intMAGTotalValue;
                            }

                            if (!InitiationEnabled || !AddInitiationsAllowed)
                                ClearInitiations();
                            foreach (Func<bool> funcToCall in PostLoadMethods)
                                if (!funcToCall.Invoke())
                                    return false;
                            PostLoadMethods.Clear();
                            //Timekeeper.Finish("load_char_improvementrefreshers");
                        }

                        //// If the character had old Qualities that were converted, immediately save the file so they are in the new format.
                        //if (blnHasOldQualities)
                        //{
                        //    Timekeeper.Start("load_char_resav");  //Lets not silently save file on load?
                        //    Save();
                        //    Timekeeper.Finish("load_char_resav");
                        //}
                        loadActivity.SetSuccess(true);
                    }
                    catch (Exception e)
                    {
                        loadActivity.SetSuccess(false);
                        Log.Error(e);
                        throw;
                    }
                }
                return true;
            }

            finally
            {
                IsLoadMethodRunning = false;
            }
        }

        public XmlDocument GenerateExportXml(CultureInfo objCultureInfo, string strLanguage)
        {
            return CommonFunctions.GenerateCharactersExportXml(objCultureInfo, strLanguage, this);
        }

        public XmlDocument GenerateExportXml(CultureInfo objCultureInfo, string strLanguage, CancellationToken objToken)
        {
            return CommonFunctions.GenerateCharactersExportXml(objCultureInfo, strLanguage, objToken, this);
        }

        /// <summary>
        /// Print this character information to a XmlTextWriter. This creates only the character object itself, not any of the opening or closing XmlDocument items.
        /// This can be used to write multiple characters to a single XmlDocument.
        /// </summary>
        /// <param name="objWriter">XmlTextWriter to write to.</param>
        /// <param name="objCulture">Culture in which to print.</param>
        /// <param name="strLanguageToPrint">Language in which to print.</param>
        public void PrintToXmlTextWriter(XmlTextWriter objWriter, CultureInfo objCulture = null, string strLanguageToPrint = "")
        {
            if (objWriter == null)
                throw new ArgumentNullException(nameof(objWriter));
            if (objCulture == null)
                objCulture = GlobalSettings.CultureInfo;
            if (string.IsNullOrEmpty(strLanguageToPrint))
                strLanguageToPrint = GlobalSettings.Language;
            // <character>
            objWriter.WriteStartElement("character");

            // <settings />
            objWriter.WriteElementString("settings", SettingsKey);
            // <buildmethod />
            objWriter.WriteElementString("buildmethod", Settings.BuildMethod.ToString());
            // <imageformat />
            objWriter.WriteElementString("imageformat", "jpeg"); // Here for legacy/compatibility purposes, we always export as JPEG now
            // <metatype />
            objWriter.WriteElementString("metatype", DisplayMetatype(strLanguageToPrint));
            // <metatype_english />
            objWriter.WriteElementString("metatype_english", Metatype);
            // <metatype_guid />
            objWriter.WriteElementString("metatype_guid", MetatypeGuid.ToString("D", GlobalSettings.InvariantCultureInfo));
            // <metavariant />
            objWriter.WriteElementString("metavariant", DisplayMetavariant(strLanguageToPrint));
            // <metavariant_english />
            objWriter.WriteElementString("metavariant_english", Metavariant);
            // <metavariant_guid />
            objWriter.WriteElementString("metavariant_guid", MetavariantGuid.ToString("D", GlobalSettings.InvariantCultureInfo));
            // <movement />
            objWriter.WriteElementString("movement", FullMovement(objCulture, strLanguageToPrint));
            // <walk />
            objWriter.WriteElementString("walk", FullMovement(objCulture, strLanguageToPrint));
            // <run />
            objWriter.WriteElementString("run", FullMovement(objCulture, strLanguageToPrint));
            // <sprint />
            objWriter.WriteElementString("sprint", FullMovement(objCulture, strLanguageToPrint));
            // <movementwalk />
            objWriter.WriteElementString("movementwalk", GetMovement(objCulture, strLanguageToPrint));
            // <movementswim />
            objWriter.WriteElementString("movementswim", GetSwim(objCulture, strLanguageToPrint));
            // <movementfly />
            objWriter.WriteElementString("movementfly", GetFly(objCulture, strLanguageToPrint));

            // <prioritymetatype />
            objWriter.WriteElementString("prioritymetatype", MetatypePriority);
            // <priorityattributes />
            objWriter.WriteElementString("priorityattributes", AttributesPriority);
            // <priorityspecial />
            objWriter.WriteElementString("priorityspecial", SpecialPriority);
            // <priorityskills />
            objWriter.WriteElementString("priorityskills", SkillsPriority);
            // <priorityresources />
            objWriter.WriteElementString("priorityresources", ResourcesPriority);
            // <priorityskills >
            objWriter.WriteStartElement("priorityskills");
            foreach(string strSkill in PriorityBonusSkillList)
            {
                objWriter.WriteElementString("priorityskill", strSkill);
            }

            // </priorityskills>
            objWriter.WriteEndElement();

            // <handedness />
            if(Ambidextrous)
            {
                objWriter.WriteElementString("primaryarm",
                    LanguageManager.GetString("String_Ambidextrous", strLanguageToPrint));
            }
            else if(PrimaryArm == "Left")
            {
                objWriter.WriteElementString("primaryarm",
                    LanguageManager.GetString("String_Improvement_SideLeft", strLanguageToPrint));
            }
            else
            {
                objWriter.WriteElementString("primaryarm",
                    LanguageManager.GetString("String_Improvement_SideRight", strLanguageToPrint));
            }

            // If the character does not have a name, call them Unnamed Character. This prevents a transformed document from
            // having a self-terminated title tag which causes browser to not rendering anything.
            // <name />
            objWriter.WriteElementString("name",
                !string.IsNullOrEmpty(Name)
                    ? Name
                    : LanguageManager.GetString("String_UnnamedCharacter", strLanguageToPrint));

            PrintMugshots(objWriter);

            // <sex />
            objWriter.WriteElementString("gender",
                TranslateExtra(ReverseTranslateExtra(Gender, GlobalSettings.Language, "contacts.xml"),
                    strLanguageToPrint, "contacts.xml"));
            // <age />
            objWriter.WriteElementString("age",
                TranslateExtra(ReverseTranslateExtra(Age, GlobalSettings.Language, "contacts.xml"), strLanguageToPrint,
                    "contacts.xml"));
            // <eyes />
            objWriter.WriteElementString("eyes", TranslateExtra(ReverseTranslateExtra(Eyes), strLanguageToPrint));
            // <height />
            objWriter.WriteElementString("height", TranslateExtra(ReverseTranslateExtra(Height), strLanguageToPrint));
            // <weight />
            objWriter.WriteElementString("weight", TranslateExtra(ReverseTranslateExtra(Weight), strLanguageToPrint));
            // <skin />
            objWriter.WriteElementString("skin", TranslateExtra(ReverseTranslateExtra(Skin), strLanguageToPrint));
            // <hair />
            objWriter.WriteElementString("hair", TranslateExtra(ReverseTranslateExtra(Hair), strLanguageToPrint));
            // <description />
            objWriter.WriteElementString("description", Description.RtfToHtml());
            // <background />
            objWriter.WriteElementString("background", Background.RtfToHtml());
            // <concept />
            objWriter.WriteElementString("concept", Concept.RtfToHtml());
            // <notes />
            objWriter.WriteElementString("notes", Notes.RtfToHtml());
            // <alias />
            objWriter.WriteElementString("alias", Alias);
            // <playername />
            objWriter.WriteElementString("playername", PlayerName);
            // <gamenotes />
            objWriter.WriteElementString("gamenotes", GameNotes.RtfToHtml());

            // <limitphysical />
            objWriter.WriteElementString("limitphysical", LimitPhysical.ToString(objCulture));
            // <limitmental />
            objWriter.WriteElementString("limitmental", LimitMental.ToString(objCulture));
            // <limitsocial />
            objWriter.WriteElementString("limitsocial", LimitSocial.ToString(objCulture));
            // <limitastral />
            objWriter.WriteElementString("limitastral", LimitAstral.ToString(objCulture));
            // <contactpoints />
            objWriter.WriteElementString("contactpoints", ContactPoints.ToString(objCulture));
            // <contactpointsused />
            objWriter.WriteElementString("contactpointsused", ContactPointsUsed.ToString(objCulture));
            // <cfplimit />
            objWriter.WriteElementString("cfplimit", CFPLimit.ToString(objCulture));
            // <totalaiprogramlimit />
            objWriter.WriteElementString("ainormalprogramlimit", AINormalProgramLimit.ToString(objCulture));
            // <aiadvancedprogramlimit />
            objWriter.WriteElementString("aiadvancedprogramlimit", AIAdvancedProgramLimit.ToString(objCulture));
            // <spelllimit />
            objWriter.WriteElementString("spelllimit", FreeSpells.ToString(objCulture));
            // <karma />
            objWriter.WriteElementString("karma", Karma.ToString(objCulture));
            // <totalkarma />
            objWriter.WriteElementString("totalkarma", CareerKarma.ToString(objCulture));
            // <special />
            objWriter.WriteElementString("special", Special.ToString(objCulture));
            // <totalspecial />
            objWriter.WriteElementString("totalspecial", TotalSpecial.ToString(objCulture));
            // <attributes />
            objWriter.WriteElementString("attributes", Attributes.ToString(objCulture));
            // <totalattributes />
            objWriter.WriteElementString("totalattributes", TotalAttributes.ToString(objCulture));
            // <edgeused />
            objWriter.WriteElementString("edgeused", EdgeUsed.ToString(objCulture));
            // <edgeremaining />
            objWriter.WriteElementString("edgeremaining", EdgeRemaining.ToString(objCulture));
            // <streetcred />
            objWriter.WriteElementString("streetcred", StreetCred.ToString(objCulture));
            // <calculatedstreetcred />
            objWriter.WriteElementString("calculatedstreetcred", CalculatedStreetCred.ToString(objCulture));
            // <totalstreetcred />
            objWriter.WriteElementString("totalstreetcred", TotalStreetCred.ToString(objCulture));
            // <burntstreetcred />
            objWriter.WriteElementString("burntstreetcred", BurntStreetCred.ToString(objCulture));
            // <notoriety />
            objWriter.WriteElementString("notoriety", Notoriety.ToString(objCulture));
            // <calculatednotoriety />
            objWriter.WriteElementString("calculatednotoriety", CalculatedNotoriety.ToString(objCulture));
            // <totalnotoriety />
            objWriter.WriteElementString("totalnotoriety", TotalNotoriety.ToString(objCulture));
            // <publicawareness />
            objWriter.WriteElementString("publicawareness", PublicAwareness.ToString(objCulture));
            // <calculatedpublicawareness />
            objWriter.WriteElementString("calculatedpublicawareness", CalculatedPublicAwareness.ToString(objCulture));
            // <totalpublicawareness />
            objWriter.WriteElementString("totalpublicawareness", TotalPublicAwareness.ToString(objCulture));
            // <astralreputation />
            objWriter.WriteElementString("astralreputation", AstralReputation.ToString(objCulture));
            // <totalastralreputation />
            objWriter.WriteElementString("totalastralreputation", TotalAstralReputation.ToString(objCulture));
            // <wildreputation />
            objWriter.WriteElementString("wildreputation", WildReputation.ToString(objCulture));
            // <totalwildreputation />
            objWriter.WriteElementString("totalwildreputation", TotalWildReputation.ToString(objCulture));
            // <created />
            objWriter.WriteElementString("created", Created.ToString(GlobalSettings.InvariantCultureInfo));
            // <nuyen />
            objWriter.WriteElementString("nuyen", Nuyen.ToString(Settings.NuyenFormat, objCulture));
            // <adept />
            objWriter.WriteElementString("adept", AdeptEnabled.ToString(GlobalSettings.InvariantCultureInfo));
            // <magician />
            objWriter.WriteElementString("magician", MagicianEnabled.ToString(GlobalSettings.InvariantCultureInfo));
            // <technomancer />
            objWriter.WriteElementString("technomancer", TechnomancerEnabled.ToString(GlobalSettings.InvariantCultureInfo));
            // <ai />
            objWriter.WriteElementString("ai", AdvancedProgramsEnabled.ToString(GlobalSettings.InvariantCultureInfo));
            // <cyberwaredisabled />
            objWriter.WriteElementString("cyberwaredisabled", CyberwareDisabled.ToString(GlobalSettings.InvariantCultureInfo));
            // <critter />
            objWriter.WriteElementString("critter", CritterEnabled.ToString(GlobalSettings.InvariantCultureInfo));

            objWriter.WriteElementString("totaless", Essence().ToString(Settings.EssenceFormat, objCulture));

            // <tradition />
            if(MagicTradition.Type != TraditionType.None)
            {
                MagicTradition.Print(objWriter, objCulture, strLanguageToPrint);
            }

            // <attributes>
            objWriter.WriteStartElement("attributes");
            AttributeSection.Print(objWriter, objCulture, strLanguageToPrint);

            // </attributes>
            objWriter.WriteEndElement();
            // <dodge />
            objWriter.WriteElementString("dodge", Dodge.ToString(objCulture));
            // <armor />
            objWriter.WriteElementString("armor", TotalArmorRating.ToString(objCulture));
            // <firearmor />
            objWriter.WriteElementString("firearmor", TotalFireArmorRating.ToString(objCulture));
            // <coldarmor />
            objWriter.WriteElementString("coldarmor", TotalColdArmorRating.ToString(objCulture));
            // <electricityarmor />
            objWriter.WriteElementString("electricityarmor", TotalElectricityArmorRating.ToString(objCulture));
            // <acidarmor />
            objWriter.WriteElementString("acidarmor", TotalAcidArmorRating.ToString(objCulture));
            // <fallingarmor />
            objWriter.WriteElementString("fallingarmor", TotalFallingArmorRating.ToString(objCulture));

            int intDamageResistanceDice = ImprovementManager.ValueOf(this, Improvement.ImprovementType.DamageResistance).StandardRound();
            // <armordicestun />
            objWriter.WriteElementString("armordicestun",
                (BOD.TotalValue + intDamageResistanceDice + TotalArmorRating).ToString(objCulture));
            // <firearmordicestun />
            objWriter.WriteElementString("firearmordicestun",
                (BOD.TotalValue + intDamageResistanceDice + TotalFireArmorRating).ToString(objCulture));
            // <coldarmordicestun />
            objWriter.WriteElementString("coldarmordicestun",
                (BOD.TotalValue + intDamageResistanceDice + TotalColdArmorRating).ToString(objCulture));
            // <electricityarmordicestun />
            objWriter.WriteElementString("electricityarmordicestun",
                (BOD.TotalValue + intDamageResistanceDice + TotalElectricityArmorRating).ToString(objCulture));
            // <acidarmordicestun />
            objWriter.WriteElementString("acidarmordicestun",
                (BOD.TotalValue + intDamageResistanceDice + TotalAcidArmorRating).ToString(objCulture));
            // <fallingarmordicestun />
            objWriter.WriteElementString("fallingarmordicestun",
                (BOD.TotalValue + intDamageResistanceDice + TotalFallingArmorRating).ToString(objCulture));
            // <armordicephysical />
            objWriter.WriteElementString("armordicephysical",
                (BOD.TotalValue + intDamageResistanceDice + TotalArmorRating).ToString(objCulture));
            // <firearmordicephysical />
            objWriter.WriteElementString("firearmordicephysical",
                (BOD.TotalValue + intDamageResistanceDice + TotalFireArmorRating).ToString(objCulture));
            // <coldarmordicephysical />
            objWriter.WriteElementString("coldarmordicephysical",
                (BOD.TotalValue + intDamageResistanceDice + TotalColdArmorRating).ToString(objCulture));
            // <electricityarmordicephysical />
            objWriter.WriteElementString("electricityarmordicephysical",
                (BOD.TotalValue + intDamageResistanceDice + TotalElectricityArmorRating).ToString(objCulture));
            // <acidarmordicephysical />
            objWriter.WriteElementString("acidarmordicephysical",
                (BOD.TotalValue + intDamageResistanceDice + TotalAcidArmorRating).ToString(objCulture));
            // <fallingarmordicephysical />
            objWriter.WriteElementString("fallingarmordicephysical",
                (BOD.TotalValue + intDamageResistanceDice + TotalFallingArmorRating).ToString(objCulture));

            bool blnIsAI = IsAI;
            bool blnPhysicalTrackIsCore = blnIsAI && !(HomeNode is Vehicle);
            // Condition Monitors.
            // <physicalcm />
            int intPhysicalCM = PhysicalCM;
            objWriter.WriteElementString("physicalcm", intPhysicalCM.ToString(objCulture));
            objWriter.WriteElementString("physicalcmiscorecm",
                blnPhysicalTrackIsCore.ToString(GlobalSettings.InvariantCultureInfo));
            // <stuncm />
            int intStunCM = StunCM;
            objWriter.WriteElementString("stuncm", intStunCM.ToString(objCulture));
            objWriter.WriteElementString("stuncmismatrixcm", blnIsAI.ToString(GlobalSettings.InvariantCultureInfo));

            // Condition Monitor Progress.
            // <physicalcmfilled />
            objWriter.WriteElementString("physicalcmfilled", PhysicalCMFilled.ToString(objCulture));
            // <stuncmfilled />
            objWriter.WriteElementString("stuncmfilled", StunCMFilled.ToString(objCulture));

            // <cmthreshold>
            objWriter.WriteElementString("cmthreshold", CMThreshold.ToString(objCulture));
            // <cmthresholdoffset>
            objWriter.WriteElementString("physicalcmthresholdoffset",
                Math.Min(PhysicalCMThresholdOffset, intPhysicalCM).ToString(objCulture));
            // <cmthresholdoffset>
            objWriter.WriteElementString("stuncmthresholdoffset",
                Math.Min(StunCMThresholdOffset, intStunCM).ToString(objCulture));
            // <cmoverflow>
            objWriter.WriteElementString("cmoverflow", CMOverflow.ToString(objCulture));

            // <psyche>
            objWriter.WriteElementString("psyche", _blnPsycheActive.ToString(GlobalSettings.InvariantCultureInfo));

            // Calculate Initiatives.
            // Initiative.
            objWriter.WriteElementString("init", GetInitiative(objCulture, strLanguageToPrint));
            objWriter.WriteElementString("initdice", InitiativeDice.ToString(objCulture));
            objWriter.WriteElementString("initvalue", InitiativeValue.ToString(objCulture));
            objWriter.WriteElementString("initbonus",
                Math.Max(ImprovementManager.ValueOf(this, Improvement.ImprovementType.Initiative), 0)
                    .ToString(objCulture));

            // Astral Initiative.
            if(MAGEnabled)
            {
                objWriter.WriteElementString("astralinit", GetAstralInitiative(objCulture, strLanguageToPrint));
                objWriter.WriteElementString("astralinitdice", AstralInitiativeDice.ToString(objCulture));
                objWriter.WriteElementString("astralinitvalue", AstralInitiativeValue.ToString(objCulture));
            }

            // Matrix Initiative (AR).
            objWriter.WriteElementString("matrixarinit", GetMatrixInitiative(objCulture, strLanguageToPrint));
            objWriter.WriteElementString("matrixarinitdice", MatrixInitiativeDice.ToString(objCulture));
            objWriter.WriteElementString("matrixarinitvalue", MatrixInitiativeValue.ToString(objCulture));

            // Matrix Initiative (Cold).
            objWriter.WriteElementString("matrixcoldinit", GetMatrixInitiativeCold(objCulture, strLanguageToPrint));
            objWriter.WriteElementString("matrixcoldinitdice", MatrixInitiativeDice.ToString(objCulture));
            objWriter.WriteElementString("matrixcoldinitvalue", MatrixInitiativeValue.ToString(objCulture));

            // Matrix Initiative (Hot).
            objWriter.WriteElementString("matrixhotinit", GetMatrixInitiativeHot(objCulture, strLanguageToPrint));
            objWriter.WriteElementString("matrixhotinitdice", MatrixInitiativeDice.ToString(objCulture));
            objWriter.WriteElementString("matrixhotinitvalue", MatrixInitiativeValue.ToString(objCulture));

            // Rigger Initiative.
            objWriter.WriteElementString("riggerinit", GetInitiative(objCulture, strLanguageToPrint));

            // <magenabled />
            objWriter.WriteElementString("magenabled", MAGEnabled.ToString(GlobalSettings.InvariantCultureInfo));
            // <initiategrade />
            objWriter.WriteElementString("initiategrade", InitiateGrade.ToString(objCulture));
            // <resenabled />
            objWriter.WriteElementString("resenabled", RESEnabled.ToString(GlobalSettings.InvariantCultureInfo));
            // <submersiongrade />
            objWriter.WriteElementString("submersiongrade", SubmersionGrade.ToString(objCulture));
            // <depenabled />
            objWriter.WriteElementString("depenabled", DEPEnabled.ToString(GlobalSettings.InvariantCultureInfo));
            // <groupmember />
            objWriter.WriteElementString("groupmember", GroupMember.ToString(GlobalSettings.InvariantCultureInfo));
            // <groupname />
            objWriter.WriteElementString("groupname", GroupName);
            // <groupnotes />
            objWriter.WriteElementString("groupnotes", GroupNotes);
            // <surprise />
            objWriter.WriteElementString("surprise", Surprise.ToString(objCulture));
            // <composure />
            objWriter.WriteElementString("composure", Composure.ToString(objCulture));
            // <judgeintentions />
            objWriter.WriteElementString("judgeintentions", JudgeIntentions.ToString(objCulture));
            // <judgeintentionsresist />
            objWriter.WriteElementString("judgeintentionsresist", JudgeIntentionsResist.ToString(objCulture));
            // <liftandcarry />
            objWriter.WriteElementString("liftandcarry", LiftAndCarry.ToString(objCulture));
            // <memory />
            objWriter.WriteElementString("memory", Memory.ToString(objCulture));
            // <liftweight />
            objWriter.WriteElementString("liftweight", (STR.TotalValue * 15).ToString(objCulture));
            // <carryweight />
            objWriter.WriteElementString("carryweight", (STR.TotalValue * 10).ToString(objCulture));
            // <fatigueresist />
            objWriter.WriteElementString("fatigueresist", FatigueResist.ToString(objCulture));
            // <radiationresist />
            objWriter.WriteElementString("radiationresist", RadiationResist.ToString(objCulture));
            // <sonicresist />
            objWriter.WriteElementString("sonicresist", SonicResist.ToString(objCulture));
            // <toxincontacttesist />
            objWriter.WriteElementString("toxincontactresist", ToxinContactResist(strLanguageToPrint, objCulture));
            // <toxiningestionresist />
            objWriter.WriteElementString("toxiningestionresist", ToxinIngestionResist(strLanguageToPrint, objCulture));
            // <toxininhalationresist />
            objWriter.WriteElementString("toxininhalationresist",
                ToxinInhalationResist(strLanguageToPrint, objCulture));
            // <toxininjectionresist />
            objWriter.WriteElementString("toxininjectionresist", ToxinInjectionResist(strLanguageToPrint, objCulture));
            // <pathogencontactresist />
            objWriter.WriteElementString("pathogencontactresist",
                PathogenContactResist(strLanguageToPrint, objCulture));
            // <pathogeningestionresist />
            objWriter.WriteElementString("pathogeningestionresist",
                PathogenIngestionResist(strLanguageToPrint, objCulture));
            // <pathogeninhalationresist />
            objWriter.WriteElementString("pathogeninhalationresist",
                PathogenInhalationResist(strLanguageToPrint, objCulture));
            // <pathogeninjectionresist />
            objWriter.WriteElementString("pathogeninjectionresist",
                PathogenInjectionResist(strLanguageToPrint, objCulture));
            // <physiologicaladdictionresistfirsttime />
            objWriter.WriteElementString("physiologicaladdictionresistfirsttime",
                PhysiologicalAddictionResistFirstTime.ToString(objCulture));
            // <physiologicaladdictionresistalreadyaddicted />
            objWriter.WriteElementString("physiologicaladdictionresistalreadyaddicted",
                PhysiologicalAddictionResistAlreadyAddicted.ToString(objCulture));
            // <psychologicaladdictionresistfirsttime />
            objWriter.WriteElementString("psychologicaladdictionresistfirsttime",
                PsychologicalAddictionResistFirstTime.ToString(objCulture));
            // <psychologicaladdictionresistalreadyaddicted />
            objWriter.WriteElementString("psychologicaladdictionresistalreadyaddicted",
                PsychologicalAddictionResistAlreadyAddicted.ToString(objCulture));
            // <physicalcmnaturalrecovery />
            objWriter.WriteElementString("physicalcmnaturalrecovery", PhysicalCMNaturalRecovery.ToString(objCulture));
            // <stuncmnaturalrecovery />
            objWriter.WriteElementString("stuncmnaturalrecovery", StunCMNaturalRecovery.ToString(objCulture));

            // Spell Resistances
            //Indirect Dodge
            objWriter.WriteElementString("indirectdefenseresist", SpellDefenseIndirectDodge.ToString(objCulture));
            //Direct Soak - Mana
            objWriter.WriteElementString("directmanaresist", SpellDefenseDirectSoakMana.ToString(objCulture));
            //Direct Soak - Physical
            objWriter.WriteElementString("directphysicalresist", SpellDefenseDirectSoakPhysical.ToString(objCulture));
            //Detection Spells
            objWriter.WriteElementString("detectionspellresist", SpellDefenseDetection.ToString(objCulture));
            //Decrease Attribute - BOD
            objWriter.WriteElementString("decreasebodresist", SpellDefenseDecreaseBOD.ToString(objCulture));
            //Decrease Attribute - AGI
            objWriter.WriteElementString("decreaseagiresist", SpellDefenseDecreaseAGI.ToString(objCulture));
            //Decrease Attribute - REA
            objWriter.WriteElementString("decreaserearesist", SpellDefenseDecreaseREA.ToString(objCulture));
            //Decrease Attribute - STR
            objWriter.WriteElementString("decreasestrresist", SpellDefenseDecreaseSTR.ToString(objCulture));
            //Decrease Attribute - CHA
            objWriter.WriteElementString("decreasecharesist", SpellDefenseDecreaseCHA.ToString(objCulture));
            //Decrease Attribute - INT
            objWriter.WriteElementString("decreaseintresist", SpellDefenseDecreaseINT.ToString(objCulture));
            //Decrease Attribute - LOG
            objWriter.WriteElementString("decreaselogresist", SpellDefenseDecreaseLOG.ToString(objCulture));
            //Decrease Attribute - WIL
            objWriter.WriteElementString("decreasewilresist", SpellDefenseDecreaseWIL.ToString(objCulture));
            //Illusion - Mana
            objWriter.WriteElementString("illusionmanaresist", SpellDefenseIllusionMana.ToString(objCulture));
            //Illusion - Physical
            objWriter.WriteElementString("illusionphysicalresist", SpellDefenseIllusionPhysical.ToString(objCulture));
            //Manipulation - Mental
            objWriter.WriteElementString("manipulationmentalresist",
                SpellDefenseManipulationMental.ToString(objCulture));
            //Manipulation - Physical
            objWriter.WriteElementString("manipulationphysicalresist",
                SpellDefenseManipulationPhysical.ToString(objCulture));

            // <skills>
            objWriter.WriteStartElement("skills");
            SkillsSection.Print(objWriter, objCulture, strLanguageToPrint);
            objWriter.WriteEndElement();

            // <contacts>
            objWriter.WriteStartElement("contacts");
            foreach(Contact objContact in Contacts)
            {
                objContact.Print(objWriter, objCulture, strLanguageToPrint);
            }

            // </contacts>
            objWriter.WriteEndElement();

            // <limitmodifiersphys>
            objWriter.WriteStartElement("limitmodifiersphys");
            foreach(LimitModifier objLimitModifier in LimitModifiers)
            {
                if (objLimitModifier.Limit == "Physical")
                    objLimitModifier.Print(objWriter, objCulture, strLanguageToPrint);
            }

            // Populate Limit Modifiers from Improvements
            foreach(Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.LimitModifier, "Physical"))
            {
                string strName = GetObjectName(objImprovement, strLanguageToPrint);
                if(strName == objImprovement.SourceName)
                    strName = objImprovement.UniqueName;
                strName += LanguageManager.GetString("String_Colon", strLanguageToPrint) + LanguageManager.GetString("String_Space", strLanguageToPrint);
                if(objImprovement.Value > 0)
                    strName += '+';
                strName += objImprovement.Value.ToString(objCulture);

                if(!string.IsNullOrEmpty(objImprovement.Condition))
                    strName += ',' + LanguageManager.GetString("String_Space", strLanguageToPrint) + objImprovement.Condition;

                objWriter.WriteStartElement("limitmodifier");
                objWriter.WriteElementString("name", strName);
                if(GlobalSettings.PrintNotes)
                    objWriter.WriteElementString("notes", objImprovement.Notes);
                objWriter.WriteEndElement();
            }

            // </limitmodifiersphys>
            objWriter.WriteEndElement();

            // <limitmodifiersment>
            objWriter.WriteStartElement("limitmodifiersment");
            foreach(LimitModifier objLimitModifier in LimitModifiers)
            {
                if (objLimitModifier.Limit == "Mental")
                    objLimitModifier.Print(objWriter, objCulture, strLanguageToPrint);
            }

            // Populate Limit Modifiers from Improvements
            foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.LimitModifier, "Mental"))
            {
                string strName = GetObjectName(objImprovement, strLanguageToPrint);
                if(strName == objImprovement.SourceName)
                    strName = objImprovement.UniqueName;
                strName += LanguageManager.GetString("String_Colon", strLanguageToPrint) + LanguageManager.GetString("String_Space", strLanguageToPrint);
                if(objImprovement.Value > 0)
                    strName += '+';
                strName += objImprovement.Value.ToString(objCulture);

                if(!string.IsNullOrEmpty(objImprovement.Condition))
                    strName += ',' + LanguageManager.GetString("String_Space", strLanguageToPrint) + objImprovement.Condition;

                objWriter.WriteStartElement("limitmodifier");
                objWriter.WriteElementString("name", strName);
                if(GlobalSettings.PrintNotes)
                    objWriter.WriteElementString("notes", objImprovement.Notes);
                objWriter.WriteEndElement();
            }

            // </limitmodifiersment>
            objWriter.WriteEndElement();

            // <limitmodifierssoc>
            objWriter.WriteStartElement("limitmodifierssoc");
            foreach(LimitModifier objLimitModifier in LimitModifiers)
            {
                if (objLimitModifier.Limit == "Social")
                    objLimitModifier.Print(objWriter, objCulture, strLanguageToPrint);
            }

            // Populate Limit Modifiers from Improvements
            foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.LimitModifier, "Social"))
            {
                string strName = GetObjectName(objImprovement, strLanguageToPrint);
                if(strName == objImprovement.SourceName)
                    strName = objImprovement.UniqueName;
                strName += LanguageManager.GetString("String_Colon", strLanguageToPrint) + LanguageManager.GetString("String_Space", strLanguageToPrint);
                if(objImprovement.Value > 0)
                    strName += '+';
                strName += objImprovement.Value.ToString(objCulture);

                if(!string.IsNullOrEmpty(objImprovement.Condition))
                    strName += ',' + LanguageManager.GetString("String_Space", strLanguageToPrint) + objImprovement.Condition;

                objWriter.WriteStartElement("limitmodifier");
                objWriter.WriteElementString("name", strName);
                if(GlobalSettings.PrintNotes)
                    objWriter.WriteElementString("notes", objImprovement.Notes);
                objWriter.WriteEndElement();
            }

            // </limitmodifierssoc>
            objWriter.WriteEndElement();

            // <mentorspirits>
            objWriter.WriteStartElement("mentorspirits");
            foreach (MentorSpirit objMentorSpirit in MentorSpirits)
            {
                objMentorSpirit.Print(objWriter, strLanguageToPrint);
            }

            // </mentorspirits>
            objWriter.WriteEndElement();

            // <spells>
            objWriter.WriteStartElement("spells");
            foreach(Spell objSpell in Spells)
            {
                objSpell.Print(objWriter, objCulture, strLanguageToPrint);
            }

            // </spells>
            objWriter.WriteEndElement();

            // <powers>
            objWriter.WriteStartElement("powers");
            foreach(Power objPower in Powers)
            {
                objPower.Print(objWriter, objCulture, strLanguageToPrint);
            }

            // </powers>
            objWriter.WriteEndElement();

            // <spirits>
            objWriter.WriteStartElement("spirits");
            foreach(Spirit objSpirit in Spirits)
            {
                objSpirit.Print(objWriter, objCulture, strLanguageToPrint);
            }

            // </spirits>
            objWriter.WriteEndElement();

            // <complexforms>
            objWriter.WriteStartElement("complexforms");
            foreach(ComplexForm objComplexForm in ComplexForms)
            {
                objComplexForm.Print(objWriter, strLanguageToPrint);
            }

            // </complexforms>
            objWriter.WriteEndElement();

            // <aiprograms>
            objWriter.WriteStartElement("aiprograms");
            foreach(AIProgram objProgram in AIPrograms)
            {
                objProgram.Print(objWriter, strLanguageToPrint);
            }

            // </aiprograms>
            objWriter.WriteEndElement();

            // <martialarts>
            objWriter.WriteStartElement("martialarts");
            foreach(MartialArt objMartialArt in MartialArts)
            {
                objMartialArt.Print(objWriter, objCulture, strLanguageToPrint);
            }

            // </martialarts>
            objWriter.WriteEndElement();

            // <armors>
            objWriter.WriteStartElement("armors");
            foreach(Armor objArmor in Armor)
            {
                objArmor.Print(objWriter, objCulture, strLanguageToPrint);
            }

            // </armors>
            objWriter.WriteEndElement();

            // <weapons>
            objWriter.WriteStartElement("weapons");
            foreach(Weapon objWeapon in Weapons)
            {
                objWeapon.Print(objWriter, objCulture, strLanguageToPrint);
            }

            // </weapons>
            objWriter.WriteEndElement();

            // <cyberwares>
            objWriter.WriteStartElement("cyberwares");
            foreach(Cyberware objCyberware in Cyberware)
            {
                objCyberware.Print(objWriter, objCulture, strLanguageToPrint);
            }

            // </cyberwares>
            objWriter.WriteEndElement();

            // <qualities>
            // Multiple instances of the same quality are combined into just one entry with a number next to it (e.g. 6 discrete entries of "Focused Concentration" become "Focused Concentration 6")
            Dictionary<string, int> strQualitiesToPrint = new Dictionary<string, int>(Qualities.Count);
            foreach(Quality objQuality in Qualities)
            {
                string strKey = objQuality.SourceIDString + '|' + objQuality.SourceName + '|' + objQuality.Extra;
                if(strQualitiesToPrint.TryGetValue(strKey, out int intExistingRating))
                {
                    strQualitiesToPrint[strKey] = intExistingRating + 1;
                }
                else
                {
                    strQualitiesToPrint.Add(strKey, 1);
                }
            }

            objWriter.WriteStartElement("qualities");
            foreach(Quality objQuality in Qualities)
            {
                string strKey = objQuality.SourceIDString + '|' + objQuality.SourceName + '|' + objQuality.Extra;
                if(strQualitiesToPrint.TryGetValue(strKey, out int intLoopRating))
                {
                    objQuality.Print(objWriter, intLoopRating, objCulture, strLanguageToPrint);
                    strQualitiesToPrint.Remove(strKey);
                }
            }

            // </qualities>
            objWriter.WriteEndElement();

            // <lifestyles>
            objWriter.WriteStartElement("lifestyles");
            foreach(Lifestyle objLifestyle in Lifestyles)
            {
                objLifestyle.Print(objWriter, objCulture, strLanguageToPrint);
            }

            // </lifestyles>
            objWriter.WriteEndElement();

            // <gears>
            objWriter.WriteStartElement("gears");
            foreach(Gear objGear in Gear)
            {
                objGear.Print(objWriter, objCulture, strLanguageToPrint);
            }

            // </gears>
            objWriter.WriteEndElement();

            // <drugs>
            objWriter.WriteStartElement("drugs");
            foreach(Drug objDrug in Drugs)
            {
                objDrug.Print(objWriter, objCulture, strLanguageToPrint);
            }

            // </drugs>
            objWriter.WriteEndElement();

            // <vehicles>
            objWriter.WriteStartElement("vehicles");
            foreach(Vehicle objVehicle in Vehicles)
            {
                objVehicle.Print(objWriter, objCulture, strLanguageToPrint);
            }

            // </vehicles>
            objWriter.WriteEndElement();

            // <initiationgrades>
            objWriter.WriteStartElement("initiationgrades");
            foreach(InitiationGrade objGrade in InitiationGrades)
            {
                objGrade.Print(objWriter, objCulture);

                //TODO: Probably better to integrate this into the main print method, but eh.
                // <metamagics>
                objWriter.WriteStartElement("metamagics");
                foreach(Metamagic objMetamagic in Metamagics)
                {
                    if (objMetamagic.Grade == objGrade.Grade)
                        objMetamagic.Print(objWriter, objCulture, strLanguageToPrint);
                }

                // </metamagics>
                objWriter.WriteEndElement();

                // <arts>
                objWriter.WriteStartElement("arts");
                foreach(Art objArt in Arts)
                {
                    if (objArt.Grade == objGrade.Grade)
                        objArt.Print(objWriter, strLanguageToPrint);
                }

                // </arts>
                objWriter.WriteEndElement();

                // <enhancements>
                objWriter.WriteStartElement("enhancements");
                foreach(Enhancement objEnhancement in Enhancements)
                {
                    if (objEnhancement.Grade == objGrade.Grade)
                        objEnhancement.Print(objWriter, strLanguageToPrint);
                }

                // </enhancements>
                objWriter.WriteEndElement();
            }

            // </initiationgrade>
            objWriter.WriteEndElement();

            // <metamagics>
            objWriter.WriteStartElement("metamagics");
            foreach(Metamagic objMetamagic in Metamagics)
            {
                objMetamagic.Print(objWriter, objCulture, strLanguageToPrint);
            }

            // </metamagics>
            objWriter.WriteEndElement();

            // <arts>
            objWriter.WriteStartElement("arts");
            foreach(Art objArt in Arts)
            {
                objArt.Print(objWriter, strLanguageToPrint);
            }

            // </arts>
            objWriter.WriteEndElement();

            // <enhancements>
            objWriter.WriteStartElement("enhancements");
            foreach(Enhancement objEnhancement in Enhancements)
            {
                objEnhancement.Print(objWriter, strLanguageToPrint);
            }

            // </enhancements>
            objWriter.WriteEndElement();

            // <critterpowers>
            objWriter.WriteStartElement("critterpowers");
            foreach(CritterPower objPower in CritterPowers)
            {
                objPower.Print(objWriter, strLanguageToPrint);
            }

            // </critterpowers>
            objWriter.WriteEndElement();

            // <sustained>
            objWriter.WriteStartElement("sustainedobjects");
            foreach (SustainedObject objSustained in SustainedCollection)
            {
                objSustained.Print(objWriter, objCulture, strLanguageToPrint);
            }

            //</sustained>
            objWriter.WriteEndElement();

            // <calendar>
            objWriter.WriteStartElement("calendar");
            //Calendar.Sort();
            foreach(CalendarWeek objWeek in Calendar)
                objWeek.Print(objWriter, objCulture, GlobalSettings.PrintNotes);
            // </expenses>
            objWriter.WriteEndElement();

            // Print the Expense Log Entries if the option is enabled.
            if(GlobalSettings.PrintExpenses)
            {
                // <expenses>
                objWriter.WriteStartElement("expenses");
                foreach(ExpenseLogEntry objExpense in ExpenseEntries.Reverse())
                    objExpense.Print(objWriter, objCulture, strLanguageToPrint);
                // </expenses>
                objWriter.WriteEndElement();
            }

            // </character>
            objWriter.WriteEndElement();
        }
        #endregion

        private bool _blnDisposing;
        /// <summary>
        /// Remove stray event handlers and clear all info used by this character
        /// </summary>
        public void Dispose()
        {
            if (_blnDisposing)
                return;
            if (!Utils.IsUnitTest && (Program.MainForm.OpenCharacters.Contains(this) || Program.MainForm.OpenCharacters.Any(x => x.LinkedCharacters.Contains(this))))
                return; // Do not actually dispose any characters who are still in the open characters list or required by a character who is

            _blnDisposing = true;
            _lstLinkedCharacters.Clear(); // Clear this list because it relates to Contacts and Spirits disposal
            foreach (Image imgMugshot in _lstMugshots)
                imgMugshot.Dispose();
            foreach (Contact objContact in _lstContacts)
                objContact.Dispose();
            foreach (Spirit objSpirit in _lstSpirits)
                objSpirit.Dispose();
            _lstLifestyles.Clear(); // Will automatically dispose all Lifestyles
            ImprovementManager.ClearCachedValues(this);
            AttributeSection.Dispose();
            SkillsSection.Dispose();
            DoOnSaveCompleted.Dispose();
            if (!SettingsManager.LoadedCharacterSettings.ContainsKey(_objSettings.DictionaryKey))
                _objSettings.Dispose();
            _blnDisposing = false;
        }

        /// <summary>
        /// Reset all of the Character information and start from scratch.
        /// </summary>
        public void ResetCharacter()
        {
            _intFreeSpells = 0;
            _intCFPLimit = 0;
            _intAINormalProgramLimit = 0;
            _intAIAdvancedProgramLimit = 0;
            _intCachedAllowSpriteFettering = int.MinValue;
            _intCachedAmbidextrous = int.MinValue;
            _intCachedBlackMarketDiscount = int.MinValue;
            _intCachedCareerKarma = int.MinValue;
            _intCachedContactPoints = int.MinValue;
            _intCachedDealerConnectionDiscount = int.MinValue;
            _intCachedEnemyKarma = int.MinValue;
            _intCachedErased = int.MinValue;
            _intCachedExCon = int.MinValue;
            _intCachedFame = int.MinValue;
            _intCachedFriendsInHighPlaces = int.MinValue;
            _intCachedInitiationEnabled = int.MinValue;
            _intCachedMadeMan = int.MinValue;
            _intCachedMetagenicNegativeQualities = int.MinValue;
            _intCachedMetagenicPositiveQualities = int.MinValue;
            _intCachedNegativeQualities = int.MinValue;
            _intCachedNegativeQualityLimitKarma = int.MinValue;
            _intCachedOverclocker = int.MinValue;
            _intCachedPositiveQualities = int.MinValue;
            _intCachedPositiveQualitiesTotal = int.MinValue;
            _intCachedRedlinerBonus = int.MinValue;
            _intCachedRestrictedGear = int.MinValue;
            _intCachedTotalAcidArmorRating = int.MinValue;
            _intCachedTotalArmorRating = int.MinValue;
            _intCachedTotalColdArmorRating = int.MinValue;
            _intCachedTotalElectricityArmorRating = int.MinValue;
            _intCachedTotalFallingArmorRating = int.MinValue;
            _intCachedTotalFireArmorRating = int.MinValue;
            _intCurrentCounterspellingDice = 0;
            _decCachedBiowareEssence = decimal.MinValue;
            _decCachedCyberwareEssence = decimal.MinValue;
            ResetCachedEssence();
            _decCachedEssenceHole = decimal.MinValue;
            _decCachedPowerPointsUsed = decimal.MinValue;
            _decCachedPrototypeTranshumanEssenceUsed = decimal.MinValue;
            _intContactPointsUsed = 0;
            _intKarma = 0;
            _intSpecial = 0;
            _intTotalSpecial = 0;
            _intAttributes = 0;
            _intTotalAttributes = 0;
            _intEdgeUsed = 0;
            _intBoundSpiritLimit = int.MinValue;
            _intRegisteredSpriteLimit = int.MinValue;

            // Reset Metatype Information.
            _strMetatype = string.Empty;
            _strMetavariant = string.Empty;
            _strMetatypeCategory = string.Empty;
            _intMetatypeBP = 0;
            _strMovement = string.Empty;

            // Reset Special Tab Flags.
            _blnAdeptEnabled = false;
            _blnMagicianEnabled = false;
            _blnTechnomancerEnabled = false;
            _blnAdvancedProgramsEnabled = false;
            _blnCyberwareDisabled = false;
            _blnInitiationDisabled = false;
            _blnCritterEnabled = false;

            // Reset Attributes.
            AttributeSection.Reset();
            _blnMAGEnabled = false;
            _blnRESEnabled = false;
            _blnDEPEnabled = false;
            _blnGroupMember = false;
            _strGroupName = string.Empty;
            _strGroupNotes = string.Empty;
            _intInitiateGrade = 0;
            _intSubmersionGrade = 0;

            _intMAGAdept = 0;
            _intMAGMagician = 0;

            _lstLinkedCharacters.Clear();
            _intMainMugshotIndex = -1;
            foreach (Image imgMugshot in _lstMugshots)
                imgMugshot.Dispose();
            _lstMugshots.Clear();
            foreach (Contact objContact in _lstContacts)
                objContact.Dispose();
            _lstContacts.Clear();
            foreach (Spirit objSpirit in _lstSpirits)
                objSpirit.Dispose();
            _lstSpirits.Clear();
            // Reset all of the Lists.
            // This kills the GC
            ImprovementManager.ClearCachedValues(this);
            _lstImprovements.Clear();
            _lstSpells.Clear();
            _lstSustainedObjects.Clear();
            _lstFoci.Clear();
            _lstStackedFoci.Clear();
            _lstPowers.Clear();
            _lstComplexForms.Clear();
            _lstAIPrograms.Clear();
            _lstMartialArts.Clear();
            _lstLimitModifiers.Clear();
            _lstArmor.Clear();
            _lstCyberware.Clear();
            _lstMetamagics.Clear();
            _lstArts.Clear();
            _lstEnhancements.Clear();
            _lstWeapons.Clear();
            _lstLifestyles.Clear();
            _lstGear.Clear();
            _lstVehicles.Clear();
            _lstExpenseLog.Clear();
            _lstCritterPowers.Clear();
            _lstInitiationGrades.Clear();
            _lstQualities.Clear();
            _lstCalendar.Clear();
            _lstDrugs.Clear();

            SkillsSection.Reset();
            LoadAsDirty = false;
        }

        #endregion

        #region Helper Methods

        /// <summary>
        /// Retrieve the name of the Object that created an Improvement.
        /// </summary>
        /// <param name="objImprovement">Improvement to check.</param>
        /// <param name="strLanguage">Language in which to fetch name.</param>
        public string GetObjectName(Improvement objImprovement, string strLanguage = "")
        {
            if (objImprovement == null)
                return string.Empty;
            if (string.IsNullOrEmpty(strLanguage))
                strLanguage = GlobalSettings.Language;
            string strSpace = LanguageManager.GetString("String_Space", strLanguage);
            string strImprovedSourceName = objImprovement.SourceName.TrimEndOnce("Pair");
            bool blnWireless = false;

            if (strImprovedSourceName.EndsWith("Wireless", StringComparison.Ordinal))
            {
                blnWireless = true;
                strImprovedSourceName = strImprovedSourceName.TrimEndOnce("Wireless", true);
            }

            Improvement.ImprovementSource eSource = objImprovement.ImproveSource;
            switch (eSource)
            {
                case Improvement.ImprovementSource.Bioware:
                case Improvement.ImprovementSource.Cyberware:
                {
                    Cyberware objCyberware = Cyberware.DeepFirstOrDefault(x => x.Children,
                                                                          x => x.InternalId == strImprovedSourceName
                                                                               && x.SourceType == eSource);
                    if (objCyberware != null)
                    {
                        string strWareReturn = objCyberware.DisplayNameShort(strLanguage);
                        if (objCyberware.Parent != null)
                            strWareReturn += strSpace + '(' + objCyberware.Parent.DisplayNameShort(strLanguage) + ')';
                        if (blnWireless)
                            strWareReturn += strSpace + LanguageManager.GetString("String_Wireless", strLanguage);
                        return strWareReturn;
                    }

                    foreach (Vehicle objVehicle in Vehicles)
                    {
                        foreach (VehicleMod objVehicleMod in objVehicle.Mods)
                        {
                            objCyberware = objVehicleMod.Cyberware.DeepFirstOrDefault(x => x.Children,
                                x => x.InternalId == strImprovedSourceName);
                            if (objCyberware != null)
                            {
                                string strWareReturn
                                    = objCyberware.DisplayNameShort(strLanguage) + strSpace + '('
                                      + objVehicle.DisplayNameShort(strLanguage) + ','
                                      + strSpace + objVehicleMod.DisplayNameShort(strLanguage);
                                if (objCyberware.Parent != null)
                                    strWareReturn += ',' + strSpace + objCyberware.Parent.DisplayNameShort(strLanguage);
                                strWareReturn += ')';
                                if (blnWireless)
                                    strWareReturn
                                        += strSpace + LanguageManager.GetString("String_Wireless", strLanguage);
                                return strWareReturn;
                            }
                        }

                        foreach (WeaponMount objMount in objVehicle.WeaponMounts)
                        {
                            foreach (VehicleMod objVehicleMod in objMount.Mods)
                            {
                                objCyberware = objVehicleMod.Cyberware.DeepFirstOrDefault(x => x.Children,
                                    x => x.InternalId == strImprovedSourceName);
                                if (objCyberware != null)
                                {
                                    string strWareReturn
                                        = objCyberware.DisplayNameShort(strLanguage) + strSpace + '('
                                          + objVehicle.DisplayNameShort(strLanguage) + ',' + strSpace
                                          + objMount.DisplayNameShort(strLanguage) + ','
                                          + strSpace + objVehicleMod.DisplayNameShort(strLanguage);
                                    if (objCyberware.Parent != null)
                                        strWareReturn += ',' + strSpace
                                                             + objCyberware.Parent.DisplayNameShort(strLanguage);
                                    strWareReturn += ')';
                                    if (blnWireless)
                                        strWareReturn += strSpace
                                                         + LanguageManager.GetString("String_Wireless", strLanguage);
                                    return strWareReturn;
                                }
                            }
                        }
                    }

                    break;
                }
                case Improvement.ImprovementSource.Gear:
                {
                    Gear objReturnGear =
                        Gear.DeepFirstOrDefault(x => x.Children, x => x.InternalId == strImprovedSourceName);
                    if (objReturnGear != null)
                    {
                        string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                        if (objReturnGear.Parent is Gear parent)
                            strGearReturn += strSpace + '(' + parent.DisplayNameShort(strLanguage) + ')';
                        if (blnWireless)
                            strGearReturn += strSpace + LanguageManager.GetString("String_Wireless", strLanguage);
                        return strGearReturn;
                    }

                    objReturnGear = Weapons.FindWeaponGear(strImprovedSourceName, out WeaponAccessory objGearAccessory);

                    if (objReturnGear != null)
                    {
                        string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                        if (objReturnGear.Parent is Gear parent)
                            strGearReturn += strSpace + '(' + objGearAccessory.Parent.DisplayNameShort(strLanguage)
                                             + ','
                                             + strSpace
                                             + objGearAccessory.DisplayNameShort(strLanguage) + ',' + strSpace
                                             + parent.DisplayNameShort(strLanguage) + ')';
                        else
                            strGearReturn += strSpace + '(' + objGearAccessory.Parent.DisplayNameShort(strLanguage)
                                             + ','
                                             + strSpace + objGearAccessory.DisplayNameShort(strLanguage) + ')';
                        if (blnWireless)
                            strGearReturn
                                += strSpace + LanguageManager.GetString("String_Wireless", strLanguage);
                        return strGearReturn;
                    }

                    objReturnGear
                        = Armor.FindArmorGear(strImprovedSourceName, out Armor objArmor, out ArmorMod objArmorMod);
                    if (objReturnGear != null)
                    {
                        string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                        if (objReturnGear.Parent is Gear objParent)
                        {
                            strGearReturn += strSpace + '(' + objArmor.DisplayNameShort(strLanguage) + ',' + strSpace
                                             + objArmorMod.DisplayNameShort(strLanguage) + ',' + strSpace
                                             + objParent.DisplayNameShort(strLanguage) + ')';
                        }
                        else if (objArmorMod != null)
                            strGearReturn += strSpace + '(' + objArmor.DisplayNameShort(strLanguage) + ',' + strSpace
                                             + objArmorMod.DisplayNameShort(strLanguage) + ')';
                        else
                            strGearReturn += strSpace + '(' + objArmor.DisplayNameShort(strLanguage) + ')';

                        if (blnWireless)
                            strGearReturn += strSpace + LanguageManager.GetString("String_Wireless", strLanguage);
                        return strGearReturn;
                    }

                    objReturnGear = Cyberware.FindCyberwareGear(strImprovedSourceName, out Cyberware objGearCyberware);

                    if (objReturnGear != null)
                    {
                        string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                        if (objReturnGear.Parent is Gear parent)
                            strGearReturn += strSpace + '(' + objGearCyberware.DisplayNameShort(strLanguage) + ','
                                             + strSpace
                                             + strSpace + parent.DisplayNameShort(strLanguage) + ')';
                        else
                            strGearReturn += strSpace + '(' + objGearCyberware.DisplayNameShort(strLanguage) + ')';
                        if (blnWireless)
                            strGearReturn += strSpace + LanguageManager.GetString("String_Wireless", strLanguage);
                        return strGearReturn;
                    }

                    foreach (Vehicle objVehicle in Vehicles)
                    {
                        objReturnGear = objVehicle.GearChildren.DeepFirstOrDefault(x => x.Children,
                            x => x.InternalId == strImprovedSourceName);
                        if (objReturnGear != null)
                        {
                            string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                            if (objReturnGear.Parent is Gear parent)
                                strGearReturn += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ','
                                                 + strSpace
                                                 + strSpace + parent.DisplayNameShort(strLanguage) + ')';
                            else
                                strGearReturn += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ')';
                            if (blnWireless)
                                strGearReturn += strSpace + LanguageManager.GetString("String_Wireless", strLanguage);
                            return strGearReturn;
                        }

                        foreach (Weapon objWeapon in objVehicle.Weapons.DeepWhere(x => x.Children,
                                     x => x.WeaponAccessories.Any(y => y.GearChildren.Count > 0)))
                        {
                            foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                            {
                                objReturnGear = objAccessory.GearChildren.DeepFirstOrDefault(x => x.Children,
                                    x => x.InternalId == strImprovedSourceName);
                                if (objReturnGear != null)
                                {
                                    string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                                    if (objReturnGear.Parent is Gear parent)
                                        strGearReturn
                                            += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ','
                                               + strSpace
                                               + objWeapon.DisplayNameShort(strLanguage) + ',' + strSpace
                                               + objAccessory.DisplayNameShort(strLanguage) + ','
                                               + strSpace + parent.DisplayNameShort(strLanguage) + ')';
                                    else
                                        strGearReturn
                                            += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ','
                                               + strSpace
                                               + objWeapon.DisplayNameShort(strLanguage) + ',' + strSpace
                                               + objAccessory.DisplayNameShort(strLanguage) + ')';
                                    if (blnWireless)
                                        strGearReturn += strSpace
                                                         + LanguageManager.GetString("String_Wireless", strLanguage);
                                    return strGearReturn;
                                }
                            }
                        }

                        foreach (VehicleMod objVehicleMod in objVehicle.Mods)
                        {
                            foreach (Weapon objWeapon in objVehicleMod.Weapons.DeepWhere(x => x.Children,
                                         x => x.WeaponAccessories.Any(y => y.GearChildren.Count > 0)))
                            {
                                foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                                {
                                    objReturnGear = objAccessory.GearChildren.DeepFirstOrDefault(x => x.Children,
                                        x => x.InternalId == strImprovedSourceName);
                                    if (objReturnGear != null)
                                    {
                                        string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                                        if (objReturnGear.Parent is Gear parent)
                                            strGearReturn
                                                += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ','
                                                   + strSpace + objVehicleMod.DisplayNameShort(strLanguage)
                                                   + ',' + strSpace + objWeapon.DisplayNameShort(strLanguage) + ','
                                                   + strSpace + objAccessory.DisplayNameShort(strLanguage)
                                                   + ',' + strSpace + parent.DisplayNameShort(strLanguage) + ')';
                                        else
                                            strGearReturn
                                                += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ','
                                                   + strSpace + objVehicleMod.DisplayNameShort(strLanguage)
                                                   + ',' + strSpace + objWeapon.DisplayNameShort(strLanguage) + ','
                                                   + strSpace + objAccessory.DisplayNameShort(strLanguage) + ')';
                                        if (blnWireless)
                                            strGearReturn += strSpace
                                                             + LanguageManager.GetString(
                                                                 "String_Wireless", strLanguage);
                                        return strGearReturn;
                                    }
                                }
                            }

                            foreach (Cyberware objCyberware in objVehicleMod.Cyberware.DeepWhere(x => x.Children,
                                         x => x.GearChildren.Count > 0))
                            {
                                objReturnGear = objCyberware.GearChildren.DeepFirstOrDefault(x => x.Children,
                                    x => x.InternalId == strImprovedSourceName);
                                if (objReturnGear != null)
                                {
                                    string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                                    if (objReturnGear.Parent is Gear parent)
                                        strGearReturn
                                            += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ','
                                               + strSpace + objVehicleMod.DisplayNameShort(strLanguage)
                                               + ',' + strSpace + objCyberware.DisplayNameShort(strLanguage) + ','
                                               + strSpace + parent.DisplayNameShort(strLanguage) + ')';
                                    else
                                        strGearReturn
                                            += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ','
                                               + strSpace + objVehicleMod.DisplayNameShort(strLanguage)
                                               + ',' + strSpace + objCyberware.DisplayNameShort(strLanguage) + ')';
                                    if (blnWireless)
                                        strGearReturn += strSpace
                                                         + LanguageManager.GetString("String_Wireless", strLanguage);
                                    return strGearReturn;
                                }
                            }
                        }

                        foreach (WeaponMount objMount in objVehicle.WeaponMounts)
                        {
                            foreach (VehicleMod objVehicleMod in objMount.Mods)
                            {
                                foreach (Weapon objWeapon in objVehicleMod.Weapons.DeepWhere(x => x.Children,
                                             x => x.WeaponAccessories.Any(y => y.GearChildren.Count > 0)))
                                {
                                    foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                                    {
                                        objReturnGear = objAccessory.GearChildren.DeepFirstOrDefault(x => x.Children,
                                            x => x.InternalId == strImprovedSourceName);
                                        if (objReturnGear != null)
                                        {
                                            string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                                            if (objReturnGear.Parent is Gear parent)
                                                strGearReturn
                                                    += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ','
                                                       + strSpace + objMount.DisplayNameShort(strLanguage) + ','
                                                       + strSpace + objVehicleMod.DisplayNameShort(strLanguage)
                                                       + ',' + strSpace + objWeapon.DisplayNameShort(strLanguage) + ','
                                                       + strSpace + objAccessory.DisplayNameShort(strLanguage)
                                                       + ',' + strSpace + parent.DisplayNameShort(strLanguage) + ')';
                                            else
                                                strGearReturn
                                                    += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ','
                                                       + strSpace + objMount.DisplayNameShort(strLanguage) + ','
                                                       + strSpace + objVehicleMod.DisplayNameShort(strLanguage)
                                                       + ',' + strSpace + objWeapon.DisplayNameShort(strLanguage) + ','
                                                       + strSpace + objAccessory.DisplayNameShort(strLanguage) + ')';
                                            if (blnWireless)
                                                strGearReturn += strSpace
                                                                 + LanguageManager.GetString(
                                                                     "String_Wireless", strLanguage);
                                            return strGearReturn;
                                        }
                                    }
                                }

                                foreach (Cyberware objCyberware in objVehicleMod.Cyberware.DeepWhere(x => x.Children,
                                             x => x.GearChildren.Count > 0))
                                {
                                    objReturnGear = objCyberware.GearChildren.DeepFirstOrDefault(x => x.Children,
                                        x => x.InternalId == strImprovedSourceName);
                                    if (objReturnGear != null)
                                    {
                                        string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                                        if (objReturnGear.Parent is Gear parent)
                                            strGearReturn
                                                += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ','
                                                   + strSpace + objMount.DisplayNameShort(strLanguage) + ',' + strSpace
                                                   + objVehicleMod.DisplayNameShort(strLanguage)
                                                   + ',' + strSpace + objCyberware.DisplayNameShort(strLanguage) + ','
                                                   + strSpace + parent.DisplayNameShort(strLanguage) + ')';
                                        else
                                            strGearReturn
                                                += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ','
                                                   + strSpace + objMount.DisplayNameShort(strLanguage) + ',' + strSpace
                                                   + objVehicleMod.DisplayNameShort(strLanguage)
                                                   + ',' + strSpace + objCyberware.DisplayNameShort(strLanguage) + ')';
                                        if (blnWireless)
                                            strGearReturn += strSpace
                                                             + LanguageManager.GetString(
                                                                 "String_Wireless", strLanguage);
                                        return strGearReturn;
                                    }
                                }
                            }
                        }
                    }

                    break;
                }
                case Improvement.ImprovementSource.Spell:
                    foreach(Spell objSpell in Spells)
                    {
                        if(objSpell.InternalId == strImprovedSourceName)
                        {
                            return objSpell.DisplayNameShort(strLanguage);
                        }
                    }

                    break;
                case Improvement.ImprovementSource.Power:
                    foreach(Power objPower in Powers)
                    {
                        if(objPower.InternalId == strImprovedSourceName)
                        {
                            return objPower.DisplayNameShort(strLanguage);
                        }
                    }

                    break;
                case Improvement.ImprovementSource.CritterPower:
                    foreach(CritterPower objPower in CritterPowers)
                    {
                        if(objPower.InternalId == strImprovedSourceName)
                        {
                            return objPower.DisplayNameShort(strLanguage);
                        }
                    }

                    break;
                case Improvement.ImprovementSource.Metamagic:
                    foreach (Metamagic objMetamagic in Metamagics)
                    {
                        if (objMetamagic.InternalId == strImprovedSourceName && objMetamagic.SourceType == Improvement.ImprovementSource.Metamagic)
                        {
                            return objMetamagic.DisplayNameShort(strLanguage);
                        }
                    }

                    break;
                case Improvement.ImprovementSource.Echo:
                    foreach(Metamagic objMetamagic in Metamagics)
                    {
                        if(objMetamagic.InternalId == strImprovedSourceName && objMetamagic.SourceType == Improvement.ImprovementSource.Echo)
                        {
                            return objMetamagic.DisplayNameShort(strLanguage);
                        }
                    }

                    break;
                case Improvement.ImprovementSource.Art:
                    foreach(Art objArt in Arts)
                    {
                        if(objArt.InternalId == strImprovedSourceName)
                        {
                            return objArt.DisplayNameShort(strLanguage);
                        }
                    }

                    break;
                case Improvement.ImprovementSource.Enhancement:
                    foreach(Enhancement objEnhancement in Enhancements)
                    {
                        if(objEnhancement.InternalId == strImprovedSourceName)
                        {
                            return objEnhancement.DisplayNameShort(strLanguage);
                        }
                    }

                    break;
                case Improvement.ImprovementSource.Armor:
                {
                    foreach (Armor objArmor in Armor)
                    {
                        if (objArmor.InternalId == strImprovedSourceName)
                        {
                            string strReturnArmor = objArmor.DisplayNameShort(strLanguage);
                            if (blnWireless)
                                strReturnArmor += strSpace + LanguageManager.GetString("String_Wireless", strLanguage);
                            return strReturnArmor;
                        }
                    }

                    break;
                }
                case Improvement.ImprovementSource.ArmorMod:
                {
                    foreach (Armor objArmor in Armor)
                    {
                        foreach (ArmorMod objMod in objArmor.ArmorMods)
                        {
                            if (objMod.InternalId == strImprovedSourceName)
                            {
                                string strReturnArmorMod = objMod.DisplayNameShort(strLanguage) + strSpace + '('
                                                           + objArmor.DisplayNameShort(strLanguage) + ')';
                                if (blnWireless)
                                    strReturnArmorMod
                                        += strSpace + LanguageManager.GetString("String_Wireless", strLanguage);
                                return strReturnArmorMod;
                            }
                        }
                    }

                    break;
                }
                case Improvement.ImprovementSource.ComplexForm:
                    foreach(ComplexForm objComplexForm in ComplexForms)
                    {
                        if(objComplexForm.InternalId == strImprovedSourceName)
                        {
                            return objComplexForm.DisplayNameShort(strLanguage);
                        }
                    }

                    break;
                case Improvement.ImprovementSource.AIProgram:
                    foreach(AIProgram objProgram in AIPrograms)
                    {
                        if(objProgram.InternalId == strImprovedSourceName)
                        {
                            return objProgram.DisplayNameShort(strLanguage);
                        }
                    }

                    break;
                case Improvement.ImprovementSource.Quality:
                    if(strImprovedSourceName.StartsWith("SEEKER", StringComparison.Ordinal))
                    {
                        if (strImprovedSourceName == "SEEKER_WIL")
                            return LoadDataXPath("qualities.xml")
                                   .SelectSingleNode(
                                       "/chummer/qualities/quality[name = \"Cyber-Singularity Seeker\"]/translate")
                                   ?.Value ?? "Cyber-Singularity Seeker";
                        return LoadDataXPath("qualities.xml")
                               .SelectSingleNode("/chummer/qualities/quality[name = \"Redliner\"]/translate")
                               ?.Value ?? "Redliner";
                    }

                    foreach(Quality objQuality in Qualities)
                    {
                        if(objQuality.InternalId == strImprovedSourceName)
                        {
                            return objQuality.DisplayNameShort(strLanguage);
                        }
                    }

                    break;
                case Improvement.ImprovementSource.MartialArtTechnique:
                    foreach (MartialArtTechnique objTechnique in MartialArts.SelectMany(x => x.Techniques))
                    {
                        if (objTechnique.InternalId == strImprovedSourceName)
                        {
                            return objTechnique.DisplayName(strLanguage);
                        }
                    }

                    break;
                case Improvement.ImprovementSource.MentorSpirit:
                    foreach(MentorSpirit objMentorSpirit in MentorSpirits)
                    {
                        if(objMentorSpirit.InternalId == strImprovedSourceName)
                        {
                            return objMentorSpirit.DisplayNameShort(strLanguage);
                        }
                    }

                    break;
                case Improvement.ImprovementSource.Heritage:
                    return LanguageManager.GetString("String_Priority", strLanguage);
                case Improvement.ImprovementSource.Initiation:
                    return LanguageManager.GetString("Tab_Initiation", strLanguage);
                case Improvement.ImprovementSource.Submersion:
                    return LanguageManager.GetString("Tab_Submersion", strLanguage);
                case Improvement.ImprovementSource.ArmorEncumbrance:
                    return LanguageManager.GetString("String_ArmorEncumbrance", strLanguage);
                case Improvement.ImprovementSource.Tradition:
                    return LanguageManager.GetString("String_Tradition", strLanguage);
                case Improvement.ImprovementSource.AstralReputation:
                    return LanguageManager.GetString("String_AstralReputation", strLanguage);
                case Improvement.ImprovementSource.CyberadeptDaemon:
                    return LoadDataXPath("qualities.xml", strLanguage)
                        .SelectSingleNode(
                            "/chummer/qualities/quality[name = \"Resonant Stream: Cyberadept\"]/translate")
                        ?.Value ?? "Resonant Stream: Cyberadept";
                default:
                    if(objImprovement.ImproveType == Improvement.ImprovementType.ArmorEncumbrancePenalty)
                        return LanguageManager.GetString("String_ArmorEncumbrance", strLanguage);
                    // If this comes from a custom Improvement, use the name the player gave it instead of showing a GUID.
                    if(!string.IsNullOrEmpty(objImprovement.CustomName))
                        return objImprovement.CustomName;
                    string strReturn = strImprovedSourceName;
                    if(string.IsNullOrEmpty(strReturn) || strReturn.IsGuid())
                    {
                        string strTemp = LanguageManager.GetString("String_" + objImprovement.ImproveSource,
                            strLanguage, false);
                        if(!string.IsNullOrEmpty(strTemp))
                            strReturn = strTemp;
                    }

                    return strReturn;
            }

            return string.Empty;
        }

        public void CleanUpOrphanedImprovements()
        {
            int intNewImprovementCount = 0;
            int intOldImprovementCount = Improvements.Count;
            // Loop this until we remove every single orphaned improvement (necessary because orphaned improvements can add other improvements)
            while (intOldImprovementCount != intNewImprovementCount)
            {
                intOldImprovementCount = Improvements.Count;
                // Relying on (a lack of) GetObjectName is slower than ideal, but much easier to maintain
                Improvements.RemoveAll(x => string.IsNullOrEmpty(GetObjectName(x, GlobalSettings.DefaultLanguage)));
                intNewImprovementCount = Improvements.Count;
            }
        }

        public void FormatImprovementModifiers(StringBuilder sbdToolTip, IEnumerable<Improvement.ImprovementType> improvements, string strSpace, int intModifiers)
        {
            if (sbdToolTip == null)
                return;
            sbdToolTip.Append(strSpace).Append('+').Append(strSpace).Append(LanguageManager.GetString("Tip_Modifiers"));
            bool blnFirstModifier = true;
            foreach (Improvement.ImprovementType eType in improvements)
            {
                foreach (Improvement objLoopImprovement in ImprovementManager.GetCachedImprovementListForValueOf(this, eType))
                {
                    if (blnFirstModifier)
                    {
                        blnFirstModifier = false;
                        sbdToolTip.Append(LanguageManager.GetString("String_Colon"));
                    }
                    else
                        sbdToolTip.Append(',');

                    sbdToolTip.Append(strSpace).Append(GetObjectName(objLoopImprovement));
                }
            }

            sbdToolTip.Append(strSpace).Append('(').Append(intModifiers.ToString(GlobalSettings.CultureInfo)).Append(')');
        }

        /// <summary>
        /// Return a list of CyberwareGrades from XML files.
        /// </summary>
        /// <param name="objSource">Source to load the Grades from, either Bioware or Cyberware.</param>
        /// <param name="blnIgnoreBannedGrades">Whether to ignore grades banned at chargen.</param>
        public IEnumerable<Grade> GetGradeList(Improvement.ImprovementSource objSource, bool blnIgnoreBannedGrades = false)
        {
            string strXPath;
            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdFilter))
            {
                if (Settings != null)
                {
                    sbdFilter.Append('(').Append(Settings.BookXPath()).Append(") and ");
                    if (!IgnoreRules && !Created && !blnIgnoreBannedGrades)
                    {
                        foreach (string strBannedGrade in Settings.BannedWareGrades)
                        {
                            sbdFilter.Append("not(contains(name, ").Append(strBannedGrade.CleanXPath())
                                     .Append(")) and ");
                        }
                    }
                }

                if (sbdFilter.Length != 0)
                {
                    sbdFilter.Length -= 5;
                    strXPath = "/chummer/grades/grade[(" + sbdFilter + ")]";
                }
                else
                    strXPath = "/chummer/grades/grade";
            }

            using (XmlNodeList xmlGradeList = LoadData(Grade.GetDataFileNameFromImprovementSource(objSource)).SelectNodes(strXPath))
            {
                if (xmlGradeList?.Count > 0)
                {
                    foreach(XmlNode objNode in xmlGradeList)
                    {
                        Grade objGrade = new Grade(this, objSource);
                        objGrade.Load(objNode);
                        yield return objGrade;
                    }
                }
            }
        }

        /// <summary>
        /// Calculate the number of Free Spirit Power Points used.
        /// </summary>
        public string CalculateFreeSpiritPowerPoints()
        {
            string strSpace = LanguageManager.GetString("String_Space");

            if (Metatype == "Free Spirit" && !IsCritter)
            {
                // PC Free Spirit.
                decimal decPowerPoints = 0;

                foreach(CritterPower objPower in CritterPowers)
                {
                    if(objPower.CountTowardsLimit)
                        decPowerPoints += objPower.PowerPoints;
                }

                int intPowerPoints = EDG.TotalValue + ImprovementManager.ValueOf(this, Improvement.ImprovementType.FreeSpiritPowerPoints).StandardRound();

                // If the house rule to base Power Points on the character's MAG value instead, use the character's MAG.
                if(Settings.FreeSpiritPowerPointsMAG)
                    intPowerPoints = MAG.TotalValue + ImprovementManager.ValueOf(this,
                                         Improvement.ImprovementType.FreeSpiritPowerPoints).StandardRound();

                return intPowerPoints.ToString(GlobalSettings.CultureInfo) + strSpace + '('
                       + (intPowerPoints - decPowerPoints).ToString(GlobalSettings.CultureInfo) + strSpace
                       + LanguageManager.GetString("String_Remaining") + ')';
            }
            else
            {
                int intPowerPoints;

                switch (Metatype)
                {
                    case "Free Spirit":
                        // Critter Free Spirits have a number of Power Points equal to their EDG plus any Free Spirit Power Points Improvements.
                        intPowerPoints = EDG.TotalValue + ImprovementManager.ValueOf(this, Improvement.ImprovementType.FreeSpiritPowerPoints).StandardRound();
                        break;
                    case "Ally Spirit":
                        // Ally Spirits get a number of Power Points equal to their MAG.
                        intPowerPoints = MAG.TotalValue;
                        break;
                    default:
                        // Spirits get 1 Power Point for every 3 full points of Force (MAG) they possess.
                        intPowerPoints = MAG.TotalValue / 3;
                        break;
                }

                int intUsed = CritterPowers.Count(x => x.Category != "Weakness" && x.CountTowardsLimit); // _objCharacter.CritterPowers.Count - intExisting;

                return intPowerPoints.ToString(GlobalSettings.CultureInfo) + strSpace + '('
                       + (intPowerPoints - intUsed).ToString(GlobalSettings.CultureInfo) + strSpace
                       + LanguageManager.GetString("String_Remaining") + ')';
            }
        }

        /// <summary>
        /// Calculate the number of Free Sprite Power Points used.
        /// </summary>
        public string CalculateFreeSpritePowerPoints()
        {
            // Free Sprite Power Points.
            int intUsedPowerPoints = 0;

            foreach(CritterPower objPower in CritterPowers)
            {
                if(objPower.CountTowardsLimit)
                    ++intUsedPowerPoints;
            }

            int intPowerPoints = EDG.TotalValue + ImprovementManager.ValueOf(this, Improvement.ImprovementType.FreeSpiritPowerPoints).StandardRound();

            string strSpace = LanguageManager.GetString("String_Space");

            return intPowerPoints.ToString(GlobalSettings.CultureInfo) + strSpace + '(' + (intPowerPoints - intUsedPowerPoints).ToString(GlobalSettings.CultureInfo)
                        + strSpace + LanguageManager.GetString("String_Remaining") + ')';
        }

        /// <summary>
        /// Construct a list of possible places to put a piece of modular cyberware. Names are display names of the given items, values are internalIDs of the given items.
        /// </summary>
        /// <param name="objModularCyberware">Cyberware for which to construct the list.</param>
        /// <returns></returns>
        public IEnumerable<ListItem> ConstructModularCyberlimbList([NotNull] Cyberware objModularCyberware)
        {
            yield return new ListItem("None", LanguageManager.GetString("String_None"));

            string strSpace = LanguageManager.GetString("String_Space");

            foreach(Cyberware objLoopCyberware in Cyberware.GetAllDescendants(x => x.Children))
            {
                // Make sure this has an eligible mount location and it's not the selected piece modular cyberware
                if(objLoopCyberware.HasModularMount == objModularCyberware.PlugsIntoModularMount
                   && (objLoopCyberware.Location == objModularCyberware.Location
                       || string.IsNullOrEmpty(objModularCyberware.Location))
                   && objLoopCyberware.Grade.Name == objModularCyberware.Grade.Name
                   && objLoopCyberware != objModularCyberware
                   // Make sure it's not the place where the mount is already occupied (either by us or something else)
                   && objLoopCyberware.Children.All(x => x.PlugsIntoModularMount != objLoopCyberware.HasModularMount))
                {
                    string strName = objLoopCyberware.Parent?.CurrentDisplayName
                                     ?? objLoopCyberware.CurrentDisplayName;
                    yield return new ListItem(objLoopCyberware.InternalId, strName);
                }
            }

            foreach(Vehicle objLoopVehicle in Vehicles)
            {
                foreach(VehicleMod objLoopVehicleMod in objLoopVehicle.Mods)
                {
                    foreach(Cyberware objLoopCyberware in objLoopVehicleMod.Cyberware.GetAllDescendants(x => x.Children))
                    {
                        // Make sure this has an eligible mount location and it's not the selected piece modular cyberware
                        if(objLoopCyberware.HasModularMount == objModularCyberware.PlugsIntoModularMount
                           && objLoopCyberware.Location == objModularCyberware.Location
                           && objLoopCyberware.Grade.Name == objModularCyberware.Grade.Name
                           && objLoopCyberware != objModularCyberware
                           // Make sure it's not the place where the mount is already occupied (either by us or something else)
                           && objLoopCyberware.Children.All(x => x.PlugsIntoModularMount != objLoopCyberware.HasModularMount))
                        {
                            string strName = objLoopVehicle.CurrentDisplayName
                                             + strSpace + (objLoopCyberware.Parent?.CurrentDisplayName
                                                           ?? objLoopVehicleMod.CurrentDisplayName);
                            yield return new ListItem(objLoopCyberware.InternalId, strName);
                        }
                    }
                }

                foreach(WeaponMount objLoopWeaponMount in objLoopVehicle.WeaponMounts)
                {
                    foreach(VehicleMod objLoopVehicleMod in objLoopWeaponMount.Mods)
                    {
                        foreach(Cyberware objLoopCyberware in objLoopVehicleMod.Cyberware.GetAllDescendants(x => x.Children))
                        {
                            // Make sure this has an eligible mount location and it's not the selected piece modular cyberware
                            if(objLoopCyberware.HasModularMount == objModularCyberware.PlugsIntoModularMount
                               && objLoopCyberware.Location == objModularCyberware.Location
                               && objLoopCyberware.Grade.Name == objModularCyberware.Grade.Name
                               && objLoopCyberware != objModularCyberware
                               // Make sure it's not the place where the mount is already occupied (either by us or something else)
                               && objLoopCyberware.Children.All(x => x.PlugsIntoModularMount != objLoopCyberware.HasModularMount))
                            {
                                string strName = objLoopVehicle.CurrentDisplayName
                                                 + strSpace + (objLoopCyberware.Parent?.CurrentDisplayName
                                                               ?? objLoopVehicleMod.CurrentDisplayName);
                                yield return new ListItem(objLoopCyberware.InternalId, strName);
                            }
                        }
                    }
                }
            }
        }

        public bool SwitchBuildMethods(CharacterBuildMethod eOldBuildMethod, CharacterBuildMethod eNewBuildMethod, string strOldSettingsKey)
        {
            DialogResult eResult;
            if (eNewBuildMethod.UsesPriorityTables())
            {
                eResult = Program.MainForm.DoThreadSafeFunc(() =>
                {
                    using (SelectMetatypePriority frmSelectMetatype = new SelectMetatypePriority(this))
                    {
                        frmSelectMetatype.ShowDialogSafe(Program.GetFormForDialog(this));
                        return frmSelectMetatype.DialogResult;
                    }
                });
            }
            else
            {
                eResult = Program.MainForm.DoThreadSafeFunc(() =>
                {
                    using (SelectMetatypeKarma frmSelectMetatype = new SelectMetatypeKarma(this))
                    {
                        frmSelectMetatype.ShowDialogSafe(Program.GetFormForDialog(this));
                        return frmSelectMetatype.DialogResult;
                    }
                });
            }
            if (eResult != DialogResult.OK)
            {
                SettingsKey = strOldSettingsKey;
                return false;
            }
            if (eOldBuildMethod == CharacterBuildMethod.LifeModule)
            {
                for (int i = Qualities.Count - 1; i >= 0; --i)
                {
                    if (i >= Qualities.Count)
                        continue;
                    Quality objQuality = Qualities[i];
                    if (objQuality.OriginSource == QualitySource.LifeModule)
                        objQuality.DeleteQuality();
                }
            }
            return true;
        }

        public string CalculateKarmaValue(string strLanguage, out int intReturn)
        {
            string strColonCharacter = LanguageManager.GetString("String_Colon");
            string strSpace = LanguageManager.GetString("String_Space");
            string strKarmaString = LanguageManager.GetString("String_Karma", strLanguage);
            int intExtraKarmaToRemoveForPointBuyComparison = 0;
            intReturn = Settings.BuildKarma;

            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdMessage))
            {
                sbdMessage.AppendLine(LanguageManager.GetString("Message_KarmaValue", strLanguage)).AppendLine()
                          .Append(LanguageManager.GetString("Label_Base", strLanguage))
                          .Append(strColonCharacter).Append(strSpace)
                          .Append(intReturn.ToString(GlobalSettings.CultureInfo))
                          .Append(strSpace).Append(strKarmaString);

                if (EffectiveBuildMethodUsesPriorityTables)
                {
                    // Zeroed to -10 because that's Human's value at default settings
                    int intMetatypeQualitiesValue = -2 * Settings.KarmaAttribute;
                    // Karma value of all qualities (we're ignoring metatype cost because Point Buy karma costs don't line up with other methods' values)
                    foreach (Quality objQuality in Qualities.Where(x =>
                                                                       x.OriginSource == QualitySource.Metatype
                                                                       || x.OriginSource
                                                                       == QualitySource.MetatypeRemovable))
                    {
                        XPathNavigator xmlQualityNode = objQuality.GetNodeXPath();
                        if (xmlQualityNode == null)
                            continue;
                        int intLoopKarma = 0;
                        if (xmlQualityNode.TryGetInt32FieldQuickly("karma", ref intLoopKarma))
                            intMetatypeQualitiesValue += intLoopKarma;
                    }

                    intReturn += intMetatypeQualitiesValue;

                    // Subtract extra karma cost of a metatype in priority
                    int intTemp = -MetatypeBP;
                    int intAttributesValue = 0;
                    // Value from attribute points and raised attribute minimums
                    foreach (CharacterAttrib objLoopAttrib in AttributeSection.AttributeList.Concat(AttributeSection
                                 .SpecialAttributeList))
                    {
                        string strAttributeName = objLoopAttrib.Abbrev;
                        if (strAttributeName != "ESS" &&
                            (strAttributeName != "MAGAdept" || (IsMysticAdept && Settings.MysAdeptSecondMAGAttribute))
                            &&
                            objLoopAttrib.MetatypeMaximum > 0)
                        {
                            int intLoopAttribValue =
                                Math.Max(objLoopAttrib.Base + objLoopAttrib.FreeBase + objLoopAttrib.RawMinimum,
                                         objLoopAttrib.TotalMinimum) + objLoopAttrib.AttributeValueModifiers;
                            if (intLoopAttribValue > 1)
                            {
                                intTemp += ((intLoopAttribValue + 1) * intLoopAttribValue / 2 - 1)
                                           * Settings.KarmaAttribute;
                                if (strAttributeName != "MAG" && strAttributeName != "MAGAdept" &&
                                    strAttributeName != "RES" && strAttributeName != "DEP")
                                {
                                    int intVanillaAttribValue =
                                        Math.Max(
                                            objLoopAttrib.Base + objLoopAttrib.FreeBase + objLoopAttrib.RawMinimum -
                                            objLoopAttrib.MetatypeMinimum + 1,
                                            objLoopAttrib.TotalMinimum - objLoopAttrib.MetatypeMinimum + 1) +
                                        objLoopAttrib.AttributeValueModifiers;
                                    intAttributesValue
                                        += ((intVanillaAttribValue + 1) * intVanillaAttribValue / 2 - 1) *
                                           Settings.KarmaAttribute;
                                }
                                else
                                    intAttributesValue += ((intLoopAttribValue + 1) * intLoopAttribValue / 2 - 1) *
                                                          Settings.KarmaAttribute;
                            }
                        }
                    }

                    // For point buy comparisons, we need to use the metatype's Point Buy cost for the comparison, not attributes + metatype qualities.
                    intExtraKarmaToRemoveForPointBuyComparison
                        += intTemp - intAttributesValue + intMetatypeQualitiesValue;

                    if (intTemp - intAttributesValue + intMetatypeQualitiesValue != 0)
                    {
                        sbdMessage.AppendLine().Append(LanguageManager.GetString("Label_SumtoTenHeritage", strLanguage))
                                  .Append(strSpace)
                                  .Append((intTemp - intAttributesValue + intMetatypeQualitiesValue).ToString(
                                              GlobalSettings.CultureInfo)).Append(strSpace).Append(strKarmaString);
                    }

                    if (intAttributesValue != 0)
                    {
                        sbdMessage.AppendLine()
                                  .Append(LanguageManager.GetString("Label_SumtoTenAttributes", strLanguage))
                                  .Append(strSpace).Append(intAttributesValue.ToString(GlobalSettings.CultureInfo))
                                  .Append(strSpace).Append(strKarmaString);
                    }

                    intReturn += intTemp;

                    // Karma needs to be added based on the character's metatype/metavariant Point Buy karma cost because that is what is used in Point Buy,
                    // not the metatype/metavariant attribute/quality costs.
                    intTemp = 0;
                    if (this.GetNodeXPath()?.TryGetInt32FieldQuickly("karma", ref intTemp) == true)
                        intExtraKarmaToRemoveForPointBuyComparison -= intTemp;

                    intTemp = 0;
                    // This is where "Talent" qualities like Adept and Technomancer get added in
                    foreach (Quality objQuality in Qualities.Where(x => x.OriginSource == QualitySource.Heritage))
                    {
                        XPathNavigator xmlQualityNode = objQuality.GetNodeXPath();
                        if (xmlQualityNode == null)
                            continue;
                        int intLoopKarma = 0;
                        if (xmlQualityNode?.TryGetInt32FieldQuickly("karma", ref intLoopKarma) == true)
                            intTemp += intLoopKarma;
                    }

                    if (intTemp != 0)
                    {
                        sbdMessage.AppendLine().Append(LanguageManager.GetString("String_Qualities", strLanguage))
                                  .Append(strColonCharacter).Append(strSpace)
                                  .Append(intTemp.ToString(GlobalSettings.CultureInfo)).Append(strSpace)
                                  .Append(strKarmaString);
                        intReturn += intTemp;
                    }

                    // Value from free spells
                    intTemp = FreeSpells * SpellKarmaCost("Spells");
                    if (intTemp != 0)
                    {
                        sbdMessage.AppendLine().Append(LanguageManager.GetString("String_FreeSpells", strLanguage))
                                  .Append(strColonCharacter).Append(strSpace)
                                  .Append(intTemp.ToString(GlobalSettings.CultureInfo)).Append(strSpace)
                                  .Append(strKarmaString);
                        intReturn += intTemp;
                    }

                    // Value from free complex forms
                    intTemp = CFPLimit * ComplexFormKarmaCost;
                    if (intTemp != 0)
                    {
                        sbdMessage.AppendLine().Append(LanguageManager.GetString("String_FreeCFs", strLanguage))
                                  .Append(strColonCharacter).Append(strSpace)
                                  .Append(intTemp.ToString(GlobalSettings.CultureInfo)).Append(strSpace)
                                  .Append(strKarmaString);
                        intReturn += intTemp;
                    }

                    intTemp = 0;
                    // Value from skill points
                    foreach (Skill objLoopActiveSkill in SkillsSection.Skills)
                    {
                        if (!(objLoopActiveSkill.SkillGroupObject?.Base > 0))
                        {
                            int intLoopRating = objLoopActiveSkill.Base;
                            if (intLoopRating > 0)
                            {
                                intTemp += Settings.KarmaNewActiveSkill;
                                intTemp += ((intLoopRating + 1) * intLoopRating / 2 - 1)
                                           * Settings.KarmaImproveActiveSkill;
                                if (EffectiveBuildMethodIsLifeModule)
                                    intTemp += objLoopActiveSkill.Specializations.Count(x => x.Free) *
                                               Settings.KarmaSpecialization;
                                else if (!objLoopActiveSkill.BuyWithKarma)
                                    intTemp += objLoopActiveSkill.Specializations.Count * Settings.KarmaSpecialization;
                            }
                        }
                    }

                    if (intTemp != 0)
                    {
                        sbdMessage.AppendLine().Append(LanguageManager.GetString("String_SkillPoints", strLanguage))
                                  .Append(strColonCharacter).Append(strSpace)
                                  .Append(intTemp.ToString(GlobalSettings.CultureInfo)).Append(strSpace)
                                  .Append(strKarmaString);
                        intReturn += intTemp;
                    }

                    intTemp = 0;
                    // Value from skill group points
                    foreach (int intLoopRating in SkillsSection.SkillGroups.Select(x => x.Base))
                    {
                        if (intLoopRating <= 0)
                            continue;
                        intTemp += Settings.KarmaNewSkillGroup;
                        intTemp += ((intLoopRating + 1) * intLoopRating / 2 - 1) * Settings.KarmaImproveSkillGroup;
                    }

                    if (intTemp != 0)
                    {
                        sbdMessage.AppendLine()
                                  .Append(LanguageManager.GetString("String_SkillGroupPoints", strLanguage))
                                  .Append(strColonCharacter).Append(strSpace)
                                  .Append(intTemp.ToString(GlobalSettings.CultureInfo)).Append(strSpace)
                                  .Append(strKarmaString);
                        intReturn += intTemp;
                    }

                    // Starting Nuyen karma value
                    decimal decBaseStartingNuyen
                        = CalculateStartingNuyenFromKarma(Math.Min(NuyenBP, TotalNuyenMaximumBP), StartingNuyen);
                    if (decBaseStartingNuyen != 0)
                    {
                        // Start off with the negative value of the karma we put into nuyen to make this calculation work properly for weird, nonlinear scaling
                        intTemp = -Math.Min(NuyenBP, TotalNuyenMaximumBP).ToInt32();
                        // This looks horrible, but we cannot use binary search or calculate karma value directly because XPath expressions are so free-form
                        // The only option is to loop through every possible Karma value until we find the lowest one that gives more nuyen than Priority gives
                        for (int i = 0; i < int.MaxValue; ++i)
                        {
                            decimal decLoopNuyen = CalculateStartingNuyenFromKarma(i, 0);
                            // This looks quite wonky when what we're actually looking for is the exact value, but effectively rounds karma requirements up in cases where Nuyen doesn't divide cleanly
                            if (decLoopNuyen >= decBaseStartingNuyen)
                            {
                                intTemp += i;
                                break;
                            }
                        }

                        if (intTemp != 0)
                        {
                            sbdMessage.AppendLine()
                                      .Append(LanguageManager.GetString("Checkbox_CreatePACKSKit_StartingNuyen",
                                                                        strLanguage)).Append(strColonCharacter)
                                      .Append(strSpace).Append(intTemp.ToString(GlobalSettings.CultureInfo))
                                      .Append(strSpace).Append(strKarmaString);
                            intReturn += intTemp;
                        }
                    }
                }

                int intContactPointsValue = ContactPoints * Settings.KarmaContact;
                if (intContactPointsValue != 0)
                {
                    sbdMessage.AppendLine().Append(LanguageManager.GetString("String_Contacts", strLanguage))
                              .Append(strColonCharacter).Append(strSpace)
                              .Append(intContactPointsValue.ToString(GlobalSettings.CultureInfo)).Append(strSpace)
                              .Append(strKarmaString);
                    intReturn += intContactPointsValue;
                    intExtraKarmaToRemoveForPointBuyComparison += intContactPointsValue;
                }

                int intKnowledgePointsValue = 0;
                foreach (KnowledgeSkill objLoopKnowledgeSkill in SkillsSection.KnowledgeSkills)
                {
                    int intLoopRating = objLoopKnowledgeSkill.Base;
                    if (intLoopRating > 0)
                    {
                        intKnowledgePointsValue += Settings.KarmaNewKnowledgeSkill;
                        intKnowledgePointsValue += ((intLoopRating + 1) * intLoopRating / 2 - 1) *
                                                   Settings.KarmaImproveKnowledgeSkill;
                        if (EffectiveBuildMethodIsLifeModule)
                            intKnowledgePointsValue += objLoopKnowledgeSkill.Specializations.Count(x => x.Free) *
                                                       Settings.KarmaKnowledgeSpecialization;
                        else if (!objLoopKnowledgeSkill.BuyWithKarma)
                            intKnowledgePointsValue += objLoopKnowledgeSkill.Specializations.Count *
                                                       Settings.KarmaKnowledgeSpecialization;
                    }
                }

                if (intKnowledgePointsValue != 0)
                {
                    sbdMessage.AppendLine().Append(LanguageManager.GetString("Label_KnowledgeSkills", strLanguage))
                              .Append(strColonCharacter).Append(strSpace)
                              .Append(intKnowledgePointsValue.ToString(GlobalSettings.CultureInfo)).Append(strSpace)
                              .Append(strKarmaString);
                    intReturn += intKnowledgePointsValue;
                    intExtraKarmaToRemoveForPointBuyComparison += intKnowledgePointsValue;
                }

                sbdMessage.AppendLine().AppendLine().Append(LanguageManager.GetString("String_Total", strLanguage))
                          .Append(strColonCharacter).Append(strSpace)
                          .Append(intReturn.ToString(GlobalSettings.CultureInfo))
                          .Append(strSpace).AppendLine(strKarmaString).AppendLine()
                          .Append(LanguageManager.GetString("String_TotalComparisonWithPointBuy", strLanguage))
                          .Append(strColonCharacter).Append(strSpace)
                          .Append((intReturn - intExtraKarmaToRemoveForPointBuyComparison).ToString(
                                      GlobalSettings.CultureInfo)).Append(strSpace).Append(strKarmaString);

                return sbdMessage.ToString();
            }
        }

        /// <summary>
        /// Creates a list of keywords for each category of an XML node. Used to preselect whether items of that category are discounted by the Black Market Pipeline quality.
        /// </summary>
        public IEnumerable<string> GenerateBlackMarketMappings(XPathNavigator xmlCategoryList)
        {
            // Character has no Black Market discount qualities. Fail out early.
            if (BlackMarketDiscount)
            {
                if (xmlCategoryList == null)
                {
                    yield break;
                }
                // if the passed list is still the root, assume we're looking for default categories. Special cases like vehicle modcategories are expected to be passed through by the parameter.
                if (xmlCategoryList.Name == "chummer")
                {
                    xmlCategoryList = xmlCategoryList.SelectSingleNodeAndCacheExpression("categories");
                    if (xmlCategoryList == null)
                        yield break;
                }
                // Get all the improved names of the Black Market Pipeline improvements. In most cases this should only be 1 item, but supports custom content.
                using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                out HashSet<string> setNames))
                {
                    foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                 this, Improvement.ImprovementType.BlackMarketDiscount))
                    {
                        setNames.Add(objImprovement.ImprovedName);
                    }

                    // For each category node, split the comma-separated blackmarket attribute (if present on the node), then add each category where any of those items matches a Black Market Pipeline improvement.
                    foreach (XPathNavigator xmlCategoryNode in xmlCategoryList.SelectAndCacheExpression("category"))
                    {
                        string strBlackMarketAttribute
                            = xmlCategoryNode.SelectSingleNodeAndCacheExpression("@blackmarket")?.Value;
                        if (!string.IsNullOrEmpty(strBlackMarketAttribute) &&
                            strBlackMarketAttribute.SplitNoAlloc(',', StringSplitOptions.RemoveEmptyEntries)
                                                   .Any(x => setNames.Contains(x)))
                        {
                            yield return xmlCategoryNode.Value;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Book code (using the translated version if applicable) using the character's data files.
        /// </summary>
        /// <param name="strAltCode">Book code to search for.</param>
        /// <param name="strLanguage">Language to load.</param>
        public string LanguageBookCodeFromAltCode(string strAltCode, string strLanguage = "")
        {
            return CommonFunctions.LanguageBookCodeFromAltCode(strAltCode, strLanguage, this);
        }

        /// <summary>
        /// Book code (using the translated version if applicable) using the character's data files.
        /// </summary>
        /// <param name="strCode">Book code to search for.</param>
        /// <param name="strLanguage">Language to load.</param>
        public string LanguageBookShort(string strCode, string strLanguage = "")
        {
            return CommonFunctions.LanguageBookShort(strCode, strLanguage, this);
        }

        /// <summary>
        /// Book name (using the translated version if applicable) using the character's data files.
        /// </summary>
        /// <param name="strCode">Book code to search for.</param>
        /// <param name="strLanguage">Language to load.</param>
        public string LanguageBookLong(string strCode, string strLanguage = "")
        {
            return CommonFunctions.LanguageBookLong(strCode, strLanguage, this);
        }

        /// <summary>
        /// Attempt to translate any Extra text for an item using the character's data files.
        /// </summary>
        /// <param name="strExtra">Extra string to translate.</param>
        /// <param name="strIntoLanguage">Language into which the string should be translated</param>
        /// <param name="strPreferFile">Name of a file to prefer for extras before all others.</param>
        public string TranslateExtra(string strExtra, string strIntoLanguage = "", string strPreferFile = "")
        {
            return LanguageManager.TranslateExtra(strExtra, strIntoLanguage, this, strPreferFile);
        }

        /// <summary>
        /// Attempt to translate any Extra text for an item using the character's data files.
        /// </summary>
        /// <param name="strExtra">Extra string to translate.</param>
        /// <param name="strIntoLanguage">Language into which the string should be translated</param>
        /// <param name="strPreferFile">Name of a file to prefer for extras before all others.</param>
        public Task<string> TranslateExtraAsync(string strExtra, string strIntoLanguage = "", string strPreferFile = "")
        {
            return LanguageManager.TranslateExtraAsync(strExtra, strIntoLanguage, this, strPreferFile);
        }

        /// <summary>
        /// Attempt to translate any Extra text for an item from a foreign language to the default one using the character's data files.
        /// </summary>
        /// <param name="strExtra">Extra string to translate.</param>
        /// <param name="strFromLanguage">Language from which the string should be translated</param>
        /// <param name="strPreferFile">Name of a file to prefer for extras before all others.</param>
        public string ReverseTranslateExtra(string strExtra, string strFromLanguage = "", string strPreferFile = "")
        {
            return LanguageManager.ReverseTranslateExtra(strExtra, strFromLanguage, this, strPreferFile);
        }

        /// <summary>
        /// Attempt to translate any Extra text for an item from a foreign language to the default one using the character's data files.
        /// </summary>
        /// <param name="strExtra">Extra string to translate.</param>
        /// <param name="strFromLanguage">Language from which the string should be translated</param>
        /// <param name="strPreferFile">Name of a file to prefer for extras before all others.</param>
        public Task<string> ReverseTranslateExtraAsync(string strExtra, string strFromLanguage = "", string strPreferFile = "")
        {
            return LanguageManager.ReverseTranslateExtraAsync(strExtra, strFromLanguage, this, strPreferFile);
        }
        #endregion

        #region UI Methods

        #region Move TreeNodes

        /// <summary>
        /// Move a Gear TreeNode after Drag and Drop, changing its parent.
        /// </summary>
        /// <param name="objGearNode">Node of gear to move.</param>
        /// <param name="objDestination">Destination Node.</param>
        public void MoveGearParent(TreeNode objDestination, TreeNode objGearNode)
        {
            if (objGearNode == null || objDestination == null)
                return;
            // The item cannot be dropped onto itself or onto one of its children.
            for(TreeNode objCheckNode = objDestination;
                objCheckNode != null && objCheckNode.Level >= objDestination.Level;
                objCheckNode = objCheckNode.Parent)
                if(objCheckNode == objGearNode)
                    return;
            if(!(objGearNode.Tag is Gear objGear))
            {
                return;
            }

            // Gear cannot be moved to one if its children.
            bool blnAllowMove = true;
            if(objDestination.Level > 0)
            {
                TreeNode objFindNode = objDestination;
                do
                {
                    objFindNode = objFindNode.Parent;
                    if(objFindNode.Tag == objGear)
                    {
                        blnAllowMove = false;
                        break;
                    }
                } while(objFindNode.Level > 0);
            }

            if(!blnAllowMove)
                return;

            // Remove the Gear from the character.
            if(objGear.Parent is IHasChildren<Gear> parent)
                parent.Children.Remove(objGear);
            else
                Gear.Remove(objGear);

            switch (objDestination.Tag)
            {
                case Location objLocation:
                    // The Gear was moved to a location, so add it to the character instead.
                    objGear.Location = objLocation;
                    objLocation.Children.Add(objGear);
                    Gear.Add(objGear);
                    break;
                case Gear objParent:
                    // Add the Gear as a child of the destination Node and clear its location.
                    objGear.Location = null;
                    objParent.Children.Add(objGear);
                    break;
            }
        }

        /// <summary>
        /// Move a Gear TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodeToMove">Node of gear to move.</param>
        public void MoveGearNode(int intNewIndex, TreeNode objDestination, TreeNode nodeToMove)
        {
            if (objDestination == null || nodeToMove == null)
                return;
            if (nodeToMove.Tag is Gear objGear)
            {
                TreeNode objNewParent = objDestination;
                while (objNewParent.Level > 0 && !(objNewParent.Tag is Location))
                    objNewParent = objNewParent.Parent;

                switch (objNewParent.Tag)
                {
                    case Location objLocation:
                        nodeToMove.Remove();
                        objGear.Location = objLocation;
                        objNewParent.Nodes.Insert(0, nodeToMove);
                        break;
                    case string _:
                        objGear.Location = null;
                        intNewIndex = Math.Min(intNewIndex, Gear.Count - 1);
                        Gear.Move(Gear.IndexOf(objGear), intNewIndex);
                        break;
                }
            }
        }

        /// <summary>
        /// Move a Gear Location TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodOldNode">Node of gear location to move.</param>
        public void MoveGearRoot(int intNewIndex, TreeNode objDestination, TreeNode nodOldNode)
        {
            if (nodOldNode == null)
                return;
            if(objDestination != null)
            {
                TreeNode objNewParent = objDestination;
                while(objNewParent.Level > 0)
                    objNewParent = objNewParent.Parent;
                intNewIndex = objNewParent.Index;
            }

            if(intNewIndex == 0)
                return;

            if(!(nodOldNode.Tag is Location objLocation)) return;
            GearLocations.Move(GearLocations.IndexOf(objLocation), intNewIndex);
        }

        /// <summary>
        /// Move a Lifestyle TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodLifestyleNode">Node of lifestyle to move.</param>
        public void MoveLifestyleNode(int intNewIndex, TreeNode objDestination, TreeNode nodLifestyleNode)
        {
            if (nodLifestyleNode == null)
                return;
            if (objDestination != null)
            {
                TreeNode objNewParent = objDestination;
                while(objNewParent.Level > 0)
                    objNewParent = objNewParent.Parent;
                intNewIndex = objNewParent.Index;
            }

            if (intNewIndex == 0)
                return;

            if (nodLifestyleNode.Tag is Lifestyle objLifestyle)
                Lifestyles.Move(Lifestyles.IndexOf(objLifestyle), intNewIndex);
        }

        /// <summary>
        /// Move an Armor TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodeToMove">Node of armor to move.</param>
        public void MoveArmorNode(int intNewIndex, TreeNode objDestination, TreeNode nodeToMove)
        {
            if (objDestination == null)
                return;
            if (nodeToMove?.Tag is Armor objArmor)
            {
                TreeNode objNewParent = objDestination;
                while (objNewParent.Level > 0 && !(objNewParent.Tag is Location))
                    objNewParent = objNewParent.Parent;

                switch (objNewParent.Tag)
                {
                    case Location objLocation:
                        nodeToMove.Remove();
                        objArmor.Location = objLocation;
                        objNewParent.Nodes.Insert(0, nodeToMove);
                        break;
                    case string _:
                        objArmor.Location = null;
                        intNewIndex = Math.Min(intNewIndex, Armor.Count - 1);
                        Armor.Move(Armor.IndexOf(objArmor), intNewIndex);
                        break;
                }
            }
        }

        /// <summary>
        /// Move an Armor Location TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodOldNode">Node of armor location to move.</param>
        public void MoveArmorRoot(int intNewIndex, TreeNode objDestination, TreeNode nodOldNode)
        {
            if (nodOldNode == null)
                return;
            if (objDestination != null)
            {
                TreeNode objNewParent = objDestination;
                while (objNewParent.Level > 0)
                    objNewParent = objNewParent.Parent;
                intNewIndex = objNewParent.Index;
            }

            if (intNewIndex == 0)
                return;

            if (!(nodOldNode.Tag is Location objLocation))
                return;
            ArmorLocations.Move(ArmorLocations.IndexOf(objLocation), intNewIndex);
        }

        /// <summary>
        /// Move a Weapon TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodeToMove">Node of weapon to move.</param>
        public void MoveWeaponNode(int intNewIndex, TreeNode objDestination, TreeNode nodeToMove)
        {
            if (objDestination == null)
                return;
            if (nodeToMove?.Tag is Weapon objWeapon)
            {
                TreeNode objNewParent = objDestination;
                while (objNewParent.Level > 0 && !(objNewParent.Tag is Location))
                    objNewParent = objNewParent.Parent;

                switch (objNewParent.Tag)
                {
                    case Location objLocation:
                        nodeToMove.Remove();
                        objWeapon.Location = objLocation;
                        objNewParent.Nodes.Insert(0, nodeToMove);
                        break;
                    case string _:
                        objWeapon.Location = null;
                        intNewIndex = Math.Min(intNewIndex, Weapons.Count - 1);
                        Weapons.Move(Weapons.IndexOf(objWeapon), intNewIndex);
                        break;
                }
            }
        }

        /// <summary>
        /// Move a Weapon Location TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodOldNode">Node of weapon location to move.</param>
        public void MoveWeaponRoot(int intNewIndex, TreeNode objDestination, TreeNode nodOldNode)
        {
            if (nodOldNode == null)
                return;
            if (objDestination != null)
            {
                TreeNode objNewParent = objDestination;
                while (objNewParent.Level > 0)
                    objNewParent = objNewParent.Parent;
                intNewIndex = objNewParent.Index;
            }

            if (intNewIndex == 0)
                return;

            if (!(nodOldNode.Tag is Location objLocation))
                return;
            WeaponLocations.Move(WeaponLocations.IndexOf(objLocation), intNewIndex);
        }

        /// <summary>
        /// Move a Vehicle TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodeToMove">Node of vehicle to move.</param>
        public void MoveVehicleNode(int intNewIndex, TreeNode objDestination, TreeNode nodeToMove)
        {
            if (objDestination == null)
                return;
            if(nodeToMove?.Tag is Vehicle objVehicle)
            {
                TreeNode objNewParent = objDestination;
                while (objNewParent.Level > 0 && !(objNewParent.Tag is Location))
                    objNewParent = objNewParent.Parent;

                switch (objNewParent.Tag)
                {
                    case Location objLocation:
                        nodeToMove.Remove();
                        objVehicle.Location = objLocation;
                        objNewParent.Nodes.Insert(0, nodeToMove);
                        break;
                    case string _:
                        objVehicle.Location = null;
                        intNewIndex = Math.Min(intNewIndex, Weapons.Count - 1);
                        Vehicles.Move(Vehicles.IndexOf(objVehicle), intNewIndex);
                        break;
                }
            }
        }

        /// <summary>
        /// Move a Vehicle Gear TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="nodDestination">Destination Node.</param>
        /// <param name="nodGearNode">Node of gear to move.</param>
        public void MoveVehicleGearParent(TreeNode nodDestination, TreeNode nodGearNode)
        {
            if (nodDestination == null || nodGearNode == null)
                return;
            // The item cannot be dropped onto itself or onto one of its children.
            for (TreeNode objCheckNode = nodDestination;
                objCheckNode != null && objCheckNode.Level >= nodDestination.Level;
                objCheckNode = objCheckNode.Parent)
                if (objCheckNode == nodGearNode)
                    return;
            if (!(nodGearNode.Tag is IHasInternalId nodeId)) return;
            // Locate the currently selected piece of Gear.
            //TODO: Better interface for determining what the parent of a bit of gear is.
            Gear objGear = Vehicles.FindVehicleGear(nodeId.InternalId, out Vehicle objOldVehicle,
                out WeaponAccessory objOldWeaponAccessory, out Cyberware objOldCyberware);

            if (objGear == null)
                return;

            if (nodDestination.Tag is Gear objDestinationGear)
            {
                // Remove the Gear from the Vehicle.
                if(objGear.Parent is IHasChildren<Gear> parent)
                    parent.Children.Remove(objGear);
                else if(objOldCyberware != null)
                    objOldCyberware.GearChildren.Remove(objGear);
                else if(objOldWeaponAccessory != null)
                    objOldWeaponAccessory.GearChildren.Remove(objGear);
                else
                    objOldVehicle.GearChildren.Remove(objGear);

                // Add the Gear to its new parent.
                objGear.Location = null;
                objDestinationGear.Children.Add(objGear);
            }
            else
            {
                // Determine if this is a Location.
                TreeNode nodVehicleNode = nodDestination;
                Location objLocation = null;
                while (nodVehicleNode.Level > 1)
                {
                    if (objLocation is null && nodVehicleNode.Tag is Location loc)
                    {
                        objLocation = loc;
                    }
                    nodVehicleNode = nodVehicleNode.Parent;
                }

                // Determine if this is a Location in the destination Vehicle.
                if (nodDestination.Tag is Vehicle objNewVehicle)
                {
                    // Remove the Gear from the Vehicle.
                    if(objGear.Parent is IHasChildren<Gear> parent)
                        parent.Children.Remove(objGear);
                    else if(objOldCyberware != null)
                        objOldCyberware.GearChildren.Remove(objGear);
                    else if(objOldWeaponAccessory != null)
                        objOldWeaponAccessory.GearChildren.Remove(objGear);
                    else
                        objOldVehicle.GearChildren.Remove(objGear);

                    // Add the Gear to the Vehicle and set its Location.
                    objGear.Parent = objNewVehicle;
                    objNewVehicle.GearChildren.Add(objGear);
                    objLocation?.Children.Add(objGear);
                }
            }
        }

        /// <summary>
        /// Move an Improvement TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodOldNode">Node of improvement to move.</param>
        public void MoveImprovementNode(TreeNode objDestination, TreeNode nodOldNode)
        {
            if (objDestination == null)
                return;
            if (nodOldNode?.Tag is Improvement objImprovement)
            {
                TreeNode objNewParent = objDestination;
                while (objNewParent.Level > 0)
                    objNewParent = objNewParent.Parent;

                objImprovement.CustomGroup = objNewParent.Tag.ToString() == "Node_SelectedImprovements"
                    ? string.Empty
                    : objNewParent.Text;
                Improvements[Improvements.IndexOf(objImprovement)] = objImprovement;
            }
        }

        /// <summary>
        /// Move an Improvement Group TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodOldNode">Node of improvement group to move.</param>
        public void MoveImprovementRoot(int intNewIndex, TreeNode objDestination, TreeNode nodOldNode)
        {
            if (nodOldNode == null)
                return;
            if (objDestination != null)
            {
                TreeNode objNewParent = objDestination;
                while(objNewParent.Level > 0)
                    objNewParent = objNewParent.Parent;
                intNewIndex = objNewParent.Index;
            }

            if(intNewIndex == 0)
                return;

            string strLocation = nodOldNode.Tag.ToString();
            ImprovementGroups.Move(ImprovementGroups.IndexOf(strLocation), intNewIndex);
        }

        #endregion

        #region Tab clearing

        /// <summary>
        /// Clear all Spell tab elements from the character.
        /// </summary>
        public void ClearMagic(bool blnKeepAdeptEligible)
        {
            if (ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.FreeSpells).Count > 0
                || ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.FreeSpellsATT).Count > 0
                || ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.FreeSpellsSkill).Count > 0)
            {
                // Run through all of the Spells and remove their Improvements.
                for(int i = Spells.Count - 1; i >= 0; --i)
                {
                    if(i < Spells.Count)
                    {
                        Spell objToRemove = Spells[i];
                        if(objToRemove.Grade == 0)
                        {
                            if(blnKeepAdeptEligible && objToRemove.Category == "Rituals" &&
                                !objToRemove.Descriptors.Contains("Spell"))
                                continue;
                            // Remove the Improvements created by the Spell.
                            ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Spell,
                                objToRemove.InternalId);
                            Spells.RemoveAt(i);
                        }
                    }
                }
            }

            for(int i = Spirits.Count - 1; i >= 0; --i)
            {
                if(i < Spirits.Count)
                {
                    Spirit objToRemove = Spirits[i];
                    if(objToRemove.EntityType == SpiritType.Spirit)
                    {
                        Spirits.RemoveAt(i);
                    }
                }
            }
        }

        /// <summary>
        /// Clear all Adept tab elements from the character.
        /// </summary>
        public void ClearAdeptPowers()
        {
            // Run through all powers and remove the ones not added by improvements or foci
            for(int i = Powers.Count - 1; i >= 0; --i)
            {
                if(i < Powers.Count)
                {
                    Power objToRemove = Powers[i];
                    if (objToRemove.FreeLevels == 0 && objToRemove.FreePoints == 0)
                    {
                        // Remove the Improvements created by the Power.
                        ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Power,
                            objToRemove.InternalId);
                        Powers.RemoveAt(i);
                    }
                    else
                        objToRemove.Rating = 0;
                }
            }
        }

        /// <summary>
        /// Clear all Technomancer tab elements from the character.
        /// </summary>
        public void ClearResonance()
        {
            // Run through all of the Complex Forms and remove their Improvements.
            for(int i = ComplexForms.Count - 1; i >= 0; --i)
            {
                if(i < ComplexForms.Count)
                {
                    ComplexForm objToRemove = ComplexForms[i];
                    if(objToRemove.Grade == 0)
                    {
                        // Remove the Improvements created by the Spell.
                        ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.ComplexForm,
                            objToRemove.InternalId);
                        ComplexForms.RemoveAt(i);
                    }
                }
            }

            for(int i = Spirits.Count - 1; i >= 0; --i)
            {
                if(i < Spirits.Count)
                {
                    Spirit objToRemove = Spirits[i];
                    if(objToRemove.EntityType == SpiritType.Sprite)
                    {
                        Spirits.RemoveAt(i);
                    }
                }
            }
        }

        /// <summary>
        /// Clear all Advanced Programs tab elements from the character.
        /// </summary>
        public void ClearAdvancedPrograms()
        {
            // Run through all advanced programs and remove the ones not added by improvements
            for(int i = AIPrograms.Count - 1; i >= 0; --i)
            {
                if(i < AIPrograms.Count)
                {
                    AIProgram objToRemove = AIPrograms[i];
                    if(objToRemove.CanDelete)
                    {
                        // Remove the Improvements created by the Program.
                        ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.AIProgram,
                            objToRemove.InternalId);
                        AIPrograms.RemoveAt(i);
                    }
                }
            }
        }

        /// <summary>
        /// Clear all cyberware and bioware implanted on the character.
        /// </summary>
        public void ClearCyberwareTab()
        {
            string strDisabledSource = string.Empty;
            if (Created)
            {
                Improvement objDisablingImprovement = ImprovementManager
                                                      .GetCachedImprovementListForValueOf(
                                                          this,
                                                          Improvement.ImprovementType.SpecialTab,
                                                          "Cyberware")
                                                      .FirstOrDefault(x => x.UniqueName == "disabletab");
                if (objDisablingImprovement != null)
                {
                    strDisabledSource = LanguageManager.GetString("String_Space") +
                                        '(' + GetObjectName(objDisablingImprovement, GlobalSettings.Language) + ')' +
                                        LanguageManager.GetString("String_Space");
                }
            }

            foreach (Cyberware objCyberware in Cyberware.ToList())
            {
                if (objCyberware.SourceID == Backend.Equipment.Cyberware.EssenceHoleGUID)
                    continue;
                if (objCyberware.SourceID == Backend.Equipment.Cyberware.EssenceAntiHoleGUID)
                    continue;
                if (!objCyberware.IsModularCurrentlyEquipped)
                    continue;
                if (!string.IsNullOrEmpty(objCyberware.PlugsIntoModularMount))
                {
                    if (objCyberware.CanRemoveThroughImprovements)
                    {
                        objCyberware.Parent?.Children.Remove(objCyberware);
                        Cyberware.Add(objCyberware);
                        objCyberware.ChangeModularEquip(false);
                    }
                }
                else if (objCyberware.CanRemoveThroughImprovements)
                {
                    objCyberware.DeleteCyberware();
                    ExpenseLogEntry objExpense = new ExpenseLogEntry(this);
                    string strEntry = LanguageManager.GetString(
                        objCyberware.SourceType == Improvement.ImprovementSource.Cyberware
                            ? "String_ExpenseSoldCyberware"
                            : "String_ExpenseSoldBioware");
                    objExpense.Create(0,
                                      strEntry + strDisabledSource
                                               + objCyberware.DisplayNameShort(GlobalSettings.Language),
                                      ExpenseType.Nuyen, DateTime.Now);
                    ExpenseEntries.AddWithSort(objExpense);
                }
            }
        }

        /// <summary>
        /// Clear all Critter tab elements from the character.
        /// </summary>
        public void ClearCritterPowers()
        {
            for(int i = CritterPowers.Count - 1; i >= 0; --i)
            {
                if(i < CritterPowers.Count)
                {
                    CritterPower objToRemove = CritterPowers[i];
                    if(objToRemove.Grade >= 0)
                    {
                        // Remove the Improvements created by the Metamagic.
                        ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.CritterPower,
                            objToRemove.InternalId);
                        CritterPowers.RemoveAt(i);
                    }
                }
            }
        }

        /// <summary>
        /// Clear all Initiation tab elements from the character that were not added by improvements.
        /// </summary>
        public void ClearInitiations()
        {
            // Do not update grade numbers until after we're done processing everything
            _blnClearingInitiations = true;
            // We need to remove grades that can potentially add stuff that adds grades, so we cannot use foreach
            for (int i = InitiationGrades.Count - 1; i >= 0; --i)
            {
                InitiationGrades[i].Remove(false, false);
            }
            // Now update our grade numbers
            _blnClearingInitiations = false;
            InitiateGrade = 0;
            SubmersionGrade = 0;
        }

        #endregion

        #endregion

        #region Basic Properties

        private CharacterSettings _objSettings;

        /// <summary>
        /// Character Settings object.
        /// </summary>
        public CharacterSettings Settings
        {
            get => _objSettings;
            private set // Private to make sure this is always in sync with GameplayOption
            {
                if (ReferenceEquals(_objSettings, value))
                    return;
                bool blnActuallyDifferentSettings = !_objSettings.HasIdenticalSettings(value);
                if (_objSettings != null)
                    _objSettings.PropertyChanged -= OptionsOnPropertyChanged;
                _objSettings = value;
                if (_objSettings != null)
                    _objSettings.PropertyChanged += OptionsOnPropertyChanged;
                if (blnActuallyDifferentSettings && !IsLoading)
                    OnPropertyChanged();
            }
        }

        /// <summary>
        /// Name of the file the Character is saved to.
        /// </summary>
        public string FileName
        {
            get => _strFileName;
            set
            {
                if(_strFileName != value)
                {
                    _strFileName = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Last write time of the file to which this character is saved.
        /// </summary>
        public DateTime FileLastWriteTime => _dateFileLastWriteTime > DateTime.MinValue ? _dateFileLastWriteTime : DateTime.UtcNow;

        /// <summary>
        /// Whether or not the character has been saved as Created and can no longer be modified using the Build system.
        /// </summary>
        [HubTag]
        public bool Created
        {
            get => _blnCreated;
            set
            {
                if (_blnCreated == value)
                    return;
                _blnCreated = value;
                OnPropertyChanged();
            }
        }

        /// <summary>
        /// Character's name.
        /// </summary>
        [HubTag]
        public string Name
        {
            get => _strName;
            set
            {
                if(_strName != value)
                {
                    _strName = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's portraits encoded using Base64.
        /// </summary>
        public List<Image> Mugshots => _lstMugshots;

        /// <summary>
        /// Character's main portrait encoded using Base64.
        /// </summary>
        public Image MainMugshot
        {
            get
            {
                if(MainMugshotIndex >= Mugshots.Count || MainMugshotIndex < 0)
                    return null;

                return Mugshots[MainMugshotIndex];
            }
            set
            {
                if(value == null)
                {
                    MainMugshotIndex = -1;
                    return;
                }

                int intNewMainMugshotIndex = Mugshots.IndexOf(value);
                if(intNewMainMugshotIndex != -1)
                {
                    MainMugshotIndex = intNewMainMugshotIndex;
                }
                else
                {
                    Mugshots.Add(value);
                    MainMugshotIndex = Mugshots.Count - 1;
                }
            }
        }

        /// <summary>
        /// Index of Character's main portrait. -1 if set to none.
        /// </summary>
        public int MainMugshotIndex
        {
            get => _intMainMugshotIndex;
            set
            {
                if(value >= _lstMugshots.Count || value < -1)
                    value = -1;

                if(_intMainMugshotIndex != value)
                {
                    _intMainMugshotIndex = value;
                    OnPropertyChanged();
                }
            }
        }

        public void SaveMugshots(XmlTextWriter objWriter)
        {
            if (objWriter == null)
                return;
            objWriter.WriteElementString("mainmugshotindex",
                MainMugshotIndex.ToString(GlobalSettings.InvariantCultureInfo));
            // <mugshot>
            objWriter.WriteStartElement("mugshots");
            foreach (Image imgMugshot in Mugshots)
            {
                objWriter.WriteElementString("mugshot", GlobalSettings.ImageToBase64StringForStorage(imgMugshot));
            }
            // </mugshot>
            objWriter.WriteEndElement();
        }

        public void LoadMugshots(XPathNavigator xmlSavedNode)
        {
            // Mugshots
            xmlSavedNode.TryGetInt32FieldQuickly("mainmugshotindex", ref _intMainMugshotIndex);
            XPathNodeIterator xmlMugshotsList = xmlSavedNode.SelectAndCacheExpression("mugshots/mugshot");
            List<string> lstMugshotsBase64 = new List<string>(xmlMugshotsList.Count);
            foreach(XPathNavigator objXmlMugshot in xmlMugshotsList)
            {
                string strMugshot = objXmlMugshot.Value;
                if(!string.IsNullOrWhiteSpace(strMugshot))
                {
                    lstMugshotsBase64.Add(strMugshot);
                }
            }

            if(lstMugshotsBase64.Count > 1)
            {
                Image[] objMugshotImages = new Image[lstMugshotsBase64.Count];
                Parallel.For(0, lstMugshotsBase64.Count, i => objMugshotImages[i] = lstMugshotsBase64[i].ToImage(PixelFormat.Format32bppPArgb));
                _lstMugshots.AddRange(objMugshotImages);
            }
            else if(lstMugshotsBase64.Count == 1)
            {
                _lstMugshots.Add(lstMugshotsBase64[0].ToImage(PixelFormat.Format32bppPArgb));
            }

            // Legacy Shimmer
            if(Mugshots.Count == 0)
            {
                XPathNavigator objOldMugshotNode = xmlSavedNode.SelectSingleNode("mugshot");
                string strMugshot = objOldMugshotNode?.Value;
                if(!string.IsNullOrWhiteSpace(strMugshot))
                {
                    _lstMugshots.Add(strMugshot.ToImage(PixelFormat.Format32bppPArgb));
                    _intMainMugshotIndex = 0;
                }
            }
        }

        public void PrintMugshots(XmlTextWriter objWriter)
        {
            if (objWriter == null)
                return;
            if(Mugshots.Count > 0)
            {
                // Since IE is retarded and can't handle base64 images before IE9, the image needs to be dumped to a temporary directory and its information rewritten.
                // If you give it an extension of jpg, gif, or png, it expects the file to be in that format and won't render the image unless it was originally that type.
                // But if you give it the extension img, it will render whatever you give it (which doesn't make any damn sense, but that's IE for you).
                string strMugshotsDirectoryPath = Path.Combine(Utils.GetStartupPath, "mugshots");
                if(!Directory.Exists(strMugshotsDirectoryPath))
                {
                    try
                    {
                        Directory.CreateDirectory(strMugshotsDirectoryPath);
                    }
                    catch(UnauthorizedAccessException)
                    {
                        Program.MainForm.ShowMessageBox(LanguageManager.GetString("Message_Insufficient_Permissions_Warning"));
                    }
                }

                Guid guiImage = Guid.NewGuid();
                Image imgMainMugshot = MainMugshot;
                if(imgMainMugshot != null)
                {
                    string imgMugshotPath = Path.Combine(strMugshotsDirectoryPath,
                        guiImage.ToString("N", GlobalSettings.InvariantCultureInfo) + ".jpg");
                    imgMainMugshot.Save(imgMugshotPath);
                    // <mainmugshotpath />
                    objWriter.WriteElementString("mainmugshotpath",
                        "file://" + imgMugshotPath.Replace(Path.DirectorySeparatorChar, '/'));
                    // <mainmugshotbase64 />
                    objWriter.WriteElementString("mainmugshotbase64", imgMainMugshot.ToBase64StringAsJpeg());
                }

                // <othermugshots>
                objWriter.WriteElementString("hasothermugshots",
                    (imgMainMugshot == null || Mugshots.Count > 1).ToString(GlobalSettings.InvariantCultureInfo));
                objWriter.WriteStartElement("othermugshots");
                for(int i = 0; i < Mugshots.Count; ++i)
                {
                    if(i == MainMugshotIndex)
                        continue;
                    Image imgMugshot = Mugshots[i];
                    objWriter.WriteStartElement("mugshot");

                    objWriter.WriteElementString("stringbase64", imgMugshot.ToBase64StringAsJpeg());

                    string imgMugshotPath = Path.Combine(strMugshotsDirectoryPath,
                        guiImage.ToString("N", GlobalSettings.InvariantCultureInfo) +
                        i.ToString(GlobalSettings.InvariantCultureInfo) + ".jpg");
                    imgMugshot.Save(imgMugshotPath);
                    objWriter.WriteElementString("temppath",
                        "file://" + imgMugshotPath.Replace(Path.DirectorySeparatorChar, '/'));

                    objWriter.WriteEndElement();
                }

                // </mugshots>
                objWriter.WriteEndElement();
            }
        }

        /// <summary>
        /// Character's Gameplay Option.
        /// </summary>
        [HubTag]
        public string SettingsKey
        {
            get => _strSettingsKey;
            set
            {
                if (_strSettingsKey == value)
                    return;
                if (!SettingsManager.LoadedCharacterSettings.TryGetValue(value, out CharacterSettings objNewSettings))
                    throw new InvalidOperationException(nameof(SettingsKey));
                _strSettingsKey = value;
                OnPropertyChanged();
                Settings = objNewSettings;
            }
        }

        /// <summary>
        /// Character's Metatype Priority.
        /// </summary>
        [HubTag]
        public string MetatypePriority
        {
            get => _strPriorityMetatype;
            set
            {
                if(_strPriorityMetatype != value)
                {
                    _strPriorityMetatype = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Attributes Priority.
        /// </summary>
        [HubTag]
        public string AttributesPriority
        {
            get => _strPriorityAttributes;
            set
            {
                if(_strPriorityAttributes != value)
                {
                    _strPriorityAttributes = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Special Priority.
        /// </summary>
        [HubTag]
        public string SpecialPriority
        {
            get => _strPrioritySpecial;
            set
            {
                if(_strPrioritySpecial != value)
                {
                    _strPrioritySpecial = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Skills Priority.
        /// </summary>
        [HubTag]
        public string SkillsPriority
        {
            get => _strPrioritySkills;
            set
            {
                if(_strPrioritySkills != value)
                {
                    _strPrioritySkills = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Resources Priority.
        /// </summary>
        [HubTag]
        public string ResourcesPriority
        {
            get => _strPriorityResources;
            set
            {
                if(_strPriorityResources != value)
                {
                    _strPriorityResources = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Resources Priority.
        /// </summary>
        [HubTag]
        public string TalentPriority
        {
            get => _strPriorityTalent;
            set
            {
                if(_strPriorityTalent != value)
                {
                    _strPriorityTalent = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's list of priority bonus skills.
        /// </summary>
        public List<string> PriorityBonusSkillList => _lstPrioritySkills;

        /// <summary>
        /// Character's gender.
        /// </summary>
        public string Gender
        {
            get => _strGender;
            set
            {
                if(_strGender != value)
                {
                    _strGender = value;
                    OnPropertyChanged();
                }
            }
        }

        private string _strCachedCharacterGrammaticGender = string.Empty;

        public string CharacterGrammaticGender
        {
            get
            {
                if(!string.IsNullOrEmpty(_strCachedCharacterGrammaticGender))
                    return _strCachedCharacterGrammaticGender;
                switch(ReverseTranslateExtra(Gender).ToUpperInvariant())
                {
                    case "M":
                    case "MALE":
                    case "MAN":
                    case "BOY":
                    case "LORD":
                    case "GENTLEMAN":
                    case "GUY":
                        return _strCachedCharacterGrammaticGender = "male";
                    case "F":
                    case "W":
                    case "FEMALE":
                    case "WOMAN":
                    case "GIRL":
                    case "LADY":
                    case "GAL":
                        return _strCachedCharacterGrammaticGender = "female";
                    default:
                        return _strCachedCharacterGrammaticGender = "neutral";
                }
            }
        }

        /// <summary>
        /// Character's age.
        /// </summary>
        public string Age
        {
            get => _strAge;
            set
            {
                if(_strAge != value)
                {
                    _strAge = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's eyes.
        /// </summary>
        public string Eyes
        {
            get => _strEyes;
            set
            {
                if(_strEyes != value)
                {
                    _strEyes = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's height.
        /// </summary>
        public string Height
        {
            get => _strHeight;
            set
            {
                if(_strHeight != value)
                {
                    _strHeight = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's weight.
        /// </summary>
        public string Weight
        {
            get => _strWeight;
            set
            {
                if(_strWeight != value)
                {
                    _strWeight = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's skin.
        /// </summary>
        public string Skin
        {
            get => _strSkin;
            set
            {
                if(_strSkin != value)
                {
                    _strSkin = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's hair.
        /// </summary>
        public string Hair
        {
            get => _strHair;
            set
            {
                if(_strHair != value)
                {
                    _strHair = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's description.
        /// </summary>
        public string Description
        {
            get => _strDescription;
            set
            {
                if(_strDescription != value)
                {
                    string strOldText = _strDescription.RtfToPlainText();
                    string strOldHtml = _strDescription.RtfToHtml();
                    string strNewText = value.RtfToPlainText();
                    string strNewHtml = value.RtfToHtml();
                    _strDescription = string.IsNullOrWhiteSpace(strNewText) ? string.Empty : value;
                    // There's something wonky with Rtf comparison, so do an HTML comparison to be sure that something was definitely changed
                    if ((!string.IsNullOrWhiteSpace(strOldText) || !string.IsNullOrWhiteSpace(strNewText))
                        && (!string.IsNullOrWhiteSpace(strOldHtml) || !string.IsNullOrWhiteSpace(strNewHtml))
                        && strOldHtml != strNewHtml)
                        OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's background.
        /// </summary>
        public string Background
        {
            get => _strBackground;
            set
            {
                if(_strBackground != value)
                {
                    string strOldText = _strBackground.RtfToPlainText();
                    string strOldHtml = _strBackground.RtfToHtml();
                    string strNewText = value.RtfToPlainText();
                    string strNewHtml = value.RtfToHtml();
                    _strBackground = string.IsNullOrWhiteSpace(strNewText) ? string.Empty : value;
                    // There's something wonky with Rtf comparison, so do an HTML comparison to be sure that something was definitely changed
                    if ((!string.IsNullOrWhiteSpace(strOldText) || !string.IsNullOrWhiteSpace(strNewText))
                        && (!string.IsNullOrWhiteSpace(strOldHtml) || !string.IsNullOrWhiteSpace(strNewHtml))
                        && strOldHtml != strNewHtml)
                        OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's concept.
        /// </summary>
        public string Concept
        {
            get => _strConcept;
            set
            {
                if(_strConcept != value)
                {
                    string strOldText = _strConcept.RtfToPlainText();
                    string strOldHtml = _strConcept.RtfToHtml();
                    string strNewText = value.RtfToPlainText();
                    string strNewHtml = value.RtfToHtml();
                    _strConcept = string.IsNullOrWhiteSpace(strNewText) ? string.Empty : value;
                    // There's something wonky with Rtf comparison, so do an HTML comparison to be sure that something was definitely changed
                    if ((!string.IsNullOrWhiteSpace(strOldText) || !string.IsNullOrWhiteSpace(strNewText))
                        && (!string.IsNullOrWhiteSpace(strOldHtml) || !string.IsNullOrWhiteSpace(strNewHtml))
                        && strOldHtml != strNewHtml)
                        OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character notes.
        /// </summary>
        public string Notes
        {
            get => _strNotes;
            set
            {
                if(_strNotes != value)
                {
                    string strOldText = _strNotes.RtfToPlainText();
                    string strOldHtml = _strNotes.RtfToHtml();
                    string strNewText = value.RtfToPlainText();
                    string strNewHtml = value.RtfToHtml();
                    _strNotes = string.IsNullOrWhiteSpace(strNewText) ? string.Empty : value;
                    // There's something wonky with Rtf comparison, so do an HTML comparison to be sure that something was definitely changed
                    if ((!string.IsNullOrWhiteSpace(strOldText) || !string.IsNullOrWhiteSpace(strNewText))
                        && (!string.IsNullOrWhiteSpace(strOldHtml) || !string.IsNullOrWhiteSpace(strNewHtml))
                        && strOldHtml != strNewHtml)
                        OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// General gameplay notes.
        /// </summary>
        public string GameNotes
        {
            get => _strGameNotes;
            set
            {
                if(_strGameNotes != value)
                {
                    string strOldText = _strGameNotes.RtfToPlainText();
                    string strOldHtml = _strGameNotes.RtfToHtml();
                    string strNewText = value.RtfToPlainText();
                    string strNewHtml = value.RtfToHtml();
                    _strGameNotes = string.IsNullOrWhiteSpace(strNewText) ? string.Empty : value;
                    // There's something wonky with Rtf comparison, so do an HTML comparison to be sure that something was definitely changed
                    if ((!string.IsNullOrWhiteSpace(strOldText) || !string.IsNullOrWhiteSpace(strNewText))
                        && (!string.IsNullOrWhiteSpace(strOldHtml) || !string.IsNullOrWhiteSpace(strNewHtml))
                        && strOldHtml != strNewHtml)
                        OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// What is the Characters preferred hand
        /// </summary>
        public string PrimaryArm
        {
            get => _strPrimaryArm;
            set
            {
                if(_strPrimaryArm != value)
                {
                    _strPrimaryArm = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Player name.
        /// </summary>
        [HubTag]
        public string PlayerName
        {
            get => _strPlayerName;
            set
            {
                if(_strPlayerName != value)
                {
                    _strPlayerName = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's alias.
        /// </summary>
        [HubTag]
        public string Alias
        {
            get => _strAlias;
            set
            {
                if(_strAlias != value)
                {
                    _strAlias = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's name to use when loading them in a new tab.
        /// </summary>
        public string CharacterName
        {
            get
            {
                if(!string.IsNullOrWhiteSpace(Alias))
                    return Alias;
                return !string.IsNullOrWhiteSpace(Name) ? Name : LanguageManager.GetString("String_UnnamedCharacter");
            }
        }

        /// <summary>
        /// Street Cred.
        /// </summary>
        [HubTag]
        public int StreetCred
        {
            get => _intStreetCred;
            set
            {
                if(_intStreetCred != value)
                {
                    _intStreetCred = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Burnt Street Cred.
        /// </summary>
        public int BurntStreetCred
        {
            get => _intBurntStreetCred;
            set
            {
                if(_intBurntStreetCred != value)
                {
                    _intBurntStreetCred = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Notoriety.
        /// </summary>
        [HubTag]
        public int Notoriety
        {
            get => _intNotoriety;
            set
            {
                if(_intNotoriety != value)
                {
                    _intNotoriety = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Public Awareness.
        /// </summary>
        public int PublicAwareness
        {
            get => _intPublicAwareness;
            set
            {
                if(_intPublicAwareness != value)
                {
                    _intPublicAwareness = value;
                    OnPropertyChanged();
                }
            }
        }

        private bool RefreshAstralReputationImprovements()
        {
            if (IsLoading) // Not all improvements are guaranteed to have been loaded in, so just skip the refresh until the end
            {
                if (!PostLoadMethods.Contains(RefreshAstralReputationImprovements))
                    PostLoadMethods.Enqueue(RefreshAstralReputationImprovements);
                return true;
            }
            int intCurrentTotalAstralReputation = TotalAstralReputation;
            List<Improvement> lstCurrentAstralReputationImprovements = Improvements.Where(x => x.ImproveSource == Improvement.ImprovementSource.AstralReputation).ToList();
            if (lstCurrentAstralReputationImprovements.All(x => x.Value == -intCurrentTotalAstralReputation))
                return true;
            ImprovementManager.RemoveImprovements(this, lstCurrentAstralReputationImprovements);
            ImprovementManager.CreateImprovement(this, "Summoning", Improvement.ImprovementSource.AstralReputation,
                nameof(TotalAstralReputation).ToUpperInvariant(), Improvement.ImprovementType.Skill, Guid.NewGuid().ToString("D", GlobalSettings.InvariantCultureInfo),
                -intCurrentTotalAstralReputation);
            ImprovementManager.CreateImprovement(this, "Binding", Improvement.ImprovementSource.AstralReputation,
                nameof(TotalAstralReputation).ToUpperInvariant(), Improvement.ImprovementType.Skill, Guid.NewGuid().ToString("D", GlobalSettings.InvariantCultureInfo),
                -intCurrentTotalAstralReputation);
            ImprovementManager.CreateImprovement(this, "Banishing", Improvement.ImprovementSource.AstralReputation,
                nameof(TotalAstralReputation).ToUpperInvariant(), Improvement.ImprovementType.Skill, Guid.NewGuid().ToString("D", GlobalSettings.InvariantCultureInfo),
                -intCurrentTotalAstralReputation);
            if (intCurrentTotalAstralReputation >= 3)
                ImprovementManager.CreateImprovement(this, "Chain Breaker", Improvement.ImprovementSource.AstralReputation,
                    nameof(TotalAstralReputation).ToUpperInvariant(), Improvement.ImprovementType.DisableQuality, Guid.NewGuid().ToString("D", GlobalSettings.InvariantCultureInfo),
                    -intCurrentTotalAstralReputation);
            ImprovementManager.Commit(this);
            return true;
        }

        /// <summary>
        /// Tooltip to use for Astral Reputation total.
        /// </summary>
        public string AstralReputationTooltip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdReturn))
                {
                    sbdReturn.Append(AstralReputation.ToString(GlobalSettings.CultureInfo));

                    foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.AstralReputation))
                    {
                        sbdReturn.Append(strSpace).Append('+').Append(strSpace).Append(GetObjectName(objImprovement))
                                 .Append(strSpace).Append('(')
                                 .Append(objImprovement.Value.ToString(GlobalSettings.CultureInfo)).Append(')');
                    }

                    return sbdReturn.ToString();
                }
            }
        }

        /// <summary>
        /// Astral Reputation (SG 207).
        /// </summary>
        public int TotalAstralReputation => Math.Max(0, AstralReputation + ImprovementManager.ValueOf(this, Improvement.ImprovementType.AstralReputation).StandardRound());

        /// <summary>
        /// Points of Astral Reputation that have added or removed manually (latter usually by burning Wild Reputation).
        /// </summary>
        public int AstralReputation
        {
            get => _intBaseAstralReputation;
            set
            {
                if (_intBaseAstralReputation != value)
                {
                    _intBaseAstralReputation = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Tooltip to use for Wild Reputation total.
        /// </summary>
        public string WildReputationTooltip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdReturn))
                {
                    sbdReturn.Append(WildReputation.ToString(GlobalSettings.CultureInfo));

                    foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.AstralReputationWild))
                    {
                        sbdReturn.Append(strSpace).Append('+').Append(strSpace).Append(GetObjectName(objImprovement))
                                 .Append(strSpace).Append('(')
                                 .Append(objImprovement.Value.ToString(GlobalSettings.CultureInfo)).Append(')');
                    }

                    return sbdReturn.ToString();
                }
            }
        }

        /// <summary>
        /// Total Reputation with Wild Spirits (FA 175).
        /// </summary>
        public int TotalWildReputation =>
            Math.Max(0,
                WildReputation
                + ImprovementManager.ValueOf(this, Improvement.ImprovementType.AstralReputationWild).StandardRound());

        /// <summary>
        /// Points of Wild Reputation that have added or removed manually (latter usually by burning it to lower Astral Reputation).
        /// </summary>
        public int WildReputation
        {
            get => _intBaseWildReputation;
            set
            {
                if (_intBaseWildReputation != value)
                {
                    _intBaseWildReputation = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Number of Physical Condition Monitor Boxes that are filled.
        /// </summary>
        public int PhysicalCMFilled
        {
            get
            {
                if(HomeNode is Vehicle objVehicle)
                    return objVehicle.PhysicalCMFilled;

                return _intPhysicalCMFilled;
            }
            set
            {
                if(HomeNode is Vehicle objVehicle)
                {
                    if(objVehicle.PhysicalCMFilled != value)
                    {
                        objVehicle.PhysicalCMFilled = value;
                        OnPropertyChanged();
                    }
                }
                else if(_intPhysicalCMFilled != value)
                {
                    _intPhysicalCMFilled = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Number of Stun Condition Monitor Boxes that are filled.
        /// </summary>
        public int StunCMFilled
        {
            get
            {
                if(IsAI && HomeNode != null)
                {
                    // A.I. do not have a Stun Condition Monitor, but they do have a Matrix Condition Monitor if they are in their home node.
                    return HomeNode.MatrixCMFilled;
                }

                return _intStunCMFilled;
            }
            set
            {
                if(IsAI && HomeNode != null)
                {
                    // A.I. do not have a Stun Condition Monitor, but they do have a Matrix Condition Monitor if they are in their home node.
                    if(HomeNode.MatrixCMFilled != value)
                    {
                        HomeNode.MatrixCMFilled = value;
                        OnPropertyChanged();
                    }
                }
                else if(_intStunCMFilled != value)
                {
                    _intStunCMFilled = value;
                    OnPropertyChanged();
                }
            }
        }

        public bool AddInitiationsAllowed => Created || IgnoreRules || Settings.AllowInitiationInCreateMode;

        /// <summary>
        /// Whether or not character creation rules should be ignored.
        /// </summary>
        [HubTag]
        public bool IgnoreRules
        {
            get => _blnIgnoreRules;
            set
            {
                if(_blnIgnoreRules != value)
                {
                    _blnIgnoreRules = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Contact Points.
        /// </summary>
        public int ContactPoints
        {
            get
            {
                if(_intCachedContactPoints == int.MinValue)
                {
                    string strExpression = Settings.ContactPointsExpression;
                    if (strExpression.IndexOfAny('{', '+', '-', '*', ',') != -1 || strExpression.Contains("div"))
                    {
                        using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                      out StringBuilder sbdValue))
                        {
                            sbdValue.Append(strExpression);
                            AttributeSection.ProcessAttributesInXPath(sbdValue, strExpression);

                            // This is first converted to a decimal and rounded up since some items have a multiplier that is not a whole number, such as 2.5.
                            object objProcess
                                = CommonFunctions.EvaluateInvariantXPath(sbdValue.ToString(), out bool blnIsSuccess);
                            _intCachedContactPoints = blnIsSuccess ? ((double) objProcess).StandardRound() : 0;
                        }
                    }
                    else
                        int.TryParse(strExpression, NumberStyles.Any, GlobalSettings.InvariantCultureInfo, out _intCachedContactPoints);
                }

                return _intCachedContactPoints;
            }
        }

        /// <summary>
        /// Number of free Contact Points the character has used.
        /// </summary>
        public int ContactPointsUsed
        {
            get => _intContactPointsUsed;
            set
            {
                if(_intContactPointsUsed != value)
                {
                    _intContactPointsUsed = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// CFP Limit.
        /// </summary>
        public int CFPLimit
        {
            get => _intCFPLimit;
            set
            {
                if(_intCFPLimit != value)
                {
                    _intCFPLimit = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Total AI Program Limit.
        /// </summary>
        public int AINormalProgramLimit
        {
            get => _intAINormalProgramLimit;
            set
            {
                if(_intAINormalProgramLimit != value)
                {
                    _intAINormalProgramLimit = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// AI Advanced Program Limit.
        /// </summary>
        public int AIAdvancedProgramLimit
        {
            get => _intAIAdvancedProgramLimit;
            set
            {
                if(_intAIAdvancedProgramLimit != value)
                {
                    _intAIAdvancedProgramLimit = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Spell Limit.
        /// </summary>
        public int FreeSpells
        {
            get => _intFreeSpells;
            set
            {
                if(_intFreeSpells != value)
                {
                    _intFreeSpells = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Karma.
        /// </summary>
        public int Karma
        {
            get => _intKarma;
            set
            {
                if(_intKarma != value)
                {
                    _intKarma = value;
                    OnPropertyChanged();
                }
            }
        }

        public string DisplayKarma => Karma.ToString(GlobalSettings.CultureInfo);

        /// <summary>
        /// Special.
        /// </summary>
        public int Special
        {
            get => _intSpecial;
            set
            {
                if(_intSpecial != value)
                {
                    _intSpecial = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// TotalSpecial.
        /// </summary>
        public int TotalSpecial
        {
            get => _intTotalSpecial;
            set
            {
                if(_intTotalSpecial != value)
                {
                    _intTotalSpecial = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Attributes.
        /// </summary>
        public int Attributes
        {
            get => _intAttributes;
            set
            {
                if(_intAttributes != value)
                {
                    _intAttributes = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// TotalAttributes.
        /// </summary>
        public int TotalAttributes
        {
            get => _intTotalAttributes;
            set
            {
                if(_intTotalAttributes != value)
                {
                    _intTotalAttributes = value;
                    OnPropertyChanged();
                }
            }
        }

        private int _intCachedCareerKarma = int.MinValue;

        /// <summary>
        /// Total amount of Karma the character has earned over the career.
        /// </summary>
        [HubTag]
        public int CareerKarma
        {
            get
            {
                if(_intCachedCareerKarma != int.MinValue)
                    return _intCachedCareerKarma;

                int intKarma = 0;

                foreach(ExpenseLogEntry objEntry in _lstExpenseLog)
                {
                    // Since we're only interested in the amount they have earned, only count values that are greater than 0 and are not refunds.
                    if(objEntry.Type == ExpenseType.Karma && (objEntry.Amount > 0 || objEntry.ForceCareerVisible) && !objEntry.Refund)
                        intKarma += objEntry.Amount.StandardRound();
                }

                return _intCachedCareerKarma = intKarma;
            }
        }

        public string DisplayCareerKarma => CareerKarma.ToString(GlobalSettings.CultureInfo);

        private decimal _decCachedCareerNuyen = decimal.MinValue;

        /// <summary>
        /// Total amount of Nuyen the character has earned over the career.
        /// </summary>
        public decimal CareerNuyen
        {
            get
            {
                if(_decCachedCareerNuyen != decimal.MinValue)
                    return _decCachedCareerNuyen;

                decimal decNuyen = 0;

                foreach(ExpenseLogEntry objEntry in _lstExpenseLog)
                {
                    // Since we're only interested in the amount they have earned, only count values that are greater than 0 and are not refunds.
                    if(objEntry.Type == ExpenseType.Nuyen && objEntry.Amount > 0 && !objEntry.Refund)
                        decNuyen += objEntry.Amount;
                }

                return _decCachedCareerNuyen = decNuyen;
            }
        }

        public string DisplayCareerNuyen =>
            CareerNuyen.ToString(Settings.NuyenFormat, GlobalSettings.CultureInfo) + '';

        /// <summary>
        /// Special.
        /// </summary>
        public int EdgeUsed
        {
            get => _intEdgeUsed;
            set
            {
                if (_intEdgeUsed != value)
                {
                    _intEdgeUsed = value;
                    OnPropertyChanged();
                }
            }
        }

        public int EdgeRemaining => EDG.TotalValue - EdgeUsed;

        public string EdgeRemainingString => EdgeRemaining.ToString(GlobalSettings.CultureInfo) + LanguageManager.GetString("String_Of")
            + EDG.TotalValue.ToString(GlobalSettings.CultureInfo) + LanguageManager.GetString("String_Space") + LanguageManager.GetString("String_Remaining");

        /// <summary>
        /// Whether or not the character is a Critter.
        /// </summary>
        [HubTag]
        public bool IsCritter
        {
            get => _blnIsCritter;
            set
            {
                if(_blnIsCritter != value)
                {
                    _blnIsCritter = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Whether or not the character is a changeling.
        /// </summary>
        [HubTag]
        public bool IsChangeling => MetagenicLimit > 0;

        /// <summary>
        /// The highest number of free Metagenic qualities the character can have.
        /// </summary>
        public int MetagenicLimit => ImprovementManager.ValueOf(this, Improvement.ImprovementType.MetageneticLimit).StandardRound();

        /// <summary>
        /// The highest number of free Metagenic qualities the character can have.
        /// </summary>
        public int SpecialModificationLimit => ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpecialModificationLimit).StandardRound();

        /// <summary>
        /// Whether or not the character is possessed by a Spirit.
        /// </summary>
        public bool Possessed
        {
            get => _blnPossessed;
            set
            {
                if(_blnPossessed != value)
                {
                    _blnPossessed = value;
                    OnPropertyChanged();
                }
            }
        }

        public int SpellKarmaCost(string strCategory = "")
        {
            decimal decReturn = Settings.KarmaSpell;

            // Unconditional modifiers first (which can be cached)
            decReturn += ImprovementManager.ValueOf(this, Improvement.ImprovementType.NewSpellKarmaCost, strImprovedName: strCategory);

            foreach (Improvement objLoopImprovement in Improvements)
            {
                if (objLoopImprovement.ImproveType != Improvement.ImprovementType.NewSpellKarmaCost)
                    continue;
                if (!objLoopImprovement.Enabled)
                    continue;
                switch (objLoopImprovement.Condition)
                {
                    case "career":
                        if (Created)
                            decReturn += objLoopImprovement.Value;
                        break;
                    case "create":
                        if (!Created)
                            decReturn += objLoopImprovement.Value;
                        break;
                    default:
                        continue;
                }
            }

            // Unconditional modifiers first (which can be cached)
            decimal decMultiplier = 1.0m;
            foreach (Improvement objLoopImprovement in ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.NewSpellKarmaCostMultiplier, strCategory))
            {
                decMultiplier *= objLoopImprovement.Value / 100.0m;
            }

            foreach (Improvement objLoopImprovement in Improvements)
            {
                if (objLoopImprovement.ImproveType != Improvement.ImprovementType.NewSpellKarmaCostMultiplier)
                    continue;
                if (!objLoopImprovement.Enabled)
                    continue;
                switch (objLoopImprovement.Condition)
                {
                    case "career":
                        if (Created)
                            decMultiplier *= objLoopImprovement.Value / 100.0m;
                        break;
                    case "create":
                        if (!Created)
                            decMultiplier *= objLoopImprovement.Value / 100.0m;
                        break;
                    default:
                        continue;
                }
            }

            if (decMultiplier != 1.0m)
                decReturn *= decMultiplier;

            return Math.Max(decReturn.StandardRound(), 0);
        }

        public int ComplexFormKarmaCost
        {
            get
            {
                decimal decReturn = Settings.KarmaNewComplexForm;

                decimal decMultiplier = 1.0m;
                foreach(Improvement objLoopImprovement in Improvements)
                {
                    if ((string.IsNullOrEmpty(objLoopImprovement.Condition)
                         || (objLoopImprovement.Condition == "career") == Created
                         || (objLoopImprovement.Condition == "create") != Created) && objLoopImprovement.Enabled)
                    {
                        switch (objLoopImprovement.ImproveType)
                        {
                            case Improvement.ImprovementType.NewComplexFormKarmaCost:
                                decReturn += objLoopImprovement.Value;
                                break;
                            case Improvement.ImprovementType.NewComplexFormKarmaCostMultiplier:
                                decMultiplier *= objLoopImprovement.Value / 100.0m;
                                break;
                        }
                    }
                }

                if(decMultiplier != 1.0m)
                    decReturn *= decMultiplier;

                return Math.Max(decReturn.StandardRound(), 0);
            }
        }

        public int AIProgramKarmaCost
        {
            get
            {
                decimal decReturn = Settings.KarmaNewAIProgram;

                decimal decMultiplier = 1.0m;
                foreach(Improvement objLoopImprovement in Improvements)
                {
                    if ((string.IsNullOrEmpty(objLoopImprovement.Condition)
                         || (objLoopImprovement.Condition == "career") == Created
                         || (objLoopImprovement.Condition == "create") != Created) && objLoopImprovement.Enabled)
                    {
                        switch (objLoopImprovement.ImproveType)
                        {
                            case Improvement.ImprovementType.NewAIProgramKarmaCost:
                                decReturn += objLoopImprovement.Value;
                                break;
                            case Improvement.ImprovementType.NewAIProgramKarmaCostMultiplier:
                                decMultiplier *= objLoopImprovement.Value / 100.0m;
                                break;
                        }
                    }
                }

                if (decMultiplier != 1.0m)
                    decReturn *= decMultiplier;

                return Math.Max(decReturn.StandardRound(), 0);
            }
        }

        public int AIAdvancedProgramKarmaCost
        {
            get
            {
                decimal decReturn = Settings.KarmaNewAIAdvancedProgram;

                decimal decMultiplier = 1.0m;
                foreach(Improvement objLoopImprovement in Improvements)
                {
                    if ((string.IsNullOrEmpty(objLoopImprovement.Condition)
                         || (objLoopImprovement.Condition == "career") == Created
                         || (objLoopImprovement.Condition == "create") != Created) && objLoopImprovement.Enabled)
                    {
                        switch (objLoopImprovement.ImproveType)
                        {
                            case Improvement.ImprovementType.NewAIAdvancedProgramKarmaCost:
                                decReturn += objLoopImprovement.Value;
                                break;
                            case Improvement.ImprovementType.NewAIAdvancedProgramKarmaCostMultiplier:
                                decMultiplier *= objLoopImprovement.Value / 100.0m;
                                break;
                        }
                    }
                }

                if (decMultiplier != 1.0m)
                    decReturn *= decMultiplier;

                return Math.Max(decReturn.StandardRound(), 0);
            }
        }

        private int _intCachedAmbidextrous = int.MinValue;

        public bool Ambidextrous
        {
            get
            {
                if(_intCachedAmbidextrous < 0)
                {
                    _intCachedAmbidextrous = ImprovementManager
                                             .GetCachedImprovementListForValueOf(
                                                 this, Improvement.ImprovementType.Ambidextrous).Count > 0
                        ? 1
                        : 0;
                }

                return _intCachedAmbidextrous > 0;
            }
        }

        #endregion

        #region Attributes

        /// <summary>
        /// Get a CharacterAttribute by its name.
        /// </summary>
        /// <param name="strAttribute">CharacterAttribute name to retrieve.</param>
        /// <param name="blnExplicit">Whether to force looking for a specific attribute name.
        /// Mostly expected to be used for gutting Mystic Adept power points.</param>
        public CharacterAttrib GetAttribute(string strAttribute, bool blnExplicit = false)
        {
            if(strAttribute == "MAGAdept" && (!IsMysticAdept || !Settings.MysAdeptSecondMAGAttribute) && !blnExplicit)
                strAttribute = "MAG";
            return AttributeSection.GetAttributeByName(strAttribute);
        }

        /// <summary>
        /// Body (BOD) CharacterAttribute.
        /// </summary>
        public CharacterAttrib BOD => AttributeSection.GetAttributeByName("BOD");

        /// <summary>
        /// Agility (AGI) CharacterAttribute.
        /// </summary>
        public CharacterAttrib AGI => AttributeSection.GetAttributeByName("AGI");

        /// <summary>
        /// Reaction (REA) CharacterAttribute.
        /// </summary>
        public CharacterAttrib REA => AttributeSection.GetAttributeByName("REA");

        /// <summary>
        /// Strength (STR) CharacterAttribute.
        /// </summary>
        public CharacterAttrib STR => AttributeSection.GetAttributeByName("STR");

        /// <summary>
        /// Charisma (CHA) CharacterAttribute.
        /// </summary>
        public CharacterAttrib CHA => AttributeSection.GetAttributeByName("CHA");

        /// <summary>
        /// Intuition (INT) CharacterAttribute.
        /// </summary>
        public CharacterAttrib INT => AttributeSection.GetAttributeByName("INT");

        /// <summary>
        /// Logic (LOG) CharacterAttribute.
        /// </summary>
        public CharacterAttrib LOG => AttributeSection.GetAttributeByName("LOG");

        /// <summary>
        /// Willpower (WIL) CharacterAttribute.
        /// </summary>
        public CharacterAttrib WIL => AttributeSection.GetAttributeByName("WIL");

        /// <summary>
        /// Edge (EDG) CharacterAttribute.
        /// </summary>
        public CharacterAttrib EDG => AttributeSection.GetAttributeByName("EDG");

        /// <summary>
        /// Magic (MAG) CharacterAttribute.
        /// </summary>
        public CharacterAttrib MAG => AttributeSection.GetAttributeByName("MAG");

        /// <summary>
        /// Reflection of MAG (hide it, if it is not enabled!)
        /// </summary>
        [HubTag("Magic")]
        public CharacterAttrib ReflectionMAG => MAGEnabled ? MAG : null;

        /// <summary>
        /// Magic (MAG) CharacterAttribute for Adept powers of Mystic Adepts when the appropriate house rule is enabled.
        /// </summary>
        public CharacterAttrib MAGAdept
        {
            get
            {
                if(Settings.MysAdeptSecondMAGAttribute && IsMysticAdept)
                    return AttributeSection.GetAttributeByName("MAGAdept");
                return MAG;
            }
        }

        /// <summary>
        /// Reflection of MAGAdept (hide it, if it is not enabled!)
        /// </summary>
        [HubTag("MagicAdept")]
        public CharacterAttrib ReflectionMAGAdept => MAGEnabled ? MAGAdept : null;

        /// <summary>
        /// Resonance (RES) CharacterAttribute.
        /// </summary>
        public CharacterAttrib RES => AttributeSection.GetAttributeByName("RES");

        /// <summary>
        /// Reflection of RES (hide it, if it is not enabled!)
        /// </summary>
        [HubTag("Resonance")]
        public CharacterAttrib ReflectionRES => RESEnabled ? RES : null;

        /// <summary>
        /// Depth (DEP) Attribute.
        /// </summary>
        public CharacterAttrib DEP => AttributeSection.GetAttributeByName("DEP");

        /// <summary>
        /// Reflection of DEP (hide it, if it is not enabled!)
        /// </summary>
        [HubTag("Depth")]
        public CharacterAttrib ReflectionDEP => DEPEnabled ? DEP : null;

        /// <summary>
        /// Essence (ESS) Attribute.
        /// </summary>
        public CharacterAttrib ESS => AttributeSection.GetAttributeByName("ESS");

        /// <summary>
        /// Is the MAG CharacterAttribute enabled?
        /// </summary>
        [HubTag]
        public bool MAGEnabled
        {
            get => _blnMAGEnabled;
            set
            {
                if(_blnMAGEnabled != value)
                {
                    _blnMAGEnabled = value;
                    if (IsLoading)
                    {
                        OnPropertyChanged();
                        return;
                    }
                    if (value)
                    {
                        // Career mode, so no extra calculations need to be done for EssenceAtSpecialStart
                        if(Created)
                        {
                            ResetCachedEssence();
                            EssenceAtSpecialStart = Essence(true);
                        }
                        // EssenceAtSpecialStart needs to be calculated by assuming that the character took the MAG-enabling quality with the highest essence penalty first, as that would be the most optimal
                        else
                        {
                            // If this character has any MAG-enabling bonuses that could be granted before all others (because they're priority and/or metatype-given),
                            // it has to be assumed those are taken first.
                            List<Improvement> lstAttributeImprovements = ImprovementManager
                                .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Attribute, "MAG");
                            bool blnCountOnlyPriorityOrMetatypeGivenBonuses = lstAttributeImprovements.Any(
                                x => x.ImproveSource
                                     == Improvement.ImprovementSource
                                                   .Metatype
                                     || x.ImproveSource
                                     == Improvement.ImprovementSource
                                                   .Metavariant
                                     || x.ImproveSource
                                     == Improvement.ImprovementSource
                                                   .Heritage);
                            if (!blnCountOnlyPriorityOrMetatypeGivenBonuses)
                            {
                                List<string> lstMAGEnablingQualityIds = lstAttributeImprovements
                                                                        .Where(x => x.ImproveSource
                                                                                   == Improvement.ImprovementSource
                                                                                       .Quality).Select(
                                                                            x => x.SourceName).ToList();
                                // Can't use foreach because new items can get added to this list while it is looping
                                for (int i = 0; i < lstMAGEnablingQualityIds.Count; ++i)
                                {
                                    Quality objQuality = Qualities.FirstOrDefault(x => x.InternalId == lstMAGEnablingQualityIds[i]);
                                    if (objQuality != null)
                                    {
                                        if (objQuality.OriginSource == QualitySource.Metatype
                                            || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                            || objQuality.OriginSource == QualitySource.BuiltIn
                                            || objQuality.OriginSource == QualitySource.LifeModule
                                            || objQuality.OriginSource == QualitySource.Heritage)
                                        {
                                            blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                            break;
                                        }

                                        if (objQuality.OriginSource == QualitySource.Improvement)
                                        {
                                            List<Improvement> lstSpecificQualityImprovements = ImprovementManager
                                                .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.SpecificQuality, objQuality.InternalId);
                                            if (lstSpecificQualityImprovements.Any(x =>
                                                    x.ImproveSource == Improvement.ImprovementSource.Metatype
                                                    || x.ImproveSource == Improvement.ImprovementSource.Metavariant
                                                    || x.ImproveSource == Improvement.ImprovementSource.Heritage))
                                            {
                                                blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                                break;
                                            }
                                            // Qualities that add other qualities get added to the list to be checked, too
                                            lstMAGEnablingQualityIds.AddRange(
                                                lstSpecificQualityImprovements
                                                    .Where(
                                                        x => x.ImproveSource == Improvement.ImprovementSource.Quality)
                                                    .Select(x => x.SourceName));
                                        }
                                    }
                                }
                            }
                            Dictionary<string, decimal> dicImprovementEssencePenalties =
                                new Dictionary<string, decimal>(Improvements.Count);
                            foreach(Improvement objImprovement in Improvements)
                            {
                                if (!objImprovement.Enabled)
                                    continue;
                                bool blnCountImprovement = !blnCountOnlyPriorityOrMetatypeGivenBonuses
                                                           || objImprovement.ImproveSource == Improvement.ImprovementSource.Metatype
                                                           || objImprovement.ImproveSource == Improvement.ImprovementSource.Metavariant
                                                           || objImprovement.ImproveSource == Improvement.ImprovementSource.Heritage;
                                if (!blnCountImprovement && objImprovement.ImproveSource == Improvement.ImprovementSource.Quality)
                                {
                                    Quality objQuality = Qualities.FirstOrDefault(x => x.InternalId == objImprovement.SourceName);
                                    while (objQuality != null)
                                    {
                                        if (objQuality.OriginSource == QualitySource.Metatype
                                            || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                            || objQuality.OriginSource == QualitySource.BuiltIn
                                            || objQuality.OriginSource == QualitySource.LifeModule
                                            || objQuality.OriginSource == QualitySource.Heritage)
                                        {
                                            blnCountImprovement = true;
                                            break;
                                        }

                                        if (objQuality.OriginSource == QualitySource.Improvement)
                                        {
                                            Improvement objParentImprovement = ImprovementManager
                                                                               .GetCachedImprovementListForValueOf(
                                                                                   this,
                                                                                   Improvement.ImprovementType
                                                                                       .SpecificQuality,
                                                                                   objQuality.InternalId)
                                                                               .FirstOrDefault();
                                            if (objParentImprovement == null)
                                                break;
                                            if (objParentImprovement.ImproveSource == Improvement.ImprovementSource.Metatype
                                                || objParentImprovement.ImproveSource == Improvement.ImprovementSource.Metavariant
                                                || objParentImprovement.ImproveSource == Improvement.ImprovementSource.Heritage)
                                            {
                                                blnCountImprovement = true;
                                                break;
                                            }
                                            if (objParentImprovement.ImproveSource == Improvement.ImprovementSource.Quality)
                                            {
                                                // Qualities that add other qualities get added to the list to be checked, too
                                                objQuality = Qualities.FirstOrDefault(x => x.InternalId == objParentImprovement.SourceName);
                                            }
                                            else
                                                break;
                                        }
                                        else
                                            break;
                                    }
                                }
                                if (blnCountImprovement)
                                {
                                    decimal decLoopEssencePenalty = 0;
                                    switch (objImprovement.ImproveType)
                                    {
                                        case Improvement.ImprovementType.EssencePenalty:
                                            decLoopEssencePenalty += objImprovement.Value;
                                            break;
                                        case Improvement.ImprovementType.EssencePenaltyT100:
                                        case Improvement.ImprovementType.EssencePenaltyMAGOnlyT100:
                                            decLoopEssencePenalty += objImprovement.Value / 100.0m;
                                            break;
                                    }

                                    if(decLoopEssencePenalty != 0)
                                    {
                                        if(dicImprovementEssencePenalties.TryGetValue(objImprovement.SourceName, out decimal decExistingPenalty))
                                            dicImprovementEssencePenalties[objImprovement.SourceName] = decExistingPenalty + decLoopEssencePenalty;
                                        else
                                            dicImprovementEssencePenalties.Add(objImprovement.SourceName,
                                                decLoopEssencePenalty);
                                    }
                                }
                            }

                            if(dicImprovementEssencePenalties.Count > 0)
                                EssenceAtSpecialStart =
                                    ESS.MetatypeMaximum + dicImprovementEssencePenalties.Values.Min();
                            else
                                EssenceAtSpecialStart = ESS.MetatypeMaximum;
                        }
                    }
                    else
                    {
                        if(!RESEnabled)
                        {
                            ClearInitiations();
                            MagicTradition.ResetTradition();
                        }
                        else
                        {
                            XmlNode xmlTraditionListDataNode = LoadData("streams.xml").SelectSingleNode("/chummer/traditions");
                            if(xmlTraditionListDataNode != null)
                            {
                                XmlNode xmlTraditionDataNode = xmlTraditionListDataNode.SelectSingleNode("tradition[name = \"Default\"]");
                                if(xmlTraditionDataNode != null)
                                {
                                    if(!MagicTradition.Create(xmlTraditionDataNode, true))
                                        MagicTradition.ResetTradition();
                                }
                                else
                                    MagicTradition.ResetTradition();
                            }
                            else
                                MagicTradition.ResetTradition();
                        }
                        if(!Created && !RESEnabled && !DEPEnabled)
                            EssenceAtSpecialStart = decimal.MinValue;
                    }

                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Maximum force of spirits summonable/bindable by the character. Limited to MAG at creation.
        /// </summary>
        public int MaxSpiritForce
        {
            get
            {
                int intReturn = Settings.SpiritForceBasedOnTotalMAG ? MAG.TotalValue : MAG.Value;
                if (intReturn <= 0)
                    return 0;
                if (Created)
                    intReturn *= 2;
                return intReturn;
            }
        }

        public int BoundSpiritLimit
        {
            get
            {
                if (_intBoundSpiritLimit == int.MinValue)
                {
                    string strExpression = Settings.BoundSpiritExpression;
                    if (strExpression.IndexOfAny('{', '+', '-', '*', ',') != -1 || strExpression.Contains("div"))
                    {
                        using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                      out StringBuilder sbdValue))
                        {
                            sbdValue.Append(strExpression);
                            AttributeSection.ProcessAttributesInXPath(sbdValue, strExpression);

                            // This is first converted to a decimal and rounded up since some items have a multiplier that is not a whole number, such as 2.5.
                            object objProcess
                                = CommonFunctions.EvaluateInvariantXPath(sbdValue.ToString(), out bool blnIsSuccess);
                            _intBoundSpiritLimit = blnIsSuccess ? ((double) objProcess).StandardRound() : 0;
                        }
                    }
                    else
                        int.TryParse(strExpression, NumberStyles.Any, GlobalSettings.InvariantCultureInfo, out _intBoundSpiritLimit);
                }
                return _intBoundSpiritLimit;
            }
        }

        /// <summary>
        /// Maximum level of sprites compilable/registrable by the character. Limited to RES at creation.
        /// </summary>
        public int MaxSpriteLevel
        {
            get
            {
                int intReturn = RES.TotalValue;
                if (intReturn <= 0)
                    return 0;
                if (Created)
                    intReturn *= 2;
                return intReturn;
            }
        }

        public int RegisteredSpriteLimit
        {
            get
            {
                if (_intRegisteredSpriteLimit == int.MinValue)
                {
                    string strExpression = Settings.RegisteredSpriteExpression;
                    if (strExpression.IndexOfAny('{', '+', '-', '*', ',') != -1 || strExpression.Contains("div"))
                    {
                        using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                      out StringBuilder sbdValue))
                        {
                            sbdValue.Append(strExpression);
                            AttributeSection.ProcessAttributesInXPath(sbdValue, strExpression);

                            // This is first converted to a decimal and rounded up since some items have a multiplier that is not a whole number, such as 2.5.
                            object objProcess
                                = CommonFunctions.EvaluateInvariantXPath(sbdValue.ToString(), out bool blnIsSuccess);
                            _intRegisteredSpriteLimit = blnIsSuccess ? ((double) objProcess).StandardRound() : 0;
                        }
                    }
                    else
                        int.TryParse(strExpression, NumberStyles.Any, GlobalSettings.InvariantCultureInfo, out _intRegisteredSpriteLimit);
                }
                return _intRegisteredSpriteLimit;
            }
        }

        /// <summary>
        /// Amount of Power Points for Mystic Adepts.
        /// </summary>
        public int MysticAdeptPowerPoints
        {
            get => _intMAGAdept;
            set
            {
                int intNewValue = Math.Min(value, MAG.TotalValue);
                if(_intMAGAdept != intNewValue)
                {
                    _intMAGAdept = intNewValue;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Total Amount of Power Points this character has.
        /// </summary>
        public decimal PowerPointsTotal
        {
            get
            {
                decimal decMAG = UseMysticAdeptPPs ? MysticAdeptPowerPoints : MAGAdept.TotalValue;

                // Add any Power Point Improvements to MAG.
                decMAG += ImprovementManager.ValueOf(this, Improvement.ImprovementType.AdeptPowerPoints);

                return Math.Max(decMAG, 0);
            }
        }

        private decimal _decCachedPowerPointsUsed = decimal.MinValue;

        public decimal PowerPointsUsed
        {
            get
            {
                if(_decCachedPowerPointsUsed != decimal.MinValue)
                    return _decCachedPowerPointsUsed;
                return _decCachedPowerPointsUsed = Powers.Sum(objPower => objPower.PowerPoints);
            }
        }

        public string DisplayPowerPointsRemaining
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                return PowerPointsTotal.ToString(GlobalSettings.CultureInfo) + strSpace + '(' +
                       (PowerPointsTotal - PowerPointsUsed).ToString(GlobalSettings.CultureInfo) + strSpace +
                       LanguageManager.GetString("String_Remaining") + ')';
            }
        }

        public bool AnyPowerAdeptWayDiscountEnabled => Powers.Any(objPower => objPower.AdeptWayDiscountEnabled);

        /// <summary>
        /// Magician's Tradition.
        /// </summary>
        [HubTag("Tradition", "", "MagicTradition", false)]
        public Tradition MagicTradition
        {
            get => _objTradition;
            set => _objTradition = value;
        }

        /// <summary>
        /// Initiate Grade.
        /// </summary>
        [HubTag]
        public int InitiateGrade
        {
            get => _intInitiateGrade;
            set
            {
                if (_intInitiateGrade == value)
                    return;
                bool blnFirstInitiation = _intInitiateGrade == 0;
                _intInitiateGrade = value;
                // Remove any existing Initiation Improvements.
                if (value == 0)
                {
                    ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Initiation);
                    // Update any Metamagic Improvements the character might have.
                    foreach (Metamagic objMetamagic in Metamagics.Where(x => x.SourceType == Improvement.ImprovementSource.Metamagic && x.Bonus?.InnerXml.Contains("Rating") == true))
                    {
                        ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Metamagic,
                            objMetamagic.InternalId);
                    }
                }
                else if (blnFirstInitiation)
                {
                    // Create the new Improvement.
                    ImprovementManager.CreateImprovement(this, "MAG", Improvement.ImprovementSource.Initiation,
                        string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, value, 0, 1);
                    ImprovementManager.CreateImprovement(this, "MAGAdept", Improvement.ImprovementSource.Initiation,
                        string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, value, 0, 1);
                    ImprovementManager.Commit(this);
                    // Update any Metamagic Improvements the character might have.
                    foreach (Metamagic objMetamagic in Metamagics.Where(x => x.SourceType == Improvement.ImprovementSource.Metamagic && x.Bonus?.InnerXml.Contains("Rating") == true))
                    {
                        ImprovementManager.CreateImprovements(this, Improvement.ImprovementSource.Metamagic,
                            objMetamagic.InternalId, objMetamagic.Bonus, value,
                            objMetamagic.DisplayNameShort(GlobalSettings.Language));
                    }
                }
                else
                {
                    if (Improvements.All(x => x.ImproveSource != Improvement.ImprovementSource.Initiation))
                    {
                        // Create the new Improvement.
                        ImprovementManager.CreateImprovement(this, "MAG", Improvement.ImprovementSource.Initiation,
                            string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, value, 0, 1);
                        ImprovementManager.CreateImprovement(this, "MAGAdept", Improvement.ImprovementSource.Initiation,
                            string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, value, 0, 1);
                        ImprovementManager.Commit(this);
                    }
                    else
                    {
                        // ReSharper disable once ForCanBeConvertedToForeach
                        for (int i = 0; i < Improvements.Count; ++i)
                        {
                            Improvement objImprovement = Improvements[i];
                            if (objImprovement.ImproveSource == Improvement.ImprovementSource.Initiation)
                                objImprovement.Rating = value;
                        }
                    }

                    // Update any Metamagic Improvements the character might have.
                    foreach (Metamagic objMetamagic in Metamagics.Where(x => x.SourceType == Improvement.ImprovementSource.Metamagic && x.Bonus?.InnerXml.Contains("Rating") == true))
                    {
                        string strMetamagicId = objMetamagic.InternalId;
                        // If the Bonus contains "Rating", refresh ratings of existing Improvements.
                        if (Improvements.All(x =>
                            x.ImproveSource != Improvement.ImprovementSource.Metamagic ||
                            x.SourceName != strMetamagicId))
                        {
                            ImprovementManager.CreateImprovements(this, Improvement.ImprovementSource.Metamagic,
                                                                  strMetamagicId, objMetamagic.Bonus, value,
                                objMetamagic.DisplayNameShort(GlobalSettings.Language));
                        }
                        else
                        {
                            // ReSharper disable once ForCanBeConvertedToForeach
                            for (int i = 0; i < Improvements.Count; ++i)
                            {
                                Improvement objImprovement = Improvements[i];
                                if (objImprovement.SourceName == strMetamagicId &&
                                    objImprovement.ImproveSource == Improvement.ImprovementSource.Metamagic)
                                    objImprovement.Rating = value;
                            }
                        }
                    }
                }
                OnPropertyChanged();
            }
        }

        /// <summary>
        /// Is the RES CharacterAttribute enabled?
        /// </summary>
        [HubTag]
        public bool RESEnabled
        {
            get => _blnRESEnabled;
            set
            {
                if(_blnRESEnabled != value)
                {
                    _blnRESEnabled = value;
                    if (IsLoading)
                    {
                        OnPropertyChanged();
                        return;
                    }
                    if (value)
                    {
                        // Career mode, so no extra calculations need to be done for EssenceAtSpecialStart
                        if(Created)
                        {
                            ResetCachedEssence();
                            EssenceAtSpecialStart = Essence();
                        }
                        // EssenceAtSpecialStart needs to be calculated by assuming that the character took the RES-enabling quality with the highest essence penalty first, as that would be the most optimal
                        else
                        {
                            // If this character has any RES-enabling bonuses that could be granted before all others (because they're priority and/or metatype-given),
                            // it has to be assumed those are taken first.
                            List<Improvement> lstAttributeImprovements = ImprovementManager
                                .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Attribute, "RES");
                            bool blnCountOnlyPriorityOrMetatypeGivenBonuses = lstAttributeImprovements.Any(
                                x => x.ImproveSource
                                     == Improvement.ImprovementSource
                                                   .Metatype
                                     || x.ImproveSource
                                     == Improvement.ImprovementSource
                                                   .Metavariant
                                     || x.ImproveSource
                                     == Improvement.ImprovementSource
                                                   .Heritage);
                            if (!blnCountOnlyPriorityOrMetatypeGivenBonuses)
                            {
                                List<string> lstRESEnablingQualityIds = lstAttributeImprovements
                                                                        .Where(x => x.ImproveSource
                                                                                   == Improvement.ImprovementSource
                                                                                       .Quality).Select(
                                                                            x => x.SourceName).ToList();
                                // Can't use foreach because new items can get added to this list while it is looping
                                for (int i = 0; i < lstRESEnablingQualityIds.Count; ++i)
                                {
                                    Quality objQuality = Qualities.FirstOrDefault(x => x.InternalId == lstRESEnablingQualityIds[i]);
                                    if (objQuality != null)
                                    {
                                        if (objQuality.OriginSource == QualitySource.Metatype
                                            || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                            || objQuality.OriginSource == QualitySource.BuiltIn
                                            || objQuality.OriginSource == QualitySource.LifeModule
                                            || objQuality.OriginSource == QualitySource.Heritage)
                                        {
                                            blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                            break;
                                        }

                                        if (objQuality.OriginSource == QualitySource.Improvement)
                                        {
                                            List<Improvement> lstSpecificQualityImprovements = ImprovementManager
                                                .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.SpecificQuality, objQuality.InternalId);
                                            if (lstSpecificQualityImprovements.Any(x =>
                                                    x.ImproveSource == Improvement.ImprovementSource.Metatype
                                                    || x.ImproveSource == Improvement.ImprovementSource.Metavariant
                                                    || x.ImproveSource == Improvement.ImprovementSource.Heritage))
                                            {
                                                blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                                break;
                                            }
                                            // Qualities that add other qualities get added to the list to be checked, too
                                            lstRESEnablingQualityIds.AddRange(
                                                lstSpecificQualityImprovements
                                                    .Where(
                                                        x => x.ImproveSource == Improvement.ImprovementSource.Quality)
                                                    .Select(x => x.SourceName));
                                        }
                                    }
                                }
                            }
                            Dictionary<string, decimal> dicImprovementEssencePenalties =
                                new Dictionary<string, decimal>(Improvements.Count);
                            foreach (Improvement objImprovement in Improvements)
                            {
                                if (!objImprovement.Enabled)
                                    continue;
                                bool blnCountImprovement = !blnCountOnlyPriorityOrMetatypeGivenBonuses
                                                           || objImprovement.ImproveSource == Improvement.ImprovementSource.Metatype
                                                           || objImprovement.ImproveSource == Improvement.ImprovementSource.Metavariant
                                                           || objImprovement.ImproveSource == Improvement.ImprovementSource.Heritage;
                                if (!blnCountImprovement
                                    && objImprovement.ImproveSource == Improvement.ImprovementSource.Quality)
                                {
                                    Quality objQuality = Qualities.FirstOrDefault(x => x.InternalId == objImprovement.SourceName);
                                    while (objQuality != null)
                                    {
                                        if (objQuality.OriginSource == QualitySource.Metatype
                                            || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                            || objQuality.OriginSource == QualitySource.BuiltIn
                                            || objQuality.OriginSource == QualitySource.LifeModule
                                            || objQuality.OriginSource == QualitySource.Heritage)
                                        {
                                            blnCountImprovement = true;
                                            break;
                                        }

                                        if (objQuality.OriginSource == QualitySource.Improvement)
                                        {
                                            Improvement objParentImprovement = ImprovementManager
                                                                               .GetCachedImprovementListForValueOf(
                                                                                   this,
                                                                                   Improvement.ImprovementType
                                                                                       .SpecificQuality,
                                                                                   objQuality.InternalId)
                                                                               .FirstOrDefault();
                                            if (objParentImprovement == null)
                                                break;
                                            if (objParentImprovement.ImproveSource == Improvement.ImprovementSource.Metatype
                                                || objParentImprovement.ImproveSource == Improvement.ImprovementSource.Metavariant
                                                || objParentImprovement.ImproveSource == Improvement.ImprovementSource.Heritage)
                                            {
                                                blnCountImprovement = true;
                                                break;
                                            }
                                            if (objParentImprovement.ImproveSource == Improvement.ImprovementSource.Quality)
                                            {
                                                // Qualities that add other qualities get added to the list to be checked, too
                                                objQuality = Qualities.FirstOrDefault(x => x.InternalId == objParentImprovement.SourceName);
                                            }
                                            else
                                                break;
                                        }
                                        else
                                            break;
                                    }
                                }
                                if (blnCountImprovement)
                                {
                                    decimal decLoopEssencePenalty = 0;
                                    switch (objImprovement.ImproveType)
                                    {
                                        case Improvement.ImprovementType.EssencePenalty:
                                            decLoopEssencePenalty += objImprovement.Value;
                                            break;
                                        case Improvement.ImprovementType.EssencePenaltyT100:
                                            decLoopEssencePenalty += objImprovement.Value / 100.0m;
                                            break;
                                    }

                                    if(decLoopEssencePenalty != 0)
                                    {
                                        if(dicImprovementEssencePenalties.TryGetValue(objImprovement.SourceName, out decimal decExistingPenalty))
                                            dicImprovementEssencePenalties[objImprovement.SourceName] = decExistingPenalty + decLoopEssencePenalty;
                                        else
                                            dicImprovementEssencePenalties.Add(objImprovement.SourceName,
                                                decLoopEssencePenalty);
                                    }
                                }
                            }

                            if(dicImprovementEssencePenalties.Count > 0)
                                EssenceAtSpecialStart =
                                    ESS.MetatypeMaximum + dicImprovementEssencePenalties.Values.Min();
                            else
                                EssenceAtSpecialStart = ESS.MetatypeMaximum;
                        }

                        XmlNode xmlTraditionListDataNode = LoadData("streams.xml").SelectSingleNode("/chummer/traditions");
                        if(xmlTraditionListDataNode != null)
                        {
                            XmlNode xmlTraditionDataNode = xmlTraditionListDataNode.SelectSingleNode("tradition[name = \"Default\"]");
                            if(xmlTraditionDataNode != null)
                            {
                                if(!MagicTradition.Create(xmlTraditionDataNode, true))
                                    MagicTradition.ResetTradition();
                            }
                            else
                            {
                                xmlTraditionDataNode = xmlTraditionListDataNode.SelectSingleNode("tradition");
                                if(xmlTraditionDataNode != null && !MagicTradition.Create(xmlTraditionDataNode, true))
                                {
                                    MagicTradition.ResetTradition();
                                }
                            }
                        }
                    }
                    else
                    {
                        if(!MAGEnabled)
                        {
                            ClearInitiations();
                            MagicTradition.ResetTradition();
                        }
                        else
                        {
                            XmlNode xmlTraditionListDataNode = LoadData("traditions.xml").SelectSingleNode("/chummer/traditions");
                            if(xmlTraditionListDataNode != null)
                            {
                                XmlNode xmlTraditionDataNode = xmlTraditionListDataNode.SelectSingleNode("tradition[id = " + Tradition.CustomMagicalTraditionGuid.CleanXPath() + ']');
                                if(xmlTraditionDataNode != null)
                                {
                                    if(!MagicTradition.Create(xmlTraditionDataNode))
                                        MagicTradition.ResetTradition();
                                }
                                else
                                    MagicTradition.ResetTradition();
                            }
                            else
                                MagicTradition.ResetTradition();
                        }
                        if(!Created && !DEPEnabled && !MAGEnabled)
                            EssenceAtSpecialStart = decimal.MinValue;
                    }

                    ImprovementManager.ClearCachedValue(this, Improvement.ImprovementType.MatrixInitiativeDice);
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Is the DEP CharacterAttribute enabled?
        /// </summary>
        [HubTag]
        public bool DEPEnabled
        {
            get => _blnDEPEnabled;
            set
            {
                if(_blnDEPEnabled != value)
                {
                    _blnDEPEnabled = value;
                    if (IsLoading)
                    {
                        OnPropertyChanged();
                        return;
                    }
                    if (value)
                    {
                        // Career mode, so no extra calculations need to be done for EssenceAtSpecialStart
                        if(Created)
                        {
                            ResetCachedEssence();
                            EssenceAtSpecialStart = Essence();
                        }
                        // EssenceAtSpecialStart needs to be calculated by assuming that the character took the DEP-enabling quality with the highest essence penalty first, as that would be the most optimal
                        else
                        {
                            // If this character has any DEP-enabling bonuses that could be granted before all others (because they're priority and/or metatype-given),
                            // it has to be assumed those are taken first.
                            List<Improvement> lstAttributeImprovements = ImprovementManager
                                .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Attribute, "DEP");
                            bool blnCountOnlyPriorityOrMetatypeGivenBonuses = lstAttributeImprovements.Any(
                                x => x.ImproveSource
                                     == Improvement.ImprovementSource
                                                   .Metatype
                                     || x.ImproveSource
                                     == Improvement.ImprovementSource
                                                   .Metavariant
                                     || x.ImproveSource
                                     == Improvement.ImprovementSource
                                                   .Heritage);
                            if (!blnCountOnlyPriorityOrMetatypeGivenBonuses)
                            {
                                List<string> lstDEPEnablingQualityIds = lstAttributeImprovements
                                                                        .Where(x => x.ImproveSource
                                                                                   == Improvement.ImprovementSource
                                                                                       .Quality).Select(
                                                                            x => x.SourceName).ToList();
                                // Can't use foreach because new items can get added to this list while it is looping
                                for (int i = 0; i < lstDEPEnablingQualityIds.Count; ++i)
                                {
                                    Quality objQuality = Qualities.FirstOrDefault(x => x.InternalId == lstDEPEnablingQualityIds[i]);
                                    if (objQuality != null)
                                    {
                                        if (objQuality.OriginSource == QualitySource.Metatype
                                            || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                            || objQuality.OriginSource == QualitySource.BuiltIn
                                            || objQuality.OriginSource == QualitySource.LifeModule
                                            || objQuality.OriginSource == QualitySource.Heritage)
                                        {
                                            blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                            break;
                                        }

                                        if (objQuality.OriginSource == QualitySource.Improvement)
                                        {
                                            List<Improvement> lstSpecificQualityImprovements = ImprovementManager
                                                .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.SpecificQuality, objQuality.InternalId);
                                            if (lstSpecificQualityImprovements.Any(x =>
                                                    x.ImproveSource == Improvement.ImprovementSource.Metatype
                                                    || x.ImproveSource == Improvement.ImprovementSource.Metavariant
                                                    || x.ImproveSource == Improvement.ImprovementSource.Heritage))
                                            {
                                                blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                                break;
                                            }
                                            // Qualities that add other qualities get added to the list to be checked, too
                                            lstDEPEnablingQualityIds.AddRange(
                                                lstSpecificQualityImprovements
                                                    .Where(
                                                        x => x.ImproveSource == Improvement.ImprovementSource.Quality)
                                                    .Select(x => x.SourceName));
                                        }
                                    }
                                }
                            }
                            Dictionary<string, decimal> dicImprovementEssencePenalties =
                                new Dictionary<string, decimal>(Improvements.Count);
                            foreach (Improvement objImprovement in Improvements)
                            {
                                if (!objImprovement.Enabled)
                                    continue;
                                bool blnCountImprovement = !blnCountOnlyPriorityOrMetatypeGivenBonuses
                                                           || objImprovement.ImproveSource == Improvement.ImprovementSource.Metatype
                                                           || objImprovement.ImproveSource == Improvement.ImprovementSource.Metavariant
                                                           || objImprovement.ImproveSource == Improvement.ImprovementSource.Heritage;
                                if (!blnCountImprovement
                                    && objImprovement.ImproveSource == Improvement.ImprovementSource.Quality)
                                {
                                    Quality objQuality = Qualities.FirstOrDefault(x => x.InternalId == objImprovement.SourceName);
                                    while (objQuality != null)
                                    {
                                        if (objQuality.OriginSource == QualitySource.Metatype
                                            || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                            || objQuality.OriginSource == QualitySource.BuiltIn
                                            || objQuality.OriginSource == QualitySource.LifeModule
                                            || objQuality.OriginSource == QualitySource.Heritage)
                                        {
                                            blnCountImprovement = true;
                                            break;
                                        }

                                        if (objQuality.OriginSource == QualitySource.Improvement)
                                        {
                                            Improvement objParentImprovement = ImprovementManager
                                                                               .GetCachedImprovementListForValueOf(
                                                                                   this,
                                                                                   Improvement.ImprovementType
                                                                                       .SpecificQuality,
                                                                                   objQuality.InternalId)
                                                                               .FirstOrDefault();
                                            if (objParentImprovement == null)
                                                break;
                                            if (objParentImprovement.ImproveSource == Improvement.ImprovementSource.Metatype
                                                || objParentImprovement.ImproveSource == Improvement.ImprovementSource.Metavariant
                                                || objParentImprovement.ImproveSource == Improvement.ImprovementSource.Heritage)
                                            {
                                                blnCountImprovement = true;
                                                break;
                                            }
                                            if (objParentImprovement.ImproveSource == Improvement.ImprovementSource.Quality)
                                            {
                                                // Qualities that add other qualities get added to the list to be checked, too
                                                objQuality = Qualities.FirstOrDefault(x => x.InternalId == objParentImprovement.SourceName);
                                            }
                                            else
                                                break;
                                        }
                                        else
                                            break;
                                    }
                                }
                                if (blnCountImprovement)
                                {
                                    decimal decLoopEssencePenalty = 0;
                                    switch (objImprovement.ImproveType)
                                    {
                                        case Improvement.ImprovementType.EssencePenalty:
                                            decLoopEssencePenalty += objImprovement.Value;
                                            break;
                                        case Improvement.ImprovementType.EssencePenaltyT100:
                                            decLoopEssencePenalty += objImprovement.Value / 100.0m;
                                            break;
                                    }

                                    if(decLoopEssencePenalty != 0)
                                    {
                                        if(dicImprovementEssencePenalties.TryGetValue(objImprovement.SourceName, out decimal decExistingPenalty))
                                            dicImprovementEssencePenalties[objImprovement.SourceName] = decExistingPenalty + decLoopEssencePenalty;
                                        else
                                            dicImprovementEssencePenalties.Add(objImprovement.SourceName,
                                                decLoopEssencePenalty);
                                    }
                                }
                            }

                            if(dicImprovementEssencePenalties.Count > 0)
                                EssenceAtSpecialStart =
                                    ESS.MetatypeMaximum + dicImprovementEssencePenalties.Values.Min();
                            else
                                EssenceAtSpecialStart = ESS.MetatypeMaximum;
                        }
                    }
                    else if(!Created && !RESEnabled && !MAGEnabled)
                        EssenceAtSpecialStart = decimal.MinValue;

                    OnPropertyChanged();
                }
            }
        }

        [HubTag]
        public bool IsAI => DEPEnabled && BOD.MetatypeMaximum == 0;

        /// <summary>
        /// Submersion Grade.
        /// </summary>
        [HubTag]
        public int SubmersionGrade
        {
            get => _intSubmersionGrade;
            set
            {
                if (_intSubmersionGrade == value)
                    return;
                bool blnFirstSubmersion = _intSubmersionGrade == 0;
                _intSubmersionGrade = value;
                // Remove any existing Submersion Improvements.
                if (value == 0)
                {
                    ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Submersion);
                    // Update any Echo Improvements the character might have.
                    foreach (Metamagic objMetamagic in Metamagics.Where(x => x.SourceType == Improvement.ImprovementSource.Echo && x.Bonus?.InnerXml.Contains("Rating") == true))
                    {
                        ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Echo,
                            objMetamagic.InternalId);
                    }
                }
                else if (blnFirstSubmersion)
                {
                    // Create the new Improvement.
                    ImprovementManager.CreateImprovement(this, "RES", Improvement.ImprovementSource.Submersion,
                        string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, value, 0, 1);
                    ImprovementManager.Commit(this);
                    // Update any Echo Improvements the character might have.
                    foreach (Metamagic objMetamagic in Metamagics.Where(x => x.SourceType == Improvement.ImprovementSource.Echo && x.Bonus?.InnerXml.Contains("Rating") == true))
                    {
                        ImprovementManager.CreateImprovements(this, Improvement.ImprovementSource.Echo,
                            objMetamagic.InternalId, objMetamagic.Bonus, value,
                            objMetamagic.DisplayNameShort(GlobalSettings.Language));
                    }
                }
                else
                {
                    if (Improvements.All(x => x.ImproveSource != Improvement.ImprovementSource.Submersion))
                    {
                        // Create the new Improvement.
                        ImprovementManager.CreateImprovement(this, "RES", Improvement.ImprovementSource.Submersion,
                            string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, value, 0, 1);
                        ImprovementManager.Commit(this);
                    }
                    else
                    {
                        // ReSharper disable once ForCanBeConvertedToForeach
                        for (int i = 0; i < Improvements.Count; ++i)
                        {
                            Improvement objImprovement = Improvements[i];
                            if (objImprovement.ImproveSource == Improvement.ImprovementSource.Submersion)
                                objImprovement.Rating = value;
                        }
                    }

                    // Update any Echo Improvements the character might have.
                    foreach (Metamagic objMetamagic in Metamagics.Where(x => x.SourceType == Improvement.ImprovementSource.Echo && x.Bonus?.InnerXml.Contains("Rating") == true))
                    {
                        string strMetamagicId = objMetamagic.InternalId;
                        // If the Bonus contains "Rating", refresh ratings of existing Improvements.
                        if (Improvements.All(x =>
                            x.ImproveSource != Improvement.ImprovementSource.Echo ||
                            x.SourceName != strMetamagicId))
                        {
                            ImprovementManager.CreateImprovements(this, Improvement.ImprovementSource.Echo,
                                                                  strMetamagicId, objMetamagic.Bonus, value,
                                objMetamagic.DisplayNameShort(GlobalSettings.Language));
                        }
                        else
                        {
                            // ReSharper disable once ForCanBeConvertedToForeach
                            for (int i = 0; i < Improvements.Count; ++i)
                            {
                                Improvement objImprovement = Improvements[i];
                                if (objImprovement.SourceName == strMetamagicId &&
                                    objImprovement.ImproveSource == Improvement.ImprovementSource.Echo)
                                    objImprovement.Rating = value;
                            }
                        }
                    }
                }
                OnPropertyChanged();
            }
        }

        /// <summary>
        /// Whether or not the character is a member of a Group or Network.
        /// </summary>
        public bool GroupMember
        {
            get => _blnGroupMember;
            set
            {
                if(_blnGroupMember != value)
                {
                    _blnGroupMember = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// The name of the Group the Initiate has joined.
        /// </summary>
        [HubTag]
        public string GroupName
        {
            get => _strGroupName;
            set
            {
                if(_strGroupName != value)
                {
                    _strGroupName = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Notes for the Group the Initiate has joined.
        /// </summary>
        public string GroupNotes
        {
            get => _strGroupNotes;
            set
            {
                if(_strGroupNotes != value)
                {
                    _strGroupNotes = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Essence the character had when the first gained access to MAG/RES.
        /// </summary>
        public decimal EssenceAtSpecialStart
        {
            get => _decEssenceAtSpecialStart;
            set
            {
                if(_decEssenceAtSpecialStart != value)
                {
                    _decEssenceAtSpecialStart = value;
                    RefreshEssenceLossImprovements();
                }
            }
        }

        private decimal _decCachedEssence = decimal.MinValue;

        public void ResetCachedEssence()
        {
            _decCachedEssence = decimal.MinValue;
        }

        /// <summary>
        /// Character's Essence.
        /// </summary>
        /// <param name="blnForMAGPenalty">Whether fetched Essence is to be used to calculate the penalty MAG should receive from lost Essence (true) or not (false).</param>
        public decimal Essence(bool blnForMAGPenalty = false)
        {
            if(!blnForMAGPenalty && _decCachedEssence != decimal.MinValue)
                return _decCachedEssence;
            // If the character has a fixed Essence Improvement, permanently fix their Essence at its value.
            if(ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.CyborgEssence).Count > 0)
            {
                if(blnForMAGPenalty)
                    return 0.1m;
                return _decCachedEssence = 0.1m;
            }

            decimal decESS = ESS.MetatypeMaximum;
            decESS += ImprovementManager.ValueOf(this, Improvement.ImprovementType.EssencePenalty);
            decESS += ImprovementManager.ValueOf(this, Improvement.ImprovementType.EssencePenaltyT100) / 100.0m;
            if(blnForMAGPenalty)
                decESS += ImprovementManager.ValueOf(this, Improvement.ImprovementType.EssencePenaltyMAGOnlyT100) / 100.0m;

            // Run through all of the pieces of Cyberware and include their Essence cost.
            decESS -= Cyberware.Sum(objCyberware => objCyberware.CalculatedESS);

            //1781 Essence is not printing
            //ESS.Base = Convert.ToInt32(decESS); -- Disabled because this messes up Character Validity, and it really shouldn't be what "Base" of an attribute is supposed to be (it's supposed to be extra levels gained)

            if(blnForMAGPenalty)
                return decESS;
            return _decCachedEssence = decESS;
        }

        private decimal _decCachedCyberwareEssence = decimal.MinValue;

        /// <summary>
        /// Essence consumed by Cyberware.
        /// </summary>
        public decimal CyberwareEssence
        {
            get
            {
                if(_decCachedCyberwareEssence != decimal.MinValue)
                    return _decCachedCyberwareEssence;
                // Run through all of the pieces of Cyberware and include their Essence cost. Cyberware and Bioware costs are calculated separately.
                return _decCachedCyberwareEssence = Cyberware
                    .Where(objCyberware => objCyberware.SourceType == Improvement.ImprovementSource.Cyberware
                                           && !objCyberware.SourceID.Equals(Backend.Equipment.Cyberware.EssenceHoleGUID)
                                           && !objCyberware.SourceID.Equals(Backend.Equipment.Cyberware.EssenceAntiHoleGUID))
                    .Sum(objCyberware => objCyberware.CalculatedESS);
            }
        }

        private decimal _decCachedBiowareEssence = decimal.MinValue;

        /// <summary>
        /// Essence consumed by Bioware.
        /// </summary>
        public decimal BiowareEssence
        {
            get
            {
                if(_decCachedBiowareEssence != decimal.MinValue)
                    return _decCachedBiowareEssence;
                // Run through all of the pieces of Cyberware and include their Essence cost. Cyberware and Bioware costs are calculated separately.
                return _decCachedBiowareEssence = Cyberware
                    .Where(objCyberware => objCyberware.SourceType == Improvement.ImprovementSource.Bioware
                                           && !objCyberware.SourceID.Equals(Backend.Equipment.Cyberware.EssenceHoleGUID)
                                           && !objCyberware.SourceID.Equals(Backend.Equipment.Cyberware.EssenceAntiHoleGUID))
                    .Sum(objCyberware => objCyberware.CalculatedESS);
            }
        }

        private decimal _decCachedEssenceHole = decimal.MinValue;

        /// <summary>
        /// Essence consumed by Essence Holes.
        /// </summary>
        public decimal EssenceHole
        {
            get
            {
                if(_decCachedEssenceHole != decimal.MinValue)
                    return _decCachedEssenceHole;
                // Find the total Essence Cost of all Essence Hole objects.
                return _decCachedEssenceHole = Cyberware
                    .Where(objCyberware => objCyberware.SourceID.Equals(Backend.Equipment.Cyberware.EssenceHoleGUID)
                                           || objCyberware.SourceID.Equals(Backend.Equipment.Cyberware.EssenceAntiHoleGUID))
                    .Sum(objCyberware => objCyberware.CalculatedESS);
            }
        }

        public void IncreaseEssenceHole(decimal decEssence, bool blnOverflowIntoHole = true)
        {
            IncreaseEssenceHole((decEssence * 100).StandardRound(), blnOverflowIntoHole);
        }

        public void IncreaseEssenceHole(int intCentiessence, bool blnOverflowIntoHole = true)
        {
            Cyberware objAntiHole = Cyberware.FirstOrDefault(x => x.SourceID == Backend.Equipment.Cyberware.EssenceAntiHoleGUID);
            if(objAntiHole != null)
            {
                if(objAntiHole.Rating > intCentiessence)
                {
                    objAntiHole.Rating -= intCentiessence;
                    return;
                }

                intCentiessence -= objAntiHole.Rating;
                objAntiHole.DeleteCyberware();
            }

            if(blnOverflowIntoHole)
            {
                Cyberware objHole = Cyberware.FirstOrDefault(x => x.SourceID == Backend.Equipment.Cyberware.EssenceHoleGUID);
                if(objHole == null)
                {
                    XmlNode xmlEssHole = LoadData("cyberware.xml").SelectSingleNode("/chummer/cyberwares/cyberware[id = " + Backend.Equipment.Cyberware.EssenceHoleGUID.ToString("D", GlobalSettings.InvariantCultureInfo).CleanXPath() + ']');
                    objHole = new Cyberware(this);
                    List<Weapon> lstWeapons = new List<Weapon>(1);
                    List<Vehicle> lstVehicles = new List<Vehicle>(1);
                    objHole.Create(xmlEssHole, GetGradeList(Improvement.ImprovementSource.Cyberware, true).FirstOrDefault(x => x.Name == "None"), Improvement.ImprovementSource.Cyberware, intCentiessence, lstWeapons,
                        lstVehicles);

                    Cyberware.Add(objHole);

                    foreach(Weapon objWeapon in lstWeapons)
                    {
                        Weapons.Add(objWeapon);
                    }

                    foreach(Vehicle objVehicle in lstVehicles)
                    {
                        Vehicles.Add(objVehicle);
                    }
                }
                else
                {
                    objHole.Rating += intCentiessence;
                }

                if(objHole.Rating == 0 && Cyberware.Contains(objHole))
                    Cyberware.Remove(objHole);
            }

            if(objAntiHole?.Rating == 0 && Cyberware.Contains(objAntiHole))
                Cyberware.Remove(objAntiHole);
        }

        public void DecreaseEssenceHole(decimal decEssence, bool blnOverflowIntoHole = true)
        {
            DecreaseEssenceHole((decEssence * 100).StandardRound(), blnOverflowIntoHole);
        }

        /// <summary>
        /// Decrease or create an Essence Hole, if required.
        /// </summary>
        /// <param name="intCentiessence">Hundredths of Essence to push into a new Essence Hole or Antihole.</param>
        /// <param name="blnOverflowIntoAntiHole">Should we increase or create an Essence Antihole to handle any overflow. Remember, Essence Holes are consumed first.</param>
        public void DecreaseEssenceHole(int intCentiessence, bool blnOverflowIntoAntiHole = true)
        {
            Cyberware objHole = Cyberware.FirstOrDefault(x => x.SourceID == Backend.Equipment.Cyberware.EssenceHoleGUID);

            if(objHole != null)
            {
                if(objHole.Rating > intCentiessence)
                {
                    objHole.Rating -= intCentiessence;
                    return;
                }

                intCentiessence -= objHole.Rating;
                objHole.DeleteCyberware();
            }

            if(blnOverflowIntoAntiHole && intCentiessence != 0)
            {
                Cyberware objAntiHole = Cyberware.FirstOrDefault(x => x.SourceID == Backend.Equipment.Cyberware.EssenceAntiHoleGUID);
                if(objAntiHole == null)
                {
                    XmlNode xmlEssAntiHole = LoadData("cyberware.xml").SelectSingleNode("/chummer/cyberwares/cyberware[id = " + Backend.Equipment.Cyberware.EssenceAntiHoleGUID.ToString("D", GlobalSettings.InvariantCultureInfo).CleanXPath() + ']');
                    objAntiHole = new Cyberware(this);
                    List<Weapon> lstWeapons = new List<Weapon>(1);
                    List<Vehicle> lstVehicles = new List<Vehicle>(1);
                    objAntiHole.Create(xmlEssAntiHole, GetGradeList(Improvement.ImprovementSource.Cyberware, true).FirstOrDefault(x => x.Name == "None"), Improvement.ImprovementSource.Cyberware, intCentiessence, lstWeapons, lstVehicles);

                    Cyberware.Add(objAntiHole);

                    foreach(Weapon objWeapon in lstWeapons)
                    {
                        Weapons.Add(objWeapon);
                    }
                    foreach(Vehicle objVehicle in lstVehicles)
                    {
                        Vehicles.Add(objVehicle);
                    }
                }
                else
                {
                    objAntiHole.Rating += intCentiessence;
                }

                if(objAntiHole.Rating == 0 && Cyberware.Contains(objAntiHole))
                    Cyberware.Remove(objAntiHole);
            }

            if(objHole?.Rating == 0 && Cyberware.Contains(objHole))
                Cyberware.Remove(objHole);
        }

        private decimal _decCachedPrototypeTranshumanEssenceUsed = decimal.MinValue;

        /// <summary>
        /// Essence consumed by Prototype Transhuman 'ware
        /// </summary>
        public decimal PrototypeTranshumanEssenceUsed
        {
            get
            {
                if(_decCachedPrototypeTranshumanEssenceUsed != decimal.MinValue)
                    return _decCachedPrototypeTranshumanEssenceUsed;
                // Find the total Essence Cost of all Prototype Transhuman 'ware.
                if (!IsPrototypeTranshuman)
                    return _decCachedPrototypeTranshumanEssenceUsed = 0.0m;
                return _decCachedPrototypeTranshumanEssenceUsed = Cyberware
                    .Where(objCyberware => objCyberware.PrototypeTranshuman)
                    .Sum(objCyberware => objCyberware.CalculatedESSPrototypeInvariant);
            }
        }

        public string DisplayEssence => Essence().ToString(Settings.EssenceFormat, GlobalSettings.CultureInfo);

        /// <summary>
        /// This is only here for Reflection
        /// </summary>
        [HubTag("Essence")]
        public decimal EssenceDecimal => Essence();

        public string DisplayCyberwareEssence =>
            CyberwareEssence.ToString(Settings.EssenceFormat, GlobalSettings.CultureInfo);

        public string DisplayBiowareEssence =>
            BiowareEssence.ToString(Settings.EssenceFormat, GlobalSettings.CultureInfo);

        public string DisplayEssenceHole => EssenceHole.ToString(Settings.EssenceFormat, GlobalSettings.CultureInfo);

        public string DisplayPrototypeTranshumanEssenceUsed =>
            PrototypeTranshumanEssenceUsed.ToString(Settings.EssenceFormat, GlobalSettings.CultureInfo) + " / " +
            PrototypeTranshuman.ToString(Settings.EssenceFormat, GlobalSettings.CultureInfo);

        #region Initiative

        #region Physical

        /// <summary>
        /// Physical Initiative.
        /// </summary>
        public string Initiative => GetInitiative(GlobalSettings.CultureInfo, GlobalSettings.Language);

        public string GetInitiative(CultureInfo objCulture, string strLanguage)
        {
            return string.Format(objCulture, LanguageManager.GetString("String_Initiative", strLanguage),
                InitiativeValue.ToString(objCulture),
                InitiativeDice.ToString(objCulture));
        }

        public string InitiativeToolTip
        {
            get
            {
                int intINTAttributeModifiers = INT.AttributeModifiers;
                int intREAAttributeModifiers = REA.AttributeModifiers;
                string strSpace = LanguageManager.GetString("String_Space");

                string strInit = REA.DisplayAbbrev + strSpace + '(' + REA.Value.ToString(GlobalSettings.CultureInfo) + ')'
                                 + strSpace + '+' + strSpace + INT.DisplayAbbrev + strSpace + '(' + INT.Value.ToString(GlobalSettings.CultureInfo) + ')';
                if(ImprovementManager.ValueOf(this, Improvement.ImprovementType.Initiative) != 0 || intINTAttributeModifiers != 0 || intREAAttributeModifiers != 0 || WoundModifier != 0)
                {
                    strInit += strSpace + '+' + strSpace + LanguageManager.GetString("Tip_Modifiers") + strSpace + '('
                               + (ImprovementManager.ValueOf(this, Improvement.ImprovementType.Initiative) + intINTAttributeModifiers + intREAAttributeModifiers + WoundModifier).ToString(GlobalSettings.CultureInfo) + ')';
                }

                return string.Format(GlobalSettings.CultureInfo, LanguageManager.GetString("String_Initiative"), strInit, InitiativeDice.ToString(GlobalSettings.CultureInfo));
            }
        }

        /// <summary>
        /// Initiative Dice.
        /// </summary>
        [HubTag]
        public int InitiativeDice
        {
            get
            {
                int intExtraIP = _intInitiativeDice
                                 + ImprovementManager.ValueOf(this, Improvement.ImprovementType.InitiativeDice).StandardRound()
                                 + ImprovementManager.ValueOf(this, Improvement.ImprovementType.InitiativeDiceAdd).StandardRound();

                return Math.Min(intExtraIP, Settings.MaxInitiativeDice);
            }
        }

        [HubTag]
        public int InitiativeValue
        {
            get
            {
                if ((INT == null) || (REA == null))
                {
                    Utils.BreakIfDebug();
                    return 0;
                }

                int intINI = INT.TotalValue + REA.TotalValue + WoundModifier;
                intINI += ImprovementManager.ValueOf(this, Improvement.ImprovementType.Initiative).StandardRound();
                if(intINI < 0)
                    intINI = 0;
                return intINI;
            }
        }

        #endregion

        #region Astral

        /// <summary>
        /// Astral Initiative.
        /// </summary>
        public string AstralInitiative => GetAstralInitiative(GlobalSettings.CultureInfo, GlobalSettings.Language);

        public string GetAstralInitiative(CultureInfo objCulture, string strLanguageToPrint)
        {
            return string.Format(objCulture, LanguageManager.GetString("String_Initiative", strLanguageToPrint),
                AstralInitiativeValue.ToString(objCulture),
                AstralInitiativeDice.ToString(objCulture));
        }

        public string AstralInitiativeToolTip
        {
            get
            {
                if(!MAGEnabled)
                    return string.Empty;
                int intINTAttributeModifiers = INT.AttributeModifiers;
                string strSpace = LanguageManager.GetString("String_Space");
                string strInit = INT.DisplayAbbrev + strSpace + '(' + INT.Value.ToString(GlobalSettings.CultureInfo) + ')' + strSpace + '' + strSpace + 2.ToString(GlobalSettings.CultureInfo);
                if(intINTAttributeModifiers != 0 || WoundModifier != 0)
                    strInit += LanguageManager.GetString("Tip_Modifiers") + strSpace + '(' + (intINTAttributeModifiers + WoundModifier).ToString(GlobalSettings.CultureInfo) + ')';
                return string.Format(GlobalSettings.CultureInfo, LanguageManager.GetString("String_Initiative"),
                    strInit, AstralInitiativeDice.ToString(GlobalSettings.CultureInfo));
            }
        }

        /// <summary>
        /// Astral Initiative Value.
        /// </summary>
        public int AstralInitiativeValue => (INT.TotalValue * 2) + WoundModifier;

        /// <summary>
        /// Astral Initiative Dice.
        /// </summary>
        public int AstralInitiativeDice
        {
            get
            {
                int intReturn = Settings.MinAstralInitiativeDice;
                return Math.Min(intReturn, Settings.MaxAstralInitiativeDice);
            }
        }

        #endregion

        #region Matrix

        #region AR

        /// <summary>
        /// Formatted AR Matrix Initiative.
        /// </summary>
        public string MatrixInitiative => GetMatrixInitiative(GlobalSettings.CultureInfo, GlobalSettings.Language);

        public string GetMatrixInitiative(CultureInfo objCulture, string strLanguageToPrint)
        {
            return string.Format(objCulture, LanguageManager.GetString("String_Initiative", strLanguageToPrint),
                MatrixInitiativeValue, MatrixInitiativeDice);
        }

        public string MatrixInitiativeToolTip
        {
            get
            {
                int intINTAttributeModifiers = INT.AttributeModifiers;

                string strSpace = LanguageManager.GetString("String_Space");

                string strInit;
                if(IsAI)
                {
                    strInit = INT.DisplayAbbrev + strSpace + '(' + INT.Value.ToString(GlobalSettings.CultureInfo) + ')';

                    if(HomeNode != null)
                    {
                        int intHomeNodeDP = HomeNode.GetTotalMatrixAttribute("Data Processing");
                        if(HomeNode is Vehicle objHomeNodeVehicle)
                        {
                            int intHomeNodePilot = objHomeNodeVehicle.Pilot;
                            if(intHomeNodePilot > intHomeNodeDP)
                                intHomeNodeDP = intHomeNodePilot;
                        }

                        strInit += strSpace + '+' + strSpace + LanguageManager.GetString("String_DataProcessing") +
                                   strSpace + '(' + intHomeNodeDP.ToString(GlobalSettings.CultureInfo) + ')';
                    }

                    if(intINTAttributeModifiers != 0 || WoundModifier != 0)
                    {
                        strInit += strSpace + '+' + strSpace + LanguageManager.GetString("Tip_Modifiers") + strSpace +
                                   '(' +
                                   (intINTAttributeModifiers + WoundModifier).ToString(GlobalSettings.CultureInfo) + ')';
                    }
                }
                else
                {
                    int intREAAttributeModifiers = REA.AttributeModifiers;

                    strInit = REA.DisplayAbbrev + strSpace + '(' + REA.Value.ToString(GlobalSettings.CultureInfo) + ')' +
                              strSpace + '+' + strSpace + INT.DisplayAbbrev + strSpace + '(' +
                              INT.Value.ToString(GlobalSettings.CultureInfo) + ')';
                    if(ImprovementManager.ValueOf(this, Improvement.ImprovementType.Initiative) != 0 || intINTAttributeModifiers != 0 || intREAAttributeModifiers != 0 || WoundModifier != 0)
                    {
                        strInit += strSpace + '+' + strSpace + LanguageManager.GetString("Tip_Modifiers") + strSpace +
                                   '(' + (ImprovementManager.ValueOf(this, Improvement.ImprovementType.Initiative) +
                                          intINTAttributeModifiers + intREAAttributeModifiers + WoundModifier)
                                   .ToString(GlobalSettings.CultureInfo) + ')';
                    }
                }

                return string.Format(GlobalSettings.CultureInfo, LanguageManager.GetString("String_Initiative"),
                    strInit, MatrixInitiativeDice);
            }
        }

        /// <summary>
        /// AR Matrix Initiative Value.
        /// </summary>
        public int MatrixInitiativeValue
        {
            get
            {
                if(IsAI)
                {
                    int intINI = (INT.TotalValue) + WoundModifier;
                    if(HomeNode != null)
                    {
                        int intHomeNodeDP = HomeNode.GetTotalMatrixAttribute("Data Processing");
                        if(HomeNode is Vehicle objHomeNodeVehicle)
                        {
                            int intHomeNodePilot = objHomeNodeVehicle.Pilot;
                            if(intHomeNodePilot > intHomeNodeDP)
                                intHomeNodeDP = intHomeNodePilot;
                        }

                        intINI += intHomeNodeDP;
                    }

                    return intINI;
                }

                return InitiativeValue;
            }
        }

        /// <summary>
        /// AR Matrix Initiative Dice.
        /// </summary>
        public int MatrixInitiativeDice
        {
            get
            {
                int intReturn;
                // A.I.s always have 4 Matrix Initiative Dice.
                if(IsAI)
                    intReturn = Settings.MinHotSimInitiativeDice + ImprovementManager.ValueOf(this, Improvement.ImprovementType.MatrixInitiativeDice).StandardRound();
                else
                    intReturn = InitiativeDice;

                // Add in any additional Matrix Initiative Pass bonuses.
                intReturn += ImprovementManager.ValueOf(this, Improvement.ImprovementType.MatrixInitiativeDiceAdd).StandardRound();

                return Math.Min(intReturn, Settings.MaxInitiativeDice);
            }
        }

        #endregion

        #region Cold Sim

        /// <summary>
        /// Matrix Initiative via VR with Cold Sim.
        /// </summary>
        public string MatrixInitiativeCold => GetMatrixInitiativeCold(GlobalSettings.CultureInfo, GlobalSettings.Language);

        public string GetMatrixInitiativeCold(CultureInfo objCulture, string strLanguageToPrint)
        {
            if(IsAI)
            {
                return GetMatrixInitiative(objCulture, strLanguageToPrint);
            }

            return string.Format(objCulture, LanguageManager.GetString(ActiveCommlink == null ? "String_MatrixInitiative" : "String_Initiative", strLanguageToPrint),
                MatrixInitiativeColdValue, MatrixInitiativeColdDice);
        }

        public string MatrixInitiativeColdToolTip
        {
            get
            {
                if(IsAI)
                {
                    return MatrixInitiativeToolTip;
                }

                int intINTAttributeModifiers = INT.AttributeModifiers;

                string strSpace = LanguageManager.GetString("String_Space");

                string strInit = INT.DisplayAbbrev + strSpace + '(' + INT.Value.ToString(GlobalSettings.CultureInfo) + ')';
                if(ActiveCommlink != null)
                {
                    strInit += strSpace + '+' + strSpace + LanguageManager.GetString("String_DataProcessing") +
                               strSpace + '(' + ActiveCommlink.GetTotalMatrixAttribute("Data Processing")
                                   .ToString(GlobalSettings.CultureInfo) + ')';
                }

                if(ImprovementManager.ValueOf(this, Improvement.ImprovementType.MatrixInitiative) != 0 || intINTAttributeModifiers != 0 || WoundModifier != 0)
                {
                    strInit += strSpace + '+' + strSpace + LanguageManager.GetString("Tip_Modifiers") + strSpace + '(' +
                               (ImprovementManager.ValueOf(this, Improvement.ImprovementType.MatrixInitiative) +
                                intINTAttributeModifiers + WoundModifier).ToString(GlobalSettings.CultureInfo) + ')';
                }

                return string.Format(GlobalSettings.CultureInfo, LanguageManager.GetString(ActiveCommlink == null ? "String_MatrixInitiativeLong" : "String_Initiative"),
                    strInit, MatrixInitiativeColdDice);
            }
        }

        /// <summary>
        /// Cold Sim Matrix Initiative Value.
        /// </summary>
        public int MatrixInitiativeColdValue
        {
            get
            {
                if(IsAI)
                {
                    return MatrixInitiativeValue;
                }

                int intCommlinkDP = ActiveCommlink?.GetTotalMatrixAttribute("Data Processing") ?? 0;
                return INT.TotalValue + intCommlinkDP + WoundModifier +
                       ImprovementManager.ValueOf(this, Improvement.ImprovementType.MatrixInitiative).StandardRound();
            }
        }

        /// <summary>
        /// Cold Sim Matrix Initiative Dice.
        /// </summary>
        public int MatrixInitiativeColdDice
        {
            get
            {
                if(IsAI)
                {
                    return MatrixInitiativeDice;
                }

                return Math.Min(Settings.MinColdSimInitiativeDice + ImprovementManager.ValueOf(this, Improvement.ImprovementType.MatrixInitiativeDice).StandardRound(),
                                Settings.MaxColdSimInitiativeDice);
            }
        }

        #endregion

        #region Hot Sim

        /// <summary>
        /// Matrix Initiative via VR with Hot Sim.
        /// </summary>
        public string MatrixInitiativeHot => GetMatrixInitiativeHot(GlobalSettings.CultureInfo, GlobalSettings.Language);

        public string GetMatrixInitiativeHot(CultureInfo objCulture, string strLanguageToPrint)
        {
            if(IsAI)
            {
                return GetMatrixInitiative(objCulture, strLanguageToPrint);
            }

            return string.Format(objCulture, LanguageManager.GetString(ActiveCommlink == null ? "String_MatrixInitiative" : "String_Initiative", strLanguageToPrint),
                MatrixInitiativeHotValue, MatrixInitiativeHotDice);
        }

        public string MatrixInitiativeHotToolTip
        {
            get
            {
                if(IsAI)
                {
                    return MatrixInitiativeToolTip;
                }

                int intINTAttributeModifiers = INT.AttributeModifiers;

                string strSpace = LanguageManager.GetString("String_Space");

                string strInit = INT.DisplayAbbrev + strSpace + '(' + INT.Value.ToString(GlobalSettings.CultureInfo) + ')';
                if(ActiveCommlink != null)
                {
                    strInit += strSpace + '+' + strSpace + LanguageManager.GetString("String_DataProcessing") +
                               strSpace + '(' + ActiveCommlink.GetTotalMatrixAttribute("Data Processing")
                                   .ToString(GlobalSettings.CultureInfo) + ')';
                }

                if(ImprovementManager.ValueOf(this, Improvement.ImprovementType.MatrixInitiative) != 0 || intINTAttributeModifiers != 0 || WoundModifier != 0)
                {
                    strInit += strSpace + '+' + strSpace + LanguageManager.GetString("Tip_Modifiers") + strSpace + '(' +
                               (ImprovementManager.ValueOf(this, Improvement.ImprovementType.MatrixInitiative) +
                                intINTAttributeModifiers + WoundModifier).ToString(GlobalSettings.CultureInfo) + ')';
                }

                return string.Format(GlobalSettings.CultureInfo, LanguageManager.GetString(ActiveCommlink == null ? "String_MatrixInitiativeLong" : "String_Initiative"),
                    strInit, MatrixInitiativeHotDice);
            }
        }

        /// <summary>
        /// Hot Sim Matrix Initiative Value.
        /// </summary>
        public int MatrixInitiativeHotValue
        {
            get
            {
                if(IsAI)
                {
                    return MatrixInitiativeValue;
                }

                int intCommlinkDP = ActiveCommlink?.GetTotalMatrixAttribute("Data Processing") ?? 0;
                return INT.TotalValue + intCommlinkDP + WoundModifier +
                       ImprovementManager.ValueOf(this, Improvement.ImprovementType.MatrixInitiative).StandardRound();
            }
        }

        /// <summary>
        /// Hot Sim Matrix Initiative Dice.
        /// </summary>
        public int MatrixInitiativeHotDice
        {
            get
            {
                if(IsAI)
                {
                    return MatrixInitiativeDice;
                }

                return Math.Min(Settings.MinHotSimInitiativeDice + ImprovementManager.ValueOf(this, Improvement.ImprovementType.MatrixInitiativeDice).StandardRound(),
                                Settings.MaxHotSimInitiativeDice);
            }
        }

        #endregion

        #region XPath Processing
        /// <summary>
        /// Replaces substring in the form of {Skill} with the total dicepool of the skill.
        /// </summary>
        /// <param name="strInput">Stringbuilder object that contains the input.</param>
        /// <param name="dicValueOverrides">Alternative dictionary to use for value lookup instead of SkillsSection.GetActiveSkill.</param>
        public string ProcessMatrixAttributesInXPath(string strInput, IReadOnlyDictionary<string, int> dicValueOverrides = null)
        {
            if (string.IsNullOrEmpty(strInput))
                return strInput;
            string strReturn = strInput;
            foreach (string strAttributeName in MatrixAttributes.MatrixAttributeStrings)
            {
                strReturn = strReturn
                    .CheapReplace('{' + strAttributeName + '}', () => dicValueOverrides?.ContainsKey(strAttributeName) == true
                        ? dicValueOverrides[strAttributeName].ToString()
                        : ActiveCommlink?.GetTotalMatrixAttribute(strAttributeName).ToString());
            }
            return strReturn;
        }

        /// <summary>
        /// Replaces stringbuilder content in the form of {MatrixAttribute} with the total pool of the Matrix Attribute of the Active Commlink, if any.
        /// </summary>
        /// <param name="sbdInput">Stringbuilder object that contains the input.</param>
        /// <param name="dicValueOverrides">Alternative dictionary to use for value lookup instead of SkillsSection.GetActiveSkill.</param>
        public void ProcessMatrixAttributesInXPath(StringBuilder sbdInput, IReadOnlyDictionary<string, int> dicValueOverrides = null)
        {
            if (sbdInput == null || sbdInput.Length <= 0)
                return;
            foreach (string strAttributeName in MatrixAttributes.MatrixAttributeStrings)
            {
                sbdInput.CheapReplace('{' + strAttributeName + '}', () => dicValueOverrides?.ContainsKey(strAttributeName) == true
                    ? dicValueOverrides[strAttributeName].ToString()
                    : ActiveCommlink?.GetTotalMatrixAttribute(strAttributeName).ToString());
            }
        }
        #endregion
        #endregion

        #endregion

        /// <summary>
        /// Character's total Spell Resistance from qualities and metatype properties.
        /// </summary>
        public int SpellResistance => ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance).StandardRound();

        #endregion

        #region Special CharacterAttribute Tests

        /// <summary>
        /// Composure (WIL + CHA).
        /// </summary>
        public int Composure => WIL.TotalValue + CHA.TotalValue +
                                ImprovementManager.ValueOf(this, Improvement.ImprovementType.Composure).StandardRound()
                                + WoundModifier
                                + SustainingPenalty;

        public string ComposureToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(CHA.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(CHA.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(LanguageManager.GetString("Tip_Skill_Wounds"))
                              .Append(strSpace).Append('(').Append(WoundModifier.ToString(GlobalSettings.CultureInfo))
                              .Append(')').Append(strSpace).Append('+').Append(strSpace)
                              .Append(LanguageManager.GetString("Tip_Skill_Sustain")).Append(strSpace).Append('(')
                              .Append(SustainingPenalty.ToString(GlobalSettings.CultureInfo)).Append(')');
                    foreach (Improvement objLoopImprovement in ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Composure))
                    {
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                  .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        /// <summary>
        /// Judge Intentions (INT + CHA).
        /// </summary>
        public int JudgeIntentions => INT.TotalValue + CHA.TotalValue +
                                      (ImprovementManager.ValueOf(this, Improvement.ImprovementType.JudgeIntentions)
                                       + ImprovementManager.ValueOf(this, Improvement.ImprovementType.JudgeIntentionsOffense)).StandardRound()
                                       + SustainingPenalty
                                       + WoundModifier;

        public string JudgeIntentionsToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(CHA.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(CHA.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(INT.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(INT.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(LanguageManager.GetString("Tip_Skill_Wounds"))
                              .Append(strSpace).Append('(').Append(WoundModifier.ToString(GlobalSettings.CultureInfo))
                              .Append(')').Append(strSpace).Append('+').Append(strSpace)
                              .Append(LanguageManager.GetString("Tip_Skill_Sustain")).Append(strSpace).Append('(')
                              .Append(SustainingPenalty.ToString(GlobalSettings.CultureInfo)).Append(')');
                    foreach (Improvement objLoopImprovement in ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.JudgeIntentions))
                    {
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                  .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');
                    }
                    foreach (Improvement objLoopImprovement in ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.JudgeIntentionsOffense))
                    {
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                  .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        /// <summary>
        /// Judge Intentions Resist (CHA + WIL).
        /// </summary>
        public int JudgeIntentionsResist => CHA.TotalValue + WIL.TotalValue +
                                            (ImprovementManager.ValueOf(this, Improvement.ImprovementType.JudgeIntentions)
                                             + ImprovementManager.ValueOf(this, Improvement.ImprovementType.JudgeIntentionsDefense)).StandardRound();

        public string JudgeIntentionsResistToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(CHA.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(CHA.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');
                    foreach (Improvement objLoopImprovement in ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.JudgeIntentions))
                    {
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                  .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');
                    }
                    foreach (Improvement objLoopImprovement in ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.JudgeIntentionsDefense))
                    {
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                  .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        /// <summary>
        /// Lifting and Carrying (STR + BOD).
        /// </summary>
        public int LiftAndCarry => STR.TotalValue + BOD.TotalValue +
                                   ImprovementManager.ValueOf(this, Improvement.ImprovementType.LiftAndCarry).StandardRound()
                                   + WoundModifier
                                   + SustainingPenalty;

        public string LiftAndCarryToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(BOD.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(BOD.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(STR.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(STR.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(LanguageManager.GetString("Tip_Skill_Wounds"))
                              .Append(strSpace).Append('(').Append(WoundModifier.ToString(GlobalSettings.CultureInfo))
                              .Append(')').Append(strSpace).Append('+').Append(strSpace)
                              .Append(LanguageManager.GetString("Tip_Skill_Sustain")).Append(strSpace).Append('(')
                              .Append(SustainingPenalty.ToString(GlobalSettings.CultureInfo)).Append(')');
                    foreach (Improvement objLoopImprovement in ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.LiftAndCarry))
                    {
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                  .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');
                    }

                    sbdToolTip.AppendLine().AppendFormat(GlobalSettings.CultureInfo,
                                                         LanguageManager.GetString("Tip_LiftAndCarry"),
                                                         (STR.TotalValue * 15).ToString(GlobalSettings.CultureInfo),
                                                         (STR.TotalValue * 10).ToString(GlobalSettings.CultureInfo));
                    return sbdToolTip.ToString();
                }
            }
        }

        /// <summary>
        /// Memory (LOG + WIL).
        /// </summary>
        public int Memory => LOG.TotalValue + WIL.TotalValue +
                             ImprovementManager.ValueOf(this, Improvement.ImprovementType.Memory).StandardRound()
                             + WoundModifier
                             + SustainingPenalty;

        public string MemoryToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(LOG.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(LOG.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(LanguageManager.GetString("Tip_Skill_Wounds"))
                              .Append(strSpace).Append('(').Append(WoundModifier.ToString(GlobalSettings.CultureInfo))
                              .Append(')').Append(strSpace).Append('+').Append(strSpace)
                              .Append(LanguageManager.GetString("Tip_Skill_Sustain")).Append(strSpace).Append('(')
                              .Append(SustainingPenalty.ToString(GlobalSettings.CultureInfo)).Append(')');
                    foreach (Improvement objLoopImprovement in ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Memory))
                    {
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                  .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        /// <summary>
        /// Resist test to Fatigue damage (BOD + WIL).
        /// </summary>
        public int FatigueResist => BOD.TotalValue + WIL.TotalValue +
                                    ImprovementManager.ValueOf(this, Improvement.ImprovementType.FatigueResist).StandardRound();

        /// <summary>
        /// Resist test to Radiation damage (BOD + WIL).
        /// </summary>
        public int RadiationResist => BOD.TotalValue + WIL.TotalValue +
                                      ImprovementManager.ValueOf(this, Improvement.ImprovementType.RadiationResist).StandardRound();

        /// <summary>
        /// Resist test to Sonic Attacks damage (WIL).
        /// </summary>
        public int SonicResist =>
            WIL.TotalValue + ImprovementManager.ValueOf(this, Improvement.ImprovementType.SonicResist).StandardRound();

        /// <summary>
        /// Resist test to Contact-vector Toxins (BOD + WIL).
        /// </summary>
        public string ToxinContactResist(string strLanguage, CultureInfo objCulture)
        {
            if (IsAI || ImprovementManager
                        .GetCachedImprovementListForValueOf(
                            this, Improvement.ImprovementType.ToxinContactImmune).Count > 0)
                return LanguageManager.GetString("String_Immune", strLanguage);
            return (BOD.TotalValue + WIL.TotalValue +
                    ImprovementManager.ValueOf(this, Improvement.ImprovementType.ToxinContactResist).StandardRound())
                .ToString(objCulture);
        }

        /// <summary>
        /// Resist test to Ingestion-vector Toxins (BOD + WIL).
        /// </summary>
        public string ToxinIngestionResist(string strLanguage, CultureInfo objCulture)
        {
            if (IsAI || ImprovementManager
                        .GetCachedImprovementListForValueOf(
                            this, Improvement.ImprovementType.ToxinIngestionImmune).Count > 0)
                return LanguageManager.GetString("String_Immune", strLanguage);
            return (BOD.TotalValue + WIL.TotalValue +
                    ImprovementManager.ValueOf(this, Improvement.ImprovementType.ToxinIngestionResist).StandardRound())
                .ToString(objCulture);
        }

        /// <summary>
        /// Resist test to Inhalation-vector Toxins (BOD + WIL).
        /// </summary>
        public string ToxinInhalationResist(string strLanguage, CultureInfo objCulture)
        {
            if (IsAI || ImprovementManager
                        .GetCachedImprovementListForValueOf(
                            this, Improvement.ImprovementType.ToxinInhalationImmune).Count > 0)
                return LanguageManager.GetString("String_Immune", strLanguage);
            return (BOD.TotalValue + WIL.TotalValue +
                    ImprovementManager.ValueOf(this, Improvement.ImprovementType.ToxinInhalationResist).StandardRound())
                .ToString(objCulture);
        }

        /// <summary>
        /// Resist test to Injection-vector Toxins (BOD + WIL).
        /// </summary>
        public string ToxinInjectionResist(string strLanguage, CultureInfo objCulture)
        {
            if (IsAI || ImprovementManager
                        .GetCachedImprovementListForValueOf(
                            this, Improvement.ImprovementType.ToxinInjectionImmune).Count > 0)
                return LanguageManager.GetString("String_Immune", strLanguage);
            return (BOD.TotalValue + WIL.TotalValue +
                    ImprovementManager.ValueOf(this, Improvement.ImprovementType.ToxinInjectionResist).StandardRound())
                .ToString(objCulture);
        }

        /// <summary>
        /// Resist test to Contact-vector Pathogens (BOD + WIL).
        /// </summary>
        public string PathogenContactResist(string strLanguage, CultureInfo objCulture)
        {
            if (IsAI || ImprovementManager
                        .GetCachedImprovementListForValueOf(
                            this, Improvement.ImprovementType.PathogenContactImmune).Count > 0)
                return LanguageManager.GetString("String_Immune", strLanguage);
            return (BOD.TotalValue + WIL.TotalValue +
                    ImprovementManager.ValueOf(this, Improvement.ImprovementType.PathogenContactResist).StandardRound())
                .ToString(objCulture);
        }

        /// <summary>
        /// Resist test to Ingestion-vector Pathogens (BOD + WIL).
        /// </summary>
        public string PathogenIngestionResist(string strLanguage, CultureInfo objCulture)
        {
            if (IsAI || ImprovementManager
                        .GetCachedImprovementListForValueOf(
                            this, Improvement.ImprovementType.PathogenIngestionImmune).Count > 0)
                return LanguageManager.GetString("String_Immune", strLanguage);
            return (BOD.TotalValue + WIL.TotalValue +
                    ImprovementManager.ValueOf(this, Improvement.ImprovementType.PathogenIngestionResist).StandardRound())
                .ToString(objCulture);
        }

        /// <summary>
        /// Resist test to Inhalation-vector Pathogens (BOD + WIL).
        /// </summary>
        public string PathogenInhalationResist(string strLanguage, CultureInfo objCulture)
        {
            if (IsAI || ImprovementManager
                        .GetCachedImprovementListForValueOf(
                            this, Improvement.ImprovementType.PathogenInhalationImmune).Count > 0)
                return LanguageManager.GetString("String_Immune", strLanguage);
            return (BOD.TotalValue + WIL.TotalValue +
                    ImprovementManager.ValueOf(this, Improvement.ImprovementType.PathogenInhalationResist).StandardRound())
                .ToString(objCulture);
        }

        /// <summary>
        /// Resist test to Injection-vector Pathogens (BOD + WIL).
        /// </summary>
        public string PathogenInjectionResist(string strLanguage, CultureInfo objCulture)
        {
            if (IsAI || ImprovementManager
                        .GetCachedImprovementListForValueOf(
                            this, Improvement.ImprovementType.PathogenInjectionImmune).Count > 0)
                return LanguageManager.GetString("String_Immune", strLanguage);
            return (BOD.TotalValue + WIL.TotalValue +
                    ImprovementManager.ValueOf(this, Improvement.ImprovementType.PathogenInjectionResist).StandardRound())
                .ToString(objCulture);
        }

        /// <summary>
        /// Resist test to Physiological Addiction (BOD + WIL) if you are not addicted yet.
        /// </summary>
        public int PhysiologicalAddictionResistFirstTime =>
            BOD.TotalValue + WIL.TotalValue + ImprovementManager.ValueOf(this,
                Improvement.ImprovementType.PhysiologicalAddictionFirstTime).StandardRound();

        /// <summary>
        /// Resist test to Psychological Addiction (LOG + WIL) if you are not addicted yet.
        /// </summary>
        public int PsychologicalAddictionResistFirstTime =>
            LOG.TotalValue + WIL.TotalValue + ImprovementManager.ValueOf(this,
                Improvement.ImprovementType.PsychologicalAddictionFirstTime).StandardRound();

        /// <summary>
        /// Resist test to Physiological Addiction (BOD + WIL) if you are already addicted.
        /// </summary>
        public int PhysiologicalAddictionResistAlreadyAddicted =>
            BOD.TotalValue + WIL.TotalValue + ImprovementManager.ValueOf(this,
                Improvement.ImprovementType.PhysiologicalAddictionAlreadyAddicted).StandardRound();

        /// <summary>
        /// Resist test to Psychological Addiction (LOG + WIL) if you are already addicted.
        /// </summary>
        public int PsychologicalAddictionResistAlreadyAddicted =>
            LOG.TotalValue + WIL.TotalValue + ImprovementManager.ValueOf(this,
                Improvement.ImprovementType.PsychologicalAddictionAlreadyAddicted).StandardRound();

        /// <summary>
        /// Dicepool for natural recovery from Stun CM box damage (BOD + WIL).
        /// </summary>
        public int StunCMNaturalRecovery
        {
            get
            {
                // Matrix damage for A.I.s is not naturally repaired
                if(IsAI)
                    return 0;
                int intReturn = BOD.TotalValue + WIL.TotalValue +
                                ImprovementManager.ValueOf(this, Improvement.ImprovementType.StunCMRecovery).StandardRound();
                if (ImprovementManager
                    .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.AddESStoStunCMRecovery).Count
                    > 0)
                    intReturn += Essence().ToInt32();
                return intReturn;
            }
        }

        /// <summary>
        /// Dicepool for natural recovery from Physical CM box damage (2 x BOD).
        /// </summary>
        public int PhysicalCMNaturalRecovery
        {
            get
            {
                if(IsAI)
                {
                    if(HomeNode is Vehicle)
                        return 0;

                    // A.I.s can restore Core damage via Software + Depth [Data Processing] (1 day) Extended Test
                    int intAIReturn =
                        (SkillsSection.GetActiveSkill("Software")?.PoolOtherAttribute("DEP") ??
                         DEP.TotalValue - 1) +
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.PhysicalCMRecovery).StandardRound();
                    if (ImprovementManager
                        .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.AddESStoPhysicalCMRecovery).Count
                        > 0)
                        intAIReturn += Essence().ToInt32();
                    return intAIReturn;
                }

                int intReturn = 2 * BOD.TotalValue +
                                ImprovementManager.ValueOf(this, Improvement.ImprovementType.PhysicalCMRecovery).StandardRound();
                if (ImprovementManager
                    .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.AddESStoPhysicalCMRecovery).Count
                    > 0)
                    intReturn += Essence().ToInt32();
                return intReturn;
            }
        }

        #endregion

        #region Reputation

        /// <summary>
        /// Amount of Street Cred the character has earned through standard means.
        /// </summary>
        public int CalculatedStreetCred
        {
            get
            {
                // Street Cred = Career Karma / 10, rounded down
                int intReturn = CareerKarma /
                                (10 + ImprovementManager.ValueOf(this,
                                     Improvement.ImprovementType.StreetCredMultiplier).StandardRound());

                // Deduct burnt Street Cred.
                intReturn -= BurntStreetCred;

                return intReturn;
            }
        }

        /// <summary>
        /// Character's total amount of Street Cred (earned + GM awarded).
        /// </summary>
        public int TotalStreetCred =>
            Math.Max(
                CalculatedStreetCred + StreetCred +
                ImprovementManager.ValueOf(this, Improvement.ImprovementType.StreetCred).StandardRound(), 0);

        public string CareerDisplayStreetCred
        {
            get
            {
                int intTotalStreetCred = TotalStreetCred;
                int intCalculatedStreetCred = intTotalStreetCred - StreetCred;
                return (intCalculatedStreetCred >= 0
                           ? " + " + intCalculatedStreetCred.ToString(GlobalSettings.CultureInfo)
                           : " - " + (-intCalculatedStreetCred).ToString(GlobalSettings.CultureInfo)) + " = " +
                       intTotalStreetCred.ToString(GlobalSettings.CultureInfo);
            }
        }

        public bool CanBurnStreetCred => Created && TotalStreetCred >= 2;

        /// <summary>
        /// Street Cred Tooltip.
        /// </summary>
        public string StreetCredTooltip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdReturn))
                {
                    sbdReturn.Append(StreetCred.ToString(GlobalSettings.CultureInfo));

                    foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.StreetCred))
                    {
                        sbdReturn.Append(strSpace).Append('+').Append(strSpace).Append(GetObjectName(objImprovement))
                                 .Append(strSpace).Append('(')
                                 .Append(objImprovement.Value.ToString(GlobalSettings.CultureInfo)).Append(')');
                    }

                    sbdReturn.Append(strSpace).Append('+').Append(strSpace).Append('[')
                             .Append(LanguageManager.GetString("String_CareerKarma")).Append(strSpace).Append('')
                             .Append(strSpace)
                             .Append((10 + ImprovementManager.ValueOf(
                                         this, Improvement.ImprovementType.StreetCredMultiplier))
                                     .ToString(GlobalSettings.CultureInfo)).Append(']').Append(strSpace).Append('(')
                             .Append(
                                 (CareerKarma
                                  / (10 + ImprovementManager.ValueOf(
                                      this, Improvement.ImprovementType.StreetCredMultiplier)))
                                 .ToString(GlobalSettings.CultureInfo)).Append(')');

                    if (BurntStreetCred != 0)
                        sbdReturn.Append(strSpace).Append('-').Append(strSpace)
                                 .Append(LanguageManager.GetString("String_BurntStreetCred")).Append(strSpace)
                                 .Append('(')
                                 .Append(BurntStreetCred.ToString(GlobalSettings.CultureInfo)).Append(')');

                    return sbdReturn.ToString();
                }
            }
        }

        /// <summary>
        /// Amount of Notoriety the character has earned through standard means.
        /// </summary>
        public int CalculatedNotoriety
        {
            get
            {
                // Notoriety is simply the total value of Notoriety Improvements + the number of Enemies they have.
                int intReturn = ImprovementManager.ValueOf(this, Improvement.ImprovementType.Notoriety).StandardRound() -
                                                                (BurntStreetCred / 2); // + Contacts.Count(x => x.EntityType == ContactType.Enemy);

                return intReturn;
            }
        }

        /// <summary>
        /// Character's total amount of Notoriety (earned + GM awarded - burnt Street Cred).
        /// </summary>
        public int TotalNotoriety => CalculatedNotoriety + Notoriety;

        public string CareerDisplayNotoriety
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                int intCalculatedNotoriety = CalculatedNotoriety;
                return (intCalculatedNotoriety >= 0
                           ? strSpace + '+' + strSpace +
                             intCalculatedNotoriety.ToString(GlobalSettings.CultureInfo)
                           : strSpace + '-' + strSpace +
                             (-intCalculatedNotoriety).ToString(GlobalSettings.CultureInfo)) + strSpace + '=' +
                       strSpace + TotalNotoriety.ToString(GlobalSettings.CultureInfo);
            }
        }

        /// <summary>
        /// Tooltip to use for Notoriety total.
        /// </summary>
        public string NotorietyTooltip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdReturn))
                {
                    sbdReturn.Append(Notoriety.ToString(GlobalSettings.CultureInfo));

                    foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                 this, Improvement.ImprovementType.Notoriety))
                    {
                        sbdReturn.Append(strSpace).Append('+').Append(strSpace).Append(GetObjectName(objImprovement))
                                 .Append(strSpace).Append('(')
                                 .Append(objImprovement.Value.ToString(GlobalSettings.CultureInfo)).Append(')');
                    }

                    if (BurntStreetCred > 0)
                        sbdReturn.Append(strSpace).Append('-').Append(strSpace)
                                 .Append(LanguageManager.GetString("String_BurntStreetCred")).Append(
                                     strSpace).Append('(')
                                 .Append((BurntStreetCred / 2).ToString(GlobalSettings.CultureInfo)).Append(')');

                    return sbdReturn.ToString();
                }
            }
        }

        /// <summary>
        /// Amount of Public Awareness the character has earned through standard means.
        /// </summary>
        public int CalculatedPublicAwareness
        {
            get
            {
                int intReturn = ImprovementManager.ValueOf(this, Improvement.ImprovementType.PublicAwareness).StandardRound();
                if(Settings.UseCalculatedPublicAwareness)
                {
                    // Public Awareness is calculated as (Street Cred + Notoriety) / 3, rounded down.
                    intReturn += (TotalStreetCred + TotalNotoriety) / 3;
                }

                return intReturn;
            }
        }

        /// <summary>
        /// Character's total amount of Public Awareness (earned + GM awarded).
        /// </summary>
        public int TotalPublicAwareness
        {
            get
            {
                int intReturn = PublicAwareness + CalculatedPublicAwareness;
                if(Erased && intReturn >= 1)
                    return 1;
                return intReturn;
            }
        }

        public string CareerDisplayPublicAwareness
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                int intTotalPublicAwareness = TotalPublicAwareness;
                int intCalculatedPublicAwareness = intTotalPublicAwareness - PublicAwareness;
                return (intCalculatedPublicAwareness >= 0
                           ? strSpace + '+' + strSpace +
                             intCalculatedPublicAwareness.ToString(GlobalSettings.CultureInfo)
                           : strSpace + '-' + strSpace +
                             (-intCalculatedPublicAwareness).ToString(GlobalSettings.CultureInfo)) + strSpace +
                       '=' + strSpace + intTotalPublicAwareness.ToString(GlobalSettings.CultureInfo);
            }
        }

        /// <summary>
        /// Public Awareness Tooltip.
        /// </summary>
        public string PublicAwarenessTooltip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdReturn))
                {
                    sbdReturn.Append(PublicAwareness.ToString(GlobalSettings.CultureInfo));

                    foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                 this, Improvement.ImprovementType.PublicAwareness))
                    {
                        sbdReturn.Append(strSpace).Append('+').Append(strSpace).Append(GetObjectName(objImprovement))
                                 .Append(strSpace).Append('(')
                                 .Append(objImprovement.Value.ToString(GlobalSettings.CultureInfo)).Append(')');
                    }

                    if (Settings.UseCalculatedPublicAwareness)
                    {
                        sbdReturn.Append(strSpace).Append('+').Append(strSpace).Append('[')
                                 .Append(LanguageManager.GetString("String_StreetCred")).Append(strSpace).Append('+')
                                 .Append(strSpace).Append(LanguageManager.GetString("String_Notoriety")).Append(']')
                                 .Append(strSpace).Append('').Append(strSpace)
                                 .Append(3.ToString(GlobalSettings.CultureInfo)).Append(strSpace).Append('(')
                                 .Append(((TotalStreetCred + TotalNotoriety) / 3).ToString(GlobalSettings.CultureInfo))
                                 .Append(')');
                    }

                    if (Erased)
                    {
                        int intTotalPublicAwareness = PublicAwareness + CalculatedPublicAwareness;
                        if (intTotalPublicAwareness > 1)
                        {
                            string strErasedString = Qualities.FirstOrDefault(x => x.Name == "Erased")
                                                              ?.DisplayNameShort(GlobalSettings.Language);
                            if (string.IsNullOrEmpty(strErasedString))
                            {
                                XPathNavigator xmlErasedQuality = LoadDataXPath("qualities.xml")
                                    .SelectSingleNode("chummer/qualities/quality[name = \"Erased\"]");
                                if (xmlErasedQuality != null)
                                {
                                    strErasedString = xmlErasedQuality.SelectSingleNodeAndCacheExpression("translate")?.Value ?? "Erased";
                                }
                            }

                            sbdReturn.Append(strSpace).Append('-').Append(strSpace).Append(strErasedString)
                                     .Append(strSpace)
                                     .Append('(')
                                     .Append((intTotalPublicAwareness - 1).ToString(GlobalSettings.CultureInfo))
                                     .Append(')');
                        }
                    }

                    return sbdReturn.ToString();
                }
            }
        }

        #endregion

        #region List Properties

        /// <summary>
        /// Improvements.
        /// </summary>
        public EnhancedObservableCollection<Improvement> Improvements => _lstImprovements;

        /// <summary>
        /// Mentor spirits.
        /// </summary>
        [HubTag(true)]
        public EnhancedObservableCollection<MentorSpirit> MentorSpirits => _lstMentorSpirits;

        /// <summary>
        /// Contacts and Enemies.
        /// </summary>
        public EnhancedObservableCollection<Contact> Contacts => _lstContacts;

        /// <summary>
        /// Spirits and Sprites.
        /// </summary>
        public EnhancedObservableCollection<Spirit> Spirits => _lstSpirits;

        /// <summary>
        /// Magician Spells.
        /// </summary>
        [HubTag(true)]
        public EnhancedObservableCollection<Spell> Spells => _lstSpells;

        /// <summary>
        /// Sustained Spells
        /// </summary>
        public EnhancedObservableCollection<SustainedObject> SustainedCollection => _lstSustainedObjects;

        /// <summary>
        /// Foci.
        /// </summary>
        public List<Focus> Foci => _lstFoci;

        /// <summary>
        /// Stacked Foci.
        /// </summary>
        public List<StackedFocus> StackedFoci => _lstStackedFoci;

        /// <summary>
        /// Adept Powers.
        /// </summary>
        [HubTag(true)]
        public CachedBindingList<Power> Powers => _lstPowers;

        /// <summary>
        /// Technomancer Complex Forms.
        /// </summary>
        [HubTag(true)]
        public EnhancedObservableCollection<ComplexForm> ComplexForms => _lstComplexForms;

        /// <summary>
        /// AI Programs and Advanced Programs
        /// </summary>
        [HubTag(true)]
        public EnhancedObservableCollection<AIProgram> AIPrograms => _lstAIPrograms;

        /// <summary>
        /// Martial Arts.
        /// </summary>
        public EnhancedObservableCollection<MartialArt> MartialArts => _lstMartialArts;

        /// <summary>
        /// Limit Modifiers.
        /// </summary>
        public EnhancedObservableCollection<LimitModifier> LimitModifiers => _lstLimitModifiers;

        /// <summary>
        /// Armor.
        /// </summary>
        [HubTag(true)]
        public EnhancedObservableCollection<Armor> Armor => _lstArmor;

        /// <summary>
        /// Cyberware and Bioware.
        /// </summary>
        [HubTag(true)]
        public EnhancedObservableCollection<Cyberware> Cyberware => _lstCyberware;

        /// <summary>
        /// Weapons.
        /// </summary>
        [HubTag(true)]
        public EnhancedObservableCollection<Weapon> Weapons => _lstWeapons;

        /// <summary>
        /// Lifestyles.
        /// </summary>
        public EnhancedObservableCollection<Lifestyle> Lifestyles => _lstLifestyles;

        /// <summary>
        /// Gear.
        /// </summary>
        [HubTag(true)]
        public EnhancedObservableCollection<Gear> Gear => _lstGear;

        /// <summary>
        /// Vehicles.
        /// </summary>
        [HubTag(true)]
        public EnhancedObservableCollection<Vehicle> Vehicles => _lstVehicles;

        /// <summary>
        /// Metamagics and Echoes.
        /// </summary>
        [HubTag(true)]
        public EnhancedObservableCollection<Metamagic> Metamagics => _lstMetamagics;

        /// <summary>
        /// Enhancements.
        /// </summary>
        public EnhancedObservableCollection<Enhancement> Enhancements => _lstEnhancements;

        /// <summary>
        /// Arts.
        /// </summary>
        public EnhancedObservableCollection<Art> Arts => _lstArts;

        /// <summary>
        /// Critter Powers.
        /// </summary>
        [HubTag(true)]
        public EnhancedObservableCollection<CritterPower> CritterPowers => _lstCritterPowers;

        /// <summary>
        /// Initiation and Submersion Grades.
        /// </summary>
        public EnhancedObservableCollection<InitiationGrade> InitiationGrades => _lstInitiationGrades;

        /// <summary>
        /// Expenses (Karma and Nuyen).
        /// </summary>
        public EnhancedObservableCollection<ExpenseLogEntry> ExpenseEntries => _lstExpenseLog;

        /// <summary>
        /// Qualities (Positive and Negative).
        /// </summary>
        [HubTag(true)]
        public EnhancedObservableCollection<Quality> Qualities => _lstQualities;

        /*
        /// <summary>
        /// Life modules
        /// </summary>
        public List<LifeModule> LifeModules
        {
            get { return _lstLifeModules; }
        }
        */

        /// <summary>
        /// Locations.
        /// </summary>
        public EnhancedObservableCollection<Location> GearLocations => _lstGearLocations;

        /// <summary>
        /// Armor Bundles.
        /// </summary>
        public EnhancedObservableCollection<Location> ArmorLocations => _lstArmorLocations;

        /// <summary>
        /// Vehicle Locations.
        /// </summary>
        public EnhancedObservableCollection<Location> VehicleLocations => _lstVehicleLocations;

        /// <summary>
        /// Weapon Locations.
        /// </summary>
        public EnhancedObservableCollection<Location> WeaponLocations => _lstWeaponLocations;

        /// <summary>
        /// Improvement Groups.
        /// </summary>
        public EnhancedObservableCollection<string> ImprovementGroups => _lstImprovementGroups;

        /// <summary>
        /// Calendar.
        /// </summary>
        public BindingList<CalendarWeek> Calendar => _lstCalendar;

        /// <summary>
        /// List of internal IDs that need their improvements re-applied.
        /// </summary>
        public List<string> InternalIdsNeedingReapplyImprovements => _lstInternalIdsNeedingReapplyImprovements;

        #endregion

        #region Armor Properties

        public int GetArmorRating(Improvement.ImprovementType eDamageType = Improvement.ImprovementType.Armor)
        {
            return GetArmorRatingWithImprovement(eDamageType, out int _, out List<Improvement> _);
        }

        public int GetArmorRatingWithImprovement(Improvement.ImprovementType eDamageType, out int intFromEquippedArmorImprovements, out List<Improvement> lstUsedImprovements)
        {
            intFromEquippedArmorImprovements = 0;
            if (eDamageType == Improvement.ImprovementType.None)
            {
                lstUsedImprovements = new List<Improvement>();
                return 0;
            }
            List<Armor> lstArmorsToConsider = Armor.Where(objArmor => objArmor.Equipped).ToList();
            decimal decBaseArmorImprovement = ImprovementManager.ValueOf(this, eDamageType, out lstUsedImprovements);
            if (eDamageType != Improvement.ImprovementType.Armor)
            {
                decBaseArmorImprovement += ImprovementManager.ValueOf(this, Improvement.ImprovementType.Armor, out List<Improvement> lstUsedImprovementsExtra);
                lstUsedImprovements.AddRange(lstUsedImprovementsExtra);
            }

            if (lstArmorsToConsider.Count == 0)
                return decBaseArmorImprovement.StandardRound();
            decimal decGeneralArmorImprovementValue = decBaseArmorImprovement;
            Dictionary<Armor, decimal> dicArmorImprovementValues = lstArmorsToConsider.ToDictionary(x => x, y => decBaseArmorImprovement);
            foreach (Improvement objImprovement in lstUsedImprovements)
            {
                if (objImprovement.ImproveSource != Improvement.ImprovementSource.Armor &&
                    objImprovement.ImproveSource != Improvement.ImprovementSource.ArmorMod)
                    continue;
                Armor objSourceArmor =
                    lstArmorsToConsider.Find(x => x.InternalId == objImprovement.SourceName)
                    ?? lstArmorsToConsider.FindArmorMod(objImprovement.SourceName)?.Parent;
                if (objSourceArmor == null)
                    continue;
                decGeneralArmorImprovementValue -= objImprovement.Value;
                foreach (Armor objArmor in lstArmorsToConsider)
                {
                    if (objArmor != objSourceArmor)
                        dicArmorImprovementValues[objArmor] -= objImprovement.Value;
                }
            }

            Armor objHighestArmor = null;
            int intHighest = 0;
            int intHighestNoCustomStack = 0;
            // Run through the list of Armor currently worn and retrieve the highest total Armor rating.
            // This is used for Custom-Fit armour's stacking.
            foreach (Armor objArmor in lstArmorsToConsider)
            {
                if (objArmor.ArmorValue.StartsWith('+')
                     || objArmor.ArmorValue.StartsWith('-'))
                    continue;
                int intCustomStackBonus = 0;
                string strArmorName = objArmor.Name;
                foreach (Armor objInnerArmor in lstArmorsToConsider)
                {
                    if (objInnerArmor == objArmor)
                        continue;
                    if (!objInnerArmor.ArmorOverrideValue.StartsWith('+') && !objInnerArmor.ArmorOverrideValue.StartsWith('-'))
                        continue;
                    if (objInnerArmor.ArmorMods.Any(objMod => objMod.Name == "Custom Fit (Stack)"
                                                              && objMod.Extra == strArmorName
                                                              && objMod.Equipped))
                        intCustomStackBonus += objInnerArmor.TotalOverrideArmor;
                }

                int intArmorValue = objArmor.TotalArmor + dicArmorImprovementValues[objArmor].StandardRound();
                if (intArmorValue + intCustomStackBonus > intHighest)
                {
                    intHighest = intArmorValue + intCustomStackBonus;
                    intFromEquippedArmorImprovements = (dicArmorImprovementValues[objArmor] - decGeneralArmorImprovementValue).StandardRound();
                    intHighestNoCustomStack = intArmorValue;
                    objHighestArmor = objArmor;
                }
            }

            int intArmor = intHighestNoCustomStack;

            // Run through the list of Armor currently worn again and look at armors that start with '+' since they stack with the highest Armor.
            int intStacking = 0;
            foreach (Armor objArmor in lstArmorsToConsider)
            {
                if (!objArmor.ArmorValue.StartsWith('+')
                    && !objArmor.ArmorValue.StartsWith('-')
                    && !objArmor.ArmorOverrideValue.StartsWith('+')
                    && !objArmor.ArmorOverrideValue.StartsWith('-')
                    || objArmor == objHighestArmor)
                    continue;
                bool blnDoAdd = true;
                bool blnCustomFit = false;
                if (objHighestArmor != null)
                {
                    foreach (ArmorMod objMod in objArmor.ArmorMods)
                    {
                        if (objMod.Name == "Custom Fit (Stack)")
                        {
                            blnDoAdd = objMod.Extra == objHighestArmor.Name && objMod.Equipped;
                            blnCustomFit = true;
                            break;
                        }
                    }
                }

                if (blnDoAdd)
                {
                    if (!blnCustomFit && (objArmor.ArmorValue.StartsWith('+') || objArmor.ArmorValue.StartsWith('-')))
                        intStacking += objArmor.TotalArmor;
                    else
                        intStacking += objArmor.TotalOverrideArmor;
                }
            }

            return intArmor + intStacking;
        }

        public int DamageResistancePool
        {
            get
            {
                int intBody = 0;
                if (IsAI)
                {
                    if (HomeNode is Vehicle objVehicle)
                        intBody = objVehicle.TotalBody;
                }
                else
                    intBody = BOD.TotalValue;
                return intBody +
                       TotalArmorRating +
                       ImprovementManager.ValueOf(this, Improvement.ImprovementType.DamageResistance).StandardRound();
            }
        }

        public string DamageResistancePoolToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                int intBody;
                string strBodyAbbrev;
                if (IsAI)
                {
                    intBody = HomeNode is Vehicle objVehicle ? objVehicle.TotalBody : 0;
                    strBodyAbbrev = LanguageManager.GetString("String_VehicleBody");
                }
                else
                {
                    intBody = BOD.TotalValue;
                    strBodyAbbrev = BOD.DisplayAbbrev;
                }

                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(strBodyAbbrev).Append(strSpace).Append('(')
                              .Append(intBody.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(LanguageManager.GetString("Tip_Armor"))
                              .Append(strSpace).Append('(')
                              .Append(TotalArmorRating.ToString(GlobalSettings.CultureInfo)).Append(')');

                    foreach (Improvement objLoopImprovement in ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.DamageResistance))
                    {
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                  .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public int CurrentCounterspellingDice
        {
            get => _intCurrentCounterspellingDice;
            set
            {
                if(_intCurrentCounterspellingDice != value)
                {
                    _intCurrentCounterspellingDice = value;
                    OnPropertyChanged();
                }
            }
        }
        #region Dodge
        public int Dodge => REA.TotalValue + INT.TotalValue + TotalBonusDodgeRating + WoundModifier + SustainingPenalty;

        public string DisplayDodge => Dodge.ToString(GlobalSettings.CultureInfo);

        public string DodgeToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(REA.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(REA.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(INT.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(INT.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(LanguageManager.GetString("Tip_Skill_Wounds"))
                              .Append(strSpace).Append('(').Append(WoundModifier.ToString(GlobalSettings.CultureInfo))
                              .Append(')').Append(strSpace).Append('+').Append(strSpace)
                              .Append(LanguageManager.GetString("Tip_Skill_Sustain")).Append(strSpace).Append('(')
                              .Append(SustainingPenalty.ToString(GlobalSettings.CultureInfo)).Append(')');

                    int intModifiers = TotalBonusDodgeRating;

                    if (intModifiers != 0)
                    {
                        FormatImprovementModifiers(
                            sbdToolTip,
                            Improvement.ImprovementType.Dodge.Yield(),
                            strSpace,
                            intModifiers);
                    }

                    return sbdToolTip.ToString();
                }
            }
        }
        #endregion
        #region Spell Defense
        #region Indirect Dodge
        public int SpellDefenseIndirectDodge => Dodge;

        public string DisplaySpellDefenseIndirectDodge => CurrentCounterspellingDice == 0
            ? SpellDefenseIndirectDodge.ToString(GlobalSettings.CultureInfo)
            : SpellDefenseIndirectDodge.ToString(GlobalSettings.CultureInfo) +
              LanguageManager.GetString("String_Space") + '(' +
              (SpellDefenseIndirectDodge + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo) + ')';

        public string SpellDefenseIndirectDodgeToolTip
        {
            get
            {
                string strToolTip = DodgeToolTip;

                if (CurrentCounterspellingDice != 0)
                {
                    string strSpace = LanguageManager.GetString("String_Space");
                    strToolTip += strSpace + '+' + strSpace + LanguageManager.GetString("Label_CounterspellingDice") +
                                  strSpace + '(' + CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo) + ')';
                }

                return strToolTip;
            }
        }
        #endregion
        #region Indirect Soak
        public int SpellDefenseIndirectSoak
        {
            get
            {
                int intAttributes = 0;
                if (IsAI)
                {
                    if (HomeNode is Vehicle objVehicle)
                        intAttributes = objVehicle.TotalBody;
                }
                else
                    intAttributes = BOD.TotalValue;

                return intAttributes +
                       GetArmorRating(Improvement.ImprovementType.SpellResistance) +
                       ImprovementManager.ValueOf(this, Improvement.ImprovementType.DamageResistance).StandardRound();
            }
        }

        public string DisplaySpellDefenseIndirectSoak => CurrentCounterspellingDice == 0
            ? SpellDefenseIndirectSoak.ToString(GlobalSettings.CultureInfo)
            : SpellDefenseIndirectSoak.ToString(GlobalSettings.CultureInfo) +
              LanguageManager.GetString("String_Space") + '(' +
              (SpellDefenseIndirectSoak + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo) + ')';

        public string SpellDefenseIndirectSoakToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                int intBody;
                string strBodyAbbrev;
                if (IsAI)
                {
                    intBody = HomeNode is Vehicle objVehicle ? objVehicle.TotalBody : 0;
                    strBodyAbbrev = LanguageManager.GetString("String_VehicleBody");
                }
                else
                {
                    intBody = BOD.TotalValue;
                    strBodyAbbrev = BOD.DisplayAbbrev;
                }

                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(strBodyAbbrev).Append(strSpace).Append('(')
                              .Append(intBody.ToString(GlobalSettings.CultureInfo)).Append(')')
                              .Append(strSpace).Append('+').Append(strSpace)
                              .Append(LanguageManager.GetString("Tip_Armor"))
                              .Append(strSpace).Append('(')
                              .Append(TotalArmorRating.ToString(GlobalSettings.CultureInfo))
                              .Append(')');

                    if (CurrentCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                  .Append('(').Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');

                    int intModifiers = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                        + ImprovementManager.ValueOf(
                                            this, Improvement.ImprovementType.DamageResistance)).StandardRound();

                    if (intModifiers != 0)
                    {
                        FormatImprovementModifiers(
                            sbdToolTip,
                            Improvement.ImprovementType.DamageResistance.Yield(),
                            strSpace,
                            intModifiers);
                    }

                    return sbdToolTip.ToString();
                }
            }
        }
        #endregion
        #region Direct Soak Mana
        public int SpellDefenseDirectSoakMana => WIL.TotalValue
                                                 + (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                                     + ImprovementManager.ValueOf(this, Improvement.ImprovementType.DirectManaSpellResist)).StandardRound();

        public string DisplaySpellDefenseDirectSoakMana => CurrentCounterspellingDice == 0
            ? SpellDefenseDirectSoakMana.ToString(GlobalSettings.CultureInfo)
            : SpellDefenseDirectSoakMana.ToString(GlobalSettings.CultureInfo) +
              LanguageManager.GetString("String_Space") + '(' +
              (SpellDefenseDirectSoakMana + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo) + ')';

        public string SpellDefenseDirectSoakManaToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                    if (CurrentCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                  .Append('(').Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');

                    int intModifiers = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                        + ImprovementManager.ValueOf(
                                            this, Improvement.ImprovementType.DirectManaSpellResist)).StandardRound();

                    if (intModifiers != 0)
                    {
                        FormatImprovementModifiers(
                            sbdToolTip,
                            Improvement.ImprovementType.SpellResistance.Yield(),
                            strSpace,
                            intModifiers);
                    }

                    return sbdToolTip.ToString();
                }
            }
        }
        #endregion
        #region Direct Soak Physical
        public int SpellDefenseDirectSoakPhysical
        {
            get
            {
                int intAttributes = 0;
                if (IsAI)
                {
                    if (HomeNode is Vehicle objVehicle)
                        intAttributes = objVehicle.TotalBody;
                }
                else
                    intAttributes = BOD.TotalValue;

                return intAttributes +
                       (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance) +
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.DirectPhysicalSpellResist))
                       .StandardRound();
            }
        }

        public string DisplaySpellDefenseDirectSoakPhysical => CurrentCounterspellingDice == 0
            ? SpellDefenseDirectSoakPhysical.ToString(GlobalSettings.CultureInfo)
            : SpellDefenseDirectSoakPhysical.ToString(GlobalSettings.CultureInfo) +
              LanguageManager.GetString("String_Space") + '(' +
              (SpellDefenseDirectSoakPhysical + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo) + ')';

        public string SpellDefenseDirectSoakPhysicalToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");

                int intBody;
                string strBodyAbbrev;
                if (IsAI)
                {
                    intBody = HomeNode is Vehicle objVehicle ? objVehicle.TotalBody : 0;
                    strBodyAbbrev = LanguageManager.GetString("String_VehicleBody");
                }
                else
                {
                    intBody = BOD.TotalValue;
                    strBodyAbbrev = BOD.DisplayAbbrev;
                }

                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(strBodyAbbrev).Append(strSpace).Append('(')
                              .Append(intBody.ToString(GlobalSettings.CultureInfo)).Append(')');

                    if (CurrentCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                  .Append('(').Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');

                    int intModifiers = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                        + ImprovementManager.ValueOf(
                                            this, Improvement.ImprovementType.DirectPhysicalSpellResist))
                        .StandardRound();

                    if (intModifiers != 0)
                    {
                        FormatImprovementModifiers(
                            sbdToolTip,
                            new[]
                            {
                                Improvement.ImprovementType.SpellResistance,
                                Improvement.ImprovementType.DirectPhysicalSpellResist
                            },
                            strSpace,
                            intModifiers);
                    }

                    return sbdToolTip.ToString();
                }
            }
        }
        #endregion
        #region Detection
        public int SpellDefenseDetection => LOG.TotalValue + WIL.TotalValue + SpellResistance +
                                            ImprovementManager.ValueOf(this, Improvement.ImprovementType.DetectionSpellResist).StandardRound();

        public string DisplaySpellDefenseDetection => CurrentCounterspellingDice == 0
            ? SpellDefenseDetection.ToString(GlobalSettings.CultureInfo)
            : SpellDefenseDetection.ToString(GlobalSettings.CultureInfo) +
              LanguageManager.GetString("String_Space") + '(' +
              (SpellDefenseDetection + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo) + ')';

        public string SpellDefenseDetectionToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(LOG.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(LOG.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                    if (CurrentCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                  .Append('(').Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');

                    int intModifiers = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                        + ImprovementManager.ValueOf(
                                            this, Improvement.ImprovementType.DetectionSpellResist)).StandardRound();

                    if (intModifiers != 0)
                    {
                        FormatImprovementModifiers(
                            sbdToolTip,
                            new []
                            {
                                Improvement.ImprovementType.SpellResistance,
                                Improvement.ImprovementType.DetectionSpellResist
                            },
                            strSpace,
                            intModifiers);
                    }

                    return sbdToolTip.ToString();
                }
            }
        }
        #endregion
        #region Decrease Attributes
        public int SpellDefenseDecreaseBOD => BOD.TotalValue + WIL.TotalValue
                                                             + (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                                                 + ImprovementManager.ValueOf(this, Improvement.ImprovementType.DecreaseBODResist)).StandardRound();

        public string DisplaySpellDefenseDecreaseBOD => CurrentCounterspellingDice == 0
            ? SpellDefenseDecreaseBOD.ToString(GlobalSettings.CultureInfo)
            : SpellDefenseDecreaseBOD.ToString(GlobalSettings.CultureInfo) +
              LanguageManager.GetString("String_Space") + '(' +
              (SpellDefenseDecreaseBOD + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo) + ')';

        public string SpellDefenseDecreaseBODToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(BOD.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(BOD.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                    if (CurrentCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                  .Append('(').Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');

                    int intModifiers = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                        + ImprovementManager.ValueOf(
                                            this, Improvement.ImprovementType.DecreaseBODResist)).StandardRound();

                    if (intModifiers != 0)
                    {
                        FormatImprovementModifiers(
                            sbdToolTip,
                            new []
                            {
                                Improvement.ImprovementType.SpellResistance,
                                Improvement.ImprovementType.DecreaseBODResist
                            },
                            strSpace,
                            intModifiers);
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public int SpellDefenseDecreaseAGI => AGI.TotalValue + WIL.TotalValue
                                                             + (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                                                 + ImprovementManager.ValueOf(this, Improvement.ImprovementType.DecreaseAGIResist)).StandardRound();

        public string DisplaySpellDefenseDecreaseAGI => CurrentCounterspellingDice == 0
            ? SpellDefenseDecreaseAGI.ToString(GlobalSettings.CultureInfo)
            : SpellDefenseDecreaseAGI.ToString(GlobalSettings.CultureInfo) +
              LanguageManager.GetString("String_Space") + '(' +
              (SpellDefenseDecreaseAGI + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo) + ')';

        public string SpellDefenseDecreaseAGIToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(AGI.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(AGI.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                    if (CurrentCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                  .Append('(').Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');

                    int intModifiers = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                        + ImprovementManager.ValueOf(
                                            this, Improvement.ImprovementType.DecreaseAGIResist)).StandardRound();

                    if (intModifiers != 0)
                    {
                        FormatImprovementModifiers(
                            sbdToolTip,
                            new []
                            {
                                Improvement.ImprovementType.SpellResistance,
                                Improvement.ImprovementType.DecreaseAGIResist
                            },
                            strSpace,
                            intModifiers);
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public int SpellDefenseDecreaseREA => REA.TotalValue + WIL.TotalValue
                                                             + (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                                                 + ImprovementManager.ValueOf(this, Improvement.ImprovementType.DecreaseREAResist)).StandardRound();

        public string DisplaySpellDefenseDecreaseREA => CurrentCounterspellingDice == 0
            ? SpellDefenseDecreaseREA.ToString(GlobalSettings.CultureInfo)
            : SpellDefenseDecreaseREA.ToString(GlobalSettings.CultureInfo) +
              LanguageManager.GetString("String_Space") + '(' +
              (SpellDefenseDecreaseREA + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo) + ')';

        public string SpellDefenseDecreaseREAToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(REA.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(REA.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                    if (CurrentCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                  .Append('(').Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');

                    int intModifiers = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                        + ImprovementManager.ValueOf(
                                            this, Improvement.ImprovementType.DecreaseREAResist)).StandardRound();

                    if (intModifiers != 0)
                    {
                        FormatImprovementModifiers(
                            sbdToolTip,
                            new []
                            {
                                Improvement.ImprovementType.SpellResistance,
                                Improvement.ImprovementType.DecreaseREAResist
                            },
                            strSpace,
                            intModifiers);
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public int SpellDefenseDecreaseSTR => STR.TotalValue + WIL.TotalValue
                                                             + (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                                                 + ImprovementManager.ValueOf(this, Improvement.ImprovementType.DecreaseSTRResist)).StandardRound();

        public string DisplaySpellDefenseDecreaseSTR => CurrentCounterspellingDice == 0
            ? SpellDefenseDecreaseSTR.ToString(GlobalSettings.CultureInfo)
            : SpellDefenseDecreaseSTR.ToString(GlobalSettings.CultureInfo) +
              LanguageManager.GetString("String_Space") + '(' +
              (SpellDefenseDecreaseSTR + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo) + ')';

        public string SpellDefenseDecreaseSTRToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(STR.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(STR.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                    if (CurrentCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                  .Append('(').Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');

                    int intModifiers = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                        + ImprovementManager.ValueOf(
                                            this, Improvement.ImprovementType.DecreaseSTRResist)).StandardRound();

                    if (intModifiers != 0)
                    {
                        FormatImprovementModifiers(
                            sbdToolTip,
                            Improvement.ImprovementType.SpellResistance.Yield(),
                            strSpace,
                            intModifiers);
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public int SpellDefenseDecreaseCHA => CHA.TotalValue + WIL.TotalValue
                                                             + (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                                                 + ImprovementManager.ValueOf(this, Improvement.ImprovementType.DecreaseCHAResist)).StandardRound();

        public string DisplaySpellDefenseDecreaseCHA => CurrentCounterspellingDice == 0
            ? SpellDefenseDecreaseCHA.ToString(GlobalSettings.CultureInfo)
            : SpellDefenseDecreaseCHA.ToString(GlobalSettings.CultureInfo) +
              LanguageManager.GetString("String_Space") + '(' +
              (SpellDefenseDecreaseCHA + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo) + ')';

        public string SpellDefenseDecreaseCHAToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(CHA.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(CHA.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                    if (CurrentCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                  .Append('(').Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');

                    int intModifiers = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                        + ImprovementManager.ValueOf(
                                            this, Improvement.ImprovementType.DecreaseCHAResist)).StandardRound();

                    if (intModifiers != 0)
                    {
                        FormatImprovementModifiers(
                            sbdToolTip,
                            new []
                            {
                                Improvement.ImprovementType.SpellResistance,
                                Improvement.ImprovementType.DecreaseCHAResist
                            },
                            strSpace,
                            intModifiers);
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public int SpellDefenseDecreaseINT => INT.TotalValue + WIL.TotalValue
                                                             + (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                                                 + ImprovementManager.ValueOf(this, Improvement.ImprovementType.DecreaseINTResist)).StandardRound();

        public string DisplaySpellDefenseDecreaseINT => CurrentCounterspellingDice == 0
            ? SpellDefenseDecreaseINT.ToString(GlobalSettings.CultureInfo)
            : SpellDefenseDecreaseINT.ToString(GlobalSettings.CultureInfo) +
              LanguageManager.GetString("String_Space") + '(' +
              (SpellDefenseDecreaseINT + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo) + ')';

        public string SpellDefenseDecreaseINTToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(INT.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(INT.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                    if (CurrentCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                  .Append('(').Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');

                    int intModifiers = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                        + ImprovementManager.ValueOf(
                                            this, Improvement.ImprovementType.DecreaseINTResist)).StandardRound();

                    if (intModifiers != 0)
                    {
                        FormatImprovementModifiers(
                            sbdToolTip,
                            new []
                            {
                                Improvement.ImprovementType.SpellResistance,
                                Improvement.ImprovementType.DecreaseINTResist
                            },
                            strSpace,
                            intModifiers);
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public int SpellDefenseDecreaseLOG => LOG.TotalValue + WIL.TotalValue
                                                             + (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                                                 + ImprovementManager.ValueOf(this, Improvement.ImprovementType.DecreaseLOGResist)).StandardRound();

        public string DisplaySpellDefenseDecreaseLOG => CurrentCounterspellingDice == 0
            ? SpellDefenseDecreaseLOG.ToString(GlobalSettings.CultureInfo)
            : SpellDefenseDecreaseLOG.ToString(GlobalSettings.CultureInfo) +
              LanguageManager.GetString("String_Space") + '(' +
              (SpellDefenseDecreaseLOG + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo) + ')';

        public string SpellDefenseDecreaseLOGToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(LOG.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(LOG.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                    if (CurrentCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                  .Append('(').Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');

                    int intModifiers = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                        + ImprovementManager.ValueOf(
                                            this, Improvement.ImprovementType.DecreaseLOGResist)).StandardRound();

                    if (intModifiers != 0)
                    {
                        FormatImprovementModifiers(
                            sbdToolTip,
                            new []
                            {
                                Improvement.ImprovementType.SpellResistance,
                                Improvement.ImprovementType.DecreaseLOGResist
                            },
                            strSpace,
                            intModifiers);
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public int SpellDefenseDecreaseWIL => WIL.TotalValue + WIL.TotalValue
                                                             + (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                                                 + ImprovementManager.ValueOf(this, Improvement.ImprovementType.DecreaseWILResist)).StandardRound();

        public string DisplaySpellDefenseDecreaseWIL => CurrentCounterspellingDice == 0
            ? SpellDefenseDecreaseWIL.ToString(GlobalSettings.CultureInfo)
            : SpellDefenseDecreaseWIL.ToString(GlobalSettings.CultureInfo) +
              LanguageManager.GetString("String_Space") + '(' +
              (SpellDefenseDecreaseWIL + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo) + ')';

        public string SpellDefenseDecreaseWILToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                    if (CurrentCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                  .Append('(').Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');

                    int intModifiers = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                        + ImprovementManager.ValueOf(
                                            this, Improvement.ImprovementType.DecreaseWILResist)).StandardRound();

                    if (intModifiers != 0)
                    {
                        FormatImprovementModifiers(
                            sbdToolTip,
                            new []
                            {
                                Improvement.ImprovementType.SpellResistance,
                                Improvement.ImprovementType.DecreaseWILResist
                            },
                            strSpace,
                            intModifiers);
                    }

                    return sbdToolTip.ToString();
                }
            }
        }
        #endregion
        #endregion

        public int Surprise => REA.TotalValue + INT.TotalValue
                                              + ImprovementManager.ValueOf(this, Improvement.ImprovementType.Surprise).StandardRound()
                                              + WoundModifier
                                              + SustainingPenalty;

        public string SurpriseToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(REA.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(REA.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(INT.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(INT.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(LanguageManager.GetString("Tip_Skill_Wounds"))
                              .Append(strSpace).Append('(').Append(WoundModifier.ToString(GlobalSettings.CultureInfo))
                              .Append(')').Append(strSpace).Append('+').Append(strSpace)
                              .Append(LanguageManager.GetString("Tip_Skill_Sustain")).Append(strSpace).Append('(')
                              .Append(SustainingPenalty.ToString(GlobalSettings.CultureInfo)).Append(')');

                    if (CurrentCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                  .Append('(').Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');

                    int intModifiers = ImprovementManager.ValueOf(this, Improvement.ImprovementType.Surprise)
                                                         .StandardRound();

                    if (intModifiers != 0)
                    {
                        FormatImprovementModifiers(
                            sbdToolTip,
                            Improvement.ImprovementType.Surprise.Yield(),
                            strSpace,
                            intModifiers);
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        private int _intCachedTotalArmorRating = int.MinValue;
        private int _intCachedTotalFireArmorRating = int.MinValue;
        private int _intCachedTotalColdArmorRating = int.MinValue;
        private int _intCachedTotalElectricityArmorRating = int.MinValue;
        private int _intCachedTotalAcidArmorRating = int.MinValue;
        private int _intCachedTotalFallingArmorRating = int.MinValue;

        /// <summary>
        /// The Character's total Armor Rating.
        /// </summary>
        [HubTag]
        public int TotalArmorRating
        {
            get
            {
                if (_intCachedTotalArmorRating == int.MinValue)
                    _intCachedTotalArmorRating = GetArmorRating();
                return _intCachedTotalArmorRating;
            }
        }

        public string TotalArmorRatingToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                int intArmor
                    = GetArmorRatingWithImprovement(Improvement.ImprovementType.Armor,
                                                    out int intFromHighestArmorImprovements,
                                                    out List<Improvement> lstUsedImprovements)
                      - ImprovementManager.ValueOf(this, Improvement.ImprovementType.Armor).StandardRound()
                      + intFromHighestArmorImprovements;

                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(LanguageManager.GetString("Tip_Armor")).Append(strSpace).Append('(')
                              .Append(intArmor.ToString(GlobalSettings.CultureInfo)).Append(')');
                    foreach (Improvement objLoopImprovement in lstUsedImprovements)
                    {
                        if (objLoopImprovement.ImproveSource != Improvement.ImprovementSource.Armor
                            && objLoopImprovement.ImproveSource != Improvement.ImprovementSource.ArmorMod)
                        {
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                      .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against Fire attacks.
        /// </summary>
        public int TotalFireArmorRating
        {
            get
            {
                if (_intCachedTotalFireArmorRating == int.MinValue)
                    _intCachedTotalFireArmorRating = GetArmorRating(Improvement.ImprovementType.FireArmor);
                return _intCachedTotalFireArmorRating;
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against Cold attacks.
        /// </summary>
        public int TotalColdArmorRating
        {
            get
            {
                if (_intCachedTotalColdArmorRating == int.MinValue)
                    _intCachedTotalColdArmorRating = GetArmorRating(Improvement.ImprovementType.ColdArmor);
                return _intCachedTotalColdArmorRating;
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against Electricity attacks.
        /// </summary>
        public int TotalElectricityArmorRating
        {
            get
            {
                if (_intCachedTotalElectricityArmorRating == int.MinValue)
                    _intCachedTotalElectricityArmorRating = GetArmorRating(Improvement.ImprovementType.ElectricityArmor);
                return _intCachedTotalElectricityArmorRating;
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against Acid attacks.
        /// </summary>
        public int TotalAcidArmorRating
        {
            get
            {
                if (_intCachedTotalAcidArmorRating == int.MinValue)
                    _intCachedTotalAcidArmorRating = GetArmorRating(Improvement.ImprovementType.AcidArmor);
                return _intCachedTotalAcidArmorRating;
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against falling damage (AP -4 not factored in).
        /// </summary>
        public int TotalFallingArmorRating
        {
            get
            {
                if (_intCachedTotalFallingArmorRating == int.MinValue)
                    _intCachedTotalFallingArmorRating = GetArmorRating(Improvement.ImprovementType.FallingArmor);
                return _intCachedTotalFallingArmorRating;
            }
        }

        /// <summary>
        /// The Character's total bonus to Dodge Rating (to add on top of REA + INT).
        /// </summary>
        public int TotalBonusDodgeRating => ImprovementManager.ValueOf(this, Improvement.ImprovementType.Dodge).StandardRound();

        /// <summary>
        /// Armor Encumbrance modifier from Armor.
        /// </summary>
        public int ArmorEncumbrance
        {
            get
            {
                List<Armor> lstArmorsToConsider = Armor.Where(objArmor => objArmor.Equipped).ToList();
                if (lstArmorsToConsider.Count == 0 || lstArmorsToConsider.All(objArmor => !objArmor.Encumbrance))
                    return 0;
                Armor objHighestArmor = null;
                int intHighest = 0;
                // Run through the list of Armor currently worn and retrieve the highest total Armor rating.
                // This is used for Custom-Fit armour's stacking.
                foreach (Armor objArmor in lstArmorsToConsider)
                {
                    if (objArmor.ArmorValue.StartsWith('+')
                        || objArmor.ArmorValue.StartsWith('-'))
                        continue;
                    int intLoopTotal = objArmor.TotalArmor;
                    string strArmorName = objArmor.Name;
                    foreach (Armor objInnerArmor in lstArmorsToConsider)
                    {
                        if (objInnerArmor == objArmor)
                            continue;
                        if (!objInnerArmor.ArmorOverrideValue.StartsWith('+') && !objInnerArmor.ArmorOverrideValue.StartsWith('-'))
                            continue;
                        if (objInnerArmor.ArmorMods.Any(objMod => objMod.Name == "Custom Fit (Stack)"
                                                                  && objMod.Extra == strArmorName
                                                                  && objMod.Equipped))
                            intLoopTotal += objInnerArmor.TotalOverrideArmor;
                    }

                    if (intLoopTotal > intHighest)
                    {
                        intHighest = intLoopTotal;
                        objHighestArmor = objArmor;
                    }
                }

                int intTotalA = 0;

                foreach (Armor objArmor in lstArmorsToConsider)
                {
                    if (!objArmor.Encumbrance
                        || (!objArmor.ArmorValue.StartsWith('+')
                            && !objArmor.ArmorValue.StartsWith('-')
                            && !objArmor.ArmorOverrideValue.StartsWith('+')
                            && !objArmor.ArmorOverrideValue.StartsWith('-'))
                        || objArmor == objHighestArmor)
                        continue;
                    bool blnDoAdd = true;
                    bool blnCustomFit = false;
                    if (objHighestArmor != null)
                    {
                        foreach (ArmorMod objMod in objArmor.ArmorMods)
                        {
                            if (objMod.Name == "Custom Fit (Stack)")
                            {
                                blnDoAdd = objMod.Extra == objHighestArmor.Name && objMod.Equipped;
                                blnCustomFit = true;
                                break;
                            }
                        }
                    }

                    if (blnDoAdd)
                    {
                        if (!blnCustomFit && (objArmor.ArmorValue.StartsWith('+') || objArmor.ArmorValue.StartsWith('-')))
                            intTotalA += objArmor.TotalArmor;
                        else
                            intTotalA += objArmor.TotalOverrideArmor;
                    }
                }

                // calculate armor encumbrance
                int intSTRTotalValue = STR.TotalValue;
                if (intTotalA > intSTRTotalValue + 1)
                    return (intSTRTotalValue - intTotalA) / 2; // a negative number is expected
                return 0;
            }
        }

        #endregion

        #region Spell Defense
        public int SpellDefenseIllusionMana => LOG.TotalValue + WIL.TotalValue
                                                              + (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                                                  + ImprovementManager.ValueOf(this, Improvement.ImprovementType.ManaIllusionResist)).StandardRound();

        public string DisplaySpellDefenseIllusionMana => CurrentCounterspellingDice == 0
            ? SpellDefenseIllusionMana.ToString(GlobalSettings.CultureInfo)
            : SpellDefenseIllusionMana.ToString(GlobalSettings.CultureInfo) +
              LanguageManager.GetString("String_Space") + '(' +
              (SpellDefenseIllusionMana + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo) + ')';

        public string SpellDefenseIllusionManaToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(LOG.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(LOG.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                    if (CurrentCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                  .Append('(').Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');

                    int intModifiers = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                        + ImprovementManager.ValueOf(
                                            this, Improvement.ImprovementType.ManaIllusionResist))
                        .StandardRound();

                    if (intModifiers != 0)
                    {
                        FormatImprovementModifiers(
                            sbdToolTip,
                            new []
                            {
                                Improvement.ImprovementType.SpellResistance,
                                Improvement.ImprovementType.ManaIllusionResist
                            },
                            strSpace,
                            intModifiers);
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public int SpellDefenseIllusionPhysical => LOG.TotalValue + INT.TotalValue
                                                                  + (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                                                      + ImprovementManager.ValueOf(this, Improvement.ImprovementType.PhysicalIllusionResist)).StandardRound();

        public string DisplaySpellDefenseIllusionPhysical => CurrentCounterspellingDice == 0
            ? SpellDefenseIllusionPhysical.ToString(GlobalSettings.CultureInfo)
            : SpellDefenseIllusionPhysical.ToString(GlobalSettings.CultureInfo) +
              LanguageManager.GetString("String_Space") + '(' +
              (SpellDefenseIllusionPhysical + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo) + ')';

        public string SpellDefenseIllusionPhysicalToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(LOG.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(LOG.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(INT.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(INT.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                    if (CurrentCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                  .Append('(').Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');

                    int intModifiers = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                        + ImprovementManager.ValueOf(
                                            this, Improvement.ImprovementType.PhysicalIllusionResist)).StandardRound();

                    if (intModifiers != 0)
                    {
                        FormatImprovementModifiers(
                            sbdToolTip,
                            new []
                            {
                                Improvement.ImprovementType.SpellResistance,
                                Improvement.ImprovementType.PhysicalIllusionResist
                            },
                            strSpace,
                            intModifiers);
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public int SpellDefenseManipulationMental => LOG.TotalValue + WIL.TotalValue
                                                                    + (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                                                        + ImprovementManager.ValueOf(this, Improvement.ImprovementType.MentalManipulationResist)).StandardRound();

        public string DisplaySpellDefenseManipulationMental => CurrentCounterspellingDice == 0
            ? SpellDefenseManipulationMental.ToString(GlobalSettings.CultureInfo)
            : SpellDefenseManipulationMental.ToString(GlobalSettings.CultureInfo) +
              LanguageManager.GetString("String_Space") + '(' +
              (SpellDefenseManipulationMental + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo) + ')';

        public string SpellDefenseManipulationMentalToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(LOG.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(LOG.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                    if (CurrentCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                  .Append('(').Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');

                    int intModifiers = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                        + ImprovementManager.ValueOf(
                                            this, Improvement.ImprovementType.MentalManipulationResist))
                        .StandardRound();

                    if (intModifiers != 0)
                    {
                        FormatImprovementModifiers(
                            sbdToolTip,
                            new []
                            {
                                Improvement.ImprovementType.SpellResistance,
                                Improvement.ImprovementType.MentalManipulationResist
                            },
                            strSpace,
                            intModifiers);
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public int SpellDefenseManipulationPhysical
        {
            get
            {
                int intAttributes = 0;
                if (IsAI)
                {
                    if (HomeNode is Vehicle objVehicle)
                        intAttributes = objVehicle.TotalBody * 2;
                }
                else
                    intAttributes = BOD.TotalValue + STR.TotalValue;

                return intAttributes +
                       (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance) +
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.PhysicalManipulationResist))
                       .StandardRound();
            }
        }

        public string DisplaySpellDefenseManipulationPhysical => CurrentCounterspellingDice == 0
            ? SpellDefenseManipulationPhysical.ToString(GlobalSettings.CultureInfo)
            : SpellDefenseManipulationPhysical.ToString(GlobalSettings.CultureInfo) +
              LanguageManager.GetString("String_Space") + '(' +
              (SpellDefenseManipulationPhysical + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo) + ')';

        public string SpellDefenseManipulationPhysicalToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                int intBody;
                int intStrength;
                string strBodyAbbrev;
                string strStrengthAbbrev;
                if(IsAI)
                {
                    intBody = intStrength = (HomeNode is Vehicle objVehicle ? objVehicle.TotalBody : 0);
                    strBodyAbbrev = strStrengthAbbrev = LanguageManager.GetString("String_VehicleBody");
                }
                else
                {
                    intBody = BOD.TotalValue;
                    intStrength = STR.TotalValue;
                    strBodyAbbrev = BOD.DisplayAbbrev;
                    strStrengthAbbrev = STR.DisplayAbbrev;
                }

                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(strBodyAbbrev).Append(strSpace).Append('(')
                              .Append(intBody.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(strStrengthAbbrev).Append(strSpace).Append('(')
                              .Append(intStrength.ToString(GlobalSettings.CultureInfo)).Append(')');

                    if (CurrentCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                  .Append('(').Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');

                    int intModifiers = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance) +
                                        ImprovementManager.ValueOf(
                                            this, Improvement.ImprovementType.PhysicalManipulationResist))
                        .StandardRound();

                    if (intModifiers != 0)
                    {
                        FormatImprovementModifiers(
                            sbdToolTip,
                            new []
                            {
                                Improvement.ImprovementType.SpellResistance,
                                Improvement.ImprovementType.PhysicalManipulationResist
                            },
                            strSpace,
                            intModifiers);
                    }

                    return sbdToolTip.ToString();
                }
            }
        }
        #endregion

        /// <summary>
        /// Custom Drugs created by the character.
        /// </summary>
        public EnhancedObservableCollection<Drug> Drugs => _lstDrugs;

        #region Condition Monitors

        /// <summary>
        /// Number of Physical Condition Monitor boxes.
        /// </summary>
        public int PhysicalCM
        {
            get
            {
                int intCMPhysical = 8;
                if(IsAI)
                {
                    if(HomeNode is Vehicle objVehicle)
                    {
                        return objVehicle.PhysicalCM;
                    }
                    if (DEP != null)
                    // A.I.s use Core Condition Monitors instead of Physical Condition Monitors if they are not in a vehicle or drone.
                        intCMPhysical += (DEP.TotalValue + 1) / 2;
                }
                else
                {
                    if (BOD != null)
                        intCMPhysical += (BOD.TotalValue + 1) / 2;
                }

                // Include Improvements in the Condition Monitor values.
                intCMPhysical += ImprovementManager.ValueOf(this, Improvement.ImprovementType.PhysicalCM).StandardRound();
                return intCMPhysical;
            }
        }

        public string PhysicalCMLabelText
        {
            get
            {
                return IsAI
                    ? LanguageManager.GetString(HomeNode is Vehicle ? "Label_OtherPhysicalCM" : "Label_OtherCoreCM")
                    : LanguageManager.GetString("Label_OtherPhysicalCM");
            }
        }

        public string PhysicalCMToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                string strModifiers = LanguageManager.GetString("Tip_Modifiers");
                string strCM;
                int intBonus;
                if(IsAI)
                {
                    if(HomeNode is Vehicle objVehicleHomeNode)
                    {
                        strCM = objVehicleHomeNode.BasePhysicalBoxes.ToString(GlobalSettings.CultureInfo) + strSpace +
                                '+' + strSpace + '(' + BOD.DisplayAbbrev + '' + 2.ToString(GlobalSettings.CultureInfo) +
                                ')' + strSpace + '(' +
                                ((objVehicleHomeNode.TotalBody + 1) / 2).ToString(GlobalSettings.CultureInfo) + ')';

                        intBonus = objVehicleHomeNode.Mods.Sum(objMod => objMod.ConditionMonitor);
                        if(intBonus != 0)
                            strCM += strSpace + '+' + strSpace + strModifiers + strSpace + '(' + intBonus.ToString(GlobalSettings.CultureInfo) + ')';
                    }
                    else
                    {
                        strCM = 8.ToString(GlobalSettings.CultureInfo) + strSpace + '+' + strSpace + '(' +
                                DEP.DisplayAbbrev + '' + 2.ToString(GlobalSettings.CultureInfo) + ')' + strSpace + '(' +
                                ((DEP.TotalValue + 1) / 2).ToString(GlobalSettings.CultureInfo) + ')';

                        intBonus = ImprovementManager.ValueOf(this, Improvement.ImprovementType.PhysicalCM).StandardRound();
                        if(intBonus != 0)
                            strCM += strSpace + '+' + strSpace + strModifiers + strSpace + '(' + intBonus.ToString(GlobalSettings.CultureInfo) + ')';
                    }
                }
                else
                {
                    strCM = 8.ToString(GlobalSettings.CultureInfo) + strSpace + '+' + strSpace + '(' +
                            BOD.DisplayAbbrev + '' + 2.ToString(GlobalSettings.CultureInfo) + ')' + strSpace + '(' +
                            ((BOD.TotalValue + 1) / 2).ToString(GlobalSettings.CultureInfo) + ')';

                    intBonus = ImprovementManager.ValueOf(this, Improvement.ImprovementType.PhysicalCM).StandardRound();
                    if(intBonus != 0)
                        strCM += strSpace + '+' + strSpace + strModifiers + strSpace + '(' + intBonus.ToString(GlobalSettings.CultureInfo) + ')';
                }

                return strCM;
            }
        }

        /// <summary>
        /// Number of Stun Condition Monitor boxes.
        /// </summary>
        public int StunCM
        {
            get
            {
                int intCMStun = 0;
                if(IsAI)
                {
                    // A.I. do not have a Stun Condition Monitor, but they do have a Matrix Condition Monitor if they are in their home node.
                    if(HomeNode != null)
                    {
                        intCMStun = HomeNode.MatrixCM;
                    }
                }
                else
                {
                    intCMStun = 8 + (WIL.TotalValue + 1) / 2;
                    // Include Improvements in the Condition Monitor values.
                    intCMStun += ImprovementManager.ValueOf(this, Improvement.ImprovementType.StunCM).StandardRound();
                }

                return intCMStun;
            }
        }

        public bool StunCMVisible => !IsAI || HomeNode != null;

        public string StunCMLabelText
        {
            get
            {
                if(IsAI)
                {
                    return HomeNode == null ? string.Empty : LanguageManager.GetString("Label_OtherMatrixCM");
                }
                return LanguageManager.GetString("Label_OtherStunCM");
            }
        }

        public string StunCMToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                string strModifiers = LanguageManager.GetString("Tip_Modifiers");
                string strCM;
                int intBonus;
                if (IsAI)
                {
                    if (HomeNode == null)
                        return string.Empty;
                    strCM = 8.ToString(GlobalSettings.CultureInfo) + strSpace + '+' + strSpace + '(' +
                            LanguageManager.GetString("String_DeviceRating") + '' +
                            2.ToString(GlobalSettings.CultureInfo) + ')' + strSpace + '(' +
                            ((HomeNode.GetTotalMatrixAttribute("Device Rating") + 1) / 2).ToString(GlobalSettings
                                .CultureInfo) + ')';

                    intBonus = HomeNode.TotalBonusMatrixBoxes;
                    if (intBonus != 0)
                        strCM += strSpace + '+' + strSpace + strModifiers + strSpace + '(' +
                                 intBonus.ToString(GlobalSettings.CultureInfo) + ')';
                }
                else
                {
                    strCM = 8.ToString(GlobalSettings.CultureInfo) + strSpace + '+' + strSpace + '(' +
                            WIL.DisplayAbbrev + '' + 2.ToString(GlobalSettings.CultureInfo) + ')' + strSpace + '(' +
                            ((WIL.TotalValue + 1) / 2).ToString(GlobalSettings.CultureInfo) + ')';

                    intBonus = ImprovementManager.ValueOf(this, Improvement.ImprovementType.StunCM).StandardRound();
                    if (intBonus != 0)
                        strCM += strSpace + '+' + strSpace + strModifiers + strSpace + '(' +
                                 intBonus.ToString(GlobalSettings.CultureInfo) + ')';
                }

                return strCM;
            }
        }

        /// <summary>
        /// Number of Condition Monitor boxes are needed to reach a Condition Monitor Threshold.
        /// </summary>
        public int CMThreshold
        {
            get
            {
                int intCMThreshold = 3 + ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMThreshold).StandardRound();
                return intCMThreshold;
            }
        }

        /// <summary>
        /// Returns PhysicalCMThresholdOffset and StunCMThresholdOffset as a pair.
        /// </summary>
        public Tuple<int, int> CMThresholdOffsets =>
            new Tuple<int, int>(PhysicalCMThresholdOffset, StunCMThresholdOffset);

        /// <summary>
        /// Number of additional boxes appear before the first Physical Condition Monitor penalty.
        /// </summary>
        public int PhysicalCMThresholdOffset
        {
            get
            {
                if (ImprovementManager
                    .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.IgnoreCMPenaltyPhysical).Count
                    > 0)
                    return int.MaxValue;
                if (IsAI || ImprovementManager
                            .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.IgnoreCMPenaltyStun)
                            .Count > 0)
                    return (ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMThresholdOffset) +
                            ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMSharedThresholdOffset))
                        .StandardRound();

                decimal decCMThresholdOffset =
                    ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMThresholdOffset);
                // We're subtracting CM Threshold from the amount of CM boxes filled because you only need to ignore wounds up to your first wound threshold, not all wounds
                decimal decCMSharedThresholdOffset = decCMThresholdOffset +
                                                 ImprovementManager.ValueOf(this,
                                                     Improvement.ImprovementType.CMSharedThresholdOffset) -
                                                 Math.Max(StunCMFilled - CMThreshold - decCMThresholdOffset, 0);
                return Math.Max(decCMThresholdOffset, decCMSharedThresholdOffset).StandardRound();
            }
        }

        /// <summary>
        /// Number of additional boxes appear before the first Stun Condition Monitor penalty.
        /// </summary>
        public int StunCMThresholdOffset
        {
            get
            {
                // A.I.s don't get wound penalties from Matrix damage
                if(IsAI)
                    return int.MaxValue;
                if (ImprovementManager
                    .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.IgnoreCMPenaltyStun)
                    .Count > 0)
                    return int.MaxValue;
                if (ImprovementManager
                    .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.IgnoreCMPenaltyPhysical).Count
                    > 0)
                    return (ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMThresholdOffset) +
                            ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMSharedThresholdOffset))
                        .StandardRound();

                decimal decCMThresholdOffset =
                    ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMThresholdOffset);
                // We're subtracting CM Threshold from the amount of CM boxes filled because you only need to ignore wounds up to your first wound threshold, not all wounds
                decimal decCMSharedThresholdOffset = decCMThresholdOffset +
                                                 ImprovementManager.ValueOf(this,
                                                     Improvement.ImprovementType.CMSharedThresholdOffset) -
                                                 Math.Max(PhysicalCMFilled - CMThreshold - decCMThresholdOffset, 0);
                return Math.Max(decCMThresholdOffset, decCMSharedThresholdOffset).StandardRound();
            }
        }

        /// <summary>
        /// Number of Overflow Condition Monitor boxes.
        /// </summary>
        public int CMOverflow
        {
            get
            {
                int intCMOverflow = 0;
                // A.I. do not have an Overflow Condition Monitor.
                if(!IsAI)
                {
                    // Characters get a number of overflow boxes equal to their BOD (plus any Improvements). One more boxes is added to mark the character as dead.
                    intCMOverflow = BOD.TotalValue +
                                    ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMOverflow).StandardRound() + 1;
                }

                return intCMOverflow;
            }
        }

        #endregion

        #region Build Properties

        /// <summary>
        /// Method being used to build the character.
        /// </summary>
        public CharacterBuildMethod EffectiveBuildMethod => IsCritter ? CharacterBuildMethod.Karma : Settings.BuildMethod;

        public bool EffectiveBuildMethodUsesPriorityTables => EffectiveBuildMethod.UsesPriorityTables();

        public bool EffectiveBuildMethodIsLifeModule => EffectiveBuildMethod == CharacterBuildMethod.LifeModule;

        public bool EnableAutomaticStoryButton => EffectiveBuildMethodIsLifeModule && Settings.AutomaticBackstory;

        /// <summary>
        /// Amount of Nuyen the character has.
        /// </summary>
        public decimal Nuyen
        {
            get => _decNuyen;
            set
            {
                if(_decNuyen != value)
                {
                    _decNuyen = value;
                    OnPropertyChanged();
                }
            }
        }

        public decimal StolenNuyen
        {
            get => _decStolenNuyen;
            set
            {
                if (_decStolenNuyen != value)
                {
                    _decStolenNuyen = value;
                    OnPropertyChanged();
                }
            }
        }

        public string DisplayNuyen => Nuyen.ToString(Settings.NuyenFormat, GlobalSettings.CultureInfo) + '';

        public string DisplayStolenNuyen => StolenNuyen.ToString(Settings.NuyenFormat, GlobalSettings.CultureInfo) + '';

        /// <summary>
        /// Amount of Nuyen the character started with via the priority system.
        /// </summary>
        public decimal StartingNuyen
        {
            get => _decStartingNuyen;
            set
            {
                if(_decStartingNuyen != value)
                {
                    _decStartingNuyen = value;
                    OnPropertyChanged();
                }
            }
        }

        private decimal _decCachedTotalStartingNuyen = decimal.MinValue;

        public decimal TotalStartingNuyen
        {
            get
            {
                if (_decCachedTotalStartingNuyen == decimal.MinValue)
                {
                    decimal decFromKarma = CalculateStartingNuyenFromKarma(Math.Min(NuyenBP, TotalNuyenMaximumBP), StartingNuyen);
                    _decCachedTotalStartingNuyen = decFromKarma +
                                                   ImprovementManager.ValueOf(this, Improvement.ImprovementType.Nuyen) -
                                                   ImprovementManager.ValueOf(this, Improvement.ImprovementType.Nuyen
                                                       , strImprovedName: "Stolen");
                }

                return _decCachedTotalStartingNuyen;
            }
        }

        private decimal CalculateStartingNuyenFromKarma(decimal decKarma, decimal decStartingNuyen)
        {
            decimal decFromKarma = 0.0m;
            string strExpression = Settings.ChargenKarmaToNuyenExpression
                .Replace("{Karma}", decKarma.ToString(GlobalSettings.InvariantCultureInfo))
                .Replace("{PriorityNuyen}", decStartingNuyen.ToString(GlobalSettings.InvariantCultureInfo));
            if (strExpression.IndexOfAny('{', '+', '-', '*', ',') != -1 || strExpression.Contains("div"))
            {
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdValue))
                {
                    sbdValue.Append(strExpression);
                    AttributeSection.ProcessAttributesInXPath(sbdValue, strExpression);

                    // This is first converted to a decimal and rounded up since some items have a multiplier that is not a whole number, such as 2.5.
                    object objProcess =
                        CommonFunctions.EvaluateInvariantXPath(sbdValue.ToString(), out bool blnIsSuccess);
                    if (blnIsSuccess)
                        decFromKarma = Convert.ToDecimal((double) objProcess);
                }
            }
            else
                decimal.TryParse(strExpression, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                    out decFromKarma);
            return decFromKarma;
        }

        public string DisplayTotalStartingNuyen =>
            '=' + LanguageManager.GetString("String_Space") +
            TotalStartingNuyen.ToString(Settings.NuyenFormat, GlobalSettings.CultureInfo) + '';

        /// <summary>
        /// Number of Build Points put into Nuyen.
        /// </summary>
        public decimal NuyenBP
        {
            get => _decNuyenBP;
            set
            {
                decimal decNewValue = Math.Max(Math.Min(value, TotalNuyenMaximumBP), 0);
                if(_decNuyenBP != decNewValue)
                {
                    _decNuyenBP = decNewValue;
                    OnPropertyChanged();
                }
            }
        }

        public decimal TotalNuyenMaximumBP
        {
            get
            {
                const decimal decMaxValue = int.MaxValue;
                // If UnrestrictedNuyen is enabled, return the maximum possible value
                if(IgnoreRules || Settings.UnrestrictedNuyen)
                {
                    return decMaxValue;
                }

                return Math.Max(Math.Min(decMaxValue,
                    Settings.NuyenMaximumBP + ImprovementManager.ValueOf(this, Improvement.ImprovementType.NuyenMaxBP)), 0);
            }
        }

        /// <summary>
        /// The calculated Astral Limit.
        /// </summary>
        public int LimitAstral => Math.Max(LimitMental, LimitSocial);

        public string LimitAstralToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                return string.Concat(LanguageManager.GetString("Label_Options_Maximum"),
                    strSpace, "(", LanguageManager.GetString("String_LimitMentalShort"),
                    strSpace, "[", LimitMental.ToString(GlobalSettings.CultureInfo), "],",
                    strSpace, LanguageManager.GetString("String_LimitSocialShort"),
                    strSpace, "[", LimitSocial.ToString(GlobalSettings.CultureInfo), "])");
            }
        }

        /// <summary>
        /// The calculated Physical Limit.
        /// </summary>
        public int LimitPhysical
        {
            get
            {
                if(IsAI)
                {
                    Vehicle objHomeNodeVehicle = HomeNode as Vehicle;
                    return objHomeNodeVehicle?.Handling ?? 0;
                }

                int intLimit = (STR.TotalValue * 2 + BOD.TotalValue + REA.TotalValue + 2) / 3;
                return intLimit + ImprovementManager.ValueOf(this, Improvement.ImprovementType.PhysicalLimit).StandardRound();
            }
        }

        public string LimitPhysicalToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                if(IsAI)
                {
                    Vehicle objHomeNodeVehicle = HomeNode as Vehicle;
                    return string.Concat(LanguageManager.GetString("String_Handling"),
                        strSpace, "[", (objHomeNodeVehicle?.Handling ?? 0).ToString(GlobalSettings.CultureInfo), "]");
                }

                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append('(').Append(STR.DisplayAbbrev).Append(strSpace).Append('[')
                              .Append(STR.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(']').Append(strSpace)
                              .Append('').Append(strSpace).Append(2.ToString(GlobalSettings.CultureInfo))
                              .Append(strSpace).Append('+').Append(strSpace).Append(BOD.DisplayAbbrev).Append(strSpace)
                              .Append('[').Append(BOD.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(']')
                              .Append(strSpace).Append('+').Append(strSpace).Append(REA.DisplayAbbrev).Append(strSpace)
                              .Append('[').Append(REA.TotalValue.ToString(GlobalSettings.CultureInfo)).Append("])")
                              .Append(strSpace).Append('/').Append(strSpace)
                              .Append(3.ToString(GlobalSettings.CultureInfo));
                    foreach (Improvement objLoopImprovement in ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.PhysicalLimit))
                    {
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                  .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');
                    }
                    return sbdToolTip.ToString();
                }
            }
        }

        /// <summary>
        /// The calculated Mental Limit.
        /// </summary>
        public int LimitMental
        {
            get
            {
                int intLimit = (LOG.TotalValue * 2 + INT.TotalValue + WIL.TotalValue + 2) / 3;
                if(IsAI && HomeNode != null)
                {
                    if(HomeNode is Vehicle objHomeNodeVehicle)
                    {
                        int intHomeNodeSensor = objHomeNodeVehicle.CalculatedSensor;
                        if(intHomeNodeSensor > intLimit)
                        {
                            intLimit = intHomeNodeSensor;
                        }
                    }

                    int intHomeNodeDP = HomeNode.GetTotalMatrixAttribute("Data Processing");
                    if(intHomeNodeDP > intLimit)
                    {
                        intLimit = intHomeNodeDP;
                    }
                }

                return intLimit + ImprovementManager.ValueOf(this, Improvement.ImprovementType.MentalLimit).StandardRound();
            }
        }

        public string LimitMentalToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append('(').Append(LOG.DisplayAbbrev).Append(strSpace).Append('[')
                              .Append(LOG.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(']').Append(strSpace)
                              .Append('').Append(strSpace).Append(2.ToString(GlobalSettings.CultureInfo))
                              .Append(strSpace).Append('+').Append(strSpace).Append(INT.DisplayAbbrev).Append(strSpace)
                              .Append('[').Append(INT.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(']')
                              .Append(strSpace).Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace)
                              .Append('[').Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append("])")
                              .Append(strSpace).Append('/').Append(strSpace)
                              .Append(3.ToString(GlobalSettings.CultureInfo));

                    if (IsAI && HomeNode != null)
                    {
                        int intLimit = (LOG.TotalValue * 2 + INT.TotalValue + WIL.TotalValue + 2) / 3;
                        if (HomeNode is Vehicle objHomeNodeVehicle)
                        {
                            int intHomeNodeSensor = objHomeNodeVehicle.CalculatedSensor;
                            if (intHomeNodeSensor > intLimit)
                            {
                                intLimit = intHomeNodeSensor;
                                sbdToolTip.Clear();
                                sbdToolTip.Append(LanguageManager.GetString("String_Sensor")).Append(strSpace)
                                          .Append('[').Append(intLimit.ToString(GlobalSettings.CultureInfo))
                                          .Append(']');
                            }
                        }

                        int intHomeNodeDP = HomeNode.GetTotalMatrixAttribute("Data Processing");
                        if (intHomeNodeDP > intLimit)
                        {
                            intLimit = intHomeNodeDP;
                            sbdToolTip.Clear();
                            sbdToolTip.Append(LanguageManager.GetString("String_DataProcessing")).Append(strSpace)
                                      .Append('[').Append(intLimit.ToString(GlobalSettings.CultureInfo))
                                      .Append(']');
                        }
                    }

                    foreach (Improvement objLoopImprovement in ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.MentalLimit))
                    {
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                  .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        /// <summary>
        /// The calculated Social Limit.
        /// </summary>
        public int LimitSocial
        {
            get
            {
                int intLimit;
                if(IsAI && HomeNode != null)
                {
                    int intHomeNodeDP = HomeNode.GetTotalMatrixAttribute("Data Processing");

                    if(HomeNode is Vehicle objHomeNodeVehicle)
                    {
                        int intHomeNodePilot = objHomeNodeVehicle.Pilot;
                        if(intHomeNodePilot > intHomeNodeDP)
                            intHomeNodeDP = intHomeNodePilot;
                    }

                    intLimit = (CHA.TotalValue + intHomeNodeDP + WIL.TotalValue + Essence().StandardRound() + 2) / 3;
                }
                else
                {
                    intLimit = (CHA.TotalValue * 2 + WIL.TotalValue + Essence().StandardRound() + 2) / 3;
                }

                return intLimit + ImprovementManager.ValueOf(this, Improvement.ImprovementType.SocialLimit).StandardRound();
            }
        }

        public string LimitSocialToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append('(').Append(CHA.DisplayAbbrev).Append(strSpace).Append('[')
                              .Append(CHA.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(']');
                    if (IsAI && HomeNode != null)
                    {
                        int intHomeNodeDP = HomeNode.GetTotalMatrixAttribute("Data Processing");
                        string strDPString = LanguageManager.GetString("String_DataProcessing");
                        if (HomeNode is Vehicle objHomeNodeVehicle)
                        {
                            int intHomeNodePilot = objHomeNodeVehicle.Pilot;
                            if (intHomeNodePilot > intHomeNodeDP)
                            {
                                intHomeNodeDP = intHomeNodePilot;
                                strDPString = LanguageManager.GetString("String_Pilot");
                            }
                        }

                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace).Append(strDPString).Append(strSpace)
                                  .Append('[').Append(intHomeNodeDP.ToString(GlobalSettings.CultureInfo)).Append(']');
                    }
                    else
                    {
                        sbdToolTip.Append(strSpace).Append('').Append(strSpace)
                                  .Append(2.ToString(GlobalSettings.CultureInfo));
                    }

                    sbdToolTip.Append(strSpace).Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace)
                              .Append('[').Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(']')
                              .Append(strSpace).Append('+').Append(strSpace).Append(ESS.DisplayAbbrev).Append(strSpace)
                              .Append('[').Append(DisplayEssence).Append("])").Append(strSpace).Append('/')
                              .Append(strSpace)
                              .Append(3.ToString(GlobalSettings.CultureInfo));

                    foreach (Improvement objLoopImprovement in ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.SocialLimit))
                    {
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                  .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public bool HasMentorSpirit => MentorSpirits.Count > 0;

        public string FirstMentorSpiritDisplayName => MentorSpirits.Count > 0
            ? MentorSpirits[0].DisplayNameShort(GlobalSettings.Language)
            : string.Empty;

        public string FirstMentorSpiritDisplayInformation
        {
            get
            {
                if(MentorSpirits.Count == 0)
                    return string.Empty;

                MentorSpirit objMentorSpirit = MentorSpirits[0];
                string strSpace = LanguageManager.GetString("String_Space");
                return (LanguageManager.GetString("Label_SelectMentorSpirit_Advantage") + strSpace
                    + objMentorSpirit.DisplayAdvantage(GlobalSettings.Language)
                    + Environment.NewLine + Environment.NewLine
                    + LanguageManager.GetString("Label_SelectMetamagic_Disadvantage") + strSpace
                    + objMentorSpirit.DisplayDisadvantage(GlobalSettings.Language)).WordWrap();
            }
        }

        #endregion

        #region Metatype/Metavariant Information

        /// <summary>
        /// Character's Metatype.
        /// </summary>
        public string Metatype
        {
            get => _strMetatype;
            set
            {
                if(_strMetatype != value)
                {
                    _strMetatype = value;
                    OnPropertyChanged();
                }
            }
        }

        public Guid MetatypeGuid
        {
            get => _guiMetatype;
            set => _guiMetatype = value;
        }

        /// <summary>
        /// The name of the metatype as it should appear on printouts (translated name only).
        /// </summary>
        public string DisplayMetatype(string strLanguage)
        {
            if (strLanguage.Equals(GlobalSettings.DefaultLanguage, StringComparison.OrdinalIgnoreCase))
                return Metatype;

            return GetNodeXPath(true, strLanguage)?.SelectSingleNodeAndCacheExpression("translate")?.Value ?? Metatype;
        }

        /// <summary>
        /// Character's Metavariant.
        /// </summary>
        public string Metavariant
        {
            get => _strMetavariant;
            set
            {
                if(_strMetavariant != value)
                {
                    _strMetavariant = value;
                    OnPropertyChanged();
                }
            }
        }

        public Guid MetavariantGuid
        {
            get => _guiMetavariant;
            set => _guiMetavariant = value;
        }

        /// <summary>
        /// The name of the metatype as it should appear on printouts (translated name only).
        /// </summary>
        public string DisplayMetavariant(string strLanguage)
        {
            if (strLanguage.Equals(GlobalSettings.DefaultLanguage, StringComparison.OrdinalIgnoreCase))
                return Metavariant;

            return GetNodeXPath(false, strLanguage)?.SelectSingleNodeAndCacheExpression("translate")?.Value ?? Metavariant;
        }

        public string FormattedMetatype => FormattedMetatypeMethod(GlobalSettings.Language);
        /// <summary>
        /// The metatype, including metavariant if any, in an appropriate language.
        /// </summary>
        /// <param name="strLanguage">Language to be used. Defaults to GlobalSettings.Language</param>
        /// <returns></returns>
        public string FormattedMetatypeMethod(string strLanguage = "")
        {
            if (string.IsNullOrEmpty(strLanguage))
                strLanguage = GlobalSettings.Language;
            string strMetatype = DisplayMetatype(strLanguage);

            if (MetavariantGuid != Guid.Empty)
            {
                strMetatype += LanguageManager.GetString("String_Space") + '(' + DisplayMetavariant(strLanguage) + ')';
            }

            return strMetatype;
        }

        /// <summary>
        /// Metatype Category.
        /// </summary>
        public string MetatypeCategory
        {
            get => _strMetatypeCategory;
            set
            {
                if(_strMetatypeCategory != value)
                {
                    bool blnDoCyberzombieRefresh = _strMetatypeCategory == "Cyberzombie" || value == "Cyberzombie";
                    _strMetatypeCategory = value;
                    OnPropertyChanged();
                    if(blnDoCyberzombieRefresh)
                        RefreshEssenceLossImprovements();
                }
            }
        }

        public int LimbCount(string strLimbSlot = "")
        {
            if(string.IsNullOrEmpty(strLimbSlot))
            {
                return Settings.LimbCount + ImprovementManager.ValueOf(this, Improvement.ImprovementType.AddLimb).StandardRound();
            }

            int intReturn =
                1 + ImprovementManager.ValueOf(this, Improvement.ImprovementType.AddLimb, false, strLimbSlot).StandardRound();
            if(strLimbSlot == "arm" || strLimbSlot == "leg")
                ++intReturn;
            return intReturn;
        }

        public string DisplayMovement => GetMovement(GlobalSettings.CultureInfo, GlobalSettings.Language);

        /// <summary>
        /// Character's Movement rate (Culture-dependent).
        /// </summary>
        public string GetMovement(CultureInfo objCulture, string strLanguage)
        {
            // Don't attempt to do anything if the character's Movement is "Special" (typically for A.I.s).
            return Movement == "Special"
                ? LanguageManager.GetString("String_ModeSpecial", strLanguage)
                : CalculatedMovement("Ground", true, objCulture, strLanguage);
        }

        /// <summary>
        /// Character's Movement rate data string.
        /// </summary>
        public string Movement
        {
            get
            {
                if(string.IsNullOrWhiteSpace(_strMovement))
                {
                    _strMovement = this.GetNodeXPath().SelectSingleNodeAndCacheExpression("movement")?.Value
                                   ?? GetNodeXPath(true).SelectSingleNodeAndCacheExpression("movement")?.Value
                                   ?? string.Empty;
                }

                return _strMovement;
            }
            set
            {
                if(_strMovement != value)
                {
                    _strMovement = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Run rate data string.
        /// </summary>
        public string RunString
        {
            get
            {
                if(string.IsNullOrWhiteSpace(_strRun))
                {
                    _strRun = this.GetNodeXPath().SelectSingleNodeAndCacheExpression("run")?.Value
                              ?? GetNodeXPath(true).SelectSingleNodeAndCacheExpression("run")?.Value
                              ?? string.Empty;
                }

                return _strRun;
            }
            set
            {
                if(_strRun != value)
                {
                    _strRun = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Alternate Run rate data string.
        /// </summary>
        public string RunAltString
        {
            get
            {
                if(string.IsNullOrWhiteSpace(_strRunAlt))
                {
                    _strRunAlt = this.GetNodeXPath().SelectSingleNodeAndCacheExpression("run")?.GetAttribute("alt", string.Empty)
                                 ?? GetNodeXPath(true).SelectSingleNodeAndCacheExpression("run")?.GetAttribute("alt", string.Empty)
                                 ?? string.Empty;
                }

                return _strRunAlt;
            }
            set
            {
                if(_strRunAlt != value)
                {
                    _strRunAlt = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Walk rate data string.
        /// </summary>
        public string WalkString
        {
            get
            {
                if(string.IsNullOrWhiteSpace(_strWalk))
                {
                    _strWalk = this.GetNodeXPath().SelectSingleNodeAndCacheExpression("walk")?.Value
                               ?? GetNodeXPath(true).SelectSingleNodeAndCacheExpression("walk")?.Value
                               ?? string.Empty;
                }

                return _strWalk;
            }
            set
            {
                if(_strWalk != value)
                {
                    _strWalk = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Alternate Walk rate data string.
        /// </summary>
        public string WalkAltString
        {
            get
            {
                if(string.IsNullOrWhiteSpace(_strWalkAlt))
                {
                    _strWalkAlt = this.GetNodeXPath().SelectSingleNodeAndCacheExpression("walk")?.GetAttribute("alt", string.Empty)
                                  ?? GetNodeXPath(true).SelectSingleNodeAndCacheExpression("walk")?.GetAttribute("alt", string.Empty)
                                  ?? string.Empty;
                }

                return _strWalkAlt;
            }
            set
            {
                if(_strWalkAlt != value)
                {
                    _strWalkAlt = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Sprint rate data string.
        /// </summary>
        public string SprintString
        {
            get
            {
                if(string.IsNullOrWhiteSpace(_strSprint))
                {
                    _strSprint = this.GetNodeXPath().SelectSingleNodeAndCacheExpression("sprint")?.Value
                                 ?? GetNodeXPath(true).SelectSingleNodeAndCacheExpression("sprint")?.Value
                                 ?? string.Empty;
                }

                return _strSprint;
            }
            set
            {
                if(_strSprint != value)
                {
                    _strSprint = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Alternate Sprint rate data string.
        /// </summary>
        public string SprintAltString
        {
            get
            {
                if(string.IsNullOrWhiteSpace(_strSprintAlt))
                {
                    _strSprintAlt = this.GetNodeXPath().SelectSingleNodeAndCacheExpression("sprint")?.GetAttribute("alt", string.Empty)
                                    ?? GetNodeXPath(true).SelectSingleNodeAndCacheExpression("sprint")?.GetAttribute("alt", string.Empty)
                                    ?? string.Empty;
                }

                return _strSprintAlt;
            }
            set
            {
                if(_strSprintAlt != value)
                {
                    _strSprintAlt = value;
                    OnPropertyChanged();
                }
            }
        }

        public string CurrentWalkingRateString =>
            AttributeSection.AttributeCategory == CharacterAttrib.AttributeCategory.Standard
                ? WalkString
                : WalkAltString;

        public string CurrentRunningRateString =>
            AttributeSection.AttributeCategory == CharacterAttrib.AttributeCategory.Standard
                ? RunString
                : RunAltString;

        public string CurrentSprintingRateString =>
            AttributeSection.AttributeCategory == CharacterAttrib.AttributeCategory.Standard
                ? SprintString
                : SprintAltString;

        /// <summary>
        /// Character's running Movement rate.
        /// <param name="strType">Takes one of three parameters: Ground, 2 for Swim, 3 for Fly. Returns 0 if the requested type isn't found.</param>
        /// </summary>
        public decimal WalkingRate(string strType = "Ground")
        {
            decimal decTmp = decimal.MinValue;
            foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.WalkSpeed, strType))
                decTmp = Math.Max(decTmp, objImprovement.Value);

            if(decTmp != decimal.MinValue)
                return decTmp;

            int intIndexToGet = 0;
            switch (strType)
            {
                case "Fly":
                    intIndexToGet = 2;
                    break;
                case "Swim":
                    intIndexToGet = 1;
                    break;
            }

            string strReturn = CurrentWalkingRateString.SplitNoAlloc('/', StringSplitOptions.RemoveEmptyEntries)
                                                       .ElementAtOrDefault(intIndexToGet);
            if (strReturn != null)
                decimal.TryParse(strReturn, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                 out decTmp);
            return decTmp;
        }

        /// <summary>
        /// Character's running Movement rate.
        /// <param name="strType">Takes one of three parameters: Ground, 2 for Swim, 3 for Fly. Returns 0 if the requested type isn't found.</param>
        /// </summary>
        public decimal RunningRate(string strType = "Ground")
        {
            decimal decTmp = decimal.MinValue;
            foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.RunSpeed, strType))
                decTmp = Math.Max(decTmp, objImprovement.Value);

            if(decTmp != decimal.MinValue)
                return decTmp;

            int intIndexToGet = 0;
            switch (strType)
            {
                case "Fly":
                    intIndexToGet = 2;
                    break;
                case "Swim":
                    intIndexToGet = 1;
                    break;
            }

            string strReturn = CurrentRunningRateString.SplitNoAlloc('/', StringSplitOptions.RemoveEmptyEntries)
                                                       .ElementAtOrDefault(intIndexToGet);
            if (strReturn != null)
                decimal.TryParse(strReturn, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                 out decTmp);
            return decTmp;
        }

        /// <summary>
        /// Character's sprinting Movement rate (meters per hit).
        /// <param name="strType">Takes one of three parameters: Ground, 2 for Swim, 3 for Fly. Returns 0 if the requested type isn't found.</param>
        /// </summary>
        public decimal SprintingRate(string strType = "Ground")
        {
            decimal decTmp = decimal.MinValue;
            foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.SprintSpeed, strType))
                decTmp = Math.Max(decTmp, objImprovement.Value / 100.0m);

            if(decTmp != decimal.MinValue)
                return decTmp;

            int intIndexToGet = 0;
            switch(strType)
            {
                case "Fly":
                    intIndexToGet = 2;
                    break;
                case "Swim":
                    intIndexToGet = 1;
                    break;
            }

            string strReturn = CurrentSprintingRateString.SplitNoAlloc('/', StringSplitOptions.RemoveEmptyEntries)
                                                         .ElementAtOrDefault(intIndexToGet);
            if (strReturn != null)
                decimal.TryParse(strReturn, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                 out decTmp);
            return decTmp;
        }

        public string CalculatedMovement(string strMovementType, bool blnUseCyberlegs = false,
            CultureInfo objCulture = null, string strLanguage = "")
        {
            decimal decSprint = SprintingRate(strMovementType) +
                                ImprovementManager.ValueOf(this, Improvement.ImprovementType.SprintBonus, false,
                                    strMovementType) / 100.0m;
            decimal decRun = RunningRate(strMovementType) + ImprovementManager.ValueOf(this,
                                 Improvement.ImprovementType.RunMultiplier, false, strMovementType);
            decimal decWalk = WalkingRate(strMovementType) + ImprovementManager.ValueOf(this,
                                  Improvement.ImprovementType.WalkMultiplier, false, strMovementType);
            // Everything else after this just multiplies values, so zeroes can be checked for here
            if(decWalk == 0 && decRun == 0 && decSprint == 0)
            {
                return "0";
            }

            decSprint *= 1.0m + ImprovementManager.ValueOf(this, Improvement.ImprovementType.SprintBonusPercent, false,
                             strMovementType) / 100.0m;
            decRun *= 1.0m + ImprovementManager.ValueOf(this, Improvement.ImprovementType.RunMultiplierPercent, false,
                          strMovementType) / 100.0m;
            decWalk *= 1.0m + ImprovementManager.ValueOf(this, Improvement.ImprovementType.WalkMultiplierPercent, false,
                           strMovementType) / 100.0m;

            int intAGI = AGI.CalculatedTotalValue(false);
            int intSTR = STR.CalculatedTotalValue(false);
            if(Settings.CyberlegMovement && blnUseCyberlegs)
            {
                int intTempAGI = int.MaxValue;
                int intTempSTR = int.MaxValue;
                int intLegs = 0;
                foreach(Cyberware objCyber in Cyberware.Where(objCyber => objCyber.LimbSlot == "leg"))
                {
                    intLegs += objCyber.LimbSlotCount;
                    intTempAGI = Math.Min(intTempAGI, objCyber.TotalAgility);
                    intTempSTR = Math.Min(intTempSTR, objCyber.TotalStrength);
                }

                if(intTempAGI != int.MaxValue && intTempSTR != int.MaxValue && intLegs >= 2)
                {
                    intAGI = intTempAGI;
                    intSTR = intTempSTR;
                }
            }

            if (strMovementType == "Swim")
            {
                decWalk *= (intAGI + intSTR) * 0.5m;
                decRun *= (intAGI + intSTR) * 0.5m;
            }
            else
            {
                decWalk *= intAGI;
                decRun *= intAGI;
            }
            if (objCulture == null)
                objCulture = GlobalSettings.CultureInfo;
            string strReturn = string.Empty;
            if (decWalk != 0)
            {
                if (decRun != 0)
                    strReturn = decWalk.ToString("#,0.##", objCulture) + '/' + decRun.ToString("#,0.##", objCulture);
                else
                    strReturn = decWalk.ToString("#,0.##", objCulture);
            }
            else if (decRun != 0 || decSprint != 0)
                strReturn = decRun.ToString("#,0.##", objCulture);
            if (decSprint != 0)
            {
                if (!string.IsNullOrEmpty(strReturn))
                    strReturn += ',' + LanguageManager.GetString("String_Space", strLanguage);
                strReturn += decSprint.ToString("#,0.##", objCulture)
                             + LanguageManager.GetString("String_MetersPerHit", strLanguage);
            }
            return strReturn;
        }

        public string DisplaySwim => GetSwim(GlobalSettings.CultureInfo, GlobalSettings.Language);

        /// <summary>
        /// Character's Swim rate.
        /// </summary>
        public string GetSwim(CultureInfo objCulture, string strLanguage)
        {
            // Don't attempt to do anything if the character's Movement is "Special" (typically for A.I.s).
            return Movement == "Special"
                ? LanguageManager.GetString("String_ModeSpecial", strLanguage)
                : CalculatedMovement("Swim", false, objCulture, strLanguage);
        }

        public string DisplayFly => GetFly(GlobalSettings.CultureInfo, GlobalSettings.Language);

        /// <summary>
        /// Character's Fly rate.
        /// </summary>
        public string GetFly(CultureInfo objCulture, string strLanguage)
        {
            // Don't attempt to do anything if the character's Movement is "Special" (typically for A.I.s).
            return Movement == "Special"
                ? LanguageManager.GetString("String_ModeSpecial", strLanguage)
                : CalculatedMovement("Fly", false, objCulture, strLanguage);
        }

        /// <summary>
        /// Full Movement (Movement, Swim, and Fly) for printouts.
        /// </summary>
        private string FullMovement(CultureInfo objCulture, string strLanguage)
        {
            string strSpace = LanguageManager.GetString("String_Space");
            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdReturn))
            {
                string strGroundMovement = GetMovement(objCulture, strLanguage);
                string strSwimMovement = GetSwim(objCulture, strLanguage);
                string strFlyMovement = GetFly(objCulture, strLanguage);
                if (!string.IsNullOrEmpty(strGroundMovement) && strGroundMovement != "0")
                    sbdReturn.Append(strGroundMovement).Append(',').Append(strSpace);
                if (!string.IsNullOrEmpty(strSwimMovement) && strSwimMovement != "0")
                    sbdReturn.Append(LanguageManager.GetString("Label_OtherSwim", strLanguage)).Append(strSpace)
                             .Append(strSwimMovement).Append(',').Append(strSpace);
                if (!string.IsNullOrEmpty(strFlyMovement) && strFlyMovement != "0")
                    sbdReturn.Append(LanguageManager.GetString("Label_OtherFly", strLanguage)).Append(strSpace)
                             .Append(strFlyMovement).Append(',').Append(strSpace);

                // Remove the trailing ", ".
                if (sbdReturn.Length > 0)
                    sbdReturn.Length -= 2;

                return sbdReturn.ToString();
            }
        }

        /// <summary>
        /// BP cost of character's Metatype.
        /// </summary>
        public int MetatypeBP
        {
            get => _intMetatypeBP;
            set
            {
                if(_intMetatypeBP != value)
                {
                    _intMetatypeBP = value;
                    OnPropertyChanged();
                }
            }
        }
        /// <summary>
        /// MetatypeBP as a string, including Karma string and multiplied by options as relevant.
        /// TODO: Belongs in a viewmodel for frmCreate rather than the main character class?
        /// </summary>
        public string DisplayMetatypeBP
        {
            get
            {
                string s = string.Empty;
                switch (EffectiveBuildMethod)
                {
                    case CharacterBuildMethod.Karma:
                    case CharacterBuildMethod.LifeModule:
                        s = (MetatypeBP * Settings.MetatypeCostsKarmaMultiplier).ToString(GlobalSettings.CultureInfo);
                        break;
                    case CharacterBuildMethod.Priority:
                    case CharacterBuildMethod.SumtoTen:
                        s = (MetatypeBP).ToString(GlobalSettings.CultureInfo);
                        break;
                }

                s += LanguageManager.GetString("String_Space") + LanguageManager.GetString("String_Karma");
                return s;
            }
        }

        /// <summary>
        /// Whether or not the character is a non-Free Sprite.
        /// </summary>
        public bool IsSprite => MetatypeCategory.EndsWith("Sprites", StringComparison.Ordinal) && !IsFreeSprite;

        /// <summary>
        /// Whether or not the character is a Free Sprite.
        /// </summary>
        public bool IsFreeSprite => MetatypeCategory == "Free Sprite";

        #endregion

        #region Special Functions and Enabled Check Properties

        /// <summary>
        /// Whether or not Adept options are enabled.
        /// </summary>
        public bool AdeptEnabled
        {
            get => _blnAdeptEnabled;
            set
            {
                if(_blnAdeptEnabled != value)
                {
                    _blnAdeptEnabled = value;
                    if(!value)
                    {
                        ClearAdeptPowers();
                    }

                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Whether or not Magician options are enabled.
        /// </summary>
        public bool MagicianEnabled
        {
            get => _blnMagicianEnabled;
            set
            {
                if(_blnMagicianEnabled != value)
                {
                    _blnMagicianEnabled = value;
                    if(!value)
                    {
                        ClearMagic(AdeptEnabled);
                    }

                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Whether or not Technomancer options are enabled.
        /// </summary>
        public bool TechnomancerEnabled
        {
            get => _blnTechnomancerEnabled;
            set
            {
                if(_blnTechnomancerEnabled != value)
                {
                    _blnTechnomancerEnabled = value;
                    if(!value)
                    {
                        ClearResonance();
                    }

                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Whether or not the Drug Psyche is active
        /// </summary>
        public bool PsycheActive
        {
            get => _blnPsycheActive;
            set
            {
                if (_blnPsycheActive != value)
                {
                    _blnPsycheActive = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Whether or not Advanced Program options are enabled.
        /// </summary>
        public bool AdvancedProgramsEnabled
        {
            get => _blnAdvancedProgramsEnabled;
            set
            {
                if(_blnAdvancedProgramsEnabled != value)
                {
                    _blnAdvancedProgramsEnabled = value;
                    if(!value)
                    {
                        ClearAdvancedPrograms();
                    }

                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Whether or not Cyberware options are disabled.
        /// </summary>
        public bool CyberwareDisabled
        {
            get => _blnCyberwareDisabled;
            set
            {
                if(_blnCyberwareDisabled != value)
                {
                    _blnCyberwareDisabled = value;
                    if (value)
                        ClearCyberwareTab();

                    OnPropertyChanged();
                }
            }
        }

        public bool AddCyberwareEnabled => !CyberwareDisabled && !IsAI
                                                              && ImprovementManager
                                                                 .GetCachedImprovementListForValueOf(
                                                                     this, Improvement.ImprovementType.DisableCyberware)
                                                                 .Count == 0;

        public bool AddBiowareEnabled => !CyberwareDisabled && !IsAI
                                                            && ImprovementManager
                                                               .GetCachedImprovementListForValueOf(
                                                                   this, Improvement.ImprovementType.DisableBioware)
                                                               .Count == 0;

        private int _intCachedInitiationEnabled = int.MinValue;

        /// <summary>
        /// Whether or not the Initiation tab should be shown (override for BP mode).
        /// </summary>
        public bool InitiationEnabled
        {
            get
            {
                if(_intCachedInitiationEnabled < 0)
                {
                    _intCachedInitiationEnabled = !InitiationForceDisabled && (MAGEnabled || RESEnabled) ? 1 : 0;
                }

                return _intCachedInitiationEnabled > 0;
            }
        }

        public bool InitiationForceDisabled
        {
            get => _blnInitiationDisabled;
            set
            {
                if(_blnInitiationDisabled != value)
                {
                    _blnInitiationDisabled = value;
                    if(value)
                    {
                        ClearInitiations();
                    }

                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Whether or not Critter options are enabled.
        /// </summary>
        public bool CritterEnabled
        {
            get => _blnCritterEnabled;
            set
            {
                if(_blnCritterEnabled != value)
                {
                    _blnCritterEnabled = value;
                    if(!value)
                    {
                        ClearCritterPowers();
                    }

                    OnPropertyChanged();
                }
            }
        }

        private int _intCachedDealerConnectionDiscount = int.MinValue;

        /// <summary>
        /// Whether or not Black Market Discount is enabled.
        /// </summary>
        public bool DealerConnectionDiscount
        {
            get
            {
                if (_intCachedDealerConnectionDiscount < 0)
                    _intCachedDealerConnectionDiscount = ImprovementManager
                                                         .GetCachedImprovementListForValueOf(
                                                             this, Improvement.ImprovementType.DealerConnection).Count
                                                         > 0
                        ? 1
                        : 0;

                return _intCachedDealerConnectionDiscount > 0;
            }
        }

        public void RefreshDealerConnectionDiscounts()
        {
            // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
            if (IsLoading)
                return;

            if (Created)
                return; // Don't need to refresh properties in Career mode because costs are calculated immediately upon purchasing stuff

            if (DealerConnectionDiscount)
                return;
            
            using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                            out HashSet<string> setDealerConnectionMaps))
            {
                foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                             this, Improvement.ImprovementType.DealerConnection))
                {
                    setDealerConnectionMaps.Add(objImprovement.UniqueName);
                }

                foreach (Vehicle objVehicle in Vehicles)
                {
                    objVehicle.DealerConnectionDiscount = objVehicle.DealerConnectionDiscount
                                                          && Vehicle.DoesDealerConnectionApply(
                                                              setDealerConnectionMaps, objVehicle.Category);
                }
            }
        }

        private int _intCachedBlackMarketDiscount = int.MinValue;

        /// <summary>
        /// Whether or not Black Market Discount is enabled.
        /// </summary>
        public bool BlackMarketDiscount
        {
            get
            {
                if (_intCachedBlackMarketDiscount < 0)
                    _intCachedBlackMarketDiscount = ImprovementManager
                                                    .GetCachedImprovementListForValueOf(
                                                        this, Improvement.ImprovementType.BlackMarketDiscount).Count
                                                    > 0
                        ? 1
                        : 0;

                return _intCachedBlackMarketDiscount > 0;
            }
        }

        public void RefreshBlackMarketDiscounts()
        {
            // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
            if (IsLoading)
                return;

            if (Created)
                return; // Don't need to refresh properties in Career mode because costs are calculated immediately upon purchasing stuff

            if (BlackMarketDiscount)
            {
                using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool, out HashSet<string> setArmorBlackMarketMaps))
                using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool, out HashSet<string> setArmorModBlackMarketMaps))
                using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool, out HashSet<string> setBiowareBlackMarketMaps))
                using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool, out HashSet<string> setCyberwareBlackMarketMaps))
                using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool, out HashSet<string> setGearBlackMarketMaps))
                using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool, out HashSet<string> setVehicleBlackMarketMaps))
                using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool, out HashSet<string> setVehicleModBlackMarketMaps))
                using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool, out HashSet<string> setWeaponMountBlackMarketMaps))
                using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool, out HashSet<string> setWeaponBlackMarketMaps))
                {
                    setArmorBlackMarketMaps.AddRange(GenerateBlackMarketMappings(LoadDataXPath("armor.xml")
                                                          .SelectSingleNodeAndCacheExpression("/chummer")));
                    setArmorModBlackMarketMaps.AddRange(GenerateBlackMarketMappings(LoadDataXPath("armor.xml")
                                                            .SelectSingleNodeAndCacheExpression(
                                                                "/chummer/modcategories")));
                    setBiowareBlackMarketMaps.AddRange(GenerateBlackMarketMappings(LoadDataXPath("bioware.xml")
                                                           .SelectSingleNodeAndCacheExpression("/chummer")));
                    setCyberwareBlackMarketMaps.AddRange(GenerateBlackMarketMappings(LoadDataXPath("cyberware.xml")
                                                             .SelectSingleNodeAndCacheExpression("/chummer")));
                    setGearBlackMarketMaps.AddRange(GenerateBlackMarketMappings(LoadDataXPath("gear.xml")
                                                        .SelectSingleNodeAndCacheExpression("/chummer")));
                    setVehicleBlackMarketMaps.AddRange(GenerateBlackMarketMappings(LoadDataXPath("vehicles.xml")
                                                           .SelectSingleNodeAndCacheExpression("/chummer")));
                    setVehicleModBlackMarketMaps.AddRange(GenerateBlackMarketMappings(LoadDataXPath("vehicles.xml")
                                                              .SelectSingleNodeAndCacheExpression(
                                                                  "/chummer/modcategories")));
                    setWeaponMountBlackMarketMaps.AddRange(GenerateBlackMarketMappings(LoadDataXPath("vehicles.xml")
                                                               .SelectSingleNodeAndCacheExpression(
                                                                   "/chummer/weaponmountcategories")));
                    setWeaponBlackMarketMaps.AddRange(GenerateBlackMarketMappings(LoadDataXPath("weapons.xml")
                                                          .SelectSingleNodeAndCacheExpression("/chummer")));

                    foreach (Armor objArmor in Armor)
                    {
                        objArmor.DiscountCost
                            = objArmor.DiscountCost && setArmorBlackMarketMaps.Contains(objArmor.Category);
                        foreach (ArmorMod objMod in objArmor.ArmorMods)
                        {
                            objMod.DiscountCost = objMod.DiscountCost
                                                  && setArmorModBlackMarketMaps.Contains(objMod.Category);
                            foreach (Gear objGear in objMod.GearChildren.GetAllDescendants(x => x.Children))
                                objGear.DiscountCost = objGear.DiscountCost
                                                       && setGearBlackMarketMaps.Contains(objGear.Category);
                        }

                        foreach (Gear objGear in objArmor.GearChildren.GetAllDescendants(x => x.Children))
                            objGear.DiscountCost
                                = objGear.DiscountCost && setGearBlackMarketMaps.Contains(objGear.Category);
                    }

                    foreach (Cyberware objCyberware in Cyberware.GetAllDescendants(x => x.Children))
                    {
                        if (objCyberware.DiscountCost)
                        {
                            objCyberware.DiscountCost
                                = (objCyberware.SourceType == Improvement.ImprovementSource.Bioware
                                    ? setBiowareBlackMarketMaps
                                    : setCyberwareBlackMarketMaps).Contains(objCyberware.Category);
                        }

                        foreach (Gear objGear in objCyberware.GearChildren.GetAllDescendants(x => x.Children))
                            objGear.DiscountCost
                                = objGear.DiscountCost && setGearBlackMarketMaps.Contains(objGear.Category);
                    }

                    foreach (Gear objGear in Gear.GetAllDescendants(x => x.Children))
                        objGear.DiscountCost
                            = objGear.DiscountCost && setGearBlackMarketMaps.Contains(objGear.Category);

                    foreach (Vehicle objVehicle in Vehicles)
                    {
                        objVehicle.DiscountCost = objVehicle.DiscountCost
                                                  && setVehicleBlackMarketMaps.Contains(objVehicle.Category);
                        foreach (Gear objGear in objVehicle.GearChildren.GetAllDescendants(x => x.Children))
                            objGear.DiscountCost
                                = objGear.DiscountCost && setGearBlackMarketMaps.Contains(objGear.Category);
                        foreach (VehicleMod objMod in objVehicle.Mods)
                        {
                            objMod.DiscountCost = objMod.DiscountCost
                                                  && setVehicleModBlackMarketMaps.Contains(objMod.Category);
                            foreach (Cyberware objCyberware in objMod.Cyberware.GetAllDescendants(x => x.Children))
                            {
                                if (objCyberware.DiscountCost)
                                {
                                    objCyberware.DiscountCost
                                        = (objCyberware.SourceType == Improvement.ImprovementSource.Bioware
                                            ? setBiowareBlackMarketMaps
                                            : setCyberwareBlackMarketMaps).Contains(objCyberware.Category);
                                }

                                foreach (Gear objGear in objCyberware.GearChildren.GetAllDescendants(x => x.Children))
                                    objGear.DiscountCost = objGear.DiscountCost
                                                           && setGearBlackMarketMaps.Contains(objGear.Category);
                            }
                        }

                        foreach (Weapon objWeapon in objVehicle.Weapons.GetAllDescendants(x => x.Children))
                        {
                            objWeapon.DiscountCost = objWeapon.DiscountCost
                                                     && setWeaponBlackMarketMaps.Contains(objWeapon.Category);
                            foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                            {
                                objAccessory.DiscountCost = objAccessory.DiscountCost
                                                            && setWeaponBlackMarketMaps.Contains(objWeapon.Category);
                                foreach (Gear objGear in objAccessory.GearChildren.GetAllDescendants(x => x.Children))
                                    objGear.DiscountCost = objGear.DiscountCost
                                                           && setGearBlackMarketMaps.Contains(objGear.Category);
                            }
                        }

                        foreach (WeaponMount objMount in objVehicle.WeaponMounts)
                        {
                            objMount.DiscountCost = objMount.DiscountCost
                                                    && setWeaponMountBlackMarketMaps.Contains(objMount.Category);
                            foreach (VehicleMod objMod in objMount.Mods)
                            {
                                objMod.DiscountCost = objMod.DiscountCost
                                                      && setVehicleModBlackMarketMaps.Contains(objMod.Category);
                                foreach (Cyberware objCyberware in objMod.Cyberware.GetAllDescendants(x => x.Children))
                                {
                                    if (objCyberware.DiscountCost)
                                    {
                                        objCyberware.DiscountCost
                                            = (objCyberware.SourceType == Improvement.ImprovementSource.Bioware
                                                ? setBiowareBlackMarketMaps
                                                : setCyberwareBlackMarketMaps).Contains(objCyberware.Category);
                                    }

                                    foreach (Gear objGear in objCyberware.GearChildren.GetAllDescendants(
                                                 x => x.Children))
                                        objGear.DiscountCost = objGear.DiscountCost
                                                               && setGearBlackMarketMaps.Contains(objGear.Category);
                                }
                            }

                            foreach (Weapon objWeapon in objMount.Weapons.GetAllDescendants(x => x.Children))
                            {
                                objWeapon.DiscountCost = objWeapon.DiscountCost
                                                         && setWeaponBlackMarketMaps.Contains(objWeapon.Category);
                                foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                                {
                                    objAccessory.DiscountCost = objAccessory.DiscountCost
                                                                && setWeaponBlackMarketMaps
                                                                    .Contains(objWeapon.Category);
                                    foreach (Gear objGear in objAccessory.GearChildren.GetAllDescendants(
                                                 x => x.Children))
                                        objGear.DiscountCost = objGear.DiscountCost
                                                               && setGearBlackMarketMaps.Contains(objGear.Category);
                                }
                            }
                        }
                    }

                    foreach (Weapon objWeapon in Weapons.GetAllDescendants(x => x.Children))
                    {
                        objWeapon.DiscountCost = objWeapon.DiscountCost
                                                 && setWeaponBlackMarketMaps.Contains(objWeapon.Category);
                        foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                        {
                            objAccessory.DiscountCost = objAccessory.DiscountCost
                                                        && setWeaponBlackMarketMaps.Contains(objWeapon.Category);
                            foreach (Gear objGear in objAccessory.GearChildren.GetAllDescendants(x => x.Children))
                                objGear.DiscountCost = objGear.DiscountCost
                                                       && setGearBlackMarketMaps.Contains(objGear.Category);
                        }
                    }
                }
            }
            else
            {
                // Forcefully disable all Black Market Discounts that don't apply.
                foreach (Armor objArmor in Armor)
                {
                    objArmor.DiscountCost = false;
                    foreach (ArmorMod objMod in objArmor.ArmorMods)
                    {
                        objMod.DiscountCost = false;
                        foreach (Gear objGear in objMod.GearChildren.GetAllDescendants(x => x.Children))
                            objGear.DiscountCost = false;
                    }

                    foreach (Gear objGear in objArmor.GearChildren.GetAllDescendants(x => x.Children))
                        objGear.DiscountCost = false;
                }

                foreach (Cyberware objCyberware in Cyberware.GetAllDescendants(x => x.Children))
                {
                    objCyberware.DiscountCost = false;
                    foreach (Gear objGear in objCyberware.GearChildren.GetAllDescendants(x => x.Children))
                        objGear.DiscountCost = false;
                }

                foreach (Gear objGear in Gear.GetAllDescendants(x => x.Children))
                    objGear.DiscountCost = false;

                foreach (Vehicle objVehicle in Vehicles)
                {
                    objVehicle.DiscountCost = false;
                    foreach (Gear objGear in objVehicle.GearChildren.GetAllDescendants(x => x.Children))
                        objGear.DiscountCost = false;
                    foreach (VehicleMod objMod in objVehicle.Mods)
                    {
                        objMod.DiscountCost = false;
                        foreach (Cyberware objCyberware in objMod.Cyberware.GetAllDescendants(x => x.Children))
                        {
                            objCyberware.DiscountCost = false;
                            foreach (Gear objGear in objCyberware.GearChildren.GetAllDescendants(x => x.Children))
                                objGear.DiscountCost = false;
                        }
                    }
                    foreach (Weapon objWeapon in objVehicle.Weapons.GetAllDescendants(x => x.Children))
                    {
                        objWeapon.DiscountCost = false;
                        foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                        {
                            objAccessory.DiscountCost = false;
                            foreach (Gear objGear in objAccessory.GearChildren.GetAllDescendants(x => x.Children))
                                objGear.DiscountCost = false;
                        }
                    }

                    foreach (WeaponMount objMount in objVehicle.WeaponMounts)
                    {
                        objMount.DiscountCost = false;
                        foreach (VehicleMod objMod in objMount.Mods)
                        {
                            objMod.DiscountCost = false;
                            foreach (Cyberware objCyberware in objMod.Cyberware.GetAllDescendants(x => x.Children))
                            {
                                objCyberware.DiscountCost = false;
                                foreach (Gear objGear in objCyberware.GearChildren.GetAllDescendants(x => x.Children))
                                    objGear.DiscountCost = false;
                            }
                        }
                        foreach (Weapon objWeapon in objMount.Weapons.GetAllDescendants(x => x.Children))
                        {
                            objWeapon.DiscountCost = false;
                            foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                            {
                                objAccessory.DiscountCost = false;
                                foreach (Gear objGear in objAccessory.GearChildren.GetAllDescendants(x => x.Children))
                                    objGear.DiscountCost = false;
                            }
                        }
                    }
                }

                foreach (Weapon objWeapon in Weapons.GetAllDescendants(x => x.Children))
                {
                    objWeapon.DiscountCost = false;
                    foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                    {
                        objAccessory.DiscountCost = false;
                        foreach (Gear objGear in objAccessory.GearChildren.GetAllDescendants(x => x.Children))
                            objGear.DiscountCost = false;
                    }
                }
            }
        }

        /// <summary>
        /// Whether or not this character can quicken spells.
        /// </summary>
        public bool QuickeningEnabled => ImprovementManager
                                         .GetCachedImprovementListForValueOf(
                                             this, Improvement.ImprovementType.QuickeningMetamagic).Count > 0;

        /// <summary>
        /// Whether or not user is getting free bioware from Prototype Transhuman.
        /// </summary>
        public decimal PrototypeTranshuman
        {
            get => _decPrototypeTranshuman;
            set
            {
                if (_decPrototypeTranshuman == value)
                    return;
                _decPrototypeTranshuman = value;
                OnPropertyChanged();
            }
        }

        public bool IsPrototypeTranshuman => PrototypeTranshuman > 0;

        private int _intCachedFriendsInHighPlaces = int.MinValue;

        /// <summary>
        /// Whether or not Friends in High Places is enabled.
        /// </summary>
        public bool FriendsInHighPlaces
        {
            get
            {
                if (_intCachedFriendsInHighPlaces < 0)
                    _intCachedFriendsInHighPlaces = ImprovementManager
                                                    .GetCachedImprovementListForValueOf(
                                                        this, Improvement.ImprovementType.FriendsInHighPlaces).Count
                                                    > 0
                        ? 1
                        : 0;

                return _intCachedFriendsInHighPlaces > 0;
            }
        }

        private int _intCachedExCon = int.MinValue;

        /// <summary>
        /// Whether or not ExCon is enabled.
        /// </summary>
        public bool ExCon
        {
            get
            {
                if (_intCachedExCon < 0)
                    _intCachedExCon = ImprovementManager
                                      .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.ExCon).Count
                                      > 0
                        ? 1
                        : 0;

                return _intCachedExCon > 0;
            }
        }

        private int _intCachedTrustFund = int.MinValue;

        /// <summary>
        /// Value of the Trust Fund quality.
        /// </summary>
        public int TrustFund
        {
            get
            {
                if(_intCachedTrustFund != int.MinValue)
                    return _intCachedTrustFund;

                List<Improvement> lstTrustFundImprovements = ImprovementManager
                    .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.TrustFund);
                return _intCachedTrustFund = lstTrustFundImprovements.Count > 0
                    ? lstTrustFundImprovements.Max(x => x.Value).StandardRound()
                    : 0;
            }
        }

        private int _intCachedRestrictedGear = int.MinValue;

        /// <summary>
        /// The maximum availability for Restricted Gear if this character has it. If they do not, this is 0.
        /// </summary>
        public int RestrictedGear
        {
            get
            {
                if(_intCachedRestrictedGear < 0)
                {
                    foreach(Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.RestrictedGear))
                    {
                        _intCachedRestrictedGear
                            = Math.Max(_intCachedRestrictedGear, objImprovement.Value.StandardRound());
                    }
                }

                return _intCachedRestrictedGear;
            }
        }

        private int _intCachedOverclocker = int.MinValue;

        /// <summary>
        /// Whether or not Overclocker is enabled.
        /// </summary>
        public bool Overclocker
        {
            get
            {
                if (_intCachedOverclocker < 0)
                    _intCachedOverclocker = ImprovementManager
                                            .GetCachedImprovementListForValueOf(
                                                this, Improvement.ImprovementType.Overclocker).Count > 0
                        ? 1
                        : 0;

                return _intCachedOverclocker > 0;
            }
        }

        private int _intCachedMadeMan = int.MinValue;

        /// <summary>
        /// Whether or not MadeMan is enabled.
        /// </summary>
        public bool MadeMan
        {
            get
            {
                if (_intCachedMadeMan < 0)
                    _intCachedMadeMan
                        = ImprovementManager
                          .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.MadeMan).Count > 0
                            ? 1
                            : 0;

                return _intCachedMadeMan > 0;
            }
        }

        private int _intCachedFame = int.MinValue;

        /// <summary>
        /// Whether or not Fame is enabled.
        /// </summary>
        public bool Fame
        {
            get
            {
                if (_intCachedFame < 0)
                    _intCachedFame = ImprovementManager
                                     .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Fame).Count
                                     > 0
                        ? 1
                        : 0;

                return _intCachedFame > 0;
            }
        }

        private int _intCachedErased = int.MinValue;

        /// <summary>
        /// Whether or not Erased is enabled.
        /// </summary>
        public bool Erased
        {
            get
            {
                if(_intCachedErased < 0)
                    _intCachedErased = ImprovementManager
                                       .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Erased).Count
                                       > 0
                        ? 1
                        : 0;

                return _intCachedErased > 0;
            }
        }

        private int _intCachedAllowSpriteFettering = int.MinValue;

        /// <summary>
        /// Whether or not the character is allowed to Fetter sprites. See Kill Code 91 (Sprite Pet)
        /// </summary>
        public bool AllowSpriteFettering
        {
            get
            {
                if (_intCachedAllowSpriteFettering < 0)
                    _intCachedAllowSpriteFettering = ImprovementManager
                                                     .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.AllowSpriteFettering).Count
                                                     > 0
                        ? 1
                        : 0;
                return _intCachedAllowSpriteFettering > 0;
            }
        }

        /// <summary>
        /// Extended Availability Test information for an item based on the character's Negotiate Skill.
        /// </summary>
        /// <param name="decCost">Item's cost.</param>
        /// <param name="strAvail">Item's Availability.</param>
        public string AvailTest(decimal decCost, string strAvail)
        {
            if (string.IsNullOrEmpty(strAvail))
                return LanguageManager.GetString("String_None");
            bool blnShowTest = false;
            string strTestSuffix = LanguageManager.GetString("String_AvailRestricted");
            if(strAvail.EndsWith(strTestSuffix, StringComparison.Ordinal))
            {
                blnShowTest = true;
                strAvail = strAvail.TrimEndOnce(strTestSuffix, true);
            }
            else
            {
                strTestSuffix = LanguageManager.GetString("String_AvailForbidden");
                if(strAvail.EndsWith(strTestSuffix, StringComparison.Ordinal))
                {
                    blnShowTest = true;
                    strAvail = strAvail.TrimEndOnce(strTestSuffix, true);
                }
            }

            if(int.TryParse(strAvail, out int intAvail) && (intAvail != 0 || blnShowTest))
            {
                return GetAvailTestString(decCost, intAvail);
            }

            return LanguageManager.GetString("String_None");
        }

        /// <summary>
        /// Extended Availability Test information for an item based on the character's Negotiate Skill.
        /// </summary>
        /// <param name="decCost">Item's cost.</param>
        /// <param name="objAvailability">Item's Availability.</param>
        public string AvailTest(decimal decCost, AvailabilityValue objAvailability)
        {
            if(objAvailability.Value != 0 || objAvailability.Suffix == 'R' || objAvailability.Suffix == 'F')
            {
                return GetAvailTestString(decCost, objAvailability.Value);
            }

            return LanguageManager.GetString("String_None");
        }

        private string GetAvailTestString(decimal decCost, int intAvailValue)
        {
            string strSpace = LanguageManager.GetString("String_Space");
            string strInterval;
            // Find the character's Negotiation total.
            int intPool = SkillsSection.GetActiveSkill("Negotiation")?.Pool ?? 0;
            // Determine the interval based on the item's price.
            if(decCost <= 100.0m)
                strInterval = '6' + strSpace + LanguageManager.GetString("String_Hours");
            else if(decCost <= 1000.0m)
                strInterval = '1' + strSpace + LanguageManager.GetString("String_Day");
            else if(decCost <= 10000.0m)
                strInterval = '2' + strSpace + LanguageManager.GetString("String_Days");
            else if(decCost <= 100000.0m)
                strInterval = '1' + strSpace + LanguageManager.GetString("String_Week");
            else
                strInterval = '1' + strSpace + LanguageManager.GetString("String_Month");

            return intPool.ToString(GlobalSettings.CultureInfo) + strSpace + '('
                   + intAvailValue.ToString(GlobalSettings.CultureInfo) + ',' + strSpace + strInterval + ')';
        }

        /// <summary>
        /// Whether or not Adapsin is enabled.
        /// </summary>
        public bool AdapsinEnabled =>
            ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Adapsin).Count > 0;

        /// <summary>
        /// Whether or not Burnout's Way is enabled.
        /// </summary>
        public bool BurnoutEnabled => ImprovementManager
                                      .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.BurnoutsWay)
                                      .Count > 0;

        #endregion

        #region Application Properties

        private readonly HashSet<Character> _lstLinkedCharacters = new HashSet<Character>();

        /// <summary>
        /// Characters referenced by some member of this character (usually a contact).
        /// </summary>
        public HashSet<Character> LinkedCharacters => _lstLinkedCharacters;

        #endregion

        #region Old Quality Conversion Code

        /// <summary>
        /// Convert Qualities that are still saved in the old format.
        /// </summary>
        private void ConvertOldQualities(XmlNodeList objXmlQualityList)
        {
            XmlNode xmlRootQualitiesNode = LoadData("qualities.xml").SelectSingleNode("/chummer/qualities");

            if(xmlRootQualitiesNode != null)
            {
                // Convert the old Qualities.
                foreach(XmlNode objXmlQuality in objXmlQualityList)
                {
                    if(objXmlQuality["name"] == null)
                    {
                        XmlNode objXmlQualityNode =
                            xmlRootQualitiesNode.SelectSingleNode(
                                "quality[name = " + GetQualityName(objXmlQuality.InnerText).CleanXPath() + ']');

                        if(objXmlQualityNode != null)
                        {
                            string strForceValue = string.Empty;
                            // Re-create the bonuses for the Quality.
                            if (objXmlQualityNode.InnerXml.Contains("<bonus>"))
                            {
                                // Look for the existing Improvement.
                                foreach(Improvement objImprovement in Improvements)
                                {
                                    if(objImprovement.ImproveSource == Improvement.ImprovementSource.Quality &&
                                        objImprovement.SourceName == objXmlQuality.InnerText && objImprovement.Enabled)
                                    {
                                        strForceValue = objImprovement.ImprovedName;
                                        Improvements.Remove(objImprovement);
                                        break;
                                    }
                                }
                            }

                            // Convert the item to the new Quality class.
                            Quality objQuality = new Quality(this);
                            objQuality.Create(objXmlQualityNode, QualitySource.Selected, _lstWeapons, strForceValue);
                            Qualities.Add(objQuality);
                        }
                    }
                }

                // Take care of the Metatype information.
                string strXPath = "/chummer/metatypes/metatype[name = " + Metatype.CleanXPath() + ']';
                XmlNode objXmlMetatype = LoadData("metatypes.xml").SelectSingleNode(strXPath) ??
                                         LoadData("critters.xml").SelectSingleNode(strXPath);

                if(objXmlMetatype != null)
                {
                    // Positive Qualities.
                    using (XmlNodeList xmlMetatypeQualityList =
                        objXmlMetatype.SelectNodes("qualities/positive/quality"))
                    {
                        if (xmlMetatypeQualityList != null)
                        {
                            foreach (XmlNode objXmlMetatypeQuality in xmlMetatypeQualityList)
                            {
                                bool blnFound = false;
                                // See if the Quality already exists in the character.
                                foreach (Quality objCharacterQuality in _lstQualities)
                                {
                                    if (objCharacterQuality.Name == objXmlMetatypeQuality.InnerText)
                                    {
                                        blnFound = true;
                                        break;
                                    }
                                }

                                // If the Quality was not found, create it.
                                if (!blnFound)
                                {
                                    string strForceValue =
                                        objXmlMetatypeQuality.Attributes?["select"]?.InnerText ?? string.Empty;
                                    Quality objQuality = new Quality(this);

                                    XmlNode objXmlQuality =
                                        xmlRootQualitiesNode.SelectSingleNode(
                                            "quality[name = " + objXmlMetatypeQuality.InnerText.CleanXPath() + ']');
                                    objQuality.Create(objXmlQuality, QualitySource.Metatype, _lstWeapons,
                                        strForceValue);
                                    Qualities.Add(objQuality);
                                }
                            }
                        }
                    }

                    // Negative Qualities.
                    using (XmlNodeList xmlMetatypeQualityList =
                        objXmlMetatype.SelectNodes("qualities/negative/quality"))
                    {
                        if (xmlMetatypeQualityList != null)
                        {
                            foreach (XmlNode objXmlMetatypeQuality in xmlMetatypeQualityList)
                            {
                                bool blnFound = false;
                                // See if the Quality already exists in the character.
                                foreach (Quality objCharacterQuality in _lstQualities)
                                {
                                    if (objCharacterQuality.Name == objXmlMetatypeQuality.InnerText)
                                    {
                                        blnFound = true;
                                        break;
                                    }
                                }

                                // If the Quality was not found, create it.
                                if (!blnFound)
                                {
                                    string strForceValue =
                                        objXmlMetatypeQuality.Attributes?["select"]?.InnerText ?? string.Empty;
                                    Quality objQuality = new Quality(this);

                                    XmlNode objXmlQuality =
                                        xmlRootQualitiesNode.SelectSingleNode(
                                            "quality[name = " + objXmlMetatypeQuality.InnerText.CleanXPath() + ']');
                                    objQuality.Create(objXmlQuality, QualitySource.Metatype, _lstWeapons,
                                        strForceValue);
                                    Qualities.Add(objQuality);
                                }
                            }
                        }
                    }

                    // Do it all over again for Metavariants.
                    if(!string.IsNullOrEmpty(_strMetavariant))
                    {
                        objXmlMetatype =
                            objXmlMetatype.SelectSingleNode("metavariants/metavariant[name = " + Metavariant.CleanXPath() + ']');

                        if (objXmlMetatype != null)
                        {
                            // Positive Qualities.
                            using (XmlNodeList xmlMetatypeQualityList =
                                objXmlMetatype.SelectNodes("qualities/positive/quality"))
                            {
                                if (xmlMetatypeQualityList != null)
                                {
                                    foreach (XmlNode objXmlMetatypeQuality in xmlMetatypeQualityList)
                                    {
                                        bool blnFound = false;
                                        // See if the Quality already exists in the character.
                                        foreach (Quality objCharacterQuality in _lstQualities)
                                        {
                                            if (objCharacterQuality.Name == objXmlMetatypeQuality.InnerText)
                                            {
                                                blnFound = true;
                                                break;
                                            }
                                        }

                                        // If the Quality was not found, create it.
                                        if (!blnFound)
                                        {
                                            string strForceValue =
                                                objXmlMetatypeQuality.Attributes?["select"]?.InnerText ?? string.Empty;
                                            Quality objQuality = new Quality(this);

                                            XmlNode objXmlQuality =
                                                xmlRootQualitiesNode.SelectSingleNode(
                                                    "quality[name = " + objXmlMetatypeQuality.InnerText.CleanXPath() + ']');
                                            objQuality.Create(objXmlQuality, QualitySource.Metatype, _lstWeapons,
                                                strForceValue);
                                            Qualities.Add(objQuality);
                                        }
                                    }
                                }
                            }

                            // Negative Qualities.
                            using (XmlNodeList xmlMetatypeQualityList =
                                objXmlMetatype.SelectNodes("qualities/negative/quality"))
                            {
                                if (xmlMetatypeQualityList != null)
                                {
                                    foreach (XmlNode objXmlMetatypeQuality in xmlMetatypeQualityList)
                                    {
                                        bool blnFound = false;
                                        // See if the Quality already exists in the character.
                                        foreach (Quality objCharacterQuality in _lstQualities)
                                        {
                                            if (objCharacterQuality.Name == objXmlMetatypeQuality.InnerText)
                                            {
                                                blnFound = true;
                                                break;
                                            }
                                        }

                                        // If the Quality was not found, create it.
                                        if (!blnFound)
                                        {
                                            string strForceValue =
                                                objXmlMetatypeQuality.Attributes?["select"]?.InnerText ?? string.Empty;
                                            Quality objQuality = new Quality(this);

                                            XmlNode objXmlQuality =
                                                xmlRootQualitiesNode.SelectSingleNode(
                                                    "quality[name = " + objXmlMetatypeQuality.InnerText.CleanXPath() + ']');
                                            objQuality.Create(objXmlQuality, QualitySource.Metatype, _lstWeapons,
                                                strForceValue);
                                            Qualities.Add(objQuality);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Get the name of a Quality by parsing out its BP cost.
        /// </summary>
        /// <param name="strQuality">String to parse.</param>
        private static string GetQualityName(string strQuality)
        {
            int intPos = strQuality.IndexOf('[');
            if(intPos != -1)
                strQuality = strQuality.Substring(0, intPos - 1);
            return strQuality;
        }

        /// <summary>
        /// Check for older instances of certain qualities that were manually numbered to be replaced with multiple instances of the first level quality (so that it works with the level system)
        /// Returns true if it's a corrected quality, false otherwise
        /// </summary>
        private bool CorrectedUnleveledQuality(XmlNode xmlOldQuality, XmlNode xmlRootQualitiesNode)
        {
            XmlNode xmlNewQuality = null;
            int intRanks = 0;
            switch(xmlOldQuality["name"]?.InnerText)
            {
                case "Focused Concentration (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Focused Concentration\"]");
                        intRanks = 1;
                        break;
                    }
                case "Focused Concentration (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Focused Concentration\"]");
                        intRanks = 2;
                        break;
                    }
                case "Focused Concentration (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Focused Concentration\"]");
                        intRanks = 3;
                        break;
                    }
                case "Focused Concentration (Rating 4)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Focused Concentration\"]");
                        intRanks = 4;
                        break;
                    }
                case "Focused Concentration (Rating 5)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Focused Concentration\"]");
                        intRanks = 5;
                        break;
                    }
                case "Focused Concentration (Rating 6)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Focused Concentration\"]");
                        intRanks = 6;
                        break;
                    }
                case "High Pain Tolerance (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"High Pain Tolerance\"]");
                        intRanks = 1;
                        break;
                    }
                case "High Pain Tolerance (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"High Pain Tolerance\"]");
                        intRanks = 2;
                        break;
                    }
                case "High Pain Tolerance (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"High Pain Tolerance\"]");
                        intRanks = 3;
                        break;
                    }
                case "Magic Resistance (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Magic Resistance\"]");
                        intRanks = 1;
                        break;
                    }
                case "Magic Resistance (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Magic Resistance\"]");
                        intRanks = 2;
                        break;
                    }
                case "Magic Resistance (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Magic Resistance\"]");
                        intRanks = 3;
                        break;
                    }
                case "Magic Resistance (Rating 4)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Magic Resistance\"]");
                        intRanks = 4;
                        break;
                    }
                case "Will to Live (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Will to Live\"]");
                        intRanks = 1;
                        break;
                    }
                case "Will to Live (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Will to Live\"]");
                        intRanks = 2;
                        break;
                    }
                case "Will to Live (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Will to Live\"]");
                        intRanks = 3;
                        break;
                    }
                case "Gremlins (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Gremlins\"]");
                        intRanks = 1;
                        break;
                    }
                case "Gremlins (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Gremlins\"]");
                        intRanks = 2;
                        break;
                    }
                case "Gremlins (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Gremlins\"]");
                        intRanks = 3;
                        break;
                    }
                case "Gremlins (Rating 4)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Gremlins\"]");
                        intRanks = 4;
                        break;
                    }
                case "Aged (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Aged\"]");
                        intRanks = 1;
                        break;
                    }
                case "Aged (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Aged\"]");
                        intRanks = 2;
                        break;
                    }
                case "Aged (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Aged\"]");
                        intRanks = 3;
                        break;
                    }
                case "Illness (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Illness\"]");
                        intRanks = 1;
                        break;
                    }
                case "Illness (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Illness\"]");
                        intRanks = 2;
                        break;
                    }
                case "Illness (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Illness\"]");
                        intRanks = 3;
                        break;
                    }
                case "Perceptive I":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Perceptive\"]");
                        intRanks = 1;
                        break;
                    }
                case "Perceptive II":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Perceptive\"]");
                        intRanks = 2;
                        break;
                    }
                case "Spike Resistance I":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Spike Resistance\"]");
                        intRanks = 1;
                        break;
                    }
                case "Spike Resistance II":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Spike Resistance\"]");
                        intRanks = 2;
                        break;
                    }
                case "Spike Resistance III":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Spike Resistance\"]");
                        intRanks = 3;
                        break;
                    }
                case "Tough as Nails Physical I":
                    {
                        xmlNewQuality =
                            xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Tough as Nails (Physical)\"]");
                        intRanks = 1;
                        break;
                    }
                case "Tough as Nails Physical II":
                    {
                        xmlNewQuality =
                            xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Tough as Nails (Physical)\"]");
                        intRanks = 2;
                        break;
                    }
                case "Tough as Nails Physical III":
                    {
                        xmlNewQuality =
                            xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Tough as Nails (Physical)\"]");
                        intRanks = 3;
                        break;
                    }
                case "Tough as Nails Stun I":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Tough as Nails (Stun)\"]");
                        intRanks = 1;
                        break;
                    }
                case "Tough as Nails Stun II":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Tough as Nails (Stun)\"]");
                        intRanks = 2;
                        break;
                    }
                case "Tough as Nails Stun III":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Tough as Nails (Stun)\"]");
                        intRanks = 3;
                        break;
                    }
                case "Dimmer Bulb I":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Dimmer Bulb\"]");
                        intRanks = 1;
                        break;
                    }
                case "Dimmer Bulb II":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Dimmer Bulb\"]");
                        intRanks = 2;
                        break;
                    }
                case "Dimmer Bulb III":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Dimmer Bulb\"]");
                        intRanks = 3;
                        break;
                    }
                case "In Debt I":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 1;
                        break;
                    }
                case "In Debt II":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 2;
                        break;
                    }
                case "In Debt III":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 3;
                        break;
                    }
                case "In Debt IV":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 4;
                        break;
                    }
                case "In Debt V":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 5;
                        break;
                    }
                case "In Debt VI":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 6;
                        break;
                    }
                case "In Debt VII":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 7;
                        break;
                    }
                case "In Debt VIII":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 8;
                        break;
                    }
                case "In Debt IX":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 9;
                        break;
                    }
                case "In Debt X":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 10;
                        break;
                    }
                case "In Debt XI":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 11;
                        break;
                    }
                case "In Debt XII":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 12;
                        break;
                    }
                case "In Debt XIII":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 13;
                        break;
                    }
                case "In Debt XIV":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 14;
                        break;
                    }
                case "In Debt XV":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 15;
                        break;
                    }
                case "Infirm I":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Infirm\"]");
                        intRanks = 1;
                        break;
                    }
                case "Infirm II":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Infirm\"]");
                        intRanks = 2;
                        break;
                    }
                case "Infirm III":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Infirm\"]");
                        intRanks = 3;
                        break;
                    }
                case "Infirm IV":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Infirm\"]");
                        intRanks = 4;
                        break;
                    }
                case "Infirm V":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Infirm\"]");
                        intRanks = 5;
                        break;
                    }
                case "Shiva Arms (1 Pair)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Shiva Arms (Pair)\"]");
                        intRanks = 1;
                        break;
                    }
                case "Shiva Arms (2 Pair)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Shiva Arms (Pair)\"]");
                        intRanks = 2;
                        break;
                    }
                case "Arcane Arrester I":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Arcane Arrester\"]");
                        intRanks = 1;
                        break;
                    }
                case "Arcane Arrester II":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Arcane Arrester\"]");
                        intRanks = 2;
                        break;
                    }
                case "Pilot Origins (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Pilot Origins\"]");
                        intRanks = 1;
                        break;
                    }
                case "Pilot Origins (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Pilot Origins\"]");
                        intRanks = 2;
                        break;
                    }
                case "Pilot Origins (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Pilot Origins\"]");
                        intRanks = 3;
                        break;
                    }
                case "Social Appearance Anxiety (Rating 1)":
                    {
                        xmlNewQuality =
                            xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Social Appearance Anxiety\"]");
                        intRanks = 1;
                        break;
                    }
                case "Social Appearance Anxiety (Rating 2)":
                    {
                        xmlNewQuality =
                            xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Social Appearance Anxiety\"]");
                        intRanks = 2;
                        break;
                    }
                case "Social Appearance Anxiety (Rating 3)":
                    {
                        xmlNewQuality =
                            xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Social Appearance Anxiety\"]");
                        intRanks = 3;
                        break;
                    }
            }

            if(intRanks > 0)
            {
                for(int i = 0; i < intRanks; ++i)
                {
                    Quality objQuality = new Quality(this);
                    if(i == 0 && xmlOldQuality.TryGetField("guid", Guid.TryParse, out Guid guidOld))
                    {
                        ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Quality,
                            guidOld.ToString());
                        objQuality.SetGUID(guidOld);
                    }

                    QualitySource objQualitySource =
                        Quality.ConvertToQualitySource(xmlOldQuality["qualitysource"]?.InnerText);
                    objQuality.Create(xmlNewQuality, objQualitySource, _lstWeapons, xmlOldQuality["extra"]?.InnerText);
                    if(xmlOldQuality["bp"] != null && int.TryParse(xmlOldQuality["bp"].InnerText, out int intOldBP))
                        objQuality.BP = intOldBP / intRanks;

                    Qualities.Add(objQuality);
                }

                return true;
            }

            return false;
        }

        #endregion

        #region Temporary Properties : Dashboard

        // This region is for properties that are applicable to the Dashboard
        /// <summary>
        /// The Current Initiative roll result including base Initiative
        /// <note>Dashboard</note>
        /// </summary>
        public int InitRoll { get; set; }

        /// <summary>
        /// The Initiative Passes that the player has
        /// <note>Dashboard</note>
        /// </summary>
        public int InitPasses
        {
            get
            {
                if(_intInitPasses == int.MinValue)
                    _intInitPasses = InitiativeDice;
                return _intInitPasses;
            }
            set
            {
                if(_intInitPasses != value)
                {
                    _intInitPasses = value;
                    OnPropertyChanged();
                }
            }
        }

        private int _intInitPasses = int.MinValue;

        /// <summary>
        /// True iff the character is currently delaying an action
        /// <note>Dashboard</note>
        /// </summary>
        public bool Delayed { get; set; }

        /// <summary>
        /// The current name and initiative of the character
        /// </summary>
        public string DisplayInit => Name + " : " + InitRoll.ToString(GlobalSettings.CultureInfo);

        /// <summary>
        /// The initial Initiative of the character
        /// <note>Dashboard</note>
        /// </summary>
        public int InitialInit { get; set; }

        #endregion

        #region Temporary Properties

        /// <summary>
        /// Takes a semicolon-separated list of book codes and returns a formatted string with displaynames.
        /// </summary>
        /// <param name="strInput"></param>
        /// <param name="strLanguage">Language to fetch</param>
        public string TranslatedBookList(string strInput, string strLanguage = "")
        {
            if (string.IsNullOrEmpty(strInput))
                return string.Empty;
            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdReturn))
            {
                // Load the Sourcebook information.
                XPathNavigator objXmlDocument = LoadDataXPath("books.xml", strLanguage);

                foreach (string strBook in strInput.TrimEndOnce(';')
                                                   .SplitNoAlloc(';', StringSplitOptions.RemoveEmptyEntries))
                {
                    XPathNavigator objXmlBook
                        = objXmlDocument.SelectSingleNode("/chummer/books/book[code = " + strBook.CleanXPath() + ']');
                    if (objXmlBook != null)
                    {
                        string strToAppend = objXmlBook.SelectSingleNodeAndCacheExpression("translate")?.Value;
                        if (!string.IsNullOrEmpty(strToAppend))
                            sbdReturn.AppendLine(strToAppend);
                        else
                        {
                            strToAppend = objXmlBook.SelectSingleNode("name")?.Value;
                            if (!string.IsNullOrEmpty(strToAppend))
                                sbdReturn.AppendLine(strToAppend);
                            else
                            {
                                strToAppend = objXmlBook.SelectSingleNode("altcode")?.Value ?? strBook;
                                sbdReturn.Append(LanguageManager.GetString("String_Unknown", strLanguage))
                                         .Append(LanguageManager.GetString("String_Space", strLanguage)).Append('(')
                                         .Append(strToAppend).AppendLine(')');
                            }
                        }
                    }
                    else
                    {
                        sbdReturn.Append(LanguageManager.GetString("String_Unknown", strLanguage))
                                 .Append(LanguageManager.GetString("String_Space", strLanguage)).AppendLine(strBook);
                    }
                }

                return sbdReturn.ToString();
            }
        }

        #endregion

        //Can't be at improvementmanager due reasons
        private readonly Lazy<Stack<string>> _pushtext = new Lazy<Stack<string>>();

        /// <summary>
        /// Push a value that will be used instead of dialog instead in next <selecttext />
        /// </summary>
        public Stack<string> Pushtext => _pushtext.Value;

        private IHasMatrixAttributes _objActiveCommlink;

        /// <summary>
        /// The Active Commlink of the character. Returns null if character has no active commlink.
        /// </summary>
        public IHasMatrixAttributes ActiveCommlink
        {
            get => _objActiveCommlink;
            set
            {
                if(_objActiveCommlink != value)
                {
                    _objActiveCommlink = value;
                    OnPropertyChanged();
                }
            }
        }

        private IHasMatrixAttributes _objHomeNode;

        /// <summary>
        /// Home Node. Returns null if home node is not set to any item.
        /// </summary>
        public IHasMatrixAttributes HomeNode
        {
            get => _objHomeNode;
            set
            {
                if(_objHomeNode != value)
                {
                    _objHomeNode = value;
                    OnPropertyChanged();
                }
            }
        }

        [HubTag]
        public SkillsSection SkillsSection { get; }

        public int RedlinerBonus
        {
            get
            {
                if(_intCachedRedlinerBonus == int.MinValue)
                    RefreshRedlinerImprovements();
                return _intCachedRedlinerBonus;
            }
        }

        private bool RefreshRedlinerImprovements()
        {
            if (IsLoading) // If we are in the middle of loading, just queue a single refresh to happen at the end of the process
            {
                if (!PostLoadMethods.Contains(RefreshRedlinerImprovements))
                    PostLoadMethods.Enqueue(RefreshRedlinerImprovements);
                return true;
            }
            //Get attributes affected by redliner/cyber singularity seeker
            List<Improvement> lstSeekerImprovements = ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Attribute)
                                                                        .Where(objLoopImprovement => objLoopImprovement.SourceName.Contains("SEEKER")).ToList();
            lstSeekerImprovements.AddRange(ImprovementManager
                                           .GetCachedImprovementListForValueOf(
                                               this, Improvement.ImprovementType.PhysicalCM)
                                           .Where(objLoopImprovement =>
                                                      objLoopImprovement.SourceName.Contains("SEEKER")));
            List<string> lstSeekerAttributes = ImprovementManager
                                               .GetCachedImprovementListForValueOf(
                                                   this, Improvement.ImprovementType.Seeker)
                                               .Select(objImprovement => objImprovement.ImprovedName).ToList();

            //if neither contains anything, it is safe to exit
            if(lstSeekerImprovements.Count == 0 && lstSeekerAttributes.Count == 0)
            {
                _intCachedRedlinerBonus = 0;
                return true;
            }

            //Calculate bonus from cyberlimbs
            int intCount = Cyberware.Sum(objCyberware => objCyberware.GetCyberlimbCount(Settings.RedlinerExcludes));

            intCount = Math.Min(intCount / 2, 2);
            _intCachedRedlinerBonus = lstSeekerAttributes.Any(x => x == "STR" || x == "AGI")
                ? intCount
                : 0;

            for (int i = lstSeekerAttributes.Count - 1; i >= 0; --i)
            {
                string strSeekerAttribute = "SEEKER_" + lstSeekerAttributes[i];
                int intCountToTarget = strSeekerAttribute == "SEEKER_BOX" ? intCount * -3 : intCount;
                Improvement objImprovement
                    = lstSeekerImprovements.Find(x => x.SourceName == strSeekerAttribute
                                                      && x.Value == intCountToTarget);
                if (objImprovement != null)
                {
                    lstSeekerAttributes.RemoveAt(i);
                    lstSeekerImprovements.Remove(objImprovement);
                }
            }

            //Improvement manager defines the functions needed to manipulate improvements
            //When the locals (someday) gets moved to this class, this can be removed and use
            //the local
            if(lstSeekerImprovements.Count != 0 || lstSeekerAttributes.Count != 0)
            {
                // Remove which qualities have been removed or which values have changed
                ImprovementManager.RemoveImprovements(this, lstSeekerImprovements);

                // Add new improvements or old improvements with new values
                foreach(string strAttribute in lstSeekerAttributes)
                {
                    if(strAttribute == "BOX")
                    {
                        ImprovementManager.CreateImprovement(this, strAttribute, Improvement.ImprovementSource.Quality,
                            "SEEKER_BOX", Improvement.ImprovementType.PhysicalCM, Guid.NewGuid().ToString("D", GlobalSettings.InvariantCultureInfo),
                            intCount * -3);
                    }
                    else
                    {
                        ImprovementManager.CreateImprovement(this, strAttribute, Improvement.ImprovementSource.Quality,
                            "SEEKER_" + strAttribute, Improvement.ImprovementType.Attribute,
                            Guid.NewGuid().ToString("D", GlobalSettings.InvariantCultureInfo), intCount, 1, 0, 0, intCount);
                    }
                }

                ImprovementManager.Commit(this);
            }
            return true;
        }

        public void RefreshEssenceLossImprovements()
        {
            // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
            if (IsLoading)
                return;
            // Only worry about essence loss attribute modifiers if this character actually has any attributes that would be affected by essence loss
            // (which means EssenceAtSpecialStart is not set to decimal.MinValue)
            if(EssenceAtSpecialStart != decimal.MinValue)
            {
                decimal decESS = Essence();
                decimal decESSMag = Essence(true);
                if(!Settings.DontRoundEssenceInternally)
                {
                    int intESSDecimals = Settings.EssenceDecimals;
                    decESS = decimal.Round(decESS, intESSDecimals, MidpointRounding.AwayFromZero);
                    decESSMag = decimal.Round(decESSMag, intESSDecimals, MidpointRounding.AwayFromZero);
                }

                // Reduce a character's MAG and RES from Essence Loss.
                decimal decMetatypeMaximumESS = ESS.MetatypeMaximum;
                int intMagMaxReduction = (decMetatypeMaximumESS - decESSMag).StandardRound();
                int intMaxReduction = (decMetatypeMaximumESS - decESS).StandardRound();
                // Character has the option set where essence loss just acts as an augmented malus, so just replace old essence loss improvements with new ones that apply an augmented malus
                // equal to the amount by which the attribute's maximum would normally be reduced.
                if(Settings.SpecialKarmaCostBasedOnShownValue)
                {
                    Improvement.ImprovementSource eEssenceLossSource = Created
                        ? Improvement.ImprovementSource.EssenceLoss
                        : Improvement.ImprovementSource.EssenceLossChargen;
                    ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.EssenceLoss);
                    ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.EssenceLossChargen);
                    // With this house rule, Cyberadept Daemon just negates a penalty from Essence based on Grade instead of restoring Resonance, so delete all old improvements
                    ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.CyberadeptDaemon);
                    if (intMaxReduction != 0)
                    {
                        int intCyberadeptDaemonBonus = 0;
                        if (TechnomancerEnabled && SubmersionGrade > 0 && ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.CyberadeptDaemon).Count > 0)
                            intCyberadeptDaemonBonus = Math.Min(SubmersionGrade.DivAwayFromZero(2), (int) Math.Ceiling(CyberwareEssence));
                        ImprovementManager.CreateImprovement(this, "RES", eEssenceLossSource, string.Empty,
                            Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, 0, Math.Min(0, intCyberadeptDaemonBonus - intMaxReduction));
                        ImprovementManager.CreateImprovement(this, "DEP", eEssenceLossSource, string.Empty,
                            Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, 0, -intMaxReduction);
                    }

                    if(intMagMaxReduction != 0)
                    {
                        ImprovementManager.CreateImprovement(this, "MAG", eEssenceLossSource, string.Empty,
                            Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, 0, -intMagMaxReduction);
                        ImprovementManager.CreateImprovement(this, "MAGAdept", eEssenceLossSource, string.Empty,
                            Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, 0, -intMagMaxReduction);
                        // If this is a Mystic Adept using special Mystic Adept PP rules (i.e. no second MAG attribute), Mystic Adepts lose PPs even if they have fewer PPs than their MAG
                        if(UseMysticAdeptPPs)
                            ImprovementManager.CreateImprovement(this, string.Empty, eEssenceLossSource, string.Empty,
                                Improvement.ImprovementType.AdeptPowerPoints, string.Empty, -intMagMaxReduction);
                    }

                    if (intMaxReduction != 0 || intMagMaxReduction != 0)
                        ImprovementManager.Commit(this);
                }
                // RAW Career mode: complicated. Similar to RAW Create mode, but with the extra possibility of burning current karma levels and/or PPs instead of pure minima reduction,
                // plus the need to account for cases where a character will burn "past" 0 (i.e. to a current value that should be negative), but then upgrade to 1 afterwards.
                else if(Created)
                {
                    // "Base" minimum reduction. This is the amount by which the character's special attribute minima would be reduced across career and create modes if there wasn't any funny business
                    int intMinReduction = (EssenceAtSpecialStart - decESS).StandardRound();
                    int intMagMinReduction = (EssenceAtSpecialStart - decESSMag).StandardRound();

                    // This extra code is needed for legacy shims, to convert proper attribute values for characters who would end up having a higher level than their total attribute maxima
                    // They are extra amounts by which the relevant attributes' karma levels should be burned
                    int intExtraRESBurn = Math.Max(0,
                        Math.Max(RES.Base + RES.FreeBase + RES.RawMinimum + RES.AttributeValueModifiers,
                            RES.TotalMinimum) + RES.Karma - RES.TotalMaximum);
                    int intExtraDEPBurn = Math.Max(0,
                        Math.Max(DEP.Base + DEP.FreeBase + DEP.RawMinimum + DEP.AttributeValueModifiers,
                            DEP.TotalMinimum) + DEP.Karma - DEP.TotalMaximum);
                    int intExtraMAGBurn = Math.Max(0,
                        Math.Max(MAG.Base + MAG.FreeBase + MAG.RawMinimum + MAG.AttributeValueModifiers,
                            MAG.TotalMinimum) + MAG.Karma - MAG.TotalMaximum);
                    int intExtraMAGAdeptBurn = Math.Max(0,
                        Math.Max(
                            MAGAdept.Base + MAGAdept.FreeBase + MAGAdept.RawMinimum + MAGAdept.AttributeValueModifiers,
                            MAGAdept.TotalMinimum) + MAGAdept.Karma - MAGAdept.TotalMaximum);
                    // Old values for minimum reduction from essence loss in career mode. These are used to determine if any karma needs to get burned.
                    int intOldRESCareerMinimumReduction = 0;
                    int intOldDEPCareerMinimumReduction = 0;
                    int intOldMAGCareerMinimumReduction = 0;
                    int intOldMAGAdeptCareerMinimumReduction = 0;
                    foreach(Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Attribute))
                    {
                        if(objImprovement.ImproveSource == Improvement.ImprovementSource.EssenceLoss)
                        {
                            // Values get subtracted because negative modifier = positive reduction, positive modifier = negative reduction
                            // Augmented values also get factored in in case the character is switching off the option to treat essence loss as an augmented malus
                            switch(objImprovement.ImprovedName)
                            {
                                case "RES":
                                    intOldRESCareerMinimumReduction -=
                                        objImprovement.Minimum + objImprovement.Augmented.StandardRound();
                                    break;
                                case "DEP":
                                    intOldDEPCareerMinimumReduction -=
                                        objImprovement.Minimum + objImprovement.Augmented.StandardRound();
                                    break;
                                case "MAG":
                                    intOldMAGCareerMinimumReduction -=
                                        objImprovement.Minimum + objImprovement.Augmented.StandardRound();
                                    break;
                                case "MAGAdept":
                                    intOldMAGAdeptCareerMinimumReduction -=
                                        objImprovement.Minimum + objImprovement.Augmented.StandardRound();
                                    break;
                            }
                        }
                    }

                    // Remove any Improvements from MAG, RES, and DEP from Essence Loss that were added in career.
                    ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.EssenceLoss);

                    // Career Minimum and Maximum reduction relies on whether there's any extra reduction since chargen.
                    // This is the step where create mode attribute loss regarding attribute maximum loss gets factored out.
                    int intRESMaximumReduction = intMaxReduction + RES.TotalMaximum - RES.MaximumNoEssenceLoss();
                    int intDEPMaximumReduction = intMaxReduction + DEP.TotalMaximum - DEP.MaximumNoEssenceLoss();
                    int intMAGMaximumReduction = intMagMaxReduction + MAG.TotalMaximum - MAG.MaximumNoEssenceLoss();
                    int intMAGAdeptMaximumReduction =
                        intMagMaxReduction + MAGAdept.TotalMaximum - MAGAdept.MaximumNoEssenceLoss();

                    // Create the Essence Loss (or gain, in case of essence restoration and increasing maxima) Improvements.
                    if(intMaxReduction > 0
                       || intMinReduction > 0
                       || intRESMaximumReduction != 0
                       || intDEPMaximumReduction != 0)
                    {
                        // This is the step where create mode attribute loss regarding attribute minimum loss gets factored out.
                        int intRESMinimumReduction;
                        int intDEPMinimumReduction;
                        // If only maxima would be reduced, use the attribute's current total value instead of its current maximum, as this makes sure minima will only get reduced if the maximum reduction would eat into the current value
                        if(Settings.ESSLossReducesMaximumOnly)
                        {
                            intRESMinimumReduction = Math.Max(0,
                                intMinReduction + RES.TotalValue - RES.MaximumNoEssenceLoss(true));
                            intDEPMinimumReduction = Math.Max(0,
                                intMinReduction + DEP.TotalValue - DEP.MaximumNoEssenceLoss(true));
                        }
                        else
                        {
                            intRESMinimumReduction =
                                intMinReduction + RES.TotalMaximum - RES.MaximumNoEssenceLoss(true);
                            intDEPMinimumReduction =
                                intMinReduction + DEP.TotalMaximum - DEP.MaximumNoEssenceLoss(true);
                        }

                        // If the new RES reduction is greater than the old one...
                        int intRESMinimumReductionDelta = intRESMinimumReduction - intOldRESCareerMinimumReduction;
                        if(intRESMinimumReductionDelta > 0)
                        {
                            // ... and adding minimum reducing-improvements wouldn't do anything, start burning karma.
                            if(intRESMinimumReduction >
                                RES.Base + RES.FreeBase + RES.RawMinimum + RES.AttributeValueModifiers)
                            {
                                // intRESMinimumReduction is not actually reduced so that karma doesn't get burned away each time this function is called.
                                // Besides, this only fires if intRESMinimumReduction is already at a level where increasing it any more wouldn't have any effect on the character.
                                intExtraRESBurn += Math.Min(RES.Karma, intRESMinimumReductionDelta);
                                RES.Karma -= intExtraRESBurn;
                            }
                        }
                        // If the new RES reduction is less than our old one, the character doesn't actually get any new values back
                        else
                        {
                            intRESMinimumReduction = intOldRESCareerMinimumReduction;
                        }

                        // If the new DEP reduction is greater than the old one...
                        int intDEPMinimumReductionDelta = intDEPMinimumReduction - intOldDEPCareerMinimumReduction;
                        if(intDEPMinimumReductionDelta > 0)
                        {
                            // ... and adding minimum reducing-improvements wouldn't do anything, start burning karma.
                            if(intDEPMinimumReduction >
                                DEP.Base + DEP.FreeBase + DEP.RawMinimum + DEP.AttributeValueModifiers)
                            {
                                // intDEPMinimumReduction is not actually reduced so that karma doesn't get burned away each time this function is called.
                                // Besides, this only fires if intDEPMinimumReduction is already at a level where increasing it any more wouldn't have any effect on the character.
                                intExtraDEPBurn += Math.Min(DEP.Karma, intDEPMinimumReductionDelta);
                                DEP.Karma -= intExtraDEPBurn;
                            }
                        }
                        // If the new DEP reduction is less than our old one, the character doesn't actually get any new values back
                        else
                        {
                            intDEPMinimumReduction = intOldDEPCareerMinimumReduction;
                        }

                        // Create Improvements
                        if(intRESMinimumReduction != 0 || intRESMaximumReduction != 0)
                            ImprovementManager.CreateImprovement(this, "RES", Improvement.ImprovementSource.EssenceLoss,
                                string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1,
                                -intRESMinimumReduction, -intRESMaximumReduction);
                        if(intDEPMinimumReduction != 0 || intDEPMaximumReduction != 0)
                            ImprovementManager.CreateImprovement(this, "DEP", Improvement.ImprovementSource.EssenceLoss,
                                string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1,
                                -intDEPMinimumReduction, -intDEPMaximumReduction);
                        if (intRESMinimumReduction != 0 || intRESMaximumReduction != 0 ||
                            intDEPMinimumReduction != 0 || intDEPMaximumReduction != 0)
                            ImprovementManager.Commit(this);
                    }

                    if(intMagMaxReduction > 0
                       || intMagMinReduction > 0
                       || intMAGMaximumReduction != 0
                       || intMAGAdeptMaximumReduction != 0)
                    {
                        // This is the step where create mode attribute loss regarding attribute minimum loss gets factored out.
                        int intMAGMinimumReduction;
                        int intMAGAdeptMinimumReduction;
                        // If only maxima would be reduced, use the attribute's current total value instead of its current maximum, as this makes sure minima will only get reduced if the maximum reduction would eat into the current value
                        if(Settings.ESSLossReducesMaximumOnly)
                        {
                            intMAGMinimumReduction = Math.Max(0,
                                intMagMinReduction + MAG.TotalValue - MAG.MaximumNoEssenceLoss(true));
                            intMAGAdeptMinimumReduction = Math.Max(0,
                                intMagMinReduction + MAGAdept.TotalValue - MAGAdept.MaximumNoEssenceLoss(true));
                        }
                        else
                        {
                            intMAGMinimumReduction =
                                intMagMinReduction + MAG.TotalMaximum - MAG.MaximumNoEssenceLoss(true);
                            intMAGAdeptMinimumReduction =
                                intMagMinReduction + MAGAdept.TotalMaximum - MAGAdept.MaximumNoEssenceLoss(true);
                        }

                        // If the new MAG reduction is greater than the old one...
                        int intMAGMinimumReductionDelta = intMAGMinimumReduction - intOldMAGCareerMinimumReduction;
                        if(intMAGMinimumReductionDelta > 0)
                        {
                            // ... and adding minimum reducing-improvements wouldn't do anything, start burning karma.
                            if(intMAGMinimumReduction >
                                MAG.Base + MAG.FreeBase + MAG.RawMinimum + MAG.AttributeValueModifiers)
                            {
                                // intMAGMinimumReduction is not actually reduced so that karma doesn't get burned away each time this function is called.
                                // Besides, this only fires if intMAGMinimumReduction is already at a level where increasing it any more wouldn't have any effect on the character.
                                intExtraMAGBurn += Math.Min(MAG.Karma, intMAGMinimumReductionDelta);
                                MAG.Karma -= intExtraMAGBurn;
                            }

                            // Mystic Adept PPs may need to be burned away based on the change of our MAG attribute
                            if(UseMysticAdeptPPs)
                            {
                                // First burn away PPs gained during chargen...
                                int intChargenPPBurn = Math.Min(MysticAdeptPowerPoints, intMAGMinimumReductionDelta);
                                MysticAdeptPowerPoints -= intChargenPPBurn;
                                // ... now burn away PPs gained from initiations.
                                decimal decPPBurn = Math.Min(intMAGMinimumReductionDelta - intChargenPPBurn,
                                    ImprovementManager.ValueOf(this, Improvement.ImprovementType.AdeptPowerPoints));
                                // Source needs to be EssenceLossChargen so that it doesn't get wiped in career mode.
                                if(decPPBurn != 0)
                                {
                                    ImprovementManager.CreateImprovement(this, string.Empty,
                                        Improvement.ImprovementSource.EssenceLossChargen, string.Empty,
                                        Improvement.ImprovementType.AdeptPowerPoints, string.Empty, -decPPBurn);
                                    ImprovementManager.Commit(this);
                                }
                            }
                        }
                        // If the new MAG reduction is less than our old one, the character doesn't actually get any new values back
                        else
                        {
                            intMAGMinimumReduction = intOldMAGCareerMinimumReduction;
                        }

                        // Make sure we only attempt to burn MAGAdept karma levels if it's actually a separate attribute from MAG
                        if(MAGAdept != MAG)
                        {
                            // If the new MAGAdept reduction is greater than the old one...
                            int intMAGAdeptMinimumReductionDelta =
                                intMAGAdeptMinimumReduction - intOldMAGAdeptCareerMinimumReduction;
                            if(intMAGAdeptMinimumReductionDelta > 0)
                            {
                                // ... and adding minimum reducing-improvements wouldn't do anything, start burning karma.
                                if(intMAGAdeptMinimumReduction > MAGAdept.Base + MAGAdept.FreeBase +
                                    MAGAdept.RawMinimum + MAGAdept.AttributeValueModifiers)
                                {
                                    // intMAGAdeptMinimumReduction is not actually reduced so that karma doesn't get burned away each time this function is called.
                                    // Besides, this only fires if intMAGAdeptMinimumReduction is already at a level where increasing it any more wouldn't have any effect on the character.
                                    intExtraMAGAdeptBurn += Math.Min(MAGAdept.Karma, intMAGAdeptMinimumReductionDelta);
                                    MAGAdept.Karma -= intExtraMAGAdeptBurn;
                                }
                            }
                            // If the new MAGAdept reduction is less than our old one, the character doesn't actually get any new values back
                            else
                            {
                                intMAGAdeptMinimumReduction = intOldMAGAdeptCareerMinimumReduction;
                            }
                        }
                        // Otherwise make sure that if the new MAGAdept reduction is less than our old one, the character doesn't actually get any new values back
                        else if(intMAGAdeptMinimumReduction < intOldMAGAdeptCareerMinimumReduction)
                        {
                            intMAGAdeptMinimumReduction = intOldMAGAdeptCareerMinimumReduction;
                        }

                        // Create Improvements
                        if(intMAGMinimumReduction != 0 || intMAGMaximumReduction != 0)
                            ImprovementManager.CreateImprovement(this, "MAG", Improvement.ImprovementSource.EssenceLoss,
                                string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1,
                                -intMAGMinimumReduction, -intMAGMaximumReduction);
                        if(intMAGAdeptMinimumReduction != 0 || intMAGAdeptMaximumReduction != 0)
                            ImprovementManager.CreateImprovement(this, "MAGAdept",
                                Improvement.ImprovementSource.EssenceLoss, string.Empty,
                                Improvement.ImprovementType.Attribute, string.Empty, 0, 1, -intMAGAdeptMinimumReduction,
                                -intMAGAdeptMaximumReduction);
                        if (intMAGMinimumReduction != 0 || intMAGMaximumReduction != 0 ||
                            intMAGAdeptMinimumReduction != 0 || intMAGAdeptMaximumReduction != 0)
                            ImprovementManager.Commit(this);
                    }
                }
                // RAW Create mode: Reduce maxima based on max ESS - current ESS, reduce minima based on their essence from the most optimal way in which they could have gotten access to special attributes
                else
                {
                    int intMinReduction = (EssenceAtSpecialStart - decESS).StandardRound();
                    int intMagMinReduction = (EssenceAtSpecialStart - decESSMag).StandardRound();
                    int intRESMinimumReduction = intMinReduction;
                    int intDEPMinimumReduction = intMinReduction;
                    int intMAGMinimumReduction = intMagMinReduction;
                    int intMAGAdeptMinimumReduction = intMagMinReduction;
                    if(Settings.ESSLossReducesMaximumOnly)
                    {
                        intRESMinimumReduction = Math.Max(0, intMinReduction + RES.TotalValue - RES.TotalMaximum);
                        intDEPMinimumReduction = Math.Max(0, intMinReduction + DEP.TotalValue - DEP.TotalMaximum);
                        intMAGMinimumReduction = Math.Max(0, intMagMinReduction + MAG.TotalValue - MAG.TotalMaximum);
                        intMAGAdeptMinimumReduction = Math.Max(0,
                            intMagMinReduction + MAGAdept.TotalValue - MAGAdept.TotalMaximum);
                    }

                    ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.EssenceLoss);
                    ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.EssenceLossChargen);
                    if(intMaxReduction != 0 || intRESMinimumReduction != 0 || intDEPMinimumReduction != 0)
                    {
                        ImprovementManager.CreateImprovement(this, "RES",
                            Improvement.ImprovementSource.EssenceLossChargen, string.Empty,
                            Improvement.ImprovementType.Attribute, string.Empty, 0, 1, -intRESMinimumReduction,
                            -intMaxReduction);
                        ImprovementManager.CreateImprovement(this, "DEP",
                            Improvement.ImprovementSource.EssenceLossChargen, string.Empty,
                            Improvement.ImprovementType.Attribute, string.Empty, 0, 1, -intDEPMinimumReduction,
                            -intMaxReduction);
                    }

                    if(intMagMaxReduction != 0 || intMAGMinimumReduction != 0 || intMAGAdeptMinimumReduction != 0)
                    {
                        ImprovementManager.CreateImprovement(this, "MAG",
                            Improvement.ImprovementSource.EssenceLossChargen, string.Empty,
                            Improvement.ImprovementType.Attribute, string.Empty, 0, 1, -intMAGMinimumReduction,
                            -intMagMaxReduction);
                        ImprovementManager.CreateImprovement(this, "MAGAdept",
                            Improvement.ImprovementSource.EssenceLossChargen, string.Empty,
                            Improvement.ImprovementType.Attribute, string.Empty, 0, 1, -intMAGAdeptMinimumReduction,
                            -intMagMaxReduction);
                    }
                }

                ImprovementManager.Commit(this);

                // If the character is in Career mode, it is possible for them to be forced to burn out.
                if(Created)
                {
                    // If the CharacterAttribute reaches 0, the character has burned out.
                    if(MAGEnabled)
                    {
                        if(Settings.SpecialKarmaCostBasedOnShownValue)
                        {
                            if(Settings.MysAdeptSecondMAGAttribute && IsMysticAdept)
                            {
                                if(intMagMaxReduction >= MAG.TotalMaximum)
                                {
                                    MAG.Base = MAGAdept.Base;
                                    MAG.Karma = MAGAdept.Karma;
                                    MAG.MetatypeMinimum = MAGAdept.MetatypeMinimum;
                                    MAG.MetatypeMaximum = MAGAdept.MetatypeMaximum;
                                    MAG.MetatypeAugmentedMaximum = MAGAdept.MetatypeAugmentedMaximum;
                                    MAGAdept.Base = 0;
                                    MAGAdept.Karma = 0;
                                    MAGAdept.MetatypeMinimum = 0;
                                    MAGAdept.MetatypeMaximum = 0;
                                    MAGAdept.MetatypeAugmentedMaximum = 0;

                                    MagicianEnabled = false;
                                }

                                if(intMagMaxReduction >= MAGAdept.TotalMaximum)
                                {
                                    MAGAdept.Base = 0;
                                    MAGAdept.Karma = 0;
                                    MAGAdept.MetatypeMinimum = 0;
                                    MAGAdept.MetatypeMaximum = 0;
                                    MAGAdept.MetatypeAugmentedMaximum = 0;

                                    AdeptEnabled = false;
                                }

                                if(!MagicianEnabled && !AdeptEnabled)
                                    MAGEnabled = false;
                            }
                            else if(intMagMaxReduction >= MAG.TotalMaximum)
                            {
                                MAG.Base = 0;
                                MAG.Karma = 0;
                                MAG.MetatypeMinimum = 0;
                                MAG.MetatypeMaximum = 0;
                                MAG.MetatypeAugmentedMaximum = 0;

                                MagicianEnabled = false;
                                AdeptEnabled = false;
                                MAGEnabled = false;
                            }
                        }
                        else if (Settings.MysAdeptSecondMAGAttribute && IsMysticAdept)
                        {
                            if (MAG.TotalMaximum < 1)
                            {
                                MAG.Base = MAGAdept.Base;
                                MAG.Karma = MAGAdept.Karma;
                                MAG.MetatypeMinimum = MAGAdept.MetatypeMinimum;
                                MAG.MetatypeMaximum = MAGAdept.MetatypeMaximum;
                                MAG.MetatypeAugmentedMaximum = MAGAdept.MetatypeAugmentedMaximum;
                                MAGAdept.Base = 0;
                                MAGAdept.Karma = 0;
                                MAGAdept.MetatypeMinimum = 0;
                                MAGAdept.MetatypeMaximum = 0;
                                MAGAdept.MetatypeAugmentedMaximum = 0;

                                MagicianEnabled = false;
                            }

                            if (MAGAdept.TotalMaximum < 1)
                            {
                                MAGAdept.Base = 0;
                                MAGAdept.Karma = 0;
                                MAGAdept.MetatypeMinimum = 0;
                                MAGAdept.MetatypeMaximum = 0;
                                MAGAdept.MetatypeAugmentedMaximum = 0;

                                AdeptEnabled = false;
                            }

                            if (!MagicianEnabled && !AdeptEnabled)
                                MAGEnabled = false;
                        }
                        else if (MAG.TotalMaximum < 1)
                        {
                            MAG.Base = 0;
                            MAG.Karma = 0;
                            MAG.MetatypeMinimum = 0;
                            MAG.MetatypeMaximum = 0;
                            MAG.MetatypeAugmentedMaximum = 0;

                            MagicianEnabled = false;
                            AdeptEnabled = false;
                            MAGEnabled = false;
                        }
                    }

                    if(RESEnabled
                       && (Settings.SpecialKarmaCostBasedOnShownValue
                           && intMaxReduction >= RES.TotalMaximum
                           || !Settings.SpecialKarmaCostBasedOnShownValue
                           && RES.TotalMaximum < 1))
                    {
                        RES.Base = 0;
                        RES.Karma = 0;
                        RES.MetatypeMinimum = 0;
                        RES.MetatypeMinimum = 0;
                        RES.MetatypeAugmentedMaximum = 0;

                        RESEnabled = false;
                        TechnomancerEnabled = false;
                    }
                }
            }
            // Otherwise any essence loss improvements that might have been left need to be deleted (e.g. character is in create mode and had access to special attributes, but that access was removed)
            else
            {
                ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.EssenceLossChargen);
                ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.EssenceLoss);
                ImprovementManager.Commit(this);
            }

            // If the character is Cyberzombie, adjust their Attributes based on their Essence.
            if(MetatypeCategory == "Cyberzombie")
            {
                int intESSModifier = (-Essence()).StandardRound();
                ImprovementManager.RemoveImprovements(this,
                    Improvements.Where(x =>
                        x.ImproveSource == Improvement.ImprovementSource.Cyberzombie &&
                        x.ImproveType == Improvement.ImprovementType.Attribute).ToList());
                if(intESSModifier != 0)
                {
                    ImprovementManager.CreateImprovement(this, "BOD", Improvement.ImprovementSource.Cyberzombie,
                        string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, intESSModifier);
                    ImprovementManager.CreateImprovement(this, "AGI", Improvement.ImprovementSource.Cyberzombie,
                        string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, intESSModifier);
                    ImprovementManager.CreateImprovement(this, "REA", Improvement.ImprovementSource.Cyberzombie,
                        string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, intESSModifier);
                    ImprovementManager.CreateImprovement(this, "STR", Improvement.ImprovementSource.Cyberzombie,
                        string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, intESSModifier);
                    ImprovementManager.CreateImprovement(this, "CHA", Improvement.ImprovementSource.Cyberzombie,
                        string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, intESSModifier);
                    ImprovementManager.CreateImprovement(this, "INT", Improvement.ImprovementSource.Cyberzombie,
                        string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, intESSModifier);
                    ImprovementManager.CreateImprovement(this, "LOG", Improvement.ImprovementSource.Cyberzombie,
                        string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, intESSModifier);
                    ImprovementManager.CreateImprovement(this, "WIL", Improvement.ImprovementSource.Cyberzombie,
                        string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, intESSModifier);
                    ImprovementManager.Commit(this);
                }
            }
        }

        public void RefreshBODDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(16)
                    {
                        nameof(LimitPhysical),
                        nameof(DamageResistancePool),
                        nameof(LiftAndCarry),
                        nameof(FatigueResist),
                        nameof(RadiationResist),
                        nameof(PhysiologicalAddictionResistFirstTime),
                        nameof(PhysiologicalAddictionResistAlreadyAddicted),
                        nameof(StunCMNaturalRecovery),
                        nameof(PhysicalCMNaturalRecovery),
                        nameof(PhysicalCM),
                        nameof(CMOverflow),
                        nameof(SpellDefenseIndirectSoak),
                        nameof(SpellDefenseDirectSoakPhysical),
                        nameof(SpellDefenseDecreaseBOD),
                        nameof(SpellDefenseManipulationPhysical)
                    };
                    if (!Created)
                    {
                        if (Settings.ContactPointsExpression.Contains("{BOD}"))
                            lstProperties.Add(nameof(ContactPoints));
                        if (Settings.ChargenKarmaToNuyenExpression.Contains("{BOD}"))
                            lstProperties.Add(nameof(TotalStartingNuyen));
                    }
                    OnMultiplePropertyChanged(lstProperties);
                    if (!Created && Settings.KnowledgePointsExpression.Contains("{BOD}"))
                        SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    if (Settings.BoundSpiritExpression.Contains("{BOD}"))
                        _intBoundSpiritLimit = int.MinValue;
                    if (Settings.RegisteredSpriteExpression.Contains("{BOD}"))
                        _intRegisteredSpriteLimit = int.MinValue;
                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    if (!Created)
                    {
                        if (Settings.ContactPointsExpression.Contains("{BODUnaug}"))
                        {
                            if (Settings.ChargenKarmaToNuyenExpression.Contains("{BODUnaug}"))
                                this.OnMultiplePropertyChanged(nameof(ContactPoints), nameof(TotalStartingNuyen));
                            else
                                OnPropertyChanged(nameof(ContactPoints));
                        }
                        else if (Settings.ChargenKarmaToNuyenExpression.Contains("{BODUnaug}"))
                            OnPropertyChanged(nameof(TotalStartingNuyen));
                        if (Settings.KnowledgePointsExpression.Contains("{BODUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }
                    if (Settings.BoundSpiritExpression.Contains("{BODUnaug}"))
                        _intBoundSpiritLimit = int.MinValue;
                    if (Settings.RegisteredSpriteExpression.Contains("{BODUnaug}"))
                        _intRegisteredSpriteLimit = int.MinValue;
                    break;
                }
                case nameof(CharacterAttrib.MetatypeMaximum):
                {
                    if(DEPEnabled)
                        OnPropertyChanged(nameof(IsAI));
                    break;
                }
            }
        }

        public void RefreshAGIDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(2)
                    {
                        nameof(SpellDefenseDecreaseAGI)
                    };
                    if (!Created)
                    {
                        if (Settings.ContactPointsExpression.Contains("{AGI}"))
                            lstProperties.Add(nameof(ContactPoints));
                        if (Settings.ChargenKarmaToNuyenExpression.Contains("{AGI}"))
                            lstProperties.Add(nameof(TotalStartingNuyen));
                    }
                    OnMultiplePropertyChanged(lstProperties);
                    if (!Created && Settings.KnowledgePointsExpression.Contains("{AGI}"))
                        SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    if (Settings.BoundSpiritExpression.Contains("{AGI}"))
                        _intBoundSpiritLimit = int.MinValue;
                    if (Settings.RegisteredSpriteExpression.Contains("{AGI}"))
                        _intRegisteredSpriteLimit = int.MinValue;
                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    if (!Created)
                    {
                        if (Settings.ContactPointsExpression.Contains("{AGIUnaug}"))
                        {
                            if (Settings.ChargenKarmaToNuyenExpression.Contains("{AGIUnaug}"))
                                this.OnMultiplePropertyChanged(nameof(ContactPoints), nameof(TotalStartingNuyen));
                            else
                                OnPropertyChanged(nameof(ContactPoints));
                        }
                        else if (Settings.ChargenKarmaToNuyenExpression.Contains("{AGIUnaug}"))
                            OnPropertyChanged(nameof(TotalStartingNuyen));
                        if (Settings.KnowledgePointsExpression.Contains("{AGIUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }
                    if (Settings.BoundSpiritExpression.Contains("{AGIUnaug}"))
                        _intBoundSpiritLimit = int.MinValue;
                    if (Settings.RegisteredSpriteExpression.Contains("{AGIUnaug}"))
                        _intRegisteredSpriteLimit = int.MinValue;
                    break;
                }
            }
        }

        public void RefreshREADependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(6)
                    {
                        nameof(LimitPhysical),
                        nameof(InitiativeValue),
                        nameof(Dodge),
                        nameof(SpellDefenseDecreaseREA),
                        nameof(Surprise)
                    };
                    if (!Created)
                    {
                        if (Settings.ContactPointsExpression.Contains("{REA}"))
                            lstProperties.Add(nameof(ContactPoints));
                        if (Settings.ChargenKarmaToNuyenExpression.Contains("{REA}"))
                            lstProperties.Add(nameof(TotalStartingNuyen));
                    }
                    OnMultiplePropertyChanged(lstProperties);
                    if (!Created && Settings.KnowledgePointsExpression.Contains("{REA}"))
                        SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    if (Settings.BoundSpiritExpression.Contains("{REA}"))
                        _intBoundSpiritLimit = int.MinValue;
                    if (Settings.RegisteredSpriteExpression.Contains("{REA}"))
                        _intRegisteredSpriteLimit = int.MinValue;
                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    if (!Created)
                    {
                        if (Settings.ContactPointsExpression.Contains("{REAUnaug}"))
                        {
                            if (Settings.ChargenKarmaToNuyenExpression.Contains("{REAUnaug}"))
                                this.OnMultiplePropertyChanged(nameof(ContactPoints), nameof(TotalStartingNuyen));
                            else
                                OnPropertyChanged(nameof(ContactPoints));
                        }
                        else if (Settings.ChargenKarmaToNuyenExpression.Contains("{REAUnaug}"))
                            OnPropertyChanged(nameof(TotalStartingNuyen));
                        if (Settings.KnowledgePointsExpression.Contains("{REAUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }
                    if (Settings.BoundSpiritExpression.Contains("{REAUnaug}"))
                        _intBoundSpiritLimit = int.MinValue;
                    if (Settings.RegisteredSpriteExpression.Contains("{REAUnaug}"))
                        _intRegisteredSpriteLimit = int.MinValue;
                    break;
                }
            }
        }

        public void RefreshSTRDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    // Encumbrance is only affected by STR.TotalValue when it comes to attributes
                    RefreshEncumbrance();
                    List<string> lstProperties = new List<string>(5)
                    {
                        nameof(LimitPhysical),
                        nameof(LiftAndCarry),
                        nameof(SpellDefenseDecreaseSTR),
                        nameof(SpellDefenseManipulationPhysical)
                    };
                    if (!Created)
                    {
                        if (Settings.ContactPointsExpression.Contains("{STR}"))
                            lstProperties.Add(nameof(ContactPoints));
                        if (Settings.ChargenKarmaToNuyenExpression.Contains("{STR}"))
                            lstProperties.Add(nameof(TotalStartingNuyen));
                    }
                    OnMultiplePropertyChanged(lstProperties);
                    if (!Created && Settings.KnowledgePointsExpression.Contains("{STR}"))
                        SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    if (Settings.BoundSpiritExpression.Contains("{STR}"))
                        _intBoundSpiritLimit = int.MinValue;
                    if (Settings.RegisteredSpriteExpression.Contains("{STR}"))
                        _intRegisteredSpriteLimit = int.MinValue;
                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    if (!Created)
                    {
                        if (Settings.ContactPointsExpression.Contains("{STRUnaug}"))
                        {
                            if (Settings.ChargenKarmaToNuyenExpression.Contains("{STRUnaug}"))
                                this.OnMultiplePropertyChanged(nameof(ContactPoints), nameof(TotalStartingNuyen));
                            else
                                OnPropertyChanged(nameof(ContactPoints));
                        }
                        else if (Settings.ChargenKarmaToNuyenExpression.Contains("{STRUnaug}"))
                            OnPropertyChanged(nameof(TotalStartingNuyen));
                        if (Settings.KnowledgePointsExpression.Contains("{STRUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }
                    if (Settings.BoundSpiritExpression.Contains("{STRUnaug}"))
                        _intBoundSpiritLimit = int.MinValue;
                    if (Settings.RegisteredSpriteExpression.Contains("{STRUnaug}"))
                        _intRegisteredSpriteLimit = int.MinValue;
                    break;
                }
            }
        }

        public void RefreshCHADependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(6)
                    {
                        nameof(LimitSocial),
                        nameof(Composure),
                        nameof(JudgeIntentions),
                        nameof(JudgeIntentionsResist),
                        nameof(SpellDefenseDecreaseCHA)
                    };
                    if (!Created)
                    {
                        if (Settings.ContactPointsExpression.Contains("{CHA}"))
                            lstProperties.Add(nameof(ContactPoints));
                        if (Settings.ChargenKarmaToNuyenExpression.Contains("{CHA}"))
                            lstProperties.Add(nameof(TotalStartingNuyen));
                    }
                    OnMultiplePropertyChanged(lstProperties);
                    if (!Created && Settings.KnowledgePointsExpression.Contains("{CHA}"))
                        SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    if (Settings.BoundSpiritExpression.Contains("{CHA}"))
                        _intBoundSpiritLimit = int.MinValue;
                    if (Settings.RegisteredSpriteExpression.Contains("{CHA}"))
                        _intRegisteredSpriteLimit = int.MinValue;
                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    if (!Created)
                    {
                        if (Settings.ContactPointsExpression.Contains("{CHAUnaug}"))
                        {
                            if (Settings.ChargenKarmaToNuyenExpression.Contains("{CHAUnaug}"))
                                this.OnMultiplePropertyChanged(nameof(ContactPoints), nameof(TotalStartingNuyen));
                            else
                                OnPropertyChanged(nameof(ContactPoints));
                        }
                        else if (Settings.ChargenKarmaToNuyenExpression.Contains("{CHAUnaug}"))
                            OnPropertyChanged(nameof(TotalStartingNuyen));
                        if (Settings.KnowledgePointsExpression.Contains("{CHAUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }
                    if (Settings.BoundSpiritExpression.Contains("{CHAUnaug}"))
                        _intBoundSpiritLimit = int.MinValue;
                    if (Settings.RegisteredSpriteExpression.Contains("{CHAUnaug}"))
                        _intRegisteredSpriteLimit = int.MinValue;
                    break;
                }
            }
        }

        public void RefreshINTDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(12)
                    {
                        nameof(LimitMental),
                        nameof(JudgeIntentions),
                        nameof(InitiativeValue),
                        nameof(AstralInitiativeValue),
                        nameof(MatrixInitiativeValue),
                        nameof(MatrixInitiativeColdValue),
                        nameof(MatrixInitiativeHotValue),
                        nameof(Dodge),
                        nameof(SpellDefenseDecreaseINT),
                        nameof(SpellDefenseIllusionPhysical),
                        nameof(Surprise)
                    };
                    if (!Created)
                    {
                        if (Settings.ContactPointsExpression.Contains("{INT}"))
                            lstProperties.Add(nameof(ContactPoints));
                        if (Settings.ChargenKarmaToNuyenExpression.Contains("{INT}"))
                            lstProperties.Add(nameof(TotalStartingNuyen));
                    }
                    OnMultiplePropertyChanged(lstProperties);
                    if (!Created && Settings.KnowledgePointsExpression.Contains("{INT}"))
                        SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    if (Settings.BoundSpiritExpression.Contains("{INT}"))
                        _intBoundSpiritLimit = int.MinValue;
                    if (Settings.RegisteredSpriteExpression.Contains("{INT}"))
                        _intRegisteredSpriteLimit = int.MinValue;
                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    if (!Created)
                    {
                        if (Settings.ContactPointsExpression.Contains("{INTUnaug}"))
                        {
                            if (Settings.ChargenKarmaToNuyenExpression.Contains("{INTUnaug}"))
                                this.OnMultiplePropertyChanged(nameof(ContactPoints), nameof(TotalStartingNuyen));
                            else
                                OnPropertyChanged(nameof(ContactPoints));
                        }
                        else if (Settings.ChargenKarmaToNuyenExpression.Contains("{INTUnaug}"))
                            OnPropertyChanged(nameof(TotalStartingNuyen));
                        if (Settings.KnowledgePointsExpression.Contains("{INTUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }
                    if (Settings.BoundSpiritExpression.Contains("{INTUnaug}"))
                        _intBoundSpiritLimit = int.MinValue;
                    if (Settings.RegisteredSpriteExpression.Contains("{INTUnaug}"))
                        _intRegisteredSpriteLimit = int.MinValue;
                    break;
                }
            }
        }

        public void RefreshLOGDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(10)
                    {
                        nameof(LimitMental),
                        nameof(Memory),
                        nameof(PsychologicalAddictionResistFirstTime),
                        nameof(PsychologicalAddictionResistAlreadyAddicted),
                        nameof(SpellDefenseDetection),
                        nameof(SpellDefenseDecreaseLOG),
                        nameof(SpellDefenseIllusionMana),
                        nameof(SpellDefenseIllusionPhysical),
                        nameof(SpellDefenseManipulationMental)
                    };
                    if (!Created)
                    {
                        if (Settings.ContactPointsExpression.Contains("{LOG}"))
                            lstProperties.Add(nameof(ContactPoints));
                        if (Settings.ChargenKarmaToNuyenExpression.Contains("{LOG}"))
                            lstProperties.Add(nameof(TotalStartingNuyen));
                    }
                    OnMultiplePropertyChanged(lstProperties);
                    if (!Created && Settings.KnowledgePointsExpression.Contains("{LOG}"))
                        SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));

                    if (Settings.BoundSpiritExpression.Contains("{INT}"))
                        _intBoundSpiritLimit = int.MinValue;
                    if (Settings.RegisteredSpriteExpression.Contains("{INT}"))
                        _intRegisteredSpriteLimit = int.MinValue;
                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    if (!Created)
                    {
                        if (Settings.ContactPointsExpression.Contains("{LOGUnaug}"))
                        {
                            if (Settings.ChargenKarmaToNuyenExpression.Contains("{LOGUnaug}"))
                                this.OnMultiplePropertyChanged(nameof(ContactPoints), nameof(TotalStartingNuyen));
                            else
                                OnPropertyChanged(nameof(ContactPoints));
                        }
                        else if (Settings.ChargenKarmaToNuyenExpression.Contains("{LOGUnaug}"))
                            OnPropertyChanged(nameof(TotalStartingNuyen));
                        if (Settings.KnowledgePointsExpression.Contains("{LOGUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }
                    if (Settings.BoundSpiritExpression.Contains("{INTUnaug}"))
                        _intBoundSpiritLimit = int.MinValue;
                    if (Settings.RegisteredSpriteExpression.Contains("{INTUnaug}"))
                        _intRegisteredSpriteLimit = int.MinValue;
                    break;
                }
            }
        }

        public void RefreshWILDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(27)
                    {
                        nameof(LimitSocial),
                        nameof(LimitMental),
                        nameof(Composure),
                        nameof(Memory),
                        nameof(JudgeIntentionsResist),
                        nameof(FatigueResist),
                        nameof(SonicResist),
                        nameof(RadiationResist),
                        nameof(PhysiologicalAddictionResistFirstTime),
                        nameof(PhysiologicalAddictionResistAlreadyAddicted),
                        nameof(PsychologicalAddictionResistFirstTime),
                        nameof(PsychologicalAddictionResistAlreadyAddicted),
                        nameof(StunCMNaturalRecovery),
                        nameof(StunCM),
                        nameof(SpellDefenseDirectSoakMana),
                        nameof(SpellDefenseDetection),
                        nameof(SpellDefenseDecreaseBOD),
                        nameof(SpellDefenseDecreaseAGI),
                        nameof(SpellDefenseDecreaseREA),
                        nameof(SpellDefenseDecreaseSTR),
                        nameof(SpellDefenseDecreaseCHA),
                        nameof(SpellDefenseDecreaseINT),
                        nameof(SpellDefenseDecreaseLOG),
                        nameof(SpellDefenseDecreaseWIL),
                        nameof(SpellDefenseIllusionMana),
                        nameof(SpellDefenseManipulationMental)
                    };
                    if (!Created)
                    {
                        if (Settings.ContactPointsExpression.Contains("{WIL}"))
                            lstProperties.Add(nameof(ContactPoints));
                        if (Settings.ChargenKarmaToNuyenExpression.Contains("{WIL}"))
                            lstProperties.Add(nameof(TotalStartingNuyen));
                    }
                    OnMultiplePropertyChanged(lstProperties);
                    if (!Created && Settings.KnowledgePointsExpression.Contains("{WIL}"))
                        SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));

                    if (Settings.BoundSpiritExpression.Contains("{WIL}"))
                        _intBoundSpiritLimit = int.MinValue;
                    if (Settings.RegisteredSpriteExpression.Contains("{WIL}"))
                        _intRegisteredSpriteLimit = int.MinValue;
                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    if (!Created)
                    {
                        if (Settings.ContactPointsExpression.Contains("{WILUnaug}"))
                        {
                            if (Settings.ChargenKarmaToNuyenExpression.Contains("{WILUnaug}"))
                                this.OnMultiplePropertyChanged(nameof(ContactPoints), nameof(TotalStartingNuyen));
                            else
                                OnPropertyChanged(nameof(ContactPoints));
                        }
                        else if (Settings.ChargenKarmaToNuyenExpression.Contains("{WILUnaug}"))
                            OnPropertyChanged(nameof(TotalStartingNuyen));
                        if (Settings.KnowledgePointsExpression.Contains("{WILUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }
                    if (Settings.BoundSpiritExpression.Contains("{WILUnaug}"))
                        _intBoundSpiritLimit = int.MinValue;
                    if (Settings.RegisteredSpriteExpression.Contains("{WILUnaug}"))
                        _intRegisteredSpriteLimit = int.MinValue;
                    break;
                }
            }
        }

        public void RefreshEDGDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(3);
                    if (EdgeUsed > EDG.TotalValue)
                        EdgeUsed = EDG.TotalValue;
                    else
                        lstProperties.Add(nameof(EdgeRemaining));
                    if (!Created)
                    {
                        if (Settings.ContactPointsExpression.Contains("{EDG}"))
                            lstProperties.Add(nameof(ContactPoints));
                        if (Settings.ChargenKarmaToNuyenExpression.Contains("{EDG}"))
                            lstProperties.Add(nameof(TotalStartingNuyen));
                    }
                    OnMultiplePropertyChanged(lstProperties);
                    if (!Created && Settings.KnowledgePointsExpression.Contains("{EDG}"))
                        SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));

                    if (Settings.BoundSpiritExpression.Contains("{EDG}"))
                        _intBoundSpiritLimit = int.MinValue;
                    if (Settings.RegisteredSpriteExpression.Contains("{EDG}"))
                        _intRegisteredSpriteLimit = int.MinValue;
                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    if (!Created)
                    {
                        if (Settings.ContactPointsExpression.Contains("{EDGUnaug}"))
                        {
                            if (Settings.ChargenKarmaToNuyenExpression.Contains("{EDGUnaug}"))
                                this.OnMultiplePropertyChanged(nameof(ContactPoints), nameof(TotalStartingNuyen));
                            else
                                OnPropertyChanged(nameof(ContactPoints));
                        }
                        else if (Settings.ChargenKarmaToNuyenExpression.Contains("{EDGUnaug}"))
                            OnPropertyChanged(nameof(TotalStartingNuyen));
                        if (Settings.KnowledgePointsExpression.Contains("{EDGUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }
                    if (Settings.BoundSpiritExpression.Contains("{EDGUnaug}"))
                        _intBoundSpiritLimit = int.MinValue;
                    if (Settings.RegisteredSpriteExpression.Contains("{EDGUnaug}"))
                        _intRegisteredSpriteLimit = int.MinValue;
                    break;
                }
            }
        }

        public void RefreshMAGDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    if(!IsLoading && MysticAdeptPowerPoints > 0)
                    {
                        int intMAGTotalValue = MAG.TotalValue;
                        if(MysticAdeptPowerPoints > intMAGTotalValue)
                            MysticAdeptPowerPoints = intMAGTotalValue;
                    }

                    List<string> lstProperties = new List<string>(5);
                    if(Settings.SpiritForceBasedOnTotalMAG)
                        lstProperties.Add(nameof(MaxSpiritForce));
                    if(MysAdeptAllowPPCareer)
                        lstProperties.Add(nameof(CanAffordCareerPP));
                    if(!UseMysticAdeptPPs && MAG == MAGAdept)
                        lstProperties.Add(nameof(PowerPointsTotal));
                    if (AnyPowerAdeptWayDiscountEnabled)
                        lstProperties.Add(nameof(AllowAdeptWayPowerDiscount));
                    if (!Created)
                    {
                        if (Settings.ContactPointsExpression.Contains("{MAG}"))
                            lstProperties.Add(nameof(ContactPoints));
                        if (Settings.ChargenKarmaToNuyenExpression.Contains("{MAG}"))
                            lstProperties.Add(nameof(TotalStartingNuyen));
                    }
                    OnMultiplePropertyChanged(lstProperties);
                    if (!Created && Settings.KnowledgePointsExpression.Contains("{MAG}"))
                        SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));

                    if (Settings.BoundSpiritExpression.Contains("{MAG}"))
                        _intBoundSpiritLimit = int.MinValue;
                    if (Settings.RegisteredSpriteExpression.Contains("{MAG}"))
                        _intRegisteredSpriteLimit = int.MinValue;
                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    List<string> lstProperties = new List<string>(2);
                    if (!Settings.SpiritForceBasedOnTotalMAG)
                        lstProperties.Add(nameof(MaxSpiritForce));
                    if (!Created)
                    {
                        if (Settings.ContactPointsExpression.Contains("{MAGUnaug}"))
                            lstProperties.Add(nameof(ContactPoints));
                        if (Settings.ChargenKarmaToNuyenExpression.Contains("{MAGUnaug}"))
                            lstProperties.Add(nameof(TotalStartingNuyen));
                    }
                    OnMultiplePropertyChanged(lstProperties);
                    if (!Created && Settings.KnowledgePointsExpression.Contains("{MAGUnaug}"))
                        SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));

                    if (Settings.BoundSpiritExpression.Contains("{MAGUnaug}"))
                        _intBoundSpiritLimit = int.MinValue;
                    if (Settings.RegisteredSpriteExpression.Contains("{MAGUnaug}"))
                        _intRegisteredSpriteLimit = int.MinValue;
                    break;
                }
            }
        }

        public void RefreshMAGAdeptDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            if(MAG == MAGAdept)
                return;

            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(2);
                    if (!UseMysticAdeptPPs)
                        lstProperties.Add(nameof(MaxSpiritForce));
                    if (!Created)
                    {
                        if (Settings.ContactPointsExpression.Contains("{MAGAdept}"))
                            lstProperties.Add(nameof(ContactPoints));
                        if (Settings.ChargenKarmaToNuyenExpression.Contains("{MAGAdept}"))
                            lstProperties.Add(nameof(TotalStartingNuyen));
                    }
                    OnMultiplePropertyChanged(lstProperties);
                    if (!Created && Settings.KnowledgePointsExpression.Contains("{MAGAdept}"))
                        SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));

                    if (Settings.BoundSpiritExpression.Contains("{MAGAdept}"))
                        _intBoundSpiritLimit = int.MinValue;
                    if (Settings.RegisteredSpriteExpression.Contains("{MAGAdept}"))
                        _intRegisteredSpriteLimit = int.MinValue;
                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    if (!Created)
                    {
                        if (Settings.ContactPointsExpression.Contains("{MAGAdeptUnaug}"))
                        {
                            if (Settings.ChargenKarmaToNuyenExpression.Contains("{MAGAdeptUnaug}"))
                                this.OnMultiplePropertyChanged(nameof(ContactPoints), nameof(TotalStartingNuyen));
                            else
                                OnPropertyChanged(nameof(ContactPoints));
                        }
                        else if (Settings.ChargenKarmaToNuyenExpression.Contains("{MAGAdeptUnaug}"))
                            OnPropertyChanged(nameof(TotalStartingNuyen));

                        if (Settings.KnowledgePointsExpression.Contains("{MAGAdeptUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    if (Settings.BoundSpiritExpression.Contains("{MAGAdeptUnaug}"))
                        _intBoundSpiritLimit = int.MinValue;
                    if (Settings.RegisteredSpriteExpression.Contains("{MAGAdeptUnaug}"))
                        _intRegisteredSpriteLimit = int.MinValue;
                    break;
                }
            }
        }

        public void RefreshRESDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(2)
                    {
                        nameof(MaxSpriteLevel)
                    };
                    if (!Created)
                    {
                        if (Settings.ContactPointsExpression.Contains("{RES}"))
                            lstProperties.Add(nameof(ContactPoints));
                        if (Settings.ChargenKarmaToNuyenExpression.Contains("{RES}"))
                            lstProperties.Add(nameof(TotalStartingNuyen));
                    }
                    OnMultiplePropertyChanged(lstProperties);
                    if (!Created && Settings.KnowledgePointsExpression.Contains("{RES}"))
                        SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    if (Settings.BoundSpiritExpression.Contains("{RES}"))
                        _intBoundSpiritLimit = int.MinValue;
                    if (Settings.RegisteredSpriteExpression.Contains("{RES}"))
                        _intRegisteredSpriteLimit = int.MinValue;
                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    if (!Created)
                    {
                        if (Settings.ContactPointsExpression.Contains("{RESUnaug}"))
                        {
                            if (Settings.ChargenKarmaToNuyenExpression.Contains("{RESUnaug}"))
                                this.OnMultiplePropertyChanged(nameof(ContactPoints), nameof(TotalStartingNuyen));
                            else
                                OnPropertyChanged(nameof(ContactPoints));
                        }
                        else if (Settings.ChargenKarmaToNuyenExpression.Contains("{RESUnaug}"))
                            OnPropertyChanged(nameof(TotalStartingNuyen));
                        if (Settings.KnowledgePointsExpression.Contains("{RESUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    if (Settings.BoundSpiritExpression.Contains("{RESUnaug}"))
                        _intBoundSpiritLimit = int.MinValue;
                    if (Settings.RegisteredSpriteExpression.Contains("{RESUnaug}"))
                        _intRegisteredSpriteLimit = int.MinValue;
                    break;
                }
            }
        }

        public void RefreshDEPDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    if (IsAI)
                        EDG.OnPropertyChanged(nameof(CharacterAttrib.MetatypeMaximum));
                    if (!Created)
                    {
                        if (Settings.ContactPointsExpression.Contains("{DEP}"))
                        {
                            if (Settings.ChargenKarmaToNuyenExpression.Contains("{DEP}"))
                                this.OnMultiplePropertyChanged(nameof(ContactPoints), nameof(TotalStartingNuyen));
                            else
                                OnPropertyChanged(nameof(ContactPoints));
                        }
                        else if (Settings.ChargenKarmaToNuyenExpression.Contains("{DEP}"))
                            OnPropertyChanged(nameof(TotalStartingNuyen));
                        if (Settings.KnowledgePointsExpression.Contains("{DEP}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    if (Settings.BoundSpiritExpression.Contains("{DEP}"))
                        _intBoundSpiritLimit = int.MinValue;
                    if (Settings.RegisteredSpriteExpression.Contains("{DEP}"))
                        _intRegisteredSpriteLimit = int.MinValue;
                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    if (!Created)
                    {
                        if (Settings.ContactPointsExpression.Contains("{DEPUnaug}"))
                        {
                            if (Settings.ChargenKarmaToNuyenExpression.Contains("{DEPUnaug}"))
                                this.OnMultiplePropertyChanged(nameof(ContactPoints), nameof(TotalStartingNuyen));
                            else
                                OnPropertyChanged(nameof(ContactPoints));
                        }
                        else if (Settings.ChargenKarmaToNuyenExpression.Contains("{DEPUnaug}"))
                            OnPropertyChanged(nameof(TotalStartingNuyen));
                        if (Settings.KnowledgePointsExpression.Contains("{DEPUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    if (Settings.BoundSpiritExpression.Contains("{DEPUnaug}"))
                        _intBoundSpiritLimit = int.MinValue;
                    if (Settings.RegisteredSpriteExpression.Contains("{DEPUnaug}"))
                        _intRegisteredSpriteLimit = int.MinValue;
                    break;
                }
            }
        }

        public void RefreshESSDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                // Only ESS.MetatypeMaximum is used for the Essence method/property when it comes to attributes
                case nameof(CharacterAttrib.MetatypeMaximum):
                    this.OnMultiplePropertyChanged(nameof(PrototypeTranshumanEssenceUsed), nameof(BiowareEssence), nameof(CyberwareEssence), nameof(EssenceHole));
                    break;
                case nameof(CharacterAttrib.TotalValue):
                {
                    if (!Created)
                    {
                        if (Settings.ContactPointsExpression.Contains("{ESS}"))
                        {
                            if (Settings.ChargenKarmaToNuyenExpression.Contains("{ESS}"))
                                this.OnMultiplePropertyChanged(nameof(ContactPoints), nameof(TotalStartingNuyen));
                            else
                                OnPropertyChanged(nameof(ContactPoints));
                        }
                        else if (Settings.ChargenKarmaToNuyenExpression.Contains("{ESS}"))
                            OnPropertyChanged(nameof(TotalStartingNuyen));
                        if (Settings.KnowledgePointsExpression.Contains("{ESS}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    if (Settings.BoundSpiritExpression.Contains("{ESS}"))
                        _intBoundSpiritLimit = int.MinValue;
                    if (Settings.RegisteredSpriteExpression.Contains("{ESS}"))
                        _intRegisteredSpriteLimit = int.MinValue;
                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    if (!Created)
                    {
                        if (Settings.ContactPointsExpression.Contains("{ESSUnaug}"))
                        {
                            if (Settings.ChargenKarmaToNuyenExpression.Contains("{ESSUnaug}"))
                                this.OnMultiplePropertyChanged(nameof(ContactPoints), nameof(TotalStartingNuyen));
                            else
                                OnPropertyChanged(nameof(ContactPoints));
                        }
                        else if (Settings.ChargenKarmaToNuyenExpression.Contains("{ESSUnaug}"))
                            OnPropertyChanged(nameof(TotalStartingNuyen));
                        if (Settings.KnowledgePointsExpression.Contains("{ESSUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    if (Settings.BoundSpiritExpression.Contains("{ESSUnaug}"))
                        _intBoundSpiritLimit = int.MinValue;
                    if (Settings.RegisteredSpriteExpression.Contains("{ESSUnaug}"))
                        _intRegisteredSpriteLimit = int.MinValue;
                    break;
                }
            }
        }

        public void RefreshEncumbrance()
        {
            // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
            if(IsLoading)
                return;
            // Remove any Improvements from Armor Encumbrance.
            ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.ArmorEncumbrance);
            if(!Settings.NoArmorEncumbrance)
            {
                // Create the Armor Encumbrance Improvements.
                int intEncumbrance = ArmorEncumbrance;
                if(intEncumbrance != 0)
                {
                    ImprovementManager.CreateImprovement(this, "AGI", Improvement.ImprovementSource.ArmorEncumbrance,
                        string.Empty, Improvement.ImprovementType.Attribute, "precedence-1", 0, 1, 0, 0,
                        intEncumbrance);
                    ImprovementManager.CreateImprovement(this, "REA", Improvement.ImprovementSource.ArmorEncumbrance,
                        string.Empty, Improvement.ImprovementType.Attribute, "precedence-1", 0, 1, 0, 0,
                        intEncumbrance);
                    ImprovementManager.Commit(this);
                }
            }
        }

        public void RefreshWoundPenalties()
        {
            // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
            if(IsLoading)
                return;
            int intPhysicalCMFilled = Math.Min(PhysicalCMFilled, PhysicalCM);
            int intStunCMFilled = Math.Min(StunCMFilled, StunCM);
            int intCMThreshold = CMThreshold;
            int intStunCMPenalty = ImprovementManager
                                   .GetCachedImprovementListForValueOf(
                                       this, Improvement.ImprovementType.IgnoreCMPenaltyStun)
                                   .Count > 0
                ? 0
                : Math.Min(0, StunCMThresholdOffset - intStunCMFilled) / intCMThreshold;
            int intPhysicalCMPenalty = ImprovementManager
                                       .GetCachedImprovementListForValueOf(
                                           this, Improvement.ImprovementType.IgnoreCMPenaltyPhysical)
                                       .Count > 0
                ? 0
                : Math.Min(0, PhysicalCMThresholdOffset - intPhysicalCMFilled) / intCMThreshold;

            _intWoundModifier = intPhysicalCMPenalty + intStunCMPenalty;
        }

        private int _intWoundModifier;

        /// <summary>
        /// Recalculates the Dicepoolmodifier for sustaining spells or complex forms
        /// </summary>
        public bool RefreshSustainingPenalties()
        {
            if (IsLoading) // If we are in the middle of loading, just queue a single refresh to happen at the end of the process
            {
                if (!PostLoadMethods.Contains(RefreshSustainingPenalties))
                    PostLoadMethods.Enqueue(RefreshSustainingPenalties);
                return true;
            }

            int intDicePenaltySustainedSpell = Settings.DicePenaltySustaining;

            //The sustaining of Critterpowers doesn't cause any penalties that's why they aren't counted there is no way to change them to self sustained anyway, but just to be sure
            List<SustainedObject> lstSustainedSpells = SustainedCollection.Where(x => x.HasSustainingPenalty).ToList();
            // Handling of bonuses that let characters sustain some objects for free requires special handling in order to best match the bonus ensemble to the sustained spells ensemble
            if (ImprovementManager.ValueOf(this, Improvement.ImprovementType.PenaltyFreeSustain, out List<Improvement> lstUsedImprovements) != 0)
            {
                // Set up a dictionary where the key is the maximum force/level of the bonus and the value is the number of objects that can be sustained
                SortedDictionary<decimal, int> dicPenaltyFreeSustains = new SortedDictionary<decimal, int>();
                foreach (Improvement objImprovement in lstUsedImprovements)
                {
                    decimal decForce = objImprovement.Value;
                    if (dicPenaltyFreeSustains.TryGetValue(decForce, out int intExistingRating))
                        dicPenaltyFreeSustains[decForce] = intExistingRating + objImprovement.Rating;
                    else
                        dicPenaltyFreeSustains.Add(decForce, objImprovement.Rating);
                }
                // List of supported objects, sorted in descending order of Force
                List<SustainedObject> lstSupportedObjects = new List<SustainedObject>(lstSustainedSpells.Count);
                // Go from lowest maximum force/level bonus to highest (that's why we use SortedDictionary) and match each one to the highest possible objects for it.
                foreach (KeyValuePair<decimal, int> kvpLoop in dicPenaltyFreeSustains)
                {
                    int intSupportedForce = kvpLoop.Key.StandardRound();
                    int intNumSupportsPossible = kvpLoop.Value;
                    lstSupportedObjects.Clear();
                    foreach (SustainedObject objLoopObject in lstSustainedSpells)
                    {
                        int intLoopForce = objLoopObject.Force;
                        if (intLoopForce > intSupportedForce)
                            continue;
                        if (intLoopForce == intSupportedForce)
                        {
                            if (lstSupportedObjects.Count + 1 > intNumSupportsPossible)
                                // Remove the last element because we know it's the lowest
                                lstSupportedObjects.RemoveAt(lstSupportedObjects.Count - 1);
                            // Safe to insert object at the top because we cannot get objects with more Force in the list
                            lstSupportedObjects.Insert(0, objLoopObject);
                            if (lstSupportedObjects.Count == intNumSupportsPossible && lstSupportedObjects[lstSupportedObjects.Count - 1].Force == intSupportedForce)
                                // The entire list at this point is saturated with objects with the maximum allowable force, so quit out early
                                break;
                        }
                        else
                        {
                            if (lstSupportedObjects.Count + 1 > intNumSupportsPossible)
                            {
                                // Check against the last element because we know it'll be the lowest, only replace item if loop has a higher force than this one
                                if (intLoopForce <= lstSupportedObjects[lstSupportedObjects.Count - 1].Force)
                                    continue;
                                lstSupportedObjects.RemoveAt(lstSupportedObjects.Count - 1);
                            }
                            lstSupportedObjects.AddWithSort(objLoopObject, (x, y) => y.Force.CompareTo(x.Force));
                        }
                    }
                    // Remove all sustained objects that supported as penalty-free
                    lstSustainedSpells.RemoveAll(x => lstSupportedObjects.Contains(x));
                    // If we have no more sustained objects in need of penalty removal, exit out early
                    if (lstSustainedSpells.Count == 0)
                        break;
                }
            }
            int intModifierPerSpell = PsycheActive ? -1 : -intDicePenaltySustainedSpell;

            SustainingPenalty = lstSustainedSpells.Count * intModifierPerSpell;

            return true;
        }

        private int _intSustainingPenalty;
        /// <summary>
        /// Dicepool modifier the character has from wounds. Should be a non-positive number because wound modifiers are always penalties if they are not 0.
        /// </summary>
        public int WoundModifier => _intWoundModifier;

        /// <summary>
        /// Dicepool modifie the character has from sustaining spells. Should be negative
        /// </summary>
        public int SustainingPenalty
        {
            get => _intSustainingPenalty;
            private set //Private set instead of read only, to allow inclusion of OnPropertyChanged
            {
                if (value != _intSustainingPenalty)
                {
                    _intSustainingPenalty = value;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Whether to immediately mark a character file as dirty when it is loaded in. Used if we're changing a character's settings on load.
        /// </summary>
        public bool LoadAsDirty
        {
            get;
            private set;
        }

        public Version LastSavedVersion => _verSavedVersion;

        /// <summary>
        /// Is the character a mystic adept (MagicianEnabled && AdeptEnabled)? Used for databinding properties.
        /// </summary>
        public bool IsMysticAdept => AdeptEnabled && MagicianEnabled;

        /// <summary>
        /// Whether this character is using special Mystic Adept PP rules (true) or calculate PPs from Mystic Adept's Adept MAG (false)
        /// </summary>
        public bool UseMysticAdeptPPs => IsMysticAdept && !Settings.MysAdeptSecondMAGAttribute;

        /// <summary>
        /// Whether this character is a Mystic Adept uses PPs and can purchase PPs in career mode
        /// </summary>
        public bool MysAdeptAllowPPCareer => UseMysticAdeptPPs && Settings.MysAdeptAllowPpCareer;

        /// <summary>
        /// Could this character buy Power Points in career mode if the optional/house rule is enabled
        /// </summary>
        public bool CanAffordCareerPP => MysAdeptAllowPPCareer
                                         && Karma >= Settings.KarmaMysticAdeptPowerPoint
                                         && MAG.TotalValue > MysticAdeptPowerPoints;
        /// <summary>
        /// Whether the character is allowed to gain free spells that are limited to the Touch range.
        /// </summary>
        public Tuple<bool, bool> AllowFreeSpells
        {
            get
            {
                //Free Spells (typically from Dedicated Spellslinger or custom Improvements) are only handled manually
                //in Career Mode. Create mode manages itself.
                int intFreeGenericSpells = ImprovementManager.ValueOf(this, Improvement.ImprovementType.FreeSpells).StandardRound();
                int intFreeTouchOnlySpells = 0;
                foreach (Improvement imp in ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.FreeSpellsATT))
                {
                    int intAttValue = GetAttribute(imp.ImprovedName).TotalValue;
                    if (imp.UniqueName.Contains("half"))
                        intAttValue = (intAttValue + 1) / 2;
                    if (imp.UniqueName.Contains("touchonly"))
                        intFreeTouchOnlySpells += intAttValue;
                    else
                        intFreeGenericSpells += intAttValue;
                }
                foreach (Improvement imp in ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.FreeSpellsSkill))
                {
                    Skill skill = SkillsSection.GetActiveSkill(imp.ImprovedName);
                    int intSkillValue = SkillsSection.GetActiveSkill(imp.ImprovedName).TotalBaseRating;
                    if (imp.UniqueName.Contains("half"))
                        intSkillValue = (intSkillValue + 1) / 2;
                    if (imp.UniqueName.Contains("touchonly"))
                        intFreeTouchOnlySpells += intSkillValue;
                    else
                        intFreeGenericSpells += intSkillValue;
                    //TODO: I don't like this being hardcoded, even though I know full well CGL are never going to reuse this
                    intFreeGenericSpells += skill.Specializations.Count(spec => Spells.Any(spell => spell.Category == spec.Name && !spell.FreeBonus));
                }

                int intTotalFreeNonTouchSpellsCount = Spells.Count(spell =>
                    spell.FreeBonus && (spell.Range != "T" && spell.Range != "T (A)"));
                int intTotalFreeTouchOnlySpellsCount = Spells.Count(spell =>
                    spell.FreeBonus && (spell.Range == "T" || spell.Range == "T (A)"));
                return new Tuple<bool, bool>(intFreeTouchOnlySpells > intTotalFreeTouchOnlySpellsCount,
                    intFreeGenericSpells > intTotalFreeNonTouchSpellsCount +
                    Math.Max(intTotalFreeTouchOnlySpellsCount - intFreeTouchOnlySpells, 0));
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;

        #region Static

        //A tree of dependencies. Once some of the properties are changed,
        //anything they depend on, also needs to raise OnChanged
        //This tree keeps track of dependencies
        private static readonly PropertyDependencyGraph<Character> s_CharacterDependencyGraph =
            new PropertyDependencyGraph<Character>(
                    new DependencyGraphNode<string, Character>(nameof(CharacterName),
                        new DependencyGraphNode<string, Character>(nameof(Alias)),
                        new DependencyGraphNode<string, Character>(nameof(Name), x => string.IsNullOrWhiteSpace(x.Alias))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayPowerPointsRemaining),
                        new DependencyGraphNode<string, Character>(nameof(PowerPointsTotal),
                            new DependencyGraphNode<string, Character>(nameof(UseMysticAdeptPPs),
                                new DependencyGraphNode<string, Character>(nameof(IsMysticAdept),
                                    new DependencyGraphNode<string, Character>(nameof(AdeptEnabled)),
                                    new DependencyGraphNode<string, Character>(nameof(MagicianEnabled))
                                )
                            ),
                            new DependencyGraphNode<string, Character>(nameof(MysticAdeptPowerPoints), x => x.UseMysticAdeptPPs)
                        ),
                        new DependencyGraphNode<string, Character>(nameof(PowerPointsUsed))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(CanAffordCareerPP),
                        new DependencyGraphNode<string, Character>(nameof(MysAdeptAllowPPCareer),
                            new DependencyGraphNode<string, Character>(nameof(UseMysticAdeptPPs))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(MysticAdeptPowerPoints)),
                        new DependencyGraphNode<string, Character>(nameof(Karma))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(AddInitiationsAllowed),
                        new DependencyGraphNode<string, Character>(nameof(IgnoreRules)),
                        new DependencyGraphNode<string, Character>(nameof(Created))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(InitiationEnabled),
                        new DependencyGraphNode<string, Character>(nameof(MAGEnabled)),
                        new DependencyGraphNode<string, Character>(nameof(RESEnabled)),
                        new DependencyGraphNode<string, Character>(nameof(InitiationForceDisabled))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(InitiativeToolTip),
                        new DependencyGraphNode<string, Character>(nameof(Initiative),
                            new DependencyGraphNode<string, Character>(nameof(InitiativeDice)),
                            new DependencyGraphNode<string, Character>(nameof(InitiativeValue),
                                new DependencyGraphNode<string, Character>(nameof(WoundModifier))
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(AstralInitiativeToolTip),
                        new DependencyGraphNode<string, Character>(nameof(AstralInitiative),
                            new DependencyGraphNode<string, Character>(nameof(AstralInitiativeDice)),
                            new DependencyGraphNode<string, Character>(nameof(AstralInitiativeValue),
                                new DependencyGraphNode<string, Character>(nameof(WoundModifier))
                            )
                        ),
                        new DependencyGraphNode<string, Character>(nameof(MAGEnabled))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeToolTip),
                        new DependencyGraphNode<string, Character>(nameof(MatrixInitiative),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeDice),
                                new DependencyGraphNode<string, Character>(nameof(IsAI)),
                                new DependencyGraphNode<string, Character>(nameof(InitiativeDice), x => !x.IsAI)
                            ),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeValue),
                                new DependencyGraphNode<string, Character>(nameof(IsAI)),
                                new DependencyGraphNode<string, Character>(nameof(HomeNode), x => x.IsAI),
                                new DependencyGraphNode<string, Character>(nameof(WoundModifier), x => x.IsAI),
                                new DependencyGraphNode<string, Character>(nameof(InitiativeValue), x => !x.IsAI)
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeColdToolTip),
                        new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeCold),
                            new DependencyGraphNode<string, Character>(nameof(IsAI)),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiative), x => x.IsAI),
                            new DependencyGraphNode<string, Character>(nameof(ActiveCommlink), x => !x.IsAI),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeColdDice),
                                new DependencyGraphNode<string, Character>(nameof(IsAI)),
                                new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeDice), x => x.IsAI)
                            ),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeColdValue),
                                new DependencyGraphNode<string, Character>(nameof(ActiveCommlink), x => !x.IsAI),
                                new DependencyGraphNode<string, Character>(nameof(IsAI)),
                                new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeValue), x => x.IsAI),
                                new DependencyGraphNode<string, Character>(nameof(WoundModifier), x => !x.IsAI)
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeHotToolTip),
                        new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeHot),
                            new DependencyGraphNode<string, Character>(nameof(IsAI)),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiative), x => x.IsAI),
                            new DependencyGraphNode<string, Character>(nameof(ActiveCommlink), x => !x.IsAI),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeHotDice),
                                new DependencyGraphNode<string, Character>(nameof(IsAI)),
                                new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeDice), x => x.IsAI)
                            ),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeHotValue),
                                new DependencyGraphNode<string, Character>(nameof(ActiveCommlink), x => !x.IsAI),
                                new DependencyGraphNode<string, Character>(nameof(IsAI)),
                                new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeValue), x => x.IsAI),
                                new DependencyGraphNode<string, Character>(nameof(WoundModifier), x => !x.IsAI)
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(IsSprite),
                        new DependencyGraphNode<string, Character>(nameof(IsFreeSprite),
                            new DependencyGraphNode<string, Character>(nameof(MetatypeCategory))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayMetatypeBP),
                        new DependencyGraphNode<string, Character>(nameof(MetatypeBP))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(PhysicalCMLabelText),
                        new DependencyGraphNode<string, Character>(nameof(IsAI)),
                        new DependencyGraphNode<string, Character>(nameof(HomeNode))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(PhysicalCMToolTip),
                        new DependencyGraphNode<string, Character>(nameof(PhysicalCM))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(StunCMToolTip),
                        new DependencyGraphNode<string, Character>(nameof(StunCM))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(StunCMVisible),
                        new DependencyGraphNode<string, Character>(nameof(IsAI)),
                        new DependencyGraphNode<string, Character>(nameof(HomeNode))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(StunCMLabelText),
                        new DependencyGraphNode<string, Character>(nameof(IsAI)),
                        new DependencyGraphNode<string, Character>(nameof(HomeNode))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SustainingPenalty),
                        new DependencyGraphNode<string, Character>(nameof(PsycheActive))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(WoundModifier),
                        new DependencyGraphNode<string, Character>(nameof(PhysicalCMFilled),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(PhysicalCM),
                            new DependencyGraphNode<string, Character>(nameof(IsAI)),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(StunCMFilled),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(StunCM),
                            new DependencyGraphNode<string, Character>(nameof(IsAI)),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(CMThreshold)),
                        new DependencyGraphNode<string, Character>(nameof(PhysicalCMThresholdOffset),
                            new DependencyGraphNode<string, Character>(nameof(StunCMFilled)),
                            new DependencyGraphNode<string, Character>(nameof(CMThreshold)),
                            new DependencyGraphNode<string, Character>(nameof(IsAI))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(StunCMThresholdOffset),
                            new DependencyGraphNode<string, Character>(nameof(PhysicalCMFilled)),
                            new DependencyGraphNode<string, Character>(nameof(CMThreshold)),
                            new DependencyGraphNode<string, Character>(nameof(IsAI))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(CMThresholdOffsets),
                        new DependencyGraphNode<string, Character>(nameof(PhysicalCMThresholdOffset)),
                        new DependencyGraphNode<string, Character>(nameof(StunCMThresholdOffset))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(EffectiveBuildMethodUsesPriorityTables),
                        new DependencyGraphNode<string, Character>(nameof(EffectiveBuildMethod),
                            new DependencyGraphNode<string, Character>(nameof(IsCritter))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(EnableAutomaticStoryButton),
                        new DependencyGraphNode<string, Character>(nameof(EffectiveBuildMethodIsLifeModule),
                            new DependencyGraphNode<string, Character>(nameof(EffectiveBuildMethod))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DamageResistancePoolToolTip),
                        new DependencyGraphNode<string, Character>(nameof(DamageResistancePool),
                            new DependencyGraphNode<string, Character>(nameof(TotalArmorRating)),
                            new DependencyGraphNode<string, Character>(nameof(IsAI)),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode), x => x.IsAI)
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(IsAI),
                        new DependencyGraphNode<string, Character>(nameof(DEPEnabled))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseIndirectDodgeToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIndirectDodge),
                            new DependencyGraphNode<string, Character>(nameof(TotalBonusDodgeRating))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DodgeToolTip),
                        new DependencyGraphNode<string, Character>(nameof(Dodge),
                            new DependencyGraphNode<string, Character>(nameof(TotalBonusDodgeRating),
                            new DependencyGraphNode<string, Character>(nameof(WoundModifier)),
                            new DependencyGraphNode<string, Character>(nameof(SustainingPenalty))
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseIndirectDodge),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIndirectDodge))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseIndirectSoakToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIndirectSoak),
                            new DependencyGraphNode<string, Character>(nameof(TotalArmorRating)),
                            new DependencyGraphNode<string, Character>(nameof(IsAI)),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode), x => x.IsAI),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseIndirectSoak),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIndirectSoak))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDirectSoakManaToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDirectSoakMana),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDirectSoakMana),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDirectSoakMana))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDirectSoakPhysicalToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDirectSoakPhysical),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDirectSoakPhysical),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDirectSoakPhysical))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDetectionToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDetection),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDetection),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDetection))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseBODToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseBOD),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseBOD),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseBOD))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseAGIToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseAGI),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseAGI),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseAGI))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseREAToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseREA),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseREA),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseREA))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseSTRToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseSTR),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseSTR),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseSTR))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseCHAToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseCHA),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseCHA),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseCHA))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseINTToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseINT),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseINT),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseINT))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseLOGToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseLOG),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseLOG),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseLOG))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseWILToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseWIL),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseWIL),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseWIL))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseIllusionManaToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIllusionMana),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseIllusionMana),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIllusionMana))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseIllusionPhysicalToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIllusionPhysical),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseIllusionPhysical),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIllusionPhysical))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseManipulationMentalToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseManipulationMental),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseManipulationMental),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseManipulationMental))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseManipulationPhysicalToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseManipulationPhysical),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance)),
                            new DependencyGraphNode<string, Character>(nameof(IsAI)),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode), x => x.IsAI)
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseManipulationPhysical),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseManipulationPhysical))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(TotalArmorRatingToolTip),
                        new DependencyGraphNode<string, Character>(nameof(TotalArmorRating),
                            new DependencyGraphNode<string, Character>(nameof(GetArmorRating),
                                new DependencyGraphNode<string, Character>(nameof(GetArmorRatingWithImprovement))
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(TotalFireArmorRating),
                        new DependencyGraphNode<string, Character>(nameof(GetArmorRating))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(TotalColdArmorRating),
                        new DependencyGraphNode<string, Character>(nameof(GetArmorRating))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(TotalElectricityArmorRating),
                        new DependencyGraphNode<string, Character>(nameof(GetArmorRating))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(TotalAcidArmorRating),
                        new DependencyGraphNode<string, Character>(nameof(GetArmorRating))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(TotalFallingArmorRating),
                        new DependencyGraphNode<string, Character>(nameof(GetArmorRating))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayEssence),
                        new DependencyGraphNode<string, Character>(nameof(Essence),
                            new DependencyGraphNode<string, Character>(nameof(CyberwareEssence)),
                            new DependencyGraphNode<string, Character>(nameof(BiowareEssence)),
                            new DependencyGraphNode<string, Character>(nameof(PrototypeTranshumanEssenceUsed)),
                            new DependencyGraphNode<string, Character>(nameof(EssenceHole))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(ComposureToolTip),
                        new DependencyGraphNode<string, Character>(nameof(Composure),
                            new DependencyGraphNode<string, Character>(nameof(SustainingPenalty)),
                            new DependencyGraphNode<string, Character>(nameof(WoundModifier))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SurpriseToolTip),
                        new DependencyGraphNode<string, Character>(nameof(Surprise),
                            new DependencyGraphNode<string, Character>(nameof(WoundModifier)),
                            new DependencyGraphNode<string, Character>(nameof(SustainingPenalty))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(JudgeIntentionsToolTip),
                        new DependencyGraphNode<string, Character>(nameof(JudgeIntentions),
                            new DependencyGraphNode<string, Character>(nameof(WoundModifier)),
                            new DependencyGraphNode<string, Character>(nameof(SustainingPenalty))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(JudgeIntentionsResistToolTip),
                        new DependencyGraphNode<string, Character>(nameof(JudgeIntentionsResist))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(LiftAndCarryToolTip),
                        new DependencyGraphNode<string, Character>(nameof(LiftAndCarry),
                            new DependencyGraphNode<string, Character>(nameof(WoundModifier)),
                            new DependencyGraphNode<string, Character>(nameof(SustainingPenalty))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(MemoryToolTip),
                        new DependencyGraphNode<string, Character>(nameof(Memory),
                            new DependencyGraphNode<string, Character>(nameof(WoundModifier)),
                            new DependencyGraphNode<string, Character>(nameof(SustainingPenalty))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayCyberwareEssence),
                        new DependencyGraphNode<string, Character>(nameof(CyberwareEssence))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayBiowareEssence),
                        new DependencyGraphNode<string, Character>(nameof(BiowareEssence))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayEssenceHole),
                        new DependencyGraphNode<string, Character>(nameof(EssenceHole))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayPrototypeTranshumanEssenceUsed),
                        new DependencyGraphNode<string, Character>(nameof(PrototypeTranshumanEssenceUsed)),
                        new DependencyGraphNode<string, Character>(nameof(PrototypeTranshuman))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(IsPrototypeTranshuman),
                        new DependencyGraphNode<string, Character>(nameof(PrototypeTranshuman))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayNuyen),
                        new DependencyGraphNode<string, Character>(nameof(Nuyen))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayStolenNuyen),
                        new DependencyGraphNode<string, Character>(nameof(StolenNuyen))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayKarma),
                        new DependencyGraphNode<string, Character>(nameof(Karma))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayTotalStartingNuyen),
                        new DependencyGraphNode<string, Character>(nameof(TotalStartingNuyen),
                            new DependencyGraphNode<string, Character>(nameof(StartingNuyen)),
                            new DependencyGraphNode<string, Character>(nameof(NuyenBP)),
                            new DependencyGraphNode<string, Character>(nameof(TotalNuyenMaximumBP),
                                new DependencyGraphNode<string, Character>(nameof(StolenNuyen)),
                                new DependencyGraphNode<string, Character>(nameof(IgnoreRules))
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayCareerNuyen),
                        new DependencyGraphNode<string, Character>(nameof(CareerNuyen))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayCareerKarma),
                        new DependencyGraphNode<string, Character>(nameof(CareerKarma))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(StreetCredTooltip),
                        new DependencyGraphNode<string, Character>(nameof(TotalStreetCred),
                            new DependencyGraphNode<string, Character>(nameof(StreetCred)),
                            new DependencyGraphNode<string, Character>(nameof(CalculatedStreetCred),
                                new DependencyGraphNode<string, Character>(nameof(CareerKarma)),
                                new DependencyGraphNode<string, Character>(nameof(BurntStreetCred))
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(CanBurnStreetCred),
                        new DependencyGraphNode<string, Character>(nameof(TotalStreetCred))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(NotorietyTooltip),
                        new DependencyGraphNode<string, Character>(nameof(TotalNotoriety),
                            new DependencyGraphNode<string, Character>(nameof(Notoriety)),
                            new DependencyGraphNode<string, Character>(nameof(CalculatedNotoriety)),
                            new DependencyGraphNode<string, Character>(nameof(BurntStreetCred))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(PublicAwarenessTooltip),
                        new DependencyGraphNode<string, Character>(nameof(TotalPublicAwareness),
                            new DependencyGraphNode<string, Character>(nameof(Erased)),
                            new DependencyGraphNode<string, Character>(nameof(CalculatedPublicAwareness),
                                new DependencyGraphNode<string, Character>(nameof(PublicAwareness)),
                                new DependencyGraphNode<string, Character>(nameof(TotalStreetCred),
                                    x => x.Settings.UseCalculatedPublicAwareness),
                                new DependencyGraphNode<string, Character>(nameof(TotalNotoriety),
                                    x => x.Settings.UseCalculatedPublicAwareness)
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(CareerDisplayStreetCred),
                        new DependencyGraphNode<string, Character>(nameof(TotalStreetCred))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(CareerDisplayNotoriety),
                        new DependencyGraphNode<string, Character>(nameof(TotalNotoriety))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(CareerDisplayPublicAwareness),
                        new DependencyGraphNode<string, Character>(nameof(TotalPublicAwareness))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(AddBiowareEnabled),
                        new DependencyGraphNode<string, Character>(nameof(CyberwareDisabled)),
                        new DependencyGraphNode<string, Character>(nameof(IsAI))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(AddCyberwareEnabled),
                        new DependencyGraphNode<string, Character>(nameof(CyberwareDisabled)),
                        new DependencyGraphNode<string, Character>(nameof(IsAI))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(HasMentorSpirit),
                        new DependencyGraphNode<string, Character>(nameof(MentorSpirits))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(CharacterGrammaticGender),
                        new DependencyGraphNode<string, Character>(nameof(Gender))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(FirstMentorSpiritDisplayName),
                        new DependencyGraphNode<string, Character>(nameof(MentorSpirits))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(FirstMentorSpiritDisplayInformation),
                        new DependencyGraphNode<string, Character>(nameof(MentorSpirits))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(LimitPhysicalToolTip),
                        new DependencyGraphNode<string, Character>(nameof(LimitPhysical),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(LimitMentalToolTip),
                        new DependencyGraphNode<string, Character>(nameof(LimitMental),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(LimitSocialToolTip),
                        new DependencyGraphNode<string, Character>(nameof(LimitSocial),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(LimitAstralToolTip),
                        new DependencyGraphNode<string, Character>(nameof(LimitAstral),
                            new DependencyGraphNode<string, Character>(nameof(LimitMental)),
                            new DependencyGraphNode<string, Character>(nameof(LimitSocial))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayMovement),
                        new DependencyGraphNode<string, Character>(nameof(GetMovement),
                            new DependencyGraphNode<string, Character>(nameof(Movement)),
                            new DependencyGraphNode<string, Character>(nameof(CalculatedMovement),
                                new DependencyGraphNode<string, Character>(nameof(WalkingRate),
                                    new DependencyGraphNode<string, Character>(nameof(CurrentWalkingRateString),
                                        new DependencyGraphNode<string, Character>(nameof(WalkString),
                                            x => x.AttributeSection.AttributeCategory ==
                                                 CharacterAttrib.AttributeCategory.Standard),
                                        new DependencyGraphNode<string, Character>(nameof(WalkAltString),
                                            x => x.AttributeSection.AttributeCategory !=
                                                 CharacterAttrib.AttributeCategory.Standard)
                                    )
                                ),
                                new DependencyGraphNode<string, Character>(nameof(RunningRate),
                                    new DependencyGraphNode<string, Character>(nameof(CurrentRunningRateString),
                                        new DependencyGraphNode<string, Character>(nameof(RunString),
                                            x => x.AttributeSection.AttributeCategory ==
                                                 CharacterAttrib.AttributeCategory.Standard),
                                        new DependencyGraphNode<string, Character>(nameof(RunAltString),
                                            x => x.AttributeSection.AttributeCategory !=
                                                 CharacterAttrib.AttributeCategory.Standard)
                                    )
                                ),
                                new DependencyGraphNode<string, Character>(nameof(SprintingRate),
                                    new DependencyGraphNode<string, Character>(nameof(CurrentSprintingRateString),
                                        new DependencyGraphNode<string, Character>(nameof(SprintString),
                                            x => x.AttributeSection.AttributeCategory ==
                                                 CharacterAttrib.AttributeCategory.Standard),
                                        new DependencyGraphNode<string, Character>(nameof(SprintAltString),
                                            x => x.AttributeSection.AttributeCategory !=
                                                 CharacterAttrib.AttributeCategory.Standard)
                                    )
                                )
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySwim),
                        new DependencyGraphNode<string, Character>(nameof(GetSwim),
                            new DependencyGraphNode<string, Character>(nameof(Movement)),
                            new DependencyGraphNode<string, Character>(nameof(CalculatedMovement))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayFly),
                        new DependencyGraphNode<string, Character>(nameof(GetFly),
                            new DependencyGraphNode<string, Character>(nameof(Movement)),
                            new DependencyGraphNode<string, Character>(nameof(CalculatedMovement))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayNegativeQualityKarma),
                        new DependencyGraphNode<string, Character>(nameof(NegativeQualityKarma),
                            new DependencyGraphNode<string, Character>(nameof(EnemyKarma)),
                            new DependencyGraphNode<string, Character>(nameof(Contacts)),
                            new DependencyGraphNode<string, Character>(nameof(Qualities))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(NegativeQualityLimitKarma),
                            new DependencyGraphNode<string, Character>(nameof(EnemyKarma)),
                            new DependencyGraphNode<string, Character>(nameof(Contacts)),
                            new DependencyGraphNode<string, Character>(nameof(Qualities))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayPositiveQualityKarma),
                        new DependencyGraphNode<string, Character>(nameof(PositiveQualityKarma),
                            new DependencyGraphNode<string, Character>(nameof(Contacts)),
                            new DependencyGraphNode<string, Character>(nameof(Qualities))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(PositiveQualityKarmaTotal),
                            new DependencyGraphNode<string, Character>(nameof(Contacts)),
                            new DependencyGraphNode<string, Character>(nameof(Qualities))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayMetagenicQualityKarma),
                        new DependencyGraphNode<string, Character>(nameof(MetagenicPositiveQualityKarma),
                        new DependencyGraphNode<string, Character>(nameof(MetagenicNegativeQualityKarma),
                            new DependencyGraphNode<string, Character>(nameof(IsChangeling)),
                            new DependencyGraphNode<string, Character>(nameof(Qualities))
                        ))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(AstralReputationTooltip),
                        new DependencyGraphNode<string, Character>(nameof(TotalAstralReputation),
                            new DependencyGraphNode<string, Character>(nameof(AstralReputation))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(WildReputationTooltip),
                        new DependencyGraphNode<string, Character>(nameof(TotalWildReputation),
                            new DependencyGraphNode<string, Character>(nameof(WildReputation))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(EdgeRemainingString),
                        new DependencyGraphNode<string, Character>(nameof(EdgeRemaining),
                            new DependencyGraphNode<string, Character>(nameof(EdgeUsed))
                        )
                    )
                );
        #endregion

        [NotifyPropertyChangedInvocator]
        public void OnPropertyChanged([CallerMemberName] string strPropertyName = null)
        {
            this.OnMultiplePropertyChanged(strPropertyName);
        }

        public void OnMultiplePropertyChanged(IReadOnlyCollection<string> lstPropertyNames)
        {
            HashSet<string> setNamesOfChangedProperties = null;
            try
            {
                foreach (string strPropertyName in lstPropertyNames)
                {
                    if (setNamesOfChangedProperties == null)
                        setNamesOfChangedProperties
                            = s_CharacterDependencyGraph.GetWithAllDependents(this, strPropertyName, true);
                    else
                    {
                        foreach (string strLoopChangedProperty in s_CharacterDependencyGraph
                                     .GetWithAllDependentsEnumerable(
                                         this, strPropertyName))
                            setNamesOfChangedProperties.Add(strLoopChangedProperty);
                    }
                }

                if (setNamesOfChangedProperties == null || setNamesOfChangedProperties.Count == 0)
                    return;

                if (setNamesOfChangedProperties.Contains(nameof(CharacterGrammaticGender)))
                {
                    _strCachedCharacterGrammaticGender = string.Empty;
                }

                if (setNamesOfChangedProperties.Contains(nameof(TotalStartingNuyen)))
                {
                    _decCachedTotalStartingNuyen = decimal.MinValue;
                }

                if (setNamesOfChangedProperties.Contains(nameof(ContactPoints)))
                {
                    _intCachedContactPoints = int.MinValue;
                }

                if (setNamesOfChangedProperties.Contains(nameof(TotalArmorRating)))
                {
                    _intCachedTotalArmorRating = int.MinValue;
                }

                if (setNamesOfChangedProperties.Contains(nameof(TotalFireArmorRating)))
                {
                    _intCachedTotalFireArmorRating = int.MinValue;
                }

                if (setNamesOfChangedProperties.Contains(nameof(TotalColdArmorRating)))
                {
                    _intCachedTotalColdArmorRating = int.MinValue;
                }

                if (setNamesOfChangedProperties.Contains(nameof(TotalElectricityArmorRating)))
                {
                    _intCachedTotalElectricityArmorRating = int.MinValue;
                }

                if (setNamesOfChangedProperties.Contains(nameof(TotalAcidArmorRating)))
                {
                    _intCachedTotalAcidArmorRating = int.MinValue;
                }

                if (setNamesOfChangedProperties.Contains(nameof(TotalFallingArmorRating)))
                {
                    _intCachedTotalFallingArmorRating = int.MinValue;
                }

                if (setNamesOfChangedProperties.Contains(nameof(TrustFund)))
                {
                    _intCachedTrustFund = int.MinValue;
                }

                if (setNamesOfChangedProperties.Contains(nameof(RestrictedGear)))
                {
                    _intCachedRestrictedGear = int.MinValue;
                }

                if (setNamesOfChangedProperties.Contains(nameof(FriendsInHighPlaces)))
                {
                    _intCachedFriendsInHighPlaces = int.MinValue;
                }

                if (setNamesOfChangedProperties.Contains(nameof(ExCon)))
                {
                    _intCachedExCon = int.MinValue;
                }

                if (setNamesOfChangedProperties.Contains(nameof(MadeMan)))
                {
                    _intCachedMadeMan = int.MinValue;
                }

                if (setNamesOfChangedProperties.Contains(nameof(Fame)))
                {
                    _intCachedFame = int.MinValue;
                }

                if (setNamesOfChangedProperties.Contains(nameof(Erased)))
                {
                    _intCachedErased = int.MinValue;
                }

                if (setNamesOfChangedProperties.Contains(nameof(AllowSpriteFettering)))
                {
                    _intCachedAllowSpriteFettering = int.MinValue;
                }

                if (setNamesOfChangedProperties.Contains(nameof(Overclocker)))
                {
                    _intCachedOverclocker = int.MinValue;
                }

                if (setNamesOfChangedProperties.Contains(nameof(Ambidextrous)))
                {
                    _intCachedAmbidextrous = int.MinValue;
                }

                if (setNamesOfChangedProperties.Contains(nameof(DealerConnectionDiscount)))
                {
                    _intCachedDealerConnectionDiscount = int.MinValue;
                    RefreshDealerConnectionDiscounts();
                }

                if (setNamesOfChangedProperties.Contains(nameof(BlackMarketDiscount)))
                {
                    _intCachedBlackMarketDiscount = int.MinValue;
                    RefreshBlackMarketDiscounts();
                }

                if (setNamesOfChangedProperties.Contains(nameof(PowerPointsUsed)))
                {
                    _decCachedPowerPointsUsed = decimal.MinValue;
                }

                if (setNamesOfChangedProperties.Contains(nameof(CyberwareEssence)))
                {
                    _decCachedCyberwareEssence = decimal.MinValue;
                }

                if (setNamesOfChangedProperties.Contains(nameof(BiowareEssence)))
                {
                    _decCachedPrototypeTranshumanEssenceUsed = decimal.MinValue;
                    _decCachedBiowareEssence = decimal.MinValue;
                }

                if (setNamesOfChangedProperties.Contains(nameof(EssenceHole)))
                {
                    _decCachedEssenceHole = decimal.MinValue;
                }

                if (setNamesOfChangedProperties.Contains(nameof(PrototypeTranshumanEssenceUsed)))
                {
                    _decCachedBiowareEssence = decimal.MinValue;
                    _decCachedPrototypeTranshumanEssenceUsed = decimal.MinValue;
                }

                if (setNamesOfChangedProperties.Contains(nameof(CareerNuyen)))
                {
                    _decCachedCareerNuyen = decimal.MinValue;
                }

                if (setNamesOfChangedProperties.Contains(nameof(CareerKarma)))
                {
                    _intCachedCareerKarma = int.MinValue;
                }

                if (setNamesOfChangedProperties.Contains(nameof(InitiationEnabled)))
                {
                    _intCachedInitiationEnabled = int.MinValue;
                }

                if (setNamesOfChangedProperties.Contains(nameof(RedlinerBonus)))
                {
                    _intCachedRedlinerBonus = int.MinValue;
                    RefreshRedlinerImprovements();
                }

                if (setNamesOfChangedProperties.Contains(nameof(Essence)))
                {
                    ResetCachedEssence();
                    RefreshEssenceLossImprovements();
                }

                if (setNamesOfChangedProperties.Contains(nameof(WoundModifier)))
                {
                    RefreshWoundPenalties();
                }

                if (setNamesOfChangedProperties.Contains(nameof(SustainingPenalty)))
                {
                    RefreshSustainingPenalties();
                }

                if (setNamesOfChangedProperties.Contains(nameof(EnemyKarma)))
                {
                    _intCachedEnemyKarma = int.MinValue;
                }

                if (setNamesOfChangedProperties.Contains(nameof(Qualities)))
                {
                    _intCachedNegativeQualities = int.MinValue;
                    _intCachedNegativeQualityLimitKarma = int.MinValue;
                    _intCachedPositiveQualities = int.MinValue;
                    _intCachedPositiveQualitiesTotal = int.MinValue;
                    _intCachedMetagenicNegativeQualities = int.MinValue;
                    _intCachedMetagenicPositiveQualities = int.MinValue;
                }

                if (setNamesOfChangedProperties.Contains(nameof(MetagenicLimit)))
                {
                    _intCachedMetagenicNegativeQualities = int.MinValue;
                    _intCachedMetagenicPositiveQualities = int.MinValue;
                }

                if (setNamesOfChangedProperties.Contains(nameof(TotalAstralReputation)))
                    RefreshAstralReputationImprovements();

                if (setNamesOfChangedProperties.Contains(nameof(Settings)))
                    foreach (string strProperty in Settings.GetType().GetProperties().Select(x => x.Name))
                        OptionsOnPropertyChanged(this, new PropertyChangedEventArgs(strProperty));

                foreach (string strPropertyToChange in setNamesOfChangedProperties)
                {
                    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(strPropertyToChange));
                }

                if (!Created)
                {
                    // If in create mode, update the Force for Spirits and Sprites (equal to Magician MAG Rating or RES Rating).
                    if (setNamesOfChangedProperties.Contains(nameof(MaxSpriteLevel)))
                    {
                        foreach (Spirit objSpirit in Spirits)
                        {
                            if (objSpirit.EntityType != SpiritType.Spirit)
                                objSpirit.Force = MaxSpriteLevel;
                        }
                    }

                    if (setNamesOfChangedProperties.Contains(nameof(MaxSpiritForce)))
                    {
                        foreach (Spirit objSpirit in Spirits)
                        {
                            if (objSpirit.EntityType == SpiritType.Spirit)
                                objSpirit.Force = MaxSpiritForce;
                        }
                    }
                }
            }
            finally
            {
                if (setNamesOfChangedProperties != null)
                    Utils.StringHashSetPool.Return(setNamesOfChangedProperties);
            }

            if (Program.MainForm == null || IsLoading)
                return;
            foreach(Character objLoopOpenCharacter in Program.MainForm.OpenCharacters)
            {
                if(objLoopOpenCharacter != this && objLoopOpenCharacter.LinkedCharacters.Contains(this))
                {
                    foreach(Spirit objSpirit in objLoopOpenCharacter.Spirits)
                    {
                        if(objSpirit.LinkedCharacter == this)
                        {
                            objSpirit.OnPropertyChanged(nameof(Spirit.LinkedCharacter));
                        }
                    }

                    foreach(Contact objContact in objLoopOpenCharacter.Contacts)
                    {
                        if(objContact.LinkedCharacter == this)
                        {
                            objContact.OnPropertyChanged(nameof(Contact.LinkedCharacter));
                        }
                    }
                }
            }
        }

        #region Hero Lab Importing
        public static readonly ReadOnlyCollection<string> HeroLabPluginNodeNames = Array.AsReadOnly(new[]
            {"modifications", "accessories", "ammunition", "programs", "othergear"});

        /// <summary>
        /// Load the Character from an XML file.
        /// </summary>
        public bool LoadFromHeroLabFile(string strPorFile, string strCharacterId, string strSettingsName = "")
        {
            return LoadFromHeroLabFileCoreAsync(true, strPorFile, strCharacterId, strSettingsName).GetAwaiter().GetResult();
        }

        /// <summary>
        /// Load the Character from an XML file.
        /// </summary>
        public Task<bool> LoadFromHeroLabFileAsync(string strPorFile, string strCharacterId, string strSettingsName = "")
        {
            return LoadFromHeroLabFileCoreAsync(false, strPorFile, strCharacterId, strSettingsName);
        }

        /// <summary>
        /// Load the Character from an XML file.
        /// </summary>
        public async Task<bool> LoadFromHeroLabFileCoreAsync(bool blnSync, string strPorFile, string strCharacterId, string strSettingsName = "")
        {
            if(!File.Exists(strPorFile))
                return false;
            while (IsLoadMethodRunning)
            {
                if (blnSync)
                    Utils.SafeSleep();
                else
                    await Utils.SafeSleepAsync();
            }
            IsLoadMethodRunning = true;
            try
            {
                Dictionary<string, Bitmap> dicImages = new Dictionary<string, Bitmap>(1);
                XPathNavigator xmlStatBlockDocument = null;
                XPathNavigator xmlLeadsDocument = null;
                List<string> lstTextStatBlockLines = null;
                using (CustomActivity op_load = Timekeeper.StartSyncron("LoadFromHeroLabFile", null,
                                                                        CustomActivity.OperationType.DependencyOperation, strPorFile))
                {
                    try
                    {
                        op_load.MyDependencyTelemetry.Type = "loadHeroLab";
                        op_load.MyDependencyTelemetry.Target = strPorFile;

                        try
                        {
                            string strLeadsName = string.Empty;
                            using (ZipArchive zipArchive = ZipFile.Open(strPorFile, ZipArchiveMode.Read,
                                Encoding.GetEncoding(850)))
                            {
                                foreach (ZipArchiveEntry entry in zipArchive.Entries)
                                {
                                    string strEntryFullName = entry.FullName;
                                    string strKey = Path.GetFileName(strEntryFullName);
                                    if ((xmlStatBlockDocument == null && strEntryFullName.StartsWith("statblocks_xml",
                                            StringComparison.OrdinalIgnoreCase)) ||
                                        (string.IsNullOrEmpty(strLeadsName) &&
                                         strEntryFullName.EndsWith("portfolio.xml",
                                             StringComparison.OrdinalIgnoreCase)) ||
                                        lstTextStatBlockLines == null && strEntryFullName.StartsWith("statblocks_txt",
                                            StringComparison.OrdinalIgnoreCase))
                                    {
                                        if (strEntryFullName.EndsWith(".xml", StringComparison.OrdinalIgnoreCase))
                                        {
                                            try
                                            {
                                                using (StreamReader objStreamReader =
                                                    new StreamReader(entry.Open(), true))
                                                {
                                                    using (XmlReader objReader = XmlReader.Create(objStreamReader,
                                                        GlobalSettings.SafeXmlReaderSettings))
                                                    {
                                                        XPathDocument xmlSourceDoc = new XPathDocument(objReader);
                                                        XPathNavigator objDummy = xmlSourceDoc.CreateNavigator();
                                                        if (strEntryFullName.StartsWith("statblocks_xml",
                                                            StringComparison.Ordinal))
                                                        {
                                                            if (objDummy.SelectSingleNode(
                                                                "/document/public/character[@name = " +
                                                                strCharacterId.CleanXPath() + ']') != null)
                                                                xmlStatBlockDocument = objDummy;
                                                        }
                                                        else
                                                        {
                                                            strLeadsName = objDummy.SelectSingleNode(
                                                                "/document/portfolio/hero[@heroname = " +
                                                                strCharacterId.CleanXPath() + "]/@leadfile")?.Value;
                                                        }
                                                    }
                                                }
                                            }
                                            // If we run into any problems loading the character xml files, fail out early.
                                            catch (IOException e)
                                            {
                                                Log.Info(e);
                                                Utils.BreakIfDebug();
                                            }
                                            catch (XmlException e)
                                            {
                                                Log.Info(e);
                                                Utils.BreakIfDebug();
                                            }
                                        }
                                        else if (strEntryFullName.EndsWith(".txt",
                                            StringComparison.OrdinalIgnoreCase) && !strKey.Contains('.'))
                                        {
                                            lstTextStatBlockLines = new List<string>(30);

                                            using (StreamReader objReader = File.OpenText(strEntryFullName))
                                            {
                                                string strLine;
                                                while ((strLine = blnSync
                                                    // ReSharper disable once MethodHasAsyncOverload
                                                    ? objReader.ReadLine()
                                                    : await objReader.ReadLineAsync()) != null)
                                                {
                                                    // Trim away the newlines and empty spaces at the beginning and end of lines
                                                    strLine = strLine.Trim('\n', '\r', ' ').Trim();

                                                    lstTextStatBlockLines.Add(strLine);
                                                }
                                            }
                                        }
                                    }
                                    else if (strEntryFullName.StartsWith("images", StringComparison.Ordinal) &&
                                             strEntryFullName.Contains('.'))
                                    {
                                        using (Bitmap bmpMugshot = new Bitmap(entry.Open(), true))
                                        {
                                            Bitmap bmpNewMugshot =
                                                bmpMugshot.PixelFormat == PixelFormat.Format32bppPArgb
                                                    ? bmpMugshot
                                                        .Clone() as Bitmap // Clone makes sure file handle is closed
                                                    : bmpMugshot.ConvertPixelFormat(PixelFormat.Format32bppPArgb);
                                            if (dicImages.TryGetValue(strKey, out Bitmap bmpExistingMugshot))
                                            {
                                                bmpExistingMugshot.Dispose();
                                                dicImages[strKey] = bmpNewMugshot;
                                            }
                                            else
                                                dicImages.Add(strKey, bmpNewMugshot);
                                        }
                                    }
                                }

                                if (!string.IsNullOrEmpty(strLeadsName))
                                {
                                    // Need a second sweep for the Leads file
                                    foreach (ZipArchiveEntry entry in zipArchive.Entries)
                                    {
                                        string strEntryFullName = entry.FullName;
                                        if (strEntryFullName.EndsWith(strLeadsName, StringComparison.OrdinalIgnoreCase))
                                        {
                                            try
                                            {
                                                using (StreamReader objStreamReader =
                                                    new StreamReader(entry.Open(), true))
                                                {
                                                    using (XmlReader objReader = XmlReader.Create(objStreamReader,
                                                        GlobalSettings.SafeXmlReaderSettings))
                                                    {
                                                        XPathDocument xmlSourceDoc = new XPathDocument(objReader);
                                                        xmlLeadsDocument = xmlSourceDoc.CreateNavigator();
                                                    }
                                                }
                                            }
                                            // If we run into any problems loading the character xml files, fail out early.
                                            catch (IOException)
                                            {
                                                continue;
                                            }
                                            catch (XmlException)
                                            {
                                                continue;
                                            }

                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        catch (IOException ex)
                        {
                            if (op_load != null)
                            {
                                op_load.SetSuccess(false);
                                op_load.AddBaggage(ex.GetType().Name, ex.Message);
                                Log.Error(ex);
                            }

                            Program.MainForm.ShowMessageBox(
                                string.Format(GlobalSettings.CultureInfo,
                                              blnSync
                                                  // ReSharper disable once MethodHasAsyncOverload
                                                  ? LanguageManager.GetString("Message_FailedLoad")
                                                  : await LanguageManager.GetStringAsync("Message_FailedLoad"), ex.Message),
                                blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? LanguageManager.GetString("MessageTitle_FailedLoad")
                                    : await LanguageManager.GetStringAsync("MessageTitle_FailedLoad"),
                                MessageBoxButtons.OK, MessageBoxIcon.Error);
                            return false;
                        }
                        catch (NotSupportedException ex)
                        {
                            if (op_load != null)
                            {
                                op_load.SetSuccess(false);
                                op_load.AddBaggage(ex.GetType().Name, ex.Message);
                                Log.Error(ex);
                            }

                            Program.MainForm.ShowMessageBox(
                                string.Format(GlobalSettings.CultureInfo,
                                              blnSync
                                                  // ReSharper disable once MethodHasAsyncOverload
                                                  ? LanguageManager.GetString("Message_FailedLoad")
                                                  : await LanguageManager.GetStringAsync("Message_FailedLoad"), ex.Message),
                                blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? LanguageManager.GetString("MessageTitle_FailedLoad")
                                    : await LanguageManager.GetStringAsync("MessageTitle_FailedLoad"),
                                MessageBoxButtons.OK, MessageBoxIcon.Error);
                            return false;
                        }
                        catch (UnauthorizedAccessException ex)
                        {
                            if (op_load != null)
                            {
                                op_load.SetSuccess(false);
                                op_load.AddBaggage(ex.GetType().Name, ex.Message);
                                Log.Error(ex);
                            }

                            Program.MainForm.ShowMessageBox(
                                string.Format(GlobalSettings.CultureInfo,
                                              blnSync
                                                  // ReSharper disable once MethodHasAsyncOverload
                                                  ? LanguageManager.GetString("Message_FailedLoad")
                                                  : await LanguageManager.GetStringAsync("Message_FailedLoad"), ex.Message),
                                blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? LanguageManager.GetString("MessageTitle_FailedLoad")
                                    : await LanguageManager.GetStringAsync("MessageTitle_FailedLoad"),
                                MessageBoxButtons.OK, MessageBoxIcon.Error);
                            return false;
                        }

                        if (xmlLeadsDocument == null || xmlStatBlockDocument == null)
                        {
                            return false;
                        }

                        IsLoading = true;
                        try
                        {
                            XPathNavigator xmlStatBlockBaseNode;
                            XPathNavigator xmlLeadsBaseNode;

                            using (_ = Timekeeper.StartSyncron("load_char_misc", op_load))
                            {
                                _dateFileLastWriteTime = File.GetLastWriteTimeUtc(strPorFile);

                                xmlStatBlockBaseNode =
                                    xmlStatBlockDocument.SelectSingleNode("/document/public/character[@name = " +
                                                                          strCharacterId.CleanXPath() + ']');
                                xmlLeadsBaseNode =
                                    xmlLeadsDocument.SelectSingleNode("/document/hero[@heroname = " +
                                                                      strCharacterId.CleanXPath() +
                                                                      "]");

                                _blnCreated = (xmlStatBlockBaseNode.SelectSingleNode("karma/@total")?.Value ?? "0") !=
                                              "0";
                                if (!_blnCreated)
                                {
                                    XPathNodeIterator xmlJournalEntries =
                                        xmlStatBlockBaseNode.SelectAndCacheExpression("journals/journal");
                                    if (xmlJournalEntries.Count > 1)
                                    {
                                        _blnCreated = true;
                                    }
                                    else if (xmlJournalEntries.Count == 1 &&
                                             xmlJournalEntries.Current.SelectSingleNode("@name")?.Value != "Title")
                                    {
                                        _blnCreated = true;
                                    }
                                }

                                ResetCharacter();

                                // Get the name of the settings file in use if possible.
                                if (!string.IsNullOrEmpty(strSettingsName))
                                {
                                    if (!SettingsManager.LoadedCharacterSettings.ContainsKey(strSettingsName))
                                        return false;

                                    SettingsKey = strSettingsName;
                                }

                                // Metatype information.
                                string strRaceString = xmlStatBlockBaseNode.SelectSingleNode("race/@name")?.Value;
                                if (!string.IsNullOrEmpty(strRaceString))
                                {
                                    if (strRaceString == "Metasapient")
                                        strRaceString = "A.I.";
                                    foreach (XPathNavigator xmlMetatype in (blnSync
                                            // ReSharper disable once MethodHasAsyncOverload
                                            ? LoadDataXPath("metatypes.xml")
                                            : await LoadDataXPathAsync("metatypes.xml"))
                                        .SelectAndCacheExpression("/chummer/metatypes/metatype"))
                                    {
                                        string strMetatypeName = xmlMetatype.SelectSingleNode("name").Value;
                                        if (strMetatypeName == strRaceString)
                                        {
                                            _strMetatype = strMetatypeName;
                                            _strMetatypeCategory = xmlMetatype.SelectSingleNode("category").Value;
                                            _strMetavariant = "None";

                                            XPathNavigator objRunNode = xmlMetatype.SelectSingleNode("run");
                                            XPathNavigator objWalkNode = xmlMetatype.SelectSingleNode("walk");
                                            XPathNavigator objSprintNode = xmlMetatype.SelectSingleNode("sprint");

                                            _strMovement = xmlMetatype.SelectSingleNode("movement")?.Value ??
                                                           string.Empty;
                                            _strRun = objRunNode?.Value ?? string.Empty;
                                            _strWalk = objWalkNode?.Value ?? string.Empty;
                                            _strSprint = objSprintNode?.Value ?? string.Empty;

                                            objRunNode = objRunNode?.SelectSingleNode("@alt");
                                            objWalkNode = objWalkNode?.SelectSingleNode("@alt");
                                            objSprintNode = objSprintNode?.SelectSingleNode("@alt");
                                            _strRunAlt = objRunNode?.Value ?? string.Empty;
                                            _strWalkAlt = objWalkNode?.Value ?? string.Empty;
                                            _strSprintAlt = objSprintNode?.Value ?? string.Empty;
                                            break;
                                        }

                                        foreach (XPathNavigator xmlMetavariant in xmlMetatype.Select(
                                            "metavariants/metavariant"))
                                        {
                                            string strMetavariantName = xmlMetavariant.SelectSingleNode("name").Value;
                                            if (strMetavariantName == strRaceString)
                                            {
                                                _strMetatype = strMetatypeName;
                                                _strMetatypeCategory = xmlMetatype.SelectSingleNode("category").Value;
                                                _strMetavariant = strMetavariantName;

                                                XPathNavigator objRunNode = xmlMetavariant?.SelectSingleNode("run") ??
                                                                            xmlMetatype?.SelectSingleNode("run");
                                                XPathNavigator objWalkNode = xmlMetavariant?.SelectSingleNode("walk") ??
                                                                             xmlMetatype?.SelectSingleNode("walk");
                                                XPathNavigator objSprintNode =
                                                    xmlMetavariant?.SelectSingleNode("sprint") ??
                                                    xmlMetatype?.SelectSingleNode("sprint");

                                                _strMovement = xmlMetavariant?.SelectSingleNode("movement")?.Value ??
                                                               xmlMetatype?.SelectSingleNode("movement")?.Value ??
                                                               string.Empty;
                                                _strRun = objRunNode?.Value ?? string.Empty;
                                                _strWalk = objWalkNode?.Value ?? string.Empty;
                                                _strSprint = objSprintNode?.Value ?? string.Empty;

                                                objRunNode = objRunNode?.SelectSingleNode("@alt");
                                                objWalkNode = objWalkNode?.SelectSingleNode("@alt");
                                                objSprintNode = objSprintNode?.SelectSingleNode("@alt");
                                                _strRunAlt = objRunNode?.Value ?? string.Empty;
                                                _strWalkAlt = objWalkNode?.Value ?? string.Empty;
                                                _strSprintAlt = objSprintNode?.Value ?? string.Empty;
                                                break;
                                            }
                                        }
                                    }
                                }

                                // General character information.
                                int intAsIndex = strCharacterId.IndexOf(" as ", StringComparison.Ordinal);
                                if (intAsIndex != -1)
                                {
                                    _strName = strCharacterId.Substring(0, intAsIndex);
                                    _strAlias = strCharacterId.Substring(intAsIndex).TrimStart(" as ").Trim('\'');
                                }
                                else
                                {
                                    _strAlias = strCharacterId;
                                }

                                XPathNavigator xmlPersonalNode = xmlStatBlockBaseNode.SelectSingleNode("personal");
                                if (xmlPersonalNode != null)
                                {
                                    _strBackground = xmlPersonalNode.SelectSingleNode("description")?.Value;
                                    _strHeight = xmlPersonalNode.SelectSingleNode("charheight/@text")?.Value;
                                    _strWeight = xmlPersonalNode.SelectSingleNode("charweight/@text")?.Value;
                                    if (xmlPersonalNode.HasAttributes)
                                    {
                                        _strGender = xmlPersonalNode.SelectSingleNode("@gender")?.Value;
                                        _strAge = xmlPersonalNode.SelectSingleNode("@age")?.Value;
                                        _strHair = xmlPersonalNode.SelectSingleNode("@hair")?.Value;
                                        _strEyes = xmlPersonalNode.SelectSingleNode("@eyes")?.Value;
                                        _strSkin = xmlPersonalNode.SelectSingleNode("@skin")?.Value;
                                    }
                                }

                                _strPlayerName = xmlStatBlockBaseNode.SelectSingleNode("@playername")?.Value;

                                foreach (XPathNavigator xmlImageFileNameNode in xmlStatBlockBaseNode.Select(
                                    "images/image/@filename"))
                                {
                                    if (dicImages.TryGetValue(xmlImageFileNameNode.Value, out Bitmap objOutput))
                                        _lstMugshots.Add(objOutput);
                                }

                                if (_lstMugshots.Count > 0)
                                    _intMainMugshotIndex = 0;

                                if (string.IsNullOrEmpty(strSettingsName))
                                {
                                    string strSettingsSummary =
                                        xmlStatBlockBaseNode.SelectSingleNode("settings/@summary")?.Value;
                                    if (!string.IsNullOrEmpty(strSettingsSummary))
                                    {
                                        int intCharCreationSystemsIndex =
                                            strSettingsSummary.IndexOf("Character Creation Systems:",
                                                StringComparison.Ordinal);
                                        int intSemicolonIndex = strSettingsSummary.IndexOf(';');
                                        if (intCharCreationSystemsIndex + 28 <= intSemicolonIndex &&
                                            intCharCreationSystemsIndex != -1)
                                        {
                                            string strHeroLabSettingsName = strSettingsSummary.Substring(
                                                    intCharCreationSystemsIndex + 28,
                                                    strSettingsSummary.IndexOf(';') - 28 - intCharCreationSystemsIndex)
                                                .Trim();
                                            if (strHeroLabSettingsName == "Established Runners")
                                                strHeroLabSettingsName = "Standard";
                                            KeyValuePair<string, CharacterSettings> kvpHeroLabSettings =
                                                SettingsManager.LoadedCharacterSettings.FirstOrDefault(x =>
                                                    x.Value.Name == strHeroLabSettingsName);
                                            if (kvpHeroLabSettings.Value != null)
                                            {
                                                SettingsKey = kvpHeroLabSettings.Key;
                                                strSettingsName = kvpHeroLabSettings.Key;
                                            }
                                        }
                                    }
                                }

                                if (string.IsNullOrEmpty(strSettingsName))
                                {
                                    int intKarma =
                                        xmlStatBlockBaseNode.SelectSingleNode("creation/bp/@total")?.ValueAsInt ?? 0;

                                    if (intKarma >= 100)
                                    {
                                        KeyValuePair<string, CharacterSettings> kvpHeroLabSettings =
                                            SettingsManager.LoadedCharacterSettings.FirstOrDefault(x =>
                                                x.Value.BuiltInOption
                                                && x.Value.BuildMethod == CharacterBuildMethod.Karma);
                                        if (kvpHeroLabSettings.Value != null)
                                        {
                                            SettingsKey = kvpHeroLabSettings.Key;
                                            strSettingsName = kvpHeroLabSettings.Key;
                                        }
                                    }
                                    else
                                    {
                                        _strPriorityAttributes = ConvertPriorityString(xmlLeadsBaseNode
                                            .SelectSingleNode(
                                                "container/pick[@thing = \"priAttr\"]/field[@id = \"priOrder\"]/@value")
                                            ?.Value);
                                        _strPrioritySpecial = ConvertPriorityString(xmlLeadsBaseNode
                                            .SelectSingleNode(
                                                "container/pick[@thing = \"priMagic\"]/field[@id = \"priOrder\"]/@value")
                                            ?.Value);
                                        _strPriorityMetatype = ConvertPriorityString(xmlLeadsBaseNode
                                            .SelectSingleNode(
                                                "container/pick[@thing = \"priMeta\"]/field[@id = \"priOrder\"]/@value")
                                            ?.Value);
                                        _strPriorityResources = ConvertPriorityString(xmlLeadsBaseNode
                                            .SelectSingleNode(
                                                "container/pick[@thing = \"priResourc\"]/field[@id = \"priOrder\"]/@value")
                                            ?.Value);
                                        _strPrioritySkills = ConvertPriorityString(xmlLeadsBaseNode
                                            .SelectSingleNode(
                                                "container/pick[@thing = \"priSkill\"]/field[@id = \"priOrder\"]/@value")
                                            ?.Value);

                                        string ConvertPriorityString(string strInput)
                                        {
                                            switch (strInput)
                                            {
                                                case "1.":
                                                    return "A";
                                                case "2.":
                                                    return "B";
                                                case "3.":
                                                    return "C";
                                                case "4.":
                                                    return "D";
                                                case "5.":
                                                    return "E";
                                                default:
                                                    return string.Empty;
                                            }
                                        }

                                        if (_strPriorityAttributes == _strPrioritySpecial ||
                                            _strPriorityAttributes == _strPriorityMetatype ||
                                            _strPriorityAttributes == _strPriorityResources ||
                                            _strPriorityAttributes == _strPrioritySkills ||
                                            _strPrioritySpecial == _strPrioritySkills ||
                                            _strPrioritySpecial == _strPriorityMetatype ||
                                            _strPrioritySpecial == _strPriorityResources ||
                                            _strPriorityMetatype == _strPriorityResources ||
                                            _strPriorityMetatype == _strPrioritySpecial ||
                                            _strPriorityResources == _strPrioritySkills)
                                        {
                                            KeyValuePair<string, CharacterSettings> kvpHeroLabSettings =
                                                SettingsManager.LoadedCharacterSettings.FirstOrDefault(x =>
                                                    x.Value.BuiltInOption
                                                    && x.Value.BuildMethod == CharacterBuildMethod.SumtoTen);
                                            if (kvpHeroLabSettings.Value != null)
                                            {
                                                SettingsKey = kvpHeroLabSettings.Key;
                                                strSettingsName = kvpHeroLabSettings.Key;
                                            }
                                        }
                                        else
                                        {
                                            KeyValuePair<string, CharacterSettings> kvpHeroLabSettings =
                                                SettingsManager.LoadedCharacterSettings.FirstOrDefault(x =>
                                                    x.Value.BuiltInOption
                                                    && x.Value.BuildMethod == CharacterBuildMethod.Priority);
                                            if (kvpHeroLabSettings.Value != null)
                                            {
                                                SettingsKey = kvpHeroLabSettings.Key;
                                                strSettingsName = kvpHeroLabSettings.Key;
                                            }
                                        }
                                    }
                                }

                                if (string.IsNullOrEmpty(strSettingsName))
                                {
                                    if (Program.MainForm.ShowMessageBox(
                                        string.Format(GlobalSettings.CultureInfo,
                                                      blnSync
                                                          // ReSharper disable once MethodHasAsyncOverload
                                                          ? LanguageManager.GetString("Message_MissingGameplayOption")
                                                          : await LanguageManager.GetStringAsync("Message_MissingGameplayOption"),
                                            SettingsKey),
                                        blnSync
                                            // ReSharper disable once MethodHasAsyncOverload
                                            ? LanguageManager.GetString("Message_MissingGameplayOption_Title")
                                            : await LanguageManager.GetStringAsync("Message_MissingGameplayOption_Title"),
                                        MessageBoxButtons.OKCancel, MessageBoxIcon.Error) == DialogResult.OK)
                                    {
                                        using (SelectBuildMethod frmPickBP = new SelectBuildMethod(this, true))
                                        {
                                            frmPickBP.ShowDialogSafe(Program.GetFormForDialog(this));
                                            if (frmPickBP.DialogResult != DialogResult.OK)
                                                return false;
                                        }
                                    }
                                    else
                                        return false;
                                }

                                if (EffectiveBuildMethodUsesPriorityTables)
                                {
                                    if (strRaceString == "A.I.")
                                        _strPriorityTalent = "AI";
                                    XPathNavigator xmlPriorityTalentPick =
                                        xmlLeadsBaseNode.SelectSingleNode(
                                            "container/pick[starts-with(@thing, \"qu\") and @source = \"heritage\"]");
                                    if (xmlPriorityTalentPick != null)
                                    {
                                        switch (xmlPriorityTalentPick.SelectSingleNode("@thing")?.Value)
                                        {
                                            case "quAware":
                                                _strPriorityTalent = "Aware";
                                                break;
                                            case "quEnchanter":
                                                _strPriorityTalent = "Enchanter";
                                                break;
                                            case "quExplorer":
                                                _strPriorityTalent = "Explorer";
                                                break;
                                            case "quApprentice":
                                                _strPriorityTalent = "Apprentice";
                                                break;
                                            case "quAspectedMagician":
                                                _strPriorityTalent = "Aspected Magician";
                                                break;
                                            case "quAdept":
                                                _strPriorityTalent = "Adept";
                                                break;
                                            case "quMagician":
                                                _strPriorityTalent = "Magician";
                                                break;
                                            case "quMysticAdept":
                                                _strPriorityTalent = "Mystic Adept";
                                                break;
                                            case "quTechnoma":
                                                _strPriorityTalent = "Technomancer";
                                                break;
                                        }

                                        _lstPrioritySkills.Clear();
                                        foreach (XPathNavigator xmlField in xmlPriorityTalentPick.SelectAndCacheExpression("field"))
                                        {
                                            string strInnerText = xmlField.Value;
                                            if (!string.IsNullOrEmpty(strInnerText))
                                            {
                                                _lstPrioritySkills.Add(strInnerText);
                                            }
                                        }
                                    }

                                    using (SelectMetatypePriority frmSelectMetatype = new SelectMetatypePriority(this))
                                    {
                                        frmSelectMetatype.ShowDialogSafe(Program.GetFormForDialog(this));
                                        if (frmSelectMetatype.DialogResult == DialogResult.Cancel)
                                            return false;
                                    }
                                }
                                else
                                {
                                    using (SelectMetatypeKarma frmSelectMetatype = new SelectMetatypeKarma(this))
                                    {
                                        frmSelectMetatype.ShowDialogSafe(Program.GetFormForDialog(this));
                                        if (frmSelectMetatype.DialogResult == DialogResult.Cancel)
                                            return false;
                                    }
                                }

                                XPathNavigator xmlKarmaNode = xmlStatBlockBaseNode.SelectSingleNode("karma");
                                if (xmlKarmaNode != null)
                                {
                                    int.TryParse(xmlKarmaNode.SelectSingleNode("@left")?.Value, NumberStyles.Any,
                                        GlobalSettings.InvariantCultureInfo, out _intKarma);
                                    int.TryParse(xmlKarmaNode.SelectSingleNode("@total")?.Value, NumberStyles.Any,
                                        GlobalSettings.InvariantCultureInfo, out _intTotalKarma);
                                }

                                XPathNavigator xmlReputationsNode =
                                    xmlStatBlockBaseNode.SelectSingleNode("reputations");
                                if (xmlReputationsNode != null)
                                {
                                    int.TryParse(
                                        xmlReputationsNode
                                            .SelectSingleNode("reputation[@name = \"Street Cred\"]/@value")
                                            .Value,
                                        NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                        out _intStreetCred);
                                    int.TryParse(
                                        xmlReputationsNode.SelectSingleNode("reputation[@name = \"Notoriety\"]/@value")
                                            .Value,
                                        NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                        out _intNotoriety);
                                    int.TryParse(
                                        xmlReputationsNode
                                            .SelectSingleNode("reputation[@name = \"Public Awareness\"]/@value")
                                            .Value, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                        out _intPublicAwareness);
                                }

                                if (Created)
                                {
                                    decimal.TryParse(xmlStatBlockBaseNode.SelectSingleNode("cash/@total")?.Value,
                                        NumberStyles.Any,
                                        GlobalSettings.InvariantCultureInfo, out _decNuyen);
                                }

                                /* TODO: Initiation, Submersion Grades
                                objXmlCharacter.TryGetInt32FieldQuickly("initiategrade", ref _intInitiateGrade);
                                objXmlCharacter.TryGetInt32FieldQuickly("submersiongrade", ref _intSubmersionGrade);
                                */
                                //Timekeeper.Finish("load_char_misc");
                            }

                            List<Weapon> lstWeapons = new List<Weapon>(1);
                            List<Vehicle> lstVehicles = new List<Vehicle>(1);

                            using (_ = Timekeeper.StartSyncron("load_char_quality", op_load))
                            {
                                string[] astrLevelLabels =
                                {
                                    " (0)",
                                    " (1)",
                                    " (2)",
                                    " (3)",
                                    " (4)",
                                    " (5)",
                                    " (6)",
                                    " (7)",
                                    " (8)",
                                    " (9)",
                                    " (10)",
                                    " (11)",
                                    " (12)",
                                    " (13)",
                                    " (14)",
                                    " (15)"
                                };
                                // Qualities
                                XmlDocument xmlQualitiesDocument = blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? LoadData("qualities.xml")
                                    : await LoadDataAsync("qualities.xml");
                                foreach (XPathNavigator xmlQualityToImport in xmlStatBlockBaseNode.Select(
                                    "qualities/positive/quality[traitcost/@bp != \"0\"]"))
                                {
                                    string strQualityName = xmlQualityToImport.SelectSingleNode("@name")?.Value;
                                    if (!string.IsNullOrEmpty(strQualityName))
                                    {
                                        int intDicepoolLabelIndex =
                                            strQualityName.LastIndexOf("dicepool", StringComparison.Ordinal);
                                        if (intDicepoolLabelIndex != -1)
                                        {
                                            int intCullIndex = strQualityName.LastIndexOf('(', intDicepoolLabelIndex);
                                            if (intCullIndex != -1)
                                                strQualityName = strQualityName.Substring(0, intCullIndex).Trim();
                                        }

                                        int intQuantity = 1;
                                        for (int i = 0; i < astrLevelLabels.Length; ++i)
                                        {
                                            string strLoopString = astrLevelLabels[i];
                                            if (strQualityName.EndsWith(strLoopString, StringComparison.Ordinal))
                                            {
                                                strQualityName = strQualityName.TrimEndOnce(strLoopString, true);
                                                intQuantity = i;
                                                break;
                                            }
                                        }

                                        string strForcedValue = string.Empty;
                                        XmlNode xmlQualityDataNode =
                                            xmlQualitiesDocument.SelectSingleNode(
                                                "/chummer/qualities/quality[name = " + strQualityName.CleanXPath() +
                                                "]");
                                        if (xmlQualityDataNode == null)
                                        {
                                            string[] astrOriginalNameSplit =
                                                strQualityName.Split(':', StringSplitOptions.RemoveEmptyEntries);
                                            if (astrOriginalNameSplit.Length > 1)
                                            {
                                                string strName = astrOriginalNameSplit[0].Trim();
                                                xmlQualityDataNode =
                                                    xmlQualitiesDocument.SelectSingleNode(
                                                        "/chummer/qualities/quality[name = " + strName.CleanXPath() +
                                                        "]");
                                                if (xmlQualityDataNode != null)
                                                    strForcedValue = astrOriginalNameSplit[1].Trim();
                                            }
                                        }

                                        if (xmlQualityDataNode == null)
                                        {
                                            string[] astrOriginalNameSplit =
                                                strQualityName.Split(',', StringSplitOptions.RemoveEmptyEntries);
                                            if (astrOriginalNameSplit.Length > 1)
                                            {
                                                string strName = astrOriginalNameSplit[0].Trim();
                                                xmlQualityDataNode =
                                                    xmlQualitiesDocument.SelectSingleNode(
                                                        "/chummer/qualities/quality[name = " + strName.CleanXPath() +
                                                        "]");
                                                if (xmlQualityDataNode != null)
                                                    strForcedValue = astrOriginalNameSplit[1].Trim();
                                            }
                                        }

                                        if (xmlQualityDataNode != null)
                                        {
                                            for (int i = 0; i < intQuantity; ++i)
                                            {
                                                Quality objQuality = new Quality(this);
                                                objQuality.Create(xmlQualityDataNode, QualitySource.Selected,
                                                    lstWeapons,
                                                    strForcedValue);
                                                objQuality.Notes =
                                                    xmlQualityToImport.SelectSingleNode("description")?.Value ??
                                                    string.Empty;
                                                _lstQualities.Add(objQuality);
                                            }
                                        }
                                    }
                                }

                                foreach (XPathNavigator xmlQualityToImport in xmlStatBlockBaseNode.Select(
                                    "qualities/negative/quality[traitcost/@bp != \"0\"]"))
                                {
                                    string strQualityName = xmlQualityToImport.SelectSingleNode("@name")?.Value;
                                    if (!string.IsNullOrEmpty(strQualityName))
                                    {
                                        int intDicepoolLabelIndex =
                                            strQualityName.LastIndexOf("dicepool", StringComparison.Ordinal);
                                        if (intDicepoolLabelIndex != -1)
                                        {
                                            int intCullIndex = strQualityName.LastIndexOf('(', intDicepoolLabelIndex);
                                            if (intCullIndex != -1)
                                                strQualityName = strQualityName.Substring(0, intCullIndex).Trim();
                                        }

                                        switch (strQualityName)
                                        {
                                            case "Reduced (hearing)":
                                                strQualityName = "Reduced Sense (Hearing)";
                                                break;
                                            case "Reduced (smell)":
                                                strQualityName = "Reduced Sense (Smell)";
                                                break;
                                            case "Reduced (taste)":
                                                strQualityName = "Reduced Sense (Taste)";
                                                break;
                                            case "Reduced (touch)":
                                                strQualityName = "Reduced Sense (Touch)";
                                                break;
                                            case "Reduced (sight)":
                                                strQualityName = "Reduced Sense (Sight)";
                                                break;
                                        }

                                        int intQuantity = 1;
                                        for (int i = 0; i < astrLevelLabels.Length; ++i)
                                        {
                                            string strLoopString = astrLevelLabels[i];
                                            if (strQualityName.EndsWith(strLoopString, StringComparison.Ordinal))
                                            {
                                                strQualityName = strQualityName.TrimEndOnce(strLoopString, true);
                                                intQuantity = i;
                                                break;
                                            }
                                        }

                                        string strForcedValue = string.Empty;
                                        XmlNode xmlQualityDataNode =
                                            xmlQualitiesDocument.SelectSingleNode(
                                                "/chummer/qualities/quality[name = " + strQualityName.CleanXPath() +
                                                "]");
                                        if (xmlQualityDataNode == null)
                                        {
                                            string[] astrOriginalNameSplit =
                                                strQualityName.Split(':', StringSplitOptions.RemoveEmptyEntries);
                                            if (astrOriginalNameSplit.Length > 1)
                                            {
                                                string strName = astrOriginalNameSplit[0].Trim();
                                                xmlQualityDataNode =
                                                    xmlQualitiesDocument.SelectSingleNode(
                                                        "/chummer/qualities/quality[name = " + strName.CleanXPath() +
                                                        "]");
                                                if (xmlQualityDataNode != null)
                                                    strForcedValue = astrOriginalNameSplit[1].Trim();
                                            }
                                        }

                                        if (xmlQualityDataNode == null)
                                        {
                                            string[] astrOriginalNameSplit =
                                                strQualityName.Split(',', StringSplitOptions.RemoveEmptyEntries);
                                            if (astrOriginalNameSplit.Length > 1)
                                            {
                                                string strName = astrOriginalNameSplit[0].Trim();
                                                xmlQualityDataNode =
                                                    xmlQualitiesDocument.SelectSingleNode(
                                                        "/chummer/qualities/quality[name = " + strName.CleanXPath() +
                                                        "]");
                                                if (xmlQualityDataNode != null)
                                                    strForcedValue = astrOriginalNameSplit[1].Trim();
                                            }
                                        }

                                        if (xmlQualityDataNode != null)
                                        {
                                            for (int i = 0; i < intQuantity; ++i)
                                            {
                                                Quality objQuality = new Quality(this);
                                                objQuality.Create(xmlQualityDataNode, QualitySource.Selected,
                                                    lstWeapons,
                                                    strForcedValue);
                                                objQuality.Notes =
                                                    xmlQualityToImport.SelectSingleNode("description")?.Value ??
                                                    string.Empty;
                                                _lstQualities.Add(objQuality);
                                            }
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_quality");
                            }

                            AttributeSection.LoadFromHeroLab(xmlStatBlockBaseNode, op_load);
                            using (_ = Timekeeper.StartSyncron("load_char_misc2", op_load))
                            {
                                /* TODO: Find some way to get Mystic Adept PPs from Hero Lab files
                                // Attempt to load the split MAG CharacterAttribute information for Mystic Adepts.
                                if (_blnAdeptEnabled && _blnMagicianEnabled)
                                {
                                    xmlCharacterNavigator.TryGetInt32FieldQuickly("magsplitadept", ref _intMAGAdept);
                                    xmlCharacterNavigator.TryGetInt32FieldQuickly("magsplitmagician", ref _intMAGMagician);
                                }
                                */

                                // Attempt to load in the character's tradition
                                if (xmlStatBlockBaseNode.SelectSingleNode("magic/tradition") != null)
                                {
                                    _objTradition.LoadFromHeroLab(
                                        xmlStatBlockBaseNode.SelectSingleNode("magic/tradition"));
                                }

                                // Attempt to load Condition Monitor Progress.
                                XPathNavigator xmlPhysicalCMFilledNode =
                                    xmlLeadsBaseNode.SelectSingleNode(
                                        "usagepool[@id = \"DmgNet\" and @pickindex=\"5\"]/@quantity");
                                if (xmlPhysicalCMFilledNode != null)
                                    int.TryParse(xmlPhysicalCMFilledNode.Value, NumberStyles.Any,
                                        GlobalSettings.InvariantCultureInfo, out _intPhysicalCMFilled);
                                XPathNavigator xmlStunCMFilledNode =
                                    xmlLeadsBaseNode.SelectSingleNode(
                                        "usagepool[@id = \"DmgNet\" and @pickindex=\"6\"]/@quantity");
                                if (xmlStunCMFilledNode != null)
                                    int.TryParse(xmlStunCMFilledNode.Value, NumberStyles.Any,
                                        GlobalSettings.InvariantCultureInfo, out _intStunCMFilled);
                                //Timekeeper.Finish("load_char_misc2");
                            }

                            using (CustomActivity op_load_char_skills =
                                Timekeeper.StartSyncron("load_char_skills", op_load)) //slightly messy
                            {
                                SkillsSection.LoadFromHeroLab(xmlStatBlockBaseNode.SelectSingleNode("skills"),
                                                              op_load_char_skills);

                                //Timekeeper.Finish("load_char_skills");
                            }

                            /* TODO: Add support for locations from HeroLab
                            Timekeeper.Start("load_char_loc");
        
                            // Locations.
                            XmlNodeList objXmlLocationList = objXmlCharacter.SelectNodes("gearlocations/gearlocation");
                            foreach (XmlNode objXmlLocation in objXmlLocationList)
                            {
                                Location objLocation = new Location(this, _lstGearLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }
        
                            objXmlLocationList = objXmlCharacter.SelectNodes("locations/location");
                            foreach (XmlNode objXmlLocation in objXmlLocationList)
                            {
                                Location objLocation = new Location(this, _lstGearLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }
        
                            objXmlLocationList = objXmlCharacter.SelectNodes("gearlocations/location");
                            foreach (XmlNode objXmlLocation in objXmlLocationList)
                            {
                                Location objLocation = new Location(this, _lstGearLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }
        
                            Timekeeper.Finish("load_char_loc");
                            Timekeeper.Start("load_char_abundle");
        
                            // Armor Bundles.
                            objXmlLocationList = objXmlCharacter.SelectNodes("armorbundles/armorbundle");
                            foreach (XmlNode objXmlLocation in objXmlLocationList)
                            {
                                Location objLocation = new Location(this, _lstArmorLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }
        
                            objXmlLocationList = objXmlCharacter.SelectNodes("armorlocations/armorlocation");
                            foreach (XmlNode objXmlLocation in objXmlLocationList)
                            {
                                Location objLocation = new Location(this, _lstArmorLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }
        
                            objXmlLocationList = objXmlCharacter.SelectNodes("armorlocations/location");
                            foreach (XmlNode objXmlLocation in objXmlLocationList)
                            {
                                Location objLocation = new Location(this, _lstArmorLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }
        
                            Timekeeper.Finish("load_char_abundle");
                            Timekeeper.Start("load_char_vloc");
        
                            // Vehicle Locations.
                            XmlNodeList objXmlVehicleLocationList = objXmlCharacter.SelectNodes("vehiclelocations/vehiclelocation");
                            foreach (XmlNode objXmlLocation in objXmlVehicleLocationList)
                            {
                                Location objLocation = new Location(this, _lstVehicleLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }
        
                            objXmlVehicleLocationList = objXmlCharacter.SelectNodes("vehiclelocations/location");
                            foreach (XmlNode objXmlLocation in objXmlVehicleLocationList)
                            {
                                Location objLocation = new Location(this, _lstVehicleLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }
        
                            Timekeeper.Finish("load_char_vloc");
                            Timekeeper.Start("load_char_wloc");
        
                            // Weapon Locations.
                            XmlNodeList objXmlWeaponLocationList = objXmlCharacter.SelectNodes("weaponlocations/weaponlocation");
                            foreach (XmlNode objXmlLocation in objXmlWeaponLocationList)
                            {
                                Location objLocation = new Location(this, _lstWeaponLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }
        
                            objXmlWeaponLocationList = objXmlCharacter.SelectNodes("weaponlocations/location");
                            foreach (XmlNode objXmlLocation in objXmlWeaponLocationList)
                            {
                                Location objLocation = new Location(this, _lstWeaponLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }
        
                            Timekeeper.Finish("load_char_wloc");
                            */
                            using (_ = Timekeeper.StartSyncron("load_char_contacts", op_load))
                            {
                                // Contacts.
                                foreach (XPathNavigator xmlContactToImport in xmlStatBlockBaseNode.Select(
                                    "contacts/contact[@useradded != \"no\"]"))
                                {
                                    Contact objContact = new Contact(this)
                                    {
                                        EntityType = ContactType.Contact,
                                        Name = xmlContactToImport.SelectSingleNode("@name")?.Value ?? string.Empty,
                                        Role = xmlContactToImport.SelectSingleNode("@type")?.Value ?? string.Empty,
                                        Connection =
                                            xmlContactToImport.SelectSingleNode("@connection")?.ValueAsInt ?? 1,
                                        Loyalty = xmlContactToImport.SelectSingleNode("@loyalty")?.ValueAsInt ?? 1
                                    };
                                    string strDescription = xmlContactToImport.SelectSingleNode("description")?.Value;
                                    using (new FetchSafelyFromPool<StringBuilder>(
                                               Utils.StringBuilderPool, out StringBuilder sbdNotes))
                                    {
                                        foreach (string strLine in strDescription.SplitNoAlloc('\n',
                                                     StringSplitOptions.RemoveEmptyEntries))
                                        {
                                            string[] astrLineColonSplit =
                                                strLine.Split(':', StringSplitOptions.RemoveEmptyEntries);
                                            switch (astrLineColonSplit[0])
                                            {
                                                case "Metatype":
                                                    objContact.Metatype = astrLineColonSplit[1].Trim();
                                                    break;
                                                case "Gender":
                                                    objContact.Gender = astrLineColonSplit[1].Trim();
                                                    break;
                                                case "Age":
                                                    objContact.Age = astrLineColonSplit[1].Trim();
                                                    break;
                                                case "Preferred Payment Method":
                                                    objContact.PreferredPayment = astrLineColonSplit[1].Trim();
                                                    break;
                                                case "Hobbies/Vice":
                                                    objContact.HobbiesVice = astrLineColonSplit[1].Trim();
                                                    break;
                                                case "Personal Life":
                                                    objContact.PersonalLife = astrLineColonSplit[1].Trim();
                                                    break;
                                                case "Type":
                                                    objContact.Type = astrLineColonSplit[1].Trim();
                                                    break;
                                                default:
                                                    sbdNotes.AppendLine(strLine);
                                                    break;
                                            }
                                        }

                                        if (sbdNotes.Length > 0)
                                            sbdNotes.Length -= Environment.NewLine.Length;
                                        objContact.Notes = sbdNotes.ToString();
                                    }

                                    _lstContacts.Add(objContact);
                                }

                                //Timekeeper.Finish("load_char_contacts");
                            }

                            XmlDocument xmlGearDocument;
                            using (_ = Timekeeper.StartSyncron("load_char_armor", op_load))
                            {
                                // Armor.
                                xmlGearDocument = blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? LoadData("gear.xml")
                                    : await LoadDataAsync("gear.xml");
                                XmlDocument xmlArmorDocument = blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? LoadData("armor.xml")
                                    : await LoadDataAsync("armor.xml");
                                foreach (XPathNavigator xmlArmorToImport in xmlStatBlockBaseNode.Select(
                                    "gear/armor/item[@useradded != \"no\"]"))
                                {
                                    string strArmorName = xmlArmorToImport.SelectSingleNode("@name")?.Value;
                                    if (!string.IsNullOrEmpty(strArmorName))
                                    {
                                        XmlNode xmlArmorData =
                                            xmlArmorDocument.SelectSingleNode(
                                                "chummer/armors/armor[name = " + strArmorName.CleanXPath() + ']');
                                        if (xmlArmorData == null)
                                        {
                                            string[] astrOriginalNameSplit =
                                                strArmorName.Split(':', StringSplitOptions.RemoveEmptyEntries);
                                            if (astrOriginalNameSplit.Length > 1)
                                            {
                                                string strName = astrOriginalNameSplit[0].Trim();
                                                xmlArmorData =
                                                    xmlArmorDocument.SelectSingleNode(
                                                        "/chummer/armors/armor[name = " + strName.CleanXPath() + ']');
                                            }

                                            if (xmlArmorData == null)
                                            {
                                                astrOriginalNameSplit = strArmorName.Split(',',
                                                    StringSplitOptions.RemoveEmptyEntries);
                                                if (astrOriginalNameSplit.Length > 1)
                                                {
                                                    string strName = astrOriginalNameSplit[0].Trim();
                                                    xmlArmorData =
                                                        xmlArmorDocument.SelectSingleNode(
                                                            "/chummer/armors/armor[name = " +
                                                            strName.CleanXPath() + ']');
                                                }
                                            }
                                        }

                                        if (xmlArmorData != null)
                                        {
                                            Armor objArmor = new Armor(this);
                                            objArmor.Create(xmlArmorData,
                                                xmlArmorToImport.SelectSingleNode("@rating")?.ValueAsInt ?? 0,
                                                lstWeapons);
                                            objArmor.Notes = xmlArmorToImport.SelectSingleNode("description")?.Value;
                                            _lstArmor.Add(objArmor);

                                            foreach (string strName in HeroLabPluginNodeNames)
                                            {
                                                foreach (XPathNavigator xmlArmorModToImport in xmlArmorToImport.Select(
                                                    strName + "/item[@useradded != \"no\"]"))
                                                {
                                                    string strArmorModName =
                                                        xmlArmorModToImport.SelectSingleNode("@name")?.Value;
                                                    if (!string.IsNullOrEmpty(strArmorModName))
                                                    {
                                                        XmlNode xmlArmorModData =
                                                            xmlArmorDocument.SelectSingleNode(
                                                                "chummer/mods/mod[name = " +
                                                                strArmorModName.CleanXPath() +
                                                                "]");
                                                        if (xmlArmorModData != null)
                                                        {
                                                            ArmorMod objArmorMod = new ArmorMod(this);
                                                            objArmorMod.Create(xmlArmorModData,
                                                                xmlArmorModToImport.SelectSingleNode("@rating")
                                                                    ?.ValueAsInt ?? 0, lstWeapons);
                                                            objArmorMod.Notes = xmlArmorModToImport
                                                                .SelectSingleNode("description")?.Value;
                                                            objArmorMod.Parent = objArmor;
                                                            objArmor.ArmorMods.Add(objArmorMod);

                                                            foreach (string strPluginNodeName in HeroLabPluginNodeNames)
                                                            {
                                                                foreach (XPathNavigator xmlPluginToAdd in
                                                                    xmlArmorModToImport
                                                                        .Select(strPluginNodeName +
                                                                            "/item[@useradded != \"no\"]"))
                                                                {
                                                                    Gear objPlugin = new Gear(this);
                                                                    if (objPlugin.ImportHeroLabGear(xmlPluginToAdd,
                                                                        xmlArmorModData,
                                                                        lstWeapons))
                                                                        objArmorMod.GearChildren.Add(objPlugin);
                                                                }

                                                                foreach (XPathNavigator xmlPluginToAdd in
                                                                    xmlArmorModToImport
                                                                        .Select(strPluginNodeName +
                                                                            "/item[@useradded = \"no\"]"))
                                                                {
                                                                    string strGearName = xmlPluginToAdd
                                                                        .SelectSingleNode("@name")?.Value;
                                                                    if (!string.IsNullOrEmpty(strGearName))
                                                                    {
                                                                        Gear objPlugin =
                                                                            objArmorMod.GearChildren.FirstOrDefault(
                                                                                x =>
                                                                                    x.IncludedInParent &&
                                                                                    (x.Name.Contains(strGearName) ||
                                                                                        strGearName.Contains(x.Name)));
                                                                        if (objPlugin != null)
                                                                        {
                                                                            objPlugin.Quantity =
                                                                                xmlPluginToAdd
                                                                                    .SelectSingleNode("@quantity")
                                                                                    ?.ValueAsInt ?? 1;
                                                                            objPlugin.Notes = xmlPluginToAdd
                                                                                .SelectSingleNode("description")?.Value;
                                                                            objPlugin.ProcessHeroLabGearPlugins(
                                                                                xmlPluginToAdd, lstWeapons);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        else
                                                        {
                                                            Gear objPlugin = new Gear(this);
                                                            if (objPlugin.ImportHeroLabGear(xmlArmorModToImport,
                                                                xmlArmorData,
                                                                lstWeapons))
                                                                objArmor.GearChildren.Add(objPlugin);
                                                        }
                                                    }
                                                }

                                                foreach (XPathNavigator xmlArmorModToImport in xmlArmorToImport.Select(
                                                    strName + "/item[@useradded = \"no\"]"))
                                                {
                                                    string strArmorModName =
                                                        xmlArmorModToImport.SelectSingleNode("@name")?.Value;
                                                    if (!string.IsNullOrEmpty(strArmorModName))
                                                    {
                                                        ArmorMod objArmorMod = objArmor.ArmorMods.FirstOrDefault(x =>
                                                            x.IncludedInArmor &&
                                                            (x.Name.Contains(strArmorModName) ||
                                                             strArmorModName.Contains(x.Name)));
                                                        if (objArmorMod != null)
                                                        {
                                                            objArmorMod.Notes = xmlArmorModToImport
                                                                .SelectSingleNode("description")?.Value;
                                                            foreach (string strPluginNodeName in HeroLabPluginNodeNames)
                                                            {
                                                                foreach (XPathNavigator xmlPluginToAdd in
                                                                    xmlArmorModToImport
                                                                        .Select(strPluginNodeName +
                                                                            "/item[@useradded != \"no\"]"))
                                                                {
                                                                    Gear objPlugin = new Gear(this);
                                                                    if (objPlugin.ImportHeroLabGear(xmlPluginToAdd,
                                                                        objArmorMod.GetNode(), lstWeapons))
                                                                        objArmorMod.GearChildren.Add(objPlugin);
                                                                }

                                                                foreach (XPathNavigator xmlPluginToAdd in
                                                                    xmlArmorModToImport
                                                                        .Select(strPluginNodeName +
                                                                            "/item[@useradded = \"no\"]"))
                                                                {
                                                                    string strGearName = xmlPluginToAdd
                                                                        .SelectSingleNode("@name")?.Value;
                                                                    if (!string.IsNullOrEmpty(strGearName))
                                                                    {
                                                                        Gear objPlugin =
                                                                            objArmorMod.GearChildren.FirstOrDefault(
                                                                                x =>
                                                                                    x.IncludedInParent &&
                                                                                    (x.Name.Contains(strGearName) ||
                                                                                        strGearName.Contains(x.Name)));
                                                                        if (objPlugin != null)
                                                                        {
                                                                            objPlugin.Quantity =
                                                                                xmlPluginToAdd
                                                                                    .SelectSingleNode("@quantity")
                                                                                    ?.ValueAsInt ?? 1;
                                                                            objPlugin.Notes = xmlPluginToAdd
                                                                                .SelectSingleNode("description")?.Value;
                                                                            objPlugin.ProcessHeroLabGearPlugins(
                                                                                xmlPluginToAdd, lstWeapons);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        else
                                                        {
                                                            Gear objPlugin = objArmor.GearChildren.FirstOrDefault(x =>
                                                                x.IncludedInParent &&
                                                                (x.Name.Contains(strArmorModName) ||
                                                                 strArmorModName.Contains(x.Name)));
                                                            if (objPlugin != null)
                                                            {
                                                                objPlugin.Quantity = xmlArmorModToImport
                                                                    .SelectSingleNode("@quantity")?.ValueAsInt ?? 1;
                                                                objPlugin.Notes = xmlArmorModToImport
                                                                    .SelectSingleNode("description")?.Value;
                                                                objPlugin.ProcessHeroLabGearPlugins(xmlArmorModToImport,
                                                                    lstWeapons);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_armor");
                            }

                            using (_ = Timekeeper.StartSyncron("load_char_weapons", op_load))
                            {
                                // Weapons.
                                foreach (XPathNavigator xmlWeaponToImport in xmlStatBlockBaseNode.Select(
                                    "gear/weapons/item[@useradded != \"no\"]"))
                                {
                                    Weapon objWeapon = new Weapon(this);
                                    if (objWeapon.ImportHeroLabWeapon(xmlWeaponToImport, lstWeapons))
                                        _lstWeapons.Add(objWeapon);
                                }

                                foreach (XPathNavigator xmlPluginToAdd in xmlStatBlockBaseNode.Select(
                                    "gear/weapons/item[@useradded = \"no\"]"))
                                {
                                    string strName = xmlPluginToAdd.SelectSingleNode("@name")?.Value;
                                    if (!string.IsNullOrEmpty(strName))
                                    {
                                        Weapon objWeapon = _lstWeapons.FirstOrDefault(x =>
                                            !string.IsNullOrEmpty(x.ParentID) &&
                                            (x.Name.Contains(strName) || strName.Contains(x.Name)));
                                        if (objWeapon != null)
                                        {
                                            objWeapon.Notes = xmlPluginToAdd.SelectSingleNode("description")?.Value;
                                            objWeapon.ProcessHeroLabWeaponPlugins(xmlPluginToAdd, lstWeapons);
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_weapons");
                            }

                            using (_ = Timekeeper.StartSyncron("load_char_ware", op_load))
                            {
                                // Cyberware/Bioware.
                                foreach (XPathNavigator xmlCyberwareToImport in xmlStatBlockBaseNode.Select(
                                    "gear/augmentations/cyberware/item[@useradded != \"no\"]"))
                                {
                                    Cyberware objCyberware = new Cyberware(this);
                                    if (objCyberware.ImportHeroLabCyberware(xmlCyberwareToImport, null, lstWeapons,
                                        lstVehicles))
                                        _lstCyberware.Add(objCyberware);
                                    else
                                        objCyberware.Dispose();
                                }

                                foreach (XPathNavigator xmlPluginToAdd in xmlStatBlockBaseNode.Select(
                                    "gear/augmentations/cyberware/item[@useradded = \"no\"]"))
                                {
                                    string strName = xmlPluginToAdd.SelectSingleNode("@name")?.Value;
                                    if (!string.IsNullOrEmpty(strName))
                                    {
                                        Cyberware objPlugin = _lstCyberware.FirstOrDefault(x =>
                                            !string.IsNullOrEmpty(x.ParentID) &&
                                            (x.Name.Contains(strName) || strName.Contains(x.Name)));
                                        if (objPlugin != null)
                                        {
                                            objPlugin.Notes = xmlPluginToAdd.SelectSingleNode("description")?.Value;
                                            objPlugin.ProcessHeroLabCyberwarePlugins(xmlPluginToAdd, objPlugin.Grade,
                                                lstWeapons,
                                                lstVehicles);
                                        }
                                    }
                                }

                                foreach (XPathNavigator xmlCyberwareToImport in xmlStatBlockBaseNode.Select(
                                    "gear/augmentations/bioware/item[@useradded != \"no\"]"))
                                {
                                    Cyberware objCyberware = new Cyberware(this);
                                    if (objCyberware.ImportHeroLabCyberware(xmlCyberwareToImport, null, lstWeapons,
                                        lstVehicles))
                                        _lstCyberware.Add(objCyberware);
                                    else
                                        objCyberware.Dispose();
                                }

                                foreach (XPathNavigator xmlPluginToAdd in xmlStatBlockBaseNode.Select(
                                    "gear/augmentations/bioware/item[@useradded = \"no\"]"))
                                {
                                    string strName = xmlPluginToAdd.SelectSingleNode("@name")?.Value;
                                    if (!string.IsNullOrEmpty(strName))
                                    {
                                        Cyberware objPlugin = _lstCyberware.FirstOrDefault(x =>
                                            !string.IsNullOrEmpty(x.ParentID) &&
                                            (x.Name.Contains(strName) || strName.Contains(x.Name)));
                                        if (objPlugin != null)
                                        {
                                            objPlugin.Notes = xmlPluginToAdd.SelectSingleNode("description")?.Value;
                                            objPlugin.ProcessHeroLabCyberwarePlugins(xmlPluginToAdd, objPlugin.Grade,
                                                lstWeapons,
                                                lstVehicles);
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_ware");
                            }

                            XPathNodeIterator xmlNodeList;
                            using (_ = Timekeeper.StartSyncron("load_char_spells", op_load))
                            {
                                // Spells.
                                xmlNodeList = xmlStatBlockBaseNode.SelectAndCacheExpression("magic/spells/spell");
                                XmlDocument xmlSpellDocument = blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? LoadData("spells.xml")
                                    : await LoadDataAsync("spells.xml");
                                foreach (XPathNavigator xmlHeroLabSpell in xmlNodeList)
                                {
                                    string strSpellName = xmlHeroLabSpell.SelectSingleNode("@name")?.Value;
                                    if (!string.IsNullOrEmpty(strSpellName))
                                    {
                                        bool blnIsLimited =
                                            strSpellName.EndsWith(" (limited)", StringComparison.Ordinal);
                                        if (blnIsLimited)
                                            strSpellName = strSpellName.TrimEndOnce(" (limited)");
                                        string strForcedValue = string.Empty;
                                        switch (strSpellName)
                                        {
                                            case "Increase Body":
                                                strForcedValue = "BOD";
                                                strSpellName = "Increase [Attribute]";
                                                break;
                                            case "Increase Agility":
                                                strForcedValue = "AGI";
                                                strSpellName = "Increase [Attribute]";
                                                break;
                                            case "Increase Reaction":
                                                strForcedValue = "REA";
                                                strSpellName = "Increase [Attribute]";
                                                break;
                                            case "Increase Strength":
                                                strForcedValue = "STR";
                                                strSpellName = "Increase [Attribute]";
                                                break;
                                            case "Increase Charisma":
                                                strForcedValue = "CHA";
                                                strSpellName = "Increase [Attribute]";
                                                break;
                                            case "Increase Intuition":
                                                strForcedValue = "INT";
                                                strSpellName = "Increase [Attribute]";
                                                break;
                                            case "Increase Logic":
                                                strForcedValue = "LOG";
                                                strSpellName = "Increase [Attribute]";
                                                break;
                                            case "Increase Willpower":
                                                strForcedValue = "WIL";
                                                strSpellName = "Increase [Attribute]";
                                                break;
                                            case "Decrease Body":
                                                strForcedValue = "BOD";
                                                strSpellName = "Decrease [Attribute]";
                                                break;
                                            case "Decrease Agility":
                                                strForcedValue = "AGI";
                                                strSpellName = "Decrease [Attribute]";
                                                break;
                                            case "Decrease Reaction":
                                                strForcedValue = "REA";
                                                strSpellName = "Decrease [Attribute]";
                                                break;
                                            case "Decrease Strength":
                                                strForcedValue = "STR";
                                                strSpellName = "Decrease [Attribute]";
                                                break;
                                            case "Decrease Charisma":
                                                strForcedValue = "CHA";
                                                strSpellName = "Decrease [Attribute]";
                                                break;
                                            case "Decrease Intuition":
                                                strForcedValue = "INT";
                                                strSpellName = "Decrease [Attribute]";
                                                break;
                                            case "Decrease Logic":
                                                strForcedValue = "LOG";
                                                strSpellName = "Decrease [Attribute]";
                                                break;
                                            case "Decrease Willpower":
                                                strForcedValue = "WIL";
                                                strSpellName = "Decrease [Attribute]";
                                                break;
                                        }

                                        if (strSpellName.StartsWith("Detect ", StringComparison.Ordinal) &&
                                            strSpellName != "Detect Life" &&
                                            strSpellName != "Detect Life, Extended" &&
                                            strSpellName != "Detect Magic" &&
                                            strSpellName != "Detect Magic, Extended" &&
                                            strSpellName != "Detect Enemies" &&
                                            strSpellName != "Detect Enemies, Extended" &&
                                            strSpellName != "Detect Individual" &&
                                            strSpellName != "Detect Life, Extended")
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Clean ")
                                                .TrimEndOnce(", Extended");
                                            if (xmlHeroLabSpell.SelectSingleNode("@type")?.Value == "Physical")
                                                strSpellName = "Detect [Object]";
                                            else if (strSpellName.EndsWith(", Extended", StringComparison.Ordinal))
                                                strSpellName = "Detect [Life Form], Extended";
                                            else
                                                strSpellName = "Detect [Life Form]";
                                        }
                                        else if (strSpellName.StartsWith("Corrode ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Corrode ");
                                            strSpellName = "Corrode [Object]";
                                        }
                                        else if (strSpellName.StartsWith("Melt ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Melt ");
                                            strSpellName = "Melt [Object]";
                                        }
                                        else if (strSpellName.StartsWith("Sludge ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Sludge ");
                                            strSpellName = "Sludge [Object]";
                                        }
                                        else if (strSpellName.StartsWith("Disrupt ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Disrupt ");
                                            strSpellName = "Disrupt [Object]";
                                        }
                                        else if (strSpellName.StartsWith("Destroy ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Destroy ");
                                            strSpellName = xmlHeroLabSpell.SelectSingleNode("@type")?.Value ==
                                                           "Physical"
                                                ? "Destroy [Vehicle]"
                                                : "Destroy [Free Spirit]";
                                        }
                                        else if (strSpellName.StartsWith("Insecticide ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Insecticide ");
                                            strSpellName = "Insecticide [Insect Spirit]";
                                        }
                                        else if (strSpellName.StartsWith("One Less ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("One Less ");
                                            strSpellName = "One Less [Metatype/Species]";
                                        }
                                        else if (strSpellName.StartsWith("Slay ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Slay ");
                                            strSpellName = "Slay [Metatype/Species]";
                                        }
                                        else if (strSpellName.StartsWith("Slaughter ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Slaughter ");
                                            strSpellName = "Slaughter [Metatype/Species]";
                                        }
                                        else if (strSpellName.StartsWith("Ram ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Ram ");
                                            strSpellName = "Ram [Object]";
                                        }
                                        else if (strSpellName.StartsWith("Wreck ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Wreck ");
                                            strSpellName = "Wreck [Object]";
                                        }
                                        else if (strSpellName.StartsWith("Demolish ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Demolish ");
                                            strSpellName = "Demolish [Object]";
                                        }
                                        else if (strSpellName.EndsWith(" Cryptesthesia", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimEndOnce(" Cryptesthesia");
                                            strSpellName = "[Sense] Cryptesthesia";
                                        }
                                        else if (strSpellName.EndsWith(" Removal", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Mass ")
                                                .TrimEndOnce(" Removal");
                                            strSpellName = strSpellName.StartsWith("Mass ", StringComparison.Ordinal)
                                                ? "Mass [Sense] Removal"
                                                : "[Sense] Removal";
                                        }
                                        else if (strSpellName.StartsWith("Alleviate ", StringComparison.Ordinal) &&
                                                 strSpellName != "Alleviate Addiction")
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Alleviate ");
                                            strSpellName = "Alleviate [Allergy]";
                                        }
                                        else if (strSpellName.StartsWith("Clean ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Clean ");
                                            strSpellName = "Clean [Element]";
                                        }
                                        else if (strSpellName.EndsWith(" Grenade", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimEndOnce(" Grenade");
                                            strSpellName = "[Element] Grenade";
                                        }
                                        else if (strSpellName.EndsWith(" Aura", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimEndOnce(" Aura");
                                            strSpellName = "[Element] Aura";
                                        }
                                        else if (strSpellName != "Napalm Wall" &&
                                                 strSpellName.EndsWith(" Wall", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimEndOnce(" Wall");
                                            strSpellName = "[Element] Wall";
                                        }
                                        else if (strSpellName.StartsWith("Shape ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Shape ");
                                            strSpellName = "Shape [Material]";
                                        }
                                        else if (strSpellName.EndsWith(" Form", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimEndOnce(" Form");
                                            strSpellName = "[Critter] Form";
                                        }
                                        else if (strSpellName.StartsWith("Calling ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Calling ");
                                            strSpellName = "Calling [Spirit Type]";
                                        }
                                        else if (strSpellName != "Symbolic Link" &&
                                                 strSpellName.EndsWith(" Link", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimEndOnce(" Link");
                                            strSpellName = "[Sense] Link";
                                        }

                                        string strSpellCategory = xmlHeroLabSpell.SelectSingleNode("@category")?.Value;
                                        XmlNode xmlSpellData = xmlSpellDocument.SelectSingleNode(
                                            "chummer/spells/spell[category = " + strSpellCategory.CleanXPath() +
                                            " and name = " + strSpellName.CleanXPath() + ']');
                                        if (xmlSpellData == null)
                                        {
                                            string[] astrOriginalNameSplit =
                                                strSpellName.Split(':', StringSplitOptions.RemoveEmptyEntries);
                                            if (astrOriginalNameSplit.Length > 1)
                                            {
                                                string strName = astrOriginalNameSplit[0].Trim();
                                                xmlSpellData = xmlSpellDocument.SelectSingleNode(
                                                    "/chummer/spells/spell[category = " +
                                                    strSpellCategory.CleanXPath() +
                                                    " and name = " + strName.CleanXPath() + ']');
                                            }

                                            if (xmlSpellData == null)
                                            {
                                                astrOriginalNameSplit = strSpellName.Split(',',
                                                    StringSplitOptions.RemoveEmptyEntries);
                                                if (astrOriginalNameSplit.Length > 1)
                                                {
                                                    string strName = astrOriginalNameSplit[0].Trim();
                                                    xmlSpellData = xmlSpellDocument.SelectSingleNode(
                                                        "/chummer/spells/spell[category = " +
                                                        strSpellCategory.CleanXPath() + " and name = " +
                                                        strName.CleanXPath() + ']');
                                                }
                                            }
                                        }

                                        if (xmlSpellData != null)
                                        {
                                            Spell objSpell = new Spell(this);
                                            objSpell.Create(xmlSpellData, strForcedValue, blnIsLimited);
                                            objSpell.Notes = xmlHeroLabSpell.SelectSingleNode("description")?.Value;
                                            _lstSpells.Add(objSpell);
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_spells");
                            }

                            using (CustomActivity _ = Timekeeper.StartSyncron("load_char_powers", op_load))
                            {
                                // Powers.
                                xmlNodeList = xmlStatBlockBaseNode.SelectAndCacheExpression("magic/adeptpowers/adeptpower");
                                XmlDocument xmlPowersDocument = blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? LoadData("powers.xml")
                                    : await LoadDataAsync("powers.xml");
                                foreach (XPathNavigator xmlHeroLabPower in xmlNodeList)
                                {
                                    string strPowerName = xmlHeroLabPower.SelectSingleNode("@name")?.Value;
                                    if (!string.IsNullOrEmpty(strPowerName))
                                    {
                                        int intRating = 1;
                                        string strForcedValue = string.Empty;
                                        XmlNode xmlPowerData =
                                            xmlPowersDocument.SelectSingleNode(
                                                "chummer/powers/power[contains(name, " + strPowerName.CleanXPath() +
                                                ")]");
                                        if (xmlPowerData == null)
                                        {
                                            string[] astrOriginalNameSplit =
                                                strPowerName.Split(':', StringSplitOptions.RemoveEmptyEntries);
                                            if (astrOriginalNameSplit.Length > 1)
                                            {
                                                string strName = astrOriginalNameSplit[0].Trim();
                                                xmlPowerData =
                                                    xmlPowersDocument.SelectSingleNode(
                                                        "/chummer/powers/power[contains(name, " + strName.CleanXPath() +
                                                        ")]");

                                                strForcedValue = astrOriginalNameSplit[1].Trim();
                                                int intForcedValueParenthesesStart = strForcedValue.IndexOf('(');
                                                if (intForcedValueParenthesesStart != -1)
                                                    strForcedValue =
                                                        strForcedValue.Substring(0, intForcedValueParenthesesStart);
                                            }

                                            if (xmlPowerData == null)
                                            {
                                                astrOriginalNameSplit = strPowerName.Split('(',
                                                    StringSplitOptions.RemoveEmptyEntries);
                                                if (astrOriginalNameSplit.Length > 1)
                                                {
                                                    string strName = astrOriginalNameSplit[0].Trim();
                                                    xmlPowerData =
                                                        xmlPowersDocument.SelectSingleNode(
                                                            "/chummer/powers/power[contains(name, " +
                                                            strName.CleanXPath() +
                                                            ")]");

                                                    string strSecondPart = astrOriginalNameSplit[1].Trim();
                                                    int intSecondPartParenthesesEnd = strSecondPart.IndexOf(')');
                                                    if (intSecondPartParenthesesEnd != -1
                                                        && !int.TryParse(
                                                            strSecondPart.Substring(0, intSecondPartParenthesesEnd),
                                                            out intRating))
                                                        intRating = 1;

                                                    astrOriginalNameSplit = strSecondPart.Split(':',
                                                        StringSplitOptions.RemoveEmptyEntries);
                                                    if (astrOriginalNameSplit.Length >= 2)
                                                    {
                                                        strForcedValue = astrOriginalNameSplit[1].Trim();
                                                        int intForcedValueParenthesesStart =
                                                            strForcedValue.IndexOf('(');
                                                        if (intForcedValueParenthesesStart != -1)
                                                            strForcedValue =
                                                                strForcedValue.Substring(0,
                                                                    intForcedValueParenthesesStart);
                                                    }
                                                }
                                            }
                                        }

                                        if (xmlPowerData != null)
                                        {
                                            Power objPower = new Power(this) {Extra = strForcedValue};
                                            objPower.Create(xmlPowerData, intRating);
                                            objPower.Notes = xmlHeroLabPower.SelectSingleNode("description")?.Value;
                                            _lstPowers.Add(objPower);
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_powers");
                            }

                            /* TODO: Spirit/Sprite Importing
                            Timekeeper.Start("load_char_spirits");
        
                            // Spirits/Sprites.
                            foreach (XPathNavigator xmlSpirit in xmlCharacterNavigator.SelectAndCacheExpression("spirits/spirit"))
                            {
                                Spirit objSpirit = new Spirit(this);
                                objSpirit.Load(xmlSpirit);
                                _lstSpirits.Add(objSpirit);
                            }
        
                            Timekeeper.Finish("load_char_spirits");
                            */
                            using (_ = Timekeeper.StartSyncron("load_char_complex", op_load))
                            {
                                // Complex Forms/Technomancer Programs.
                                string strComplexFormsLine =
                                    lstTextStatBlockLines?.FirstOrDefault(x =>
                                        x.StartsWith("Complex Forms:", StringComparison.Ordinal));
                                if (!string.IsNullOrEmpty(strComplexFormsLine))
                                {
                                    XmlDocument xmlComplexFormsDocument = blnSync
                                        // ReSharper disable once MethodHasAsyncOverload
                                        ? LoadData("complexforms.xml")
                                        : await LoadDataAsync("complexforms.xml");

                                    string[] astrComplexForms =
                                        strComplexFormsLine.TrimStartOnce("Complex Forms:").Trim()
                                            .Split(',', StringSplitOptions.RemoveEmptyEntries);
                                    foreach (string strComplexFormEntry in astrComplexForms)
                                    {
                                        string strComplexFormName = strComplexFormEntry.Trim();
                                        string strForcedValue = string.Empty;
                                        switch (strComplexFormName)
                                        {
                                            case "Diffusion of Attack":
                                                strComplexFormName = "Diffusion of [Matrix Attribute]";
                                                strForcedValue = "Attack";
                                                break;
                                            case "Diffusion of Sleaze":
                                                strComplexFormName = "Diffusion of [Matrix Attribute]";
                                                strForcedValue = "Sleaze";
                                                break;
                                            case "Diffusion of Data Processing":
                                                strComplexFormName = "Diffusion of [Matrix Attribute]";
                                                strForcedValue = "Data Processing";
                                                break;
                                            case "Diffusion of Firewall":
                                                strComplexFormName = "Diffusion of [Matrix Attribute]";
                                                strForcedValue = "Firewall";
                                                break;
                                            case "Infusion of Attack":
                                                strComplexFormName = "Infusion of [Matrix Attribute]";
                                                strForcedValue = "Attack";
                                                break;
                                            case "Infusion of Sleaze":
                                                strComplexFormName = "Infusion of [Matrix Attribute]";
                                                strForcedValue = "Sleaze";
                                                break;
                                            case "Infusion of Data Processing":
                                                strComplexFormName = "Infusion of [Matrix Attribute]";
                                                strForcedValue = "Data Processing";
                                                break;
                                            case "Infusion of Firewall":
                                                strComplexFormName = "Infusion of [Matrix Attribute]";
                                                strForcedValue = "Firewall";
                                                break;
                                        }

                                        XmlNode xmlComplexFormData =
                                            xmlComplexFormsDocument.SelectSingleNode(
                                                "chummer/complexforms/complexform[name = " +
                                                strComplexFormName.CleanXPath() + ']');
                                        if (xmlComplexFormData == null)
                                        {
                                            string[] astrOriginalNameSplit =
                                                strComplexFormName.Split(':', StringSplitOptions.RemoveEmptyEntries);
                                            if (astrOriginalNameSplit.Length > 1)
                                            {
                                                string strName = astrOriginalNameSplit[0].Trim();
                                                xmlComplexFormData =
                                                    xmlComplexFormsDocument.SelectSingleNode(
                                                        "/chummer/complexforms/complexform[name = " +
                                                        strName.CleanXPath() +
                                                        "]");
                                            }

                                            if (xmlComplexFormData == null)
                                            {
                                                astrOriginalNameSplit = strComplexFormName.Split(',',
                                                    StringSplitOptions.RemoveEmptyEntries);
                                                if (astrOriginalNameSplit.Length > 1)
                                                {
                                                    string strName = astrOriginalNameSplit[0].Trim();
                                                    xmlComplexFormData =
                                                        xmlComplexFormsDocument.SelectSingleNode(
                                                            "/chummer/complexforms/complexform[name = " +
                                                            strName.CleanXPath() + ']');
                                                }
                                            }
                                        }

                                        if (xmlComplexFormData != null)
                                        {
                                            ComplexForm objComplexForm = new ComplexForm(this);
                                            objComplexForm.Create(xmlComplexFormData, strForcedValue);
                                            _lstComplexForms.Add(objComplexForm);
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_complex");
                            }

                            /* TODO: AI Advanced Program Importing
                            Timekeeper.Start("load_char_aiprogram");
        
                            // AI Advanced Programs.
                            objXmlNodeList = objXmlCharacter.SelectNodes("aiprograms/aiprogram");
                            foreach (XmlNode xmlHeroLabProgram in xmlNodeList)
                            {
                                AIProgram objProgram = new AIProgram(this);
                                objProgram.Load(xmlHeroLabProgram);
                                _lstAIPrograms.Add(objProgram);
                            }
        
                            Timekeeper.Finish("load_char_aiprogram");
                            */
                            /* TODO: Martial Arts import, which are saved in TXT and HTML statblocks but not in XML statblock
                            Timekeeper.Start("load_char_marts");
        
                            // Martial Arts.
                            xmlNodeList = objXmlCharacter.SelectNodes("martialarts/martialart");
                            foreach (XmlNode xmlHeroLabArt in xmlNodeList)
                            {
                                MartialArt objMartialArt = new MartialArt(this);
                                objMartialArt.Load(xmlHeroLabArt);
                                _lstMartialArts.Add(objMartialArt);
                            }
        
                            Timekeeper.Finish("load_char_marts");
                            */
                            using (_ = Timekeeper.StartSyncron("load_char_lifestyle", op_load))
                            {
                                // Lifestyles.
                                XmlNode xmlFakeSINDataNode =
                                    xmlGearDocument.SelectSingleNode("/chummer/gears/gear[name = 'Fake SIN']");
                                XmlNode xmlFakeLicenseDataNode =
                                    xmlGearDocument.SelectSingleNode("/chummer/gears/gear[name = 'Fake License']");
                                xmlNodeList = xmlStatBlockBaseNode.SelectAndCacheExpression("identities/identity");
                                foreach (XPathNavigator xmlHeroLabIdentity in xmlNodeList)
                                {
                                    string strIdentityName = xmlHeroLabIdentity.SelectSingleNode("@name")?.Value;
                                    int intIdentityNameParenthesesStart = strIdentityName.IndexOf('(');
                                    if (intIdentityNameParenthesesStart != -1)
                                        strIdentityName = strIdentityName.Substring(0, intIdentityNameParenthesesStart);
                                    XPathNavigator xmlHeroLabFakeSINNode =
                                        xmlHeroLabIdentity.SelectSingleNode("license[@name = \"Fake SIN\"]");
                                    if (xmlHeroLabFakeSINNode != null)
                                    {
                                        Gear objFakeSIN = new Gear(this);
                                        objFakeSIN.Create(xmlFakeSINDataNode,
                                            xmlHeroLabFakeSINNode.SelectSingleNode("@rating")?.ValueAsInt ?? 1,
                                            lstWeapons,
                                            strIdentityName);
                                        foreach (XPathNavigator xmlHeroLabFakeLicenseNode in xmlHeroLabIdentity.Select(
                                            "license[@name = \"Fake License\"]"))
                                        {
                                            Gear objFakeLicense = new Gear(this);
                                            objFakeLicense.Create(xmlFakeLicenseDataNode,
                                                xmlHeroLabFakeLicenseNode.SelectSingleNode("@rating")?.ValueAsInt ?? 1,
                                                lstWeapons,
                                                xmlHeroLabFakeLicenseNode.SelectSingleNode("@for")?.Value);
                                            objFakeLicense.Parent = objFakeSIN;
                                            objFakeSIN.Children.Add(objFakeLicense);
                                        }

                                        _lstGear.Add(objFakeSIN);
                                    }

                                    XPathNavigator xmlHeroLabLifestyleNode =
                                        xmlHeroLabIdentity.SelectSingleNode("lifestyle");
                                    if (xmlHeroLabLifestyleNode != null)
                                    {
                                        string strLifestyleType = xmlHeroLabLifestyleNode.SelectSingleNode("@name")
                                            ?.Value
                                            .TrimEndOnce(" Lifestyle");

                                        XmlNode xmlLifestyleDataNode =
                                            (blnSync
                                                // ReSharper disable once MethodHasAsyncOverload
                                                ? LoadData("lifestyles.xml")
                                                : await LoadDataAsync("lifestyles.xml"))
                                            .SelectSingleNode("/chummer/lifestyles/lifestyle[name = " +
                                                              strLifestyleType.CleanXPath() + ']');

                                        if (xmlLifestyleDataNode != null)
                                        {
                                            Lifestyle objLifestyle = new Lifestyle(this);
                                            objLifestyle.Create(xmlLifestyleDataNode);
                                            if (int.TryParse(xmlHeroLabLifestyleNode.SelectSingleNode("@months")?.Value,
                                                out int intMonths))
                                            {
                                                objLifestyle.Increments = intMonths;
                                            }

                                            _lstLifestyles.Add(objLifestyle);
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_lifestyle");
                            }

                            using (_ = Timekeeper.StartSyncron("load_char_gear", op_load))
                            {
                                // <gears>
                                foreach (XPathNavigator xmlGearToImport in xmlStatBlockBaseNode.Select(
                                    "gear/equipment/item[@useradded != \"no\"]"))
                                {
                                    Gear objGear = new Gear(this);
                                    if (objGear.ImportHeroLabGear(xmlGearToImport, null, lstWeapons))
                                        _lstGear.Add(objGear);
                                }

                                foreach (XPathNavigator xmlPluginToAdd in xmlStatBlockBaseNode.Select(
                                    "gear/equipment/item[@useradded = \"no\"]"))
                                {
                                    string strName = xmlPluginToAdd.SelectSingleNode("@name")?.Value;
                                    if (!string.IsNullOrEmpty(strName))
                                    {
                                        Gear objPlugin = _lstGear.FirstOrDefault(x =>
                                            x.IncludedInParent &&
                                            (x.Name.Contains(strName) || strName.Contains(x.Name)));
                                        if (objPlugin != null)
                                        {
                                            objPlugin.Quantity =
                                                Convert.ToDecimal(
                                                    xmlPluginToAdd.SelectSingleNode("@quantity")?.Value ?? "1",
                                                    GlobalSettings.InvariantCultureInfo);
                                            objPlugin.Notes = xmlPluginToAdd.SelectSingleNode("description")?.Value;
                                            objPlugin.ProcessHeroLabGearPlugins(xmlPluginToAdd, lstWeapons);
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_gear");
                            }

                            using (_ = Timekeeper.StartSyncron("load_char_car", op_load))
                            {
                                foreach (Vehicle objVehicle in lstVehicles)
                                {
                                    _lstVehicles.Add(objVehicle);
                                }

                                /* TODO: Process HeroLab Vehicles entries, which are present in HTML and TXT statblocks but not in XML
                                // Vehicles.
                                xmlNodeList = objXmlCharacter.SelectNodes("vehicles/vehicle");
                                foreach (XmlNode xmlHeroLabVehicle in xmlNodeList)
                                {
                                    Vehicle objVehicle = new Vehicle(this);
                                    objVehicle.Load(xmlHeroLabVehicle);
                                    _lstVehicles.Add(objVehicle);
                                }
                                */
                                //Timekeeper.Finish("load_char_car");
                            }

                            /* TODO: Process HeroLab Initiation/Submersion and related entries
                            Timekeeper.Start("load_char_mmagic");
                            // Metamagics/Echoes.
                            xmlNodeList = objXmlCharacter.SelectNodes("metamagics/metamagic");
                            foreach (XmlNode xmlHeroLabMetamagic in xmlNodeList)
                            {
                                Metamagic objMetamagic = new Metamagic(this);
                                objMetamagic.Load(xmlHeroLabMetamagic);
                                _lstMetamagics.Add(objMetamagic);
                            }
        
                            Timekeeper.Finish("load_char_mmagic");
                            Timekeeper.Start("load_char_arts");
        
                            // Arts
                            xmlNodeList = objXmlCharacter.SelectNodes("arts/art");
                            foreach (XmlNode xmlHeroLabArt in xmlNodeList)
                            {
                                Art objArt = new Art(this);
                                objArt.Load(xmlHeroLabArt);
                                _lstArts.Add(objArt);
                            }
        
                            Timekeeper.Finish("load_char_arts");
                            Timekeeper.Start("load_char_ench");
        
                            // Enhancements
                            xmlNodeList = objXmlCharacter.SelectNodes("enhancements/enhancement");
                            foreach (XmlNode xmlHeroLabEnhancement in objXmlNodeList)
                            {
                                Enhancement objEnhancement = new Enhancement(this);
                                objEnhancement.Load(xmlHeroLabEnhancement);
                                _lstEnhancements.Add(objEnhancement);
                            }
        
                            Timekeeper.Finish("load_char_ench");
                            Timekeeper.Start("load_char_cpow");
        
                            // Critter Powers.
                            xmlNodeList = objXmlCharacter.SelectNodes("critterpowers/critterpower");
                            foreach (XmlNode xmlHeroLabPower in xmlNodeList)
                            {
                                CritterPower objPower = new CritterPower(this);
                                objPower.Load(xmlHeroLabPower);
                                _lstCritterPowers.Add(objPower);
                            }
        
                            Timekeeper.Finish("load_char_cpow");
                            Timekeeper.Start("load_char_foci");
        
                            // Foci.
                            xmlNodeList = objXmlCharacter.SelectNodes("foci/focus");
                            foreach (XmlNode xmlHeroLabFocus in xmlNodeList)
                            {
                                Focus objFocus = new Focus(this);
                                objFocus.Load(xmlHeroLabFocus);
                                _lstFoci.Add(objFocus);
                            }
        
                            Timekeeper.Finish("load_char_foci");
                            Timekeeper.Start("load_char_init");
        
                            // Initiation Grades.
                            xmlNodeList = objXmlCharacter.SelectNodes("initiationgrades/initiationgrade");
                            foreach (XmlNode xmlHeroLabGrade in xmlNodeList)
                            {
                                InitiationGrade objGrade = new InitiationGrade(this);
                                objGrade.Load(xmlHeroLabGrade);
                                _lstInitiationGrades.Add(objGrade);
                            }
        
                            Timekeeper.Finish("load_char_init");
                            */
                            /* TODO: Import HeroLab Expense Logs, which are different from Journal entries
                            Timekeeper.Start("load_char_elog");
        
                            // Expense Log Entries.
                            XmlNodeList xmlExpenseList = objXmlCharacter.SelectNodes("expenses/expense");
                            foreach (XmlNode xmlHeroLabExpense in xmlExpenseList)
                            {
                                ExpenseLogEntry objExpenseLogEntry = new ExpenseLogEntry(this);
                                objExpenseLogEntry.Load(xmlHeroLabExpense);
                                _lstExpenseLog.Add(objExpenseLogEntry);
                            }
        
                            Timekeeper.Finish("load_char_elog");
                            */
                            _lstWeapons.AddRange(lstWeapons);

                            using (_ = Timekeeper.StartSyncron("load_char_unarmed", op_load))
                            {
                                // Look for the unarmed attack
                                bool blnFoundUnarmed = false;
                                foreach (Weapon objWeapon in _lstWeapons)
                                {
                                    if (objWeapon.Name == "Unarmed Attack")
                                    {
                                        blnFoundUnarmed = true;
                                        break;
                                    }
                                }

                                if (!blnFoundUnarmed)
                                {
                                    // Add the Unarmed Attack Weapon to the character.
                                    XmlDocument objXmlWeaponDoc = blnSync
                                        // ReSharper disable once MethodHasAsyncOverload
                                        ? LoadData("weapons.xml")
                                        : await LoadDataAsync("weapons.xml");
                                    XmlNode objXmlWeapon =
                                        objXmlWeaponDoc.SelectSingleNode(
                                            "/chummer/weapons/weapon[name = \"Unarmed Attack\"]");
                                    if (objXmlWeapon != null)
                                    {
                                        Weapon objWeapon = new Weapon(this);
                                        objWeapon.Create(objXmlWeapon, _lstWeapons);
                                        objWeapon.IncludedInWeapon = true; // Unarmed attack can never be removed
                                        _lstWeapons.Add(objWeapon);
                                    }
                                }

                                //Timekeeper.Finish("load_char_unarmed");
                            }
                        }
                        finally
                        {
                            IsLoading = false;
                        }

                        // Refresh certain improvements
                        using (_ = Timekeeper.StartSyncron("load_char_improvementrefreshers2", op_load))
                        {
                            // Refresh Black Market discounts
                            RefreshBlackMarketDiscounts();
                            // Refresh Dealer Connection discounts
                            RefreshDealerConnectionDiscounts();
                            // Refresh permanent attribute changes due to essence loss
                            RefreshEssenceLossImprovements();
                            // Refresh dicepool modifiers due to filled condition monitor boxes
                            RefreshWoundPenalties();
                            // Refresh encumbrance penalties
                            RefreshEncumbrance();
                            // Curb Mystic Adept power points if the values that were loaded in would be illegal
                            if (MysticAdeptPowerPoints > 0)
                            {
                                int intMAGTotalValue = MAG.TotalValue;
                                if (MysticAdeptPowerPoints > intMAGTotalValue)
                                    MysticAdeptPowerPoints = intMAGTotalValue;
                            }

                            if (!InitiationEnabled || !AddInitiationsAllowed)
                                ClearInitiations();
                            //Timekeeper.Finish("load_char_improvementrefreshers");
                        }
                    }
                    catch (Exception e)
                    {
                        op_load.SetSuccess(false);
                        TelemetryClient.TrackException(e);
                        Log.Error(e);
                    }
                }
                return true;
            }
            finally
            {
                IsLoadMethodRunning = false;
            }
        }
        #endregion

        #region Karma Values
        private int _intCachedPositiveQualities = int.MinValue;
        /// <summary>
        /// Total value of positive qualities that count towards the maximum quality limit in create mode.
        /// </summary>
        public int PositiveQualityKarma
        {
            get
            {
                if (_intCachedPositiveQualities == int.MinValue)
                {
                    _intCachedPositiveQualities = Qualities
                        .Where(objQuality => objQuality.Type == QualityType.Positive && objQuality.ContributeToBP && objQuality.ContributeToLimit)
                        .Sum(objQuality   => objQuality.BP) * Settings.KarmaQuality;
                    // Group contacts are counted as positive qualities
                    _intCachedPositiveQualities += Contacts
                        .Where(x => x.EntityType == ContactType.Contact && x.IsGroup && !x.Free)
                        .Sum(x => x.ContactPoints) * Settings.KarmaContact;

                    // Deduct the amount for free Qualities.
                    _intCachedPositiveQualities -=
                        (ImprovementManager.ValueOf(this, Improvement.ImprovementType.FreePositiveQualities) * Settings.KarmaQuality).StandardRound();

                    // If the character is allowed to take as many Positive Qualities as they'd like but all costs in excess are doubled, add the excess to their point cost.
                    if (Settings.ExceedPositiveQualitiesCostDoubled)
                    {
                        int intPositiveQualityExcess = _intCachedPositiveQualities - Settings.QualityKarmaLimit;
                        if (intPositiveQualityExcess > 0)
                        {
                            _intCachedPositiveQualities += intPositiveQualityExcess;
                        }
                    }
                }
                return _intCachedPositiveQualities;
            }
        }
        private int _intCachedPositiveQualitiesTotal = int.MinValue;
        /// <summary>
        /// Total value of ALL positive qualities, including those that don't contribute to the quality limit during character creation.
        /// </summary>
        public int PositiveQualityKarmaTotal
        {
            get
            {
                if (_intCachedPositiveQualitiesTotal == int.MinValue)
                {
                    // Qualities that count towards the Quality Limit are checked first to support the house rule allowing doubling of qualities over said limit.
                    _intCachedPositiveQualitiesTotal = Qualities
                                                      .Where(objQuality => objQuality.Type == QualityType.Positive && objQuality.ContributeToBP && objQuality.ContributeToLimit)
                                                      .Sum(objQuality => objQuality.BP) * Settings.KarmaQuality;
                    // Group contacts are counted as positive qualities
                    _intCachedPositiveQualitiesTotal += Contacts
                        .Where(x => x.EntityType == ContactType.Contact && x.IsGroup && !x.Free)
                        .Sum(x => x.ContactPoints) * Settings.KarmaContact;

                    // Deduct the amount for free Qualities.
                    _intCachedPositiveQualitiesTotal -=
                        (ImprovementManager.ValueOf(this, Improvement.ImprovementType.FreePositiveQualities) * Settings.KarmaQuality).StandardRound();

                    // Factor in any qualities that can be bought with spell points at the end, but before doubled karma costs are calculated.
                    int intMasteryQualityKarmaUsed = Qualities.Where(objQuality => objQuality.CanBuyWithSpellPoints)
                                                              .Sum(objQuality => objQuality.BP);
                    if (intMasteryQualityKarmaUsed != 0)
                    {
                        // Each spell costs KarmaSpell.
                        int spellCost = SpellKarmaCost("Spells");
                        // It is only karma-efficient to use spell points for Mastery qualities if real spell karma cost is not greater than unmodified spell karma cost
                        if (spellCost <= Settings.KarmaSpell && FreeSpells > 0)
                        {
                            // Assume that every [spell cost] karma spent on a Mastery quality is paid for with a priority-given spell point instead, as that is the most karma-efficient.
                            int intQualityKarmaToSpellPoints = Settings.KarmaSpell;
                            if (Settings.KarmaSpell != 0)
                                intQualityKarmaToSpellPoints
                                    = Math.Min(FreeSpells,
                                               (intMasteryQualityKarmaUsed * Settings.KarmaQuality)
                                               / Settings.KarmaSpell);
                            // Add the karma paid for by spell points back into the available karma pool.
                            _intCachedPositiveQualities -= intQualityKarmaToSpellPoints * Settings.KarmaSpell;
                        }
                    }

                    // If the character is allowed to take as many Positive Qualities as they'd like but all costs in excess are doubled, add the excess to their point cost.
                    if (Settings.ExceedPositiveQualitiesCostDoubled)
                    {
                        int intPositiveQualityExcess = _intCachedPositiveQualitiesTotal - Settings.QualityKarmaLimit;
                        if (intPositiveQualityExcess > 0)
                        {
                            _intCachedPositiveQualitiesTotal += intPositiveQualityExcess;
                        }
                    }
                    // Qualities that don't count towards the cap are added afterwards.
                    _intCachedPositiveQualitiesTotal += Qualities
                                                           .Where(objQuality => objQuality.Type == QualityType.Positive && objQuality.ContributeToBP && !objQuality.ContributeToLimit)
                                                           .Sum(objQuality => objQuality.BP) * Settings.KarmaQuality;
                }
                return _intCachedPositiveQualitiesTotal;
            }
        }

        public string DisplayPositiveQualityKarma
        {
            get
            {
                if (PositiveQualityKarma != PositiveQualityKarmaTotal)
                {
                    return string.Format(GlobalSettings.CultureInfo, "{0}{2}/{2}{1}{2}({3}){2}{4}",
                        PositiveQualityKarma,
                        Settings.QualityKarmaLimit,
                        LanguageManager.GetString("String_Space"),
                        PositiveQualityKarmaTotal,
                        LanguageManager.GetString("String_Karma"));
                }
                return string.Format(GlobalSettings.CultureInfo, "{0}/{1}{2}{3}",
                    PositiveQualityKarma,
                    Settings.QualityKarmaLimit,
                    LanguageManager.GetString("String_Space"),
                    LanguageManager.GetString("String_Karma"));
            }
        }

        private int _intCachedNegativeQualities = int.MinValue;
        public int NegativeQualityKarma
        {
            get
            {
                if (_intCachedNegativeQualities == int.MinValue)
                {
                    _intCachedNegativeQualities = Qualities
                        .Where(objQuality => objQuality.Type == QualityType.Negative && objQuality.ContributeToBP)
                        .Sum(objQuality   => objQuality.BP) * Settings.KarmaQuality;
                    // Group contacts are counted as positive qualities
                    _intCachedNegativeQualities += EnemyKarma;

                    // Deduct the amount for free Qualities.
                    _intCachedNegativeQualities -=
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.FreeNegativeQualities).StandardRound();

                    // If the character is only allowed to gain 25 BP from Negative Qualities but allowed to take as many as they'd like, limit their refunded points.
                    if (Settings.ExceedNegativeQualitiesLimit)
                    {
                        int intNegativeQualityLimit = -Settings.QualityKarmaLimit;
                        if (_intCachedNegativeQualities < intNegativeQualityLimit)
                        {
                            _intCachedNegativeQualities = intNegativeQualityLimit;
                        }
                    }

                    _intCachedNegativeQualities *= -1;
                }

                return _intCachedNegativeQualities;
            }
        }

        private int _intCachedNegativeQualityLimitKarma = int.MinValue;
        /// <summary>
        /// Negative qualities that contribute to the character's Quality Limit during character creation.
        /// </summary>
        public int NegativeQualityLimitKarma
        {
            get
            {
                if (_intCachedNegativeQualityLimitKarma == int.MinValue)
                {
                    _intCachedNegativeQualityLimitKarma = Qualities
                                                      .Where(objQuality => objQuality.Type == QualityType.Negative && objQuality.ContributeToLimit)
                                                      .Sum(objQuality => objQuality.BP) * Settings.KarmaQuality;
                    // Group contacts are counted as positive qualities
                    if (Settings.EnemyKarmaQualityLimit)
                        _intCachedNegativeQualityLimitKarma += EnemyKarma;

                    // Deduct the amount for free Qualities.
                    _intCachedNegativeQualityLimitKarma -=
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.FreeNegativeQualities).StandardRound();

                    // If the character is only allowed to gain 25 BP from Negative Qualities but allowed to take as many as they'd like, limit their refunded points.
                    if (Settings.ExceedNegativeQualitiesLimit)
                    {
                        int intNegativeQualityLimit = -Settings.QualityKarmaLimit;
                        if (_intCachedNegativeQualityLimitKarma < intNegativeQualityLimit)
                        {
                            _intCachedNegativeQualityLimitKarma = intNegativeQualityLimit;
                        }
                    }
                    _intCachedNegativeQualityLimitKarma *= -1;
                }

                return _intCachedNegativeQualityLimitKarma;
            }
        }

        public string DisplayNegativeQualityKarma
        {
            get
            {
                if (NegativeQualityLimitKarma != NegativeQualityKarma)
                {
                    return string.Format(GlobalSettings.CultureInfo, "{0}{2}/{2}{1}{2}({3}){2}{4}",
                        NegativeQualityLimitKarma,
                        Settings.QualityKarmaLimit,
                        LanguageManager.GetString("String_Space"),
                        NegativeQualityKarma,
                        LanguageManager.GetString("String_Karma"));
                }
                return string.Format(GlobalSettings.CultureInfo, "{0}/{1}{2}{3}",
                    NegativeQualityKarma,
                    Settings.QualityKarmaLimit,
                    LanguageManager.GetString("String_Space"),
                    LanguageManager.GetString("String_Karma"));
            }
        }

        private int _intCachedMetagenicPositiveQualities = int.MinValue;

        public int MetagenicPositiveQualityKarma
        {
            get
            {
                if (_intCachedMetagenicPositiveQualities == int.MinValue)
                {
                    _intCachedMetagenicPositiveQualities = Qualities
                        .Where(objQuality =>
                            objQuality.Type == QualityType.Positive && objQuality.ContributeToMetagenicLimit)
                        .Sum(objQuality => objQuality.BP);
                }
                return _intCachedMetagenicPositiveQualities;
            }
        }

        private int _intCachedMetagenicNegativeQualities = int.MinValue;
        public int MetagenicNegativeQualityKarma
        {
            get
            {
                if (_intCachedMetagenicNegativeQualities == int.MinValue)
                {
                    _intCachedMetagenicNegativeQualities = Qualities
                        .Where(objQuality =>
                            objQuality.Type == QualityType.Negative && objQuality.ContributeToMetagenicLimit)
                        .Sum(objQuality => objQuality.BP);

                    // Deduct the amount for free Qualities.
                    _intCachedMetagenicNegativeQualities -=
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.FreeNegativeQualities).StandardRound();
                }

                return _intCachedMetagenicNegativeQualities;
            }
        }

        public string DisplayMetagenicQualityKarma
        {
            get
            {
                string strReturn = string.Format(GlobalSettings.CultureInfo,
                    LanguageManager.GetString("Label_MetagenicKarmaValue"), MetagenicPositiveQualityKarma,
                    MetagenicNegativeQualityKarma, MetagenicLimit);
                if (MetagenicPositiveQualityKarma + MetagenicNegativeQualityKarma == 1)
                    strReturn += LanguageManager.GetString("Label_MetagenicKarmaValueAppend");

                return strReturn;
            }
        }

        private int _intCachedEnemyKarma = int.MinValue;
        public int EnemyKarma
        {
            get
            {
                if (_intCachedEnemyKarma != int.MinValue)
                    return _intCachedEnemyKarma;
                if (Settings.EnableEnemyTracking && Settings.KarmaEnemy > 0)
                    return _intCachedEnemyKarma = Contacts
                                           .Where(x => x.IsEnemy && !x.Free)
                                           .Sum(x => x.Connection + x.Loyalty) * Settings.KarmaEnemy;
                return _intCachedEnemyKarma = 0;
            }
        }

        public string DisplayEnemyKarma => EnemyKarma.ToString(GlobalSettings.CultureInfo)
                                           + LanguageManager.GetString("String_Space")
                                           + LanguageManager.GetString("String_Karma");

        #endregion

        #region Source

        private SourceString _objCachedSourceDetail;

        public SourceString SourceDetail
        {
            get
            {
                if (_objCachedSourceDetail == default)
                    _objCachedSourceDetail = new SourceString(Source,
                        DisplayPage(GlobalSettings.Language), GlobalSettings.Language, GlobalSettings.CultureInfo,
                        this);
                return _objCachedSourceDetail;
            }
        }

        /// <summary>
        /// Character's Sourcebook.
        /// </summary>
        public string Source
        {
            get => _strSource;
            set => _strSource = value;
        }

        /// <summary>
        /// Sourcebook Page Number.
        /// </summary>
        public string Page
        {
            get => _strPage;
            set => _strPage = value;
        }

        public bool AllowAdeptWayPowerDiscount
        {
            get
            {
                decimal decMAG;
                if (IsMysticAdept && Settings.MysAdeptSecondMAGAttribute)
                {
                    // If both Adept and Magician are enabled, this is a Mystic Adept, so use the MAG amount assigned to this portion.
                    decMAG = MAGAdept.TotalValue;
                }
                else
                {
                    // The character is just an Adept, so use the full value.
                    decMAG = MAG.TotalValue;
                }

                // Add any Power Point Improvements to MAG.
                decMAG += ImprovementManager.ValueOf(this, Improvement.ImprovementType.AdeptPowerPoints);

                return AnyPowerAdeptWayDiscountEnabled && Powers.Count(p => p.DiscountedAdeptWay) < (decMAG / 2).ToInt32();
            }
        }

        /// <summary>
        /// Sourcebook Page Number using a given language file.
        /// Returns Page if not found or the string is empty.
        /// </summary>
        /// <param name="strLanguage">Language file keyword to use.</param>
        /// <returns></returns>
        public string DisplayPage(string strLanguage)
        {
            if (strLanguage.Equals(GlobalSettings.DefaultLanguage, StringComparison.OrdinalIgnoreCase))
                return Page;
            string s = this.GetNodeXPath()?.SelectSingleNodeAndCacheExpression("altpage")?.Value ?? Page;
            return !string.IsNullOrWhiteSpace(s) ? s : Page;
        }

        /// <summary>
        /// Alias map for SourceDetail control text and tooltip assignation.
        /// </summary>
        /// <param name="sourceControl"></param>
        public void SetSourceDetail(Control sourceControl)
        {
            if (_objCachedSourceDetail.Language != GlobalSettings.Language)
                _objCachedSourceDetail = default;
            SourceDetail.SetControl(sourceControl);
        }
        #endregion

        #region Special Methods

        public bool ConvertCyberzombie()
        {
            bool blnEssence = true;
            string strMessage = LanguageManager.GetString("Message_CyberzombieRequirements");

            // Make sure the character has an Essence lower than 0.
            if (Essence() >= 0)
            {
                strMessage += Environment.NewLine + '\t' + LanguageManager.GetString("Message_CyberzombieRequirementsEssence");
                blnEssence = false;
            }

            bool blnEnabled = ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.EnableCyberzombie).Count > 0;

            if (!blnEnabled)
                strMessage += Environment.NewLine + '\t' + LanguageManager.GetString("Message_CyberzombieRequirementsImprovement");

            if (!blnEssence || !blnEnabled)
            {
                Program.MainForm.ShowMessageBox(strMessage,
                    LanguageManager.GetString("MessageTitle_CyberzombieRequirements"),
                    MessageBoxButtons.OK, MessageBoxIcon.Error);
                return false;
            }

            if (Program.MainForm.ShowMessageBox(LanguageManager.GetString("Message_CyberzombieConfirm"),
                    LanguageManager.GetString("MessageTitle_CyberzombieConfirm"),
                    MessageBoxButtons.YesNo, MessageBoxIcon.Question) == DialogResult.No)
                return false;

            int intWILResult;
            // Get the player to roll Dice to make a WIL Test and record the result.
            using (SelectDiceHits frmWILHits = new SelectDiceHits
            {
                Text = LanguageManager.GetString("String_CyberzombieWILText"),
                Description = LanguageManager.GetString("String_CyberzombieWILDescription"),
                Dice = WIL.TotalValue
            })
            {
                frmWILHits.ShowDialogSafe(Program.GetFormForDialog(this));

                if (frmWILHits.DialogResult != DialogResult.OK)
                    return false;

                intWILResult = frmWILHits.Result;
            }

            // The character gains 10 + ((Threshold - Hits) * 10)BP worth of Negative Qualities.
            int intThreshold = 3 + (Essence() - ESS.MetatypeMaximum).ToInt32();
            int intResult = 10;
            if (intWILResult < intThreshold)
            {
                intResult = (intThreshold - intWILResult) * 10;
            }
            ImprovementManager.CreateImprovement(this, string.Empty, Improvement.ImprovementSource.Cyberzombie, string.Empty, Improvement.ImprovementType.FreeNegativeQualities, string.Empty, intResult * -1);
            ImprovementManager.Commit(this);

            // Convert the character.
            // Characters lose access to Resonance.
            RESEnabled = false;

            // Gain MAG that is permanently set to 1.
            MAGEnabled = true;
            MAG.MetatypeMinimum = 1;
            MAG.MetatypeMaximum = 1;

            // Add the Cyberzombie Lifestyle if it is not already taken.
            if (Lifestyles.All(x => x.BaseLifestyle != "Cyberzombie Lifestyle Addition"))
            {
                XmlDocument objXmlLifestyleDocument = LoadData("lifestyles.xml");
                XmlNode objXmlLifestyle = objXmlLifestyleDocument.SelectSingleNode("/chummer/lifestyles/lifestyle[name = \"Cyberzombie Lifestyle Addition\"]");

                if (objXmlLifestyle != null)
                {
                    Lifestyle objLifestyle = new Lifestyle(this);
                    objLifestyle.Create(objXmlLifestyle);
                    Lifestyles.Add(objLifestyle);
                }
            }

            // Change the MetatypeCategory to Cyberzombie.
            MetatypeCategory = "Cyberzombie";

            // Gain access to Critter Powers.
            CritterEnabled = true;

            // Gain the Dual Natured Critter Power if it does not yet exist.
            if (CritterPowers.All(x => x.Name != "Dual Natured"))
            {
                XmlNode objXmlPowerNode = LoadData("critterpowers.xml").SelectSingleNode("/chummer/powers/power[name = \"Dual Natured\"]");

                if (objXmlPowerNode != null)
                {
                    CritterPower objCritterPower = new CritterPower(this);
                    objCritterPower.Create(objXmlPowerNode);
                    CritterPowers.Add(objCritterPower);
                }
            }

            // Gain the Immunity (Normal Weapons) Critter Power if it does not yet exist.
            if (!CritterPowers.Any(x => x.Name == "Immunity" && x.Extra == "Normal Weapons"))
            {
                XmlNode objXmlPowerNode = LoadData("critterpowers.xml").SelectSingleNode("/chummer/powers/power[name = \"Immunity\"]");

                if (objXmlPowerNode != null)
                {
                    CritterPower objCritterPower = new CritterPower(this);
                    objCritterPower.Create(objXmlPowerNode, 0, "Normal Weapons");
                    CritterPowers.Add(objCritterPower);
                }
            }

            return true;
        }
        #endregion
    }
}
