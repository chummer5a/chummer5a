/*  This file is part of Chummer5a.
 *
 *  Chummer5a is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  Chummer5a is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with Chummer5a.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  You can obtain the full source code for Chummer5a at
 *  https://github.com/chummer5a/chummer5a
 */
using Chummer.Annotations;
using Chummer.Backend.Attributes;
using Chummer.Backend.Equipment;
using Chummer.Backend.Skills;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Xml;
using System.Xml.XPath;
using Chummer.Backend.Uniques;
using System.Xml.Serialization;
using System.Runtime.Serialization;
using System.Threading;
using Chummer.Plugins;
using Microsoft.ApplicationInsights;
using Microsoft.IO;
using Newtonsoft.Json;
using NLog;
using Application = System.Windows.Forms.Application;

namespace Chummer
{
    /// <summary>
    /// Class that holds all of the information that makes up a complete Character.
    /// </summary>
    [DebuggerDisplay("{CharacterName} ({FileName})")]
    public sealed class Character : INotifyMultiplePropertyChanged, IHasMugshots, IHasName, IHasSource, IHasXmlDataNode, IHasLockObject
    {
        private static readonly TelemetryClient TelemetryClient = new TelemetryClient();
        private static readonly Lazy<Logger> s_ObjLogger = new Lazy<Logger>(LogManager.GetCurrentClassLogger);
        private static Logger Log => s_ObjLogger.Value;
        private XmlNode _oldSkillsBackup;
        private XmlNode _oldSkillGroupBackup;
        private string _strFileName = string.Empty;
        private string _strSettingsKey = GlobalSettings.DefaultCharacterSetting;
        private DateTime _dateFileLastWriteTime = DateTime.MinValue;
        private bool _blnIgnoreRules;
        private int _intKarma;
        private int _intTotalKarma;
        private int _intStreetCred;
        private int _intNotoriety;
        private int _intPublicAwareness;
        private int _intBurntStreetCred;
        private decimal _decNuyen;
        private decimal _decStolenNuyen;
        private decimal _decStartingNuyen;
        private decimal _decEssenceAtSpecialStart = decimal.MinValue;
        private int _intSpecial;
        private int _intTotalSpecial;
        private int _intAttributes;
        private int _intTotalAttributes;
        private int _intFreeSpells;
        private int _intCFPLimit;
        private int _intAINormalProgramLimit;
        private int _intAIAdvancedProgramLimit;
        private int _intCachedContactPoints = int.MinValue;
        private int _intContactPointsUsed;
        private int _intCachedRedlinerBonus = int.MinValue;
        private int _intCurrentCounterspellingDice;
        private int _intCurrentLiftCarryHits;
        private int _intEdgeUsed;
        private int _intBoundSpiritLimit = int.MinValue;
        private int _intRegisteredSpriteLimit = int.MinValue;
        private decimal _decCachedBaseCarryLimit = decimal.MinValue;
        private decimal _decCachedBaseLiftLimit = decimal.MinValue;
        private decimal _decCachedTotalCarriedWeight = decimal.MinValue;
        private decimal _decCachedEncumbranceInterval = decimal.MinValue;

        // General character info.
        private string _strName = string.Empty;

        private readonly ThreadSafeList<Image> _lstMugshots = new ThreadSafeList<Image>(3);
        private int _intMainMugshotIndex = -1;
        private string _strGender = string.Empty;
        private string _strAge = string.Empty;
        private string _strEyes = string.Empty;
        private string _strHeight = string.Empty;
        private string _strWeight = string.Empty;
        private string _strSkin = string.Empty;
        private string _strHair = string.Empty;
        private string _strDescription = string.Empty;
        private string _strBackground = string.Empty;
        private string _strConcept = string.Empty;
        private string _strNotes = string.Empty;
        private string _strAlias = string.Empty;
        private string _strPlayerName = string.Empty;
        private string _strGameNotes = string.Empty;
        private string _strPrimaryArm = "Right";

        public static readonly ReadOnlyCollection<string> LimbStrings = Array.AsReadOnly(new[]
            {"skull", "torso", "arm", "leg"});

        // AI Home Node

        // Active Commlink

        // If true, the Character creation has been finalized and is maintained through Karma.
        private bool _blnCreated;

        // Build Points
        private decimal _decNuyenBP;

        // Metatype Information.
        private string _strMetatype = "Human";

        private Guid _guiMetatype = Guid.Empty;
        private string _strMetavariant = string.Empty;
        private Guid _guiMetavariant = Guid.Empty;
        private string _strMetatypeCategory = "Metahuman";
        private string _strMovement = string.Empty;
        private string _strWalk = string.Empty;
        private string _strRun = string.Empty;
        private string _strSprint = string.Empty;
        private string _strWalkAlt = string.Empty;
        private string _strRunAlt = string.Empty;
        private string _strSprintAlt = string.Empty;
        private int _intMetatypeBP;
        private string _strSource;
        private string _strPage;
        private int _intInitiativeDice = 1;

        // Special Flags.

        private bool _blnAdeptEnabled;
        private bool _blnMagicianEnabled;
        private bool _blnTechnomancerEnabled;
        private bool _blnAdvancedProgramsEnabled;
        private bool _blnCyberwareDisabled;
        private bool _blnInitiationDisabled;
        private bool _blnCritterEnabled;
        private bool _blnIsCritter;
        private bool _blnPossessed;
        private decimal _decPrototypeTranshuman;
        private bool _blnMAGEnabled;
        private bool _blnRESEnabled;
        private bool _blnDEPEnabled;
        private bool _blnGroupMember;
        private string _strGroupName = string.Empty;
        private string _strGroupNotes = string.Empty;
        private int _intInitiateGrade;
        private int _intSubmersionGrade;
        private bool _blnPsycheActive;

        // Pseudo-Attributes use for Mystic Adepts.
        private int _intMAGMagician;

        private int _intMAGAdept;

        // Magic Tradition.
        private Tradition _objTradition;

        // Condition Monitor Progress.
        private int _intPhysicalCMFilled;

        private int _intStunCMFilled;

        // Spirit Reputation
        private int _intBaseAstralReputation;

        private int _intBaseWildReputation;

        // Priority Selections.
        private string _strPriorityMetatype = "A";

        private string _strPriorityAttributes = "B";
        private string _strPrioritySpecial = "C";
        private string _strPrioritySkills = "D";
        private string _strPriorityResources = "E";
        private string _strPriorityTalent = string.Empty;
        private readonly ThreadSafeList<string> _lstPrioritySkills = new ThreadSafeList<string>(3);

        // Lists.
        private readonly ThreadSafeObservableCollection<Improvement> _lstImprovements = new ThreadSafeObservableCollection<Improvement>();

        private readonly ThreadSafeObservableCollection<MentorSpirit>
            _lstMentorSpirits = new ThreadSafeObservableCollection<MentorSpirit>();

        private readonly ThreadSafeObservableCollection<Contact> _lstContacts = new ThreadSafeObservableCollection<Contact>();
        private readonly ThreadSafeObservableCollection<Spirit> _lstSpirits = new ThreadSafeObservableCollection<Spirit>();
        private readonly ThreadSafeObservableCollection<Spell> _lstSpells = new ThreadSafeObservableCollection<Spell>();

        private readonly ThreadSafeObservableCollection<SustainedObject> _lstSustainedObjects = new ThreadSafeObservableCollection<SustainedObject>();

        private readonly ThreadSafeList<Focus> _lstFoci = new ThreadSafeList<Focus>(5);
        private readonly ThreadSafeList<StackedFocus> _lstStackedFoci = new ThreadSafeList<StackedFocus>(5);
        private readonly ThreadSafeBindingList<Power> _lstPowers = new ThreadSafeBindingList<Power>();
        private readonly ThreadSafeObservableCollection<ComplexForm> _lstComplexForms = new ThreadSafeObservableCollection<ComplexForm>();
        private readonly ThreadSafeObservableCollection<AIProgram> _lstAIPrograms = new ThreadSafeObservableCollection<AIProgram>();
        private readonly ThreadSafeObservableCollection<MartialArt> _lstMartialArts = new ThreadSafeObservableCollection<MartialArt>();

        private readonly ThreadSafeObservableCollection<LimitModifier> _lstLimitModifiers =
            new ThreadSafeObservableCollection<LimitModifier>();

        private readonly ThreadSafeObservableCollection<Armor> _lstArmor = new ThreadSafeObservableCollection<Armor>();

        private readonly ThreadSafeObservableCollection<Cyberware> _lstCyberware = new ThreadSafeObservableCollection<Cyberware>();

        private readonly ThreadSafeObservableCollection<Weapon> _lstWeapons = new ThreadSafeObservableCollection<Weapon>();
        private readonly ThreadSafeObservableCollection<Quality> _lstQualities = new ThreadSafeObservableCollection<Quality>();
        private readonly ThreadSafeObservableCollection<Lifestyle> _lstLifestyles = new ThreadSafeObservableCollection<Lifestyle>();
        private readonly ThreadSafeObservableCollection<Gear> _lstGear = new ThreadSafeObservableCollection<Gear>();
        private readonly ThreadSafeObservableCollection<Vehicle> _lstVehicles = new ThreadSafeObservableCollection<Vehicle>();
        private readonly ThreadSafeObservableCollection<Metamagic> _lstMetamagics = new ThreadSafeObservableCollection<Metamagic>();
        private readonly ThreadSafeObservableCollection<Art> _lstArts = new ThreadSafeObservableCollection<Art>();
        private readonly ThreadSafeObservableCollection<Enhancement> _lstEnhancements = new ThreadSafeObservableCollection<Enhancement>();

        private readonly ThreadSafeObservableCollection<ExpenseLogEntry> _lstExpenseLog =
            new ThreadSafeObservableCollection<ExpenseLogEntry>();

        private readonly ThreadSafeObservableCollection<CritterPower>
            _lstCritterPowers = new ThreadSafeObservableCollection<CritterPower>();

        private readonly ThreadSafeObservableCollection<InitiationGrade> _lstInitiationGrades =
            new ThreadSafeObservableCollection<InitiationGrade>();

        private readonly ThreadSafeObservableCollection<Location> _lstGearLocations = new ThreadSafeObservableCollection<Location>();
        private readonly ThreadSafeObservableCollection<Location> _lstArmorLocations = new ThreadSafeObservableCollection<Location>();

        private readonly ThreadSafeObservableCollection<Location> _lstVehicleLocations = new ThreadSafeObservableCollection<Location>();

        private readonly ThreadSafeObservableCollection<Location> _lstWeaponLocations = new ThreadSafeObservableCollection<Location>();
        private readonly ThreadSafeObservableCollection<string> _lstImprovementGroups = new ThreadSafeObservableCollection<string>();
        private readonly ThreadSafeBindingList<CalendarWeek> _lstCalendar = new ThreadSafeBindingList<CalendarWeek>();

        private readonly ThreadSafeObservableCollection<Drug> _lstDrugs = new ThreadSafeObservableCollection<Drug>();

        private SortedDictionary<decimal, Tuple<string, string>> _dicAvailabilityMap;

        //private readonly List<LifeModule> _lstLifeModules = new List<LifeModule>(10);
        private ConcurrentBag<string> _lstInternalIdsNeedingReapplyImprovements = new ConcurrentBag<string>();

        // Character Version
        private string _strVersionCreated = Application.ProductVersion.FastEscapeOnceFromStart("0.0.");

        private Version _verSavedVersion = new Version();

        public AsyncFriendlyReaderWriterLock LockObject { get; } = new AsyncFriendlyReaderWriterLock();

        private readonly LockingOrderedSet<Func<Character, bool>> _setDoOnSaveCompleted = new LockingOrderedSet<Func<Character, bool>>();
        private readonly LockingOrderedSet<Func<Character, CancellationToken, Task<bool>>> _setDoOnSaveCompletedAsync = new LockingOrderedSet<Func<Character, CancellationToken, Task<bool>>>();

        /// <summary>
        /// Set of unique methods to run after the character's Save() method is otherwise finished.
        /// Input is the character in question, output is if the code resolved without errors.
        /// </summary>
        [JsonIgnore]
        [XmlIgnore]
        [IgnoreDataMember]
        public LockingOrderedSet<Func<Character, bool>> DoOnSaveCompleted
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _setDoOnSaveCompleted;
            }
        }

        /// <summary>
        /// Set of unique async methods to run after the character's Save() method is otherwise finished.
        /// Input is the character in question, output is if the code resolved without errors.
        /// </summary>
        [JsonIgnore]
        [XmlIgnore]
        [IgnoreDataMember]
        public LockingOrderedSet<Func<Character, CancellationToken, Task<bool>>> DoOnSaveCompletedAsync
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _setDoOnSaveCompletedAsync;
            }
        }

        #region Initialization, Save, Load, Print, and Reset Methods

        /// <summary>
        /// Character.
        /// </summary>
        public Character()
        {
            if (Utils.IsDesignerMode || Utils.IsRunningInVisualStudio)
                _objSettings = new CharacterSettings(); // Need this because ExpenseCharts is WPF and needs a Character in design mode.
            else if (!SettingsManager.LoadedCharacterSettings.TryGetValue(GlobalSettings.DefaultCharacterSetting, out _objSettings)
                     && !SettingsManager.LoadedCharacterSettings.TryGetValue(GlobalSettings.DefaultCharacterSettingDefaultValue, out _objSettings))
                _objSettings = SettingsManager.LoadedCharacterSettings.First().Value;

            using (_objSettings.LockObject.EnterWriteLock())
                _objSettings.PropertyChanged += OptionsOnPropertyChanged;
            _objAttributeSection = new AttributeSection(this);
            using (_objAttributeSection.LockObject.EnterWriteLock())
            {
                _objAttributeSection.Reset(true);
                _objAttributeSection.PropertyChanged += AttributeSectionOnPropertyChanged;
            }

            _objSkillsSection = new SkillsSection(this);
            using (_objSkillsSection.LockObject.EnterWriteLock())
                _objSkillsSection.Reset(true);

            _lstCyberware.CollectionChanged += CyberwareOnCollectionChanged;
            _lstArmor.CollectionChanged += ArmorOnCollectionChanged;
            _lstWeapons.CollectionChanged += WeaponsOnCollectionChanged;
            _lstGear.CollectionChanged += GearOnCollectionChanged;
            _lstContacts.CollectionChanged += ContactsOnCollectionChanged;
            _lstExpenseLog.CollectionChanged += ExpenseLogOnCollectionChanged;
            _lstMentorSpirits.CollectionChanged += MentorSpiritsOnCollectionChanged;
            _lstPowers.ListChanged += PowersOnListChanged;
            _lstPowers.BeforeRemove += PowersOnBeforeRemove;
            _lstQualities.CollectionChanged += QualitiesCollectionChanged;
            _lstCalendar.BeforeRemove += CalendarOnBeforeRemove;
            _lstMartialArts.CollectionChanged += MartialArtsOnCollectionChanged;
            _lstMetamagics.CollectionChanged += MetamagicsOnCollectionChanged;
            _lstSpells.CollectionChanged += SustainableOnCollectionChanged;
            _lstComplexForms.CollectionChanged += SustainableOnCollectionChanged;
            _lstCritterPowers.CollectionChanged += SustainableOnCollectionChanged;
            _lstSustainedObjects.CollectionChanged += SustainedObjectsOnCollectionChanged;
            _lstInitiationGrades.CollectionChanged += InitiationGradesOnCollectionChanged;
            _objTradition = new Tradition(this);
        }

        private async void CalendarOnBeforeRemove(object sender, RemovingOldEventArgs e)
        {
            using (await EnterReadLock.EnterAsync(LockObject).ConfigureAwait(false))
            {
                await (await Calendar.GetValueAtAsync(e.OldIndex).ConfigureAwait(false)).DisposeAsync()
                    .ConfigureAwait(false);
            }
        }

        private bool _blnClearingInitiations;

        private async void InitiationGradesOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (_blnClearingInitiations || IsLoading || e.Action == NotifyCollectionChangedAction.Move)
                return;
            bool blnUpdateSubmersion = false;
            bool blnUpdateInitiation = false;
            switch (e.Action)
            {
                case NotifyCollectionChangedAction.Add:
                    foreach (InitiationGrade objGrade in e.NewItems)
                    {
                        if (objGrade.Technomancer)
                        {
                            blnUpdateSubmersion = true;
                            if (blnUpdateInitiation)
                                break;
                        }
                        else
                        {
                            blnUpdateInitiation = true;
                            if (blnUpdateSubmersion)
                                break;
                        }
                    }
                    break;
                case NotifyCollectionChangedAction.Remove:
                    foreach (InitiationGrade objGrade in e.OldItems)
                    {
                        if (objGrade.Technomancer)
                        {
                            blnUpdateSubmersion = true;
                            if (blnUpdateInitiation)
                                break;
                        }
                        else
                        {
                            blnUpdateInitiation = true;
                            if (blnUpdateSubmersion)
                                break;
                        }
                    }
                    break;
                case NotifyCollectionChangedAction.Replace:
                    foreach (InitiationGrade objGrade in e.OldItems)
                    {
                        if (objGrade.Technomancer)
                        {
                            blnUpdateSubmersion = true;
                            if (blnUpdateInitiation)
                                break;
                        }
                        else
                        {
                            blnUpdateInitiation = true;
                            if (blnUpdateSubmersion)
                                break;
                        }
                    }
                    if (blnUpdateInitiation && blnUpdateSubmersion)
                        break;
                    foreach (InitiationGrade objGrade in e.NewItems)
                    {
                        if (objGrade.Technomancer)
                        {
                            blnUpdateSubmersion = true;
                            if (blnUpdateInitiation)
                                break;
                        }
                        else
                        {
                            blnUpdateInitiation = true;
                            if (blnUpdateSubmersion)
                                break;
                        }
                    }
                    break;
                case NotifyCollectionChangedAction.Reset:
                    blnUpdateInitiation = true;
                    blnUpdateSubmersion = true;
                    break;
            }
            // Need a complete recalculation because of potential issues where grades can change in between the grade getter and setter calls.
            int intSubmersion = 0;
            int intInitiation = 0;
            using (await EnterReadLock.EnterAsync(LockObject).ConfigureAwait(false))
            {
                // Don't do checks for update submersion/initiation in the accumulator because it's faster to just index counts than to do those checks every iteration.
                foreach (InitiationGrade objItem in InitiationGrades)
                {
                    if (objItem.Technomancer)
                        ++intSubmersion;
                    else
                        ++intInitiation;
                }

                if (blnUpdateSubmersion)
                    await SetSubmersionGradeAsync(intSubmersion).ConfigureAwait(false);
                if (blnUpdateInitiation)
                    await SetInitiateGradeAsync(intInitiation).ConfigureAwait(false);
            }
        }

        private async void SustainableOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (SustainedCollection.Count == 0 || IsLoading)
                return;
            switch (e.Action)
            {
                case NotifyCollectionChangedAction.Add:
                    break;

                case NotifyCollectionChangedAction.Remove:
                    foreach (IHasInternalId objItem in e.OldItems)
                    {
                        await SustainedCollection.RemoveAllAsync(x => ReferenceEquals(x.LinkedObject, objItem)).ConfigureAwait(false);
                    }
                    break;

                case NotifyCollectionChangedAction.Replace:
                    foreach (IHasInternalId objItem in e.OldItems)
                    {
                        await SustainedCollection.RemoveAllAsync(x => ReferenceEquals(x.LinkedObject, objItem)).ConfigureAwait(false);
                    }
                    break;

                case NotifyCollectionChangedAction.Move:
                    break;

                case NotifyCollectionChangedAction.Reset:
                    await SustainedCollection.RemoveAllAsync(async x =>
                                                                 !await Spells.AnyAsync(
                                                                     y => ReferenceEquals(y, x.LinkedObject)).ConfigureAwait(false)
                                                                 && !await ComplexForms.AnyAsync(
                                                                     y => ReferenceEquals(y, x.LinkedObject)).ConfigureAwait(false) &&
                                                                 !await CritterPowers.AnyAsync(
                                                                     y => ReferenceEquals(y, x.LinkedObject)).ConfigureAwait(false)).ConfigureAwait(false);
                    break;
            }
        }

        public XmlNode GetNode(bool blnReturnMetatypeOnly, string strLanguage = "", CancellationToken token = default)
        {
            return Utils.SafelyRunSynchronously(() => GetNodeCoreAsync(true, blnReturnMetatypeOnly, strLanguage, token), token);
        }

        public Task<XmlNode> GetNodeAsync(bool blnReturnMetatypeOnly, string strLanguage = "", CancellationToken token = default)
        {
            return GetNodeCoreAsync(false, blnReturnMetatypeOnly, strLanguage, token);
        }

        public Task<XmlNode> GetNodeCoreAsync(bool blnSync, string strLanguage, CancellationToken token = default)
        {
            return GetNodeCoreAsync(blnSync, false, strLanguage, token);
        }

        public async Task<XmlNode> GetNodeCoreAsync(bool blnSync, bool blnReturnMetatypeOnly, string strLanguage, CancellationToken token = default)
        {
            // ReSharper disable once MethodHasAsyncOverload
            using (blnSync ? EnterReadLock.Enter(LockObject, token) : await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                string strFile = IsCritter ? "critters.xml" : "metatypes.xml";
                XmlDocument xmlDoc = blnSync
                    // ReSharper disable once MethodHasAsyncOverload
                    ? LoadData(strFile, strLanguage, token: token)
                    : await LoadDataAsync(strFile, strLanguage, token: token).ConfigureAwait(false);
                XmlNode xmlMetatypeNode = MetatypeGuid == Guid.Empty
                    ? xmlDoc.TryGetNodeByNameOrId("/chummer/metatypes/metatype", Metatype)
                    : xmlDoc.TryGetNodeById("/chummer/metatypes/metatype", MetatypeGuid);
                if (blnReturnMetatypeOnly)
                    return xmlMetatypeNode;
                if (MetavariantGuid == Guid.Empty || string.IsNullOrEmpty(Metavariant) || xmlMetatypeNode == null)
                    return xmlMetatypeNode;
                XmlNode xmlMetavariantNode = null;
                if (MetatypeGuid != Guid.Empty)
                    xmlMetavariantNode = xmlMetatypeNode.TryGetNodeById("metavariants/metavariant", MetavariantGuid);
                if (xmlMetavariantNode == null)
                    xmlMetavariantNode = xmlMetatypeNode.TryGetNodeByNameOrId("metavariants/metavariant", Metavariant);

                return xmlMetavariantNode ?? xmlMetatypeNode;
            }
        }

        public XPathNavigator GetNodeXPath(bool blnReturnMetatypeOnly, string strLanguage = "", CancellationToken token = default)
        {
            return Utils.SafelyRunSynchronously(() => GetNodeXPathCoreAsync(true, blnReturnMetatypeOnly, strLanguage, token), token);
        }

        public Task<XPathNavigator> GetNodeXPathAsync(bool blnReturnMetatypeOnly, string strLanguage = "", CancellationToken token = default)
        {
            return GetNodeXPathCoreAsync(false, blnReturnMetatypeOnly, strLanguage, token);
        }

        public Task<XPathNavigator> GetNodeXPathCoreAsync(bool blnSync, string strLanguage, CancellationToken token = default)
        {
            return GetNodeXPathCoreAsync(blnSync, false, strLanguage, token);
        }

        public async Task<XPathNavigator> GetNodeXPathCoreAsync(bool blnSync, bool blnReturnMetatypeOnly, string strLanguage, CancellationToken token = default)
        {
            // ReSharper disable once MethodHasAsyncOverload
            using (blnSync ? EnterReadLock.Enter(LockObject, token) : await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                string strFile = IsCritter ? "critters.xml" : "metatypes.xml";
                XPathNavigator xmlDoc = blnSync
                    // ReSharper disable once MethodHasAsyncOverload
                    ? LoadDataXPath(strFile, strLanguage, token: token)
                    : await LoadDataXPathAsync(strFile, strLanguage, token: token).ConfigureAwait(false);
                XPathNavigator xmlMetatypeNode = MetatypeGuid == Guid.Empty
                    ? xmlDoc.TryGetNodeByNameOrId("/chummer/metatypes/metatype", Metatype)
                    : xmlDoc.TryGetNodeById("/chummer/metatypes/metatype", MetatypeGuid);
                if (blnReturnMetatypeOnly)
                    return xmlMetatypeNode;
                if (MetavariantGuid == Guid.Empty || string.IsNullOrEmpty(Metavariant) || xmlMetatypeNode == null)
                    return xmlMetatypeNode;
                XPathNavigator xmlMetavariantNode = null;
                if (MetavariantGuid != Guid.Empty)
                    xmlMetavariantNode = xmlMetatypeNode.TryGetNodeById("/metavariants/metavariant", MetavariantGuid);
                if (xmlMetavariantNode == null)
                    xmlMetavariantNode = xmlMetatypeNode.TryGetNodeByNameOrId("metavariants/metavariant", Metavariant);

                return xmlMetavariantNode ?? xmlMetatypeNode;
            }
        }

        public void RefreshAttributeBindings(CancellationToken token = default)
        {
            using (EnterReadLock.Enter(LockObject, token))
            using (EnterReadLock.Enter(AttributeSection.LockObject, token))
            using (EnterReadLock.Enter(AttributeSection.Attributes.LockObject, token))
            {
                Stack<CharacterAttrib> stkLockedAttribs = new Stack<CharacterAttrib>();
                try
                {
                    // First remove all existing bindings
                    foreach (CharacterAttrib objAttribute in AttributeSection.Attributes)
                    {
                        objAttribute.LockObject.EnterReadLock(token);
                        stkLockedAttribs.Push(objAttribute);
                        switch (objAttribute.Abbrev)
                        {
                            case "BOD":
                                using (objAttribute.LockObject.EnterWriteLock(token))
                                    objAttribute.PropertyChanged -= RefreshBODDependentProperties;
                                break;

                            case "AGI":
                                using (objAttribute.LockObject.EnterWriteLock(token))
                                    objAttribute.PropertyChanged -= RefreshAGIDependentProperties;
                                break;

                            case "REA":
                                using (objAttribute.LockObject.EnterWriteLock(token))
                                    objAttribute.PropertyChanged -= RefreshREADependentProperties;
                                break;

                            case "STR":
                                using (objAttribute.LockObject.EnterWriteLock(token))
                                    objAttribute.PropertyChanged -= RefreshSTRDependentProperties;
                                break;

                            case "CHA":
                                using (objAttribute.LockObject.EnterWriteLock(token))
                                    objAttribute.PropertyChanged -= RefreshCHADependentProperties;
                                break;

                            case "INT":
                                using (objAttribute.LockObject.EnterWriteLock(token))
                                    objAttribute.PropertyChanged -= RefreshINTDependentProperties;
                                break;

                            case "LOG":
                                using (objAttribute.LockObject.EnterWriteLock(token))
                                    objAttribute.PropertyChanged -= RefreshLOGDependentProperties;
                                break;

                            case "WIL":
                                using (objAttribute.LockObject.EnterWriteLock(token))
                                    objAttribute.PropertyChanged -= RefreshWILDependentProperties;
                                break;

                            case "EDG":
                                using (objAttribute.LockObject.EnterWriteLock(token))
                                    objAttribute.PropertyChanged -= RefreshEDGDependentProperties;
                                break;

                            case "MAG":
                                using (objAttribute.LockObject.EnterWriteLock(token))
                                    objAttribute.PropertyChanged -= RefreshMAGDependentProperties;
                                break;

                            case "MAGAdept":
                                using (objAttribute.LockObject.EnterWriteLock(token))
                                    objAttribute.PropertyChanged -= RefreshMAGAdeptDependentProperties;
                                break;

                            case "RES":
                                using (objAttribute.LockObject.EnterWriteLock(token))
                                    objAttribute.PropertyChanged -= RefreshRESDependentProperties;
                                break;

                            case "DEP":
                                using (objAttribute.LockObject.EnterWriteLock(token))
                                    objAttribute.PropertyChanged -= RefreshDEPDependentProperties;
                                break;

                            case "ESS":
                                using (objAttribute.LockObject.EnterWriteLock(token))
                                    objAttribute.PropertyChanged -= RefreshESSDependentProperties;
                                break;
                        }
                    }

                    using (BOD.LockObject.EnterWriteLock(token))
                        BOD.PropertyChanged += RefreshBODDependentProperties;
                    using (AGI.LockObject.EnterWriteLock(token))
                        AGI.PropertyChanged += RefreshAGIDependentProperties;
                    using (REA.LockObject.EnterWriteLock(token))
                        REA.PropertyChanged += RefreshREADependentProperties;
                    using (STR.LockObject.EnterWriteLock(token))
                        STR.PropertyChanged += RefreshSTRDependentProperties;
                    using (CHA.LockObject.EnterWriteLock(token))
                        CHA.PropertyChanged += RefreshCHADependentProperties;
                    using (INT.LockObject.EnterWriteLock(token))
                        INT.PropertyChanged += RefreshINTDependentProperties;
                    using (LOG.LockObject.EnterWriteLock(token))
                        LOG.PropertyChanged += RefreshLOGDependentProperties;
                    using (WIL.LockObject.EnterWriteLock(token))
                        WIL.PropertyChanged += RefreshWILDependentProperties;
                    using (EDG.LockObject.EnterWriteLock(token))
                        EDG.PropertyChanged += RefreshEDGDependentProperties;
                    using (MAG.LockObject.EnterWriteLock(token))
                        MAG.PropertyChanged += RefreshMAGDependentProperties;
                    using (RES.LockObject.EnterWriteLock(token))
                        RES.PropertyChanged += RefreshRESDependentProperties;
                    using (DEP.LockObject.EnterWriteLock(token))
                        DEP.PropertyChanged += RefreshDEPDependentProperties;
                    using (ESS.LockObject.EnterWriteLock(token))
                        ESS.PropertyChanged += RefreshESSDependentProperties;
                    // This needs to be explicitly set because a MAGAdept call could redirect to MAG, and we don't want that
                    CharacterAttrib objMagAdept = AttributeSection.GetAttributeByName("MAGAdept", token);
                    using (objMagAdept.LockObject.EnterWriteLock(token))
                        objMagAdept.PropertyChanged += RefreshMAGAdeptDependentProperties;
                }
                finally
                {
                    while (stkLockedAttribs.Count > 0)
                    {
                        stkLockedAttribs.Pop().LockObject.ExitReadLock();
                    }
                }
            }
        }

        public async ValueTask RefreshAttributeBindingsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                AttributeSection objAttributeSection = await GetAttributeSectionAsync(token).ConfigureAwait(false);
                using (await EnterReadLock.EnterAsync(objAttributeSection.LockObject, token).ConfigureAwait(false))
                {
                    ThreadSafeObservableCollection<CharacterAttrib> objAttributes
                        = await objAttributeSection.GetAttributesAsync(token).ConfigureAwait(false);
                    using (await EnterReadLock.EnterAsync(objAttributes.LockObject, token).ConfigureAwait(false))
                    {
                        Stack<CharacterAttrib> stkLockedAttribs
                            = new Stack<CharacterAttrib>(
                                await objAttributes.GetCountAsync(token).ConfigureAwait(false));
                        try
                        {
                            // First remove all existing bindings
                            await objAttributes.ForEachAsync(
                                async objAttribute =>
                                {
                                    await objAttribute.LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
                                    stkLockedAttribs.Push(objAttribute);
                                    switch (objAttribute.Abbrev)
                                    {
                                        case "BOD":
                                        {
                                            IAsyncDisposable objLocker = await objAttribute.LockObject
                                                .EnterWriteLockAsync(token).ConfigureAwait(false);
                                            try
                                            {
                                                objAttribute.PropertyChanged -= RefreshBODDependentProperties;
                                            }
                                            finally
                                            {
                                                await objLocker.DisposeAsync().ConfigureAwait(false);
                                            }

                                            break;
                                        }
                                        case "AGI":
                                        {
                                            IAsyncDisposable objLocker = await objAttribute.LockObject
                                                .EnterWriteLockAsync(token).ConfigureAwait(false);
                                            try
                                            {
                                                objAttribute.PropertyChanged -= RefreshAGIDependentProperties;
                                            }
                                            finally
                                            {
                                                await objLocker.DisposeAsync().ConfigureAwait(false);
                                            }

                                            break;
                                        }
                                        case "REA":
                                        {
                                            IAsyncDisposable objLocker = await objAttribute.LockObject
                                                .EnterWriteLockAsync(token).ConfigureAwait(false);
                                            try
                                            {
                                                objAttribute.PropertyChanged -= RefreshREADependentProperties;
                                            }
                                            finally
                                            {
                                                await objLocker.DisposeAsync().ConfigureAwait(false);
                                            }

                                            break;
                                        }
                                        case "STR":
                                        {
                                            IAsyncDisposable objLocker = await objAttribute.LockObject
                                                .EnterWriteLockAsync(token).ConfigureAwait(false);
                                            try
                                            {
                                                objAttribute.PropertyChanged -= RefreshSTRDependentProperties;
                                            }
                                            finally
                                            {
                                                await objLocker.DisposeAsync().ConfigureAwait(false);
                                            }

                                            break;
                                        }
                                        case "CHA":
                                        {
                                            IAsyncDisposable objLocker = await objAttribute.LockObject
                                                .EnterWriteLockAsync(token).ConfigureAwait(false);
                                            try
                                            {
                                                objAttribute.PropertyChanged -= RefreshCHADependentProperties;
                                            }
                                            finally
                                            {
                                                await objLocker.DisposeAsync().ConfigureAwait(false);
                                            }

                                            break;
                                        }
                                        case "INT":
                                        {
                                            IAsyncDisposable objLocker = await objAttribute.LockObject
                                                .EnterWriteLockAsync(token).ConfigureAwait(false);
                                            try
                                            {
                                                objAttribute.PropertyChanged -= RefreshINTDependentProperties;
                                            }
                                            finally
                                            {
                                                await objLocker.DisposeAsync().ConfigureAwait(false);
                                            }

                                            break;
                                        }
                                        case "LOG":
                                        {
                                            IAsyncDisposable objLocker = await objAttribute.LockObject
                                                .EnterWriteLockAsync(token).ConfigureAwait(false);
                                            try
                                            {
                                                objAttribute.PropertyChanged -= RefreshLOGDependentProperties;
                                            }
                                            finally
                                            {
                                                await objLocker.DisposeAsync().ConfigureAwait(false);
                                            }

                                            break;
                                        }
                                        case "WIL":
                                        {
                                            IAsyncDisposable objLocker = await objAttribute.LockObject
                                                .EnterWriteLockAsync(token).ConfigureAwait(false);
                                            try
                                            {
                                                objAttribute.PropertyChanged -= RefreshWILDependentProperties;
                                            }
                                            finally
                                            {
                                                await objLocker.DisposeAsync().ConfigureAwait(false);
                                            }

                                            break;
                                        }
                                        case "EDG":
                                        {
                                            IAsyncDisposable objLocker = await objAttribute.LockObject
                                                .EnterWriteLockAsync(token).ConfigureAwait(false);
                                            try
                                            {
                                                objAttribute.PropertyChanged -= RefreshEDGDependentProperties;
                                            }
                                            finally
                                            {
                                                await objLocker.DisposeAsync().ConfigureAwait(false);
                                            }

                                            break;
                                        }
                                        case "MAG":
                                        {
                                            IAsyncDisposable objLocker = await objAttribute.LockObject
                                                .EnterWriteLockAsync(token).ConfigureAwait(false);
                                            try
                                            {
                                                objAttribute.PropertyChanged -= RefreshMAGDependentProperties;
                                            }
                                            finally
                                            {
                                                await objLocker.DisposeAsync().ConfigureAwait(false);
                                            }

                                            break;
                                        }
                                        case "MAGAdept":
                                        {
                                            IAsyncDisposable objLocker = await objAttribute.LockObject
                                                .EnterWriteLockAsync(token).ConfigureAwait(false);
                                            try
                                            {
                                                objAttribute.PropertyChanged -= RefreshMAGAdeptDependentProperties;
                                            }
                                            finally
                                            {
                                                await objLocker.DisposeAsync().ConfigureAwait(false);
                                            }

                                            break;
                                        }
                                        case "RES":
                                        {
                                            IAsyncDisposable objLocker = await objAttribute.LockObject
                                                .EnterWriteLockAsync(token).ConfigureAwait(false);
                                            try
                                            {
                                                objAttribute.PropertyChanged -= RefreshRESDependentProperties;
                                            }
                                            finally
                                            {
                                                await objLocker.DisposeAsync().ConfigureAwait(false);
                                            }

                                            break;
                                        }
                                        case "DEP":
                                        {
                                            IAsyncDisposable objLocker = await objAttribute.LockObject
                                                .EnterWriteLockAsync(token).ConfigureAwait(false);
                                            try
                                            {
                                                objAttribute.PropertyChanged -= RefreshDEPDependentProperties;
                                            }
                                            finally
                                            {
                                                await objLocker.DisposeAsync().ConfigureAwait(false);
                                            }

                                            break;
                                        }
                                        case "ESS":
                                        {
                                            IAsyncDisposable objLocker = await objAttribute.LockObject
                                                .EnterWriteLockAsync(token).ConfigureAwait(false);
                                            try
                                            {
                                                objAttribute.PropertyChanged -= RefreshESSDependentProperties;
                                            }
                                            finally
                                            {
                                                await objLocker.DisposeAsync().ConfigureAwait(false);
                                            }

                                            break;
                                        }
                                    }
                                }, token).ConfigureAwait(false);

                            CharacterAttrib objLoopAttribute
                                = await GetAttributeAsync("BOD", token: token).ConfigureAwait(false);
                            if (objLoopAttribute != null)
                            {
                                IAsyncDisposable objLocker = await objLoopAttribute.LockObject
                                    .EnterWriteLockAsync(token)
                                    .ConfigureAwait(false);
                                try
                                {
                                    objLoopAttribute.PropertyChanged += RefreshBODDependentProperties;
                                }
                                finally
                                {
                                    await objLocker.DisposeAsync().ConfigureAwait(false);
                                }
                            }

                            objLoopAttribute = await GetAttributeAsync("AGI", token: token).ConfigureAwait(false);
                            if (objLoopAttribute != null)
                            {
                                IAsyncDisposable objLocker = await objLoopAttribute.LockObject
                                    .EnterWriteLockAsync(token)
                                    .ConfigureAwait(false);
                                try
                                {
                                    objLoopAttribute.PropertyChanged += RefreshAGIDependentProperties;
                                }
                                finally
                                {
                                    await objLocker.DisposeAsync().ConfigureAwait(false);
                                }
                            }

                            objLoopAttribute = await GetAttributeAsync("REA", token: token).ConfigureAwait(false);
                            if (objLoopAttribute != null)
                            {
                                IAsyncDisposable objLocker = await objLoopAttribute.LockObject
                                    .EnterWriteLockAsync(token)
                                    .ConfigureAwait(false);
                                try
                                {
                                    objLoopAttribute.PropertyChanged += RefreshREADependentProperties;
                                }
                                finally
                                {
                                    await objLocker.DisposeAsync().ConfigureAwait(false);
                                }
                            }

                            objLoopAttribute = await GetAttributeAsync("STR", token: token).ConfigureAwait(false);
                            if (objLoopAttribute != null)
                            {
                                IAsyncDisposable objLocker = await objLoopAttribute.LockObject
                                    .EnterWriteLockAsync(token)
                                    .ConfigureAwait(false);
                                try
                                {
                                    objLoopAttribute.PropertyChanged += RefreshSTRDependentProperties;
                                }
                                finally
                                {
                                    await objLocker.DisposeAsync().ConfigureAwait(false);
                                }
                            }

                            objLoopAttribute = await GetAttributeAsync("CHA", token: token).ConfigureAwait(false);
                            if (objLoopAttribute != null)
                            {
                                IAsyncDisposable objLocker = await objLoopAttribute.LockObject
                                    .EnterWriteLockAsync(token)
                                    .ConfigureAwait(false);
                                try
                                {
                                    objLoopAttribute.PropertyChanged += RefreshCHADependentProperties;
                                }
                                finally
                                {
                                    await objLocker.DisposeAsync().ConfigureAwait(false);
                                }
                            }

                            objLoopAttribute = await GetAttributeAsync("INT", token: token).ConfigureAwait(false);
                            if (objLoopAttribute != null)
                            {
                                IAsyncDisposable objLocker = await objLoopAttribute.LockObject
                                    .EnterWriteLockAsync(token)
                                    .ConfigureAwait(false);
                                try
                                {
                                    objLoopAttribute.PropertyChanged += RefreshINTDependentProperties;
                                }
                                finally
                                {
                                    await objLocker.DisposeAsync().ConfigureAwait(false);
                                }
                            }

                            objLoopAttribute = await GetAttributeAsync("LOG", token: token).ConfigureAwait(false);
                            if (objLoopAttribute != null)
                            {
                                IAsyncDisposable objLocker = await objLoopAttribute.LockObject
                                    .EnterWriteLockAsync(token)
                                    .ConfigureAwait(false);
                                try
                                {
                                    objLoopAttribute.PropertyChanged += RefreshLOGDependentProperties;
                                }
                                finally
                                {
                                    await objLocker.DisposeAsync().ConfigureAwait(false);
                                }
                            }

                            objLoopAttribute = await GetAttributeAsync("WIL", token: token).ConfigureAwait(false);
                            if (objLoopAttribute != null)
                            {
                                IAsyncDisposable objLocker = await objLoopAttribute.LockObject
                                    .EnterWriteLockAsync(token)
                                    .ConfigureAwait(false);
                                try
                                {
                                    objLoopAttribute.PropertyChanged += RefreshWILDependentProperties;
                                }
                                finally
                                {
                                    await objLocker.DisposeAsync().ConfigureAwait(false);
                                }
                            }

                            objLoopAttribute = await GetAttributeAsync("EDG", token: token).ConfigureAwait(false);
                            if (objLoopAttribute != null)
                            {
                                IAsyncDisposable objLocker = await objLoopAttribute.LockObject
                                    .EnterWriteLockAsync(token)
                                    .ConfigureAwait(false);
                                try
                                {
                                    objLoopAttribute.PropertyChanged += RefreshEDGDependentProperties;
                                }
                                finally
                                {
                                    await objLocker.DisposeAsync().ConfigureAwait(false);
                                }
                            }

                            objLoopAttribute = await GetAttributeAsync("MAG", token: token).ConfigureAwait(false);
                            if (objLoopAttribute != null)
                            {
                                IAsyncDisposable objLocker = await objLoopAttribute.LockObject
                                    .EnterWriteLockAsync(token)
                                    .ConfigureAwait(false);
                                try
                                {
                                    objLoopAttribute.PropertyChanged += RefreshMAGDependentProperties;
                                }
                                finally
                                {
                                    await objLocker.DisposeAsync().ConfigureAwait(false);
                                }
                            }

                            objLoopAttribute = await GetAttributeAsync("RES", token: token).ConfigureAwait(false);
                            if (objLoopAttribute != null)
                            {
                                IAsyncDisposable objLocker = await objLoopAttribute.LockObject
                                    .EnterWriteLockAsync(token)
                                    .ConfigureAwait(false);
                                try
                                {
                                    objLoopAttribute.PropertyChanged += RefreshRESDependentProperties;
                                }
                                finally
                                {
                                    await objLocker.DisposeAsync().ConfigureAwait(false);
                                }
                            }

                            objLoopAttribute = await GetAttributeAsync("DEP", token: token).ConfigureAwait(false);
                            if (objLoopAttribute != null)
                            {
                                IAsyncDisposable objLocker = await objLoopAttribute.LockObject
                                    .EnterWriteLockAsync(token)
                                    .ConfigureAwait(false);
                                try
                                {
                                    objLoopAttribute.PropertyChanged += RefreshDEPDependentProperties;
                                }
                                finally
                                {
                                    await objLocker.DisposeAsync().ConfigureAwait(false);
                                }
                            }

                            objLoopAttribute = await GetAttributeAsync("ESS", token: token).ConfigureAwait(false);
                            if (objLoopAttribute != null)
                            {
                                IAsyncDisposable objLocker = await objLoopAttribute.LockObject
                                    .EnterWriteLockAsync(token)
                                    .ConfigureAwait(false);
                                try
                                {
                                    objLoopAttribute.PropertyChanged += RefreshESSDependentProperties;
                                }
                                finally
                                {
                                    await objLocker.DisposeAsync().ConfigureAwait(false);
                                }
                            }

                            // This needs to be explicitly set because a MAGAdept call could redirect to MAG, and we don't want that
                            objLoopAttribute = await objAttributeSection
                                                     .GetAttributeByNameAsync("MAGAdept", token: token)
                                                     .ConfigureAwait(false);
                            if (objLoopAttribute != null)
                            {
                                IAsyncDisposable objLocker = await objLoopAttribute.LockObject
                                    .EnterWriteLockAsync(token)
                                    .ConfigureAwait(false);
                                try
                                {
                                    objLoopAttribute.PropertyChanged += RefreshMAGAdeptDependentProperties;
                                }
                                finally
                                {
                                    await objLocker.DisposeAsync().ConfigureAwait(false);
                                }
                            }
                        }
                        finally
                        {
                            while (stkLockedAttribs.Count > 0)
                            {
                                stkLockedAttribs.Pop().LockObject.ExitReadLock();
                            }
                        }
                    }
                }
            }
        }

        private async void OptionsOnPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            await DoOptionsOnPropertyChanged(sender, e).ConfigureAwait(false);
        }

        private async Task DoOptionsOnPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterSettings.UseCalculatedPublicAwareness):
                    OnPropertyChanged(nameof(CalculatedPublicAwareness));
                    break;

                case nameof(CharacterSettings.SpiritForceBasedOnTotalMAG):
                    OnPropertyChanged(nameof(MaxSpiritForce));
                    break;

                case nameof(CharacterSettings.CyberlegMovement):
                    OnPropertyChanged(nameof(Movement));
                    break;

                case nameof(CharacterSettings.AllowInitiationInCreateMode):
                    OnPropertyChanged(nameof(AddInitiationsAllowed));
                    break;

                case nameof(CharacterSettings.MysAdeptAllowPpCareer):
                    OnPropertyChanged(nameof(MysAdeptAllowPPCareer));
                    break;

                case nameof(CharacterSettings.MysAdeptSecondMAGAttribute):
                    this.OnMultiplePropertyChanged(nameof(UseMysticAdeptPPs), nameof(AllowAdeptWayPowerDiscount));
                    break;

                case nameof(CharacterSettings.ContactPointsExpression):
                    OnPropertyChanged(nameof(ContactPoints));
                    break;

                case nameof(CharacterSettings.SpecialKarmaCostBasedOnShownValue):
                    await RefreshEssenceLossImprovementsAsync().ConfigureAwait(false);
                    break;

                case nameof(CharacterSettings.NuyenFormat):
                    this.OnMultiplePropertyChanged(nameof(DisplayNuyen), nameof(DisplayCareerNuyen),
                                                   nameof(DisplayStolenNuyen));
                    break;

                case nameof(CharacterSettings.WeightFormat):
                    this.OnMultiplePropertyChanged(nameof(LiftAndCarryLimits), nameof(DisplayTotalCarriedWeight));
                    break;

                case nameof(CharacterSettings.EssenceFormat):
                case nameof(CharacterSettings.DontRoundEssenceInternally):
                case nameof(CharacterSettings.EssenceModifierPostExpression):
                    this.OnMultiplePropertyChanged(nameof(PrototypeTranshumanEssenceUsed), nameof(BiowareEssence),
                                                   nameof(CyberwareEssence), nameof(EssenceHole));
                    break;

                case nameof(CharacterSettings.NuyenMaximumBP):
                case nameof(CharacterSettings.UnrestrictedNuyen):
                    OnPropertyChanged(nameof(TotalNuyenMaximumBP));
                    break;

                case nameof(CharacterSettings.KarmaMysticAdeptPowerPoint):
                    OnPropertyChanged(nameof(CanAffordCareerPP));
                    break;

                case nameof(CharacterSettings.BuildMethod):
                    OnPropertyChanged(nameof(EffectiveBuildMethod));
                    break;

                case nameof(CharacterSettings.AutomaticBackstory):
                    OnPropertyChanged(nameof(EnableAutomaticStoryButton));
                    break;

                case nameof(CharacterSettings.ChargenKarmaToNuyenExpression):
                    OnPropertyChanged(nameof(TotalStartingNuyen));
                    break;

                case nameof(CharacterSettings.LimbCount):
                    OnPropertyChanged(nameof(LimbCount));
                    break;

                case nameof(CharacterSettings.MetatypeCostsKarmaMultiplier):
                    OnPropertyChanged(nameof(DisplayMetatypeBP));
                    break;

                case nameof(CharacterSettings.RedlinerExcludes):
                    OnPropertyChanged(nameof(RedlinerBonus));
                    break;

                case nameof(CharacterSettings.NoArmorEncumbrance):
                    OnPropertyChanged(nameof(ArmorEncumbrance));
                    break;

                case nameof(CharacterSettings.UncappedArmorAccessoryBonuses):
                    this.OnMultiplePropertyChanged(nameof(ArmorEncumbrance), nameof(GetArmorRatingWithImprovement));
                    break;

                case nameof(CharacterSettings.KarmaQuality):
                case nameof(CharacterSettings.QualityKarmaLimit):
                    this.OnMultiplePropertyChanged(nameof(PositiveQualityLimitKarma), nameof(PositiveQualityKarma),
                                                   nameof(NegativeQualityLimitKarma), nameof(NegativeQualityKarma));
                    break;

                case nameof(CharacterSettings.ExceedPositiveQualitiesCostDoubled):
                    this.OnMultiplePropertyChanged(nameof(PositiveQualityLimitKarma), nameof(PositiveQualityKarma));
                    break;

                case nameof(CharacterSettings.EnemyKarmaQualityLimit):
                case nameof(CharacterSettings.ExceedNegativeQualitiesNoBonus):
                    this.OnMultiplePropertyChanged(nameof(NegativeQualityLimitKarma), nameof(NegativeQualityKarma));
                    break;

                case nameof(CharacterSettings.EnableEnemyTracking):
                case nameof(CharacterSettings.KarmaEnemy):
                    OnPropertyChanged(nameof(EnemyKarma));
                    break;

                case nameof(CharacterSettings.DicePenaltySustaining):
                    OnPropertyChanged(nameof(SustainingPenalty));
                    break;

                case nameof(CharacterSettings.KarmaSpell):
                    using (await EnterReadLock.EnterAsync(LockObject).ConfigureAwait(false))
                    {
                        if (await GetFreeSpellsAsync().ConfigureAwait(false) > 0)
                            OnPropertyChanged(nameof(PositiveQualityKarma));
                    }
                    break;

                case nameof(CharacterSettings.MinInitiativeDice):
                    using (await EnterReadLock.EnterAsync(LockObject).ConfigureAwait(false))
                    {
                        XPathNavigator objNode = await this.GetNodeXPathAsync().ConfigureAwait(false);
                        if (objNode == null || await objNode.SelectSingleNodeAndCacheExpressionAsync("initiativedice").ConfigureAwait(false) == null)
                        {
                            _intInitiativeDice = Settings.MinInitiativeDice;
                            OnPropertyChanged(nameof(InitiativeDice));
                        }
                    }
                    break;

                case nameof(CharacterSettings.MaxInitiativeDice):
                    OnPropertyChanged(nameof(InitiativeDice));
                    break;

                case nameof(CharacterSettings.MinAstralInitiativeDice):
                case nameof(CharacterSettings.MaxAstralInitiativeDice):
                    OnPropertyChanged(nameof(AstralInitiativeDice));
                    break;

                case nameof(CharacterSettings.MinColdSimInitiativeDice):
                case nameof(CharacterSettings.MaxColdSimInitiativeDice):
                    OnPropertyChanged(nameof(MatrixInitiativeColdDice));
                    break;

                case nameof(CharacterSettings.MinHotSimInitiativeDice):
                    using (await EnterReadLock.EnterAsync(LockObject).ConfigureAwait(false))
                    {
                        if (IsAI)
                            this.OnMultiplePropertyChanged(nameof(MatrixInitiativeDice),
                                                           nameof(MatrixInitiativeHotDice));
                        else
                            OnPropertyChanged(nameof(MatrixInitiativeHotDice));
                    }
                    break;

                case nameof(CharacterSettings.MaxHotSimInitiativeDice):
                    OnPropertyChanged(nameof(MatrixInitiativeHotDice));
                    break;

                case nameof(CharacterSettings.LiftLimitExpression):
                    OnPropertyChanged(nameof(BaseLiftLimit));
                    break;

                case nameof(CharacterSettings.CarryLimitExpression):
                    OnPropertyChanged(nameof(BaseCarryLimit));
                    break;

                case nameof(CharacterSettings.EncumbranceIntervalExpression):
                    OnPropertyChanged(nameof(EncumbranceInterval));
                    break;

                case nameof(CharacterSettings.DoEncumbrancePenaltyPhysicalLimit):
                case nameof(CharacterSettings.DoEncumbrancePenaltyMovementSpeed):
                case nameof(CharacterSettings.DoEncumbrancePenaltyAgility):
                case nameof(CharacterSettings.DoEncumbrancePenaltyReaction):
                    OnPropertyChanged(nameof(Encumbrance));
                    break;

                case nameof(CharacterSettings.EncumbrancePenaltyPhysicalLimit):
                    if (Settings.DoEncumbrancePenaltyPhysicalLimit)
                        OnPropertyChanged(nameof(Encumbrance));
                    break;

                case nameof(CharacterSettings.EncumbrancePenaltyMovementSpeed):
                    if (Settings.DoEncumbrancePenaltyMovementSpeed)
                        OnPropertyChanged(nameof(Encumbrance));
                    break;

                case nameof(CharacterSettings.EncumbrancePenaltyAgility):
                    using (await EnterReadLock.EnterAsync(LockObject).ConfigureAwait(false))
                    {
                        if (Settings.DoEncumbrancePenaltyAgility)
                            OnPropertyChanged(nameof(Encumbrance));
                    }
                    break;

                case nameof(CharacterSettings.EncumbrancePenaltyReaction):
                    using (await EnterReadLock.EnterAsync(LockObject).ConfigureAwait(false))
                    {
                        if (Settings.DoEncumbrancePenaltyReaction)
                            OnPropertyChanged(nameof(Encumbrance));
                    }
                    break;

                case nameof(CharacterSettings.DoEncumbrancePenaltyWoundModifier):
                    this.OnMultiplePropertyChanged(nameof(WoundModifier), nameof(Encumbrance));
                    break;

                case nameof(CharacterSettings.EncumbrancePenaltyWoundModifier):
                    using (await EnterReadLock.EnterAsync(LockObject).ConfigureAwait(false))
                    {
                        if (Settings.DoEncumbrancePenaltyWoundModifier)
                            this.OnMultiplePropertyChanged(nameof(WoundModifier), nameof(Encumbrance));
                    }
                    break;
            }

            await Utils.RunOnMainThreadAsync(() => SettingsPropertyChanged?.Invoke(sender, e)).ConfigureAwait(false);
        }

        private void AttributeSectionOnPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == nameof(AttributeSection.AttributeCategory) || IsLoading)
            {
                this.OnMultiplePropertyChanged(nameof(CurrentWalkingRateString),
                                               nameof(CurrentRunningRateString),
                                               nameof(CurrentSprintingRateString));
            }
        }

        private void ContactsOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (e.Action != NotifyCollectionChangedAction.Move || IsLoading)
            {
                this.OnMultiplePropertyChanged(nameof(NegativeQualityKarma),
                                               nameof(NegativeQualityLimitKarma),
                                               nameof(PositiveQualityLimitKarma),
                                               nameof(PositiveQualityKarma),
                                               nameof(EnemyKarma));
            }
        }

        private async void PowersOnBeforeRemove(object sender, RemovingOldEventArgs e)
        {
            using (await EnterReadLock.EnterAsync(LockObject).ConfigureAwait(false))
            {
                Power objPower = await Powers.GetValueAtAsync(e.OldIndex).ConfigureAwait(false);
                if (objPower.AdeptWayDiscountEnabled)
                    this.OnMultiplePropertyChanged(nameof(AnyPowerAdeptWayDiscountEnabled),
                                                   nameof(AllowAdeptWayPowerDiscount));
                // Do not need to dispose because deleting the power already disposes the power after removing it from the character
            }
        }

        private async void PowersOnListChanged(object sender, ListChangedEventArgs e)
        {
            using (new FetchSafelyFromPool<Dictionary<INotifyMultiplePropertyChanged, HashSet<string>>>(
                       Utils.DictionaryForMultiplePropertyChangedPool,
                       out Dictionary<INotifyMultiplePropertyChanged, HashSet<string>> dicChangedProperties))
            {
                try
                {
                    switch (e.ListChangedType)
                    {
                        case ListChangedType.Reset:
                        {
                            HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                            strTemp.Add(nameof(PowerPointsUsed));
                            strTemp.Add(nameof(AnyPowerAdeptWayDiscountEnabled));
                            strTemp.Add(nameof(AllowAdeptWayPowerDiscount));
                            dicChangedProperties.Add(this, strTemp);
                            break;
                        }
                        case ListChangedType.ItemAdded:
                        {
                            HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                            strTemp.Add(nameof(PowerPointsUsed));
                            dicChangedProperties.Add(this, strTemp);
                            using (await EnterReadLock.EnterAsync(LockObject).ConfigureAwait(false))
                            {
                                Power objNewPower = Powers[e.NewIndex];
                                if (!IsLoading)
                                {
                                    // Needed in order to properly process named sources where
                                    // the tooltip was built before the object was added to the character
                                    foreach (Improvement objImprovement in Improvements)
                                    {
                                        if (objImprovement.SourceName != objNewPower.InternalId
                                            || !objImprovement.Enabled)
                                            continue;
                                        foreach ((INotifyMultiplePropertyChanged objItemToUpdate,
                                                  string strPropertyToUpdate) in
                                                 objImprovement.GetRelevantPropertyChangers())
                                        {
                                            if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                    out HashSet<string> setChangedProperties))
                                            {
                                                setChangedProperties = Utils.StringHashSetPool.Get();
                                                dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                            }

                                            setChangedProperties.Add(strPropertyToUpdate);
                                        }
                                    }
                                }

                                if (objNewPower.AdeptWayDiscountEnabled)
                                {
                                    strTemp.Add(nameof(AnyPowerAdeptWayDiscountEnabled));
                                    strTemp.Add(nameof(AllowAdeptWayPowerDiscount));
                                }
                            }

                            break;
                        }
                        case ListChangedType.ItemDeleted:
                        {
                            HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                            strTemp.Add(nameof(PowerPointsUsed));
                            dicChangedProperties.Add(this, strTemp);
                            break;
                        }
                        case ListChangedType.ItemChanged:
                        {
                            if (e.PropertyDescriptor == null)
                            {
                                break;
                            }

                            switch (e.PropertyDescriptor.Name)
                            {
                                case nameof(Power.AdeptWayDiscountEnabled):
                                {
                                    HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                                    strTemp.Add(nameof(AnyPowerAdeptWayDiscountEnabled));
                                    strTemp.Add(nameof(AllowAdeptWayPowerDiscount));
                                    dicChangedProperties.Add(this, strTemp);
                                    break;
                                }
                                case nameof(Power.DiscountedAdeptWay):
                                {
                                    HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                                    strTemp.Add(nameof(PowerPointsUsed));
                                    strTemp.Add(nameof(AnyPowerAdeptWayDiscountEnabled));
                                    strTemp.Add(nameof(AllowAdeptWayPowerDiscount));
                                    dicChangedProperties.Add(this, strTemp);
                                    using (await EnterReadLock.EnterAsync(LockObject).ConfigureAwait(false))
                                    {
                                        foreach (Power objPower in Powers)
                                        {
                                            if (!dicChangedProperties.TryGetValue(objPower,
                                                    out HashSet<string> setChangedProperties))
                                            {
                                                setChangedProperties = Utils.StringHashSetPool.Get();
                                                dicChangedProperties.Add(objPower, setChangedProperties);
                                            }

                                            setChangedProperties.Add(nameof(Power.AdeptWayDiscountEnabled));
                                        }
                                    }

                                    break;
                                }
                                case nameof(Power.PowerPoints):
                                {
                                    HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                                    strTemp.Add(nameof(PowerPointsUsed));
                                    dicChangedProperties.Add(this, strTemp);
                                    break;
                                }
                            }

                            break;
                        }
                    }

                    foreach (KeyValuePair<INotifyMultiplePropertyChanged, HashSet<string>> kvpToProcess in
                             dicChangedProperties)
                    {
                        kvpToProcess.Key.OnMultiplePropertyChanged(kvpToProcess.Value.ToList());
                    }
                }
                finally
                {
                    List<HashSet<string>> lstToReturn = dicChangedProperties.Values.ToList();
                    for (int i = lstToReturn.Count - 1; i >= 0; --i)
                    {
                        HashSet<string> setLoop = lstToReturn[i];
                        Utils.StringHashSetPool.Return(ref setLoop);
                    }
                }
            }
        }

        private async void MentorSpiritsOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (IsLoading)
                return;
            List<MentorSpirit> lstImprovementSourcesToProcess = new List<MentorSpirit>(MentorSpirits.Count);

            switch (e.Action)
            {
                case NotifyCollectionChangedAction.Add:
                case NotifyCollectionChangedAction.Replace:
                    lstImprovementSourcesToProcess.AddRange(e.NewItems.Cast<MentorSpirit>());
                    break;

                case NotifyCollectionChangedAction.Move:
                    return;

                case NotifyCollectionChangedAction.Reset:
                    lstImprovementSourcesToProcess.AddRange(MentorSpirits);
                    break;
            }

            if (lstImprovementSourcesToProcess.Count == 0)
            {
                OnPropertyChanged(nameof(MentorSpirits));
                return;
            }

            using (new FetchSafelyFromPool<Dictionary<INotifyMultiplePropertyChanged, HashSet<string>>>(
                       Utils.DictionaryForMultiplePropertyChangedPool,
                       out Dictionary<INotifyMultiplePropertyChanged, HashSet<string>> dicChangedProperties))
            {
                try
                {
                    HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                    strTemp.Add(nameof(MentorSpirits));
                    dicChangedProperties.Add(this, strTemp);
                    using (await EnterReadLock.EnterAsync(LockObject).ConfigureAwait(false))
                    {
                        foreach (MentorSpirit objNewItem in lstImprovementSourcesToProcess)
                        {
                            // Needed in order to properly process named sources where
                            // the tooltip was built before the object was added to the character
                            foreach (Improvement objImprovement in Improvements)
                            {
                                if (objImprovement.SourceName != objNewItem.InternalId || !objImprovement.Enabled)
                                    continue;
                                foreach ((INotifyMultiplePropertyChanged objItemToUpdate,
                                          string strPropertyToUpdate) in
                                         objImprovement.GetRelevantPropertyChangers())
                                {
                                    if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                                          out HashSet<string> setChangedProperties))
                                    {
                                        setChangedProperties = Utils.StringHashSetPool.Get();
                                        dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                    }

                                    setChangedProperties.Add(strPropertyToUpdate);
                                }
                            }
                        }
                    }

                    foreach (KeyValuePair<INotifyMultiplePropertyChanged, HashSet<string>> kvpToUpdate in
                             dicChangedProperties)
                    {
                        kvpToUpdate.Key.OnMultiplePropertyChanged(kvpToUpdate.Value.ToList());
                    }
                }
                finally
                {
                    List<HashSet<string>> lstToReturn = dicChangedProperties.Values.ToList();
                    for (int i = lstToReturn.Count - 1; i >= 0; --i)
                    {
                        HashSet<string> setLoop = lstToReturn[i];
                        Utils.StringHashSetPool.Return(ref setLoop);
                    }
                }
            }
        }

        private async void QualitiesCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (IsLoading)
                return;
            List<Quality> lstImprovementSourcesToProcess = new List<Quality>(Qualities.Count);

            switch (e.Action)
            {
                case NotifyCollectionChangedAction.Add:
                case NotifyCollectionChangedAction.Replace:
                    lstImprovementSourcesToProcess.AddRange(e.NewItems.Cast<Quality>());
                    break;

                case NotifyCollectionChangedAction.Move:
                    return;

                case NotifyCollectionChangedAction.Reset:
                    lstImprovementSourcesToProcess.AddRange(Qualities);
                    break;
            }

            using (new FetchSafelyFromPool<Dictionary<INotifyMultiplePropertyChanged, HashSet<string>>>(
                       Utils.DictionaryForMultiplePropertyChangedPool,
                       out Dictionary<INotifyMultiplePropertyChanged, HashSet<string>> dicChangedProperties))
            {
                try
                {
                    HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                    strTemp.Add(nameof(Qualities));
                    dicChangedProperties.Add(this, strTemp);
                    using (await EnterReadLock.EnterAsync(LockObject).ConfigureAwait(false))
                    {
                        foreach (Power objPower in Powers)
                        {
                            HashSet<string> strInnerTemp = Utils.StringHashSetPool.Get();
                            strInnerTemp.Add(nameof(Power.AdeptWayDiscountEnabled));
                            dicChangedProperties.Add(objPower, strInnerTemp);
                        }

                        if (lstImprovementSourcesToProcess.Count > 0)
                        {
                            foreach (Quality objNewItem in lstImprovementSourcesToProcess)
                            {
                                // Needed in order to properly process named sources where
                                // the tooltip was built before the object was added to the character
                                foreach (Improvement objImprovement in Improvements)
                                {
                                    if (objImprovement.SourceName != objNewItem.InternalId
                                        || !objImprovement.Enabled)
                                        continue;
                                    foreach ((INotifyMultiplePropertyChanged objItemToUpdate,
                                              string strPropertyToUpdate) in
                                             objImprovement.GetRelevantPropertyChangers())
                                    {
                                        if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                out HashSet<string> setChangedProperties))
                                        {
                                            setChangedProperties = Utils.StringHashSetPool.Get();
                                            dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                        }

                                        setChangedProperties.Add(strPropertyToUpdate);
                                    }
                                }
                            }
                        }
                    }

                    foreach (KeyValuePair<INotifyMultiplePropertyChanged, HashSet<string>> kvpToUpdate in
                             dicChangedProperties)
                    {
                        kvpToUpdate.Key.OnMultiplePropertyChanged(kvpToUpdate.Value.ToList());
                    }
                }
                finally
                {
                    List<HashSet<string>> lstToReturn = dicChangedProperties.Values.ToList();
                    for (int i = lstToReturn.Count - 1; i >= 0; --i)
                    {
                        HashSet<string> setLoop = lstToReturn[i];
                        Utils.StringHashSetPool.Return(ref setLoop);
                    }
                }
            }
        }

        private async void MartialArtsOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (IsLoading)
                return;
            List<MartialArt> lstImprovementSourcesToProcess = new List<MartialArt>(MartialArts.Count);

            switch (e.Action)
            {
                case NotifyCollectionChangedAction.Add:
                case NotifyCollectionChangedAction.Replace:
                    lstImprovementSourcesToProcess.AddRange(e.NewItems.Cast<MartialArt>());
                    break;

                case NotifyCollectionChangedAction.Move:
                    return;

                case NotifyCollectionChangedAction.Reset:
                    lstImprovementSourcesToProcess.AddRange(MartialArts);
                    break;
            }

            if (lstImprovementSourcesToProcess.Count == 0)
            {
                OnPropertyChanged(nameof(MartialArts));
                return;
            }

            using (new FetchSafelyFromPool<Dictionary<INotifyMultiplePropertyChanged, HashSet<string>>>(
                       Utils.DictionaryForMultiplePropertyChangedPool,
                       out Dictionary<INotifyMultiplePropertyChanged, HashSet<string>> dicChangedProperties))
            {
                try
                {
                    HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                    strTemp.Add(nameof(MartialArts));
                    dicChangedProperties.Add(this, strTemp);
                    using (await EnterReadLock.EnterAsync(LockObject).ConfigureAwait(false))
                    {
                        foreach (MartialArt objNewItem in lstImprovementSourcesToProcess)
                        {
                            // Needed in order to properly process named sources where
                            // the tooltip was built before the object was added to the character
                            foreach (Improvement objImprovement in Improvements)
                            {
                                if (objImprovement.SourceName != objNewItem.InternalId || !objImprovement.Enabled)
                                    continue;
                                foreach ((INotifyMultiplePropertyChanged objItemToUpdate,
                                          string strPropertyToUpdate) in
                                         objImprovement.GetRelevantPropertyChangers())
                                {
                                    if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                                          out HashSet<string> setChangedProperties))
                                    {
                                        setChangedProperties = Utils.StringHashSetPool.Get();
                                        dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                    }

                                    setChangedProperties.Add(strPropertyToUpdate);
                                }
                            }
                        }
                    }

                    foreach (KeyValuePair<INotifyMultiplePropertyChanged, HashSet<string>> kvpToUpdate in
                             dicChangedProperties)
                    {
                        kvpToUpdate.Key.OnMultiplePropertyChanged(kvpToUpdate.Value.ToList());
                    }
                }
                finally
                {
                    List<HashSet<string>> lstToReturn = dicChangedProperties.Values.ToList();
                    for (int i = lstToReturn.Count - 1; i >= 0; --i)
                    {
                        HashSet<string> setLoop = lstToReturn[i];
                        Utils.StringHashSetPool.Return(ref setLoop);
                    }
                }
            }
        }

        private async void MetamagicsOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (IsLoading)
                return;
            List<Metamagic> lstImprovementSourcesToProcess = new List<Metamagic>(Metamagics.Count);

            switch (e.Action)
            {
                case NotifyCollectionChangedAction.Add:
                case NotifyCollectionChangedAction.Replace:
                    lstImprovementSourcesToProcess.AddRange(e.NewItems.Cast<Metamagic>());
                    break;

                case NotifyCollectionChangedAction.Move:
                    return;

                case NotifyCollectionChangedAction.Reset:
                    lstImprovementSourcesToProcess.AddRange(Metamagics);
                    break;
            }

            if (lstImprovementSourcesToProcess.Count == 0)
            {
                OnPropertyChanged(nameof(Metamagics));
                return;
            }

            using (new FetchSafelyFromPool<Dictionary<INotifyMultiplePropertyChanged, HashSet<string>>>(
                       Utils.DictionaryForMultiplePropertyChangedPool,
                       out Dictionary<INotifyMultiplePropertyChanged, HashSet<string>> dicChangedProperties))
            {
                try
                {
                    HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                    strTemp.Add(nameof(Metamagics));
                    dicChangedProperties.Add(this, strTemp);
                    using (await EnterReadLock.EnterAsync(LockObject).ConfigureAwait(false))
                    {
                        foreach (Metamagic objNewItem in lstImprovementSourcesToProcess)
                        {
                            // Needed in order to properly process named sources where
                            // the tooltip was built before the object was added to the character
                            foreach (Improvement objImprovement in Improvements)
                            {
                                if (objImprovement.SourceName != objNewItem.InternalId || !objImprovement.Enabled)
                                    continue;
                                foreach ((INotifyMultiplePropertyChanged objItemToUpdate,
                                          string strPropertyToUpdate) in
                                         objImprovement.GetRelevantPropertyChangers())
                                {
                                    if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                                          out HashSet<string> setChangedProperties))
                                    {
                                        setChangedProperties = Utils.StringHashSetPool.Get();
                                        dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                    }

                                    setChangedProperties.Add(strPropertyToUpdate);
                                }
                            }
                        }
                    }

                    foreach (KeyValuePair<INotifyMultiplePropertyChanged, HashSet<string>> kvpToUpdate in
                             dicChangedProperties)
                    {
                        kvpToUpdate.Key.OnMultiplePropertyChanged(kvpToUpdate.Value.ToList());
                    }
                }
                finally
                {
                    List<HashSet<string>> lstToReturn = dicChangedProperties.Values.ToList();
                    for (int i = lstToReturn.Count - 1; i >= 0; --i)
                    {
                        HashSet<string> setLoop = lstToReturn[i];
                        Utils.StringHashSetPool.Return(ref setLoop);
                    }
                }
            }
        }

        private void ExpenseLogOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (e.Action == NotifyCollectionChangedAction.Move || IsLoading)
                return;
            using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                            out HashSet<string> setPropertiesToRefresh))
            {
                switch (e.Action)
                {
                    case NotifyCollectionChangedAction.Add:
                        foreach (ExpenseLogEntry objNewItem in e.NewItems)
                        {
                            if ((objNewItem.Amount > 0 || objNewItem.ForceCareerVisible) && !objNewItem.Refund)
                            {
                                setPropertiesToRefresh.Add(objNewItem.Type == ExpenseType.Nuyen
                                                               ? nameof(CareerNuyen)
                                                               : nameof(CareerKarma));
                            }
                        }

                        break;

                    case NotifyCollectionChangedAction.Remove:
                        foreach (ExpenseLogEntry objOldItem in e.OldItems)
                        {
                            if ((objOldItem.Amount > 0 || objOldItem.ForceCareerVisible) && !objOldItem.Refund)
                            {
                                setPropertiesToRefresh.Add(objOldItem.Type == ExpenseType.Nuyen
                                                               ? nameof(CareerNuyen)
                                                               : nameof(CareerKarma));
                            }
                        }

                        break;

                    case NotifyCollectionChangedAction.Replace:
                        foreach (ExpenseLogEntry objOldItem in e.OldItems)
                        {
                            if ((objOldItem.Amount > 0 || objOldItem.ForceCareerVisible) && !objOldItem.Refund)
                            {
                                setPropertiesToRefresh.Add(objOldItem.Type == ExpenseType.Nuyen
                                                               ? nameof(CareerNuyen)
                                                               : nameof(CareerKarma));
                            }
                        }

                        foreach (ExpenseLogEntry objNewItem in e.NewItems)
                        {
                            if ((objNewItem.Amount > 0 || objNewItem.ForceCareerVisible) && !objNewItem.Refund)
                            {
                                setPropertiesToRefresh.Add(objNewItem.Type == ExpenseType.Nuyen
                                                               ? nameof(CareerNuyen)
                                                               : nameof(CareerKarma));
                            }
                        }

                        break;

                    case NotifyCollectionChangedAction.Reset:
                        setPropertiesToRefresh.Add(nameof(CareerNuyen));
                        setPropertiesToRefresh.Add(nameof(CareerKarma));
                        break;
                }

                if (setPropertiesToRefresh.Count > 0)
                    OnMultiplePropertyChanged(setPropertiesToRefresh.ToList());
            }
        }

        private async void GearOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (e.Action == NotifyCollectionChangedAction.Move || IsLoading)
                return;
            bool blnDoEncumbranceRefresh = false;
            using (new FetchSafelyFromPool<Dictionary<INotifyMultiplePropertyChanged, HashSet<string>>>(
                       Utils.DictionaryForMultiplePropertyChangedPool,
                       out Dictionary<INotifyMultiplePropertyChanged, HashSet<string>> dicChangedProperties))
            {
                try
                {
                    switch (e.Action)
                    {
                        case NotifyCollectionChangedAction.Add:
                            foreach (Gear objNewItem in e.NewItems)
                            {
                                if (objNewItem.Equipped)
                                {
                                    blnDoEncumbranceRefresh = true;
                                }

                                using (await EnterReadLock.EnterAsync(LockObject).ConfigureAwait(false))
                                {
                                    if (!IsLoading)
                                    {
                                        // Needed in order to properly process named sources where
                                        // the tooltip was built before the object was added to the character
                                        foreach (Improvement objImprovement in Improvements)
                                        {
                                            if (objImprovement.SourceName.TrimEndOnce("Wireless")
                                                == objNewItem.InternalId
                                                &&
                                                objImprovement.Enabled)
                                            {
                                                foreach ((INotifyMultiplePropertyChanged objItemToUpdate,
                                                          string strPropertyToUpdate) in
                                                         objImprovement.GetRelevantPropertyChangers())
                                                {
                                                    if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                            out HashSet<string> setChangedProperties))
                                                    {
                                                        setChangedProperties = Utils.StringHashSetPool.Get();
                                                        dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                                    }

                                                    setChangedProperties.Add(strPropertyToUpdate);
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            break;

                        case NotifyCollectionChangedAction.Remove:
                            foreach (Gear objOldItem in e.OldItems)
                            {
                                if (objOldItem.Equipped)
                                {
                                    blnDoEncumbranceRefresh = true;
                                    break;
                                }
                            }

                            break;

                        case NotifyCollectionChangedAction.Replace:
                            foreach (Gear objOldItem in e.OldItems)
                            {
                                if (objOldItem.Equipped)
                                {
                                    blnDoEncumbranceRefresh = true;
                                    break;
                                }
                            }

                            foreach (Gear objNewItem in e.NewItems)
                            {
                                if (objNewItem.Equipped)
                                {
                                    blnDoEncumbranceRefresh = true;
                                }

                                using (await EnterReadLock.EnterAsync(LockObject).ConfigureAwait(false))
                                {
                                    if (!IsLoading)
                                    {
                                        // Needed in order to properly process named sources where
                                        // the tooltip was built before the object was added to the character
                                        foreach (Improvement objImprovement in Improvements)
                                        {
                                            if (objImprovement.SourceName.TrimEndOnce("Wireless")
                                                == objNewItem.InternalId
                                                &&
                                                objImprovement.Enabled)
                                            {
                                                foreach ((INotifyMultiplePropertyChanged objItemToUpdate,
                                                          string strPropertyToUpdate) in
                                                         objImprovement.GetRelevantPropertyChangers())
                                                {
                                                    if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                            out HashSet<string> setChangedProperties))
                                                    {
                                                        setChangedProperties = Utils.StringHashSetPool.Get();
                                                        dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                                    }

                                                    setChangedProperties.Add(strPropertyToUpdate);
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            break;

                        case NotifyCollectionChangedAction.Reset:
                            blnDoEncumbranceRefresh = true;
                            break;
                    }

                    if (blnDoEncumbranceRefresh)
                    {
                        if (!dicChangedProperties.TryGetValue(this, out HashSet<string> setChangedProperties))
                        {
                            setChangedProperties = Utils.StringHashSetPool.Get();
                            dicChangedProperties.Add(this, setChangedProperties);
                        }
                        setChangedProperties.Add(nameof(TotalCarriedWeight));
                    }

                    foreach (KeyValuePair<INotifyMultiplePropertyChanged, HashSet<string>> kvpToProcess in dicChangedProperties)
                    {
                        kvpToProcess.Key.OnMultiplePropertyChanged(kvpToProcess.Value.ToList());
                    }
                }
                finally
                {
                    List<HashSet<string>> lstToReturn = dicChangedProperties.Values.ToList();
                    for (int i = lstToReturn.Count - 1; i >= 0; --i)
                    {
                        HashSet<string> setLoop = lstToReturn[i];
                        Utils.StringHashSetPool.Return(ref setLoop);
                    }
                }
            }
        }

        private async void WeaponsOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (e.Action == NotifyCollectionChangedAction.Move || IsLoading)
                return;
            bool blnDoEncumbranceRefresh = false;
            using (new FetchSafelyFromPool<Dictionary<INotifyMultiplePropertyChanged, HashSet<string>>>(
                       Utils.DictionaryForMultiplePropertyChangedPool,
                       out Dictionary<INotifyMultiplePropertyChanged, HashSet<string>> dicChangedProperties))
            {
                try
                {
                    switch (e.Action)
                    {
                        case NotifyCollectionChangedAction.Add:
                            foreach (Weapon objNewItem in e.NewItems)
                            {
                                if (objNewItem.Equipped)
                                {
                                    blnDoEncumbranceRefresh = true;
                                }

                                using (await EnterReadLock.EnterAsync(LockObject).ConfigureAwait(false))
                                {
                                    if (!IsLoading)
                                    {
                                        // Needed in order to properly process named sources where
                                        // the tooltip was built before the object was added to the character
                                        foreach (Improvement objImprovement in Improvements)
                                        {
                                            if (objImprovement.SourceName.TrimEndOnce("Wireless")
                                                == objNewItem.InternalId
                                                &&
                                                objImprovement.Enabled)
                                            {
                                                foreach ((INotifyMultiplePropertyChanged objItemToUpdate,
                                                          string strPropertyToUpdate) in
                                                         objImprovement.GetRelevantPropertyChangers())
                                                {
                                                    if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                            out HashSet<string> setChangedProperties))
                                                    {
                                                        setChangedProperties = Utils.StringHashSetPool.Get();
                                                        dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                                    }

                                                    setChangedProperties.Add(strPropertyToUpdate);
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            break;

                        case NotifyCollectionChangedAction.Remove:
                            foreach (Weapon objOldItem in e.OldItems)
                            {
                                if (objOldItem.Equipped)
                                {
                                    blnDoEncumbranceRefresh = true;
                                    break;
                                }
                            }

                            break;

                        case NotifyCollectionChangedAction.Replace:
                            foreach (Weapon objOldItem in e.OldItems)
                            {
                                if (objOldItem.Equipped)
                                {
                                    blnDoEncumbranceRefresh = true;
                                    break;
                                }
                            }

                            foreach (Weapon objNewItem in e.NewItems)
                            {
                                if (objNewItem.Equipped)
                                {
                                    blnDoEncumbranceRefresh = true;
                                }

                                using (await EnterReadLock.EnterAsync(LockObject).ConfigureAwait(false))
                                {
                                    if (!IsLoading)
                                    {
                                        // Needed in order to properly process named sources where
                                        // the tooltip was built before the object was added to the character
                                        foreach (Improvement objImprovement in Improvements)
                                        {
                                            if (objImprovement.SourceName.TrimEndOnce("Wireless")
                                                == objNewItem.InternalId
                                                &&
                                                objImprovement.Enabled)
                                            {
                                                foreach ((INotifyMultiplePropertyChanged objItemToUpdate,
                                                          string strPropertyToUpdate) in
                                                         objImprovement.GetRelevantPropertyChangers())
                                                {
                                                    if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                            out HashSet<string> setChangedProperties))
                                                    {
                                                        setChangedProperties = Utils.StringHashSetPool.Get();
                                                        dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                                    }

                                                    setChangedProperties.Add(strPropertyToUpdate);
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            break;

                        case NotifyCollectionChangedAction.Reset:
                            blnDoEncumbranceRefresh = true;
                            break;
                    }

                    if (blnDoEncumbranceRefresh)
                    {
                        if (!dicChangedProperties.TryGetValue(this, out HashSet<string> setChangedProperties))
                        {
                            setChangedProperties = Utils.StringHashSetPool.Get();
                            dicChangedProperties.Add(this, setChangedProperties);
                        }
                        setChangedProperties.Add(nameof(TotalCarriedWeight));
                    }

                    foreach (KeyValuePair<INotifyMultiplePropertyChanged, HashSet<string>> kvpToProcess in dicChangedProperties)
                    {
                        kvpToProcess.Key.OnMultiplePropertyChanged(kvpToProcess.Value.ToList());
                    }
                }
                finally
                {
                    List<HashSet<string>> lstToReturn = dicChangedProperties.Values.ToList();
                    for (int i = lstToReturn.Count - 1; i >= 0; --i)
                    {
                        HashSet<string> setLoop = lstToReturn[i];
                        Utils.StringHashSetPool.Return(ref setLoop);
                    }
                }
            }
        }

        private async void ArmorOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (e.Action == NotifyCollectionChangedAction.Move || IsLoading)
                return;
            bool blnDoEquippedArmorRefresh = false;
            bool blnDoArmorEncumbranceRefresh = false;
            using (new FetchSafelyFromPool<Dictionary<INotifyMultiplePropertyChanged, HashSet<string>>>(
                       Utils.DictionaryForMultiplePropertyChangedPool,
                       out Dictionary<INotifyMultiplePropertyChanged, HashSet<string>> dicChangedProperties))
            {
                try
                {
                    switch (e.Action)
                    {
                        case NotifyCollectionChangedAction.Add:
                            foreach (Armor objNewItem in e.NewItems)
                            {
                                if (objNewItem.Equipped)
                                {
                                    blnDoEquippedArmorRefresh = true;
                                    if (objNewItem.Encumbrance)
                                        blnDoArmorEncumbranceRefresh = true;
                                }

                                using (await EnterReadLock.EnterAsync(LockObject).ConfigureAwait(false))
                                {
                                    if (!IsLoading)
                                    {
                                        // Needed in order to properly process named sources where
                                        // the tooltip was built before the object was added to the character
                                        foreach (Improvement objImprovement in Improvements)
                                        {
                                            if (objImprovement.SourceName.TrimEndOnce("Wireless")
                                                == objNewItem.InternalId
                                                &&
                                                objImprovement.Enabled)
                                            {
                                                foreach ((INotifyMultiplePropertyChanged objItemToUpdate,
                                                          string strPropertyToUpdate) in
                                                         objImprovement.GetRelevantPropertyChangers())
                                                {
                                                    if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                            out HashSet<string> setChangedProperties))
                                                    {
                                                        setChangedProperties = Utils.StringHashSetPool.Get();
                                                        dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                                    }

                                                    setChangedProperties.Add(strPropertyToUpdate);
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            break;

                        case NotifyCollectionChangedAction.Remove:
                            foreach (Armor objOldItem in e.OldItems)
                            {
                                if (objOldItem.Equipped)
                                {
                                    blnDoEquippedArmorRefresh = true;
                                    if (objOldItem.Encumbrance)
                                    {
                                        blnDoArmorEncumbranceRefresh = true;
                                        break;
                                    }
                                }
                            }

                            break;

                        case NotifyCollectionChangedAction.Replace:
                            foreach (Armor objOldItem in e.OldItems)
                            {
                                if (objOldItem.Equipped)
                                {
                                    blnDoEquippedArmorRefresh = true;
                                    if (objOldItem.Encumbrance)
                                    {
                                        blnDoArmorEncumbranceRefresh = true;
                                        break;
                                    }
                                }
                            }

                            foreach (Armor objNewItem in e.NewItems)
                            {
                                if (objNewItem.Equipped)
                                {
                                    blnDoEquippedArmorRefresh = true;
                                    if (objNewItem.Encumbrance)
                                        blnDoArmorEncumbranceRefresh = true;
                                }

                                using (await EnterReadLock.EnterAsync(LockObject).ConfigureAwait(false))
                                {
                                    if (!IsLoading)
                                    {
                                        // Needed in order to properly process named sources where
                                        // the tooltip was built before the object was added to the character
                                        foreach (Improvement objImprovement in Improvements)
                                        {
                                            if (objImprovement.SourceName.TrimEndOnce("Wireless")
                                                == objNewItem.InternalId
                                                &&
                                                objImprovement.Enabled)
                                            {
                                                foreach ((INotifyMultiplePropertyChanged objItemToUpdate,
                                                          string strPropertyToUpdate) in
                                                         objImprovement.GetRelevantPropertyChangers())
                                                {
                                                    if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                            out HashSet<string> setChangedProperties))
                                                    {
                                                        setChangedProperties = Utils.StringHashSetPool.Get();
                                                        dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                                    }

                                                    setChangedProperties.Add(strPropertyToUpdate);
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            break;

                        case NotifyCollectionChangedAction.Reset:
                            blnDoEquippedArmorRefresh = true;
                            blnDoArmorEncumbranceRefresh = true;
                            break;
                    }

                    if (blnDoEquippedArmorRefresh)
                    {
                        if (!dicChangedProperties.TryGetValue(this, out HashSet<string> setChangedProperties))
                        {
                            setChangedProperties = Utils.StringHashSetPool.Get();
                            dicChangedProperties.Add(this, setChangedProperties);
                        }
                        setChangedProperties.Add(nameof(GetArmorRating));
                        setChangedProperties.Add(nameof(TotalCarriedWeight));
                    }

                    if (blnDoArmorEncumbranceRefresh)
                    {
                        if (!dicChangedProperties.TryGetValue(this, out HashSet<string> setChangedProperties))
                        {
                            setChangedProperties = Utils.StringHashSetPool.Get();
                            dicChangedProperties.Add(this, setChangedProperties);
                        }
                        setChangedProperties.Add(nameof(ArmorEncumbrance));
                    }

                    foreach (KeyValuePair<INotifyMultiplePropertyChanged, HashSet<string>> kvpToProcess in dicChangedProperties)
                    {
                        kvpToProcess.Key.OnMultiplePropertyChanged(kvpToProcess.Value.ToList());
                    }
                }
                finally
                {
                    List<HashSet<string>> lstToReturn = dicChangedProperties.Values.ToList();
                    for (int i = lstToReturn.Count - 1; i >= 0; --i)
                    {
                        HashSet<string> setLoop = lstToReturn[i];
                        Utils.StringHashSetPool.Return(ref setLoop);
                    }
                }
            }
        }

        private async void CyberwareOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (e.Action == NotifyCollectionChangedAction.Move || IsLoading)
                return;
            bool blnDoEncumbranceRefresh = false;
            bool blnDoCyberlimbAttributesRefresh = false;
            using (new FetchSafelyFromPool<Dictionary<INotifyMultiplePropertyChanged, HashSet<string>>>(
                       Utils.DictionaryForMultiplePropertyChangedPool,
                       out Dictionary<INotifyMultiplePropertyChanged, HashSet<string>> dicChangedProperties))
            {
                try
                {
                    switch (e.Action)
                    {
                        case NotifyCollectionChangedAction.Add:
                        {
                            HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                            strTemp.Add(nameof(RedlinerBonus));
                            dicChangedProperties.Add(this, strTemp);
                            foreach (Cyberware objNewItem in e.NewItems)
                            {
                                if (objNewItem.IsModularCurrentlyEquipped)
                                    blnDoEncumbranceRefresh = true;
                                dicChangedProperties[this].Add(objNewItem.EssencePropertyName);
                                using (await EnterReadLock.EnterAsync(LockObject).ConfigureAwait(false))
                                {
                                    if (!IsLoading)
                                    {
                                        // Needed in order to properly process named sources where
                                        // the tooltip was built before the object was added to the character
                                        foreach (Improvement objImprovement in Improvements)
                                        {
                                            if (objImprovement.SourceName.TrimEndOnce("Pair").TrimEndOnce("Wireless") ==
                                                objNewItem.InternalId && objImprovement.Enabled)
                                            {
                                                foreach ((INotifyMultiplePropertyChanged objItemToUpdate,
                                                          string strPropertyToUpdate) in
                                                         objImprovement.GetRelevantPropertyChangers())
                                                {
                                                    if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                            out HashSet<string> setChangedProperties))
                                                    {
                                                        setChangedProperties = Utils.StringHashSetPool.Get();
                                                        dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                                    }

                                                    setChangedProperties.Add(strPropertyToUpdate);
                                                }
                                            }
                                        }
                                    }

                                    if (!blnDoCyberlimbAttributesRefresh && !Settings.DontUseCyberlimbCalculation &&
                                        objNewItem.Category == "Cyberlimb" && objNewItem.Parent == null &&
                                        objNewItem.ParentVehicle == null &&
                                        !string.IsNullOrWhiteSpace(objNewItem.LimbSlot) &&
                                        !Settings.ExcludeLimbSlot.Contains(objNewItem.LimbSlot))
                                    {
                                        blnDoCyberlimbAttributesRefresh = true;
                                    }
                                }
                            }

                            break;
                        }
                        case NotifyCollectionChangedAction.Remove:
                        {
                            HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                            strTemp.Add(nameof(RedlinerBonus));
                            dicChangedProperties.Add(this, strTemp);
                            foreach (Cyberware objOldItem in e.OldItems)
                            {
                                if (objOldItem.IsModularCurrentlyEquipped)
                                    blnDoEncumbranceRefresh = true;
                                dicChangedProperties[this].Add(objOldItem.EssencePropertyName);
                                using (await EnterReadLock.EnterAsync(LockObject).ConfigureAwait(false))
                                {
                                    if (!blnDoCyberlimbAttributesRefresh && !Settings.DontUseCyberlimbCalculation &&
                                        objOldItem.Category == "Cyberlimb" && objOldItem.Parent == null &&
                                        objOldItem.ParentVehicle == null &&
                                        !string.IsNullOrWhiteSpace(objOldItem.LimbSlot) &&
                                        !Settings.ExcludeLimbSlot.Contains(objOldItem.LimbSlot))
                                    {
                                        blnDoCyberlimbAttributesRefresh = true;
                                    }
                                }
                            }

                            break;
                        }
                        case NotifyCollectionChangedAction.Replace:
                        {
                            HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                            strTemp.Add(nameof(RedlinerBonus));
                            dicChangedProperties.Add(this, strTemp);
                            using (await EnterReadLock.EnterAsync(LockObject).ConfigureAwait(false))
                            {
                                if (!Settings.DontUseCyberlimbCalculation)
                                {
                                    foreach (Cyberware objOldItem in e.OldItems)
                                    {
                                        if (objOldItem.IsModularCurrentlyEquipped)
                                            blnDoEncumbranceRefresh = true;
                                        dicChangedProperties[this].Add(objOldItem.EssencePropertyName);
                                        if (!blnDoCyberlimbAttributesRefresh && !Settings.DontUseCyberlimbCalculation &&
                                            objOldItem.Category == "Cyberlimb" && objOldItem.Parent == null &&
                                            objOldItem.ParentVehicle == null &&
                                            !string.IsNullOrWhiteSpace(objOldItem.LimbSlot) &&
                                            !Settings.ExcludeLimbSlot.Contains(objOldItem.LimbSlot))
                                        {
                                            blnDoCyberlimbAttributesRefresh = true;
                                        }
                                    }

                                    foreach (Cyberware objNewItem in e.NewItems)
                                    {
                                        if (objNewItem.IsModularCurrentlyEquipped)
                                            blnDoEncumbranceRefresh = true;
                                        dicChangedProperties[this].Add(objNewItem.EssencePropertyName);
                                        if (!blnDoCyberlimbAttributesRefresh && !Settings.DontUseCyberlimbCalculation &&
                                            objNewItem.Category == "Cyberlimb" && objNewItem.Parent == null &&
                                            objNewItem.ParentVehicle == null &&
                                            !string.IsNullOrWhiteSpace(objNewItem.LimbSlot) &&
                                            !Settings.ExcludeLimbSlot.Contains(objNewItem.LimbSlot))
                                        {
                                            blnDoCyberlimbAttributesRefresh = true;
                                        }
                                    }
                                }
                            }

                            break;
                        }
                        case NotifyCollectionChangedAction.Reset:
                        {
                            blnDoEncumbranceRefresh = true;
                            using (await EnterReadLock.EnterAsync(LockObject).ConfigureAwait(false))
                                blnDoCyberlimbAttributesRefresh = !Settings.DontUseCyberlimbCalculation;
                            if (!dicChangedProperties.TryGetValue(this,
                                                                  out HashSet<string> setChangedProperties))
                            {
                                setChangedProperties = Utils.StringHashSetPool.Get();
                                dicChangedProperties.Add(this, setChangedProperties);
                            }
                            setChangedProperties.Add(nameof(RedlinerBonus));
                            setChangedProperties.Add(nameof(PrototypeTranshumanEssenceUsed));
                            setChangedProperties.Add(nameof(BiowareEssence));
                            setChangedProperties.Add(nameof(CyberwareEssence));
                            setChangedProperties.Add(nameof(EssenceHole));
                            break;
                        }
                    }

                    if (blnDoEncumbranceRefresh)
                    {
                        if (!dicChangedProperties.TryGetValue(this, out HashSet<string> setChangedProperties))
                        {
                            setChangedProperties = Utils.StringHashSetPool.Get();
                            dicChangedProperties.Add(this, setChangedProperties);
                        }
                        setChangedProperties.Add(nameof(TotalCarriedWeight));
                    }

                    if (blnDoCyberlimbAttributesRefresh)
                    {
                        using (await EnterReadLock.EnterAsync(LockObject).ConfigureAwait(false))
                        {
                            foreach (string strAbbrev in Backend.Equipment.Cyberware.CyberlimbAttributeAbbrevs)
                            {
                                CharacterAttrib objAttribute = await GetAttributeAsync(strAbbrev).ConfigureAwait(false);
                                if (objAttribute == null)
                                    continue;
                                if (!dicChangedProperties.TryGetValue(objAttribute,
                                                                      out HashSet<string> setChangedProperties))
                                {
                                    setChangedProperties = Utils.StringHashSetPool.Get();
                                    dicChangedProperties.Add(objAttribute, setChangedProperties);
                                }

                                setChangedProperties.Add(nameof(CharacterAttrib.TotalValue));
                            }
                        }
                    }

                    foreach (KeyValuePair<INotifyMultiplePropertyChanged, HashSet<string>> kvpToProcess in dicChangedProperties)
                    {
                        kvpToProcess.Key.OnMultiplePropertyChanged(kvpToProcess.Value.ToList());
                    }
                }
                finally
                {
                    List<HashSet<string>> lstToReturn = dicChangedProperties.Values.ToList();
                    for (int i = lstToReturn.Count - 1; i >= 0; --i)
                    {
                        HashSet<string> setLoop = lstToReturn[i];
                        Utils.StringHashSetPool.Return(ref setLoop);
                    }
                }
            }
        }

        private async void SustainedObjectsOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (e.Action == NotifyCollectionChangedAction.Move || IsLoading)
                return;
            bool blnDoRefreshPenalties = false;
            switch (e.Action)
            {
                case NotifyCollectionChangedAction.Add:
                    blnDoRefreshPenalties =
                        e.NewItems.OfType<SustainedObject>().Any(objItem => objItem.HasSustainingPenalty);
                    break;

                case NotifyCollectionChangedAction.Remove:
                    blnDoRefreshPenalties =
                        e.OldItems.OfType<SustainedObject>().Any(objItem => objItem.HasSustainingPenalty);
                    break;

                case NotifyCollectionChangedAction.Replace:
                    blnDoRefreshPenalties =
                        e.OldItems.OfType<SustainedObject>().Any(objItem => objItem.HasSustainingPenalty) ||
                        e.NewItems.OfType<SustainedObject>().Any(objItem => objItem.HasSustainingPenalty);
                    break;

                case NotifyCollectionChangedAction.Reset:
                    blnDoRefreshPenalties = true;
                    break;
            }
            if (blnDoRefreshPenalties)
                await RefreshSustainingPenaltiesAsync().ConfigureAwait(false);
        }

        [HubTag]
        public AttributeSection AttributeSection
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _objAttributeSection;
            }
        }

        public async ValueTask<AttributeSection> GetAttributeSectionAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _objAttributeSection;
        }

        #region Create, Save, Load and Print Methods

        /// <summary>
        /// Set up a character with a metatype and new attributes to match.
        /// </summary>
        public void Create(string strSelectedMetatypeCategory, string strMetatypeId, string strMetavariantId, XmlNode objXmlMetatype, int intForce, XmlNode xmlQualityDocumentQualitiesNode = null, XmlNode xmlCritterPowerDocumentPowersNode = null, XmlNode xmlSkillsDocumentKnowledgeSkillsNode = null, string strSelectedPossessionMethod = "", CancellationToken token = default)
        {
            using (LockObject.EnterWriteLock(token))
            {
                if (objXmlMetatype == null)
                    throw new ArgumentNullException(nameof(objXmlMetatype));
                // Remove any Improvements the character received from their Metatype.
                ImprovementManager.RemoveImprovements(this,
                    Improvements.Where(objImprovement =>
                        objImprovement.ImproveSource == Improvement.ImprovementSource.Metatype
                        || objImprovement.ImproveSource == Improvement.ImprovementSource.Metavariant).ToList(), token: token);

                // Remove any Qualities the character received from their Metatype, then remove the Quality.
                for (int i = Qualities.Count - 1; i >= 0; --i)
                {
                    if (i >= Qualities.Count)
                        continue;
                    Quality objQuality = Qualities[i];
                    if (objQuality.OriginSource == QualitySource.Metatype ||
                        objQuality.OriginSource == QualitySource.MetatypeRemovable ||
                        objQuality.OriginSource == QualitySource.MetatypeRemovedAtChargen)
                        objQuality.DeleteQuality(token: token);
                }

                // If this is a Shapeshifter, a Metavariant must be selected. Default to Human if None is selected.
                if (strSelectedMetatypeCategory == "Shapeshifter" && strMetavariantId == Guid.Empty.ToString())
                    strMetavariantId =
                        objXmlMetatype.SelectSingleNodeAndCacheExpressionAsNavigator("metavariants/metavariant[name = \"Human\"]/id")?.Value ??
                        string.Empty;
                XmlNode objXmlMetavariant =
                    objXmlMetatype.TryGetNodeByNameOrId("metavariants/metavariant", strMetavariantId);

                // Set Metatype information.
                XmlNode charNode =
                    strSelectedMetatypeCategory == "Shapeshifter" || strMetavariantId == Guid.Empty.ToString()
                        ? objXmlMetatype
                        : objXmlMetavariant ?? objXmlMetatype;
                AttributeSection.Create(charNode, intForce, token: token);
                MetatypeGuid = new Guid(strMetatypeId);
                Metatype = objXmlMetatype["name"]?.InnerText ?? "Human";
                MetatypeCategory = strSelectedMetatypeCategory;
                MetavariantGuid = string.IsNullOrEmpty(strMetavariantId) ? Guid.Empty : new Guid(strMetavariantId);
                Metavariant = MetavariantGuid != Guid.Empty ? objXmlMetavariant?["name"]?.InnerText ?? "None" : "None";
                // We only reverted to the base metatype to get the attributes.
                if (strSelectedMetatypeCategory == "Shapeshifter")
                {
                    charNode = objXmlMetavariant ?? objXmlMetatype;
                }

                Source = charNode["source"]?.InnerText ?? "SR5";
                Page = charNode["page"]?.InnerText ?? "0";
                _intMetatypeBP = 0;
                charNode.TryGetInt32FieldQuickly("karma", ref _intMetatypeBP);
                _intInitiativeDice = Settings.MinInitiativeDice;
                charNode.TryGetInt32FieldQuickly("initiativedice", ref _intInitiativeDice);

                Movement = objXmlMetatype["movement"]?.InnerText ?? string.Empty;

                // Determine if the Metatype has any bonuses.
                XmlNode xmlBonusNode = charNode["bonus"];
                if (xmlBonusNode != null)
                    ImprovementManager.CreateImprovements(this, Improvement.ImprovementSource.Metatype, strMetatypeId,
                        xmlBonusNode, 1, strMetatypeId, token: token);

                List<Weapon> lstWeapons = new List<Weapon>(1);
                // Create the Qualities that come with the Metatype.
                if (xmlQualityDocumentQualitiesNode == null)
                    xmlQualityDocumentQualitiesNode = LoadData("qualities.xml", token: token).SelectSingleNode("/chummer/qualities");
                if (xmlQualityDocumentQualitiesNode != null)
                {
                    using (XmlNodeList xmlQualityList = charNode.SelectNodes("qualities/*/quality"))
                    {
                        if (xmlQualityList != null)
                        {
                            foreach (XmlNode objXmlQualityItem in xmlQualityList)
                            {
                                string strQuality = objXmlQualityItem.InnerText;
                                XmlNode objXmlQuality = xmlQualityDocumentQualitiesNode.TryGetNodeByNameOrId("quality", strQuality);
                                if (objXmlQuality != null)
                                {
                                    Quality objQuality = new Quality(this);
                                    try
                                    {
                                        string strForceValue =
                                            objXmlQualityItem.Attributes["select"]?.InnerText ?? string.Empty;
                                        QualitySource objSource =
                                            objXmlQualityItem.Attributes["removable"]?.InnerText == bool.TrueString
                                                ? QualitySource.MetatypeRemovable
                                                : QualitySource.Metatype;
                                        objQuality.Create(objXmlQuality, objSource, lstWeapons, strForceValue);
                                        objQuality.ContributeToLimit = false;
                                        Qualities.Add(objQuality);
                                    }
                                    catch
                                    {
                                        objQuality.Dispose();
                                        throw;
                                    }
                                }
                            }
                        }
                    }
                }

                //Load any critter powers the character has.
                if (xmlCritterPowerDocumentPowersNode == null)
                    xmlCritterPowerDocumentPowersNode =
                        LoadData("critterpowers.xml", token: token).SelectSingleNode("/chummer/powers");
                if (xmlCritterPowerDocumentPowersNode != null)
                {
                    foreach (XmlNode objXmlPower in charNode.SelectNodes("powers/power"))
                    {
                        string strCritterPower = objXmlPower.InnerText;
                        XmlNode objXmlCritterPower = xmlCritterPowerDocumentPowersNode.TryGetNodeByNameOrId("power", strCritterPower);
                        if (objXmlCritterPower != null)
                        {
                            CritterPower objPower = new CritterPower(this);
                            string strForcedValue = objXmlPower.Attributes["select"]?.InnerText ?? string.Empty;
                            int intRating =
                                CommonFunctions.ExpressionToInt(objXmlPower.Attributes["rating"]?.InnerText, intForce,
                                                                0,
                                                                0, token);

                            objPower.Create(objXmlCritterPower, intRating, strForcedValue);
                            objPower.CountTowardsLimit = false;
                            CritterPowers.Add(objPower);
                            try
                            {
                                ImprovementManager.CreateImprovement(this, objPower.InternalId,
                                                                     Improvement.ImprovementSource.Metatype,
                                                                     string.Empty,
                                                                     Improvement.ImprovementType.CritterPower,
                                                                     string.Empty, token: token);
                            }
                            catch
                            {
                                ImprovementManager.Rollback(this, CancellationToken.None);
                                throw;
                            }

                            ImprovementManager.Commit(this);
                        }
                    }
                }

                //Load any natural weapons the character has.
                foreach (XmlNode objXmlNaturalWeapon in charNode.SelectNodes("naturalweapons/naturalweapon"))
                {
                    Weapon objWeapon = new Weapon(this)
                    {
                        Name = objXmlNaturalWeapon["name"].InnerText,
                        Category = LanguageManager.GetString("Tab_Critter", GlobalSettings.DefaultLanguage, token: token),
                        RangeType = "Melee",
                        Reach =
                            CommonFunctions.ExpressionToInt(objXmlNaturalWeapon["reach"]?.InnerText ?? "0", intForce, 0, 0, token),
                        Damage = objXmlNaturalWeapon["damage"]?.InnerText ?? "({STR})S",
                        Accuracy = objXmlNaturalWeapon["accuracy"]?.InnerText ?? "Physical",
                        AP = objXmlNaturalWeapon["ap"]?.InnerText ?? "0",
                        Mode = "0",
                        RC = "0",
                        Concealability = 0,
                        Avail = "0",
                        Cost = "0",
                        UseSkill = objXmlNaturalWeapon["useskill"]?.InnerText ?? string.Empty,
                        Source = objXmlNaturalWeapon["source"]?.InnerText ?? "SR5",
                        Page = objXmlNaturalWeapon["page"]?.InnerText ?? "0"
                    };
                    Weapons.Add(objWeapon);
                }

                // Add the Unarmed Attack Weapon to the character.
                if (Weapons.All(x => x.Name != "Unarmed Attack"))
                {
                    XmlNode objXmlWeapon = LoadData("weapons.xml", token: token)
                        .SelectSingleNode("/chummer/weapons/weapon[name = \"Unarmed Attack\"]");
                    if (objXmlWeapon != null)
                    {
                        Weapon objWeapon = new Weapon(this);
                        objWeapon.Create(objXmlWeapon, lstWeapons);
                        objWeapon.ParentID =
                            Guid.NewGuid()
                                .ToString("D",
                                    GlobalSettings.InvariantCultureInfo); // Unarmed Attack can never be removed
                        Weapons.Add(objWeapon);
                    }
                }

                //Set the Active Skill Ratings for the Critter.
                foreach (XmlNode xmlSkill in charNode.SelectNodes("skills/skill"))
                {
                    string strRating = xmlSkill.Attributes?["rating"]?.InnerText;
                    bool bImprovementAdded = false;
                    if (!string.IsNullOrEmpty(strRating))
                    {
                        try
                        {
                            ImprovementManager.CreateImprovement(this, xmlSkill.InnerText,
                                                                 Improvement.ImprovementSource.Metatype, string.Empty,
                                                                 Improvement.ImprovementType.SkillLevel,
                                                                 string.Empty,
                                                                 CommonFunctions.ExpressionToInt(
                                                                     strRating, intForce, 0, 0, token), token: token);
                        }
                        catch
                        {
                            ImprovementManager.Rollback(this, CancellationToken.None);
                            throw;
                        }

                        ImprovementManager.Commit(this);
                        bImprovementAdded = true;
                    }

                    string strSkill = xmlSkill.InnerText;
                    string strSpec = xmlSkill.Attributes?["spec"]?.InnerText ?? string.Empty;
                    Skill objSkill = SkillsSection.GetActiveSkill(strSkill, token);

                    if (objSkill == null)
                    {
                        if (ExoticSkill.IsExoticSkillName(this, strSkill, token))
                        {
                            SkillsSection.AddExoticSkill(strSkill, strSpec, token);
                            continue;
                        }

                        if (!bImprovementAdded)
                            continue;

                        //This skill does not yet exist but the datafile asks to improve it.
                        //We need to add it so it is not only improved but also shown on the skills tab.
                        SkillsSection.AddSkills(SkillsSection.FilterOption.Name, strSkill, token);
                        objSkill = SkillsSection.GetActiveSkill(strSkill, token);
                    }

                    if (objSkill != null) //More or less a safeguard only. Should not be empty at that point any longer.
                    {
                        if (string.IsNullOrEmpty(strSpec)) continue;
                        if (objSkill.Specializations.All(x => x.Name != strSpec))
                        {
                            SkillSpecialization objSpec = new SkillSpecialization(this, strSpec);
                            try
                            {
                                objSkill.Specializations.Add(objSpec);
                                try
                                {
                                    ImprovementManager.CreateImprovement(this, strSkill,
                                                                         Improvement.ImprovementSource.Metatype,
                                                                         string.Empty,
                                                                         Improvement.ImprovementType
                                                                             .SkillSpecialization,
                                                                         objSpec.InternalId, token: token);
                                }
                                catch
                                {
                                    ImprovementManager.Rollback(this, CancellationToken.None);
                                    throw;
                                }

                                ImprovementManager.Commit(this);
                            }
                            catch
                            {
                                objSpec.Dispose();
                                throw;
                            }
                        }
                    }
                }

                //Set the Skill Group Ratings for the Critter.
                foreach (XmlNode xmlSkillGroup in charNode.SelectNodes("skills/group"))
                {
                    string strRating = xmlSkillGroup.Attributes?["rating"]?.InnerText;
                    if (!string.IsNullOrEmpty(strRating))
                    {
                        try
                        {
                            ImprovementManager.CreateImprovement(this, xmlSkillGroup.InnerText,
                                                                 Improvement.ImprovementSource.Metatype, string.Empty,
                                                                 Improvement.ImprovementType.SkillGroupLevel,
                                                                 string.Empty,
                                                                 CommonFunctions.ExpressionToInt(
                                                                     strRating, intForce, 0, 0, token), token: token);
                        }
                        catch
                        {
                            ImprovementManager.Rollback(this, CancellationToken.None);
                            throw;
                        }

                        ImprovementManager.Commit(this);
                    }
                }

                //Set the Knowledge Skill Ratings for the Critter.
                if (xmlSkillsDocumentKnowledgeSkillsNode == null)
                    xmlSkillsDocumentKnowledgeSkillsNode =
                        LoadData("skills.xml", token: token).SelectSingleNode("/chummer/knowledgeskills");
                if (xmlSkillsDocumentKnowledgeSkillsNode != null)
                {
                    foreach (XmlNode xmlSkill in charNode.SelectNodes("skills/knowledge"))
                    {
                        string strName = xmlSkill.InnerText;
                        if (string.IsNullOrEmpty(strName))
                            continue;
                        string strRating = xmlSkill.Attributes?["rating"]?.InnerText;
                        if (string.IsNullOrEmpty(strRating))
                            continue;
                        if (SkillsSection.KnowledgeSkills.All(x => x.DictionaryKey != strName))
                        {
                            XmlNode objXmlSkillNode =
                                xmlSkillsDocumentKnowledgeSkillsNode.TryGetNodeByNameOrId("skill", strName);
                            if (objXmlSkillNode != null)
                            {
                                Skill objUncastSkill = Skill.FromData(objXmlSkillNode, this, true);
                                if (objUncastSkill is KnowledgeSkill objSkill)
                                    SkillsSection.KnowledgeSkills.Add(objSkill);
                                else
                                {
                                    Utils.BreakIfDebug();
                                    objUncastSkill.Remove();
                                }
                            }
                            else
                            {
                                KnowledgeSkill objSkill = new KnowledgeSkill(this, strName, true)
                                {
                                    Type = xmlSkill.Attributes?["category"]?.InnerText
                                };
                                SkillsSection.KnowledgeSkills.Add(objSkill);
                            }
                        }

                        try
                        {
                            ImprovementManager.CreateImprovement(this, strName,
                                                                 Improvement.ImprovementSource.Metatype, string.Empty,
                                                                 Improvement.ImprovementType.SkillLevel, string.Empty,
                                                                 CommonFunctions.ExpressionToInt(
                                                                     strRating, intForce, 0, 0, token), token: token);
                        }
                        catch
                        {
                            ImprovementManager.Rollback(this, CancellationToken.None);
                            throw;
                        }

                        ImprovementManager.Commit(this);
                    }
                }

                // Add any Complex Forms the Critter comes with (typically Sprites)
                XmlDocument xmlComplexFormDocument = LoadData("complexforms.xml", token: token);
                foreach (XmlNode xmlComplexForm in charNode.SelectNodes("complexforms/complexform"))
                {
                    XmlNode xmlComplexFormData = xmlComplexFormDocument.TryGetNodeByNameOrId("/chummer/complexforms/complexform", xmlComplexForm.InnerText);
                    if (xmlComplexFormData == null)
                        continue;

                    ComplexForm objComplexform = new ComplexForm(this);
                    objComplexform.Create(xmlComplexFormData);
                    if (objComplexform.InternalId.IsEmptyGuid())
                        continue;
                    objComplexform.Grade = -1;

                    ComplexForms.Add(objComplexform);

                    try
                    {
                        ImprovementManager.CreateImprovement(this, objComplexform.InternalId,
                                                             Improvement.ImprovementSource.Metatype, string.Empty,
                                                             Improvement.ImprovementType.ComplexForm,
                                                             string.Empty, token: token);
                    }
                    catch
                    {
                        ImprovementManager.Rollback(this, CancellationToken.None);
                        throw;
                    }

                    ImprovementManager.Commit(this);
                }

                //Load any cyberware the character has.
                XmlDocument xmlCyberwareDocument = LoadData("cyberware.xml", token: token);
                foreach (XmlNode node in charNode.SelectNodes("cyberwares/cyberware"))
                {
                    XmlNode objXmlCyberwareNode = xmlCyberwareDocument.TryGetNodeByNameOrId("chummer/cyberwares/cyberware", node.InnerText);
                    if (objXmlCyberwareNode == null)
                        continue;
                    Cyberware objWare = new Cyberware(this);
                    string strForcedValue = node.Attributes["select"]?.InnerText ?? string.Empty;
                    int intRating =
                        CommonFunctions.ExpressionToInt(node.Attributes["rating"]?.InnerText, intForce, 0, 0, token);

                    objWare.Create(objXmlCyberwareNode,
                        GetGrades(Improvement.ImprovementSource.Cyberware, true, token)
                            .FirstOrDefault(x => x.Name == "None"), Improvement.ImprovementSource.Metatype, intRating,
                        Weapons, Vehicles, true, true, strForcedValue);
                    Cyberware.Add(objWare);
                    try
                    {
                        ImprovementManager.CreateImprovement(this, objWare.InternalId,
                                                             Improvement.ImprovementSource.Metatype,
                                                             string.Empty, Improvement.ImprovementType.FreeWare,
                                                             string.Empty, token: token);
                    }
                    catch
                    {
                        ImprovementManager.Rollback(this, CancellationToken.None);
                        throw;
                    }

                    ImprovementManager.Commit(this);
                }

                //Load any bioware the character has.
                XmlDocument xmlBiowareDocument = LoadData("bioware.xml", token: token);
                foreach (XmlNode node in charNode.SelectNodes("biowares/bioware"))
                {
                    XmlNode objXmlCyberwareNode = xmlBiowareDocument.TryGetNodeByNameOrId("chummer/biowares/bioware", node.InnerText);
                    if (objXmlCyberwareNode == null)
                        continue;
                    Cyberware objWare = new Cyberware(this);
                    string strForcedValue = node.Attributes["select"]?.InnerText ?? string.Empty;
                    int intRating =
                        CommonFunctions.ExpressionToInt(node.Attributes["rating"]?.InnerText, intForce, 0, 0, token);

                    objWare.Create(objXmlCyberwareNode,
                        GetGrades(Improvement.ImprovementSource.Bioware, true, token)
                            .FirstOrDefault(x => x.Name == "None"), Improvement.ImprovementSource.Metatype, intRating,
                        Weapons, Vehicles, true, true, strForcedValue);
                    Cyberware.Add(objWare);
                    try
                    {
                        ImprovementManager.CreateImprovement(this, objWare.InternalId,
                                                             Improvement.ImprovementSource.Metatype,
                                                             string.Empty, Improvement.ImprovementType.FreeWare,
                                                             string.Empty, token: token);
                    }
                    catch
                    {
                        ImprovementManager.Rollback(this, CancellationToken.None);
                        throw;
                    }

                    ImprovementManager.Commit(this);
                }

                // Add any Advanced Programs the Critter comes with (typically A.I.s)
                XmlDocument xmlAIProgramDocument = LoadData("programs.xml", token: token);
                foreach (XmlNode xmlAIProgram in charNode.SelectNodes("programs/program"))
                {
                    XmlNode xmlAIProgramData = xmlAIProgramDocument.TryGetNodeByNameOrId("chummer/programs/program", xmlAIProgram.InnerText);
                    if (xmlAIProgramData == null)
                        continue;

                    // Check for SelectText.
                    string strExtra = xmlAIProgram.Attributes?["select"]?.InnerText ?? string.Empty;
                    if (xmlAIProgramData.SelectSingleNodeAndCacheExpressionAsNavigator("bonus/selecttext") != null && !string.IsNullOrWhiteSpace(strExtra))
                    {
                        using (ThreadSafeForm<SelectText> frmPickText = ThreadSafeForm<SelectText>.Get(() => new SelectText
                        {
                            Description = string.Format(GlobalSettings.CultureInfo,
                                       LanguageManager.GetString("String_Improvement_SelectText"),
                                       xmlAIProgramData["translate"]?.InnerText ?? xmlAIProgramData["name"]?.InnerText)
                        }))
                        {
                            // Make sure the dialogue window was not canceled.
                            if (frmPickText.ShowDialogSafe(this, token) == DialogResult.Cancel)
                                continue;
                            strExtra = frmPickText.MyForm.SelectedValue;
                        }
                    }

                    AIProgram objAIProgram = new AIProgram(this);
                    objAIProgram.Create(xmlAIProgram, strExtra, false);
                    if (objAIProgram.InternalId.IsEmptyGuid())
                        continue;

                    AIPrograms.Add(objAIProgram);

                    try
                    {
                        ImprovementManager.CreateImprovement(this, objAIProgram.InternalId,
                                                             Improvement.ImprovementSource.Metatype, string.Empty,
                                                             Improvement.ImprovementType.AIProgram,
                                                             string.Empty, token: token);
                    }
                    catch
                    {
                        ImprovementManager.Rollback(this, CancellationToken.None);
                        throw;
                    }

                    ImprovementManager.Commit(this);
                }

                // Add any Gear the Critter comes with (typically Programs for A.I.s)
                XmlDocument xmlGearDocument = LoadData("gear.xml", token: token);
                foreach (XmlNode xmlGear in charNode.SelectNodes("gears/gear"))
                {
                    XmlNode xmlGearData = xmlGearDocument.TryGetNodeByNameOrId(
                        "/chummer/gears/gear", xmlGear["name"].InnerText,
                        "category = " + xmlGear["category"].InnerText.CleanXPath());
                    if (xmlGearData == null)
                        continue;

                    int intRating = 1;
                    if (xmlGear["rating"] != null)
                        intRating = CommonFunctions.ExpressionToInt(xmlGear["rating"].InnerText, intForce, 0, 0, token);
                    decimal decQty = 1.0m;
                    if (xmlGear["quantity"] != null)
                        decQty = CommonFunctions.ExpressionToDecimal(xmlGear["quantity"].InnerText, intForce, token: token);
                    string strForceValue = xmlGear.Attributes?["select"]?.InnerText ?? string.Empty;

                    Gear objGear = new Gear(this);
                    objGear.Create(xmlGearData, intRating, lstWeapons, strForceValue);

                    if (objGear.InternalId.IsEmptyGuid())
                        continue;

                    objGear.Quantity = decQty;

                    // If a Commlink has just been added, see if the character already has one. If not, make it the active Commlink.
                    if (ActiveCommlink == null && objGear.IsCommlink)
                    {
                        objGear.SetActiveCommlink(this, true);
                    }

                    objGear.Cost = "0";
                    // Create any Weapons that came with this Gear.
                    foreach (Weapon objWeapon in lstWeapons)
                        Weapons.Add(objWeapon);

                    objGear.ParentID = Guid.NewGuid().ToString();

                    Gear.Add(objGear);

                    try
                    {
                        ImprovementManager.CreateImprovement(this, objGear.InternalId,
                                                             Improvement.ImprovementSource.Metatype,
                                                             string.Empty, Improvement.ImprovementType.Gear,
                                                             string.Empty, token: token);
                    }
                    catch
                    {
                        ImprovementManager.Rollback(this, CancellationToken.None);
                        throw;
                    }

                    ImprovementManager.Commit(this);
                }

                // Add any created Weapons to the character.
                foreach (Weapon objWeapon in lstWeapons)
                    Weapons.Add(objWeapon);

                // Sprites can never have Physical Attributes
                if (DEPEnabled || strSelectedMetatypeCategory?.EndsWith("Sprite", StringComparison.Ordinal) == true ||
                    strSelectedMetatypeCategory?.EndsWith("Sprites", StringComparison.Ordinal) == true)
                {
                    BOD.AssignBaseKarmaLimits(0, 0, 0, 0, 0);
                    AGI.AssignBaseKarmaLimits(0, 0, 0, 0, 0);
                    REA.AssignBaseKarmaLimits(0, 0, 0, 0, 0);
                    STR.AssignBaseKarmaLimits(0, 0, 0, 0, 0);
                    MAG.AssignBaseKarmaLimits(0, 0, 0, 0, 0);
                    MAGAdept.AssignBaseKarmaLimits(0, 0, 0, 0, 0);
                }

                if (strSelectedMetatypeCategory == "Spirits")
                {
                    XmlNode xmlOptionalPowersNode = charNode["optionalpowers"];
                    if (xmlOptionalPowersNode != null && intForce >= 3)
                    {
                        XmlDocument objDummyDocument = new XmlDocument { XmlResolver = null };
                        //For every 3 full points of Force a spirit has, it may gain one Optional Power.
                        for (int i = intForce; i >= 3; i -= 3)
                        {
                            XmlNode bonusNode = objDummyDocument.CreateNode(XmlNodeType.Element, "bonus", null);
                            XmlNode powerNode =
                                objDummyDocument.ImportNode(xmlOptionalPowersNode.CloneNode(true), true);
                            bonusNode.AppendChild(powerNode);
                            objDummyDocument.AppendChild(bonusNode);
                        }

                        foreach (XmlNode bonusNode in objDummyDocument.SelectNodes("/bonus"))
                            ImprovementManager.CreateImprovements(this, Improvement.ImprovementSource.Metatype,
                                strMetatypeId, bonusNode, 1, strMetatypeId, token: token);
                    }

                    // Remove the Critter's Materialization Power if they have it. Add the Possession or Inhabitation Power if the Possession-based Tradition checkbox is checked.
                    if (xmlCritterPowerDocumentPowersNode != null)
                    {
                        if (!string.IsNullOrEmpty(strSelectedPossessionMethod))
                        {
                            CritterPower objMaterializationPower =
                                CritterPowers.FirstOrDefault(x => x.Name == "Materialization");
                            if (objMaterializationPower != null)
                                CritterPowers.Remove(objMaterializationPower);

                            if (CritterPowers.All(x => !x.Name.Contains(strSelectedPossessionMethod)))
                            {
                                // Add the selected Power.
                                XmlNode objXmlCritterPower =
                                    xmlCritterPowerDocumentPowersNode.TryGetNodeByNameOrId("power", strSelectedPossessionMethod);
                                if (objXmlCritterPower != null)
                                {
                                    CritterPower objPower = new CritterPower(this);
                                    objPower.Create(objXmlCritterPower, 0, string.Empty);
                                    objPower.CountTowardsLimit = false;
                                    CritterPowers.Add(objPower);

                                    try
                                    {
                                        ImprovementManager.CreateImprovement(this, objPower.InternalId,
                                                                             Improvement.ImprovementSource.Metatype,
                                                                             string.Empty,
                                                                             Improvement.ImprovementType.CritterPower,
                                                                             string.Empty, token: token);
                                    }
                                    catch
                                    {
                                        ImprovementManager.Rollback(this, CancellationToken.None);
                                        throw;
                                    }

                                    ImprovementManager.Commit(this);
                                }
                            }
                        }
                        else if (CritterPowers.All(x =>
                                     x.Name != "Materialization" && !x.Name.Contains("Possession") &&
                                     !x.Name.Contains("Inhabitation")))
                        {
                            // Add the Materialization Power.
                            XmlNode objXmlCritterPower =
                                xmlCritterPowerDocumentPowersNode.SelectSingleNode("power[name = \"Materialization\"]");
                            if (objXmlCritterPower != null)
                            {
                                CritterPower objPower = new CritterPower(this);
                                objPower.Create(objXmlCritterPower, 0, string.Empty);
                                objPower.CountTowardsLimit = false;
                                CritterPowers.Add(objPower);

                                try
                                {
                                    ImprovementManager.CreateImprovement(this, objPower.InternalId,
                                                                         Improvement.ImprovementSource.Metatype,
                                                                         string.Empty,
                                                                         Improvement.ImprovementType.CritterPower,
                                                                         string.Empty, token: token);
                                }
                                catch
                                {
                                    ImprovementManager.Rollback(this, CancellationToken.None);
                                    throw;
                                }

                                ImprovementManager.Commit(this);
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Save the Character to an XML file. Returns true if successful.
        /// </summary>
        public bool Save(string strFileName = "", bool addToMRU = true, bool callOnSaveCallBack = true, CancellationToken token = default)
        {
            return Utils.SafelyRunSynchronously(() => SaveCoreAsync(true, strFileName, addToMRU, callOnSaveCallBack, token), token);
        }

        /// <summary>
        /// Save the Character to an XML file. Returns true if successful.
        /// </summary>
        public Task<bool> SaveAsync(string strFileName = "", bool addToMRU = true, bool callOnSaveCallBack = true, CancellationToken token = default)
        {
            return SaveCoreAsync(false, strFileName, addToMRU, callOnSaveCallBack, token);
        }

        /// <summary>
        /// Save the Character to an XML file. Returns true if successful.
        /// </summary>
        private async Task<bool> SaveCoreAsync(bool blnSync, string strFileName, bool addToMRU, bool callOnSaveCallBack,
                                               CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();

            if (string.IsNullOrWhiteSpace(strFileName))
            {
                strFileName = FileName;
                if (string.IsNullOrWhiteSpace(strFileName))
                {
                    return false;
                }
            }
            else if (!strFileName.EndsWith(".chum5", StringComparison.OrdinalIgnoreCase)
                     && !strFileName.EndsWith(".chum5lz", StringComparison.OrdinalIgnoreCase))
            {
                strFileName = Path.GetFileNameWithoutExtension(strFileName) + ".chum5";
                using (blnSync
                           // ReSharper disable once MethodHasAsyncOverload
                           ? EnterReadLock.Enter(LockObject, token)
                           : await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                {
                    if (!string.IsNullOrEmpty(FileName)
                        && FileName.EndsWith(".chum5lz", StringComparison.OrdinalIgnoreCase))
                        strFileName += "lz";
                }
            }

            // ReSharper disable once MethodHasAsyncOverload
            using (blnSync
                       ? EnterReadLock.Enter(LockObject, token)
                       : await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                bool blnErrorFree = true;

                if (blnSync)
                    DoSave();
                else
                    await Task.Run(DoSaveAsync, token).ConfigureAwait(false);

                void DoSave()
                {
                    using (RecyclableMemoryStream objStream = new RecyclableMemoryStream(Utils.MemoryStreamManager))
                    {
                        using (XmlWriter objWriter = Utils.GetStandardXmlWriter(objStream))
                        {
                            // ReSharper disable AccessToDisposedClosure
                            objWriter.WriteStartDocument();

                            // <character>
                            objWriter.WriteStartElement("character");

                            // <createdversion />
                            objWriter.WriteElementString("createdversion", _strVersionCreated);
                            // <minimumappversion />
                            objWriter.WriteElementString("minimumappversion", "5.214.1");
                            // <appversion />
                            objWriter.WriteElementString("appversion",
                                                         Application.ProductVersion.FastEscapeOnceFromStart("0.0."));
                            // <gameedition />
                            objWriter.WriteElementString("gameedition", "SR5");

                            // <settings />
                            objWriter.WriteElementString("settings", _strSettingsKey);
                            // <settingshashcode />
                            objWriter.WriteElementString("settingshashcode",
                                                         Settings.GetEquatableHashCode(token)
                                                                 .ToString(GlobalSettings.InvariantCultureInfo));
                            // <buildmethod />
                            objWriter.WriteElementString("buildmethod", Settings.BuildMethod.ToString());

                            // <sources>
                            objWriter.WriteStartElement("sources");
                            foreach (string strBook in Settings.Books)
                            {
                                objWriter.WriteElementString("source", strBook);
                            }

                            // </sources>
                            objWriter.WriteEndElement();

                            if (Settings.EnabledCustomDataDirectoryInfos.Count > 0)
                            {
                                // <customdatadirectorynames>
                                objWriter.WriteStartElement("customdatadirectorynames");
                                foreach (string strDirectoryName in Settings.EnabledCustomDataDirectoryInfos.Select(x =>
                                             x.Name))
                                {
                                    objWriter.WriteElementString("directoryname", strDirectoryName);
                                }

                                // </customdatadirectorynames>
                                objWriter.WriteEndElement();
                            }

                            // <metatype />
                            objWriter.WriteElementString("metatype", _strMetatype);
                            // <metatypeid />
                            objWriter.WriteElementString("metatypeid",
                                                         _guiMetatype.ToString(
                                                             "D", GlobalSettings.InvariantCultureInfo));
                            // <metatypebp />
                            objWriter.WriteElementString("metatypebp",
                                                         _intMetatypeBP.ToString(GlobalSettings.InvariantCultureInfo));
                            // <metavariant />
                            objWriter.WriteElementString("metavariant", _strMetavariant);
                            // <metavariantid />
                            objWriter.WriteElementString("metavariantid",
                                                         _guiMetavariant.ToString(
                                                             "D", GlobalSettings.InvariantCultureInfo));
                            // <metatypecategory />
                            objWriter.WriteElementString("metatypecategory", _strMetatypeCategory);
                            // <movement />
                            objWriter.WriteElementString("movement", _strMovement);
                            // <walk />
                            objWriter.WriteElementString("walk", _strWalk);
                            // <run />
                            objWriter.WriteElementString("run", _strRun);
                            // <sprint />
                            objWriter.WriteElementString("sprint", _strSprint);
                            // <walk />
                            objWriter.WriteElementString("walkalt", _strWalk);
                            // <run />
                            objWriter.WriteElementString("runalt", _strRun);
                            // <sprint />
                            objWriter.WriteElementString("sprintalt", _strSprint);
                            // <initiativedice />
                            objWriter.WriteElementString("initiativedice",
                                                         _intInitiativeDice.ToString(
                                                             GlobalSettings.InvariantCultureInfo));

                            // <prioritymetatype />
                            objWriter.WriteElementString("prioritymetatype", _strPriorityMetatype);
                            // <priorityattributes />
                            objWriter.WriteElementString("priorityattributes", _strPriorityAttributes);
                            // <priorityspecial />
                            objWriter.WriteElementString("priorityspecial", _strPrioritySpecial);
                            // <priorityskills />
                            objWriter.WriteElementString("priorityskills", _strPrioritySkills);
                            // <priorityresources />
                            objWriter.WriteElementString("priorityresources", _strPriorityResources);
                            // <priorityresources />
                            objWriter.WriteElementString("prioritytalent", _strPriorityTalent);
                            // <priorityskills >
                            objWriter.WriteStartElement("priorityskills");
                            foreach (string strSkill in _lstPrioritySkills)
                            {
                                objWriter.WriteElementString("priorityskill", strSkill);
                            }

                            // </priorityskills>
                            objWriter.WriteEndElement();

                            // <essenceatspecialstart />
                            objWriter.WriteElementString("essenceatspecialstart",
                                                         _decEssenceAtSpecialStart.ToString(
                                                             GlobalSettings.InvariantCultureInfo));

                            // <name />
                            objWriter.WriteElementString("name", _strName);
                            SaveMugshots(objWriter, token);

                            // <gender />
                            objWriter.WriteElementString("gender", _strGender);
                            // <age />
                            objWriter.WriteElementString("age", _strAge);
                            // <eyes />
                            objWriter.WriteElementString("eyes", _strEyes);
                            // <height />
                            objWriter.WriteElementString("height", _strHeight);
                            // <weight />
                            objWriter.WriteElementString("weight", _strWeight);
                            // <skin />
                            objWriter.WriteElementString("skin", _strSkin);
                            // <hair />
                            objWriter.WriteElementString("hair", _strHair);
                            // <description />
                            objWriter.WriteElementString("description", _strDescription);
                            // <background />
                            objWriter.WriteElementString("background", _strBackground);
                            // <concept />
                            objWriter.WriteElementString("concept", _strConcept);
                            // <notes />
                            objWriter.WriteElementString("notes", _strNotes.CleanOfInvalidUnicodeChars());
                            // <alias />
                            objWriter.WriteElementString("alias", _strAlias);
                            // <playername />
                            objWriter.WriteElementString("playername", _strPlayerName);
                            // <gamenotes />
                            objWriter.WriteElementString("gamenotes", _strGameNotes);
                            // <primaryarm />
                            objWriter.WriteElementString("primaryarm", _strPrimaryArm);

                            // <ignorerules />
                            if (_blnIgnoreRules)
                                objWriter.WriteElementString("ignorerules",
                                                             _blnIgnoreRules.ToString(
                                                                 GlobalSettings.InvariantCultureInfo));
                            // <iscritter />
                            if (_blnIsCritter)
                                objWriter.WriteElementString("iscritter",
                                                             _blnIsCritter.ToString(
                                                                 GlobalSettings.InvariantCultureInfo));
                            if (_blnPossessed)
                                objWriter.WriteElementString("possessed",
                                                             _blnPossessed.ToString(
                                                                 GlobalSettings.InvariantCultureInfo));
                            // <karma />
                            objWriter.WriteElementString(
                                "karma", _intKarma.ToString(GlobalSettings.InvariantCultureInfo));
                            // <special />
                            objWriter.WriteElementString("special",
                                                         _intSpecial.ToString(GlobalSettings.InvariantCultureInfo));
                            // <totalspecial />
                            objWriter.WriteElementString("totalspecial",
                                                         _intTotalSpecial.ToString(
                                                             GlobalSettings.InvariantCultureInfo));
                            // <totalattributes />
                            objWriter.WriteElementString("totalattributes",
                                                         _intTotalAttributes.ToString(
                                                             GlobalSettings.InvariantCultureInfo));
                            // <edgeused />
                            objWriter.WriteElementString("edgeused",
                                                         _intEdgeUsed.ToString(GlobalSettings.InvariantCultureInfo));
                            // <contactpoints />
                            objWriter.WriteElementString("contactpoints",
                                                         _intCachedContactPoints.ToString(
                                                             GlobalSettings.InvariantCultureInfo));
                            // <contactpointsused />
                            objWriter.WriteElementString("contactpointsused",
                                                         _intContactPointsUsed.ToString(
                                                             GlobalSettings.InvariantCultureInfo));
                            // <spelllimit />
                            objWriter.WriteElementString("spelllimit",
                                                         _intFreeSpells.ToString(GlobalSettings.InvariantCultureInfo));
                            // <cfplimit />
                            objWriter.WriteElementString("cfplimit",
                                                         _intCFPLimit.ToString(GlobalSettings.InvariantCultureInfo));
                            // <totalaiprogramlimit />
                            objWriter.WriteElementString("ainormalprogramlimit",
                                                         _intAINormalProgramLimit.ToString(
                                                             GlobalSettings.InvariantCultureInfo));
                            // <aiadvancedprogramlimit />
                            objWriter.WriteElementString("aiadvancedprogramlimit",
                                                         _intAIAdvancedProgramLimit.ToString(
                                                             GlobalSettings.InvariantCultureInfo));
                            // <currentcounterspellingdice />
                            objWriter.WriteElementString("currentcounterspellingdice",
                                                         _intCurrentCounterspellingDice.ToString(
                                                             GlobalSettings.InvariantCultureInfo));
                            // <currentliftcarryhits />
                            objWriter.WriteElementString("currentliftcarryhits",
                                                         _intCurrentLiftCarryHits.ToString(
                                                             GlobalSettings.InvariantCultureInfo));
                            // <carrylimit />
                            objWriter.WriteElementString("basecarrylimit",
                                                         _decCachedBaseCarryLimit.ToString(
                                                             GlobalSettings.InvariantCultureInfo));
                            // <liftlimit />
                            objWriter.WriteElementString("baseliftlimit",
                                                         _decCachedBaseLiftLimit.ToString(
                                                             GlobalSettings.InvariantCultureInfo));
                            // <totalcarriedweight />
                            objWriter.WriteElementString("totalcarriedweight",
                                                         _decCachedTotalCarriedWeight.ToString(
                                                             GlobalSettings.InvariantCultureInfo));
                            // <encumbranceinterval />
                            objWriter.WriteElementString("encumbranceinterval",
                                                         _decCachedEncumbranceInterval.ToString(
                                                             GlobalSettings.InvariantCultureInfo));
                            // <streetcred />
                            objWriter.WriteElementString("streetcred",
                                                         _intStreetCred.ToString(GlobalSettings.InvariantCultureInfo));
                            // <notoriety />
                            objWriter.WriteElementString("notoriety",
                                                         _intNotoriety.ToString(GlobalSettings.InvariantCultureInfo));
                            // <publicaware />
                            objWriter.WriteElementString("publicawareness",
                                                         _intPublicAwareness.ToString(
                                                             GlobalSettings.InvariantCultureInfo));
                            // <burntstreetcred />
                            objWriter.WriteElementString("burntstreetcred",
                                                         _intBurntStreetCred.ToString(
                                                             GlobalSettings.InvariantCultureInfo));
                            // <baseastralreputation />
                            objWriter.WriteElementString("baseastralreputation",
                                                         _intBaseAstralReputation.ToString(
                                                             GlobalSettings.InvariantCultureInfo));
                            // <basewildreputation />
                            objWriter.WriteElementString("basewildreputation",
                                                         _intBaseWildReputation.ToString(
                                                             GlobalSettings.InvariantCultureInfo));
                            // <created />
                            objWriter.WriteElementString("created",
                                                         _blnCreated.ToString(GlobalSettings.InvariantCultureInfo));
                            // <nuyen />
                            objWriter.WriteElementString(
                                "nuyen", _decNuyen.ToString(GlobalSettings.InvariantCultureInfo));
                            // <startingnuyen />
                            objWriter.WriteElementString("startingnuyen",
                                                         _decStartingNuyen.ToString(
                                                             GlobalSettings.InvariantCultureInfo));

                            // <nuyenbp />
                            objWriter.WriteElementString("nuyenbp",
                                                         _decNuyenBP.ToString(GlobalSettings.InvariantCultureInfo));

                            // <adept />
                            objWriter.WriteElementString("adept",
                                                         _blnAdeptEnabled.ToString(
                                                             GlobalSettings.InvariantCultureInfo));
                            // <magician />
                            objWriter.WriteElementString("magician",
                                                         _blnMagicianEnabled.ToString(
                                                             GlobalSettings.InvariantCultureInfo));
                            // <technomancer />
                            objWriter.WriteElementString("technomancer",
                                                         _blnTechnomancerEnabled.ToString(
                                                             GlobalSettings.InvariantCultureInfo));
                            // <ai />
                            objWriter.WriteElementString("ai",
                                                         _blnAdvancedProgramsEnabled.ToString(
                                                             GlobalSettings.InvariantCultureInfo));
                            // <cyberwaredisabled />
                            objWriter.WriteElementString("cyberwaredisabled",
                                                         _blnCyberwareDisabled.ToString(
                                                             GlobalSettings.InvariantCultureInfo));
                            // <initiationdisabled />
                            objWriter.WriteElementString("initiationdisabled",
                                                         _blnInitiationDisabled.ToString(
                                                             GlobalSettings.InvariantCultureInfo));
                            // <critter />
                            objWriter.WriteElementString("critter",
                                                         _blnCritterEnabled.ToString(
                                                             GlobalSettings.InvariantCultureInfo));

                            // <prototypetranshuman />
                            objWriter.WriteElementString("prototypetranshuman",
                                                         _decPrototypeTranshuman.ToString(
                                                             GlobalSettings.InvariantCultureInfo));

                            // <attributes>
                            objWriter.WriteStartElement("attributes");
                            AttributeSection.Save(objWriter, token);
                            // </attributes>
                            objWriter.WriteEndElement();

                            // <magenabled />
                            objWriter.WriteElementString("magenabled",
                                                         _blnMAGEnabled.ToString(GlobalSettings.InvariantCultureInfo));
                            // <initiategrade />
                            objWriter.WriteElementString("initiategrade",
                                                         _intInitiateGrade.ToString(
                                                             GlobalSettings.InvariantCultureInfo));
                            // <resenabled />
                            objWriter.WriteElementString("resenabled",
                                                         _blnRESEnabled.ToString(GlobalSettings.InvariantCultureInfo));
                            // <submersiongrade />
                            objWriter.WriteElementString("submersiongrade",
                                                         _intSubmersionGrade.ToString(
                                                             GlobalSettings.InvariantCultureInfo));
                            // <depenabled />
                            objWriter.WriteElementString("depenabled",
                                                         _blnDEPEnabled.ToString(GlobalSettings.InvariantCultureInfo));
                            // <groupmember />
                            objWriter.WriteElementString("groupmember",
                                                         _blnGroupMember.ToString(GlobalSettings.InvariantCultureInfo));
                            // <groupname />
                            objWriter.WriteElementString("groupname", _strGroupName);
                            // <groupnotes />
                            objWriter.WriteElementString("groupnotes", _strGroupNotes);

                            // External reader friendly stuff.
                            objWriter.WriteElementString("totaless",
                                                         Essence(token: token)
                                                             .ToString(GlobalSettings.InvariantCultureInfo));

                            // Write out the Mystic Adept MAG split info.
                            if (_blnAdeptEnabled && _blnMagicianEnabled)
                            {
                                objWriter.WriteElementString("magsplitadept",
                                                             _intMAGAdept.ToString(
                                                                 GlobalSettings.InvariantCultureInfo));
                                objWriter.WriteElementString("magsplitmagician",
                                                             _intMAGMagician.ToString(
                                                                 GlobalSettings.InvariantCultureInfo));
                            }

                            _objTradition?.Save(objWriter);

                            // Condition Monitor Progress.
                            // <physicalcmfilled />
                            objWriter.WriteElementString("physicalcmfilled",
                                                         _intPhysicalCMFilled.ToString(
                                                             GlobalSettings.InvariantCultureInfo));
                            // <stuncmfilled />
                            objWriter.WriteElementString("stuncmfilled",
                                                         _intStunCMFilled.ToString(
                                                             GlobalSettings.InvariantCultureInfo));

                            //<psyche />
                            objWriter.WriteElementString("psyche",
                                                         _blnPsycheActive.ToString(
                                                             GlobalSettings.InvariantCultureInfo));

                            ///////////////////////////////////////////SKILLS

                            SkillsSection.Save(objWriter);

                            //Write copy of old skill groups, to not totally fuck a file if error
                            _oldSkillGroupBackup?.WriteTo(objWriter);
                            _oldSkillsBackup?.WriteTo(objWriter);

                            ///////////////////////////////////////////SKILLS

                            // <contacts>
                            objWriter.WriteStartElement("contacts");
                            _lstContacts.ForEach(x => x.Save(objWriter, token), token);
                            objWriter.WriteEndElement();

                            // <spells>
                            objWriter.WriteStartElement("spells");
                            _lstSpells.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <foci>
                            objWriter.WriteStartElement("foci");
                            _lstFoci.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <stackedfoci>
                            objWriter.WriteStartElement("stackedfoci");
                            _lstStackedFoci.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <powers>
                            objWriter.WriteStartElement("powers");
                            _lstPowers.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <spirits>
                            objWriter.WriteStartElement("spirits");
                            _lstSpirits.ForEach(x => x.Save(objWriter, token), token);
                            objWriter.WriteEndElement();

                            // <complexforms>
                            objWriter.WriteStartElement("complexforms");
                            _lstComplexForms.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <aiprograms>
                            objWriter.WriteStartElement("aiprograms");
                            _lstAIPrograms.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <martialarts>
                            objWriter.WriteStartElement("martialarts");
                            _lstMartialArts.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <limitmodifiers>
                            objWriter.WriteStartElement("limitmodifiers");
                            _lstLimitModifiers.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <armors>
                            objWriter.WriteStartElement("armors");
                            _lstArmor.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <weapons>
                            objWriter.WriteStartElement("weapons");
                            _lstWeapons.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <cyberwares>
                            objWriter.WriteStartElement("cyberwares");
                            _lstCyberware.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <qualities>
                            objWriter.WriteStartElement("qualities");
                            _lstQualities.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <lifestyles>
                            objWriter.WriteStartElement("lifestyles");
                            _lstLifestyles.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <gears>
                            objWriter.WriteStartElement("gears");
                            _lstGear.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <vehicles>
                            objWriter.WriteStartElement("vehicles");
                            _lstVehicles.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <metamagics>
                            objWriter.WriteStartElement("metamagics");
                            _lstMetamagics.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <arts>
                            objWriter.WriteStartElement("arts");
                            _lstArts.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <enhancements>
                            objWriter.WriteStartElement("enhancements");
                            _lstEnhancements.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <critterpowers>
                            objWriter.WriteStartElement("critterpowers");
                            _lstCritterPowers.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <initiationgrades>
                            objWriter.WriteStartElement("initiationgrades");
                            _lstInitiationGrades.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <improvements>
                            objWriter.WriteStartElement("improvements");
                            _lstImprovements.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <sustained>
                            objWriter.WriteStartElement("sustainedobjects");
                            _lstSustainedObjects.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <drugs>
                            objWriter.WriteStartElement("drugs");
                            _lstDrugs.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <mentorspirits>
                            objWriter.WriteStartElement("mentorspirits");
                            _lstMentorSpirits.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <expenses>
                            objWriter.WriteStartElement("expenses");
                            _lstExpenseLog.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <locations>
                            objWriter.WriteStartElement("gearlocations");
                            _lstGearLocations.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <armorlocations>
                            objWriter.WriteStartElement("armorlocations");
                            _lstArmorLocations.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <vehiclelocations>
                            objWriter.WriteStartElement("vehiclelocations");
                            _lstVehicleLocations.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <weaponlocations>
                            objWriter.WriteStartElement("weaponlocations");
                            _lstWeaponLocations.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            // <improvementgroups>
                            objWriter.WriteStartElement("improvementgroups");
                            _lstImprovementGroups.ForEach(strGroup => objWriter.WriteElementString("improvementgroup", strGroup), token);
                            objWriter.WriteEndElement();

                            // <calendar>
                            objWriter.WriteStartElement("calendar");
                            _lstCalendar.ForEach(x => x.Save(objWriter), token);
                            objWriter.WriteEndElement();

                            //Plugins
                            IReadOnlyList<IPlugin> lstActivePlugins = Program.PluginLoader?.MyActivePlugins;
                            if (lstActivePlugins?.Count > 0)
                            {
                                // <plugins>
                                objWriter.WriteStartElement("plugins");
                                foreach (IPlugin plugin in lstActivePlugins)
                                {
                                    try
                                    {
                                        System.Reflection.AssemblyName objPluginAssemblyName = plugin.GetPluginAssembly().GetName();
                                        objWriter.WriteStartElement(objPluginAssemblyName.Name);
                                        objWriter.WriteAttributeString(
                                            "version", objPluginAssemblyName.Version.ToString());
                                        objWriter.WriteString(plugin.GetSaveToFileElement(this));
                                        objWriter.WriteEndElement();
                                    }
                                    catch (Exception e)
                                    {
                                        Log.Warn(
                                            e, "Exception while writing saveFileElement for plugin " + plugin + ": ");
                                    }
                                }

                                //</plugins>
                                objWriter.WriteEndElement();
                            }

                            //calculatedValues
                            objWriter.WriteStartElement("calculatedvalues");
                            objWriter.WriteComment(
                                "these values are not loaded and only stored here for third parties, who parse this files (to not have to calculate them themselves)");
                            objWriter.WriteElementString("physicalcm",
                                                         PhysicalCM.ToString(GlobalSettings.InvariantCultureInfo));
                            objWriter.WriteElementString("physicalcmthresholdoffset",
                                                         PhysicalCMThresholdOffset.ToString(
                                                             GlobalSettings.InvariantCultureInfo));
                            objWriter.WriteElementString("physicalcmoverflow",
                                                         CMOverflow.ToString(GlobalSettings.InvariantCultureInfo));
                            objWriter.WriteElementString(
                                "stuncm", StunCM.ToString(GlobalSettings.InvariantCultureInfo));
                            objWriter.WriteElementString("stuncmthresholdoffset",
                                                         StunCMThresholdOffset.ToString(
                                                             GlobalSettings.InvariantCultureInfo));
                            objWriter.WriteEndElement();
                            // </calculatedValues>

                            // </character>
                            objWriter.WriteEndElement();

                            objWriter.WriteEndDocument();
                            objWriter.Flush();
                            // ReSharper restore AccessToDisposedClosure
                        }

                        objStream.Seek(0, SeekOrigin.Begin);

                        // Validate that the character can save properly. If there's no error, save the file to the listed file location.
                        try
                        {
                            XmlDocument objDoc = new XmlDocument {XmlResolver = null};
                            using (XmlReader objXmlReader
                                   = XmlReader.Create(objStream, GlobalSettings.SafeXmlReaderSettings))
                                objDoc.Load(objXmlReader);
                            using (FileStream objFileStream
                                   = new FileStream(strFileName, FileMode.Create, FileAccess.Write, FileShare.None))
                            {
                                if (strFileName.EndsWith(".chum5", StringComparison.OrdinalIgnoreCase))
                                    objDoc.Save(objFileStream);
                                else
                                {
                                    objStream.Seek(0, SeekOrigin.Begin);
                                    objStream.CompressToLzmaFile(objFileStream, GlobalSettings.Chum5lzCompressionLevel);
                                }
                            }
                        }
                        catch (IOException e)
                        {
                            Log.Error(e);
                            if (Utils.IsUnitTest)
                                throw;
                            // ReSharper disable once MethodHasAsyncOverload
                            Program.ShowScrollableMessageBox(
                                LanguageManager.GetString("Message_Save_Error_Warning", token: token));
                            blnErrorFree = false;
                        }
                        catch (XmlException ex)
                        {
                            Log.Warn(ex);
                            if (Utils.IsUnitTest)
                                throw;
                            // ReSharper disable once MethodHasAsyncOverload
                            Program.ShowScrollableMessageBox(
                                LanguageManager.GetString("Message_Save_Error_Warning", token: token));
                            blnErrorFree = false;
                        }
                        catch (UnauthorizedAccessException) when (!Utils.IsUnitTest)
                        {
                            // ReSharper disable once MethodHasAsyncOverload
                            Program.ShowScrollableMessageBox(
                                LanguageManager.GetString("Message_Save_Error_Warning", token: token));
                            blnErrorFree = false;
                        }
                    }
                }

                async Task DoSaveAsync()
                {
                    using (RecyclableMemoryStream objStream = new RecyclableMemoryStream(Utils.MemoryStreamManager))
                    {
                        using (XmlWriter objWriter = Utils.GetStandardXmlWriter(objStream))
                        {
                            await objWriter.WriteStartDocumentAsync().ConfigureAwait(false);

                            // <character>
                            await objWriter.WriteStartElementAsync("character", token: token)
                                           .ConfigureAwait(false);

                            // <createdversion />
                            await objWriter
                                  .WriteElementStringAsync("createdversion", _strVersionCreated, token: token)
                                  .ConfigureAwait(false);
                            // <minimumappversion />
                            await objWriter.WriteElementStringAsync("minimumappversion", "5.214.1", token: token)
                                           .ConfigureAwait(false);
                            // <appversion />
                            await objWriter.WriteElementStringAsync("appversion",
                                                                    Application.ProductVersion.FastEscapeOnceFromStart(
                                                                        "0.0."), token: token)
                                           .ConfigureAwait(false);
                            // <gameedition />
                            await objWriter.WriteElementStringAsync("gameedition", "SR5", token: token)
                                           .ConfigureAwait(false);

                            // <settings />
                            await objWriter.WriteElementStringAsync("settings", _strSettingsKey, token: token)
                                           .ConfigureAwait(false);
                            CharacterSettings objSettings
                                = await GetSettingsAsync(token).ConfigureAwait(false);
                            // <settingshashcode />
                            await objWriter
                                  .WriteElementStringAsync("settingshashcode",
                                                           (await objSettings.GetEquatableHashCodeAsync(token)
                                                                             .ConfigureAwait(false))
                                                           .ToString(GlobalSettings.InvariantCultureInfo),
                                                           token: token).ConfigureAwait(false);
                            // <buildmethod />
                            await objWriter
                                  .WriteElementStringAsync("buildmethod", (await objSettings.GetBuildMethodAsync(token).ConfigureAwait(false)).ToString(),
                                                           token: token).ConfigureAwait(false);

                            // <sources>
                            await objWriter.WriteStartElementAsync("sources", token: token).ConfigureAwait(false);
                            foreach (string strBook in await objSettings.GetBooksAsync(token).ConfigureAwait(false))
                            {
                                await objWriter.WriteElementStringAsync("source", strBook, token: token)
                                               .ConfigureAwait(false);
                            }

                            // </sources>
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            IReadOnlyList<CustomDataDirectoryInfo> lstInfos = await objSettings.GetEnabledCustomDataDirectoryInfosAsync(token)
                                                                                               .ConfigureAwait(false);
                            if (lstInfos.Count > 0)
                            {
                                // <customdatadirectorynames>
                                await objWriter.WriteStartElementAsync("customdatadirectorynames", token: token)
                                               .ConfigureAwait(false);
                                foreach (string strDirectoryName in lstInfos.Select(x => x.Name))
                                {
                                    await objWriter
                                          .WriteElementStringAsync("directoryname", strDirectoryName, token: token)
                                          .ConfigureAwait(false);
                                }

                                // </customdatadirectorynames>
                                await objWriter.WriteEndElementAsync().ConfigureAwait(false);
                            }

                            // <metatype />
                            await objWriter.WriteElementStringAsync("metatype", _strMetatype, token: token)
                                           .ConfigureAwait(false);
                            // <metatypeid />
                            await objWriter.WriteElementStringAsync("metatypeid",
                                                                    _guiMetatype.ToString(
                                                                        "D", GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <metatypebp />
                            await objWriter.WriteElementStringAsync("metatypebp",
                                                                    _intMetatypeBP.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <metavariant />
                            await objWriter.WriteElementStringAsync("metavariant", _strMetavariant, token: token)
                                           .ConfigureAwait(false);
                            // <metavariantid />
                            await objWriter.WriteElementStringAsync("metavariantid",
                                                                    _guiMetavariant.ToString(
                                                                        "D", GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <metatypecategory />
                            await objWriter
                                  .WriteElementStringAsync("metatypecategory", _strMetatypeCategory, token: token)
                                  .ConfigureAwait(false);
                            // <movement />
                            await objWriter.WriteElementStringAsync("movement", _strMovement, token: token)
                                           .ConfigureAwait(false);
                            // <walk />
                            await objWriter.WriteElementStringAsync("walk", _strWalk, token: token)
                                           .ConfigureAwait(false);
                            // <run />
                            await objWriter.WriteElementStringAsync("run", _strRun, token: token)
                                           .ConfigureAwait(false);
                            // <sprint />
                            await objWriter.WriteElementStringAsync("sprint", _strSprint, token: token)
                                           .ConfigureAwait(false);
                            // <walk />
                            await objWriter.WriteElementStringAsync("walkalt", _strWalk, token: token)
                                           .ConfigureAwait(false);
                            // <run />
                            await objWriter.WriteElementStringAsync("runalt", _strRun, token: token)
                                           .ConfigureAwait(false);
                            // <sprint />
                            await objWriter.WriteElementStringAsync("sprintalt", _strSprint, token: token)
                                           .ConfigureAwait(false);
                            // <initiativedice />
                            await objWriter.WriteElementStringAsync("initiativedice",
                                                                    _intInitiativeDice.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);

                            // <prioritymetatype />
                            await objWriter
                                  .WriteElementStringAsync("prioritymetatype", _strPriorityMetatype, token: token)
                                  .ConfigureAwait(false);
                            // <priorityattributes />
                            await objWriter
                                  .WriteElementStringAsync("priorityattributes", _strPriorityAttributes,
                                                           token: token).ConfigureAwait(false);
                            // <priorityspecial />
                            await objWriter
                                  .WriteElementStringAsync("priorityspecial", _strPrioritySpecial, token: token)
                                  .ConfigureAwait(false);
                            // <priorityskills />
                            await objWriter
                                  .WriteElementStringAsync("priorityskills", _strPrioritySkills, token: token)
                                  .ConfigureAwait(false);
                            // <priorityresources />
                            await objWriter
                                  .WriteElementStringAsync("priorityresources", _strPriorityResources,
                                                           token: token).ConfigureAwait(false);
                            // <priorityresources />
                            await objWriter
                                  .WriteElementStringAsync("prioritytalent", _strPriorityTalent, token: token)
                                  .ConfigureAwait(false);
                            // <priorityskills >
                            await objWriter.WriteStartElementAsync("priorityskills", token: token)
                                           .ConfigureAwait(false);
                            foreach (string strSkill in _lstPrioritySkills)
                            {
                                await objWriter.WriteElementStringAsync("priorityskill", strSkill, token: token)
                                               .ConfigureAwait(false);
                            }

                            // </priorityskills>
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <essenceatspecialstart />
                            await objWriter.WriteElementStringAsync("essenceatspecialstart",
                                                                    _decEssenceAtSpecialStart.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);

                            // <name />
                            await objWriter.WriteElementStringAsync("name", _strName, token: token)
                                           .ConfigureAwait(false);
                            await SaveMugshotsAsync(objWriter, token).ConfigureAwait(false);

                            // <gender />
                            await objWriter.WriteElementStringAsync("gender", _strGender, token: token)
                                           .ConfigureAwait(false);
                            // <age />
                            await objWriter.WriteElementStringAsync("age", _strAge, token: token)
                                           .ConfigureAwait(false);
                            // <eyes />
                            await objWriter.WriteElementStringAsync("eyes", _strEyes, token: token)
                                           .ConfigureAwait(false);
                            // <height />
                            await objWriter.WriteElementStringAsync("height", _strHeight, token: token)
                                           .ConfigureAwait(false);
                            // <weight />
                            await objWriter.WriteElementStringAsync("weight", _strWeight, token: token)
                                           .ConfigureAwait(false);
                            // <skin />
                            await objWriter.WriteElementStringAsync("skin", _strSkin, token: token)
                                           .ConfigureAwait(false);
                            // <hair />
                            await objWriter.WriteElementStringAsync("hair", _strHair, token: token)
                                           .ConfigureAwait(false);
                            // <description />
                            await objWriter.WriteElementStringAsync("description", _strDescription, token: token)
                                           .ConfigureAwait(false);
                            // <background />
                            await objWriter.WriteElementStringAsync("background", _strBackground, token: token)
                                           .ConfigureAwait(false);
                            // <concept />
                            await objWriter.WriteElementStringAsync("concept", _strConcept, token: token)
                                           .ConfigureAwait(false);
                            // <notes />
                            await objWriter
                                  .WriteElementStringAsync("notes", _strNotes.CleanOfInvalidUnicodeChars(),
                                                           token: token).ConfigureAwait(false);
                            // <alias />
                            await objWriter.WriteElementStringAsync("alias", _strAlias, token: token)
                                           .ConfigureAwait(false);
                            // <playername />
                            await objWriter.WriteElementStringAsync("playername", _strPlayerName, token: token)
                                           .ConfigureAwait(false);
                            // <gamenotes />
                            await objWriter.WriteElementStringAsync("gamenotes", _strGameNotes, token: token)
                                           .ConfigureAwait(false);
                            // <primaryarm />
                            await objWriter.WriteElementStringAsync("primaryarm", _strPrimaryArm, token: token)
                                           .ConfigureAwait(false);

                            // <ignorerules />
                            if (_blnIgnoreRules)
                                await objWriter.WriteElementStringAsync("ignorerules",
                                                                        _blnIgnoreRules.ToString(
                                                                            GlobalSettings.InvariantCultureInfo),
                                                                        token: token).ConfigureAwait(false);
                            // <iscritter />
                            if (_blnIsCritter)
                                await objWriter.WriteElementStringAsync("iscritter",
                                                                        _blnIsCritter.ToString(
                                                                            GlobalSettings.InvariantCultureInfo),
                                                                        token: token).ConfigureAwait(false);
                            if (_blnPossessed)
                                await objWriter.WriteElementStringAsync("possessed",
                                                                        _blnPossessed.ToString(
                                                                            GlobalSettings.InvariantCultureInfo),
                                                                        token: token).ConfigureAwait(false);
                            // <karma />
                            await objWriter.WriteElementStringAsync(
                                               "karma", _intKarma.ToString(GlobalSettings.InvariantCultureInfo),
                                               token: token)
                                           .ConfigureAwait(false);
                            // <special />
                            await objWriter.WriteElementStringAsync("special",
                                                                    _intSpecial.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <totalspecial />
                            await objWriter.WriteElementStringAsync("totalspecial",
                                                                    _intTotalSpecial.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <totalattributes />
                            await objWriter.WriteElementStringAsync("totalattributes",
                                                                    _intTotalAttributes.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <edgeused />
                            await objWriter.WriteElementStringAsync("edgeused",
                                                                    _intEdgeUsed.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <contactpoints />
                            await objWriter.WriteElementStringAsync("contactpoints",
                                                                    _intCachedContactPoints.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <contactpointsused />
                            await objWriter.WriteElementStringAsync("contactpointsused",
                                                                    _intContactPointsUsed.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <spelllimit />
                            await objWriter.WriteElementStringAsync("spelllimit",
                                                                    _intFreeSpells.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <cfplimit />
                            await objWriter.WriteElementStringAsync("cfplimit",
                                                                    _intCFPLimit.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <totalaiprogramlimit />
                            await objWriter.WriteElementStringAsync("ainormalprogramlimit",
                                                                    _intAINormalProgramLimit.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <aiadvancedprogramlimit />
                            await objWriter.WriteElementStringAsync("aiadvancedprogramlimit",
                                                                    _intAIAdvancedProgramLimit.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <currentcounterspellingdice />
                            await objWriter.WriteElementStringAsync("currentcounterspellingdice",
                                                                    _intCurrentCounterspellingDice.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <currentliftcarryhits />
                            await objWriter.WriteElementStringAsync("currentliftcarryhits",
                                                                    _intCurrentLiftCarryHits.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <carrylimit />
                            await objWriter.WriteElementStringAsync("basecarrylimit",
                                                                    _decCachedBaseCarryLimit.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <liftlimit />
                            await objWriter.WriteElementStringAsync("baseliftlimit",
                                                                    _decCachedBaseLiftLimit.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <totalcarriedweight />
                            await objWriter.WriteElementStringAsync("totalcarriedweight",
                                                                    _decCachedTotalCarriedWeight.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <encumbranceinterval />
                            await objWriter.WriteElementStringAsync("encumbranceinterval",
                                                                    _decCachedEncumbranceInterval.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <streetcred />
                            await objWriter.WriteElementStringAsync("streetcred",
                                                                    _intStreetCred.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <notoriety />
                            await objWriter.WriteElementStringAsync("notoriety",
                                                                    _intNotoriety.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <publicaware />
                            await objWriter.WriteElementStringAsync("publicawareness",
                                                                    _intPublicAwareness.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <burntstreetcred />
                            await objWriter.WriteElementStringAsync("burntstreetcred",
                                                                    _intBurntStreetCred.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <baseastralreputation />
                            await objWriter.WriteElementStringAsync("baseastralreputation",
                                                                    _intBaseAstralReputation.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <basewildreputation />
                            await objWriter.WriteElementStringAsync("basewildreputation",
                                                                    _intBaseWildReputation.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <created />
                            await objWriter.WriteElementStringAsync("created",
                                                                    _blnCreated.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <nuyen />
                            await objWriter.WriteElementStringAsync(
                                               "nuyen", _decNuyen.ToString(GlobalSettings.InvariantCultureInfo),
                                               token: token)
                                           .ConfigureAwait(false);
                            // <startingnuyen />
                            await objWriter.WriteElementStringAsync("startingnuyen",
                                                                    _decStartingNuyen.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);

                            // <nuyenbp />
                            await objWriter.WriteElementStringAsync("nuyenbp",
                                                                    _decNuyenBP.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);

                            // <adept />
                            await objWriter.WriteElementStringAsync("adept",
                                                                    _blnAdeptEnabled.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <magician />
                            await objWriter.WriteElementStringAsync("magician",
                                                                    _blnMagicianEnabled.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <technomancer />
                            await objWriter.WriteElementStringAsync("technomancer",
                                                                    _blnTechnomancerEnabled.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <ai />
                            await objWriter.WriteElementStringAsync("ai",
                                                                    _blnAdvancedProgramsEnabled.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <cyberwaredisabled />
                            await objWriter.WriteElementStringAsync("cyberwaredisabled",
                                                                    _blnCyberwareDisabled.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <initiationdisabled />
                            await objWriter.WriteElementStringAsync("initiationdisabled",
                                                                    _blnInitiationDisabled.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <critter />
                            await objWriter.WriteElementStringAsync("critter",
                                                                    _blnCritterEnabled.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);

                            // <prototypetranshuman />
                            await objWriter.WriteElementStringAsync("prototypetranshuman",
                                                                    _decPrototypeTranshuman.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);

                            // <attributes>
                            await objWriter.WriteStartElementAsync("attributes", token: token)
                                           .ConfigureAwait(false);
                            AttributeSection.Save(objWriter, token);
                            // </attributes>
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <magenabled />
                            await objWriter.WriteElementStringAsync("magenabled",
                                                                    _blnMAGEnabled.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <initiategrade />
                            await objWriter.WriteElementStringAsync("initiategrade",
                                                                    _intInitiateGrade.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <resenabled />
                            await objWriter.WriteElementStringAsync("resenabled",
                                                                    _blnRESEnabled.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <submersiongrade />
                            await objWriter.WriteElementStringAsync("submersiongrade",
                                                                    _intSubmersionGrade.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <depenabled />
                            await objWriter.WriteElementStringAsync("depenabled",
                                                                    _blnDEPEnabled.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <groupmember />
                            await objWriter.WriteElementStringAsync("groupmember",
                                                                    _blnGroupMember.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <groupname />
                            await objWriter.WriteElementStringAsync("groupname", _strGroupName, token: token)
                                           .ConfigureAwait(false);
                            // <groupnotes />
                            await objWriter.WriteElementStringAsync("groupnotes", _strGroupNotes, token: token)
                                           .ConfigureAwait(false);

                            // External reader friendly stuff.
                            await objWriter.WriteElementStringAsync("totaless",
                                                                    (await EssenceAsync(token: token)
                                                                        .ConfigureAwait(false))
                                                                    .ToString(GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);

                            // Write out the Mystic Adept MAG split info.
                            if (_blnAdeptEnabled && _blnMagicianEnabled)
                            {
                                await objWriter.WriteElementStringAsync("magsplitadept",
                                                                        _intMAGAdept.ToString(
                                                                            GlobalSettings.InvariantCultureInfo),
                                                                        token: token).ConfigureAwait(false);
                                await objWriter.WriteElementStringAsync("magsplitmagician",
                                                                        _intMAGMagician.ToString(
                                                                            GlobalSettings.InvariantCultureInfo),
                                                                        token: token).ConfigureAwait(false);
                            }

                            _objTradition?.Save(objWriter);

                            // Condition Monitor Progress.
                            // <physicalcmfilled />
                            await objWriter.WriteElementStringAsync("physicalcmfilled",
                                                                    _intPhysicalCMFilled.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            // <stuncmfilled />
                            await objWriter.WriteElementStringAsync("stuncmfilled",
                                                                    _intStunCMFilled.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);

                            //<psyche />
                            await objWriter.WriteElementStringAsync("psyche",
                                                                    _blnPsycheActive.ToString(
                                                                        GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);

                            ///////////////////////////////////////////SKILLS

                            SkillsSection.Save(objWriter);

                            //Write copy of old skill groups, to not totally fuck a file if error
                            _oldSkillGroupBackup?.WriteTo(objWriter);
                            _oldSkillsBackup?.WriteTo(objWriter);

                            ///////////////////////////////////////////SKILLS

                            // <contacts>
                            await objWriter.WriteStartElementAsync("contacts", token: token).ConfigureAwait(false);
                            await _lstContacts.ForEachAsync(x => x.SaveAsync(objWriter, token), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <spells>
                            await objWriter.WriteStartElementAsync("spells", token: token).ConfigureAwait(false);
                            await _lstSpells.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <foci>
                            await objWriter.WriteStartElementAsync("foci", token: token).ConfigureAwait(false);
                            await _lstFoci.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <stackedfoci>
                            await objWriter.WriteStartElementAsync("stackedfoci", token: token)
                                           .ConfigureAwait(false);
                            await _lstStackedFoci.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <powers>
                            await objWriter.WriteStartElementAsync("powers", token: token).ConfigureAwait(false);
                            await _lstPowers.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <spirits>
                            await objWriter.WriteStartElementAsync("spirits", token: token).ConfigureAwait(false);
                            await _lstSpirits.ForEachAsync(x => x.SaveAsync(objWriter, token), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <complexforms>
                            await objWriter.WriteStartElementAsync("complexforms", token: token)
                                           .ConfigureAwait(false);
                            await _lstComplexForms.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <aiprograms>
                            await objWriter.WriteStartElementAsync("aiprograms", token: token)
                                           .ConfigureAwait(false);
                            await _lstAIPrograms.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <martialarts>
                            await objWriter.WriteStartElementAsync("martialarts", token: token)
                                           .ConfigureAwait(false);
                            await _lstMartialArts.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <limitmodifiers>
                            await objWriter.WriteStartElementAsync("limitmodifiers", token: token)
                                           .ConfigureAwait(false);
                            await _lstLimitModifiers.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <armors>
                            await objWriter.WriteStartElementAsync("armors", token: token).ConfigureAwait(false);
                            await _lstArmor.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <weapons>
                            await objWriter.WriteStartElementAsync("weapons", token: token).ConfigureAwait(false);
                            await _lstWeapons.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <cyberwares>
                            await objWriter.WriteStartElementAsync("cyberwares", token: token)
                                           .ConfigureAwait(false);
                            await _lstCyberware.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <qualities>
                            await objWriter.WriteStartElementAsync("qualities", token: token)
                                           .ConfigureAwait(false);
                            await _lstQualities.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <lifestyles>
                            await objWriter.WriteStartElementAsync("lifestyles", token: token)
                                           .ConfigureAwait(false);
                            await _lstLifestyles.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <gears>
                            await objWriter.WriteStartElementAsync("gears", token: token).ConfigureAwait(false);
                            await _lstGear.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <vehicles>
                            await objWriter.WriteStartElementAsync("vehicles", token: token).ConfigureAwait(false);
                            await _lstVehicles.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <metamagics>
                            await objWriter.WriteStartElementAsync("metamagics", token: token)
                                           .ConfigureAwait(false);
                            await _lstMetamagics.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <arts>
                            await objWriter.WriteStartElementAsync("arts", token: token).ConfigureAwait(false);
                            await _lstArts.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <enhancements>
                            await objWriter.WriteStartElementAsync("enhancements", token: token)
                                           .ConfigureAwait(false);
                            await _lstEnhancements.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <critterpowers>
                            await objWriter.WriteStartElementAsync("critterpowers", token: token)
                                           .ConfigureAwait(false);
                            await _lstCritterPowers.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <initiationgrades>
                            await objWriter.WriteStartElementAsync("initiationgrades", token: token)
                                           .ConfigureAwait(false);
                            await _lstInitiationGrades.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <improvements>
                            await objWriter.WriteStartElementAsync("improvements", token: token)
                                           .ConfigureAwait(false);
                            await _lstImprovements.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <sustained>
                            await objWriter.WriteStartElementAsync("sustainedobjects", token: token)
                                           .ConfigureAwait(false);
                            await _lstSustainedObjects.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <drugs>
                            await objWriter.WriteStartElementAsync("drugs", token: token).ConfigureAwait(false);
                            await _lstDrugs.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <mentorspirits>
                            await objWriter.WriteStartElementAsync("mentorspirits", token: token)
                                           .ConfigureAwait(false);
                            await _lstMentorSpirits.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <expenses>
                            await objWriter.WriteStartElementAsync("expenses", token: token).ConfigureAwait(false);
                            await _lstExpenseLog.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <locations>
                            await objWriter.WriteStartElementAsync("gearlocations", token: token)
                                           .ConfigureAwait(false);
                            await _lstGearLocations.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <armorlocations>
                            await objWriter.WriteStartElementAsync("armorlocations", token: token)
                                           .ConfigureAwait(false);
                            await _lstArmorLocations.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <vehiclelocations>
                            await objWriter.WriteStartElementAsync("vehiclelocations", token: token)
                                           .ConfigureAwait(false);
                            await _lstVehicleLocations.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <weaponlocations>
                            await objWriter.WriteStartElementAsync("weaponlocations", token: token)
                                           .ConfigureAwait(false);
                            await _lstWeaponLocations.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <improvementgroups>
                            await objWriter.WriteStartElementAsync("improvementgroups", token: token)
                                           .ConfigureAwait(false);
                            await _lstImprovementGroups.ForEachAsync(
                                strGroup => objWriter.WriteElementStringAsync("improvementgroup", strGroup, token: token),
                                token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            // <calendar>
                            await objWriter.WriteStartElementAsync("calendar", token: token).ConfigureAwait(false);
                            await _lstCalendar.ForEachAsync(x => x.Save(objWriter), token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            //Plugins
                            IReadOnlyList<IPlugin> lstActivePlugins = Program.PluginLoader != null
                                ? await Program.PluginLoader.GetMyActivePluginsAsync(token).ConfigureAwait(false)
                                : null;
                            if (lstActivePlugins?.Count > 0)
                            {
                                // <plugins>
                                await objWriter.WriteStartElementAsync("plugins", token: token)
                                               .ConfigureAwait(false);
                                foreach (IPlugin objPlugin in lstActivePlugins)
                                {
                                    try
                                    {
                                        System.Reflection.AssemblyName objPluginAssemblyName = objPlugin.GetPluginAssembly().GetName();
                                        await objWriter
                                              .WriteStartElementAsync(objPluginAssemblyName.Name, token: token)
                                              .ConfigureAwait(false);
                                        await objWriter
                                              .WriteAttributeStringAsync(
                                                  "version", objPluginAssemblyName.Version.ToString(), token: token)
                                              .ConfigureAwait(false);
                                        await objWriter.WriteStringAsync(objPlugin.GetSaveToFileElement(this))
                                                       .ConfigureAwait(false);
                                        await objWriter.WriteEndElementAsync().ConfigureAwait(false);
                                    }
                                    catch (Exception e)
                                    {
                                        Log.Warn(
                                            e, "Exception while writing saveFileElement for plugin " + objPlugin + ": ");
                                    }
                                }

                                //</plugins>
                                await objWriter.WriteEndElementAsync().ConfigureAwait(false);
                            }

                            //calculatedValues
                            await objWriter.WriteStartElementAsync("calculatedvalues", token: token)
                                           .ConfigureAwait(false);
                            await objWriter.WriteCommentAsync(
                                               "these values are not loaded and only stored here for third parties, who parse this files (to not have to calculate them themselves)")
                                           .ConfigureAwait(false);
                            await objWriter.WriteElementStringAsync("physicalcm",
                                                                    (await GetPhysicalCMAsync(token)
                                                                        .ConfigureAwait(false))
                                                                    .ToString(GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            await objWriter.WriteElementStringAsync("physicalcmthresholdoffset",
                                                                    (await GetPhysicalCMThresholdOffsetAsync(token)
                                                                        .ConfigureAwait(false))
                                                                    .ToString(GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            await objWriter.WriteElementStringAsync("physicalcmoverflow",
                                                                    (await GetCMOverflowAsync(token)
                                                                        .ConfigureAwait(false))
                                                                    .ToString(GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            await objWriter
                                  .WriteElementStringAsync(
                                      "stuncm",
                                      (await GetStunCMAsync(token).ConfigureAwait(false)).ToString(
                                          GlobalSettings.InvariantCultureInfo), token: token)
                                  .ConfigureAwait(false);
                            await objWriter.WriteElementStringAsync("stuncmthresholdoffset",
                                                                    (await GetStunCMThresholdOffsetAsync(token)
                                                                        .ConfigureAwait(false))
                                                                    .ToString(GlobalSettings.InvariantCultureInfo),
                                                                    token: token).ConfigureAwait(false);
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);
                            // </calculatedValues>

                            // </character>
                            await objWriter.WriteEndElementAsync().ConfigureAwait(false);

                            await objWriter.WriteEndDocumentAsync().ConfigureAwait(false);
                            await objWriter.FlushAsync().ConfigureAwait(false);
                        }

                        objStream.Position = 0;

                        // Validate that the character can save properly. If there's no error, save the file to the listed file location.
                        try
                        {
                            XmlDocument objDoc = new XmlDocument {XmlResolver = null};
                            using (XmlReader objXmlReader
                                   = XmlReader.Create(objStream, GlobalSettings.SafeXmlReaderSettings))
                                objDoc.Load(objXmlReader);
                            using (FileStream objFileStream
                                   = new FileStream(strFileName, FileMode.Create, FileAccess.Write, FileShare.None))
                            {
                                if (strFileName.EndsWith(".chum5", StringComparison.OrdinalIgnoreCase))
                                    objDoc.Save(objFileStream);
                                else
                                {
                                    objStream.Seek(0, SeekOrigin.Begin);
                                    await objStream.CompressToLzmaFileAsync(
                                                       objFileStream, GlobalSettings.Chum5lzCompressionLevel,
                                                       token: token)
                                                   .ConfigureAwait(false);
                                }
                            }
                        }
                        catch (IOException e)
                        {
                            Log.Error(e);
                            if (Utils.IsUnitTest)
                                throw;
                            Program.ShowScrollableMessageBox(await LanguageManager
                                                                   .GetStringAsync(
                                                                       "Message_Save_Error_Warning", token: token)
                                                                   .ConfigureAwait(false));
                            blnErrorFree = false;
                        }
                        catch (XmlException ex)
                        {
                            Log.Warn(ex);
                            if (Utils.IsUnitTest)
                                throw;
                            Program.ShowScrollableMessageBox(await LanguageManager
                                                                   .GetStringAsync(
                                                                       "Message_Save_Error_Warning", token: token)
                                                                   .ConfigureAwait(false));
                            blnErrorFree = false;
                        }
                        catch (UnauthorizedAccessException) when (!Utils.IsUnitTest)
                        {
                            Program.ShowScrollableMessageBox(await LanguageManager
                                                                   .GetStringAsync(
                                                                       "Message_Save_Error_Warning", token: token)
                                                                   .ConfigureAwait(false));
                            blnErrorFree = false;
                        }
                    }
                }

                if (addToMRU)
                {
                    if (blnSync)
                        // ReSharper disable once MethodHasAsyncOverload
                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                        GlobalSettings.MostRecentlyUsedCharacters.Insert(0, FileName);
                    else
                        await GlobalSettings.MostRecentlyUsedCharacters.InsertAsync(0, FileName, token)
                                            .ConfigureAwait(false);
                }

                if (blnSync)
                {
                    // ReSharper disable once MethodHasAsyncOverload
                    using (LockObject.EnterWriteLock(token))
                    {
                        _dateFileLastWriteTime = File.GetLastWriteTimeUtc(strFileName);
                    }
                }
                else
                {
                    IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        _dateFileLastWriteTime = File.GetLastWriteTimeUtc(strFileName);
                    }
                    finally
                    {
                        await objLocker.DisposeAsync().ConfigureAwait(false);
                    }
                }

                if (callOnSaveCallBack)
                {
                    // Cannot use foreach or LINQ because we need to be able to allow queued functions to add onto the queue
                    if (blnSync)
                    {
                        List<Func<bool>> lstToRun = new List<Func<bool>>(DoOnSaveCompleted.Count);
                        List<Func<Task<bool>>> lstToRunAsync = new List<Func<Task<bool>>>(DoOnSaveCompletedAsync.Count);
                        int i = 0;
                        int j = 0;
                        while (i < DoOnSaveCompleted.Count || j < DoOnSaveCompletedAsync.Count)
                        {
                            while (i < DoOnSaveCompleted.Count)
                            {
                                lstToRun.Clear();
                                for (; i < DoOnSaveCompleted.Count; ++i)
                                {
                                    Func<Character, bool> funcLoopToRun = DoOnSaveCompleted[i];
                                    if (funcLoopToRun != null)
                                        lstToRun.Add(() => funcLoopToRun(this));
                                }

                                bool[] ablnTemp = Utils.RunWithoutThreadLock(lstToRun, token);
                                if (blnErrorFree && ablnTemp.FirstMatching(false) >= 0)
                                    blnErrorFree = false;
                            }

                            while (j < DoOnSaveCompletedAsync.Count)
                            {
                                lstToRunAsync.Clear();
                                for (; j < DoOnSaveCompletedAsync.Count; ++j)
                                {
                                    Func<Character, CancellationToken, Task<bool>> funcLoopToRun
                                        = DoOnSaveCompletedAsync[j];
                                    if (funcLoopToRun != null)
                                        lstToRunAsync.Add(() => funcLoopToRun(this, token));
                                }

                                bool[] ablnTemp = Utils.RunWithoutThreadLock(lstToRunAsync, token);
                                if (blnErrorFree && ablnTemp.FirstMatching(false) >= 0)
                                    blnErrorFree = false;
                            }
                        }
                    }
                    else
                    {
                        List<Task<bool>> lstDoOnSaveCompletedAsync = new List<Task<bool>>(Utils.MaxParallelBatchSize);
                        int i = 0;
                        int j = 0;
                        while (i != await DoOnSaveCompleted.GetCountAsync(token).ConfigureAwait(false)
                               || j != await DoOnSaveCompletedAsync.GetCountAsync(token).ConfigureAwait(false))
                        {
                            lstDoOnSaveCompletedAsync.Clear();
                            while
                                (i != await DoOnSaveCompleted
                                            .GetCountAsync(token)
                                            .ConfigureAwait(
                                                false)) // Set up this way because functions can potentially add more to DoOnSaveCompleted
                            {
                                int intCounter = 0;
                                // ReSharper disable once ForCanBeConvertedToForeach
                                for (; i < await DoOnSaveCompleted.GetCountAsync(token).ConfigureAwait(false); ++i)
                                {
                                    token.ThrowIfCancellationRequested();
                                    Func<Character, bool> funcLoopToRun = await DoOnSaveCompleted
                                        .GetValueAtAsync(i, token).ConfigureAwait(false);
                                    if (funcLoopToRun != null)
                                    {
                                        lstDoOnSaveCompletedAsync.Add(
                                            Task.Run(() => funcLoopToRun.Invoke(this), token));
                                        if (++intCounter != Utils.MaxParallelBatchSize)
                                            continue;
                                        token.ThrowIfCancellationRequested();
                                        await Task.WhenAll(lstDoOnSaveCompletedAsync).ConfigureAwait(false);
                                        token.ThrowIfCancellationRequested();
                                        foreach (Task<bool> tskLoop in lstDoOnSaveCompletedAsync)
                                        {
                                            if (!await tskLoop.ConfigureAwait(false))
                                                blnErrorFree = false;
                                        }

                                        lstDoOnSaveCompletedAsync.Clear();
                                        intCounter = 0;
                                    }
                                }

                                token.ThrowIfCancellationRequested();
                                await Task.WhenAll(lstDoOnSaveCompletedAsync).ConfigureAwait(false);
                                token.ThrowIfCancellationRequested();
                                foreach (Task<bool> tskLoop in lstDoOnSaveCompletedAsync)
                                {
                                    if (!await tskLoop.ConfigureAwait(false))
                                        blnErrorFree = false;
                                }
                            }

                            lstDoOnSaveCompletedAsync.Clear();
                            while (j != await DoOnSaveCompletedAsync.GetCountAsync(token).ConfigureAwait(false))
                            {
                                int intCounter = 0;
                                // ReSharper disable once ForCanBeConvertedToForeach
                                for (; j < await DoOnSaveCompletedAsync.GetCountAsync(token).ConfigureAwait(false); ++j)
                                {
                                    Func<Character, CancellationToken, Task<bool>> funcLoopToRun
                                        = await DoOnSaveCompletedAsync.GetValueAtAsync(j, token).ConfigureAwait(false);
                                    if (funcLoopToRun != null)
                                    {
                                        lstDoOnSaveCompletedAsync.Add(
                                            Task.Run(() => funcLoopToRun.Invoke(this, token), token));
                                        if (++intCounter != Utils.MaxParallelBatchSize)
                                            continue;
                                        token.ThrowIfCancellationRequested();
                                        await Task.WhenAll(lstDoOnSaveCompletedAsync).ConfigureAwait(false);
                                        token.ThrowIfCancellationRequested();
                                        foreach (Task<bool> tskLoop in lstDoOnSaveCompletedAsync)
                                        {
                                            if (!await tskLoop.ConfigureAwait(false))
                                                blnErrorFree = false;
                                        }

                                        lstDoOnSaveCompletedAsync.Clear();
                                        intCounter = 0;
                                    }
                                }

                                token.ThrowIfCancellationRequested();
                                await Task.WhenAll(lstDoOnSaveCompletedAsync).ConfigureAwait(false);
                                token.ThrowIfCancellationRequested();
                                foreach (Task<bool> tskLoop in lstDoOnSaveCompletedAsync)
                                {
                                    if (!await tskLoop.ConfigureAwait(false))
                                        blnErrorFree = false;
                                }
                            }
                        }
                    }
                }

                return blnErrorFree;
            }
        }

        /// <summary>
        /// Syntactic sugar for XmlManager.LoadXPath() where we use the current enabled custom data directory list from our options file.
        /// XPathDocuments are usually faster than XmlDocuments, but are read-only and take longer to load if live custom data is enabled
        /// Returns a new XPathNavigator associated with the XPathDocument so that multiple threads each get their own navigator if they're called on the same file
        /// </summary>
        /// <param name="strFileName">Name of the XML file to load.</param>
        /// <param name="strLanguage">Language in which to load the data document.</param>
        /// <param name="blnLoadFile">Whether to force reloading content even if the file already exists.</param>
        /// <param name="token">Cancellation token to use.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public XPathNavigator LoadDataXPath(string strFileName, string strLanguage = "", bool blnLoadFile = false, CancellationToken token = default)
        {
            return XmlManager.LoadXPath(strFileName, Settings.EnabledCustomDataDirectoryPaths, strLanguage, blnLoadFile, token);
        }

        /// <summary>
        /// Syntactic sugar for XmlManager.LoadXPathAsync() where we use the current enabled custom data directory list from our options file.
        /// XPathDocuments are usually faster than XmlDocuments, but are read-only and take longer to load if live custom data is enabled
        /// Returns a new XPathNavigator associated with the XPathDocument so that multiple threads each get their own navigator if they're called on the same file
        /// </summary>
        /// <param name="strFileName">Name of the XML file to load.</param>
        /// <param name="strLanguage">Language in which to load the data document.</param>
        /// <param name="blnLoadFile">Whether to force reloading content even if the file already exists.</param>
        /// <param name="token">Cancellation token to use.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Task<XPathNavigator> LoadDataXPathAsync(string strFileName, string strLanguage = "",
            bool blnLoadFile = false, CancellationToken token = default)
        {
            return XmlManager.LoadXPathAsync(strFileName, Settings.EnabledCustomDataDirectoryPaths, strLanguage,
                blnLoadFile, token);
        }

        /// <summary>
        /// Syntactic sugar for XmlManager.Load() where we use the current enabled custom data directory list from our options file.
        /// </summary>
        /// <param name="strFileName">Name of the XML file to load.</param>
        /// <param name="strLanguage">Language in which to load the data document.</param>
        /// <param name="blnLoadFile">Whether to force reloading content even if the file already exists.</param>
        /// <param name="token">Cancellation token to use.</param>
        [NotNull]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public XmlDocument LoadData(string strFileName, string strLanguage = "", bool blnLoadFile = false, CancellationToken token = default)
        {
            return XmlManager.Load(strFileName, Settings.EnabledCustomDataDirectoryPaths, strLanguage, blnLoadFile, token);
        }

        /// <summary>
        /// Syntactic sugar for XmlManager.LoadAsync() where we use the current enabled custom data directory list from our options file.
        /// </summary>
        /// <param name="strFileName">Name of the XML file to load.</param>
        /// <param name="strLanguage">Language in which to load the data document.</param>
        /// <param name="blnLoadFile">Whether to force reloading content even if the file already exists.</param>
        /// <param name="token">Cancellation token to use.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Task<XmlDocument> LoadDataAsync(string strFileName, string strLanguage = "", bool blnLoadFile = false, CancellationToken token = default)
        {
            return XmlManager.LoadAsync(strFileName, Settings.EnabledCustomDataDirectoryPaths, strLanguage, blnLoadFile, token);
        }

        private int _intIsLoading;

        /// <summary>
        /// Set to true while data is being populated by the Load function
        /// </summary>
        public bool IsLoading
        {
            get => _intIsLoading > 0;
            set
            {
                if (value)
                {
                    if (Interlocked.Increment(ref _intIsLoading) == 1)
                    {
                        OnPropertyChanged();
                    }
                }
                else if (Interlocked.Decrement(ref _intIsLoading) == 0)
                {
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Add a function to the queue of methods to execute after loading has finished. Return value signals whether loading should continue after execution (True) or terminate/cancel (False).
        /// </summary>
        public bool EnqueuePostLoadMethod(Func<CancellationToken, bool> value, CancellationToken token = default)
        {
            // Only need read lock because collection is concurrent anyway
            using (EnterReadLock.Enter(LockObject, token))
            {
                return _setPostLoadMethods.TryAdd(value);
            }
        }

        /// <summary>
        /// Queue of asynchronous methods to execute after loading has finished. Return value signals whether loading should continue after execution (True) or terminate/cancel (False).
        /// </summary>
        public bool EnqueuePostLoadAsyncMethod(Func<CancellationToken, Task<bool>> value, CancellationToken token = default)
        {
            // Only need read lock because collection is concurrent anyway
            using (EnterReadLock.Enter(LockObject, token))
            {
                return _setPostLoadAsyncMethods.TryAdd(value);
            }
        }

        /// <summary>
        /// Add a function to the queue of methods to execute after loading has finished. Return value signals whether loading should continue after execution (True) or terminate/cancel (False).
        /// </summary>
        public async ValueTask<bool> EnqueuePostLoadMethodAsync(Func<CancellationToken, bool> value, CancellationToken token = default)
        {
            // Only need read lock because collection is concurrent anyway
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                return _setPostLoadMethods.TryAdd(value);
            }
        }

        /// <summary>
        /// Queue of asynchronous methods to execute after loading has finished. Return value signals whether loading should continue after execution (True) or terminate/cancel (False).
        /// </summary>
        public async ValueTask<bool> EnqueuePostLoadAsyncMethodAsync(Func<CancellationToken, Task<bool>> value, CancellationToken token = default)
        {
            // Only need read lock because collection is concurrent anyway
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                return _setPostLoadAsyncMethods.TryAdd(value);
            }
        }

        /// <summary>
        /// Load the Character from an XML file synchronously.
        /// </summary>
        /// <param name="strFileName">Name of the file to load the character from. Leave empty if the character should be loaded from FileName.</param>
        /// <param name="frmLoadingForm">Instance of frmLoading to use to update with loading progress. frmLoading::PerformStep() is called 35 times within this method, so plan accordingly.</param>
        /// <param name="showWarnings">Whether warnings about book content and other character content should be loaded.</param>
        /// <param name="token">Cancellation token to use.</param>
        public bool Load(string strFileName = "", LoadingBar frmLoadingForm = null, bool showWarnings = true, CancellationToken token = default)
        {
            return Utils.SafelyRunSynchronously(() => LoadCoreAsync(true, strFileName, frmLoadingForm, showWarnings, token), token);
        }

        /// <summary>
        /// Load the Character from an XML file asynchronously.
        /// </summary>
        /// <param name="strFileName">Name of the file to load the character from. Leave empty if the character should be loaded from FileName.</param>
        /// <param name="frmLoadingForm">Instance of frmLoading to use to update with loading progress. frmLoading::PerformStep() is called 35 times within this method, so plan accordingly.</param>
        /// <param name="showWarnings">Whether warnings about book content and other character content should be loaded.</param>
        /// <param name="token">Cancellation token to use.</param>
        public Task<bool> LoadAsync(string strFileName = "", LoadingBar frmLoadingForm = null, bool showWarnings = true, CancellationToken token = default)
        {
            return LoadCoreAsync(false, strFileName, frmLoadingForm, showWarnings, token);
        }

        public const int NumLoadingSections = 37;

        /// <summary>
        /// Load the Character from an XML file.
        /// Uses flag hack method design outlined here to avoid locking:
        /// https://docs.microsoft.com/en-us/archive/msdn-magazine/2015/july/async-programming-brownfield-async-development
        /// </summary>
        /// <param name="blnSync">Flag for whether method should always use synchronous code or not.</param>
        /// <param name="strFileName">Name of the file to load the character from. Leave empty if the character should be loaded from FileName.</param>
        /// <param name="frmLoadingForm">Instance of frmLoading to use to update with loading progress. frmLoading::PerformStep() is called NumLoadingSections times within this method, so plan accordingly.</param>
        /// <param name="showWarnings">Whether warnings about book content and other character content should be loaded.</param>
        /// <param name="token">Cancellation token to use.</param>
        private async Task<bool> LoadCoreAsync(bool blnSync, string strFileName = "", LoadingBar frmLoadingForm = null,
                                               bool showWarnings = true, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (string.IsNullOrWhiteSpace(strFileName))
                strFileName = FileName;
            if (!File.Exists(strFileName) || (!strFileName.EndsWith(".chum5", StringComparison.OrdinalIgnoreCase)
                                              && !strFileName.EndsWith(".chum5lz", StringComparison.OrdinalIgnoreCase)))
                return false;

            IDisposable objLocker = null;
            IAsyncDisposable objLockerAsync = null;
            if (blnSync)
                // ReSharper disable once MethodHasAsyncOverload
                objLocker = LockObject.EnterWriteLock(token);
            else
                objLockerAsync = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                LoadAsDirty = false;
                using (CustomActivity loadActivity = Timekeeper.StartSyncron("clsCharacter.Load", null,
                                                                             CustomActivity.OperationType
                                                                                 .DependencyOperation, strFileName))
                {
                    try
                    {
                        using (Timekeeper.StartSyncron("upload_AI_options", loadActivity))
                        {
                            UploadObjectAsMetric.UploadObject(TelemetryClient, Settings);
                        }

                        XmlDocument objXmlDocument = new XmlDocument {XmlResolver = null};
                        XmlNode objXmlCharacter = null;
                        XPathNavigator xmlCharacterNavigator = null;
                        Quality objLivingPersonaQuality = null;

                        if (frmLoadingForm != null)
                        {
                            if (blnSync)
                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                frmLoadingForm.PerformStep("XML");
                            else
                                await frmLoadingForm.PerformStepAsync("XML", token: token).ConfigureAwait(false);
                        }

                        using (Timekeeper.StartSyncron("load_xml", loadActivity))
                        {
                            bool blnKeepLoading = blnSync
                                ? LoadSaveFileDocument()
                                : await Task.Run(LoadSaveFileDocumentAsync, token).ConfigureAwait(false);

                            bool LoadSaveFileDocument()
                            {
                                bool blnErrorCaught = false;
                                do
                                {
                                    try
                                    {
                                        if (strFileName.EndsWith(".chum5", StringComparison.OrdinalIgnoreCase))
                                            objXmlDocument.LoadStandard(strFileName, !blnErrorCaught);
                                        else if (strFileName.EndsWith(".chum5lz", StringComparison.OrdinalIgnoreCase))
                                            objXmlDocument.LoadStandardFromLzmaCompressed(
                                                strFileName, !blnErrorCaught);
                                        else
                                            throw new InvalidOperationException();
                                        blnErrorCaught = false;
                                    }
                                    catch (XmlException ex)
                                    {
                                        if (GlobalSettings.InvalidUnicodeCharsExpression.IsMatch(ex.Message))
                                        {
                                            /*If we found a known control character that's preventing the character from
                                            being loaded (Expected to be notes ingested from PDF mostly) prompt the user whether to use unsafe methods.
                                            If yes, restart the load, explicitly ignoring invalid characters.*/

                                            if (Program.ShowScrollableMessageBox(
                                                    LanguageManager.GetString("Message_InvalidTextFound", token: token),
                                                    LanguageManager.GetString(
                                                        "Message_InvalidTextFound_Title", token: token),
                                                    MessageBoxButtons.YesNo, MessageBoxIcon.Warning) ==
                                                DialogResult.No)
                                            {
                                                return false;
                                            }

                                            blnErrorCaught = true;
                                        }
                                        else
                                        {
                                            if (showWarnings)
                                            {
                                                Program.ShowScrollableMessageBox(
                                                    string.Format(GlobalSettings.CultureInfo,
                                                                  LanguageManager.GetString(
                                                                      "Message_FailedLoad", token: token),
                                                                  ex.Message),
                                                    string.Format(GlobalSettings.CultureInfo,
                                                                  LanguageManager.GetString(
                                                                      "MessageTitle_FailedLoad", token: token),
                                                                  ex.Message),
                                                    MessageBoxButtons.OK, MessageBoxIcon.Error);
                                            }

                                            return false;
                                        }
                                    }
                                } while (blnErrorCaught);

                                objXmlCharacter = objXmlDocument.SelectSingleNode("/character");
                                xmlCharacterNavigator =
                                    objXmlDocument.GetFastNavigator().SelectSingleNodeAndCacheExpression("/character", token);
                                return true;
                            }

                            async Task<bool> LoadSaveFileDocumentAsync()
                            {
                                bool blnErrorCaught = false;
                                do
                                {
                                    try
                                    {
                                        if (strFileName.EndsWith(".chum5", StringComparison.OrdinalIgnoreCase))
                                            await objXmlDocument.LoadStandardAsync(
                                                strFileName, !blnErrorCaught, token).ConfigureAwait(false);
                                        else if (strFileName.EndsWith(".chum5lz", StringComparison.OrdinalIgnoreCase))
                                            await objXmlDocument.LoadStandardFromLzmaCompressedAsync(
                                                strFileName, !blnErrorCaught, token).ConfigureAwait(false);
                                        else
                                            throw new InvalidOperationException();
                                        blnErrorCaught = false;
                                    }
                                    catch (XmlException ex)
                                    {
                                        if (GlobalSettings.InvalidUnicodeCharsExpression.IsMatch(ex.Message))
                                        {
                                            /*If we found a known control character that's preventing the character from
                                            being loaded (Expected to be notes ingested from PDF mostly) prompt the user whether to use unsafe methods.
                                            If yes, restart the load, explicitly ignoring invalid characters.*/

                                            if (Program.ShowScrollableMessageBox(
                                                    await LanguageManager
                                                          .GetStringAsync("Message_InvalidTextFound", token: token)
                                                          .ConfigureAwait(false),
                                                    await LanguageManager
                                                          .GetStringAsync(
                                                              "Message_InvalidTextFound_Title", token: token)
                                                          .ConfigureAwait(false),
                                                    MessageBoxButtons.YesNo, MessageBoxIcon.Warning) ==
                                                DialogResult.No)
                                            {
                                                return false;
                                            }

                                            blnErrorCaught = true;
                                        }
                                        else
                                        {
                                            if (showWarnings)
                                            {
                                                Program.ShowScrollableMessageBox(
                                                    string.Format(GlobalSettings.CultureInfo,
                                                                  await LanguageManager
                                                                        .GetStringAsync(
                                                                            "Message_FailedLoad", token: token)
                                                                        .ConfigureAwait(false),
                                                                  ex.Message),
                                                    string.Format(GlobalSettings.CultureInfo,
                                                                  await LanguageManager
                                                                        .GetStringAsync(
                                                                            "MessageTitle_FailedLoad", token: token)
                                                                        .ConfigureAwait(false),
                                                                  ex.Message),
                                                    MessageBoxButtons.OK, MessageBoxIcon.Error);
                                            }

                                            return false;
                                        }
                                    }
                                } while (blnErrorCaught);

                                objXmlCharacter = objXmlDocument.SelectSingleNode("/character");
                                xmlCharacterNavigator
                                    = await (await objXmlDocument.GetFastNavigatorAsync(token).ConfigureAwait(false))
                                            .SelectSingleNodeAndCacheExpressionAsync("/character", token)
                                            .ConfigureAwait(false);
                                return true;
                            }

                            if (!blnKeepLoading || objXmlCharacter == null || xmlCharacterNavigator == null)
                            {
                                return false;
                            }

                            //Timekeeper.Finish("load_xml");
                        }

                        IsLoading = true;

                        try
                        {
                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("String_Settings", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("String_Settings",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_misc", loadActivity))
                            {
                                _dateFileLastWriteTime = File.GetLastWriteTimeUtc(strFileName);

                                xmlCharacterNavigator.TryGetBoolFieldQuickly("ignorerules", ref _blnIgnoreRules);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("created", ref _blnCreated);

                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ResetCharacter(token);
                                else
                                    await ResetCharacterAsync(token).ConfigureAwait(false);

                                // Get the game edition of the file if possible and make sure it's intended to be used with this version of the application.
                                string strGameEdition = string.Empty;
                                if (xmlCharacterNavigator.TryGetStringFieldQuickly("gameedition",
                                        ref strGameEdition) &&
                                    !string.IsNullOrEmpty(strGameEdition) && strGameEdition != "SR5" &&
                                    showWarnings &&
                                    !Utils.IsUnitTest)
                                {
                                    Program.ShowScrollableMessageBox(
                                        blnSync
                                            // ReSharper disable once MethodHasAsyncOverload
                                            ? LanguageManager.GetString("Message_IncorrectGameVersion_SR4",
                                                                        token: token)
                                            : await LanguageManager.GetStringAsync(
                                                "Message_IncorrectGameVersion_SR4", token: token).ConfigureAwait(false),
                                        blnSync
                                            // ReSharper disable once MethodHasAsyncOverload
                                            ? LanguageManager.GetString("MessageTitle_IncorrectGameVersion",
                                                                        token: token)
                                            : await LanguageManager.GetStringAsync(
                                                                       "MessageTitle_IncorrectGameVersion",
                                                                       token: token)
                                                                   .ConfigureAwait(false),
                                        MessageBoxButtons.YesNo,
                                        MessageBoxIcon.Error);
                                    return false;
                                }

                                string strVersion = string.Empty;
                                //Check to see if the character was created in a version of Chummer later than the currently installed one.
                                if (xmlCharacterNavigator.TryGetStringFieldQuickly("appversion", ref strVersion) &&
                                    !string.IsNullOrEmpty(strVersion))
                                {
                                    strVersion = strVersion.TrimStartOnce("0.");

                                    if (!VersionExtensions.TryParse(strVersion, out _verSavedVersion))
                                    {
                                        _verSavedVersion = Utils.IsUnitTest
                                            ? new Version(int.MaxValue, int.MaxValue, int.MaxValue)
                                            : new Version();
                                    }
                                    // Check for typo in Corrupter quality and correct it
                                    else if (_verSavedVersion?.CompareTo(new Version(5, 188, 34)) == -1)
                                    {
                                        objXmlDocument.InnerXml =
                                            objXmlDocument.InnerXml.Replace("Corruptor", "Corrupter");
                                        xmlCharacterNavigator =
                                            blnSync
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                ? objXmlDocument.GetFastNavigator()
                                                                // ReSharper disable once MethodHasAsyncOverload
                                                                .SelectSingleNodeAndCacheExpression("/character", token)
                                                : await (await objXmlDocument.GetFastNavigatorAsync(token)
                                                                             .ConfigureAwait(false))
                                                        .SelectSingleNodeAndCacheExpressionAsync("/character", token)
                                                        .ConfigureAwait(false);
                                        if (xmlCharacterNavigator == null)
                                            return false;
                                    }
                                }
#if !DEBUG
                                if (!Utils.IsUnitTest)
                                {
                                    string strMinimumVersion = string.Empty;
                                    // Check to see if a character has a minimum version set where they will not load properly on anything older
                                    if (xmlCharacterNavigator.TryGetStringFieldQuickly(
                                            "minimumappversion", ref strMinimumVersion)
                                        && !string.IsNullOrEmpty(strMinimumVersion))
                                    {
                                        strMinimumVersion = strMinimumVersion.TrimStartOnce("0.");
                                        if (Version.TryParse(strMinimumVersion, out Version objMinimumVersion)
                                            && objMinimumVersion > Utils.CurrentChummerVersion)
                                        {
                                            Program.ShowMessageBox(
                                                string.Format(GlobalSettings.CultureInfo,
                                                              blnSync
                                                                  // ReSharper disable once MethodHasAsyncOverload
                                                                  ? LanguageManager.GetString(
                                                                      "Message_OlderThanChummerSaveMinimumVersion", token: token)
                                                                  : await LanguageManager
                                                                          .GetStringAsync(
                                                                              "Message_OlderThanChummerSaveMinimumVersion",
                                                                              token: token).ConfigureAwait(false),
                                                              objMinimumVersion, Utils.CurrentChummerVersion),
                                                blnSync
                                                    // ReSharper disable once MethodHasAsyncOverload
                                                    ? LanguageManager.GetString(
                                                        "MessageTitle_OlderThanChummerSaveMinimumVersion", token: token)
                                                    : await LanguageManager
                                                            .GetStringAsync(
                                                                "MessageTitle_OlderThanChummerSaveMinimumVersion",
                                                                token: token).ConfigureAwait(false),
                                                MessageBoxButtons.OK, MessageBoxIcon.Error);
                                            return false;
                                        }
                                    }

                                    if (_verSavedVersion > Utils.CurrentChummerVersion && DialogResult.Yes
                                        != Program.ShowMessageBox(
                                            string.Format(GlobalSettings.CultureInfo,
                                                          blnSync
                                                              // ReSharper disable once MethodHasAsyncOverload
                                                              ? LanguageManager.GetString("Message_OutdatedChummerSave", token: token)
                                                              : await LanguageManager
                                                                      .GetStringAsync(
                                                                          "Message_OutdatedChummerSave", token: token)
                                                                      .ConfigureAwait(false), _verSavedVersion,
                                                          Utils.CurrentChummerVersion),
                                            blnSync
                                                // ReSharper disable once MethodHasAsyncOverload
                                                ? LanguageManager.GetString("MessageTitle_OutdatedChummerSave", token: token)
                                                : await LanguageManager
                                                        .GetStringAsync("MessageTitle_OutdatedChummerSave",
                                                                        token: token).ConfigureAwait(false),
                                            MessageBoxButtons.YesNo, MessageBoxIcon.Warning))
                                    {
                                        return false;
                                    }
                                }
#endif

                                // Get the name of the settings file in use if possible.
                                xmlCharacterNavigator.TryGetStringFieldQuickly("settings", ref _strSettingsKey);

                                int intSettingsHashCode = 0;
                                bool blnHashCodeSuccess
                                    = xmlCharacterNavigator.TryGetInt32FieldQuickly(
                                        "settingshashcode", ref intSettingsHashCode);

                                bool blnSuccess;

                                // Load the character's settings file.
                                string strDummy = string.Empty;
                                if (!xmlCharacterNavigator.TryGetStringFieldQuickly("buildmethod", ref strDummy)
                                    || !Enum.TryParse(strDummy, true, out CharacterBuildMethod eSavedBuildMethod))
                                {
                                    CharacterSettings objSettings;
                                    if (blnSync)
                                        blnSuccess = SettingsManager.LoadedCharacterSettings.TryGetValue(
                                            GlobalSettings.DefaultCharacterSettingDefaultValue, out objSettings);
                                    else
                                        (blnSuccess, objSettings)
                                            = await (await SettingsManager.GetLoadedCharacterSettingsAsync(token)
                                                                          .ConfigureAwait(false)).TryGetValueAsync(
                                                    GlobalSettings.DefaultCharacterSettingDefaultValue, token)
                                                .ConfigureAwait(false);
                                    eSavedBuildMethod = blnSuccess
                                        ? objSettings.BuildMethod
                                        : CharacterBuildMethod.Priority;
                                }

                                CharacterSettings objDefaultSettings;
                                if (blnSync)
                                    blnSuccess = SettingsManager.LoadedCharacterSettings.TryGetValue(
                                        GlobalSettings.DefaultCharacterSetting, out objDefaultSettings);
                                else
                                    (blnSuccess, objDefaultSettings)
                                        = await (await SettingsManager.GetLoadedCharacterSettingsAsync(token)
                                                                      .ConfigureAwait(false)).TryGetValueAsync(
                                            GlobalSettings.DefaultCharacterSetting, token).ConfigureAwait(false);
                                if (!blnSuccess)
                                {
                                    if (blnSync)
                                        blnSuccess = SettingsManager.LoadedCharacterSettings.TryGetValue(
                                            GlobalSettings.DefaultCharacterSettingDefaultValue, out objDefaultSettings);
                                    else
                                        (blnSuccess, objDefaultSettings)
                                            = await (await SettingsManager.GetLoadedCharacterSettingsAsync(token)
                                                                          .ConfigureAwait(false)).TryGetValueAsync(
                                                    GlobalSettings.DefaultCharacterSettingDefaultValue, token)
                                                .ConfigureAwait(false);
                                    if (!blnSuccess)
                                    {
                                        objDefaultSettings = blnSync
                                            ? SettingsManager.LoadedCharacterSettings.First().Value
                                            : (await SettingsManager.GetLoadedCharacterSettingsAsync(token)
                                                                    .ConfigureAwait(false)).First().Value;
                                    }
                                }

                                CharacterSettings objProspectiveSettings;
                                bool blnShowSelectBP = false;
                                using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                           out HashSet<string> setSavedBooks))
                                {
                                    foreach (XPathNavigator xmlBook in (blnSync
                                                 // ReSharper disable once MethodHasAsyncOverload
                                                 ? xmlCharacterNavigator.SelectAndCacheExpression(
                                                     "sources/source", token)
                                                 : await xmlCharacterNavigator.SelectAndCacheExpressionAsync(
                                                     "sources/source", token: token).ConfigureAwait(false)))
                                    {
                                        if (!string.IsNullOrEmpty(xmlBook.Value))
                                            setSavedBooks.Add(xmlBook.Value);
                                    }

                                    if (setSavedBooks.Count == 0)
                                        setSavedBooks.AddRange(objDefaultSettings.Books);

                                    XPathNodeIterator xmlCustomDirectoryNames = blnSync
                                        // ReSharper disable once MethodHasAsyncOverload
                                        ? xmlCharacterNavigator.SelectAndCacheExpression(
                                            "customdatadirectorynames/directoryname", token)
                                        : await xmlCharacterNavigator.SelectAndCacheExpressionAsync(
                                                                         "customdatadirectorynames/directoryname",
                                                                         token: token)
                                                                     .ConfigureAwait(false);
                                    List<string> lstSavedCustomDataDirectoryNames
                                        = new List<string>(xmlCustomDirectoryNames.Count);
                                    foreach (XPathNavigator xmlCustomDataDirectoryName in xmlCustomDirectoryNames)
                                    {
                                        if (!string.IsNullOrEmpty(xmlCustomDataDirectoryName.Value))
                                            lstSavedCustomDataDirectoryNames.Add(xmlCustomDataDirectoryName.Value);
                                    }

                                    decimal decLegacyMaxNuyen = objDefaultSettings.NuyenMaximumBP;
                                    xmlCharacterNavigator.TryGetDecFieldQuickly("maxnuyen", ref decLegacyMaxNuyen);
                                    int intLegacyMaxKarma = objDefaultSettings.BuildKarma;
                                    xmlCharacterNavigator.TryGetInt32FieldQuickly("maxkarma",
                                        ref intLegacyMaxKarma);

                                    // Calculate a score for a character option that roughly coincides with how suitable it is as a
                                    // replacement for the current one the character save contains Settings with a negative score
                                    // should not be considered suitable at all
                                    int CalculateCharacterSettingsMatchScore(CharacterSettings objOptionsToCheck)
                                    {
                                        int intReturn = int.MaxValue
                                                        - ((intLegacyMaxKarma - objOptionsToCheck.BuildKarma)
                                                           .RaiseToPower(2)
                                                           + (decLegacyMaxNuyen - objOptionsToCheck.NuyenMaximumBP)
                                                           .RaiseToPower(2))
                                                          .RaiseToPower(0.5m).StandardRound();

                                        int intBaseline = objOptionsToCheck.BuiltInOption ? 5 : 4;

                                        if (Created && eSavedBuildMethod != CharacterBuildMethod.LifeModule)
                                        {
                                            if (objOptionsToCheck.BuildMethod != eSavedBuildMethod)
                                            {
                                                if (objOptionsToCheck.BuildMethod.UsesPriorityTables() ==
                                                    eSavedBuildMethod.UsesPriorityTables())
                                                    intReturn -= 2;
                                                else
                                                    intReturn -= 4;
                                            }
                                        }
                                        else if (objOptionsToCheck.BuildMethod != eSavedBuildMethod)
                                        {
                                            if (objOptionsToCheck.BuildMethod.UsesPriorityTables() ==
                                                eSavedBuildMethod.UsesPriorityTables())
                                            {
                                                intBaseline += 2;
                                                intReturn -= int.MaxValue / 2;
                                            }
                                            else
                                            {
                                                intBaseline += 4;
                                                intReturn -= int.MaxValue;
                                            }
                                        }

                                        int intBaselineCustomDataCount
                                            = objOptionsToCheck.EnabledCustomDataDirectoryInfos.Count;
                                        if (intBaselineCustomDataCount == 0)
                                        {
                                            intBaselineCustomDataCount = lstSavedCustomDataDirectoryNames.Count;
                                            if (intBaselineCustomDataCount > 0)
                                            {
                                                intReturn -= intBaselineCustomDataCount.RaiseToPower(2) * intBaseline;
                                            }
                                        }
                                        else if (lstSavedCustomDataDirectoryNames.Count == 0)
                                        {
                                            intReturn -= intBaselineCustomDataCount.RaiseToPower(2) * intBaseline;
                                        }
                                        else
                                        {
                                            intBaselineCustomDataCount
                                                = Math.Max(lstSavedCustomDataDirectoryNames.Count,
                                                           intBaselineCustomDataCount);
                                            for (int i = 0;
                                                 i < objOptionsToCheck.EnabledCustomDataDirectoryInfos.Count;
                                                 ++i)
                                            {
                                                string strLoopCustomDataName =
                                                    objOptionsToCheck.EnabledCustomDataDirectoryInfos[i].Name;
                                                int intLoopIndex =
                                                    lstSavedCustomDataDirectoryNames.IndexOf(strLoopCustomDataName);
                                                if (intLoopIndex < 0)
                                                    intReturn -= intBaselineCustomDataCount * intBaseline;
                                                else
                                                    intReturn -= Math.Abs(i - intLoopIndex) * intBaseline;
                                            }

                                            foreach (string strLoopCustomDataName in lstSavedCustomDataDirectoryNames)
                                            {
                                                if (objOptionsToCheck.EnabledCustomDataDirectoryInfos.All(
                                                        x => x.Name != strLoopCustomDataName))
                                                    intReturn -= intBaselineCustomDataCount * intBaseline;
                                            }
                                        }

                                        using (new FetchSafelyFromPool<HashSet<string>>(
                                                   Utils.StringHashSetPool, out HashSet<string> setDummyBooks))
                                        {
                                            setDummyBooks.AddRange(setSavedBooks);
                                            int intExtraBooks = 0;
                                            foreach (string strBook in objOptionsToCheck.Books)
                                            {
                                                if (setDummyBooks.Remove(strBook))
                                                    ++intExtraBooks;
                                            }

                                            setDummyBooks.IntersectWith(objOptionsToCheck.Books);
                                            intReturn -= (setDummyBooks.Count * (intBaselineCustomDataCount + 1)
                                                          + intExtraBooks) * intBaseline;
                                        }

                                        return intReturn;
                                    }
                                    // Calculate a score for a character option that roughly coincides with how suitable it is as a
                                    // replacement for the current one the character save contains Settings with a negative score
                                    // should not be considered suitable at all
                                    async ValueTask<int> CalculateCharacterSettingsMatchScoreAsync(CharacterSettings objOptionsToCheck)
                                    {
                                        int intReturn = int.MaxValue
                                                        - ((intLegacyMaxKarma - objOptionsToCheck.BuildKarma)
                                                           .RaiseToPower(2)
                                                           + (decLegacyMaxNuyen - objOptionsToCheck.NuyenMaximumBP)
                                                           .RaiseToPower(2))
                                                          .RaiseToPower(0.5m).StandardRound();

                                        int intBaseline = objOptionsToCheck.BuiltInOption ? 5 : 4;

                                        if (Created && eSavedBuildMethod != CharacterBuildMethod.LifeModule)
                                        {
                                            if (objOptionsToCheck.BuildMethod != eSavedBuildMethod)
                                            {
                                                if (objOptionsToCheck.BuildMethod.UsesPriorityTables() ==
                                                    eSavedBuildMethod.UsesPriorityTables())
                                                    intReturn -= 2;
                                                else
                                                    intReturn -= 4;
                                            }
                                        }
                                        else if (objOptionsToCheck.BuildMethod != eSavedBuildMethod)
                                        {
                                            if (objOptionsToCheck.BuildMethod.UsesPriorityTables() ==
                                                eSavedBuildMethod.UsesPriorityTables())
                                            {
                                                intBaseline += 2;
                                                intReturn -= int.MaxValue / 2;
                                            }
                                            else
                                            {
                                                intBaseline += 4;
                                                intReturn -= int.MaxValue;
                                            }
                                        }

                                        IReadOnlyList<CustomDataDirectoryInfo> lstOtherEnabledCustomDataDirectoryInfos
                                            = await objOptionsToCheck
                                                    .GetEnabledCustomDataDirectoryInfosAsync(token)
                                                    .ConfigureAwait(false);
                                        int intBaselineCustomDataCount = lstOtherEnabledCustomDataDirectoryInfos.Count;
                                        if (intBaselineCustomDataCount == 0)
                                        {
                                            intBaselineCustomDataCount = lstSavedCustomDataDirectoryNames.Count;
                                            if (intBaselineCustomDataCount > 0)
                                            {
                                                intReturn -= intBaselineCustomDataCount.RaiseToPower(2) * intBaseline;
                                            }
                                        }
                                        else if (lstSavedCustomDataDirectoryNames.Count == 0)
                                        {
                                            intReturn -= intBaselineCustomDataCount.RaiseToPower(2) * intBaseline;
                                        }
                                        else
                                        {
                                            intBaselineCustomDataCount
                                                = Math.Max(lstSavedCustomDataDirectoryNames.Count,
                                                           intBaselineCustomDataCount);
                                            for (int i = 0;
                                                 i < lstOtherEnabledCustomDataDirectoryInfos.Count;
                                                 ++i)
                                            {
                                                string strLoopCustomDataName =
                                                    lstOtherEnabledCustomDataDirectoryInfos[i].Name;
                                                int intLoopIndex =
                                                    lstSavedCustomDataDirectoryNames.IndexOf(strLoopCustomDataName);
                                                if (intLoopIndex < 0)
                                                    intReturn -= intBaselineCustomDataCount * intBaseline;
                                                else
                                                    intReturn -= Math.Abs(i - intLoopIndex) * intBaseline;
                                            }

                                            foreach (string strLoopCustomDataName in lstSavedCustomDataDirectoryNames)
                                            {
                                                if (lstOtherEnabledCustomDataDirectoryInfos.All(
                                                        x => x.Name != strLoopCustomDataName))
                                                    intReturn -= intBaselineCustomDataCount * intBaseline;
                                            }
                                        }

                                        using (new FetchSafelyFromPool<HashSet<string>>(
                                                   Utils.StringHashSetPool, out HashSet<string> setDummyBooks))
                                        {
                                            setDummyBooks.AddRange(setSavedBooks);
                                            int intExtraBooks = 0;
                                            IReadOnlyCollection<string> setOtherBooks
                                                = await objOptionsToCheck.GetBooksAsync(token).ConfigureAwait(false);
                                            foreach (string strBook in setOtherBooks)
                                            {
                                                if (setDummyBooks.Remove(strBook))
                                                    ++intExtraBooks;
                                            }

                                            setDummyBooks.IntersectWith(setOtherBooks);
                                            intReturn -= (setDummyBooks.Count * (intBaselineCustomDataCount + 1)
                                                          + intExtraBooks) * intBaseline;
                                        }

                                        return intReturn;
                                    }

                                    if (blnSync)
                                        blnSuccess = SettingsManager.LoadedCharacterSettings.TryGetValue(
                                            _strSettingsKey, out objProspectiveSettings);
                                    else
                                        (blnSuccess, objProspectiveSettings)
                                            = await (await SettingsManager.GetLoadedCharacterSettingsAsync(token)
                                                                          .ConfigureAwait(false)).TryGetValueAsync(
                                                _strSettingsKey, token).ConfigureAwait(false);

                                    if (!blnSuccess && blnHashCodeSuccess)
                                    {
                                        CharacterSettings objHashCodeMatchSettings
                                            = blnSync
                                                ? SettingsManager.LoadedCharacterSettings.FirstOrDefault(
                                                    x => x.Value.GetEquatableHashCode() == intSettingsHashCode).Value
                                                : (await (await SettingsManager
                                                                .GetLoadedCharacterSettingsAsync(token)
                                                                .ConfigureAwait(false))
                                                         .FirstOrDefaultAsync(
                                                             async x => await x.Value.GetEquatableHashCodeAsync(token)
                                                                               .ConfigureAwait(false)
                                                                        == intSettingsHashCode, token)
                                                         .ConfigureAwait(false)).Value;
                                        if (objHashCodeMatchSettings != default
                                            && objHashCodeMatchSettings.BuildMethod == eSavedBuildMethod)
                                        {
                                            blnSuccess = true;
                                            objProspectiveSettings = objHashCodeMatchSettings;
                                        }
                                    }

                                    if (!blnSuccess)
                                    {
                                        // Prompt if we want to switch options or leave
                                        if (!Utils.IsUnitTest && showWarnings)
                                        {
                                            if (Program.ShowScrollableMessageBox(
                                                    string.Format(GlobalSettings.CultureInfo,
                                                                  blnSync
                                                                      // ReSharper disable once MethodHasAsyncOverload
                                                                      ? LanguageManager.GetString(
                                                                          "Message_CharacterOptions_CannotLoadSetting",
                                                                          token: token)
                                                                      : await LanguageManager.GetStringAsync(
                                                                          "Message_CharacterOptions_CannotLoadSetting",
                                                                          token: token).ConfigureAwait(false),
                                                                  Path.GetFileNameWithoutExtension(_strSettingsKey)),
                                                    blnSync
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        ? LanguageManager.GetString(
                                                            "MessageTitle_CharacterOptions_CannotLoadSetting",
                                                            token: token)
                                                        : await LanguageManager.GetStringAsync(
                                                            "MessageTitle_CharacterOptions_CannotLoadSetting",
                                                            token: token).ConfigureAwait(false),
                                                    MessageBoxButtons.YesNo, MessageBoxIcon.Error) == DialogResult.No)
                                            {
                                                return false;
                                            }

                                            blnShowSelectBP = true;
                                        }

                                        // Set up interim options for selection by build method
                                        string strReplacementSettingsKey = string.Empty;
                                        int intMostSuitable = int.MinValue;
                                        if (blnSync)
                                        {
                                            // ReSharper disable once MethodHasAsyncOverload
                                            SettingsManager.LoadedCharacterSettings.ForEach(kvpLoopOptions =>
                                            {
                                                int intLoopScore
                                                    = CalculateCharacterSettingsMatchScore(kvpLoopOptions.Value);
                                                if (intLoopScore > intMostSuitable)
                                                {
                                                    intMostSuitable = intLoopScore;
                                                    strReplacementSettingsKey = kvpLoopOptions.Key;
                                                }
                                            }, token);
                                        }
                                        else
                                        {
                                            await SettingsManager.LoadedCharacterSettings.ForEachAsync(async kvpLoopOptions =>
                                            {
                                                int intLoopScore
                                                    = await CalculateCharacterSettingsMatchScoreAsync(kvpLoopOptions.Value).ConfigureAwait(false);
                                                if (intLoopScore > intMostSuitable)
                                                {
                                                    intMostSuitable = intLoopScore;
                                                    strReplacementSettingsKey = kvpLoopOptions.Key;
                                                }
                                            }, token).ConfigureAwait(false);
                                        }

                                        if (string.IsNullOrEmpty(strReplacementSettingsKey))
                                            blnSuccess = false;
                                        else if (blnSync)
                                            blnSuccess = SettingsManager.LoadedCharacterSettings.TryGetValue(
                                                strReplacementSettingsKey, out objProspectiveSettings);
                                        else
                                            (blnSuccess, objProspectiveSettings)
                                                = await (await SettingsManager.GetLoadedCharacterSettingsAsync(token)
                                                                              .ConfigureAwait(false)).TryGetValueAsync(
                                                    strReplacementSettingsKey, token).ConfigureAwait(false);

                                        if (!blnSuccess)
                                        {
                                            strReplacementSettingsKey
                                                = GlobalSettings.DefaultCharacterSettingDefaultValue;
                                            if (blnSync)
                                                blnSuccess = SettingsManager.LoadedCharacterSettings.TryGetValue(
                                                    strReplacementSettingsKey, out objProspectiveSettings);
                                            else
                                                (blnSuccess, objProspectiveSettings)
                                                    = await (await SettingsManager
                                                                   .GetLoadedCharacterSettingsAsync(token)
                                                                   .ConfigureAwait(false)).TryGetValueAsync(
                                                        strReplacementSettingsKey, token).ConfigureAwait(false);
                                            if (!blnSuccess)
                                            {
                                                if (blnSync)
                                                {
                                                    objProspectiveSettings
                                                        = SettingsManager.LoadedCharacterSettings.FirstOrDefault().Value;
                                                    strReplacementSettingsKey = objProspectiveSettings.DictionaryKey;
                                                }
                                                else
                                                {
                                                    objProspectiveSettings
                                                        = (await SettingsManager.LoadedCharacterSettings
                                                            .FirstOrDefaultAsync(token).ConfigureAwait(false))
                                                        .Value;
                                                    strReplacementSettingsKey = await objProspectiveSettings
                                                        .GetDictionaryKeyAsync(token).ConfigureAwait(false);
                                                }
                                            }
                                        }

                                        _strSettingsKey = strReplacementSettingsKey;
                                        LoadAsDirty = true;
                                    }
                                    else if (!Created && objProspectiveSettings.BuildMethod != eSavedBuildMethod)
                                    {
                                        // Prompt if we want to switch options or leave
                                        if (!Utils.IsUnitTest && showWarnings)
                                        {
                                            if (Program.ShowScrollableMessageBox(
                                                    string.Format(GlobalSettings.CultureInfo,
                                                                  blnSync
                                                                      // ReSharper disable once MethodHasAsyncOverload
                                                                      ? LanguageManager.GetString(
                                                                          "Message_CharacterOptions_DesyncBuildMethod",
                                                                          token: token)
                                                                      : await LanguageManager.GetStringAsync(
                                                                          "Message_CharacterOptions_DesyncBuildMethod",
                                                                          token: token).ConfigureAwait(false),
                                                                  Path.GetFileNameWithoutExtension(_strSettingsKey),
                                                                  blnSync
                                                                      // ReSharper disable once MethodHasAsyncOverload
                                                                      ? LanguageManager.GetString(
                                                                          "String_" + objProspectiveSettings
                                                                              .BuildMethod, token: token)
                                                                      : await LanguageManager.GetStringAsync(
                                                                              "String_" + objProspectiveSettings
                                                                                  .BuildMethod, token: token)
                                                                          .ConfigureAwait(false),
                                                                  blnSync
                                                                      // ReSharper disable once MethodHasAsyncOverload
                                                                      ? LanguageManager.GetString(
                                                                          "String_" + eSavedBuildMethod, token: token)
                                                                      : await LanguageManager.GetStringAsync(
                                                                              "String_" + eSavedBuildMethod,
                                                                              token: token)
                                                                          .ConfigureAwait(false)),
                                                    blnSync
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        ? LanguageManager.GetString(
                                                            "MessageTitle_CharacterOptions_DesyncBuildMethod",
                                                            token: token)
                                                        : await LanguageManager.GetStringAsync(
                                                            "MessageTitle_CharacterOptions_DesyncBuildMethod",
                                                            token: token).ConfigureAwait(false),
                                                    MessageBoxButtons.YesNo, MessageBoxIcon.Error) == DialogResult.No)
                                            {
                                                return false;
                                            }

                                            blnShowSelectBP = true;
                                        }

                                        // Set up interim options for selection by build method
                                        string strReplacementSettingsKey = string.Empty;
                                        int intMostSuitable = int.MinValue;
                                        if (blnSync)
                                        {
                                            // ReSharper disable once MethodHasAsyncOverload
                                            SettingsManager.LoadedCharacterSettings.ForEach(kvpLoopOptions =>
                                            {
                                                int intLoopScore
                                                    = CalculateCharacterSettingsMatchScore(kvpLoopOptions.Value);
                                                if (intLoopScore > intMostSuitable)
                                                {
                                                    intMostSuitable = intLoopScore;
                                                    strReplacementSettingsKey = kvpLoopOptions.Key;
                                                }
                                            }, token);
                                        }
                                        else
                                        {
                                            await SettingsManager.LoadedCharacterSettings.ForEachAsync(async kvpLoopOptions =>
                                            {
                                                int intLoopScore
                                                    = await CalculateCharacterSettingsMatchScoreAsync(kvpLoopOptions.Value).ConfigureAwait(false);
                                                if (intLoopScore > intMostSuitable)
                                                {
                                                    intMostSuitable = intLoopScore;
                                                    strReplacementSettingsKey = kvpLoopOptions.Key;
                                                }
                                            }, token).ConfigureAwait(false);
                                        }

                                        if (string.IsNullOrEmpty(strReplacementSettingsKey))
                                            blnSuccess = false;
                                        else if (blnSync)
                                            blnSuccess = SettingsManager.LoadedCharacterSettings.TryGetValue(
                                                strReplacementSettingsKey, out objProspectiveSettings);
                                        else
                                            (blnSuccess, objProspectiveSettings)
                                                = await (await SettingsManager.GetLoadedCharacterSettingsAsync(token)
                                                                              .ConfigureAwait(false)).TryGetValueAsync(
                                                    strReplacementSettingsKey, token).ConfigureAwait(false);

                                        if (!blnSuccess)
                                        {
                                            strReplacementSettingsKey
                                                = GlobalSettings.DefaultCharacterSettingDefaultValue;
                                            if (blnSync)
                                                blnSuccess = SettingsManager.LoadedCharacterSettings.TryGetValue(
                                                    strReplacementSettingsKey, out objProspectiveSettings);
                                            else
                                                (blnSuccess, objProspectiveSettings)
                                                    = await (await SettingsManager
                                                                   .GetLoadedCharacterSettingsAsync(token)
                                                                   .ConfigureAwait(false)).TryGetValueAsync(
                                                        strReplacementSettingsKey, token).ConfigureAwait(false);
                                            if (!blnSuccess)
                                            {
                                                if (blnSync)
                                                {
                                                    objProspectiveSettings
                                                        = SettingsManager.LoadedCharacterSettings.FirstOrDefault().Value;
                                                    strReplacementSettingsKey = objProspectiveSettings.DictionaryKey;
                                                }
                                                else
                                                {
                                                    objProspectiveSettings
                                                        = (await SettingsManager.LoadedCharacterSettings
                                                            .FirstOrDefaultAsync(token).ConfigureAwait(false))
                                                        .Value;
                                                    strReplacementSettingsKey = await objProspectiveSettings
                                                        .GetDictionaryKeyAsync(token).ConfigureAwait(false);
                                                }
                                            }
                                        }

                                        _strSettingsKey = strReplacementSettingsKey;
                                        LoadAsDirty = true;
                                    }
                                    else if (!Utils.IsUnitTest && showWarnings)
                                    {
                                        // Legacy load stuff
                                        if (setSavedBooks.Count > 0 || lstSavedCustomDataDirectoryNames.Count > 0)
                                        {
                                            // More books is fine, so just test if the stored book list is a subset of the current option's book list
                                            bool blnPromptConfirmSetting =
                                                !setSavedBooks.IsSubsetOf(objProspectiveSettings.Books);
                                            if (!blnPromptConfirmSetting)
                                            {
                                                IReadOnlyList<CustomDataDirectoryInfo> lstProspectiveInfos
                                                    = blnSync
                                                        ? objProspectiveSettings.EnabledCustomDataDirectoryInfos
                                                        : await objProspectiveSettings
                                                            .GetEnabledCustomDataDirectoryInfosAsync(token).ConfigureAwait(false);
                                                // More custom data directories is not fine because additional ones might apply rules that weren't present before, so prompt
                                                blnPromptConfirmSetting = lstSavedCustomDataDirectoryNames.Count !=
                                                                          lstProspectiveInfos.Count;
                                                if (!blnPromptConfirmSetting)
                                                {
                                                    // Check to make sure all the names are the same
                                                    for (int i = 0; i < lstSavedCustomDataDirectoryNames.Count; ++i)
                                                    {
                                                        if (lstSavedCustomDataDirectoryNames[i]
                                                            != lstProspectiveInfos[i].Name)
                                                        {
                                                            blnPromptConfirmSetting = true;
                                                            break;
                                                        }
                                                    }
                                                }
                                            }

                                            if (blnPromptConfirmSetting)
                                            {
                                                DialogResult eShowBPResult = Program.ShowScrollableMessageBox(
                                                    string.Format(
                                                        GlobalSettings.CultureInfo,
                                                        blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString(
                                                                "Message_CharacterOptions_DesyncBooksOrCustomData",
                                                                token: token)
                                                            : await LanguageManager.GetStringAsync(
                                                                "Message_CharacterOptions_DesyncBooksOrCustomData",
                                                                token: token).ConfigureAwait(false),
                                                        objProspectiveSettings.Name),
                                                    blnSync
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        ? LanguageManager.GetString(
                                                            "MessageTitle_CharacterOptions_DesyncBooksOrCustomData",
                                                            token: token)
                                                        : await LanguageManager.GetStringAsync(
                                                            "MessageTitle_CharacterOptions_DesyncBooksOrCustomData",
                                                            token: token).ConfigureAwait(false),
                                                    MessageBoxButtons.YesNoCancel, MessageBoxIcon.Warning);
                                                if (eShowBPResult == DialogResult.Cancel)
                                                {
                                                    return false;
                                                }

                                                blnShowSelectBP = eShowBPResult == DialogResult.Yes;
                                            }
                                        }
                                        else if (blnHashCodeSuccess
                                                 && !objProspectiveSettings.BuiltInOption
                                                 // Need to make sure that the save was made in the same version of Chummer, otherwise we can get a hash code mismatch from settings themselves changing
                                                 && LastSavedVersion.CompareTo(
                                                     new Version(
                                                         Application.ProductVersion.FastEscapeOnceFromStart("0.0.")))
                                                 == 0
                                                 && (blnSync
                                                     // ReSharper disable once MethodHasAsyncOverload
                                                     ? objProspectiveSettings.GetEquatableHashCode(token)
                                                     : await objProspectiveSettings.GetEquatableHashCodeAsync(
                                                         token).ConfigureAwait(false))
                                                 != intSettingsHashCode)
                                        {
                                            DialogResult eShowBPResult = Program.ShowScrollableMessageBox(
                                                string.Format(
                                                    GlobalSettings.CultureInfo,
                                                    blnSync
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        ? LanguageManager.GetString(
                                                            "Message_CharacterOptions_DesyncFromHashCode",
                                                            token: token)
                                                        : await LanguageManager.GetStringAsync(
                                                            "Message_CharacterOptions_DesyncFromHashCode",
                                                            token: token).ConfigureAwait(false),
                                                    objProspectiveSettings.Name),
                                                blnSync
                                                    // ReSharper disable once MethodHasAsyncOverload
                                                    ? LanguageManager.GetString(
                                                        "MessageTitle_CharacterOptions_DesyncFromHashCode",
                                                        token: token)
                                                    : await LanguageManager.GetStringAsync(
                                                        "MessageTitle_CharacterOptions_DesyncFromHashCode",
                                                        token: token).ConfigureAwait(false),
                                                MessageBoxButtons.YesNoCancel, MessageBoxIcon.Warning);
                                            if (eShowBPResult == DialogResult.Cancel)
                                            {
                                                return false;
                                            }

                                            blnShowSelectBP = eShowBPResult == DialogResult.Yes;
                                        }
                                    }
                                }

                                if (blnSync)
                                    Settings = objProspectiveSettings;
                                else
                                    await SetSettingsAsync(objProspectiveSettings, token).ConfigureAwait(false);

                                if (blnShowSelectBP)
                                {
                                    LoadAsDirty = true;
                                    if (blnSync)
                                    {
                                        // ReSharper disable once MethodHasAsyncOverload
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        using (ThreadSafeForm<SelectBuildMethod> frmPickBP
                                               = ThreadSafeForm<SelectBuildMethod>.Get(
                                                   () => new SelectBuildMethod(this, true)))
                                        {
                                            // ReSharper disable once MethodHasAsyncOverload
                                            if (frmPickBP.ShowDialogSafe(this, token) != DialogResult.OK)
                                            {
                                                return false;
                                            }
                                        }
                                    }
                                    else
                                    {
                                        using (ThreadSafeForm<SelectBuildMethod> frmPickBP
                                               = await ThreadSafeForm<SelectBuildMethod>
                                                       .GetAsync(() => new SelectBuildMethod(this, true), token)
                                                       .ConfigureAwait(false))
                                        {
                                            if (await frmPickBP.ShowDialogSafeAsync(this, token).ConfigureAwait(false)
                                                != DialogResult.OK)
                                            {
                                                return false;
                                            }
                                        }
                                    }
                                }

                                if (xmlCharacterNavigator.TryGetDecFieldQuickly("essenceatspecialstart",
                                        ref _decEssenceAtSpecialStart) &&
                                    _decEssenceAtSpecialStart > ESS.MetatypeMaximum)
                                {
                                    // fix to work around a mistake made when saving decimal values in previous versions.
                                    _decEssenceAtSpecialStart /= 10;
                                }

                                xmlCharacterNavigator.TryGetStringFieldQuickly("createdversion",
                                                                               ref _strVersionCreated);

                                // Metatype information.
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("iscritter", ref _blnIsCritter);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("metatype", ref _strMetatype);
                                if (!xmlCharacterNavigator.TryGetGuidFieldQuickly("metatypeid", ref _guiMetatype))
                                {
                                    // ReSharper disable once MethodHasAsyncOverload
                                    XPathNavigator objMetatypeNode = blnSync
                                        ? GetNodeXPath(true, token: token)
                                        : await GetNodeXPathAsync(true, token: token).ConfigureAwait(false);
                                    if (objMetatypeNode == null || !Guid.TryParse(
                                            (blnSync
                                                // ReSharper disable once MethodHasAsyncOverload
                                                ? objMetatypeNode.SelectSingleNodeAndCacheExpression("id", token)
                                                : await objMetatypeNode.SelectSingleNodeAndCacheExpressionAsync(
                                                    "id", token).ConfigureAwait(false))?.Value, out _guiMetatype))
                                    {
                                        return false;
                                    }
                                }

                                xmlCharacterNavigator.TryGetStringFieldQuickly("movement", ref _strMovement);

                                xmlCharacterNavigator.TryGetStringFieldQuickly("walk", ref _strWalk);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("run", ref _strRun);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("sprint", ref _strSprint);

                                if (blnSync)
                                {
                                    // ReSharper disable once MethodHasAsyncOverload
                                    _strRunAlt = xmlCharacterNavigator.SelectSingleNodeAndCacheExpression("run/@alt", token)
                                                                      ?.Value ??
                                                 string.Empty;
                                    // ReSharper disable once MethodHasAsyncOverload
                                    _strWalkAlt = xmlCharacterNavigator.SelectSingleNodeAndCacheExpression("walk/@alt", token)
                                                                       ?.Value ??
                                                  string.Empty;
                                    _strSprintAlt = xmlCharacterNavigator
                                                    // ReSharper disable once MethodHasAsyncOverload
                                                    .SelectSingleNodeAndCacheExpression("sprint/@alt", token)?.Value ??
                                                    string.Empty;
                                }
                                else
                                {
                                    _strRunAlt
                                        = (await xmlCharacterNavigator.SelectSingleNodeAndCacheExpressionAsync(
                                              "run/@alt", token).ConfigureAwait(false))?.Value ??
                                          string.Empty;
                                    _strWalkAlt
                                        = (await xmlCharacterNavigator.SelectSingleNodeAndCacheExpressionAsync(
                                              "walk/@alt", token).ConfigureAwait(false))?.Value ??
                                          string.Empty;
                                    _strSprintAlt
                                        = (await xmlCharacterNavigator.SelectSingleNodeAndCacheExpressionAsync(
                                              "sprint/@alt", token).ConfigureAwait(false))?.Value ??
                                          string.Empty;
                                }

                                xmlCharacterNavigator.TryGetInt32FieldQuickly("initiativedice",
                                                                              ref _intInitiativeDice);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("metatypebp", ref _intMetatypeBP);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("metavariant", ref _strMetavariant);
                                //Shim for characters created prior to Run Faster Errata
                                if (_strMetavariant == "Cyclopean")
                                {
                                    _strMetavariant = "Cyclops";
                                }

                                //Shim for metavariants that were saved with an incorrect metatype string.
                                if (!string.IsNullOrEmpty(_strMetavariant) && _strMetatype == _strMetavariant)
                                {
                                    // ReSharper disable once MethodHasAsyncOverload
                                    _strMetatype = (blnSync
                                            ? GetNodeXPath(true, token: token)
                                                // ReSharper disable once MethodHasAsyncOverload
                                                .SelectSingleNodeAndCacheExpression("name", token)
                                            : await (await GetNodeXPathAsync(true, token: token).ConfigureAwait(false))
                                                    .SelectSingleNodeAndCacheExpressionAsync("name", token)
                                                    .ConfigureAwait(false))
                                        ?.Value ?? "Human";
                                }

                                if (!xmlCharacterNavigator.TryGetGuidFieldQuickly("metavariantid",
                                        ref _guiMetavariant) &&
                                    !string.IsNullOrEmpty(_strMetavariant))
                                {
                                    XPathNavigator objMetavariantNode = blnSync
                                        // ReSharper disable once MethodHasAsyncOverload
                                        ? this.GetNodeXPath(token: token)
                                        : await this.GetNodeXPathAsync(token: token).ConfigureAwait(false);
                                    if (objMetavariantNode != null)
                                    {
                                        _guiMetavariant
                                            = Guid.Parse(
                                                (blnSync
                                                    // ReSharper disable once MethodHasAsyncOverload
                                                    ? objMetavariantNode.SelectSingleNodeAndCacheExpression("id", token)
                                                    : await objMetavariantNode
                                                            .SelectSingleNodeAndCacheExpressionAsync("id", token)
                                                            .ConfigureAwait(false))
                                                ?.Value);
                                    }
                                }

                                bool blnDoSourceFetch =
                                    !xmlCharacterNavigator.TryGetStringFieldQuickly("source", ref _strSource) ||
                                    string.IsNullOrEmpty(_strSource);
                                // ReSharper disable once ConvertIfToOrExpression
                                if (!xmlCharacterNavigator.TryGetStringFieldQuickly("page", ref _strPage) ||
                                    string.IsNullOrEmpty(_strPage) || _strPage == "0")
                                    blnDoSourceFetch = true;
                                if (blnDoSourceFetch)
                                {
                                    XPathNavigator xmlCharNode
                                        = blnSync
                                            // ReSharper disable once MethodHasAsyncOverload
                                            ? this.GetNodeXPath(token: token)
                                            : await this.GetNodeXPathAsync(token: token).ConfigureAwait(false);
                                    if (xmlCharNode != null)
                                    {
                                        if (blnSync)
                                        {
                                            // ReSharper disable once MethodHasAsyncOverload
                                            _strSource = xmlCharNode.SelectSingleNodeAndCacheExpression("source", token)?.Value
                                                         ?? _strSource;
                                            // ReSharper disable once MethodHasAsyncOverload
                                            _strPage = xmlCharNode.SelectSingleNodeAndCacheExpression("page", token)?.Value
                                                       ?? _strPage;
                                        }
                                        else
                                        {
                                            _strSource = (await xmlCharNode
                                                                .SelectSingleNodeAndCacheExpressionAsync(
                                                                    "source", token).ConfigureAwait(false))?.Value
                                                         ?? _strSource;
                                            _strPage = (await xmlCharNode
                                                              .SelectSingleNodeAndCacheExpressionAsync("page", token)
                                                              .ConfigureAwait(false))?.Value ?? _strPage;
                                        }
                                    }
                                }

                                xmlCharacterNavigator.TryGetStringFieldQuickly("metatypecategory",
                                                                               ref _strMetatypeCategory);

                                // General character information.
                                xmlCharacterNavigator.TryGetStringFieldQuickly("name", ref _strName);
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    LoadMugshots(xmlCharacterNavigator, token);
                                else
                                    await LoadMugshotsAsync(xmlCharacterNavigator, token).ConfigureAwait(false);
                                if (!xmlCharacterNavigator.TryGetStringFieldQuickly("gender", ref _strGender))
                                    xmlCharacterNavigator.TryGetStringFieldQuickly("sex", ref _strGender);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("age", ref _strAge);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("eyes", ref _strEyes);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("height", ref _strHeight);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("weight", ref _strWeight);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("skin", ref _strSkin);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("hair", ref _strHair);
                                xmlCharacterNavigator.TryGetMultiLineStringFieldQuickly("description",
                                    ref _strDescription);
                                xmlCharacterNavigator.TryGetMultiLineStringFieldQuickly("background",
                                    ref _strBackground);
                                xmlCharacterNavigator.TryGetMultiLineStringFieldQuickly("concept", ref _strConcept);
                                xmlCharacterNavigator.TryGetMultiLineStringFieldQuickly("notes", ref _strNotes);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("alias", ref _strAlias);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("playername", ref _strPlayerName);
                                xmlCharacterNavigator.TryGetMultiLineStringFieldQuickly("gamenotes",
                                    ref _strGameNotes);
                                if (!xmlCharacterNavigator.TryGetStringFieldQuickly("primaryarm",
                                        ref _strPrimaryArm))
                                    _strPrimaryArm = "Right";

                                xmlCharacterNavigator.TryGetStringFieldQuickly("prioritymetatype",
                                                                               ref _strPriorityMetatype);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("priorityattributes",
                                                                               ref _strPriorityAttributes);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("priorityspecial",
                                                                               ref _strPrioritySpecial);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("priorityskills",
                                                                               ref _strPrioritySkills);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("priorityresources",
                                                                               ref _strPriorityResources);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("prioritytalent",
                                                                               ref _strPriorityTalent);

                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    _lstPrioritySkills.Clear();
                                else
                                    await _lstPrioritySkills.ClearAsync(token).ConfigureAwait(false);
                                foreach (XPathNavigator xmlSkillName in (blnSync
                                             // ReSharper disable once MethodHasAsyncOverload
                                             ? xmlCharacterNavigator.SelectAndCacheExpression(
                                                 "priorityskills/priorityskill", token)
                                             : await xmlCharacterNavigator.SelectAndCacheExpressionAsync(
                                                 "priorityskills/priorityskill", token: token).ConfigureAwait(false)))
                                {
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstPrioritySkills.Add(xmlSkillName.Value);
                                    else
                                        await _lstPrioritySkills.AddAsync(xmlSkillName.Value, token)
                                                                .ConfigureAwait(false);
                                }

                                string strSkill1 = string.Empty;
                                string strSkill2 = string.Empty;
                                if (xmlCharacterNavigator.TryGetStringFieldQuickly("priorityskill1",
                                        ref strSkill1) &&
                                    !string.IsNullOrEmpty(strSkill1))
                                {
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstPrioritySkills.Add(strSkill1);
                                    else
                                        await _lstPrioritySkills.AddAsync(strSkill1, token).ConfigureAwait(false);
                                }

                                if (xmlCharacterNavigator.TryGetStringFieldQuickly("priorityskill2",
                                        ref strSkill2) &&
                                    !string.IsNullOrEmpty(strSkill2))
                                {
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstPrioritySkills.Add(strSkill2);
                                    else
                                        await _lstPrioritySkills.AddAsync(strSkill2, token).ConfigureAwait(false);
                                }

                                xmlCharacterNavigator.TryGetBoolFieldQuickly("possessed", ref _blnPossessed);

                                xmlCharacterNavigator.TryGetInt32FieldQuickly("contactpoints",
                                                                              ref _intCachedContactPoints);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("contactpointsused",
                                                                              ref _intContactPointsUsed);
                                xmlCharacterNavigator.TryGetDecFieldQuickly("basecarrylimit",
                                                                            ref _decCachedBaseCarryLimit);
                                xmlCharacterNavigator.TryGetDecFieldQuickly("baseliftlimit",
                                                                            ref _decCachedBaseLiftLimit);
                                xmlCharacterNavigator.TryGetDecFieldQuickly("totalcarriedweight",
                                                                            ref _decCachedTotalCarriedWeight);
                                xmlCharacterNavigator.TryGetDecFieldQuickly("encumbranceinterval",
                                                                            ref _decCachedEncumbranceInterval);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("cfplimit", ref _intCFPLimit);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("ainormalprogramlimit",
                                                                              ref _intAINormalProgramLimit);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("aiadvancedprogramlimit",
                                                                              ref _intAIAdvancedProgramLimit);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("currentcounterspellingdice",
                                                                              ref _intCurrentCounterspellingDice);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("currentliftcarryhits",
                                                                              ref _intCurrentLiftCarryHits);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("spelllimit", ref _intFreeSpells);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("karma", ref _intKarma);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("totalkarma", ref _intTotalKarma);

                                xmlCharacterNavigator.TryGetInt32FieldQuickly("special", ref _intSpecial);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("totalspecial", ref _intTotalSpecial);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("totalattributes",
                                                                              ref _intTotalAttributes);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("edgeused", ref _intEdgeUsed);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("streetcred", ref _intStreetCred);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("notoriety", ref _intNotoriety);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("publicawareness",
                                                                              ref _intPublicAwareness);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("burntstreetcred",
                                                                              ref _intBurntStreetCred);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("baseastralreputation",
                                                                              ref _intBaseAstralReputation);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("basewildreputation",
                                                                              ref _intBaseWildReputation);
                                xmlCharacterNavigator.TryGetDecFieldQuickly("nuyen", ref _decNuyen);
                                xmlCharacterNavigator.TryGetDecFieldQuickly("startingnuyen", ref _decStartingNuyen);
                                xmlCharacterNavigator.TryGetDecFieldQuickly("nuyenbp", ref _decNuyenBP);

                                xmlCharacterNavigator.TryGetBoolFieldQuickly("adept", ref _blnAdeptEnabled);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("magician", ref _blnMagicianEnabled);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("technomancer",
                                                                             ref _blnTechnomancerEnabled);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("ai", ref _blnAdvancedProgramsEnabled);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("cyberwaredisabled",
                                                                             ref _blnCyberwareDisabled);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("initiationdisabled",
                                                                             ref _blnInitiationDisabled);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("critter", ref _blnCritterEnabled);

                                xmlCharacterNavigator.TryGetDecFieldQuickly("prototypetranshuman",
                                                                            ref _decPrototypeTranshuman);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("magenabled", ref _blnMAGEnabled);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("initiategrade",
                                                                              ref _intInitiateGrade);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("resenabled", ref _blnRESEnabled);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("submersiongrade",
                                                                              ref _intSubmersionGrade);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("depenabled", ref _blnDEPEnabled);
                                // Legacy shim
                                if (!_blnCreated && !_blnMAGEnabled && !_blnRESEnabled && !_blnDEPEnabled)
                                    _decEssenceAtSpecialStart = decimal.MinValue;
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("groupmember", ref _blnGroupMember);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("groupname", ref _strGroupName);
                                xmlCharacterNavigator.TryGetMultiLineStringFieldQuickly("groupnotes",
                                    ref _strGroupNotes);
                                //end load_char_misc
                            }

                            XmlNodeList objXmlNodeList;
                            XmlNodeList objXmlLocationList;
                            XmlNode xmlRootQualitiesNode;

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("String_MentorSpirit", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("String_MentorSpirit",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_mentorspirit", loadActivity))
                            {
                                // Improvements.
                                using (objXmlNodeList = objXmlCharacter.SelectNodes("mentorspirits/mentorspirit"))
                                {
                                    foreach (XmlNode objXmlMentor in objXmlNodeList)
                                    {
                                        MentorSpirit objMentor = new MentorSpirit(this, objXmlMentor);
                                        objMentor.Load(objXmlMentor);
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstMentorSpirits.Add(objMentor);
                                        else
                                            await _lstMentorSpirits.AddAsync(objMentor, token).ConfigureAwait(false);
                                    }
                                }

                                //using finish("load_char_mentorspirit");
                            }

                            List<Improvement> lstCyberadeptSweepGrades =
                                new List<Improvement>(InitiationGrades.Count);

                            // Fastest way to clear is to just create a new bag and then interlock at the end
                            ConcurrentBag<string> lstInternalIdsNeedingReapplyImprovements
                                = new ConcurrentBag<string>();

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("Tab_Improvements", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("Tab_Improvements",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_imp", loadActivity))
                            {
                                // Improvements.
                                objXmlNodeList = objXmlCharacter.SelectNodes("improvements/improvement");
                                string strCharacterInnerXml = objXmlCharacter.InnerXml;
                                bool blnRemoveImprovements = Utils.IsUnitTest;
                                foreach (XmlNode objXmlImprovement in objXmlNodeList)
                                {
                                    string strImprovementSource = objXmlImprovement["improvementsource"]?.InnerText;
                                    switch (strImprovementSource)
                                    {
                                        // Do not load condition monitor improvements from older versions of Chummer
                                        case "ConditionMonitor":
                                            continue;
                                        // Load Edge use improvements from older versions of Chummer directly into Character's Edge Use property
                                        case "EdgeUse":
                                            decimal decOldEdgeUsed = 0;
                                            if (objXmlImprovement.TryGetDecFieldQuickly("aug", ref decOldEdgeUsed))
                                                EdgeUsed = (-decOldEdgeUsed).StandardRound();
                                            continue;
                                        case "EssenceLoss":
                                        case "EssenceLossChargen":
                                            // Do not load essence loss improvements if this character does not have any attributes affected by essence loss
                                            if (_decEssenceAtSpecialStart == decimal.MinValue)
                                                continue;
                                            break;
                                    }

                                    if ((blnRemoveImprovements || showWarnings) && objXmlImprovement["custom"]?.InnerText != bool.TrueString)
                                    {
                                        string strLoopSourceName = objXmlImprovement["sourcename"]?.InnerText;
                                        if (!string.IsNullOrEmpty(strLoopSourceName)
                                            && strLoopSourceName.IsGuid())
                                        {
                                            string[] astrToCheck =
                                            {
                                                "<guid>" + strLoopSourceName + "</guid>",
                                                "<metatypeid>" + strLoopSourceName + "</metatypeid>",
                                                "<metavariantid>" + strLoopSourceName + "</metavariantid>"
                                            };
                                            if (!strCharacterInnerXml.ContainsAny(astrToCheck, StringComparison.OrdinalIgnoreCase))
                                            {
                                                //Utils.BreakIfDebug();
                                                if (blnRemoveImprovements
                                                    || (Program.ShowScrollableMessageBox(
                                                            blnSync
                                                                // ReSharper disable once MethodHasAsyncOverload
                                                                ? LanguageManager.GetString(
                                                                    "Message_OrphanedImprovements", token: token)
                                                                : await LanguageManager.GetStringAsync(
                                                                        "Message_OrphanedImprovements", token: token)
                                                                    .ConfigureAwait(false),
                                                            blnSync
                                                                // ReSharper disable once MethodHasAsyncOverload
                                                                ? LanguageManager.GetString(
                                                                    "MessageTitle_OrphanedImprovements", token: token)
                                                                : await LanguageManager.GetStringAsync(
                                                                        "MessageTitle_OrphanedImprovements", token: token)
                                                                    .ConfigureAwait(false),
                                                            MessageBoxButtons.YesNo, MessageBoxIcon.Error) ==
                                                        DialogResult.Yes))
                                                {
                                                    blnRemoveImprovements = true;
                                                    continue;
                                                }

                                                return false;
                                            }
                                        }
                                    }

                                    Improvement objImprovement = new Improvement(this);
                                    try
                                    {
                                        objImprovement.Load(objXmlImprovement);
                                        // This is initially set to false make sure no property changers are triggered
                                        objImprovement.SetupComplete = true;
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstImprovements.Add(objImprovement);
                                        else
                                            await _lstImprovements.AddAsync(objImprovement, token)
                                                                  .ConfigureAwait(false);

                                        if (objImprovement.ImproveType ==
                                            Improvement.ImprovementType.SkillsoftAccess &&
                                            objImprovement.Value == 0)
                                        {
                                            lstInternalIdsNeedingReapplyImprovements.Add(objImprovement
                                                .SourceName);
                                        }
                                        // Cyberadept fix
                                        else if (LastSavedVersion <= new Version(5, 212, 78)
                                                 && objImprovement.ImproveSource ==
                                                 Improvement.ImprovementSource.Echo
                                                 && objImprovement.ImproveType ==
                                                 Improvement.ImprovementType.Attribute
                                                 && objImprovement.ImprovedName == "RESBase"
                                                 && objImprovement.Value > 0
                                                 && objImprovement.Value == objImprovement.Augmented)
                                        {
                                            // Cyberadept in these versions was an echo. It is no longer an echo, and so needs a more complicated reapplication
                                            if (Settings.SpecialKarmaCostBasedOnShownValue)
                                            {
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    _lstImprovements.Remove(objImprovement);
                                                else
                                                    await _lstImprovements.RemoveAsync(objImprovement, token)
                                                                          .ConfigureAwait(false);
                                            }
                                            else
                                                lstCyberadeptSweepGrades.Add(objImprovement);
                                        }
                                    }
                                    catch (ArgumentException)
                                    {
                                        lstInternalIdsNeedingReapplyImprovements.Add(
                                            objXmlImprovement["sourcename"]?.InnerText);
                                    }
                                }

                                //Timekeeper.Finish("load_char_imp");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("Label_Contacts", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("Label_Contacts",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_contacts", loadActivity))
                            {
                                // Contacts.
                                foreach (XPathNavigator xmlContact in
                                         (blnSync
                                             // ReSharper disable once MethodHasAsyncOverload
                                             ? xmlCharacterNavigator.SelectAndCacheExpression("contacts/contact", token)
                                             : await xmlCharacterNavigator.SelectAndCacheExpressionAsync(
                                                 "contacts/contact", token: token).ConfigureAwait(false)))
                                {
                                    Contact objContact = new Contact(this);
                                    if (blnSync)
                                    {
                                        // ReSharper disable once MethodHasAsyncOverload
                                        objContact.Load(xmlContact, token);
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstContacts.Add(objContact);
                                    }
                                    else
                                    {
                                        await objContact.LoadAsync(xmlContact, token).ConfigureAwait(false);
                                        await _lstContacts.AddAsync(objContact, token).ConfigureAwait(false);
                                    }
                                }

                                //Timekeeper.Finish("load_char_contacts");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("String_Qualities", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("String_Qualities",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_quality", loadActivity))
                            {
                                // Qualities

                                using (objXmlNodeList = objXmlCharacter.SelectNodes("qualities/quality"))
                                {
                                    bool blnHasOldQualities = false;
                                    xmlRootQualitiesNode =
                                        (blnSync
                                            // ReSharper disable once MethodHasAsyncOverload
                                            ? LoadData("qualities.xml", token: token)
                                            : await LoadDataAsync("qualities.xml", token: token).ConfigureAwait(false))
                                        .SelectSingleNode("/chummer/qualities");
                                    foreach (XmlNode objXmlQuality in objXmlNodeList)
                                    {
                                        if (objXmlQuality["name"] != null)
                                        {
                                            if (!CorrectedUnleveledQuality(objXmlQuality, xmlRootQualitiesNode))
                                            {
                                                Quality objQuality = new Quality(this);
                                                try
                                                {
                                                    objQuality.Load(objXmlQuality);
                                                    // Corrects an issue arising from older versions of CorrectedUnleveledQuality()
                                                    if (_lstQualities.Any(x => x.InternalId == objQuality.InternalId))
                                                        objQuality.SetGUID(Guid.NewGuid());
                                                    if (blnSync)
                                                    {
                                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                        _lstQualities.Add(objQuality);
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        if (objQuality.GetNodeXPath(token: token)
                                                                      // ReSharper disable once MethodHasAsyncOverload
                                                                      ?.SelectSingleNodeAndCacheExpression(
                                                                          "bonus/addgear/name", token)
                                                                      ?.Value == "Living Persona")
                                                            objLivingPersonaQuality = objQuality;
                                                    }
                                                    else
                                                    {
                                                        await _lstQualities.AddAsync(objQuality, token)
                                                                           .ConfigureAwait(false);
                                                        XPathNavigator objQualityNode = await objQuality
                                                            .GetNodeXPathAsync(token: token).ConfigureAwait(false);
                                                        if (objQualityNode != null
                                                            && (await objQualityNode
                                                                      .SelectSingleNodeAndCacheExpressionAsync(
                                                                          "bonus/addgear/name", token)
                                                                      .ConfigureAwait(false))?.Value
                                                            == "Living Persona")
                                                            objLivingPersonaQuality = objQuality;
                                                    }

                                                    // Legacy shim
                                                    if (LastSavedVersion <= new Version(5, 195, 1)
                                                        && (objQuality.Name == "The Artisan's Way"
                                                            || objQuality.Name == "The Artist's Way"
                                                            || objQuality.Name == "The Athlete's Way"
                                                            || objQuality.Name == "The Burnout's Way"
                                                            || objQuality.Name == "The Invisible Way"
                                                            || objQuality.Name == "The Magician's Way"
                                                            || objQuality.Name == "The Speaker's Way"
                                                            || objQuality.Name == "The Warrior's Way")
                                                        && objQuality.Bonus?.HasChildNodes == false)
                                                    {
                                                        if (blnSync)
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ImprovementManager.RemoveImprovements(this,
                                                                Improvement.ImprovementSource.Quality,
                                                                objQuality.InternalId, token: token);
                                                        else
                                                            await ImprovementManager.RemoveImprovementsAsync(this,
                                                                Improvement.ImprovementSource.Quality,
                                                                objQuality.InternalId, token).ConfigureAwait(false);
                                                        XmlNode objNode = blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? objQuality.GetNode(token: token)
                                                            : await objQuality.GetNodeAsync(token: token)
                                                                              .ConfigureAwait(false);
                                                        if (objNode != null)
                                                        {
                                                            objQuality.Bonus = objNode["bonus"];
                                                            if (objQuality.Bonus != null)
                                                            {
                                                                ImprovementManager.ForcedValue = objQuality.Extra;
                                                                if (blnSync)
                                                                    // ReSharper disable once MethodHasAsyncOverload
                                                                    ImprovementManager.CreateImprovements(this,
                                                                        Improvement.ImprovementSource.Quality,
                                                                        objQuality.InternalId, objQuality.Bonus, 1,
                                                                        objQuality.CurrentDisplayNameShort, token: token);
                                                                else
                                                                    await ImprovementManager.CreateImprovementsAsync(
                                                                            this,
                                                                            Improvement.ImprovementSource.Quality,
                                                                            objQuality.InternalId, objQuality.Bonus, 1,
                                                                            await objQuality
                                                                                .GetCurrentDisplayNameShortAsync(token)
                                                                                .ConfigureAwait(false), token: token)
                                                                        .ConfigureAwait(false);
                                                                if (!string.IsNullOrEmpty(
                                                                        ImprovementManager.SelectedValue))
                                                                {
                                                                    objQuality.Extra = ImprovementManager.SelectedValue;
                                                                }
                                                            }

                                                            objQuality.FirstLevelBonus = objNode["firstlevelbonus"];
                                                            if (objQuality.FirstLevelBonus?.HasChildNodes == true)
                                                            {
                                                                bool blnDoFirstLevel = true;
                                                                foreach (Quality objCheckQuality in Qualities)
                                                                {
                                                                    if (objCheckQuality != objQuality &&
                                                                        objCheckQuality.SourceID == objQuality.SourceID &&
                                                                        objCheckQuality.Extra == objQuality.Extra &&
                                                                        objCheckQuality.SourceName
                                                                        == objQuality.SourceName)
                                                                    {
                                                                        blnDoFirstLevel = false;
                                                                        break;
                                                                    }
                                                                }

                                                                if (blnDoFirstLevel)
                                                                {
                                                                    ImprovementManager.ForcedValue = objQuality.Extra;
                                                                    if (blnSync)
                                                                        // ReSharper disable once MethodHasAsyncOverload
                                                                        ImprovementManager.CreateImprovements(this,
                                                                            Improvement.ImprovementSource.Quality,
                                                                            objQuality.InternalId,
                                                                            objQuality.FirstLevelBonus, 1,
                                                                            objQuality.CurrentDisplayNameShort, token: token);
                                                                    else
                                                                        await ImprovementManager
                                                                              .CreateImprovementsAsync(
                                                                                  this,
                                                                                  Improvement.ImprovementSource.Quality,
                                                                                  objQuality.InternalId,
                                                                                  objQuality.FirstLevelBonus, 1,
                                                                                  await objQuality
                                                                                      .GetCurrentDisplayNameShortAsync(
                                                                                          token)
                                                                                      .ConfigureAwait(false),
                                                                                  token: token)
                                                                              .ConfigureAwait(false);
                                                                    if (!string.IsNullOrEmpty(ImprovementManager
                                                                            .SelectedValue))
                                                                    {
                                                                        objQuality.Extra
                                                                            = ImprovementManager.SelectedValue;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        else
                                                        {
                                                            lstInternalIdsNeedingReapplyImprovements.Add(
                                                                objQuality.InternalId);
                                                        }

                                                        objQuality.NaturalWeaponsNode = objNode["naturalweapons"];
                                                        if (objQuality.NaturalWeaponsNode != null)
                                                        {
                                                            ImprovementManager.ForcedValue = objQuality.Extra;
                                                            if (blnSync)
                                                                // ReSharper disable once MethodHasAsyncOverload
                                                                ImprovementManager.CreateImprovements(this,
                                                                    Improvement.ImprovementSource.Quality,
                                                                    objQuality.InternalId,
                                                                    objQuality.NaturalWeaponsNode, 1,
                                                                    objQuality.CurrentDisplayNameShort, token: token);
                                                            else
                                                                await ImprovementManager.CreateImprovementsAsync(this,
                                                                        Improvement.ImprovementSource.Quality,
                                                                        objQuality.InternalId,
                                                                        objQuality.NaturalWeaponsNode, 1,
                                                                        await objQuality
                                                                              .GetCurrentDisplayNameShortAsync(token)
                                                                              .ConfigureAwait(false), token: token)
                                                                    .ConfigureAwait(false);
                                                            if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                                            {
                                                                objQuality.Extra = ImprovementManager.SelectedValue;
                                                            }
                                                        }
                                                    }

                                                    if (LastSavedVersion <= new Version(5, 200, 0)
                                                        && objQuality.Name == "Made Man"
                                                        && objQuality.Bonus["selectcontact"] != null)
                                                    {
                                                        string selectedContactUniqueId = (Improvements.FirstOrDefault(
                                                                x =>
                                                                    x.SourceName == objQuality.InternalId &&
                                                                    x.ImproveType == Improvement.ImprovementType
                                                                        .ContactForcedLoyalty))
                                                            ?.ImprovedName;
                                                        if (string.IsNullOrWhiteSpace(selectedContactUniqueId))
                                                        {
                                                            selectedContactUniqueId =
                                                                Contacts.FirstOrDefault(x => x.Name == objQuality.Extra)
                                                                        ?.UniqueId;
                                                        }

                                                        if (string.IsNullOrWhiteSpace(selectedContactUniqueId))
                                                        {
                                                            // Populate the Magician Traditions list.
                                                            using (new FetchSafelyFromPool<List<ListItem>>(
                                                                       Utils.ListItemListPool,
                                                                       out List<ListItem> lstContacts))
                                                            {
                                                                foreach (Contact objContact in Contacts)
                                                                {
                                                                    if (objContact.IsGroup)
                                                                        lstContacts.Add(new ListItem(objContact.Name,
                                                                            objContact.UniqueId));
                                                                }

                                                                if (lstContacts.Count > 1)
                                                                {
                                                                    lstContacts.Sort(CompareListItems.CompareNames);
                                                                }

                                                                if (blnSync)
                                                                {
                                                                    // ReSharper disable once MethodHasAsyncOverload
                                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                                    using (ThreadSafeForm<SelectItem> frmPickItem
                                                                           = ThreadSafeForm<SelectItem>.Get(
                                                                               () => new SelectItem()))
                                                                    {
                                                                        frmPickItem.MyForm
                                                                            .SetDropdownItemsMode(lstContacts);
                                                                        // ReSharper disable once MethodHasAsyncOverload
                                                                        if (frmPickItem.ShowDialogSafe(this, token)
                                                                            != DialogResult.OK)
                                                                        {
                                                                            return false;
                                                                        }

                                                                        selectedContactUniqueId
                                                                            = frmPickItem.MyForm.SelectedItem;
                                                                    }
                                                                }
                                                                else
                                                                {
                                                                    using (ThreadSafeForm<SelectItem> frmPickItem
                                                                           = await ThreadSafeForm<SelectItem>
                                                                               .GetAsync(() => new SelectItem(), token)
                                                                               .ConfigureAwait(false))
                                                                    {
                                                                        frmPickItem.MyForm
                                                                            .SetDropdownItemsMode(lstContacts);
                                                                        if (await frmPickItem
                                                                                .ShowDialogSafeAsync(this, token)
                                                                                .ConfigureAwait(false)
                                                                            != DialogResult.OK)
                                                                        {
                                                                            return false;
                                                                        }

                                                                        selectedContactUniqueId
                                                                            = frmPickItem.MyForm.SelectedItem;
                                                                    }
                                                                }
                                                            }
                                                        }

                                                        objQuality.Bonus =
                                                            xmlRootQualitiesNode.SelectSingleNode(
                                                                "quality[name=\"Made Man\"]/bonus");
                                                        objQuality.Extra = string.Empty;
                                                        try
                                                        {
                                                            if (blnSync)
                                                            {
                                                                // ReSharper disable MethodHasAsyncOverload
                                                                ImprovementManager.RemoveImprovements(this,
                                                                    Improvement.ImprovementSource.Quality,
                                                                    objQuality.InternalId, token: token);
                                                                ImprovementManager.CreateImprovement(this, string.Empty,
                                                                    Improvement.ImprovementSource.Quality,
                                                                    objQuality.InternalId,
                                                                    Improvement.ImprovementType.MadeMan,
                                                                    objQuality.CurrentDisplayNameShort, token: token);
                                                                ImprovementManager.CreateImprovement(
                                                                    this, selectedContactUniqueId,
                                                                    Improvement.ImprovementSource.Quality,
                                                                    objQuality.InternalId,
                                                                    Improvement.ImprovementType.AddContact,
                                                                    objQuality.CurrentDisplayNameShort, token: token);
                                                                ImprovementManager.CreateImprovement(
                                                                    this, selectedContactUniqueId,
                                                                    Improvement.ImprovementSource.Quality,
                                                                    objQuality.InternalId,
                                                                    Improvement.ImprovementType.ContactForcedLoyalty,
                                                                    objQuality.CurrentDisplayNameShort, token: token);
                                                                ImprovementManager.CreateImprovement(
                                                                    this, selectedContactUniqueId,
                                                                    Improvement.ImprovementSource.Quality,
                                                                    objQuality.InternalId,
                                                                    Improvement.ImprovementType.ContactForceGroup,
                                                                    objQuality.CurrentDisplayNameShort, token: token);
                                                                ImprovementManager.CreateImprovement(
                                                                    this, selectedContactUniqueId,
                                                                    Improvement.ImprovementSource.Quality,
                                                                    objQuality.InternalId,
                                                                    Improvement.ImprovementType.ContactMakeFree,
                                                                    objQuality.CurrentDisplayNameShort, token: token);
                                                                // ReSharper restore MethodHasAsyncOverload
                                                            }
                                                            else
                                                            {
                                                                await ImprovementManager.RemoveImprovementsAsync(this,
                                                                    Improvement.ImprovementSource.Quality,
                                                                    objQuality.InternalId, token).ConfigureAwait(false);
                                                                await ImprovementManager.CreateImprovementAsync(
                                                                        this, string.Empty,
                                                                        Improvement.ImprovementSource.Quality,
                                                                        objQuality.InternalId,
                                                                        Improvement.ImprovementType.MadeMan,
                                                                        await objQuality
                                                                              .GetCurrentDisplayNameShortAsync(token)
                                                                              .ConfigureAwait(false), token: token)
                                                                    .ConfigureAwait(false);
                                                                await ImprovementManager.CreateImprovementAsync(
                                                                        this, selectedContactUniqueId,
                                                                        Improvement.ImprovementSource.Quality,
                                                                        objQuality.InternalId,
                                                                        Improvement.ImprovementType.AddContact,
                                                                        await objQuality
                                                                              .GetCurrentDisplayNameShortAsync(token)
                                                                              .ConfigureAwait(false), token: token)
                                                                    .ConfigureAwait(false);
                                                                await ImprovementManager.CreateImprovementAsync(
                                                                        this, selectedContactUniqueId,
                                                                        Improvement.ImprovementSource.Quality,
                                                                        objQuality.InternalId,
                                                                        Improvement.ImprovementType
                                                                            .ContactForcedLoyalty,
                                                                        await objQuality
                                                                              .GetCurrentDisplayNameShortAsync(token)
                                                                              .ConfigureAwait(false), token: token)
                                                                    .ConfigureAwait(false);
                                                                await ImprovementManager.CreateImprovementAsync(
                                                                        this, selectedContactUniqueId,
                                                                        Improvement.ImprovementSource.Quality,
                                                                        objQuality.InternalId,
                                                                        Improvement.ImprovementType.ContactForceGroup,
                                                                        await objQuality
                                                                              .GetCurrentDisplayNameShortAsync(token)
                                                                              .ConfigureAwait(false), token: token)
                                                                    .ConfigureAwait(false);
                                                                await ImprovementManager.CreateImprovementAsync(
                                                                        this, selectedContactUniqueId,
                                                                        Improvement.ImprovementSource.Quality,
                                                                        objQuality.InternalId,
                                                                        Improvement.ImprovementType.ContactMakeFree,
                                                                        await objQuality
                                                                              .GetCurrentDisplayNameShortAsync(token)
                                                                              .ConfigureAwait(false), token: token)
                                                                    .ConfigureAwait(false);
                                                            }
                                                        }
                                                        catch
                                                        {
                                                            if (blnSync)
                                                                // ReSharper disable once MethodHasAsyncOverload
                                                                ImprovementManager.Rollback(this, CancellationToken.None);
                                                            else
                                                                await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                                                            throw;
                                                        }

                                                        ImprovementManager.Commit(this);
                                                    }

                                                    if (LastSavedVersion <= new Version(5, 212, 43)
                                                        && objQuality.Name == "Inspired"
                                                        && objQuality.Source == "SASS"
                                                        && objQuality.Bonus["selectexpertise"] == null)
                                                    {
                                                        // Old handling of SASS' Inspired quality was both hardcoded and wrong
                                                        // Since SASS' Inspired requires the player to choose a specialization, we always need a prompt,
                                                        // so add the quality to the list for processing when the character is opened.
                                                        lstInternalIdsNeedingReapplyImprovements.Add(
                                                            objQuality.InternalId);
                                                    }

                                                    if (LastSavedVersion <= new Version(5, 212, 56)
                                                        && objQuality.Name == "Chain Breaker"
                                                        && objQuality.Bonus == null)
                                                    {
                                                        // Chain Breaker bonus requires manual selection of two spirit types, so we need a prompt.
                                                        lstInternalIdsNeedingReapplyImprovements.Add(
                                                            objQuality.InternalId);
                                                    }

                                                    if (LastSavedVersion <= new Version(5, 212, 78)
                                                        && objQuality.Name == "Resonant Stream: Cyberadept"
                                                        && objQuality.Bonus == null)
                                                    {
                                                        objQuality.Bonus =
                                                            xmlRootQualitiesNode.SelectSingleNode(
                                                                "quality[name=\"Resonant Stream: Cyberadept\"]/bonus");
                                                        try
                                                        {
                                                            if (blnSync)
                                                            {
                                                                // ReSharper disable MethodHasAsyncOverload
                                                                ImprovementManager.RemoveImprovements(this,
                                                                    Improvement.ImprovementSource.Quality,
                                                                    objQuality.InternalId, token: token);
                                                                ImprovementManager.CreateImprovement(this, string.Empty,
                                                                    Improvement.ImprovementSource.Quality,
                                                                    objQuality.InternalId,
                                                                    Improvement.ImprovementType.CyberadeptDaemon,
                                                                    objQuality.CurrentDisplayNameShort, token: token);
                                                                // ReSharper restore MethodHasAsyncOverload
                                                            }
                                                            else
                                                            {
                                                                await ImprovementManager.RemoveImprovementsAsync(this,
                                                                        Improvement.ImprovementSource.Quality,
                                                                        objQuality.InternalId, token: token)
                                                                    .ConfigureAwait(false);
                                                                await ImprovementManager.CreateImprovementAsync(
                                                                        this, string.Empty,
                                                                        Improvement.ImprovementSource.Quality,
                                                                        objQuality.InternalId,
                                                                        Improvement.ImprovementType.CyberadeptDaemon,
                                                                        await objQuality
                                                                              .GetCurrentDisplayNameShortAsync(token)
                                                                              .ConfigureAwait(false), token: token)
                                                                    .ConfigureAwait(false);
                                                            }
                                                        }
                                                        catch
                                                        {
                                                            if (blnSync)
                                                                // ReSharper disable once MethodHasAsyncOverload
                                                                ImprovementManager.Rollback(this, CancellationToken.None);
                                                            else
                                                                await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                                                            throw;
                                                        }

                                                        ImprovementManager.Commit(this);
                                                    }
                                                }
                                                catch
                                                {
                                                    if (blnSync)
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        objQuality.Dispose();
                                                    else
                                                        await objQuality.DisposeAsync().ConfigureAwait(false);
                                                    throw;
                                                }
                                            }
                                        }
                                        else
                                        {
                                            // If the Quality does not have a name tag, it is in the old format. Set the flag to show that old Qualities are in use.
                                            blnHasOldQualities = true;
                                        }
                                    }

                                    // If old Qualities are in use, they need to be converted before loading can continue.
                                    if (blnHasOldQualities)
                                        ConvertOldQualities(objXmlNodeList);
                                    //Timekeeper.Finish("load_char_quality");
                                }
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("Label_Attributes", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("Label_Attributes",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_attributes", loadActivity))
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    AttributeSection.Load(objXmlCharacter, token);
                                else
                                    await AttributeSection.LoadAsync(objXmlCharacter, token).ConfigureAwait(false);
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("String_Tradition", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("String_Tradition",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_misc2", loadActivity))
                            {
                                // Attempt to load the split MAG CharacterAttribute information for Mystic Adepts.
                                if (_blnAdeptEnabled && _blnMagicianEnabled)
                                {
                                    xmlCharacterNavigator.TryGetInt32FieldQuickly("magsplitadept",
                                        ref _intMAGAdept);
                                    xmlCharacterNavigator.TryGetInt32FieldQuickly("magsplitmagician",
                                        ref _intMAGMagician);
                                }

                                // Attempt to load in the character's tradition (or equivalent for Technomancers)
                                string strTemp = string.Empty;
                                if (xmlCharacterNavigator.TryGetStringFieldQuickly("stream", ref strTemp) &&
                                    !string.IsNullOrEmpty(strTemp) && RESEnabled)
                                {
                                    // Legacy load a Technomancer tradition
                                    XmlNode xmlTraditionListDataNode =
                                        (blnSync
                                            // ReSharper disable once MethodHasAsyncOverload
                                            ? LoadData("streams.xml", token: token)
                                            : await LoadDataAsync("streams.xml", token: token).ConfigureAwait(false))
                                        .SelectSingleNode("/chummer/traditions");
                                    if (xmlTraditionListDataNode != null)
                                    {
                                        XmlNode xmlTraditionDataNode =
                                            xmlTraditionListDataNode.TryGetNodeByNameOrId("tradition", strTemp);
                                        if (xmlTraditionDataNode != null)
                                        {
                                            if (!_objTradition.Create(xmlTraditionDataNode, true))
                                            {
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    _objTradition.ResetTradition();
                                                else
                                                    await _objTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                                            }
                                        }
                                        else
                                        {
                                            xmlTraditionDataNode =
                                                xmlTraditionListDataNode.SelectSingleNode(
                                                    "tradition[name = \"Default\"]");
                                            if (xmlTraditionDataNode != null)
                                            {
                                                if (!_objTradition.Create(xmlTraditionDataNode, true))
                                                {
                                                    if (blnSync)
                                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                        _objTradition.ResetTradition();
                                                    else
                                                        await _objTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                                                }
                                            }
                                            else
                                            {
                                                xmlTraditionDataNode =
                                                    xmlTraditionListDataNode["tradition"];
                                                if (xmlTraditionDataNode != null &&
                                                    !_objTradition.Create(xmlTraditionDataNode, true))
                                                {
                                                    if (blnSync)
                                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                        _objTradition.ResetTradition();
                                                    else
                                                        await _objTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                                                }
                                            }
                                        }
                                    }

                                    if (_objTradition.Type != TraditionType.None)
                                    {
                                        _objTradition.LegacyLoad(xmlCharacterNavigator);
                                    }
                                }
                                else
                                {
                                    XPathNavigator xpathTraditionNavigator = blnSync
                                        // ReSharper disable once MethodHasAsyncOverload
                                        ? xmlCharacterNavigator.SelectSingleNodeAndCacheExpression("tradition", token)
                                        : await xmlCharacterNavigator
                                                .SelectSingleNodeAndCacheExpressionAsync("tradition", token)
                                                .ConfigureAwait(false);
                                    // Regular tradition load
                                    if (xpathTraditionNavigator != null)
                                    {
                                        if (blnSync
                                                // ReSharper disable once MethodHasAsyncOverload
                                                ? (xpathTraditionNavigator.SelectSingleNodeAndCacheExpression("guid", token)
                                                   != null
                                                   // ReSharper disable once MethodHasAsyncOverload
                                                   || xpathTraditionNavigator.SelectSingleNodeAndCacheExpression("id", token)
                                                   != null)
                                                : (await xpathTraditionNavigator
                                                         .SelectSingleNodeAndCacheExpressionAsync("guid", token)
                                                         .ConfigureAwait(false) != null
                                                   || await xpathTraditionNavigator
                                                            .SelectSingleNodeAndCacheExpressionAsync("id", token)
                                                            .ConfigureAwait(false) != null))
                                        {
                                            _objTradition.Load(objXmlCharacter["tradition"]);
                                        }
                                        else if (blnSync
                                                     ? MAGEnabled
                                                     : await GetMAGEnabledAsync(token).ConfigureAwait(false))
                                        {
                                            XmlNode xmlTraditionListDataNode =
                                                (blnSync
                                                    // ReSharper disable once MethodHasAsyncOverload
                                                    ? LoadData("traditions.xml", token: token)
                                                    : await LoadDataAsync("traditions.xml", token: token)
                                                        .ConfigureAwait(false))
                                                .SelectSingleNode("/chummer/traditions");
                                            if (xmlTraditionListDataNode != null)
                                            {
                                                xmlCharacterNavigator.TryGetStringFieldQuickly("tradition",
                                                    ref strTemp);
                                                XmlNode xmlTraditionDataNode =
                                                    xmlTraditionListDataNode.TryGetNodeByNameOrId("tradition", strTemp);
                                                if (xmlTraditionDataNode != null)
                                                {
                                                    if (!_objTradition.Create(xmlTraditionDataNode))
                                                    {
                                                        if (blnSync)
                                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                            _objTradition.ResetTradition();
                                                        else
                                                            await _objTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                                                    }
                                                }
                                                else
                                                {
                                                    xmlTraditionDataNode =
                                                        xmlTraditionListDataNode.TryGetNodeByNameOrId("tradition", Tradition.CustomMagicalTraditionGuid);
                                                    if (xmlTraditionDataNode != null &&
                                                        !_objTradition.Create(xmlTraditionDataNode))
                                                    {
                                                        if (blnSync)
                                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                            _objTradition.ResetTradition();
                                                        else
                                                            await _objTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                                                    }
                                                }
                                            }

                                            if (_objTradition.Type != TraditionType.None)
                                            {
                                                _objTradition.LegacyLoad(xmlCharacterNavigator);
                                            }
                                        }
                                    }
                                    // Not null but doesn't have children -> legacy load a magical tradition
                                    else if (xpathTraditionNavigator != null && MAGEnabled)
                                    {
                                        XmlNode xmlTraditionListDataNode =
                                            (blnSync
                                                // ReSharper disable once MethodHasAsyncOverload
                                                ? LoadData("traditions.xml", token: token)
                                                : await LoadDataAsync("traditions.xml", token: token)
                                                    .ConfigureAwait(false))
                                            .SelectSingleNode("/chummer/traditions");
                                        if (xmlTraditionListDataNode != null)
                                        {
                                            xmlCharacterNavigator.TryGetStringFieldQuickly("tradition",
                                                ref strTemp);
                                            XmlNode xmlTraditionDataNode =
                                                xmlTraditionListDataNode.TryGetNodeByNameOrId("tradition", strTemp);
                                            if (xmlTraditionDataNode != null)
                                            {
                                                if (!_objTradition.Create(xmlTraditionDataNode))
                                                {
                                                    if (blnSync)
                                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                        _objTradition.ResetTradition();
                                                    else
                                                        await _objTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                                                }
                                            }
                                            else
                                            {
                                                xmlTraditionDataNode =
                                                    xmlTraditionListDataNode.TryGetNodeByNameOrId("tradition", Tradition.CustomMagicalTraditionGuid);
                                                if (xmlTraditionDataNode != null &&
                                                    !_objTradition.Create(xmlTraditionDataNode))
                                                {
                                                    if (blnSync)
                                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                        _objTradition.ResetTradition();
                                                    else
                                                        await _objTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                                                }
                                            }
                                        }

                                        if (_objTradition.Type != TraditionType.None)
                                        {
                                            _objTradition.LegacyLoad(xmlCharacterNavigator);
                                        }
                                    }
                                }

                                // Attempt to load Condition Monitor Progress.
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("physicalcmfilled",
                                                                              ref _intPhysicalCMFilled);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("stuncmfilled", ref _intStunCMFilled);

                                xmlCharacterNavigator.TryGetBoolFieldQuickly("psyche", ref _blnPsycheActive);
                                //Timekeeper.Finish("load_char_misc2");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_Skills", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager
                                                                  .GetStringAsync("Tab_Skills", token: token)
                                                                  .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_skills", loadActivity)) //slightly messy
                            {
                                _oldSkillsBackup = objXmlCharacter["skills"]?.Clone();
                                _oldSkillGroupBackup = objXmlCharacter["skillgroups"]?.Clone();

                                XmlNode objSkillNode = objXmlCharacter["newskills"];
                                if (blnSync)
                                {
                                    if (objSkillNode != null)
                                    {
                                        // ReSharper disable once MethodHasAsyncOverload
                                        SkillsSection.Load(objSkillNode, false, loadActivity, token);
                                    }
                                    else
                                    {
                                        // ReSharper disable once MethodHasAsyncOverload
                                        SkillsSection.Load(objXmlCharacter, true, loadActivity, token);
                                    }
                                }
                                else if (objSkillNode != null)
                                {
                                    await SkillsSection.LoadAsync(objSkillNode, false, loadActivity, token)
                                                       .ConfigureAwait(false);
                                }
                                else
                                {
                                    await SkillsSection.LoadAsync(objXmlCharacter, true, loadActivity, token)
                                                       .ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_skills");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("String_Locations", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("String_Locations",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_loc", loadActivity))
                            {
                                // Locations.
                                objXmlLocationList = objXmlCharacter.SelectNodes("gearlocations/gearlocation");
                                foreach (XmlNode objXmlLocation in objXmlLocationList)
                                {
                                    Location objLocation = new Location(this, _lstGearLocations);
                                    objLocation.Load(objXmlLocation);
                                }

                                objXmlLocationList = objXmlCharacter.SelectNodes("locations/location");
                                foreach (XmlNode objXmlLocation in objXmlLocationList)
                                {
                                    Location objLocation = new Location(this, _lstGearLocations);
                                    objLocation.Load(objXmlLocation);
                                }

                                objXmlLocationList = objXmlCharacter.SelectNodes("gearlocations/location");
                                foreach (XmlNode objXmlLocation in objXmlLocationList)
                                {
                                    Location objLocation = new Location(this, _lstGearLocations);
                                    objLocation.Load(objXmlLocation);
                                }

                                //Timekeeper.Finish("load_char_loc");
                            }

                            using (Timekeeper.StartSyncron("load_char_abundle", loadActivity))
                            {
                                // Armor Bundles.
                                objXmlLocationList = objXmlCharacter.SelectNodes("armorbundles/armorbundle");
                                foreach (XmlNode objXmlLocation in objXmlLocationList)
                                {
                                    Location objLocation = new Location(this, _lstArmorLocations);
                                    objLocation.Load(objXmlLocation);
                                }

                                objXmlLocationList = objXmlCharacter.SelectNodes("armorlocations/armorlocation");
                                foreach (XmlNode objXmlLocation in objXmlLocationList)
                                {
                                    Location objLocation = new Location(this, _lstArmorLocations);
                                    objLocation.Load(objXmlLocation);
                                }

                                objXmlLocationList = objXmlCharacter.SelectNodes("armorlocations/location");
                                foreach (XmlNode objXmlLocation in objXmlLocationList)
                                {
                                    Location objLocation = new Location(this, _lstArmorLocations);
                                    objLocation.Load(objXmlLocation);
                                }

                                //Timekeeper.Finish("load_char_abundle");
                            }

                            using (Timekeeper.StartSyncron("load_char_vloc", loadActivity))
                            {
                                // Vehicle Locations.
                                XmlNodeList objXmlVehicleLocationList =
                                    objXmlCharacter.SelectNodes("vehiclelocations/vehiclelocation");
                                foreach (XmlNode objXmlLocation in objXmlVehicleLocationList)
                                {
                                    Location objLocation = new Location(this, _lstVehicleLocations);
                                    objLocation.Load(objXmlLocation);
                                }

                                objXmlVehicleLocationList =
                                    objXmlCharacter.SelectNodes("vehiclelocations/location");
                                foreach (XmlNode objXmlLocation in objXmlVehicleLocationList)
                                {
                                    Location objLocation = new Location(this, _lstVehicleLocations);
                                    objLocation.Load(objXmlLocation);
                                }

                                //Timekeeper.Finish("load_char_vloc");
                            }

                            using (Timekeeper.StartSyncron("load_char_wloc", loadActivity))
                            {
                                // Weapon Locations.
                                XmlNodeList objXmlWeaponLocationList =
                                    objXmlCharacter.SelectNodes("weaponlocations/weaponlocation");
                                foreach (XmlNode objXmlLocation in objXmlWeaponLocationList)
                                {
                                    Location objLocation = new Location(this, _lstWeaponLocations);
                                    objLocation.Load(objXmlLocation);
                                }

                                objXmlWeaponLocationList = objXmlCharacter.SelectNodes("weaponlocations/location");
                                foreach (XmlNode objXmlLocation in objXmlWeaponLocationList)
                                {
                                    Location objLocation = new Location(this, _lstWeaponLocations);
                                    objLocation.Load(objXmlLocation);
                                }

                                //Timekeeper.Finish("load_char_wloc");
                            }

                            using (Timekeeper.StartSyncron("load_char_sfoci", loadActivity))
                            {
                                // Stacked Foci.
                                objXmlNodeList = objXmlCharacter.SelectNodes("stackedfoci/stackedfocus");
                                foreach (XmlNode objXmlStack in objXmlNodeList)
                                {
                                    StackedFocus objStack = new StackedFocus(this);
                                    objStack.Load(objXmlStack);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstStackedFoci.Add(objStack);
                                    else
                                        await _lstStackedFoci.AddAsync(objStack, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_sfoci");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_Armor", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager
                                                                  .GetStringAsync("Tab_Armor", token: token)
                                                                  .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_armor", loadActivity))
                            {
                                // Armor.
                                objXmlNodeList = objXmlCharacter.SelectNodes("armors/armor");
                                foreach (XmlNode objXmlArmor in objXmlNodeList)
                                {
                                    Armor objArmor = new Armor(this);
                                    objArmor.Load(objXmlArmor);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstArmor.Add(objArmor);
                                    else
                                        await _lstArmor.AddAsync(objArmor, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_armor");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_Drugs", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager
                                                                  .GetStringAsync("Tab_Drugs", token: token)
                                                                  .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_drugs", loadActivity))
                            {
                                // Drugs.
                                objXmlNodeList = objXmlDocument.SelectNodes("/character/drugs/drug");
                                foreach (XmlNode objXmlDrug in objXmlNodeList)
                                {
                                    Drug objDrug = new Drug(this);
                                    objDrug.Load(objXmlDrug);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstDrugs.Add(objDrug);
                                    else
                                        await _lstDrugs.AddAsync(objDrug, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_drugs");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("Tab_Cyberware", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager
                                                                  .GetStringAsync("Tab_Cyberware", token: token)
                                                                  .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_ware", loadActivity))
                            {
                                // Cyberware/Bioware.
                                objXmlNodeList = objXmlCharacter.SelectNodes("cyberwares/cyberware");
                                // Dictionary for instantly re-applying outdated improvements for 'ware with pair bonuses in legacy shim
                                Dictionary<Cyberware, int> dicPairableCyberwares =
                                    new Dictionary<Cyberware, int>(objXmlNodeList.Count);
                                foreach (XmlNode objXmlCyberware in objXmlNodeList)
                                {
                                    Cyberware objCyberware = new Cyberware(this);
                                    objCyberware.Load(objXmlCyberware);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstCyberware.Add(objCyberware);
                                    else
                                        await _lstCyberware.AddAsync(objCyberware, token).ConfigureAwait(false);
                                    // Legacy shim #1
                                    if (objCyberware.Name == "Myostatin Inhibitor" &&
                                        LastSavedVersion <= new Version(5, 195, 1) &&
                                        !Improvements.Any(x =>
                                                              x.SourceName == objCyberware.InternalId &&
                                                              x.ImproveType == Improvement.ImprovementType
                                                                  .AttributeKarmaCost))
                                    {
                                        XmlNode objNode = blnSync
                                            // ReSharper disable once MethodHasAsyncOverload
                                            ? objCyberware.GetNode(token: token)
                                            : await objCyberware.GetNodeAsync(token: token).ConfigureAwait(false);
                                        if (objNode != null)
                                        {
                                            if (blnSync)
                                            {
                                                // ReSharper disable once MethodHasAsyncOverload
                                                ImprovementManager.RemoveImprovements(this, objCyberware.SourceType,
                                                    objCyberware.InternalId, token: token);
                                                // ReSharper disable once MethodHasAsyncOverload
                                                ImprovementManager.RemoveImprovements(this, objCyberware.SourceType,
                                                    objCyberware.InternalId + "Pair", token: token);
                                            }
                                            else
                                            {
                                                await ImprovementManager.RemoveImprovementsAsync(
                                                    this, objCyberware.SourceType,
                                                    objCyberware.InternalId, token: token).ConfigureAwait(false);
                                                await ImprovementManager.RemoveImprovementsAsync(
                                                                            this, objCyberware.SourceType,
                                                                            objCyberware.InternalId + "Pair",
                                                                            token: token)
                                                                        .ConfigureAwait(false);
                                            }

                                            objCyberware.Bonus = objNode["bonus"];
                                            objCyberware.WirelessBonus = objNode["wirelessbonus"];
                                            objCyberware.PairBonus = objNode["pairbonus"];
                                            if (!string.IsNullOrEmpty(objCyberware.Forced) &&
                                                objCyberware.Forced != "Right" &&
                                                objCyberware.Forced != "Left")
                                                ImprovementManager.ForcedValue = objCyberware.Forced;
                                            if (objCyberware.Bonus != null)
                                            {
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverload
                                                    ImprovementManager.CreateImprovements(this, objCyberware.SourceType,
                                                        objCyberware.InternalId, objCyberware.Bonus,
                                                        objCyberware.Rating,
                                                        objCyberware.CurrentDisplayNameShort, token: token);
                                                else
                                                    await ImprovementManager.CreateImprovementsAsync(
                                                                                this, objCyberware.SourceType,
                                                                                objCyberware.InternalId,
                                                                                objCyberware.Bonus,
                                                                                await objCyberware.GetRatingAsync(token)
                                                                                    .ConfigureAwait(false),
                                                                                await objCyberware
                                                                                    .GetCurrentDisplayNameShortAsync(
                                                                                        token)
                                                                                    .ConfigureAwait(false),
                                                                                token: token)
                                                                            .ConfigureAwait(false);
                                                if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                                    objCyberware.Extra = ImprovementManager.SelectedValue;
                                            }

                                            if (objCyberware.WirelessOn && objCyberware.WirelessBonus != null)
                                            {
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverload
                                                    ImprovementManager.CreateImprovements(this, objCyberware.SourceType,
                                                        objCyberware.InternalId, objCyberware.WirelessBonus,
                                                        objCyberware.Rating,
                                                        objCyberware.CurrentDisplayNameShort, token: token);
                                                else
                                                    await ImprovementManager.CreateImprovementsAsync(
                                                                                this, objCyberware.SourceType,
                                                                                objCyberware.InternalId,
                                                                                objCyberware.WirelessBonus,
                                                                                await objCyberware.GetRatingAsync(token)
                                                                                    .ConfigureAwait(false),
                                                                                await objCyberware
                                                                                    .GetCurrentDisplayNameShortAsync(
                                                                                        token)
                                                                                    .ConfigureAwait(false),
                                                                                token: token)
                                                                            .ConfigureAwait(false);
                                                if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue) &&
                                                    string.IsNullOrEmpty(objCyberware.Extra))
                                                    objCyberware.Extra = ImprovementManager.SelectedValue;
                                            }

                                            if (!objCyberware.IsModularCurrentlyEquipped)
                                            {
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    objCyberware.ChangeModularEquip(false);
                                                else
                                                    await objCyberware.ChangeModularEquipAsync(false, token: token)
                                                                      .ConfigureAwait(false);
                                            }
                                            else if (objCyberware.PairBonus != null)
                                            {
                                                Cyberware objMatchingCyberware =
                                                    dicPairableCyberwares.Keys.FirstOrDefault(
                                                        x =>
                                                            x.Name == objCyberware.Name &&
                                                            x.Extra == objCyberware.Extra);
                                                if (objMatchingCyberware != null)
                                                    ++dicPairableCyberwares[objMatchingCyberware];
                                                else
                                                    dicPairableCyberwares.Add(objCyberware, 1);
                                            }
                                        }
                                        else
                                            lstInternalIdsNeedingReapplyImprovements.Add(objCyberware.InternalId);
                                    }
                                }

                                // Legacy Shim #2 (needed to be separate because we're dealing with PairBonuses here, and we don't know if something needs its PairBonus reapplied until all Cyberwares have been loaded)
                                if (LastSavedVersion <= new Version(5, 200, 0))
                                {
                                    if (blnSync)
                                    {
                                        // ReSharper disable MethodHasAsyncOverload
                                        Cyberware.ForEach(objCyberware =>
                                        {
                                            if (objCyberware.PairBonus?.HasChildNodes == true &&
                                                !Cyberware.DeepAny(x => x.Children, x =>
                                                {
                                                    if (!objCyberware.IncludePair.Contains(x.Name) ||
                                                        x.Extra != objCyberware.Extra ||
                                                        !x.IsModularCurrentlyEquipped)
                                                        return false;
                                                    string strToMatch = x.InternalId + "Pair";
                                                    return Improvements.Any(y => y.SourceName == strToMatch);
                                                }))
                                            {
                                                XmlNode objNode = objCyberware.GetNode(token: token);
                                                if (objNode != null)
                                                {
                                                    ImprovementManager.RemoveImprovements(this, objCyberware.SourceType,
                                                        objCyberware.InternalId, token: token);
                                                    ImprovementManager.RemoveImprovements(this, objCyberware.SourceType,
                                                        objCyberware.InternalId + "Pair", token: token);

                                                    objCyberware.Bonus = objNode["bonus"];
                                                    objCyberware.WirelessBonus = objNode["wirelessbonus"];
                                                    objCyberware.PairBonus = objNode["pairbonus"];
                                                    if (!string.IsNullOrEmpty(objCyberware.Forced) &&
                                                        objCyberware.Forced != "Right" &&
                                                        objCyberware.Forced != "Left")
                                                        ImprovementManager.ForcedValue = objCyberware.Forced;
                                                    if (objCyberware.Bonus != null)
                                                    {
                                                        ImprovementManager.CreateImprovements(this,
                                                            objCyberware.SourceType,
                                                            objCyberware.InternalId, objCyberware.Bonus,
                                                            objCyberware.Rating,
                                                            objCyberware.CurrentDisplayNameShort, token: token);
                                                        if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                                            objCyberware.Extra = ImprovementManager.SelectedValue;
                                                    }

                                                    if (objCyberware.WirelessOn && objCyberware.WirelessBonus != null)
                                                    {
                                                        ImprovementManager.CreateImprovements(this,
                                                            objCyberware.SourceType,
                                                            objCyberware.InternalId, objCyberware.WirelessBonus,
                                                            objCyberware.Rating,
                                                            objCyberware.CurrentDisplayNameShort, token: token);
                                                        if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue) &&
                                                            string.IsNullOrEmpty(objCyberware.Extra))
                                                            objCyberware.Extra = ImprovementManager.SelectedValue;
                                                    }

                                                    if (!objCyberware.IsModularCurrentlyEquipped)
                                                    {
                                                        objCyberware.ChangeModularEquip(false);
                                                    }
                                                    else if (objCyberware.PairBonus != null)
                                                    {
                                                        Cyberware objMatchingCyberware =
                                                            dicPairableCyberwares.Keys.FirstOrDefault(
                                                                x =>
                                                                    x.Name == objCyberware.Name &&
                                                                    x.Extra == objCyberware.Extra);
                                                        if (objMatchingCyberware != null)
                                                            ++dicPairableCyberwares[objMatchingCyberware];
                                                        else
                                                            dicPairableCyberwares.Add(objCyberware, 1);
                                                    }
                                                }
                                                else
                                                    lstInternalIdsNeedingReapplyImprovements.Add(objCyberware.InternalId);
                                            }
                                        }, token);
                                        // ReSharper restore MethodHasAsyncOverload
                                    }
                                    else
                                    {
                                        await Cyberware.ForEachAsync(async objCyberware =>
                                        {
                                            if (objCyberware.PairBonus?.HasChildNodes == true &&
                                                !await Cyberware.DeepAnyAsync(x => x.Children, async x =>
                                                {
                                                    if (!objCyberware.IncludePair.Contains(x.Name) ||
                                                        x.Extra != objCyberware.Extra ||
                                                        !await x.GetIsModularCurrentlyEquippedAsync(token).ConfigureAwait(false))
                                                        return false;
                                                    string strToMatch = x.InternalId + "Pair";
                                                    return await Improvements.AnyAsync(y => y.SourceName == strToMatch, token).ConfigureAwait(false);
                                                }, token).ConfigureAwait(false))
                                            {
                                                XmlNode objNode = await objCyberware.GetNodeAsync(token: token).ConfigureAwait(false);
                                                if (objNode != null)
                                                {
                                                    await ImprovementManager.RemoveImprovementsAsync(
                                                        this, objCyberware.SourceType,
                                                        objCyberware.InternalId, token: token).ConfigureAwait(false);
                                                    await ImprovementManager.RemoveImprovementsAsync(
                                                                                this, objCyberware.SourceType,
                                                                                objCyberware.InternalId + "Pair",
                                                                                token: token)
                                                                            .ConfigureAwait(false);
                                                    objCyberware.Bonus = objNode["bonus"];
                                                    objCyberware.WirelessBonus = objNode["wirelessbonus"];
                                                    objCyberware.PairBonus = objNode["pairbonus"];
                                                    if (!string.IsNullOrEmpty(objCyberware.Forced) &&
                                                        objCyberware.Forced != "Right" &&
                                                        objCyberware.Forced != "Left")
                                                        ImprovementManager.ForcedValue = objCyberware.Forced;
                                                    if (objCyberware.Bonus != null)
                                                    {
                                                        await ImprovementManager.CreateImprovementsAsync(this,
                                                                objCyberware.SourceType,
                                                                objCyberware.InternalId, objCyberware.Bonus,
                                                                await objCyberware.GetRatingAsync(token)
                                                                    .ConfigureAwait(false),
                                                                await objCyberware
                                                                      .GetCurrentDisplayNameShortAsync(token)
                                                                      .ConfigureAwait(false), token: token)
                                                            .ConfigureAwait(false);
                                                        if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                                            objCyberware.Extra = ImprovementManager.SelectedValue;
                                                    }

                                                    if (objCyberware.WirelessOn && objCyberware.WirelessBonus != null)
                                                    {
                                                        await ImprovementManager.CreateImprovementsAsync(this,
                                                                objCyberware.SourceType,
                                                                objCyberware.InternalId, objCyberware.WirelessBonus,
                                                                await objCyberware.GetRatingAsync(token)
                                                                    .ConfigureAwait(false),
                                                                await objCyberware
                                                                      .GetCurrentDisplayNameShortAsync(token)
                                                                      .ConfigureAwait(false), token: token)
                                                            .ConfigureAwait(false);
                                                        if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue) &&
                                                            string.IsNullOrEmpty(objCyberware.Extra))
                                                            objCyberware.Extra = ImprovementManager.SelectedValue;
                                                    }

                                                    if (!await objCyberware.GetIsModularCurrentlyEquippedAsync(token).ConfigureAwait(false))
                                                    {
                                                        await objCyberware.ChangeModularEquipAsync(false, token: token)
                                                                          .ConfigureAwait(false);
                                                    }
                                                    else if (objCyberware.PairBonus != null)
                                                    {
                                                        Cyberware objMatchingCyberware =
                                                            dicPairableCyberwares.Keys.FirstOrDefault(
                                                                x =>
                                                                    x.Name == objCyberware.Name &&
                                                                    x.Extra == objCyberware.Extra);
                                                        if (objMatchingCyberware != null)
                                                            ++dicPairableCyberwares[objMatchingCyberware];
                                                        else
                                                            dicPairableCyberwares.Add(objCyberware, 1);
                                                    }
                                                }
                                                else
                                                    lstInternalIdsNeedingReapplyImprovements.Add(objCyberware.InternalId);
                                            }
                                        }, token).ConfigureAwait(false);
                                    }
                                }

                                // Separate Pass for PairBonuses
                                foreach (KeyValuePair<Cyberware, int> objItem in dicPairableCyberwares)
                                {
                                    Cyberware objCyberware = objItem.Key;
                                    int intCyberwaresCount = objItem.Value;
                                    List<Cyberware> lstPairableCyberwares = Cyberware.DeepWhere(x => x.Children,
                                        x => objCyberware.IncludePair.Contains(x.Name) &&
                                             x.Extra == objCyberware.Extra &&
                                             x.IsModularCurrentlyEquipped).ToList();
                                    // Need to use slightly different logic if this cyberware has a location (Left or Right) and only pairs with itself because Lefts can only be paired with Rights and Rights only with Lefts
                                    if (!string.IsNullOrEmpty(objCyberware.Location) &&
                                        objCyberware.IncludePair.All(x => x == objCyberware.Name))
                                    {
                                        int intMatchLocationCount = 0;
                                        int intNotMatchLocationCount = 0;
                                        foreach (Cyberware objPairableCyberware in lstPairableCyberwares)
                                        {
                                            if (objPairableCyberware.Location != objCyberware.Location)
                                                ++intNotMatchLocationCount;
                                            else
                                                ++intMatchLocationCount;
                                        }

                                        // Set the count to the total number of cyberwares in matching pairs, which would mean 2x the number of whichever location contains the fewest members (since every single one of theirs would have a pair)
                                        intCyberwaresCount =
                                            Math.Min(intNotMatchLocationCount, intMatchLocationCount) *
                                            2;
                                    }

                                    if (intCyberwaresCount > 0)
                                    {
                                        foreach (Cyberware objLoopCyberware in lstPairableCyberwares)
                                        {
                                            if ((intCyberwaresCount & 1) == 0)
                                            {
                                                if (!string.IsNullOrEmpty(objCyberware.Forced) &&
                                                    objCyberware.Forced != "Right" &&
                                                    objCyberware.Forced != "Left")
                                                    ImprovementManager.ForcedValue = objCyberware.Forced;
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverload
                                                    ImprovementManager.CreateImprovements(this,
                                                        objLoopCyberware.SourceType,
                                                        objLoopCyberware.InternalId + "Pair",
                                                        objLoopCyberware.PairBonus,
                                                        objLoopCyberware.Rating,
                                                        objLoopCyberware.CurrentDisplayNameShort, token: token);
                                                else
                                                    await ImprovementManager.CreateImprovementsAsync(this,
                                                                                objLoopCyberware.SourceType,
                                                                                objLoopCyberware.InternalId + "Pair",
                                                                                objLoopCyberware.PairBonus,
                                                                                await objLoopCyberware
                                                                                    .GetRatingAsync(token)
                                                                                    .ConfigureAwait(false),
                                                                                await objLoopCyberware
                                                                                    .GetCurrentDisplayNameShortAsync(
                                                                                        token)
                                                                                    .ConfigureAwait(false),
                                                                                token: token)
                                                                            .ConfigureAwait(false);
                                                if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue) &&
                                                    string.IsNullOrEmpty(objCyberware.Extra))
                                                    objCyberware.Extra = ImprovementManager.SelectedValue;
                                            }

                                            --intCyberwaresCount;
                                            if (intCyberwaresCount <= 0)
                                                break;
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_ware");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("Label_SelectedSpells", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("Label_SelectedSpells",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_spells", loadActivity))
                            {
                                // Spells.
                                objXmlNodeList = objXmlCharacter.SelectNodes("spells/spell");
                                foreach (XmlNode objXmlSpell in objXmlNodeList)
                                {
                                    Spell objSpell = new Spell(this);
                                    objSpell.Load(objXmlSpell);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstSpells.Add(objSpell);
                                    else
                                        await _lstSpells.AddAsync(objSpell, token).ConfigureAwait(false);
                                }
                                //Timekeeper.Finish("load_char_spells");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_Adept", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager
                                                                  .GetStringAsync("Tab_Adept", token: token)
                                                                  .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_powers", loadActivity))
                            {
                                // Powers.
                                objXmlNodeList = objXmlCharacter.SelectNodes("powers/power");
                                if (objXmlNodeList.Count > 0)
                                {
                                    using (new FetchSafelyFromPool<List<ListItem>>(
                                               Utils.ListItemListPool, out List<ListItem> lstPowerOrder))
                                    {
                                        bool blnDoEnhancedAccuracyRefresh =
                                            LastSavedVersion <= new Version(5, 198, 26);
                                        // Sort the Powers in alphabetical order.
                                        foreach (XmlNode xmlPower in objXmlNodeList)
                                        {
                                            string strGuid = xmlPower["guid"]?.InnerText;
                                            string strPowerName = xmlPower["name"]?.InnerText ?? string.Empty;
                                            if (blnDoEnhancedAccuracyRefresh
                                                && strPowerName == "Enhanced Accuracy (skill)")
                                            {
                                                lstInternalIdsNeedingReapplyImprovements.Add(strGuid);
                                            }

                                            if (!string.IsNullOrEmpty(strGuid))
                                                lstPowerOrder.Add(new ListItem(strGuid,
                                                                               strPowerName
                                                                               + (xmlPower["extra"]?.InnerText
                                                                                   ?? string.Empty)));
                                            else
                                            {
                                                Power objPower = new Power(this);
                                                objPower.Load(xmlPower);
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    _lstPowers.Add(objPower);
                                                else
                                                    await _lstPowers.AddAsync(objPower, token).ConfigureAwait(false);
                                            }
                                        }

                                        lstPowerOrder.Sort(CompareListItems.CompareNames);

                                        foreach (ListItem objItem in lstPowerOrder)
                                        {
                                            XmlNode objNode =
                                                objXmlCharacter.SelectSingleNode(
                                                    "powers/power[guid = " + objItem.Value.ToString().CleanXPath()
                                                                           + ']');
                                            if (objNode != null)
                                            {
                                                Power objPower = new Power(this);
                                                objPower.Load(objNode);
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    _lstPowers.Add(objPower);
                                                else
                                                    await _lstPowers.AddAsync(objPower, token).ConfigureAwait(false);
                                            }
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_powers");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("Label_Spirits", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager
                                                                  .GetStringAsync("Label_Spirits", token: token)
                                                                  .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_spirits", loadActivity))
                            {
                                // Spirits/Sprites.
                                foreach (XPathNavigator xmlSpirit in (blnSync
                                             // ReSharper disable once MethodHasAsyncOverload
                                             ? xmlCharacterNavigator.SelectAndCacheExpression("spirits/spirit", token)
                                             : await xmlCharacterNavigator.SelectAndCacheExpressionAsync(
                                                 "spirits/spirit", token: token).ConfigureAwait(false)))
                                {
                                    Spirit objSpirit = new Spirit(this);
                                    if (blnSync)
                                    {
                                        // ReSharper disable once MethodHasAsyncOverload
                                        objSpirit.Load(xmlSpirit, token);
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstSpirits.Add(objSpirit);
                                    }
                                    else
                                    {
                                        await objSpirit.LoadAsync(xmlSpirit, token).ConfigureAwait(false);
                                        await _lstSpirits.AddAsync(objSpirit, token).ConfigureAwait(false);
                                    }
                                }

                                // If we don't have any Fettered spirits, make sure that we
                                if (blnSync)
                                {
                                    if (!_lstSpirits.Any(s => s.Fettered) && Improvements.Any(imp =>
                                            imp.ImproveSource == Improvement.ImprovementSource.SpiritFettering))
                                    {
                                        // ReSharper disable once MethodHasAsyncOverload
                                        ImprovementManager.RemoveImprovements(
                                            this, Improvement.ImprovementSource.SpiritFettering, token: token);
                                    }
                                }
                                else
                                {
                                    if (!await _lstSpirits.AnyAsync(s => s.Fettered, token).ConfigureAwait(false)
                                        && await Improvements
                                                 .AnyAsync(
                                                     imp => imp.ImproveSource
                                                            == Improvement.ImprovementSource.SpiritFettering, token)
                                                 .ConfigureAwait(false))
                                    {
                                        await ImprovementManager.RemoveImprovementsAsync(this,
                                                                    Improvement.ImprovementSource.SpiritFettering,
                                                                    token: token)
                                                                .ConfigureAwait(false);
                                    }
                                }

                                //Timekeeper.Finish("load_char_spirits");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("Label_ComplexForms", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("Label_ComplexForms",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_complex", loadActivity))
                            {
                                // Complex Forms/Technomancer Programs.
                                objXmlNodeList = objXmlCharacter.SelectNodes("complexforms/complexform");
                                foreach (XmlNode objXmlComplexForm in objXmlNodeList)
                                {
                                    ComplexForm objComplexForm = new ComplexForm(this);
                                    objComplexForm.Load(objXmlComplexForm);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstComplexForms.Add(objComplexForm);
                                    else
                                        await _lstComplexForms.AddAsync(objComplexForm, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_complex");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("Tab_AdvancedPrograms", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("Tab_AdvancedPrograms",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_aiprogram", loadActivity))
                            {
                                // Complex Forms/Technomancer Programs.
                                objXmlNodeList = objXmlCharacter.SelectNodes("aiprograms/aiprogram");
                                foreach (XmlNode objXmlProgram in objXmlNodeList)
                                {
                                    AIProgram objProgram = new AIProgram(this);
                                    objProgram.Load(objXmlProgram);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstAIPrograms.Add(objProgram);
                                    else
                                        await _lstAIPrograms.AddAsync(objProgram, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_aiprogram");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("Tab_MartialArts", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("Tab_MartialArts",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_martialarts", loadActivity))
                            {
                                // Martial Arts.
                                objXmlNodeList = objXmlCharacter.SelectNodes("martialarts/martialart");
                                foreach (XmlNode objXmlArt in objXmlNodeList)
                                {
                                    MartialArt objMartialArt = new MartialArt(this);
                                    objMartialArt.Load(objXmlArt);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstMartialArts.Add(objMartialArt);
                                    else
                                        await _lstMartialArts.AddAsync(objMartialArt, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_marts");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_Limits", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager
                                                                  .GetStringAsync("Tab_Limits", token: token)
                                                                  .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_mod", loadActivity))
                            {
                                // Limit Modifiers.
                                objXmlNodeList = objXmlCharacter.SelectNodes("limitmodifiers/limitmodifier");
                                foreach (XmlNode objXmlLimit in objXmlNodeList)
                                {
                                    LimitModifier obLimitModifier = new LimitModifier(this);
                                    obLimitModifier.Load(objXmlLimit);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstLimitModifiers.Add(obLimitModifier);
                                    else
                                        await _lstLimitModifiers.AddAsync(obLimitModifier, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_mod");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("String_SelectPACKSKit_Lifestyles", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager
                                              .GetStringAsync("String_SelectPACKSKit_Lifestyles", token: token)
                                              .ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_lifestyle", loadActivity))
                            {
                                // Lifestyles.
                                objXmlNodeList = objXmlCharacter.SelectNodes("lifestyles/lifestyle");
                                foreach (XmlNode objXmlLifestyle in objXmlNodeList)
                                {
                                    Lifestyle objLifestyle = new Lifestyle(this);
                                    objLifestyle.Load(objXmlLifestyle);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstLifestyles.Add(objLifestyle);
                                    else
                                        await _lstLifestyles.AddAsync(objLifestyle, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_lifestyle");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_Gear", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager
                                                                  .GetStringAsync("Tab_Gear", token: token)
                                                                  .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_gear", loadActivity))
                            {
                                // <gears>
                                objXmlNodeList = objXmlCharacter.SelectNodes("gears/gear");
                                foreach (XmlNode objXmlGear in objXmlNodeList)
                                {
                                    Gear objGear = new Gear(this);
                                    objGear.Load(objXmlGear);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstGear.Add(objGear);
                                    else
                                        await _lstGear.AddAsync(objGear, token).ConfigureAwait(false);
                                }

                                // If the character has a technomancer quality but no Living Persona commlink, its improvements get re-applied immediately
                                if (objLivingPersonaQuality != null && LastSavedVersion <= new Version(5, 195, 1))
                                {
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverload
                                        ImprovementManager.RemoveImprovements(this,
                                                                              Improvement.ImprovementSource.Quality,
                                                                              objLivingPersonaQuality.InternalId, token: token);
                                    else
                                        await ImprovementManager.RemoveImprovementsAsync(this,
                                            Improvement.ImprovementSource.Quality,
                                            objLivingPersonaQuality.InternalId, token: token).ConfigureAwait(false);

                                    XmlNode objNode = blnSync
                                        // ReSharper disable once MethodHasAsyncOverload
                                        ? objLivingPersonaQuality.GetNode(token: token)
                                        : await objLivingPersonaQuality.GetNodeAsync(token: token)
                                                                       .ConfigureAwait(false);
                                    if (objNode != null)
                                    {
                                        objLivingPersonaQuality.Bonus = objNode["bonus"];
                                        if (objLivingPersonaQuality.Bonus != null)
                                        {
                                            ImprovementManager.ForcedValue = objLivingPersonaQuality.Extra;
                                            if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverload
                                                ImprovementManager.CreateImprovements(this,
                                                    Improvement.ImprovementSource.Quality,
                                                    objLivingPersonaQuality.InternalId,
                                                    objLivingPersonaQuality
                                                        .Bonus, 1,
                                                    objLivingPersonaQuality.CurrentDisplayNameShort, token: token);
                                            else
                                                await ImprovementManager.CreateImprovementsAsync(this,
                                                    Improvement.ImprovementSource.Quality,
                                                    objLivingPersonaQuality.InternalId,
                                                    objLivingPersonaQuality
                                                        .Bonus, 1,
                                                    await objLivingPersonaQuality.GetCurrentDisplayNameShortAsync(token)
                                                        .ConfigureAwait(false), token: token).ConfigureAwait(false);
                                            if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                            {
                                                objLivingPersonaQuality.Extra = ImprovementManager.SelectedValue;
                                            }
                                        }

                                        objLivingPersonaQuality.FirstLevelBonus = objNode["firstlevelbonus"];
                                        if (objLivingPersonaQuality.FirstLevelBonus?.HasChildNodes == true)
                                        {
                                            bool blnDoFirstLevel = true;
                                            foreach (Quality objCheckQuality in Qualities)
                                            {
                                                if (objCheckQuality != objLivingPersonaQuality &&
                                                    objCheckQuality.SourceID == objLivingPersonaQuality.SourceID &&
                                                    objCheckQuality.Extra == objLivingPersonaQuality.Extra &&
                                                    objCheckQuality.SourceName ==
                                                    objLivingPersonaQuality.SourceName)
                                                {
                                                    blnDoFirstLevel = false;
                                                    break;
                                                }
                                            }

                                            if (blnDoFirstLevel)
                                            {
                                                ImprovementManager.ForcedValue = objLivingPersonaQuality.Extra;
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverload
                                                    ImprovementManager.CreateImprovements(this,
                                                        Improvement.ImprovementSource.Quality,
                                                        objLivingPersonaQuality.InternalId,
                                                        objLivingPersonaQuality
                                                            .FirstLevelBonus, 1,
                                                        objLivingPersonaQuality.CurrentDisplayNameShort, token: token);
                                                else
                                                    await ImprovementManager.CreateImprovementsAsync(this,
                                                                                Improvement.ImprovementSource.Quality,
                                                                                objLivingPersonaQuality.InternalId,
                                                                                objLivingPersonaQuality
                                                                                    .FirstLevelBonus, 1,
                                                                                await objLivingPersonaQuality
                                                                                    .GetCurrentDisplayNameShortAsync(
                                                                                        token)
                                                                                    .ConfigureAwait(false),
                                                                                token: token)
                                                                            .ConfigureAwait(false);
                                                if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                                {
                                                    objLivingPersonaQuality.Extra =
                                                        ImprovementManager.SelectedValue;
                                                }
                                            }
                                        }
                                    }
                                    else
                                    {
                                        // Failed to re-apply the improvements immediately, so let's just add it for processing when the character is opened
                                        lstInternalIdsNeedingReapplyImprovements.Add(
                                            objLivingPersonaQuality.InternalId);
                                    }

                                    objLivingPersonaQuality.NaturalWeaponsNode = objNode["naturalweapons"];
                                    if (objLivingPersonaQuality.NaturalWeaponsNode != null)
                                    {
                                        ImprovementManager.ForcedValue = objLivingPersonaQuality.Extra;
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverload
                                            ImprovementManager.CreateImprovements(this,
                                                Improvement.ImprovementSource.Quality,
                                                objLivingPersonaQuality.InternalId,
                                                objLivingPersonaQuality
                                                    .NaturalWeaponsNode, 1,
                                                objLivingPersonaQuality.CurrentDisplayNameShort, token: token);
                                        else
                                            await ImprovementManager.CreateImprovementsAsync(this,
                                                                        Improvement.ImprovementSource.Quality,
                                                                        objLivingPersonaQuality.InternalId,
                                                                        objLivingPersonaQuality
                                                                            .NaturalWeaponsNode, 1,
                                                                        await objLivingPersonaQuality
                                                                              .GetCurrentDisplayNameShortAsync(token)
                                                                              .ConfigureAwait(false), token: token)
                                                                    .ConfigureAwait(false);
                                        if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                        {
                                            objLivingPersonaQuality.Extra = ImprovementManager.SelectedValue;
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_gear");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("Label_Vehicles", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("Label_Vehicles",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_car", loadActivity))
                            {
                                // Vehicles.
                                objXmlNodeList = objXmlCharacter.SelectNodes("vehicles/vehicle");
                                foreach (XmlNode objXmlVehicle in objXmlNodeList)
                                {
                                    Vehicle objVehicle = new Vehicle(this);
                                    objVehicle.Load(objXmlVehicle);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstVehicles.Add(objVehicle);
                                    else
                                        await _lstVehicles.AddAsync(objVehicle, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_car");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_Weapons", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager
                                                                  .GetStringAsync("Tab_Weapons", token: token)
                                                                  .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_weapons", loadActivity))
                            {
                                // Weapons.
                                objXmlNodeList = objXmlCharacter.SelectNodes("weapons/weapon");
                                foreach (XmlNode objXmlWeapon in objXmlNodeList)
                                {
                                    Weapon objWeapon = new Weapon(this);
                                    objWeapon.Load(objXmlWeapon);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstWeapons.Add(objWeapon);
                                    else
                                        await _lstWeapons.AddAsync(objWeapon, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_weapons");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("String_Metamagics", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("String_Metamagics",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_metamagics", loadActivity))
                            {
                                // Metamagics/Echoes.
                                objXmlNodeList = objXmlCharacter.SelectNodes("metamagics/metamagic");
                                foreach (XmlNode objXmlMetamagic in objXmlNodeList)
                                {
                                    Metamagic objMetamagic = new Metamagic(this);
                                    objMetamagic.Load(objXmlMetamagic);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstMetamagics.Add(objMetamagic);
                                    else
                                        await _lstMetamagics.AddAsync(objMetamagic, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_mmagic");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("String_Arts", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager
                                                                  .GetStringAsync("String_Arts", token: token)
                                                                  .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_arts", loadActivity))
                            {
                                // Arts
                                objXmlNodeList = objXmlCharacter.SelectNodes("arts/art");
                                foreach (XmlNode objXmlArt in objXmlNodeList)
                                {
                                    Art objArt = new Art(this);
                                    objArt.Load(objXmlArt);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstArts.Add(objArt);
                                    else
                                        await _lstArts.AddAsync(objArt, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_arts");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("String_Enhancements", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("String_Enhancements",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_enhancements", loadActivity))
                            {
                                // Enhancements
                                objXmlNodeList = objXmlCharacter.SelectNodes("enhancements/enhancement");
                                foreach (XmlNode objXmlEnhancement in objXmlNodeList)
                                {
                                    Enhancement objEnhancement = new Enhancement(this);
                                    objEnhancement.Load(objXmlEnhancement);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstEnhancements.Add(objEnhancement);
                                    else
                                        await _lstEnhancements.AddAsync(objEnhancement, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_ench");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_Critter", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager
                                                                  .GetStringAsync("Tab_Critter", token: token)
                                                                  .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_critterpowers", loadActivity))
                            {
                                // Critter Powers.
                                objXmlNodeList = objXmlCharacter.SelectNodes("critterpowers/critterpower");
                                foreach (XmlNode objXmlPower in objXmlNodeList)
                                {
                                    CritterPower objPower = new CritterPower(this);
                                    objPower.Load(objXmlPower);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstCritterPowers.Add(objPower);
                                    else
                                        await _lstCritterPowers.AddAsync(objPower, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_cpow");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("Label_SummaryFoci", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("Label_SummaryFoci",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_foci", loadActivity))
                            {
                                // Foci.
                                objXmlNodeList = objXmlCharacter.SelectNodes("foci/focus");
                                foreach (XmlNode objXmlFocus in objXmlNodeList)
                                {
                                    Focus objFocus = new Focus(this);
                                    objFocus.Load(objXmlFocus);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstFoci.Add(objFocus);
                                    else
                                        await _lstFoci.AddAsync(objFocus, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_foci");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("Label_SummaryInitiation", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager
                                                                  .GetStringAsync("Label_SummaryInitiation",
                                                                      token: token)
                                                                  .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_init", loadActivity))
                            {
                                // Initiation Grades.
                                objXmlNodeList = objXmlCharacter.SelectNodes("initiationgrades/initiationgrade");
                                foreach (XmlNode objXmlGrade in objXmlNodeList)
                                {
                                    InitiationGrade objGrade = new InitiationGrade(this);
                                    objGrade.Load(objXmlGrade);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstInitiationGrades.Add(objGrade);
                                    else
                                        await _lstInitiationGrades.AddAsync(objGrade, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_init");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("String_Expenses", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("String_Expenses",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            // While expenses are to be saved in create mode due to starting nuyen and starting karma being logged as expense log entries,
                            // they shouldn't get loaded in create mode because they shouldn't be there.
                            if (Created)
                            {
                                using (Timekeeper.StartSyncron("load_char_elog", loadActivity))
                                {
                                    // Expense Log Entries.
                                    XmlNodeList objXmlExpenseList = objXmlCharacter.SelectNodes("expenses/expense");
                                    foreach (XmlNode objXmlExpense in objXmlExpenseList)
                                    {
                                        ExpenseLogEntry objExpenseLogEntry = new ExpenseLogEntry(this);
                                        objExpenseLogEntry.Load(objXmlExpense);
                                        await _lstExpenseLog.AddWithSortAsync(objExpenseLogEntry, token: token)
                                                            .ConfigureAwait(false);
                                    }

                                    //Timekeeper.Finish("load_char_elog");
                                }
                            }
#if DEBUG
                            else
                            {
                                // There shouldn't be any expenses for a character loaded in create mode. This code is to help narrow down issues should expenses somehow be created.
                                XmlNodeList objXmlExpenseList = objXmlCharacter.SelectNodes("expenses/expense");
                                if (objXmlExpenseList?.Count > 0)
                                {
                                    Utils.BreakIfDebug();
                                }
                            }
#endif
                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("Tip_Skill_Sustain", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("Tip_Skill_Sustain",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            // Need to load these after everything else so that we can properly link them up during loading
                            using (Timekeeper.StartSyncron("load_char_sustainedobjects", loadActivity))
                            {
                                objXmlNodeList = objXmlCharacter.SelectNodes("sustainedobjects");
                                foreach (XmlNode objXmlSustained in objXmlNodeList)
                                {
                                    SustainedObject objSustained = new SustainedObject(this);
                                    objSustained.Load(objXmlSustained);
                                    if (objSustained.InternalId !=
                                        Guid.Empty.ToString("D", GlobalSettings.InvariantCultureInfo))
                                    {
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstSustainedObjects.Add(objSustained);
                                        else
                                            await _lstSustainedObjects.AddAsync(objSustained, token)
                                                                      .ConfigureAwait(false);
                                    }
                                }
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("Tab_Improvements", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("Tab_Improvements",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_igroup", loadActivity))
                            {
                                // Improvement Groups.
                                XmlNodeList objXmlGroupList =
                                    objXmlCharacter.SelectNodes("improvementgroups/improvementgroup");
                                if (blnSync)
                                {
                                    foreach (XmlNode objXmlGroup in objXmlGroupList)
                                    {
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstImprovementGroups.Add(objXmlGroup.InnerText);
                                    }
                                }
                                else
                                {
                                    foreach (XmlNode objXmlGroup in objXmlGroupList)
                                    {
                                        await _lstImprovementGroups.AddAsync(objXmlGroup.InnerText, token)
                                                                   .ConfigureAwait(false);
                                    }
                                }

                                //Timekeeper.Finish("load_char_igroup");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_Calendar", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager
                                                                  .GetStringAsync("Tab_Calendar", token: token)
                                                                  .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_calendar", loadActivity))
                            {
                                // Calendar.
                                XmlNodeList objXmlWeekList = objXmlCharacter.SelectNodes("calendar/week");
                                foreach (XmlNode objXmlWeek in objXmlWeekList)
                                {
                                    CalendarWeek objWeek = new CalendarWeek();
                                    try
                                    {
                                        objWeek.Load(objXmlWeek);
                                        await _lstCalendar
                                              .AddWithSortAsync(objWeek, (x, y) => y.CompareTo(x), token: token)
                                              .ConfigureAwait(false);
                                    }
                                    catch
                                    {
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverload
                                            objWeek.Dispose();
                                        else
                                            await objWeek.DisposeAsync().ConfigureAwait(false);
                                        throw;
                                    }
                                }

                                //Timekeeper.Finish("load_char_calendar");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("String_LegacyFixes", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("String_LegacyFixes",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            using (Timekeeper.StartSyncron("load_char_unarmed", loadActivity))
                            {
                                // Look for the unarmed attack
                                bool blnFoundUnarmed = false;
                                foreach (Weapon objWeapon in _lstWeapons)
                                {
                                    if (objWeapon.Name == "Unarmed Attack")
                                    {
                                        blnFoundUnarmed = true;
                                        break;
                                    }
                                }

                                if (!blnFoundUnarmed)
                                {
                                    // Add the Unarmed Attack Weapon to the character.
                                    XmlDocument objXmlWeaponDoc = blnSync
                                        // ReSharper disable once MethodHasAsyncOverload
                                        ? LoadData("weapons.xml", token: token)
                                        : await LoadDataAsync("weapons.xml", token: token).ConfigureAwait(false);
                                    XmlNode objXmlWeapon =
                                        objXmlWeaponDoc.SelectSingleNode(
                                            "/chummer/weapons/weapon[name = \"Unarmed Attack\"]");
                                    if (objXmlWeapon != null)
                                    {
                                        Weapon objWeapon = new Weapon(this);
                                        objWeapon.Create(objXmlWeapon, _lstWeapons);
                                        objWeapon.IncludedInWeapon = true; // Unarmed attack can never be removed
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstWeapons.Add(objWeapon);
                                        else
                                            await _lstWeapons.AddAsync(objWeapon, token).ConfigureAwait(false);
                                    }
                                }

                                //Timekeeper.Finish("load_char_unarmed");
                            }

                            using (Timekeeper.StartSyncron("load_char_dwarffix", loadActivity))
                            {
                                // converting from old dwarven resistance to new dwarven resistance
                                if (Metatype.Equals("dwarf", StringComparison.OrdinalIgnoreCase))
                                {
                                    Quality objOldQuality = blnSync
                                        ? Qualities.FirstOrDefault(x =>
                                                                       x.Name.Equals("Resistance to Pathogens and Toxins",
                                                                           StringComparison.Ordinal))
                                        : await Qualities.FirstOrDefaultAsync(x =>
                                                                       x.Name.Equals("Resistance to Pathogens and Toxins",
                                                                           StringComparison.Ordinal), token).ConfigureAwait(false);
                                    if (objOldQuality != null)
                                    {
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverload
                                            objOldQuality.DeleteQuality(token: token);
                                        else
                                            await objOldQuality.DeleteQualityAsync(token: token).ConfigureAwait(false);

                                        if (Qualities.All(x =>
                                                              !x.Name.Equals("Resistance to Pathogens/Toxins",
                                                                             StringComparison.Ordinal))
                                            && Qualities.All(x =>
                                                                 !x.Name.Equals(
                                                                     "Dwarf Resistance", StringComparison.Ordinal)))
                                        {
                                            XmlNode objXmlDwarfQuality =
                                                xmlRootQualitiesNode.SelectSingleNode(
                                                    "quality[name = \"Resistance to Pathogens/Toxins\"]") ??
                                                xmlRootQualitiesNode.SelectSingleNode(
                                                    "quality[name = \"Dwarf Resistance\"]");

                                            List<Weapon> lstWeapons = new List<Weapon>(1);
                                            Quality objQuality = new Quality(this);

                                            try
                                            {
                                                objQuality.Create(objXmlDwarfQuality, QualitySource.Metatype,
                                                                  lstWeapons);

                                                if (blnSync)
                                                {
                                                    foreach (Weapon objWeapon in lstWeapons)
                                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                        Weapons.Add(objWeapon);
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    Qualities.Add(objQuality);
                                                }
                                                else
                                                {
                                                    foreach (Weapon objWeapon in lstWeapons)
                                                        await Weapons.AddAsync(objWeapon, token).ConfigureAwait(false);
                                                    await Qualities.AddAsync(objQuality, token).ConfigureAwait(false);
                                                }
                                            }
                                            catch
                                            {
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverload
                                                    objQuality.Dispose();
                                                else
                                                    await objQuality.DisposeAsync().ConfigureAwait(false);
                                                throw;
                                            }
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_dwarffix");
                            }

                            using (Timekeeper.StartSyncron("load_char_cyberadeptfix", loadActivity))
                            {
                                //Sweep through grades if we have any cyberadept improvements that need reassignment
                                if (lstCyberadeptSweepGrades.Count > 0)
                                {
                                    foreach (Improvement objCyberadeptImprovement in lstCyberadeptSweepGrades)
                                    {
                                        InitiationGrade objBestGradeMatch = null;
                                        foreach (InitiationGrade objInitiationGrade in InitiationGrades)
                                        {
                                            if (!objInitiationGrade.Technomancer
                                                || objInitiationGrade.Grade.DivAwayFromZero(2) >
                                                objCyberadeptImprovement.Value
                                                || Metamagics.Any(x => x.Grade == objInitiationGrade.Grade)
                                                || lstCyberadeptSweepGrades.All(x =>
                                                    x.ImproveSource != Improvement.ImprovementSource
                                                        .CyberadeptDaemon
                                                    || x.SourceName != objInitiationGrade.InternalId))
                                                continue;
                                            if (objBestGradeMatch == null ||
                                                objBestGradeMatch.Grade > objInitiationGrade.Grade)
                                                objBestGradeMatch = objInitiationGrade;
                                        }

                                        if (objBestGradeMatch != null)
                                        {
                                            objCyberadeptImprovement.ImproveSource =
                                                Improvement.ImprovementSource.CyberadeptDaemon;
                                            objCyberadeptImprovement.SourceName = objBestGradeMatch.InternalId;
                                        }
                                        else if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstImprovements.Remove(objCyberadeptImprovement);
                                        else
                                            await _lstImprovements.RemoveAsync(objCyberadeptImprovement, token)
                                                                  .ConfigureAwait(false);
                                    }
                                }

                                //Timekeeper.Finish("load_char_cyberadeptfix");
                            }

                            using (Timekeeper.StartSyncron("load_char_mentorspiritfix", loadActivity))
                            {
                                Quality objMentorQuality = Qualities.FirstOrDefault(q => q.Name == "Mentor Spirit");
                                // This character doesn't have any improvements tied to a cached Mentor Spirit value, so re-apply the improvement that adds the Mentor spirit
                                if (objMentorQuality != null && !Improvements.Any(imp =>
                                        imp.ImproveType == Improvement.ImprovementType.MentorSpirit &&
                                        !string.IsNullOrEmpty(imp.ImprovedName)))
                                {
                                    // Selecting bonuses for a mentor spirit mid-load is confusing, so just show the error and let the player manually re-apply
                                    lstInternalIdsNeedingReapplyImprovements.Add(objMentorQuality.InternalId);
                                }

                                //Timekeeper.Finish("load_char_mentorspiritfix");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(
                                        LanguageManager.GetString("Tab_Options_Plugins", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                                            await LanguageManager.GetStringAsync("Tab_Options_Plugins",
                                                                    token: token)
                                                                .ConfigureAwait(false), token: token)
                                                        .ConfigureAwait(false);
                            }

                            //Plugins
                            using (Timekeeper.StartSyncron("load_char_plugins", loadActivity))
                            {
                                foreach (IPlugin plugin in (blnSync
                                             ? Program.PluginLoader.MyActivePlugins
                                             : await Program.PluginLoader.GetMyActivePluginsAsync(token)
                                                            .ConfigureAwait(false)))
                                {
                                    foreach (XmlNode objXmlPlugin in objXmlCharacter.SelectNodes("plugins/" +
                                                 plugin.GetPluginAssembly().GetName().Name))
                                    {
                                        plugin.LoadFileElement(this, objXmlPlugin.InnerText);
                                    }
                                }

                                //Timekeeper.Finish("load_plugins");
                            }

                            ConcurrentBag<string> lstOldIds = Interlocked.Exchange(ref _lstInternalIdsNeedingReapplyImprovements,
                                                 lstInternalIdsNeedingReapplyImprovements);
                            if (lstOldIds != null)
                            {
                                foreach (string strOldId in lstOldIds)
                                    lstInternalIdsNeedingReapplyImprovements.Add(strOldId);
                            }
                        }
                        finally
                        {
                            IsLoading = false;
                        }

                        if (frmLoadingForm != null)
                        {
                            if (blnSync)
                                // ReSharper disable once MethodHasAsyncOverload
                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                frmLoadingForm.PerformStep(
                                    LanguageManager.GetString("String_GeneratedImprovements", token: token));
                            else
                                await frmLoadingForm.PerformStepAsync(
                                    await LanguageManager.GetStringAsync("String_GeneratedImprovements", token: token)
                                                         .ConfigureAwait(false), token: token).ConfigureAwait(false);
                        }

                        // Refresh certain improvements
                        using (Timekeeper.StartSyncron("load_char_improvementrefreshers1", loadActivity))
                        {
                            // Process all events related to improvements
                            using (new FetchSafelyFromPool<
                                       Dictionary<INotifyMultiplePropertyChanged, HashSet<string>>>(
                                       Utils.DictionaryForMultiplePropertyChangedPool,
                                       out Dictionary<INotifyMultiplePropertyChanged, HashSet<string>>
                                           dicChangedProperties))
                            {
                                try
                                {
                                    foreach (Improvement objImprovement in Improvements)
                                    {
                                        if (!objImprovement.Enabled)
                                            continue;
                                        foreach ((INotifyMultiplePropertyChanged objItemToUpdate,
                                                  string strPropertyToUpdate) in objImprovement
                                                     .GetRelevantPropertyChangers())
                                        {
                                            if (!dicChangedProperties.TryGetValue(
                                                    objItemToUpdate, out HashSet<string> setChangedProperties))
                                            {
                                                setChangedProperties = Utils.StringHashSetPool.Get();
                                                dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                            }

                                            setChangedProperties.Add(strPropertyToUpdate);
                                        }
                                    }

                                    foreach (KeyValuePair<INotifyMultiplePropertyChanged, HashSet<string>>
                                                 kvpToProcess in
                                             dicChangedProperties)
                                    {
                                        kvpToProcess.Key.OnMultiplePropertyChanged(kvpToProcess.Value.ToList());
                                    }
                                }
                                finally
                                {
                                    List<HashSet<string>> lstToReturn = dicChangedProperties.Values.ToList();
                                    for (int i = lstToReturn.Count - 1; i >= 0; --i)
                                    {
                                        HashSet<string> setLoop = lstToReturn[i];
                                        Utils.StringHashSetPool.Return(ref setLoop);
                                    }
                                }
                            }

                            if (blnSync)
                            {
                                // ReSharper disable MethodHasAsyncOverload
                                // Refresh Black Market Discounts
                                RefreshBlackMarketDiscounts(token);
                                // Refresh Dealer Connection discounts
                                RefreshDealerConnectionDiscounts(token);
                                // Refresh permanent attribute changes due to essence loss
                                RefreshEssenceLossImprovements(token);
                                // Refresh dicepool modifiers due to filled condition monitor boxes
                                RefreshWoundPenalties(token);
                                // Refresh dicepool modifiers due to sustained spells
                                RefreshSustainingPenalties(token);
                                // Refresh encumbrance penalties
                                RefreshEncumbrance(token);
                                RefreshArmorEncumbrance(token);
                                // ReSharper restore MethodHasAsyncOverload
                            }
                            else
                            {
                                // Refresh Black Market Discounts
                                await RefreshBlackMarketDiscountsAsync(token).ConfigureAwait(false);
                                // Refresh Dealer Connection discounts
                                await RefreshDealerConnectionDiscountsAsync(token).ConfigureAwait(false);
                                // Refresh permanent attribute changes due to essence loss
                                await RefreshEssenceLossImprovementsAsync(token).ConfigureAwait(false);
                                // Refresh dicepool modifiers due to filled condition monitor boxes
                                await RefreshWoundPenaltiesAsync(token).ConfigureAwait(false);
                                // Refresh dicepool modifiers due to sustained spells
                                await RefreshSustainingPenaltiesAsync(token).ConfigureAwait(false);
                                // Refresh encumbrance penalties
                                await RefreshEncumbranceAsync(token).ConfigureAwait(false);
                                await RefreshArmorEncumbranceAsync(token).ConfigureAwait(false);
                            }

                            // Curb Mystic Adept power points if the values that were loaded in would be illegal
                            if (MysticAdeptPowerPoints > 0)
                            {
                                int intMAGTotalValue = blnSync
                                    ? MAG.TotalValue
                                    : await (await GetAttributeAsync("MAG", token: token).ConfigureAwait(false))
                                            .GetTotalValueAsync(token).ConfigureAwait(false);
                                if (MysticAdeptPowerPoints > intMAGTotalValue)
                                    MysticAdeptPowerPoints = intMAGTotalValue;
                            }

                            if (!InitiationEnabled || !AddInitiationsAllowed)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ClearInitiations(token);
                                else
                                    await ClearInitiationsAsync(token).ConfigureAwait(false);
                            }

                            while (_setPostLoadMethods.TryTake(out Func<CancellationToken, bool> funcToCall))
                            {
                                if (!funcToCall.Invoke(token))
                                    return false;
                            }

                            if (blnSync)
                            {
                                while (_setPostLoadAsyncMethods.TryTake(out Func<CancellationToken, Task<bool>> funcToCall))
                                {
                                    if (!Utils.SafelyRunSynchronously(() => funcToCall.Invoke(token), token))
                                        return false;
                                }
                            }
                            else
                            {
                                while (_setPostLoadAsyncMethods.TryTake(out Func<CancellationToken, Task<bool>> funcToCall))
                                {
                                    if (!await funcToCall.Invoke(token).ConfigureAwait(false))
                                        return false;
                                }
                            }
                            //Timekeeper.Finish("load_char_improvementrefreshers");
                        }

                        //// If the character had old Qualities that were converted, immediately save the file so they are in the new format.
                        //if (blnHasOldQualities)
                        //{
                        //    Timekeeper.Start("load_char_resav");  //Lets not silently save file on load?
                        //    Save();
                        //    Timekeeper.Finish("load_char_resav");
                        //}
                        loadActivity.SetSuccess(true);
                    }
                    catch (Exception e)
                    {
                        loadActivity.SetSuccess(false);
                        Log.Error(e);
                        throw;
                    }
                }

                return true;
            }
            finally
            {
                if (blnSync)
                    // ReSharper disable once MethodHasAsyncOverload
                    objLocker.Dispose();
                else
                    await objLockerAsync.DisposeAsync().ConfigureAwait(false);
            }
        }

        public Task<XmlDocument> GenerateExportXml(CultureInfo objCultureInfo, string strLanguage)
        {
            return CommonFunctions.GenerateCharactersExportXml(objCultureInfo, strLanguage, this);
        }

        public Task<XmlDocument> GenerateExportXml(CultureInfo objCultureInfo, string strLanguage, CancellationToken objToken)
        {
            return CommonFunctions.GenerateCharactersExportXml(objCultureInfo, strLanguage, objToken, this);
        }

        /// <summary>
        /// Print this character information to a XmlTextWriter. This creates only the character object itself, not any of the opening or closing XmlDocument items.
        /// This can be used to write multiple characters to a single XmlDocument.
        /// </summary>
        /// <param name="objWriter">XmlTextWriter to write to.</param>
        /// <param name="objCulture">Culture in which to print.</param>
        /// <param name="strLanguageToPrint">Language in which to print.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public Task PrintToXmlTextWriter(XmlWriter objWriter, CultureInfo objCulture = null,
                                         string strLanguageToPrint = "", CancellationToken token = default)
        {
            return objWriter != null
                ? PrintToXmlTextWriterCore(objWriter, objCulture, strLanguageToPrint, token)
                : Task.FromException(new ArgumentNullException(nameof(objWriter)));
        }

        /// <summary>
        /// Print this character information to a XmlTextWriter. This creates only the character object itself, not any of the opening or closing XmlDocument items.
        /// This can be used to write multiple characters to a single XmlDocument.
        /// </summary>
        /// <param name="objWriter">XmlTextWriter to write to.</param>
        /// <param name="objCulture">Culture in which to print.</param>
        /// <param name="strLanguageToPrint">Language in which to print.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        private async Task PrintToXmlTextWriterCore(XmlWriter objWriter, CultureInfo objCulture = null,
                                                    string strLanguageToPrint = "", CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (objCulture == null)
                objCulture = GlobalSettings.CultureInfo;
            if (string.IsNullOrEmpty(strLanguageToPrint))
                strLanguageToPrint = GlobalSettings.Language;
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                // <character>
                XmlElementWriteHelper objCharacterElement
                    = await objWriter.StartElementAsync("character", token: token).ConfigureAwait(false);
                try
                {
                    // <settings />
                    await objWriter
                          .WriteElementStringAsync("settings", await GetSettingsKeyAsync(token).ConfigureAwait(false),
                                                   token: token).ConfigureAwait(false);
                    // <buildmethod />
                    await objWriter
                          .WriteElementStringAsync("buildmethod", Settings.BuildMethod.ToString(), token: token)
                          .ConfigureAwait(false);
                    // <imageformat />
                    await objWriter.WriteElementStringAsync("imageformat",
                                                            "jpeg", token: token)
                                   .ConfigureAwait(
                                       false); // Here for legacy/compatibility purposes, we always export as JPEG now
                    // <metatype />
                    await objWriter
                          .WriteElementStringAsync(
                              "metatype", await DisplayMetatypeAsync(strLanguageToPrint, token).ConfigureAwait(false),
                              token: token).ConfigureAwait(false);
                    // <metatype_english />
                    await objWriter.WriteElementStringAsync("metatype_english", Metatype, token: token)
                                   .ConfigureAwait(false);
                    // <metatype_guid />
                    await objWriter.WriteElementStringAsync("metatype_guid",
                                                            MetatypeGuid.ToString(
                                                                "D", GlobalSettings.InvariantCultureInfo), token: token)
                                   .ConfigureAwait(false);
                    // <metavariant />
                    await objWriter.WriteElementStringAsync("metavariant",
                                                            await DisplayMetavariantAsync(strLanguageToPrint, token)
                                                                .ConfigureAwait(false), token: token)
                                   .ConfigureAwait(false);
                    // <metavariant_english />
                    await objWriter.WriteElementStringAsync("metavariant_english", Metavariant, token: token)
                                   .ConfigureAwait(false);
                    // <metavariant_guid />
                    await objWriter.WriteElementStringAsync("metavariant_guid",
                                                            MetavariantGuid.ToString(
                                                                "D", GlobalSettings.InvariantCultureInfo), token: token)
                                   .ConfigureAwait(false);
                    // <movement />
                    await objWriter
                          .WriteElementStringAsync(
                              "movement",
                              await FullMovementAsync(objCulture, strLanguageToPrint, token).ConfigureAwait(false),
                              token: token).ConfigureAwait(false);
                    // <walk />
                    await objWriter
                          .WriteElementStringAsync(
                              "walk",
                              await FullMovementAsync(objCulture, strLanguageToPrint, token).ConfigureAwait(false),
                              token: token).ConfigureAwait(false);
                    // <run />
                    await objWriter
                          .WriteElementStringAsync(
                              "run",
                              await FullMovementAsync(objCulture, strLanguageToPrint, token).ConfigureAwait(false),
                              token: token).ConfigureAwait(false);
                    // <sprint />
                    await objWriter
                          .WriteElementStringAsync(
                              "sprint",
                              await FullMovementAsync(objCulture, strLanguageToPrint, token).ConfigureAwait(false),
                              token: token).ConfigureAwait(false);
                    // <movementwalk />
                    await objWriter.WriteElementStringAsync("movementwalk",
                                                            await GetMovementAsync(
                                                                    objCulture, strLanguageToPrint, token)
                                                                .ConfigureAwait(false), token: token)
                                   .ConfigureAwait(false);
                    // <movementswim />
                    await objWriter
                          .WriteElementStringAsync("movementswim",
                                                   await GetSwimAsync(objCulture, strLanguageToPrint, token)
                                                       .ConfigureAwait(false), token: token).ConfigureAwait(false);
                    // <movementfly />
                    await objWriter
                          .WriteElementStringAsync("movementfly",
                                                   await GetFlyAsync(objCulture, strLanguageToPrint, token)
                                                       .ConfigureAwait(false), token: token).ConfigureAwait(false);

                    // <prioritymetatype />
                    await objWriter.WriteElementStringAsync("prioritymetatype", MetatypePriority, token: token)
                                   .ConfigureAwait(false);
                    // <priorityattributes />
                    await objWriter.WriteElementStringAsync("priorityattributes", AttributesPriority, token: token)
                                   .ConfigureAwait(false);
                    // <priorityspecial />
                    await objWriter.WriteElementStringAsync("priorityspecial", SpecialPriority, token: token)
                                   .ConfigureAwait(false);
                    // <priorityskills />
                    await objWriter.WriteElementStringAsync("priorityskills", SkillsPriority, token: token)
                                   .ConfigureAwait(false);
                    // <priorityresources />
                    await objWriter.WriteElementStringAsync("priorityresources", ResourcesPriority, token: token)
                                   .ConfigureAwait(false);

                    // <priorityskills>
                    XmlElementWriteHelper objPrioritySkillsElement
                        = await objWriter.StartElementAsync("priorityskills", token: token).ConfigureAwait(false);
                    try
                    {
                        foreach (string strSkill in PriorityBonusSkillList)
                        {
                            await objWriter.WriteElementStringAsync("priorityskill", strSkill, token: token)
                                           .ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        // </priorityskills>
                        await objPrioritySkillsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <handedness />
                    if (await GetAmbidextrousAsync(token).ConfigureAwait(false))
                    {
                        await objWriter.WriteElementStringAsync("primaryarm",
                                                                await LanguageManager.GetStringAsync(
                                                                    "String_Ambidextrous", strLanguageToPrint,
                                                                    token: token).ConfigureAwait(false), token: token)
                                       .ConfigureAwait(false);
                    }
                    else if (PrimaryArm == "Left")
                    {
                        await objWriter.WriteElementStringAsync("primaryarm",
                                                                await LanguageManager.GetStringAsync(
                                                                    "String_Improvement_SideLeft", strLanguageToPrint,
                                                                    token: token).ConfigureAwait(false), token: token)
                                       .ConfigureAwait(false);
                    }
                    else
                    {
                        await objWriter.WriteElementStringAsync("primaryarm",
                                                                await LanguageManager.GetStringAsync(
                                                                        "String_Improvement_SideRight",
                                                                        strLanguageToPrint, token: token)
                                                                    .ConfigureAwait(false), token: token)
                                       .ConfigureAwait(false);
                    }

                    // If the character does not have a name, call them Unnamed Character. This prevents a transformed document from
                    // having a self-terminated title tag which causes browser to not rendering anything.
                    // <name />
                    await objWriter.WriteElementStringAsync("name",
                                                            !string.IsNullOrEmpty(Name)
                                                                ? Name
                                                                : await LanguageManager.GetStringAsync(
                                                                    "String_UnnamedCharacter", strLanguageToPrint,
                                                                    token: token).ConfigureAwait(false), token: token)
                                   .ConfigureAwait(false);

                    await PrintMugshots(objWriter, token).ConfigureAwait(false);

                    // <sex />
                    await objWriter.WriteElementStringAsync("gender",
                                                            await TranslateExtraAsync(
                                                                    await ReverseTranslateExtraAsync(
                                                                        Gender, GlobalSettings.Language, "contacts.xml",
                                                                        token: token).ConfigureAwait(false),
                                                                    strLanguageToPrint, "contacts.xml", token: token)
                                                                .ConfigureAwait(false), token: token)
                                   .ConfigureAwait(false);
                    // <age />
                    await objWriter.WriteElementStringAsync("age",
                                                            await TranslateExtraAsync(
                                                                await ReverseTranslateExtraAsync(
                                                                    Age, GlobalSettings.Language, "contacts.xml",
                                                                    token: token).ConfigureAwait(false),
                                                                strLanguageToPrint,
                                                                "contacts.xml", token: token).ConfigureAwait(false),
                                                            token: token).ConfigureAwait(false);
                    // <eyes />
                    await objWriter.WriteElementStringAsync("eyes",
                                                            await TranslateExtraAsync(
                                                                await ReverseTranslateExtraAsync(Eyes, token: token)
                                                                    .ConfigureAwait(false),
                                                                strLanguageToPrint, token: token).ConfigureAwait(false),
                                                            token: token).ConfigureAwait(false);
                    // <height />
                    await objWriter.WriteElementStringAsync("height",
                                                            await TranslateExtraAsync(
                                                                await ReverseTranslateExtraAsync(Height, token: token)
                                                                    .ConfigureAwait(false),
                                                                strLanguageToPrint, token: token).ConfigureAwait(false),
                                                            token: token).ConfigureAwait(false);
                    // <weight />
                    await objWriter.WriteElementStringAsync("weight",
                                                            await TranslateExtraAsync(
                                                                await ReverseTranslateExtraAsync(Weight, token: token)
                                                                    .ConfigureAwait(false),
                                                                strLanguageToPrint, token: token).ConfigureAwait(false),
                                                            token: token).ConfigureAwait(false);
                    // <skin />
                    await objWriter.WriteElementStringAsync("skin",
                                                            await TranslateExtraAsync(
                                                                await ReverseTranslateExtraAsync(Skin, token: token)
                                                                    .ConfigureAwait(false),
                                                                strLanguageToPrint, token: token).ConfigureAwait(false),
                                                            token: token).ConfigureAwait(false);
                    // <hair />
                    await objWriter.WriteElementStringAsync("hair",
                                                            await TranslateExtraAsync(
                                                                await ReverseTranslateExtraAsync(Hair, token: token)
                                                                    .ConfigureAwait(false),
                                                                strLanguageToPrint, token: token).ConfigureAwait(false),
                                                            token: token).ConfigureAwait(false);
                    // <description />
                    await objWriter
                          .WriteElementStringAsync("description",
                                                   await Description.RtfToHtmlAsync(token).ConfigureAwait(false),
                                                   token: token).ConfigureAwait(false);
                    // <background />
                    await objWriter
                          .WriteElementStringAsync("background",
                                                   await Background.RtfToHtmlAsync(token).ConfigureAwait(false),
                                                   token: token).ConfigureAwait(false);
                    // <concept />
                    await objWriter
                          .WriteElementStringAsync("concept", await Concept.RtfToHtmlAsync(token).ConfigureAwait(false),
                                                   token: token).ConfigureAwait(false);
                    // <notes />
                    await objWriter
                          .WriteElementStringAsync("notes", await Notes.RtfToHtmlAsync(token).ConfigureAwait(false),
                                                   token: token).ConfigureAwait(false);
                    // <alias />
                    await objWriter.WriteElementStringAsync("alias", Alias, token: token).ConfigureAwait(false);
                    // <playername />
                    await objWriter.WriteElementStringAsync("playername", PlayerName, token: token)
                                   .ConfigureAwait(false);
                    // <gamenotes />
                    await objWriter
                          .WriteElementStringAsync("gamenotes",
                                                   await GameNotes.RtfToHtmlAsync(token).ConfigureAwait(false),
                                                   token: token).ConfigureAwait(false);

                    // <limitphysical />
                    await objWriter
                          .WriteElementStringAsync("limitphysical", LimitPhysical.ToString(objCulture), token: token)
                          .ConfigureAwait(false);
                    // <limitmental />
                    await objWriter
                          .WriteElementStringAsync("limitmental", LimitMental.ToString(objCulture), token: token)
                          .ConfigureAwait(false);
                    // <limitsocial />
                    await objWriter
                          .WriteElementStringAsync("limitsocial", LimitSocial.ToString(objCulture), token: token)
                          .ConfigureAwait(false);
                    // <limitastral />
                    await objWriter
                          .WriteElementStringAsync("limitastral", LimitAstral.ToString(objCulture), token: token)
                          .ConfigureAwait(false);
                    // <contactpoints />
                    await objWriter
                          .WriteElementStringAsync("contactpoints",
                                                   (await GetContactPointsAsync(token).ConfigureAwait(false)).ToString(
                                                       objCulture), token: token)
                          .ConfigureAwait(false);
                    // <contactpointsused />
                    await objWriter.WriteElementStringAsync("contactpointsused",
                                                            (await GetContactPointsUsedAsync(token)
                                                                .ConfigureAwait(false)).ToString(objCulture),
                                                            token: token)
                                   .ConfigureAwait(false);
                    // <cfplimit />
                    await objWriter.WriteElementStringAsync("cfplimit", CFPLimit.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    // <totalaiprogramlimit />
                    await objWriter.WriteElementStringAsync("ainormalprogramlimit",
                                                            AINormalProgramLimit.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    // <aiadvancedprogramlimit />
                    await objWriter.WriteElementStringAsync("aiadvancedprogramlimit",
                                                            AIAdvancedProgramLimit.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    // <spelllimit />
                    await objWriter.WriteElementStringAsync("spelllimit", (await GetFreeSpellsAsync(token).ConfigureAwait(false)).ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    // <karma />
                    await objWriter
                          .WriteElementStringAsync(
                              "karma", (await GetKarmaAsync(token).ConfigureAwait(false)).ToString(objCulture),
                              token: token).ConfigureAwait(false);
                    // <totalkarma />
                    await objWriter
                          .WriteElementStringAsync("totalkarma", CareerKarma.ToString(objCulture), token: token)
                          .ConfigureAwait(false);
                    // <special />
                    await objWriter.WriteElementStringAsync("special", Special.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    // <totalspecial />
                    await objWriter
                          .WriteElementStringAsync("totalspecial", TotalSpecial.ToString(objCulture), token: token)
                          .ConfigureAwait(false);
                    // <attributes />
                    await objWriter.WriteElementStringAsync("attributes", Attributes.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    // <totalattributes />
                    await objWriter
                          .WriteElementStringAsync("totalattributes", TotalAttributes.ToString(objCulture),
                                                   token: token).ConfigureAwait(false);
                    // <edgeused />
                    await objWriter.WriteElementStringAsync("edgeused", EdgeUsed.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    // <edgeremaining />
                    await objWriter
                          .WriteElementStringAsync("edgeremaining", EdgeRemaining.ToString(objCulture), token: token)
                          .ConfigureAwait(false);
                    // <streetcred />
                    await objWriter.WriteElementStringAsync("streetcred", StreetCred.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    // <calculatedstreetcred />
                    await objWriter.WriteElementStringAsync("calculatedstreetcred",
                                                            CalculatedStreetCred.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    // <totalstreetcred />
                    await objWriter
                          .WriteElementStringAsync("totalstreetcred", TotalStreetCred.ToString(objCulture),
                                                   token: token).ConfigureAwait(false);
                    // <burntstreetcred />
                    await objWriter
                          .WriteElementStringAsync("burntstreetcred", BurntStreetCred.ToString(objCulture),
                                                   token: token).ConfigureAwait(false);
                    // <notoriety />
                    await objWriter.WriteElementStringAsync("notoriety", Notoriety.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    // <calculatednotoriety />
                    await objWriter.WriteElementStringAsync("calculatednotoriety",
                                                            CalculatedNotoriety.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    // <totalnotoriety />
                    await objWriter
                          .WriteElementStringAsync("totalnotoriety", TotalNotoriety.ToString(objCulture), token: token)
                          .ConfigureAwait(false);
                    // <publicawareness />
                    await objWriter
                          .WriteElementStringAsync("publicawareness", PublicAwareness.ToString(objCulture),
                                                   token: token).ConfigureAwait(false);
                    // <calculatedpublicawareness />
                    await objWriter.WriteElementStringAsync("calculatedpublicawareness",
                                                            CalculatedPublicAwareness.ToString(objCulture),
                                                            token: token).ConfigureAwait(false);
                    // <totalpublicawareness />
                    await objWriter.WriteElementStringAsync("totalpublicawareness",
                                                            TotalPublicAwareness.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    // <astralreputation />
                    await objWriter
                          .WriteElementStringAsync("astralreputation", AstralReputation.ToString(objCulture),
                                                   token: token).ConfigureAwait(false);
                    // <totalastralreputation />
                    await objWriter.WriteElementStringAsync("totalastralreputation",
                                                            TotalAstralReputation.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    // <wildreputation />
                    await objWriter
                          .WriteElementStringAsync("wildreputation", WildReputation.ToString(objCulture), token: token)
                          .ConfigureAwait(false);
                    // <totalwildreputation />
                    await objWriter.WriteElementStringAsync("totalwildreputation",
                                                            TotalWildReputation.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    // <created />
                    await objWriter.WriteElementStringAsync(
                                       "created", Created.ToString(GlobalSettings.InvariantCultureInfo), token: token)
                                   .ConfigureAwait(false);
                    // <nuyen />
                    await objWriter
                          .WriteElementStringAsync("nuyen", Nuyen.ToString(Settings.NuyenFormat, objCulture),
                                                   token: token).ConfigureAwait(false);
                    // <adept />
                    await objWriter.WriteElementStringAsync(
                                       "adept", AdeptEnabled.ToString(GlobalSettings.InvariantCultureInfo),
                                       token: token)
                                   .ConfigureAwait(false);
                    // <magician />
                    await objWriter.WriteElementStringAsync(
                                       "magician", MagicianEnabled.ToString(GlobalSettings.InvariantCultureInfo),
                                       token: token)
                                   .ConfigureAwait(false);
                    // <technomancer />
                    await objWriter.WriteElementStringAsync("technomancer",
                                                            TechnomancerEnabled.ToString(
                                                                GlobalSettings.InvariantCultureInfo), token: token)
                                   .ConfigureAwait(false);
                    // <ai />
                    await objWriter.WriteElementStringAsync("ai",
                                                            AdvancedProgramsEnabled.ToString(
                                                                GlobalSettings.InvariantCultureInfo), token: token)
                                   .ConfigureAwait(false);
                    // <cyberwaredisabled />
                    await objWriter.WriteElementStringAsync("cyberwaredisabled",
                                                            CyberwareDisabled.ToString(
                                                                GlobalSettings.InvariantCultureInfo), token: token)
                                   .ConfigureAwait(false);
                    // <critter />
                    await objWriter.WriteElementStringAsync(
                                       "critter", CritterEnabled.ToString(GlobalSettings.InvariantCultureInfo),
                                       token: token)
                                   .ConfigureAwait(false);

                    await objWriter.WriteElementStringAsync(
                        "totaless",
                        (await EssenceAsync(token: token).ConfigureAwait(false)).ToString(
                            Settings.EssenceFormat, objCulture), token: token).ConfigureAwait(false);

                    // <tradition />
                    if (MagicTradition.Type != TraditionType.None)
                    {
                        await MagicTradition.Print(objWriter, objCulture, strLanguageToPrint, token)
                                            .ConfigureAwait(false);
                    }

                    // <attributes>
                    XmlElementWriteHelper objAttributesElement
                        = await objWriter.StartElementAsync("attributes", token: token).ConfigureAwait(false);
                    try
                    {
                        await AttributeSection.Print(objWriter, objCulture, strLanguageToPrint, token)
                                              .ConfigureAwait(false);
                    }
                    finally
                    {
                        // </attributes>
                        await objAttributesElement.DisposeAsync().ConfigureAwait(false);
                    }

                    int intArmor = await GetTotalArmorRatingAsync(token).ConfigureAwait(false);
                    int intFireArmor = await GetTotalFireArmorRatingAsync(token).ConfigureAwait(false);
                    int intColdArmor = await GetTotalColdArmorRatingAsync(token).ConfigureAwait(false);
                    int intElectricityArmor = await GetTotalElectricityArmorRatingAsync(token).ConfigureAwait(false);
                    int intAcidArmor = await GetTotalAcidArmorRatingAsync(token).ConfigureAwait(false);
                    int intFallingArmor = await GetTotalFallingArmorRatingAsync(token).ConfigureAwait(false);
                    // <dodge />
                    await objWriter.WriteElementStringAsync("dodge", Dodge.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    // <armor />
                    await objWriter.WriteElementStringAsync("armor", intArmor.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    // <firearmor />
                    await objWriter
                          .WriteElementStringAsync("firearmor", intFireArmor.ToString(objCulture), token: token)
                          .ConfigureAwait(false);
                    // <coldarmor />
                    await objWriter
                          .WriteElementStringAsync("coldarmor", intColdArmor.ToString(objCulture), token: token)
                          .ConfigureAwait(false);
                    // <electricityarmor />
                    await objWriter
                          .WriteElementStringAsync("electricityarmor", intElectricityArmor.ToString(objCulture),
                                                   token: token).ConfigureAwait(false);
                    // <acidarmor />
                    await objWriter
                          .WriteElementStringAsync("acidarmor", intAcidArmor.ToString(objCulture), token: token)
                          .ConfigureAwait(false);
                    // <fallingarmor />
                    await objWriter
                          .WriteElementStringAsync("fallingarmor", intFallingArmor.ToString(objCulture), token: token)
                          .ConfigureAwait(false);

                    int intDamageResistanceDice = (await ImprovementManager
                                                         .ValueOfAsync(
                                                             this, Improvement.ImprovementType.DamageResistance,
                                                             token: token).ConfigureAwait(false))
                        .StandardRound();
                    int intBodTotalValue = await (await GetAttributeAsync("BOD", token: token).ConfigureAwait(false))
                                                 .GetTotalValueAsync(token).ConfigureAwait(false);
                    // <armordicestun />
                    await objWriter.WriteElementStringAsync("armordicestun",
                                                            (intBodTotalValue + intDamageResistanceDice
                                                                              + intArmor).ToString(objCulture),
                                                            token: token).ConfigureAwait(false);
                    // <firearmordicestun />
                    await objWriter.WriteElementStringAsync("firearmordicestun",
                                                            (intBodTotalValue + intDamageResistanceDice
                                                                              + intFireArmor)
                                                            .ToString(objCulture), token: token).ConfigureAwait(false);
                    // <coldarmordicestun />
                    await objWriter.WriteElementStringAsync("coldarmordicestun",
                                                            (intBodTotalValue + intDamageResistanceDice
                                                                              + intColdArmor)
                                                            .ToString(objCulture), token: token).ConfigureAwait(false);
                    // <electricityarmordicestun />
                    await objWriter.WriteElementStringAsync("electricityarmordicestun",
                                                            (intBodTotalValue + intDamageResistanceDice
                                                                              + intElectricityArmor)
                                                            .ToString(objCulture), token: token).ConfigureAwait(false);
                    // <acidarmordicestun />
                    await objWriter.WriteElementStringAsync("acidarmordicestun",
                                                            (intBodTotalValue + intDamageResistanceDice
                                                                              + intAcidArmor)
                                                            .ToString(objCulture), token: token).ConfigureAwait(false);
                    // <fallingarmordicestun />
                    await objWriter.WriteElementStringAsync("fallingarmordicestun",
                                                            (intBodTotalValue + intDamageResistanceDice
                                                                              + intFallingArmor)
                                                            .ToString(objCulture), token: token).ConfigureAwait(false);
                    // <armordicephysical />
                    await objWriter.WriteElementStringAsync("armordicephysical",
                                                            (intBodTotalValue + intDamageResistanceDice
                                                                              + intArmor).ToString(objCulture),
                                                            token: token).ConfigureAwait(false);
                    // <firearmordicephysical />
                    await objWriter.WriteElementStringAsync("firearmordicephysical",
                                                            (intBodTotalValue + intDamageResistanceDice
                                                                              + intFireArmor)
                                                            .ToString(objCulture), token: token).ConfigureAwait(false);
                    // <coldarmordicephysical />
                    await objWriter.WriteElementStringAsync("coldarmordicephysical",
                                                            (intBodTotalValue + intDamageResistanceDice
                                                                              + intColdArmor)
                                                            .ToString(objCulture), token: token).ConfigureAwait(false);
                    // <electricityarmordicephysical />
                    await objWriter.WriteElementStringAsync("electricityarmordicephysical",
                                                            (intBodTotalValue + intDamageResistanceDice
                                                                              + intElectricityArmor)
                                                            .ToString(objCulture), token: token).ConfigureAwait(false);
                    // <acidarmordicephysical />
                    await objWriter.WriteElementStringAsync("acidarmordicephysical",
                                                            (intBodTotalValue + intDamageResistanceDice
                                                                              + intAcidArmor)
                                                            .ToString(objCulture), token: token).ConfigureAwait(false);
                    // <fallingarmordicephysical />
                    await objWriter.WriteElementStringAsync("fallingarmordicephysical",
                                                            (intBodTotalValue + intDamageResistanceDice
                                                                              + intFallingArmor)
                                                            .ToString(objCulture), token: token).ConfigureAwait(false);

                    bool blnIsAI = await GetIsAIAsync(token).ConfigureAwait(false);
                    bool blnPhysicalTrackIsCore = blnIsAI && !(HomeNode is Vehicle);
                    // Condition Monitors.
                    // <physicalcm />
                    int intPhysicalCM = await GetPhysicalCMAsync(token).ConfigureAwait(false);
                    await objWriter
                          .WriteElementStringAsync("physicalcm", intPhysicalCM.ToString(objCulture), token: token)
                          .ConfigureAwait(false);
                    await objWriter.WriteElementStringAsync("physicalcmiscorecm",
                                                            blnPhysicalTrackIsCore.ToString(
                                                                GlobalSettings.InvariantCultureInfo), token: token)
                                   .ConfigureAwait(false);
                    // <stuncm />
                    int intStunCM = await GetStunCMAsync(token).ConfigureAwait(false);
                    await objWriter.WriteElementStringAsync("stuncm", intStunCM.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    await objWriter.WriteElementStringAsync("stuncmismatrixcm",
                                                            blnIsAI.ToString(GlobalSettings.InvariantCultureInfo),
                                                            token: token).ConfigureAwait(false);

                    // Condition Monitor Progress.
                    // <physicalcmfilled />
                    await objWriter
                          .WriteElementStringAsync("physicalcmfilled", PhysicalCMFilled.ToString(objCulture),
                                                   token: token).ConfigureAwait(false);
                    // <stuncmfilled />
                    await objWriter
                          .WriteElementStringAsync("stuncmfilled", StunCMFilled.ToString(objCulture), token: token)
                          .ConfigureAwait(false);

                    // <cmthreshold>
                    await objWriter
                          .WriteElementStringAsync("cmthreshold",
                                                   (await GetCMThresholdAsync(token).ConfigureAwait(false)).ToString(
                                                       objCulture), token: token).ConfigureAwait(false);
                    // <cmthresholdoffset>
                    await objWriter.WriteElementStringAsync("physicalcmthresholdoffset",
                                                            Math.Min(
                                                                    await GetPhysicalCMThresholdOffsetAsync(token)
                                                                        .ConfigureAwait(false), intPhysicalCM)
                                                                .ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    // <cmthresholdoffset>
                    await objWriter.WriteElementStringAsync("stuncmthresholdoffset",
                                                            Math.Min(
                                                                    await GetStunCMThresholdOffsetAsync(token)
                                                                        .ConfigureAwait(false), intStunCM)
                                                                .ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    // <cmoverflow>
                    await objWriter
                          .WriteElementStringAsync("cmoverflow",
                                                   (await GetCMOverflowAsync(token).ConfigureAwait(false)).ToString(
                                                       objCulture), token: token).ConfigureAwait(false);

                    // <psyche>
                    await objWriter.WriteElementStringAsync(
                                       "psyche", _blnPsycheActive.ToString(GlobalSettings.InvariantCultureInfo),
                                       token: token)
                                   .ConfigureAwait(false);

                    // Calculate Initiatives.
                    // Initiative.
                    await objWriter
                          .WriteElementStringAsync("init", GetInitiative(objCulture, strLanguageToPrint), token: token)
                          .ConfigureAwait(false);
                    await objWriter
                          .WriteElementStringAsync("initdice", InitiativeDice.ToString(objCulture), token: token)
                          .ConfigureAwait(false);
                    await objWriter
                          .WriteElementStringAsync("initvalue", InitiativeValue.ToString(objCulture), token: token)
                          .ConfigureAwait(false);
                    await objWriter.WriteElementStringAsync("initbonus",
                                                            Math.Max(
                                                                    await ImprovementManager.ValueOfAsync(
                                                                        this, Improvement.ImprovementType.Initiative,
                                                                        token: token).ConfigureAwait(false),
                                                                    0)
                                                                .ToString(objCulture), token: token)
                                   .ConfigureAwait(false);

                    // Astral Initiative.
                    if (await GetMAGEnabledAsync(token).ConfigureAwait(false))
                    {
                        await objWriter.WriteElementStringAsync("astralinit",
                                                                GetAstralInitiative(objCulture, strLanguageToPrint),
                                                                token: token).ConfigureAwait(false);
                        await objWriter.WriteElementStringAsync("astralinitdice",
                                                                AstralInitiativeDice.ToString(objCulture), token: token)
                                       .ConfigureAwait(false);
                        await objWriter.WriteElementStringAsync("astralinitvalue",
                                                                AstralInitiativeValue.ToString(objCulture),
                                                                token: token).ConfigureAwait(false);
                    }

                    // Matrix Initiative (AR).
                    await objWriter.WriteElementStringAsync("matrixarinit",
                                                            GetMatrixInitiative(objCulture, strLanguageToPrint),
                                                            token: token).ConfigureAwait(false);
                    await objWriter.WriteElementStringAsync("matrixarinitdice",
                                                            MatrixInitiativeDice.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    await objWriter.WriteElementStringAsync("matrixarinitvalue",
                                                            MatrixInitiativeValue.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);

                    // Matrix Initiative (Cold).
                    await objWriter.WriteElementStringAsync("matrixcoldinit",
                                                            GetMatrixInitiativeCold(objCulture, strLanguageToPrint),
                                                            token: token).ConfigureAwait(false);
                    await objWriter.WriteElementStringAsync("matrixcoldinitdice",
                                                            MatrixInitiativeDice.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    await objWriter.WriteElementStringAsync("matrixcoldinitvalue",
                                                            MatrixInitiativeValue.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);

                    // Matrix Initiative (Hot).
                    await objWriter.WriteElementStringAsync("matrixhotinit",
                                                            GetMatrixInitiativeHot(objCulture, strLanguageToPrint),
                                                            token: token).ConfigureAwait(false);
                    await objWriter.WriteElementStringAsync("matrixhotinitdice",
                                                            MatrixInitiativeDice.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    await objWriter.WriteElementStringAsync("matrixhotinitvalue",
                                                            MatrixInitiativeValue.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);

                    // Rigger Initiative.
                    await objWriter.WriteElementStringAsync("riggerinit",
                                                            GetInitiative(objCulture, strLanguageToPrint), token: token)
                                   .ConfigureAwait(false);

                    // <magenabled />
                    await objWriter.WriteElementStringAsync("magenabled",
                                                            (await GetMAGEnabledAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.InvariantCultureInfo),
                                                            token: token).ConfigureAwait(false);
                    // <initiategrade />
                    await objWriter
                          .WriteElementStringAsync("initiategrade", InitiateGrade.ToString(objCulture), token: token)
                          .ConfigureAwait(false);
                    // <resenabled />
                    await objWriter.WriteElementStringAsync("resenabled",
                                                            RESEnabled.ToString(GlobalSettings.InvariantCultureInfo),
                                                            token: token).ConfigureAwait(false);
                    // <submersiongrade />
                    await objWriter
                          .WriteElementStringAsync("submersiongrade", SubmersionGrade.ToString(objCulture),
                                                   token: token).ConfigureAwait(false);
                    // <depenabled />
                    await objWriter.WriteElementStringAsync("depenabled",
                                                            DEPEnabled.ToString(GlobalSettings.InvariantCultureInfo),
                                                            token: token).ConfigureAwait(false);
                    // <groupmember />
                    await objWriter.WriteElementStringAsync("groupmember",
                                                            GroupMember.ToString(GlobalSettings.InvariantCultureInfo),
                                                            token: token).ConfigureAwait(false);
                    // <groupname />
                    await objWriter.WriteElementStringAsync("groupname", GroupName, token: token).ConfigureAwait(false);
                    // <groupnotes />
                    await objWriter.WriteElementStringAsync("groupnotes", GroupNotes, token: token)
                                   .ConfigureAwait(false);
                    // <surprise />
                    await objWriter.WriteElementStringAsync("surprise", Surprise.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    // <composure />
                    await objWriter.WriteElementStringAsync("composure", Composure.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    // <judgeintentions />
                    await objWriter
                          .WriteElementStringAsync("judgeintentions", JudgeIntentions.ToString(objCulture),
                                                   token: token).ConfigureAwait(false);
                    // <judgeintentionsresist />
                    await objWriter.WriteElementStringAsync("judgeintentionsresist",
                                                            JudgeIntentionsResist.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    // <liftandcarry />
                    await objWriter
                          .WriteElementStringAsync("liftandcarry", LiftAndCarry.ToString(objCulture), token: token)
                          .ConfigureAwait(false);
                    // <memory />
                    await objWriter.WriteElementStringAsync("memory", Memory.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    // <liftweight />
                    await objWriter.WriteElementStringAsync("liftweight",
                                                            LiftLimit.ToString(Settings.WeightFormat, objCulture),
                                                            token: token).ConfigureAwait(false);
                    // <carryweight />
                    await objWriter.WriteElementStringAsync("carryweight",
                                                            CarryLimit.ToString(Settings.WeightFormat, objCulture),
                                                            token: token).ConfigureAwait(false);
                    // <totalcarriedweight />
                    await objWriter.WriteElementStringAsync("totalcarriedweight",
                                                            TotalCarriedWeight.ToString(
                                                                Settings.WeightFormat, objCulture), token: token)
                                   .ConfigureAwait(false);
                    // <fatigueresist />
                    await objWriter
                          .WriteElementStringAsync("fatigueresist", FatigueResist.ToString(objCulture), token: token)
                          .ConfigureAwait(false);
                    // <radiationresist />
                    await objWriter
                          .WriteElementStringAsync("radiationresist", RadiationResist.ToString(objCulture),
                                                   token: token).ConfigureAwait(false);
                    // <sonicresist />
                    await objWriter
                          .WriteElementStringAsync("sonicresist", SonicResist.ToString(objCulture), token: token)
                          .ConfigureAwait(false);
                    // <toxincontacttesist />
                    await objWriter.WriteElementStringAsync("toxincontactresist",
                                                            ToxinContactResist(strLanguageToPrint, objCulture),
                                                            token: token).ConfigureAwait(false);
                    // <toxiningestionresist />
                    await objWriter.WriteElementStringAsync("toxiningestionresist",
                                                            ToxinIngestionResist(strLanguageToPrint, objCulture),
                                                            token: token).ConfigureAwait(false);
                    // <toxininhalationresist />
                    await objWriter.WriteElementStringAsync("toxininhalationresist",
                                                            ToxinInhalationResist(strLanguageToPrint, objCulture),
                                                            token: token).ConfigureAwait(false);
                    // <toxininjectionresist />
                    await objWriter.WriteElementStringAsync("toxininjectionresist",
                                                            ToxinInjectionResist(strLanguageToPrint, objCulture),
                                                            token: token).ConfigureAwait(false);
                    // <pathogencontactresist />
                    await objWriter.WriteElementStringAsync("pathogencontactresist",
                                                            PathogenContactResist(strLanguageToPrint, objCulture),
                                                            token: token).ConfigureAwait(false);
                    // <pathogeningestionresist />
                    await objWriter.WriteElementStringAsync("pathogeningestionresist",
                                                            PathogenIngestionResist(strLanguageToPrint, objCulture),
                                                            token: token).ConfigureAwait(false);
                    // <pathogeninhalationresist />
                    await objWriter.WriteElementStringAsync("pathogeninhalationresist",
                                                            PathogenInhalationResist(strLanguageToPrint, objCulture),
                                                            token: token).ConfigureAwait(false);
                    // <pathogeninjectionresist />
                    await objWriter.WriteElementStringAsync("pathogeninjectionresist",
                                                            PathogenInjectionResist(strLanguageToPrint, objCulture),
                                                            token: token).ConfigureAwait(false);
                    // <physiologicaladdictionresistfirsttime />
                    await objWriter.WriteElementStringAsync("physiologicaladdictionresistfirsttime",
                                                            PhysiologicalAddictionResistFirstTime.ToString(objCulture),
                                                            token: token).ConfigureAwait(false);
                    // <physiologicaladdictionresistalreadyaddicted />
                    await objWriter.WriteElementStringAsync("physiologicaladdictionresistalreadyaddicted",
                                                            PhysiologicalAddictionResistAlreadyAddicted.ToString(
                                                                objCulture), token: token).ConfigureAwait(false);
                    // <psychologicaladdictionresistfirsttime />
                    await objWriter.WriteElementStringAsync("psychologicaladdictionresistfirsttime",
                                                            PsychologicalAddictionResistFirstTime.ToString(objCulture),
                                                            token: token).ConfigureAwait(false);
                    // <psychologicaladdictionresistalreadyaddicted />
                    await objWriter.WriteElementStringAsync("psychologicaladdictionresistalreadyaddicted",
                                                            PsychologicalAddictionResistAlreadyAddicted.ToString(
                                                                objCulture), token: token).ConfigureAwait(false);
                    // <physicalcmnaturalrecovery />
                    await objWriter.WriteElementStringAsync("physicalcmnaturalrecovery",
                                                            PhysicalCMNaturalRecovery.ToString(objCulture),
                                                            token: token).ConfigureAwait(false);
                    // <stuncmnaturalrecovery />
                    await objWriter.WriteElementStringAsync("stuncmnaturalrecovery",
                                                            StunCMNaturalRecovery.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);

                    // Spell Resistances
                    //Indirect Dodge
                    await objWriter.WriteElementStringAsync("indirectdefenseresist",
                                                            SpellDefenseIndirectDodge.ToString(objCulture),
                                                            token: token).ConfigureAwait(false);
                    //Direct Soak - Mana
                    await objWriter.WriteElementStringAsync("directmanaresist",
                                                            SpellDefenseDirectSoakMana.ToString(objCulture),
                                                            token: token).ConfigureAwait(false);
                    //Direct Soak - Physical
                    await objWriter.WriteElementStringAsync("directphysicalresist",
                                                            SpellDefenseDirectSoakPhysical.ToString(objCulture),
                                                            token: token).ConfigureAwait(false);
                    //Detection Spells
                    await objWriter.WriteElementStringAsync("detectionspellresist",
                                                            SpellDefenseDetection.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    //Decrease Attribute - BOD
                    await objWriter.WriteElementStringAsync("decreasebodresist",
                                                            SpellDefenseDecreaseBOD.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    //Decrease Attribute - AGI
                    await objWriter.WriteElementStringAsync("decreaseagiresist",
                                                            SpellDefenseDecreaseAGI.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    //Decrease Attribute - REA
                    await objWriter.WriteElementStringAsync("decreaserearesist",
                                                            SpellDefenseDecreaseREA.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    //Decrease Attribute - STR
                    await objWriter.WriteElementStringAsync("decreasestrresist",
                                                            SpellDefenseDecreaseSTR.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    //Decrease Attribute - CHA
                    await objWriter.WriteElementStringAsync("decreasecharesist",
                                                            SpellDefenseDecreaseCHA.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    //Decrease Attribute - INT
                    await objWriter.WriteElementStringAsync("decreaseintresist",
                                                            SpellDefenseDecreaseINT.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    //Decrease Attribute - LOG
                    await objWriter.WriteElementStringAsync("decreaselogresist",
                                                            SpellDefenseDecreaseLOG.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    //Decrease Attribute - WIL
                    await objWriter.WriteElementStringAsync("decreasewilresist",
                                                            SpellDefenseDecreaseWIL.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    //Illusion - Mana
                    await objWriter.WriteElementStringAsync("illusionmanaresist",
                                                            SpellDefenseIllusionMana.ToString(objCulture), token: token)
                                   .ConfigureAwait(false);
                    //Illusion - Physical
                    await objWriter.WriteElementStringAsync("illusionphysicalresist",
                                                            SpellDefenseIllusionPhysical.ToString(objCulture),
                                                            token: token).ConfigureAwait(false);
                    //Manipulation - Mental
                    await objWriter.WriteElementStringAsync("manipulationmentalresist",
                                                            SpellDefenseManipulationMental.ToString(objCulture),
                                                            token: token).ConfigureAwait(false);
                    //Manipulation - Physical
                    await objWriter.WriteElementStringAsync("manipulationphysicalresist",
                                                            SpellDefenseManipulationPhysical.ToString(objCulture),
                                                            token: token).ConfigureAwait(false);

                    // <skills>
                    XmlElementWriteHelper objSkillsElement
                        = await objWriter.StartElementAsync("skills", token: token).ConfigureAwait(false);
                    try
                    {
                        await SkillsSection.Print(objWriter, objCulture, strLanguageToPrint, token: token)
                                           .ConfigureAwait(false);
                    }
                    finally
                    {
                        // </skills>
                        await objSkillsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <contacts>
                    XmlElementWriteHelper objContactsElement
                        = await objWriter.StartElementAsync("contacts", token: token).ConfigureAwait(false);
                    try
                    {
                        foreach (Contact objContact in Contacts)
                        {
                            await objContact.Print(objWriter, objCulture, strLanguageToPrint, token)
                                            .ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        // </contacts>
                        await objContactsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <limitmodifiersphys>
                    XmlElementWriteHelper objLimitModifiersPhysElement = await objWriter
                                                                               .StartElementAsync(
                                                                                   "limitmodifiersphys", token: token)
                                                                               .ConfigureAwait(false);
                    try
                    {
                        await (await GetLimitModifiersAsync(token).ConfigureAwait(false)).ForEachAsync(
                            async objLimitModifier =>
                            {
                                if (objLimitModifier.Limit == "Physical")
                                {
                                    await objLimitModifier.Print(objWriter, objCulture, strLanguageToPrint, token)
                                                          .ConfigureAwait(false);
                                }
                            }, token).ConfigureAwait(false);

                        // Populate Limit Modifiers from Improvements
                        foreach (Improvement objImprovement in await ImprovementManager
                                                                     .GetCachedImprovementListForValueOfAsync(this,
                                                                         Improvement.ImprovementType.LimitModifier,
                                                                         "Physical", token: token)
                                                                     .ConfigureAwait(false))
                        {
                            string strName = await GetObjectNameAsync(objImprovement, strLanguageToPrint, token)
                                .ConfigureAwait(false);
                            if (strName == objImprovement.SourceName)
                                strName = objImprovement.UniqueName;
                            strName += await LanguageManager
                                             .GetStringAsync("String_Colon", strLanguageToPrint, token: token)
                                             .ConfigureAwait(false) +
                                       await LanguageManager
                                             .GetStringAsync("String_Space", strLanguageToPrint, token: token)
                                             .ConfigureAwait(false);
                            if (objImprovement.Value > 0)
                                strName += '+';
                            strName += objImprovement.Value.ToString(objCulture);

                            if (!string.IsNullOrEmpty(objImprovement.Condition))
                                strName += ',' + await LanguageManager
                                                       .GetStringAsync("String_Space", strLanguageToPrint, token: token)
                                                       .ConfigureAwait(false) +
                                           objImprovement.Condition;

                            // <limitmodifier>
                            XmlElementWriteHelper objLimitModifierElement = await objWriter
                                .StartElementAsync("limitmodifier", token: token).ConfigureAwait(false);
                            try
                            {
                                await objWriter.WriteElementStringAsync("name", strName, token: token)
                                               .ConfigureAwait(false);
                                if (GlobalSettings.PrintNotes)
                                    await objWriter.WriteElementStringAsync("notes", objImprovement.Notes, token: token)
                                                   .ConfigureAwait(false);
                            }
                            finally
                            {
                                // </limitmodifier>
                                await objLimitModifierElement.DisposeAsync().ConfigureAwait(false);
                            }
                        }
                    }
                    finally
                    {
                        // </limitmodifiersphys>
                        await objLimitModifiersPhysElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <limitmodifiersment>
                    XmlElementWriteHelper objLimitModifiersMentElement = await objWriter
                                                                               .StartElementAsync(
                                                                                   "limitmodifiersment", token: token)
                                                                               .ConfigureAwait(false);
                    try
                    {
                        await (await GetLimitModifiersAsync(token).ConfigureAwait(false)).ForEachAsync(
                            async objLimitModifier =>
                            {
                                if (objLimitModifier.Limit == "Mental")
                                {
                                    await objLimitModifier.Print(objWriter, objCulture, strLanguageToPrint, token)
                                                          .ConfigureAwait(false);
                                }
                            }, token).ConfigureAwait(false);

                        // Populate Limit Modifiers from Improvements
                        foreach (Improvement objImprovement in await ImprovementManager
                                                                     .GetCachedImprovementListForValueOfAsync(this,
                                                                         Improvement.ImprovementType.LimitModifier,
                                                                         "Mental", token: token).ConfigureAwait(false))
                        {
                            string strName = await GetObjectNameAsync(objImprovement, strLanguageToPrint, token)
                                .ConfigureAwait(false);
                            if (strName == objImprovement.SourceName)
                                strName = objImprovement.UniqueName;
                            strName += await LanguageManager
                                             .GetStringAsync("String_Colon", strLanguageToPrint, token: token)
                                             .ConfigureAwait(false) +
                                       await LanguageManager
                                             .GetStringAsync("String_Space", strLanguageToPrint, token: token)
                                             .ConfigureAwait(false);
                            if (objImprovement.Value > 0)
                                strName += '+';
                            strName += objImprovement.Value.ToString(objCulture);

                            if (!string.IsNullOrEmpty(objImprovement.Condition))
                                strName += ',' + await LanguageManager
                                                       .GetStringAsync("String_Space", strLanguageToPrint, token: token)
                                                       .ConfigureAwait(false) +
                                           objImprovement.Condition;

                            // <limitmodifier>
                            XmlElementWriteHelper objLimitModifierElement = await objWriter
                                .StartElementAsync("limitmodifier", token: token).ConfigureAwait(false);
                            try
                            {
                                await objWriter.WriteElementStringAsync("name", strName, token: token)
                                               .ConfigureAwait(false);
                                if (GlobalSettings.PrintNotes)
                                    await objWriter.WriteElementStringAsync("notes", objImprovement.Notes, token: token)
                                                   .ConfigureAwait(false);
                            }
                            finally
                            {
                                // </limitmodifier>
                                await objLimitModifierElement.DisposeAsync().ConfigureAwait(false);
                            }
                        }
                    }
                    finally
                    {
                        // </limitmodifiersment>
                        await objLimitModifiersMentElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <limitmodifierssoc>
                    XmlElementWriteHelper objLimitModifiersSocElement
                        = await objWriter.StartElementAsync("limitmodifierssoc", token: token).ConfigureAwait(false);
                    try
                    {
                        await (await GetLimitModifiersAsync(token).ConfigureAwait(false)).ForEachAsync(
                            async objLimitModifier =>
                            {
                                if (objLimitModifier.Limit == "Social")
                                {
                                    await objLimitModifier.Print(objWriter, objCulture, strLanguageToPrint, token)
                                                          .ConfigureAwait(false);
                                }
                            }, token).ConfigureAwait(false);

                        // Populate Limit Modifiers from Improvements
                        foreach (Improvement objImprovement in await ImprovementManager
                                                                     .GetCachedImprovementListForValueOfAsync(this,
                                                                         Improvement.ImprovementType.LimitModifier,
                                                                         "Social", token: token).ConfigureAwait(false))
                        {
                            string strName = await GetObjectNameAsync(objImprovement, strLanguageToPrint, token)
                                .ConfigureAwait(false);
                            if (strName == objImprovement.SourceName)
                                strName = objImprovement.UniqueName;
                            strName += await LanguageManager
                                             .GetStringAsync("String_Colon", strLanguageToPrint, token: token)
                                             .ConfigureAwait(false) +
                                       await LanguageManager
                                             .GetStringAsync("String_Space", strLanguageToPrint, token: token)
                                             .ConfigureAwait(false);
                            if (objImprovement.Value > 0)
                                strName += '+';
                            strName += objImprovement.Value.ToString(objCulture);

                            if (!string.IsNullOrEmpty(objImprovement.Condition))
                                strName += ',' + await LanguageManager
                                                       .GetStringAsync("String_Space", strLanguageToPrint, token: token)
                                                       .ConfigureAwait(false) +
                                           objImprovement.Condition;

                            // <limitmodifier>
                            XmlElementWriteHelper objLimitModifierElement = await objWriter
                                .StartElementAsync("limitmodifier", token: token).ConfigureAwait(false);
                            try
                            {
                                await objWriter.WriteElementStringAsync("name", strName, token: token)
                                               .ConfigureAwait(false);
                                if (GlobalSettings.PrintNotes)
                                    await objWriter.WriteElementStringAsync("notes", objImprovement.Notes, token: token)
                                                   .ConfigureAwait(false);
                            }
                            finally
                            {
                                // </limitmodifier>
                                await objLimitModifierElement.DisposeAsync().ConfigureAwait(false);
                            }
                        }
                    }
                    finally
                    {
                        // </limitmodifierssoc>
                        await objLimitModifiersSocElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <mentorspirits>
                    XmlElementWriteHelper objMentorSpiritsElement
                        = await objWriter.StartElementAsync("mentorspirits", token: token).ConfigureAwait(false);
                    try
                    {
                        foreach (MentorSpirit objMentorSpirit in MentorSpirits)
                        {
                            await objMentorSpirit.Print(objWriter, strLanguageToPrint, token).ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        // </mentorspirits>
                        await objMentorSpiritsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <spells>
                    XmlElementWriteHelper objSpellsElement
                        = await objWriter.StartElementAsync("spells", token: token).ConfigureAwait(false);
                    try
                    {
                        foreach (Spell objSpell in Spells)
                        {
                            await objSpell.Print(objWriter, objCulture, strLanguageToPrint, token)
                                          .ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        // </spells>
                        await objSpellsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <powers>
                    XmlElementWriteHelper objPowersElement
                        = await objWriter.StartElementAsync("powers", token: token).ConfigureAwait(false);
                    try
                    {
                        foreach (Power objPower in Powers)
                        {
                            await objPower.Print(objWriter, objCulture, strLanguageToPrint, token)
                                          .ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        // </powers>
                        await objPowersElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <spirits>
                    XmlElementWriteHelper objSpiritsElement
                        = await objWriter.StartElementAsync("spirits", token: token).ConfigureAwait(false);
                    try
                    {
                        foreach (Spirit objSpirit in Spirits)
                        {
                            await objSpirit.Print(objWriter, objCulture, strLanguageToPrint, token)
                                           .ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        // </spirits>
                        await objSpiritsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <complexforms>
                    XmlElementWriteHelper objComplexFormsElement
                        = await objWriter.StartElementAsync("complexforms", token: token).ConfigureAwait(false);
                    try
                    {
                        foreach (ComplexForm objComplexForm in ComplexForms)
                        {
                            await objComplexForm.Print(objWriter, strLanguageToPrint, token).ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        // </complexforms>
                        await objComplexFormsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <aiprograms>
                    XmlElementWriteHelper objAIProgramsElement
                        = await objWriter.StartElementAsync("aiprograms", token: token).ConfigureAwait(false);
                    try
                    {
                        foreach (AIProgram objProgram in AIPrograms)
                        {
                            await objProgram.Print(objWriter, strLanguageToPrint, token).ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        // </aiprograms>
                        await objAIProgramsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <martialarts>
                    XmlElementWriteHelper objMartialArtsElement
                        = await objWriter.StartElementAsync("martialarts", token: token).ConfigureAwait(false);
                    try
                    {
                        foreach (MartialArt objMartialArt in MartialArts)
                        {
                            await objMartialArt.Print(objWriter, objCulture, strLanguageToPrint, token)
                                               .ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        // </martialarts>
                        await objMartialArtsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <armors>
                    XmlElementWriteHelper objArmorsElement
                        = await objWriter.StartElementAsync("armors", token: token).ConfigureAwait(false);
                    try
                    {
                        foreach (Armor objArmor in Armor)
                        {
                            await objArmor.Print(objWriter, objCulture, strLanguageToPrint, token)
                                          .ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        // </armors>
                        await objArmorsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <weapons>
                    XmlElementWriteHelper objWeaponsElement
                        = await objWriter.StartElementAsync("weapons", token: token).ConfigureAwait(false);
                    try
                    {
                        foreach (Weapon objWeapon in Weapons)
                        {
                            await objWeapon.Print(objWriter, objCulture, strLanguageToPrint, token)
                                           .ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        // </weapons>
                        await objWeaponsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <cyberwares>
                    XmlElementWriteHelper objCyberwaresElement
                        = await objWriter.StartElementAsync("cyberwares", token: token).ConfigureAwait(false);
                    try
                    {
                        foreach (Cyberware objCyberware in Cyberware)
                        {
                            await objCyberware.Print(objWriter, objCulture, strLanguageToPrint, token)
                                              .ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        // </cyberwares>
                        await objCyberwaresElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <qualities>
                    XmlElementWriteHelper objQualitiesElement
                        = await objWriter.StartElementAsync("qualities", token: token).ConfigureAwait(false);
                    try
                    {
                        // Multiple instances of the same quality are combined into just one entry with a number next to it (e.g. 6 discrete entries of "Focused Concentration" become "Focused Concentration 6")
                        Dictionary<string, int> strQualitiesToPrint = new Dictionary<string, int>(Qualities.Count);
                        foreach (Quality objQuality in Qualities)
                        {
                            string strKey = objQuality.SourceIDString + '|' + objQuality.SourceName + '|'
                                            + objQuality.Extra;
                            if (strQualitiesToPrint.TryGetValue(strKey, out int intExistingRating))
                            {
                                strQualitiesToPrint[strKey] = intExistingRating + 1;
                            }
                            else
                            {
                                strQualitiesToPrint.Add(strKey, 1);
                            }
                        }

                        foreach (Quality objQuality in Qualities)
                        {
                            string strKey = objQuality.SourceIDString + '|' + objQuality.SourceName + '|'
                                            + objQuality.Extra;
                            if (strQualitiesToPrint.TryGetValue(strKey, out int intLoopRating))
                            {
                                await objQuality.Print(objWriter, intLoopRating, objCulture, strLanguageToPrint, token)
                                                .ConfigureAwait(false);
                                strQualitiesToPrint.Remove(strKey);
                            }
                        }
                    }
                    finally
                    {
                        // </qualities>
                        await objQualitiesElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <lifestyles>
                    XmlElementWriteHelper objLifestylesElement
                        = await objWriter.StartElementAsync("lifestyles", token: token).ConfigureAwait(false);
                    try
                    {
                        foreach (Lifestyle objLifestyle in Lifestyles)
                        {
                            await objLifestyle.Print(objWriter, objCulture, strLanguageToPrint, token)
                                              .ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        // </lifestyles>
                        await objLifestylesElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <gears>
                    XmlElementWriteHelper objGearsElement
                        = await objWriter.StartElementAsync("gears", token: token).ConfigureAwait(false);
                    try
                    {
                        foreach (Gear objGear in Gear)
                        {
                            await objGear.Print(objWriter, objCulture, strLanguageToPrint, token).ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        // </gears>
                        await objGearsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <drugs>
                    XmlElementWriteHelper objDrugsElement
                        = await objWriter.StartElementAsync("drugs", token: token).ConfigureAwait(false);
                    try
                    {
                        foreach (Drug objDrug in Drugs)
                        {
                            await objDrug.Print(objWriter, objCulture, strLanguageToPrint, token).ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        // </drugs>
                        await objDrugsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <vehicles>
                    XmlElementWriteHelper objVehiclesElement
                        = await objWriter.StartElementAsync("vehicles", token: token).ConfigureAwait(false);
                    try
                    {
                        foreach (Vehicle objVehicle in Vehicles)
                        {
                            await objVehicle.Print(objWriter, objCulture, strLanguageToPrint, token)
                                            .ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        // </vehicles>
                        await objVehiclesElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <initiationgrade>
                    XmlElementWriteHelper objInitiationGradeElement
                        = await objWriter.StartElementAsync("initiationgrade", token: token).ConfigureAwait(false);
                    try
                    {
                        foreach (InitiationGrade objGrade in InitiationGrades)
                        {
                            await objGrade.Print(objWriter, objCulture, token).ConfigureAwait(false);

                            //TODO: Probably better to integrate this into the main print method, but eh.
                            // <metamagics>
                            XmlElementWriteHelper objInitiationMetamagicsElement
                                = await objWriter.StartElementAsync("metamagics", token: token).ConfigureAwait(false);
                            try
                            {
                                foreach (Metamagic objMetamagic in Metamagics)
                                {
                                    if (objMetamagic.Grade == objGrade.Grade)
                                        await objMetamagic.Print(objWriter, objCulture, strLanguageToPrint, token)
                                                          .ConfigureAwait(false);
                                }
                            }
                            finally
                            {
                                // </metamagics>
                                await objInitiationMetamagicsElement.DisposeAsync().ConfigureAwait(false);
                            }

                            // <arts>
                            XmlElementWriteHelper objInitiationArtsElement
                                = await objWriter.StartElementAsync("arts", token: token).ConfigureAwait(false);
                            try
                            {
                                foreach (Art objArt in Arts)
                                {
                                    if (objArt.Grade == objGrade.Grade)
                                        await objArt.Print(objWriter, strLanguageToPrint, token).ConfigureAwait(false);
                                }
                            }
                            finally
                            {
                                // </arts>
                                await objInitiationArtsElement.DisposeAsync().ConfigureAwait(false);
                            }

                            // <enhancements>
                            XmlElementWriteHelper objInitiationEnhancementsElement = await objWriter
                                .StartElementAsync("enhancements", token: token).ConfigureAwait(false);
                            try
                            {
                                foreach (Enhancement objEnhancement in Enhancements)
                                {
                                    if (objEnhancement.Grade == objGrade.Grade)
                                        await objEnhancement.Print(objWriter, strLanguageToPrint, token)
                                                            .ConfigureAwait(false);
                                }
                            }
                            finally
                            {
                                // </enhancements>
                                await objInitiationEnhancementsElement.DisposeAsync().ConfigureAwait(false);
                            }
                        }
                    }
                    finally
                    {
                        // </initiationgrade>
                        await objInitiationGradeElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <metamagics>
                    XmlElementWriteHelper objMetamagicsElement
                        = await objWriter.StartElementAsync("metamagics", token: token).ConfigureAwait(false);
                    try
                    {
                        foreach (Metamagic objMetamagic in Metamagics)
                        {
                            await objMetamagic.Print(objWriter, objCulture, strLanguageToPrint, token)
                                              .ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        // </metamagics>
                        await objMetamagicsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <arts>
                    XmlElementWriteHelper objArtsElement
                        = await objWriter.StartElementAsync("arts", token: token).ConfigureAwait(false);
                    try
                    {
                        foreach (Art objArt in Arts)
                        {
                            await objArt.Print(objWriter, strLanguageToPrint, token).ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        // </arts>
                        await objArtsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <enhancements>
                    XmlElementWriteHelper objEnhancementsElement
                        = await objWriter.StartElementAsync("enhancements", token: token).ConfigureAwait(false);
                    try
                    {
                        foreach (Enhancement objEnhancement in Enhancements)
                        {
                            await objEnhancement.Print(objWriter, strLanguageToPrint, token).ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        // </enhancements>
                        await objEnhancementsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <critterpowers>
                    XmlElementWriteHelper objCritterPowersElement
                        = await objWriter.StartElementAsync("critterpowers", token: token).ConfigureAwait(false);
                    try
                    {
                        foreach (CritterPower objPower in CritterPowers)
                        {
                            await objPower.Print(objWriter, strLanguageToPrint, token).ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        // </critterpowers>
                        await objCritterPowersElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <sustainedobjects>
                    XmlElementWriteHelper objSustainedObjectsElement
                        = await objWriter.StartElementAsync("sustainedobjects", token: token).ConfigureAwait(false);
                    try
                    {
                        foreach (SustainedObject objSustained in SustainedCollection)
                        {
                            await objSustained.Print(objWriter, objCulture, strLanguageToPrint, token)
                                              .ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        // </sustainedobjects>
                        await objSustainedObjectsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <otherarmors>
                    XmlElementWriteHelper objOtherArmorsElement
                        = await objWriter.StartElementAsync("otherarmors", token: token).ConfigureAwait(false);
                    try
                    {
                        foreach (Improvement objImprovement in await ImprovementManager
                                                                     .GetCachedImprovementListForValueOfAsync(
                                                                         this, Improvement.ImprovementType.Armor,
                                                                         token: token).ConfigureAwait(false))
                        {
                            if (objImprovement.ImproveSource == Improvement.ImprovementSource.Armor
                                || objImprovement.ImproveSource == Improvement.ImprovementSource.ArmorMod)
                                continue;
                            // <otherarmor>
                            XmlElementWriteHelper objBaseElement = await objWriter
                                                                         .StartElementAsync("otherarmor", token: token)
                                                                         .ConfigureAwait(false);
                            try
                            {
                                await objWriter.WriteElementStringAsync("guid", objImprovement.InternalId, token: token)
                                               .ConfigureAwait(false);
                                await objWriter
                                      .WriteElementStringAsync("sourcename", objImprovement.SourceName, token: token)
                                      .ConfigureAwait(false);
                                await objWriter
                                      .WriteElementStringAsync("objectname",
                                                               await GetObjectNameAsync(
                                                                       objImprovement, strLanguageToPrint, token)
                                                                   .ConfigureAwait(false), token: token)
                                      .ConfigureAwait(false);
                                await objWriter
                                      .WriteElementStringAsync("objectname_english",
                                                               await GetObjectNameAsync(
                                                                   objImprovement, GlobalSettings.DefaultLanguage,
                                                                   token).ConfigureAwait(false), token: token)
                                      .ConfigureAwait(false);
                                await objWriter
                                      .WriteElementStringAsync(
                                          "armor", objImprovement.Value.ToString(GlobalSettings.InvariantCultureInfo),
                                          token: token).ConfigureAwait(false);
                                await objWriter
                                      .WriteElementStringAsync("improvesource", objImprovement.ImproveSource.ToString(),
                                                               token: token).ConfigureAwait(false);
                                await objWriter
                                      .WriteElementStringAsync(
                                          "enabled",
                                          objImprovement.Enabled.ToString(GlobalSettings.InvariantCultureInfo),
                                          token: token).ConfigureAwait(false);
                                await objWriter
                                      .WriteElementStringAsync("customname", objImprovement.CustomName, token: token)
                                      .ConfigureAwait(false);
                                await objWriter
                                      .WriteElementStringAsync("customgroup", objImprovement.CustomGroup, token: token)
                                      .ConfigureAwait(false);
                                if (GlobalSettings.PrintNotes)
                                    await objWriter.WriteElementStringAsync("notes", objImprovement.Notes, token: token)
                                                   .ConfigureAwait(false);
                            }
                            finally
                            {
                                // </otherarmor>
                                await objBaseElement.DisposeAsync().ConfigureAwait(false);
                            }
                        }
                    }
                    finally
                    {
                        // </otherarmors>
                        await objOtherArmorsElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // <calendar>
                    XmlElementWriteHelper objCalendarElement
                        = await objWriter.StartElementAsync("calendar", token: token).ConfigureAwait(false);
                    try
                    {
                        foreach (CalendarWeek objWeek in Calendar)
                            await objWeek.Print(objWriter, objCulture, GlobalSettings.PrintNotes, token)
                                         .ConfigureAwait(false);
                    }
                    finally
                    {
                        // </calendar>
                        await objCalendarElement.DisposeAsync().ConfigureAwait(false);
                    }

                    // Print the Expense Log Entries if the option is enabled.
                    if (GlobalSettings.PrintExpenses)
                    {
                        // <expenses>
                        XmlElementWriteHelper objExpensesElement
                            = await objWriter.StartElementAsync("expenses", token: token).ConfigureAwait(false);
                        try
                        {
                            foreach (ExpenseLogEntry objExpense in ExpenseEntries.Reverse())
                                await objExpense.Print(objWriter, objCulture, strLanguageToPrint, token)
                                                .ConfigureAwait(false);
                        }
                        finally
                        {
                            // </expenses>
                            await objExpensesElement.DisposeAsync().ConfigureAwait(false);
                        }
                    }
                }
                finally
                {
                    // </character>
                    await objCharacterElement.DisposeAsync().ConfigureAwait(false);
                }
            }
        }

        #endregion Create, Save, Load and Print Methods

        private int _intIsDisposed;

        public bool IsDisposed => _intIsDisposed > 0;

        /// <summary>
        /// Remove stray event handlers and clear all info used by this character
        /// </summary>
        public void Dispose()
        {
            if (LockObject.IsDisposed)
                return;

            if (Program.OpenCharacters.Contains(this)
                || Program.OpenCharacters.Any(x => x.LinkedCharacters.Contains(this)))
                return; // Do not actually dispose any characters who are still in the open characters list or required by a character who is

            if (Interlocked.CompareExchange(ref _intIsDisposed, 1, 0) > 0)
                return;

            using (LockObject.EnterWriteLock()) // Wait for all pending locks to get freed before disposing
            {
                Interlocked.Exchange(ref _lstInternalIdsNeedingReapplyImprovements, null);
                using (_objSettings.LockObject.EnterWriteLock())
                    _objSettings.PropertyChanged -= OptionsOnPropertyChanged;
                ImprovementManager.ClearCachedValues(this);
                _lstLinkedCharacters.Clear(); // Clear this list because it relates to Contacts and Spirits disposal
                _lstLinkedCharacters.Dispose();
                foreach (Image imgMugshot in _lstMugshots)
                    imgMugshot.Dispose();
                _lstMugshots.Dispose();
                foreach (Contact objContact in _lstContacts)
                    objContact.Dispose();
                _lstContacts.Dispose();
                foreach (Spirit objSpirit in _lstSpirits)
                    objSpirit.Dispose();
                _lstSpirits.Dispose();
                foreach (Armor objItem in _lstArmor)
                    objItem.Dispose();
                _lstArmor.Dispose();
                foreach (Weapon objItem in _lstWeapons)
                    objItem.Dispose();
                _lstWeapons.Dispose();
                foreach (Gear objItem in _lstGear)
                    objItem.Dispose();
                _lstGear.Dispose();
                foreach (Cyberware objItem in _lstCyberware)
                    objItem.Dispose();
                _lstCyberware.Dispose();
                foreach (Vehicle objItem in _lstVehicles)
                    objItem.Dispose();
                _lstVehicles.Dispose();
                foreach (Lifestyle objItem in _lstLifestyles)
                    objItem.Dispose();
                _lstLifestyles.Dispose();
                foreach (Spell objItem in _lstSpells)
                    objItem.Dispose();
                _lstSpells.Dispose();
                foreach (MartialArt objItem in _lstMartialArts)
                    objItem.Dispose();
                _lstMartialArts.Dispose();
                _lstComplexForms.Dispose();
                _lstAIPrograms.Dispose();
                _lstPowers.Dispose();
                _lstCritterPowers.Dispose();
                _lstFoci.Dispose();
                foreach (StackedFocus objItem in _lstStackedFoci)
                    objItem.Dispose();
                _lstStackedFoci.Dispose();
                _lstMetamagics.Dispose();
                _lstArts.Dispose();
                _lstEnhancements.Dispose();
                _lstImprovements.Dispose();
                _lstInitiationGrades.Dispose();
                foreach (Quality objItem in _lstQualities)
                    objItem.Dispose();
                _lstQualities.Dispose();
                foreach (CalendarWeek objItem in _lstCalendar)
                    objItem.Dispose();
                _lstCalendar.Dispose();
                foreach (Drug objItem in _lstDrugs)
                    objItem.Dispose();
                _lstDrugs.Dispose();
                foreach (MentorSpirit objItem in _lstMentorSpirits)
                    objItem.Dispose();
                _lstMentorSpirits.Dispose();
                _lstExpenseLog.Dispose();
                foreach (Location objItem in _lstArmorLocations)
                    objItem.Dispose();
                _lstArmorLocations.Dispose();
                foreach (Location objItem in _lstGearLocations)
                    objItem.Dispose();
                _lstGearLocations.Dispose();
                foreach (Location objItem in _lstWeaponLocations)
                    objItem.Dispose();
                _lstWeaponLocations.Dispose();
                foreach (Location objItem in _lstVehicleLocations)
                    objItem.Dispose();
                _lstVehicleLocations.Dispose();
                _lstImprovementGroups.Dispose();
                _lstLimitModifiers.Dispose();
                _lstSustainedObjects.Dispose();
                _lstPrioritySkills.Dispose();
                _objSkillsSection.Dispose();
                _objAttributeSection.Dispose();
                _setDoOnSaveCompleted.Dispose();
                _setDoOnSaveCompletedAsync.Dispose();
                if (_stkPushText.IsValueCreated)
                    _stkPushText.Value.Dispose();
                if (!SettingsManager.LoadedCharacterSettings.ContainsKey(_objSettings.DictionaryKey))
                    _objSettings.Dispose();
                _objCachedEssenceLock.Dispose();
                _objTradition.Dispose();
                if (_lstCachedContactArchetypes != null)
                    Utils.ListItemListPool.Return(ref _lstCachedContactArchetypes);
            }

            LockObject.Dispose();
        }

        /// <summary>
        /// Remove stray event handlers and clear all info used by this character
        /// </summary>
        public async ValueTask DisposeAsync()
        {
            if (LockObject.IsDisposed)
                return;

            if (await Program.OpenCharacters.ContainsAsync(this).ConfigureAwait(false)
                || await Program.OpenCharacters.AnyAsync(async x => await x.LinkedCharacters.ContainsAsync(this).ConfigureAwait(false)).ConfigureAwait(false))
                return; // Do not actually dispose any characters who are still in the open characters list or required by a character who is

            if (Interlocked.CompareExchange(ref _intIsDisposed, 1, 0) > 0)
                return;

            IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync().ConfigureAwait(false);
            try
            {
                Interlocked.Exchange(ref _lstInternalIdsNeedingReapplyImprovements, null);
                IAsyncDisposable objLocker2 = await _objSettings.LockObject.EnterWriteLockAsync().ConfigureAwait(false);
                try
                {
                    _objSettings.PropertyChanged -= OptionsOnPropertyChanged;
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
                await ImprovementManager.ClearCachedValuesAsync(this).ConfigureAwait(false);
                await _lstLinkedCharacters.ClearAsync()
                                          .ConfigureAwait(
                                              false); // Clear this list because it relates to Contacts and Spirits disposal
                await _lstLinkedCharacters.DisposeAsync().ConfigureAwait(false);
                await _lstMugshots.ForEachAsync(x => x.Dispose()).ConfigureAwait(false);
                await _lstContacts.ForEachAsync(x => x.DisposeAsync().AsTask()).ConfigureAwait(false);
                await _lstSpirits.ForEachAsync(x => x.DisposeAsync().AsTask()).ConfigureAwait(false);
                await _lstArmor.ForEachAsync(x => x.DisposeAsync().AsTask()).ConfigureAwait(false);
                await _lstWeapons.ForEachAsync(x => x.DisposeAsync().AsTask()).ConfigureAwait(false);
                await _lstGear.ForEachAsync(x => x.DisposeAsync().AsTask()).ConfigureAwait(false);
                await _lstCyberware.ForEachAsync(x => x.DisposeAsync().AsTask()).ConfigureAwait(false);
                await _lstVehicles.ForEachAsync(x => x.DisposeAsync().AsTask()).ConfigureAwait(false);
                await _lstLifestyles.ForEachAsync(x => x.DisposeAsync().AsTask()).ConfigureAwait(false);
                await _lstSpells.ForEachAsync(x => x.Dispose()).ConfigureAwait(false);
                await _lstMartialArts.ForEachAsync(x => x.DisposeAsync().AsTask()).ConfigureAwait(false);
                await _lstMartialArts.DisposeAsync().ConfigureAwait(false);
                await _lstComplexForms.DisposeAsync().ConfigureAwait(false);
                await _lstAIPrograms.DisposeAsync().ConfigureAwait(false);
                await _lstPowers.ForEachAsync(x => x.DisposeAsync().AsTask()).ConfigureAwait(false);
                await _lstPowers.DisposeAsync().ConfigureAwait(false);
                await _lstCritterPowers.DisposeAsync().ConfigureAwait(false);
                await _lstFoci.DisposeAsync().ConfigureAwait(false);
                await _lstStackedFoci.ForEachAsync(x => x.DisposeAsync().AsTask()).ConfigureAwait(false);
                await _lstStackedFoci.DisposeAsync().ConfigureAwait(false);
                await _lstMetamagics.DisposeAsync().ConfigureAwait(false);
                await _lstArts.DisposeAsync().ConfigureAwait(false);
                await _lstEnhancements.DisposeAsync().ConfigureAwait(false);
                await _lstImprovements.DisposeAsync().ConfigureAwait(false);
                await _lstInitiationGrades.DisposeAsync().ConfigureAwait(false);
                await _lstQualities.ForEachAsync(x => x.DisposeAsync().AsTask()).ConfigureAwait(false);
                await _lstQualities.DisposeAsync().ConfigureAwait(false);
                await _lstCalendar.ForEachAsync(x => x.DisposeAsync().AsTask()).ConfigureAwait(false);
                await _lstCalendar.DisposeAsync().ConfigureAwait(false);
                await _lstDrugs.ForEachAsync(x => x.DisposeAsync().AsTask()).ConfigureAwait(false);
                await _lstDrugs.DisposeAsync().ConfigureAwait(false);
                await _lstMentorSpirits.ForEachAsync(x => x.DisposeAsync().AsTask()).ConfigureAwait(false);
                await _lstMentorSpirits.DisposeAsync().ConfigureAwait(false);
                await _lstExpenseLog.DisposeAsync().ConfigureAwait(false);
                await _lstArmorLocations.ForEachAsync(x => x.DisposeAsync().AsTask()).ConfigureAwait(false);
                await _lstGearLocations.ForEachAsync(x => x.DisposeAsync().AsTask()).ConfigureAwait(false);
                await _lstWeaponLocations.ForEachAsync(x => x.DisposeAsync().AsTask()).ConfigureAwait(false);
                await _lstVehicleLocations.ForEachAsync(x => x.DisposeAsync().AsTask()).ConfigureAwait(false);
                await _lstArmorLocations.DisposeAsync().ConfigureAwait(false);
                await _lstGearLocations.DisposeAsync().ConfigureAwait(false);
                await _lstWeaponLocations.DisposeAsync().ConfigureAwait(false);
                await _lstVehicleLocations.DisposeAsync().ConfigureAwait(false);
                await _lstImprovementGroups.DisposeAsync().ConfigureAwait(false);
                await _lstLimitModifiers.DisposeAsync().ConfigureAwait(false);
                await _lstSustainedObjects.DisposeAsync().ConfigureAwait(false);
                await _lstPrioritySkills.DisposeAsync().ConfigureAwait(false);
                await _objSkillsSection.DisposeAsync().ConfigureAwait(false);
                await _objAttributeSection.DisposeAsync().ConfigureAwait(false);
                await _setDoOnSaveCompleted.DisposeAsync().ConfigureAwait(false);
                await _setDoOnSaveCompletedAsync.DisposeAsync().ConfigureAwait(false);
                if (_stkPushText.IsValueCreated)
                    await _stkPushText.Value.DisposeAsync().ConfigureAwait(false);
                if (!await (await SettingsManager.GetLoadedCharacterSettingsAsync().ConfigureAwait(false))
                           .ContainsKeyAsync(await _objSettings.GetDictionaryKeyAsync().ConfigureAwait(false)).ConfigureAwait(false))
                    await _objSettings.DisposeAsync().ConfigureAwait(false);
                await _objCachedEssenceLock.DisposeAsync().ConfigureAwait(false);
                await _objTradition.DisposeAsync().ConfigureAwait(false);
                if (_lstCachedContactArchetypes != null)
                    Utils.ListItemListPool.Return(ref _lstCachedContactArchetypes);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }

            await LockObject.DisposeAsync().ConfigureAwait(false);
        }

        /// <summary>
        /// Reset all of the Character information and start from scratch.
        /// </summary>
        public void ResetCharacter(CancellationToken token = default)
        {
            using (LockObject.EnterWriteLock(token))
            {
                _intFreeSpells = 0;
                _intCFPLimit = 0;
                _intAINormalProgramLimit = 0;
                _intAIAdvancedProgramLimit = 0;
                _intCachedCareerKarma = int.MinValue;
                _intCachedContactPoints = int.MinValue;
                _decCachedBaseCarryLimit = decimal.MinValue;
                _decCachedBaseLiftLimit = decimal.MinValue;
                _decCachedTotalCarriedWeight = decimal.MinValue;
                _decCachedEncumbranceInterval = decimal.MinValue;
                _intCachedEnemyKarma = int.MinValue;
                _intCachedInitiationEnabled = int.MinValue;
                _intCachedMetagenicNegativeQualities = int.MinValue;
                _intCachedMetagenicPositiveQualities = int.MinValue;
                _intCachedNegativeQualities = int.MinValue;
                _intCachedNegativeQualityLimitKarma = int.MinValue;
                _intCachedPositiveQualityLimitKarma = int.MinValue;
                _intCachedPositiveQualities = int.MinValue;
                _intCachedRedlinerBonus = int.MinValue;
                _intCachedRestrictedGear = int.MinValue;
                _intCachedTotalAcidArmorRating = int.MinValue;
                _intCachedTotalArmorRating = int.MinValue;
                _intCachedTotalColdArmorRating = int.MinValue;
                _intCachedTotalElectricityArmorRating = int.MinValue;
                _intCachedTotalFallingArmorRating = int.MinValue;
                _intCachedTotalFireArmorRating = int.MinValue;
                _intCurrentCounterspellingDice = 0;
                _intCurrentLiftCarryHits = 0;
                _decCachedBiowareEssence = decimal.MinValue;
                _decCachedCyberwareEssence = decimal.MinValue;
                ResetCachedEssence(token);
                _decCachedEssenceHole = decimal.MinValue;
                _decCachedPowerPointsUsed = decimal.MinValue;
                _decCachedPrototypeTranshumanEssenceUsed = decimal.MinValue;
                _intContactPointsUsed = 0;
                _intKarma = 0;
                _intSpecial = 0;
                _intTotalSpecial = 0;
                _intAttributes = 0;
                _intTotalAttributes = 0;
                _intEdgeUsed = 0;
                _intBoundSpiritLimit = int.MinValue;
                _intRegisteredSpriteLimit = int.MinValue;

                // Reset Metatype Information.
                _strMetatype = string.Empty;
                _strMetavariant = string.Empty;
                _strMetatypeCategory = string.Empty;
                _intMetatypeBP = 0;
                _strMovement = string.Empty;

                // Reset Special Tab Flags.
                _blnAdeptEnabled = false;
                _blnMagicianEnabled = false;
                _blnTechnomancerEnabled = false;
                _blnAdvancedProgramsEnabled = false;
                _blnCyberwareDisabled = false;
                _blnInitiationDisabled = false;
                _blnCritterEnabled = false;

                // Reset Attributes.
                AttributeSection.Reset(token: token);
                SkillsSection.Reset(token: token);
                _blnMAGEnabled = false;
                _blnRESEnabled = false;
                _blnDEPEnabled = false;
                _blnGroupMember = false;
                _strGroupName = string.Empty;
                _strGroupNotes = string.Empty;
                _intInitiateGrade = 0;
                _intSubmersionGrade = 0;

                _intMAGAdept = 0;
                _intMAGMagician = 0;

                _lstLinkedCharacters.Clear();
                _intMainMugshotIndex = -1;
                _lstMugshots.ForEach(x => x.Dispose(), token);
                _lstMugshots.Clear();
                _lstContacts.ForEach(x => x.Dispose(), token);
                _lstContacts.Clear();
                _lstSpirits.ForEach(x => x.Dispose(), token);
                _lstSpirits.Clear();
                _lstArmor.ForEach(x => x.Dispose(), token);
                _lstWeapons.ForEach(x => x.Dispose(), token);
                _lstGear.ForEach(x => x.Dispose(), token);
                _lstCyberware.ForEach(x => x.Dispose(), token);
                _lstVehicles.ForEach(x => x.Dispose(), token);
                _lstLifestyles.ForEach(x => x.Dispose(), token);
                _lstSpells.ForEach(x => x.Dispose(), token);
                _lstPowers.ForEach(x => x.Dispose(), token);
                _lstMartialArts.ForEach(x => x.Dispose(), token);
                _lstStackedFoci.ForEach(x => x.Dispose(), token);
                _lstDrugs.ForEach(x => x.Dispose(), token);
                _lstMentorSpirits.ForEach(x => x.Dispose(), token);
                // Reset all of the Lists.
                // This kills the GC
                ImprovementManager.ClearCachedValues(this, token);
                _lstImprovements.Clear();
                _lstSpells.Clear();
                _lstSustainedObjects.Clear();
                _lstFoci.Clear();
                _lstStackedFoci.Clear();
                _lstPowers.Clear();
                _lstComplexForms.Clear();
                _lstAIPrograms.Clear();
                _lstMartialArts.Clear();
                _lstLimitModifiers.Clear();
                _lstArmor.Clear();
                _lstCyberware.Clear();
                _lstMetamagics.Clear();
                _lstArts.Clear();
                _lstEnhancements.Clear();
                _lstWeapons.Clear();
                _lstLifestyles.Clear();
                _lstGear.Clear();
                _lstVehicles.Clear();
                _lstExpenseLog.Clear();
                _lstCritterPowers.Clear();
                _lstInitiationGrades.Clear();
                _lstQualities.Clear();
                _lstCalendar.Clear();
                _lstDrugs.Clear();
                _lstMentorSpirits.Clear();

                LoadAsDirty = false;
            }
        }

        /// <summary>
        /// Reset all of the Character information and start from scratch.
        /// </summary>
        public async ValueTask ResetCharacterAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                _intFreeSpells = 0;
                _intCFPLimit = 0;
                _intAINormalProgramLimit = 0;
                _intAIAdvancedProgramLimit = 0;
                _intCachedCareerKarma = int.MinValue;
                _intCachedContactPoints = int.MinValue;
                _decCachedBaseCarryLimit = decimal.MinValue;
                _decCachedBaseLiftLimit = decimal.MinValue;
                _decCachedTotalCarriedWeight = decimal.MinValue;
                _decCachedEncumbranceInterval = decimal.MinValue;
                _intCachedEnemyKarma = int.MinValue;
                _intCachedInitiationEnabled = int.MinValue;
                _intCachedMetagenicNegativeQualities = int.MinValue;
                _intCachedMetagenicPositiveQualities = int.MinValue;
                _intCachedNegativeQualities = int.MinValue;
                _intCachedNegativeQualityLimitKarma = int.MinValue;
                _intCachedPositiveQualityLimitKarma = int.MinValue;
                _intCachedPositiveQualities = int.MinValue;
                _intCachedRedlinerBonus = int.MinValue;
                _intCachedRestrictedGear = int.MinValue;
                _intCachedTotalAcidArmorRating = int.MinValue;
                _intCachedTotalArmorRating = int.MinValue;
                _intCachedTotalColdArmorRating = int.MinValue;
                _intCachedTotalElectricityArmorRating = int.MinValue;
                _intCachedTotalFallingArmorRating = int.MinValue;
                _intCachedTotalFireArmorRating = int.MinValue;
                _intCurrentCounterspellingDice = 0;
                _intCurrentLiftCarryHits = 0;
                _decCachedBiowareEssence = decimal.MinValue;
                _decCachedCyberwareEssence = decimal.MinValue;
                await ResetCachedEssenceAsync(token).ConfigureAwait(false);
                _decCachedEssenceHole = decimal.MinValue;
                _decCachedPowerPointsUsed = decimal.MinValue;
                _decCachedPrototypeTranshumanEssenceUsed = decimal.MinValue;
                _intContactPointsUsed = 0;
                _intKarma = 0;
                _intSpecial = 0;
                _intTotalSpecial = 0;
                _intAttributes = 0;
                _intTotalAttributes = 0;
                _intEdgeUsed = 0;
                _intBoundSpiritLimit = int.MinValue;
                _intRegisteredSpriteLimit = int.MinValue;

                // Reset Metatype Information.
                _strMetatype = string.Empty;
                _strMetavariant = string.Empty;
                _strMetatypeCategory = string.Empty;
                _intMetatypeBP = 0;
                _strMovement = string.Empty;

                // Reset Special Tab Flags.
                _blnAdeptEnabled = false;
                _blnMagicianEnabled = false;
                _blnTechnomancerEnabled = false;
                _blnAdvancedProgramsEnabled = false;
                _blnCyberwareDisabled = false;
                _blnInitiationDisabled = false;
                _blnCritterEnabled = false;

                // Reset Attributes.
                await AttributeSection.ResetAsync(token: token).ConfigureAwait(false);
                await SkillsSection.ResetAsync(token: token).ConfigureAwait(false);
                _blnMAGEnabled = false;
                _blnRESEnabled = false;
                _blnDEPEnabled = false;
                _blnGroupMember = false;
                _strGroupName = string.Empty;
                _strGroupNotes = string.Empty;
                _intInitiateGrade = 0;
                _intSubmersionGrade = 0;

                _intMAGAdept = 0;
                _intMAGMagician = 0;

                await _lstLinkedCharacters.ClearAsync(token).ConfigureAwait(false);
                _intMainMugshotIndex = -1;
                await _lstMugshots.ForEachAsync(x => x.Dispose(), token).ConfigureAwait(false);
                await _lstMugshots.ClearAsync(token).ConfigureAwait(false);
                await _lstContacts.ForEachAsync(x => x.DisposeAsync().AsTask(), token)
                                  .ConfigureAwait(false);
                await _lstContacts.ClearAsync(token).ConfigureAwait(false);
                await _lstSpirits.ForEachAsync(x => x.DisposeAsync().AsTask(), token)
                                 .ConfigureAwait(false);
                await _lstSpirits.ClearAsync(token).ConfigureAwait(false);
                await _lstArmor.ForEachAsync(x => x.DisposeAsync().AsTask(), token)
                               .ConfigureAwait(false);
                await _lstWeapons.ForEachAsync(x => x.DisposeAsync().AsTask(), token)
                                 .ConfigureAwait(false);
                await _lstGear.ForEachAsync(x => x.DisposeAsync().AsTask(), token)
                              .ConfigureAwait(false);
                await _lstCyberware.ForEachAsync(x => x.DisposeAsync().AsTask(), token)
                                   .ConfigureAwait(false);
                await _lstVehicles.ForEachAsync(x => x.DisposeAsync().AsTask(), token)
                                  .ConfigureAwait(false);
                await _lstLifestyles.ForEachAsync(x => x.DisposeAsync().AsTask(), token)
                                    .ConfigureAwait(false);
                await _lstSpells.ForEachAsync(x => x.Dispose(), token).ConfigureAwait(false);
                await _lstPowers.ForEachAsync(x => x.DisposeAsync().AsTask(), token)
                                .ConfigureAwait(false);
                await _lstMartialArts.ForEachAsync(x => x.DisposeAsync().AsTask(), token)
                                     .ConfigureAwait(false);
                await _lstStackedFoci.ForEachAsync(x => x.DisposeAsync().AsTask(), token)
                                     .ConfigureAwait(false);
                await _lstDrugs.ForEachAsync(x => x.DisposeAsync().AsTask(), token)
                               .ConfigureAwait(false);
                await _lstMentorSpirits.ForEachAsync(x => x.DisposeAsync().AsTask(), token)
                                       .ConfigureAwait(false);
                // Reset all of the Lists.
                // This kills the GC
                await ImprovementManager.ClearCachedValuesAsync(this, token).ConfigureAwait(false);
                await _lstImprovements.ClearAsync(token).ConfigureAwait(false);
                await _lstSpells.ClearAsync(token).ConfigureAwait(false);
                await _lstSustainedObjects.ClearAsync(token).ConfigureAwait(false);
                await _lstFoci.ClearAsync(token).ConfigureAwait(false);
                await _lstStackedFoci.ClearAsync(token).ConfigureAwait(false);
                await _lstPowers.ClearAsync(token).ConfigureAwait(false);
                await _lstComplexForms.ClearAsync(token).ConfigureAwait(false);
                await _lstAIPrograms.ClearAsync(token).ConfigureAwait(false);
                await _lstMartialArts.ClearAsync(token).ConfigureAwait(false);
                await _lstLimitModifiers.ClearAsync(token).ConfigureAwait(false);
                await _lstArmor.ClearAsync(token).ConfigureAwait(false);
                await _lstCyberware.ClearAsync(token).ConfigureAwait(false);
                await _lstMetamagics.ClearAsync(token).ConfigureAwait(false);
                await _lstArts.ClearAsync(token).ConfigureAwait(false);
                await _lstEnhancements.ClearAsync(token).ConfigureAwait(false);
                await _lstWeapons.ClearAsync(token).ConfigureAwait(false);
                await _lstLifestyles.ClearAsync(token).ConfigureAwait(false);
                await _lstGear.ClearAsync(token).ConfigureAwait(false);
                await _lstVehicles.ClearAsync(token).ConfigureAwait(false);
                await _lstExpenseLog.ClearAsync(token).ConfigureAwait(false);
                await _lstCritterPowers.ClearAsync(token).ConfigureAwait(false);
                await _lstInitiationGrades.ClearAsync(token).ConfigureAwait(false);
                await _lstQualities.ClearAsync(token).ConfigureAwait(false);
                await _lstCalendar.ClearAsync(token).ConfigureAwait(false);
                await _lstDrugs.ClearAsync(token).ConfigureAwait(false);
                await _lstMentorSpirits.ClearAsync(token).ConfigureAwait(false);
                LoadAsDirty = false;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        #endregion Initialization, Save, Load, Print, and Reset Methods

        #region Helper Methods

        /// <summary>
        /// Retrieve the name of the Object that created an Improvement.
        /// </summary>
        /// <param name="objImprovement">Improvement to check.</param>
        /// <param name="strLanguage">Language in which to fetch name.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public string GetObjectName(Improvement objImprovement, string strLanguage = "", CancellationToken token = default)
        {
            if (objImprovement == null)
                return string.Empty;
            if (string.IsNullOrEmpty(strLanguage))
                strLanguage = GlobalSettings.Language;
            string strSpace = LanguageManager.GetString("String_Space", strLanguage, token: token);
            string strImprovedSourceName = objImprovement.SourceName.TrimEndOnce("Pair");
            bool blnWireless = false;

            if (strImprovedSourceName.EndsWith("Wireless", StringComparison.Ordinal))
            {
                blnWireless = true;
                strImprovedSourceName = strImprovedSourceName.TrimEndOnce("Wireless", true);
            }

            Improvement.ImprovementSource eSource = objImprovement.ImproveSource;
            using (EnterReadLock.Enter(LockObject, token))
            {
                switch (eSource)
                {
                    case Improvement.ImprovementSource.Bioware:
                    case Improvement.ImprovementSource.Cyberware:
                    {
                        Cyberware objCyberware = Cyberware.DeepFirstOrDefault(x => x.Children,
                                                                              x => x.InternalId == strImprovedSourceName
                                                                                  && x.SourceType == eSource);
                        if (objCyberware != null)
                        {
                            string strWareReturn = objCyberware.DisplayNameShort(strLanguage);
                            if (objCyberware.Parent != null)
                                strWareReturn += strSpace + '(' + objCyberware.Parent.DisplayNameShort(strLanguage)
                                                 + ')';
                            if (blnWireless)
                                strWareReturn += strSpace + LanguageManager.GetString("String_Wireless", strLanguage, token: token);
                            return strWareReturn;
                        }

                        foreach (Vehicle objVehicle in Vehicles)
                        {
                            foreach (VehicleMod objVehicleMod in objVehicle.Mods)
                            {
                                objCyberware = objVehicleMod.Cyberware.DeepFirstOrDefault(x => x.Children,
                                    x => x.InternalId == strImprovedSourceName);
                                if (objCyberware != null)
                                {
                                    string strWareReturn
                                        = objCyberware.DisplayNameShort(strLanguage) + strSpace + '('
                                          + objVehicle.DisplayNameShort(strLanguage) + ','
                                          + strSpace + objVehicleMod.DisplayNameShort(strLanguage);
                                    if (objCyberware.Parent != null)
                                        strWareReturn += ',' + strSpace
                                                             + objCyberware.Parent.DisplayNameShort(strLanguage);
                                    strWareReturn += ')';
                                    if (blnWireless)
                                        strWareReturn
                                            += strSpace + LanguageManager.GetString("String_Wireless", strLanguage, token: token);
                                    return strWareReturn;
                                }
                            }

                            foreach (WeaponMount objMount in objVehicle.WeaponMounts)
                            {
                                foreach (VehicleMod objVehicleMod in objMount.Mods)
                                {
                                    objCyberware = objVehicleMod.Cyberware.DeepFirstOrDefault(x => x.Children,
                                        x => x.InternalId == strImprovedSourceName);
                                    if (objCyberware != null)
                                    {
                                        string strWareReturn
                                            = objCyberware.DisplayNameShort(strLanguage) + strSpace + '('
                                              + objVehicle.DisplayNameShort(strLanguage) + ',' + strSpace
                                              + objMount.DisplayNameShort(strLanguage) + ','
                                              + strSpace + objVehicleMod.DisplayNameShort(strLanguage);
                                        if (objCyberware.Parent != null)
                                            strWareReturn += ',' + strSpace
                                                                 + objCyberware.Parent.DisplayNameShort(strLanguage);
                                        strWareReturn += ')';
                                        if (blnWireless)
                                            strWareReturn += strSpace
                                                             + LanguageManager.GetString(
                                                                 "String_Wireless", strLanguage, token: token);
                                        return strWareReturn;
                                    }
                                }
                            }
                        }

                        break;
                    }
                    case Improvement.ImprovementSource.Gear:
                    {
                        Gear objReturnGear =
                            Gear.DeepFirstOrDefault(x => x.Children, x => x.InternalId == strImprovedSourceName);
                        if (objReturnGear != null)
                        {
                            string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                            if (objReturnGear.Parent is Gear parent)
                                strGearReturn += strSpace + '(' + parent.DisplayNameShort(strLanguage) + ')';
                            if (blnWireless)
                                strGearReturn += strSpace + LanguageManager.GetString("String_Wireless", strLanguage, token: token);
                            return strGearReturn;
                        }

                        objReturnGear
                            = Weapons.FindWeaponGear(strImprovedSourceName, out WeaponAccessory objGearAccessory);

                        if (objReturnGear != null)
                        {
                            string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                            if (objReturnGear.Parent is Gear parent)
                                strGearReturn += strSpace + '(' + objGearAccessory.Parent.DisplayNameShort(strLanguage)
                                                 + ','
                                                 + strSpace
                                                 + objGearAccessory.DisplayNameShort(strLanguage) + ',' + strSpace
                                                 + parent.DisplayNameShort(strLanguage) + ')';
                            else
                                strGearReturn += strSpace + '(' + objGearAccessory.Parent.DisplayNameShort(strLanguage)
                                                 + ','
                                                 + strSpace + objGearAccessory.DisplayNameShort(strLanguage) + ')';
                            if (blnWireless)
                                strGearReturn
                                    += strSpace + LanguageManager.GetString("String_Wireless", strLanguage, token: token);
                            return strGearReturn;
                        }

                        objReturnGear
                            = Armor.FindArmorGear(strImprovedSourceName, out Armor objArmor, out ArmorMod objArmorMod);
                        if (objReturnGear != null)
                        {
                            string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                            if (objReturnGear.Parent is Gear objParent)
                            {
                                strGearReturn += strSpace + '(' + objArmor.DisplayNameShort(strLanguage, token) + ','
                                                 + strSpace
                                                 + objArmorMod.DisplayNameShort(strLanguage) + ',' + strSpace
                                                 + objParent.DisplayNameShort(strLanguage) + ')';
                            }
                            else if (objArmorMod != null)
                                strGearReturn += strSpace + '(' + objArmor.DisplayNameShort(strLanguage, token) + ','
                                                 + strSpace
                                                 + objArmorMod.DisplayNameShort(strLanguage) + ')';
                            else
                                strGearReturn += strSpace + '(' + objArmor.DisplayNameShort(strLanguage, token) + ')';

                            if (blnWireless)
                                strGearReturn += strSpace + LanguageManager.GetString("String_Wireless", strLanguage, token: token);
                            return strGearReturn;
                        }

                        objReturnGear
                            = Cyberware.FindCyberwareGear(strImprovedSourceName, out Cyberware objGearCyberware);

                        if (objReturnGear != null)
                        {
                            string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                            if (objReturnGear.Parent is Gear parent)
                                strGearReturn += strSpace + '(' + objGearCyberware.DisplayNameShort(strLanguage) + ','
                                                 + strSpace
                                                 + strSpace + parent.DisplayNameShort(strLanguage) + ')';
                            else
                                strGearReturn += strSpace + '(' + objGearCyberware.DisplayNameShort(strLanguage) + ')';
                            if (blnWireless)
                                strGearReturn += strSpace + LanguageManager.GetString("String_Wireless", strLanguage, token: token);
                            return strGearReturn;
                        }

                        foreach (Vehicle objVehicle in Vehicles)
                        {
                            objReturnGear = objVehicle.GearChildren.DeepFirstOrDefault(x => x.Children,
                                x => x.InternalId == strImprovedSourceName);
                            if (objReturnGear != null)
                            {
                                string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                                if (objReturnGear.Parent is Gear parent)
                                    strGearReturn += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ','
                                                     + strSpace
                                                     + strSpace + parent.DisplayNameShort(strLanguage) + ')';
                                else
                                    strGearReturn += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ')';
                                if (blnWireless)
                                    strGearReturn
                                        += strSpace + LanguageManager.GetString("String_Wireless", strLanguage, token: token);
                                return strGearReturn;
                            }

                            foreach (Weapon objWeapon in objVehicle.Weapons.DeepWhere(x => x.Children,
                                         x => x.WeaponAccessories.Any(y => y.GearChildren.Count > 0)))
                            {
                                foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                                {
                                    objReturnGear = objAccessory.GearChildren.DeepFirstOrDefault(x => x.Children,
                                        x => x.InternalId == strImprovedSourceName);
                                    if (objReturnGear != null)
                                    {
                                        string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                                        if (objReturnGear.Parent is Gear parent)
                                            strGearReturn
                                                += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ','
                                                   + strSpace
                                                   + objWeapon.DisplayNameShort(strLanguage) + ',' + strSpace
                                                   + objAccessory.DisplayNameShort(strLanguage) + ','
                                                   + strSpace + parent.DisplayNameShort(strLanguage) + ')';
                                        else
                                            strGearReturn
                                                += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ','
                                                   + strSpace
                                                   + objWeapon.DisplayNameShort(strLanguage) + ',' + strSpace
                                                   + objAccessory.DisplayNameShort(strLanguage) + ')';
                                        if (blnWireless)
                                            strGearReturn += strSpace
                                                             + LanguageManager.GetString(
                                                                 "String_Wireless", strLanguage, token: token);
                                        return strGearReturn;
                                    }
                                }
                            }

                            foreach (VehicleMod objVehicleMod in objVehicle.Mods)
                            {
                                foreach (Weapon objWeapon in objVehicleMod.Weapons.DeepWhere(x => x.Children,
                                             x => x.WeaponAccessories.Any(y => y.GearChildren.Count > 0)))
                                {
                                    foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                                    {
                                        objReturnGear = objAccessory.GearChildren.DeepFirstOrDefault(x => x.Children,
                                            x => x.InternalId == strImprovedSourceName);
                                        if (objReturnGear != null)
                                        {
                                            string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                                            if (objReturnGear.Parent is Gear parent)
                                                strGearReturn
                                                    += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ','
                                                       + strSpace + objVehicleMod.DisplayNameShort(strLanguage)
                                                       + ',' + strSpace + objWeapon.DisplayNameShort(strLanguage) + ','
                                                       + strSpace + objAccessory.DisplayNameShort(strLanguage)
                                                       + ',' + strSpace + parent.DisplayNameShort(strLanguage) + ')';
                                            else
                                                strGearReturn
                                                    += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ','
                                                       + strSpace + objVehicleMod.DisplayNameShort(strLanguage)
                                                       + ',' + strSpace + objWeapon.DisplayNameShort(strLanguage) + ','
                                                       + strSpace + objAccessory.DisplayNameShort(strLanguage) + ')';
                                            if (blnWireless)
                                                strGearReturn += strSpace
                                                                 + LanguageManager.GetString(
                                                                     "String_Wireless", strLanguage, token: token);
                                            return strGearReturn;
                                        }
                                    }
                                }

                                foreach (Cyberware objCyberware in objVehicleMod.Cyberware.DeepWhere(x => x.Children,
                                             x => x.GearChildren.Count > 0))
                                {
                                    objReturnGear = objCyberware.GearChildren.DeepFirstOrDefault(x => x.Children,
                                        x => x.InternalId == strImprovedSourceName);
                                    if (objReturnGear != null)
                                    {
                                        string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                                        if (objReturnGear.Parent is Gear parent)
                                            strGearReturn
                                                += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ','
                                                   + strSpace + objVehicleMod.DisplayNameShort(strLanguage)
                                                   + ',' + strSpace + objCyberware.DisplayNameShort(strLanguage) + ','
                                                   + strSpace + parent.DisplayNameShort(strLanguage) + ')';
                                        else
                                            strGearReturn
                                                += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ','
                                                   + strSpace + objVehicleMod.DisplayNameShort(strLanguage)
                                                   + ',' + strSpace + objCyberware.DisplayNameShort(strLanguage) + ')';
                                        if (blnWireless)
                                            strGearReturn += strSpace
                                                             + LanguageManager.GetString(
                                                                 "String_Wireless", strLanguage, token: token);
                                        return strGearReturn;
                                    }
                                }
                            }

                            foreach (WeaponMount objMount in objVehicle.WeaponMounts)
                            {
                                foreach (VehicleMod objVehicleMod in objMount.Mods)
                                {
                                    foreach (Weapon objWeapon in objVehicleMod.Weapons.DeepWhere(x => x.Children,
                                                 x => x.WeaponAccessories.Any(y => y.GearChildren.Count > 0)))
                                    {
                                        foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                                        {
                                            objReturnGear = objAccessory.GearChildren.DeepFirstOrDefault(
                                                x => x.Children,
                                                x => x.InternalId == strImprovedSourceName);
                                            if (objReturnGear != null)
                                            {
                                                string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                                                if (objReturnGear.Parent is Gear parent)
                                                    strGearReturn
                                                        += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage)
                                                           + ','
                                                           + strSpace + objMount.DisplayNameShort(strLanguage) + ','
                                                           + strSpace + objVehicleMod.DisplayNameShort(strLanguage)
                                                           + ',' + strSpace + objWeapon.DisplayNameShort(strLanguage)
                                                           + ','
                                                           + strSpace + objAccessory.DisplayNameShort(strLanguage)
                                                           + ',' + strSpace + parent.DisplayNameShort(strLanguage)
                                                           + ')';
                                                else
                                                    strGearReturn
                                                        += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage)
                                                           + ','
                                                           + strSpace + objMount.DisplayNameShort(strLanguage) + ','
                                                           + strSpace + objVehicleMod.DisplayNameShort(strLanguage)
                                                           + ',' + strSpace + objWeapon.DisplayNameShort(strLanguage)
                                                           + ','
                                                           + strSpace + objAccessory.DisplayNameShort(strLanguage)
                                                           + ')';
                                                if (blnWireless)
                                                    strGearReturn += strSpace
                                                                     + LanguageManager.GetString(
                                                                         "String_Wireless", strLanguage, token: token);
                                                return strGearReturn;
                                            }
                                        }
                                    }

                                    foreach (Cyberware objCyberware in objVehicleMod.Cyberware.DeepWhere(
                                                 x => x.Children,
                                                 x => x.GearChildren.Count > 0))
                                    {
                                        objReturnGear = objCyberware.GearChildren.DeepFirstOrDefault(x => x.Children,
                                            x => x.InternalId == strImprovedSourceName);
                                        if (objReturnGear != null)
                                        {
                                            string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                                            if (objReturnGear.Parent is Gear parent)
                                                strGearReturn
                                                    += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ','
                                                       + strSpace + objMount.DisplayNameShort(strLanguage) + ','
                                                       + strSpace
                                                       + objVehicleMod.DisplayNameShort(strLanguage)
                                                       + ',' + strSpace + objCyberware.DisplayNameShort(strLanguage)
                                                       + ','
                                                       + strSpace + parent.DisplayNameShort(strLanguage) + ')';
                                            else
                                                strGearReturn
                                                    += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ','
                                                       + strSpace + objMount.DisplayNameShort(strLanguage) + ','
                                                       + strSpace
                                                       + objVehicleMod.DisplayNameShort(strLanguage)
                                                       + ',' + strSpace + objCyberware.DisplayNameShort(strLanguage)
                                                       + ')';
                                            if (blnWireless)
                                                strGearReturn += strSpace
                                                                 + LanguageManager.GetString(
                                                                     "String_Wireless", strLanguage, token: token);
                                            return strGearReturn;
                                        }
                                    }
                                }
                            }
                        }

                        break;
                    }
                    case Improvement.ImprovementSource.Spell:
                        foreach (Spell objSpell in Spells)
                        {
                            if (objSpell.InternalId == strImprovedSourceName)
                            {
                                return objSpell.DisplayNameShort(strLanguage);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.Power:
                        foreach (Power objPower in Powers)
                        {
                            if (objPower.InternalId == strImprovedSourceName)
                            {
                                return objPower.DisplayNameShort(strLanguage);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.CritterPower:
                        foreach (CritterPower objPower in CritterPowers)
                        {
                            if (objPower.InternalId == strImprovedSourceName)
                            {
                                return objPower.DisplayNameShort(strLanguage);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.Metamagic:
                        foreach (Metamagic objMetamagic in Metamagics)
                        {
                            if (objMetamagic.InternalId == strImprovedSourceName
                                && objMetamagic.SourceType == Improvement.ImprovementSource.Metamagic)
                            {
                                return objMetamagic.DisplayNameShort(strLanguage);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.Echo:
                        foreach (Metamagic objMetamagic in Metamagics)
                        {
                            if (objMetamagic.InternalId == strImprovedSourceName
                                && objMetamagic.SourceType == Improvement.ImprovementSource.Echo)
                            {
                                return objMetamagic.DisplayNameShort(strLanguage);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.Art:
                        foreach (Art objArt in Arts)
                        {
                            if (objArt.InternalId == strImprovedSourceName)
                            {
                                return objArt.DisplayNameShort(strLanguage);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.Enhancement:
                        foreach (Enhancement objEnhancement in Enhancements)
                        {
                            if (objEnhancement.InternalId == strImprovedSourceName)
                            {
                                return objEnhancement.DisplayNameShort(strLanguage);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.Armor:
                    {
                        foreach (Armor objArmor in Armor)
                        {
                            if (objArmor.InternalId == strImprovedSourceName)
                            {
                                string strReturnArmor = objArmor.DisplayNameShort(strLanguage, token);
                                if (blnWireless)
                                    strReturnArmor
                                        += strSpace + LanguageManager.GetString("String_Wireless", strLanguage, token: token);
                                return strReturnArmor;
                            }
                        }

                        break;
                    }
                    case Improvement.ImprovementSource.ArmorMod:
                    {
                        foreach (Armor objArmor in Armor)
                        {
                            foreach (ArmorMod objMod in objArmor.ArmorMods)
                            {
                                if (objMod.InternalId == strImprovedSourceName)
                                {
                                    string strReturnArmorMod = objMod.DisplayNameShort(strLanguage) + strSpace + '('
                                                               + objArmor.DisplayNameShort(strLanguage, token) + ')';
                                    if (blnWireless)
                                        strReturnArmorMod
                                            += strSpace + LanguageManager.GetString("String_Wireless", strLanguage, token: token);
                                    return strReturnArmorMod;
                                }
                            }
                        }

                        break;
                    }
                    case Improvement.ImprovementSource.ComplexForm:
                        foreach (ComplexForm objComplexForm in ComplexForms)
                        {
                            if (objComplexForm.InternalId == strImprovedSourceName)
                            {
                                return objComplexForm.DisplayNameShort(strLanguage);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.AIProgram:
                        foreach (AIProgram objProgram in AIPrograms)
                        {
                            if (objProgram.InternalId == strImprovedSourceName)
                            {
                                return objProgram.DisplayNameShort(strLanguage);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.Quality:
                    {
                        if (strImprovedSourceName.StartsWith("SEEKER", StringComparison.Ordinal))
                        {
                            string strReturn = string.Empty;
                            if (GlobalSettings.Language != GlobalSettings.DefaultLanguage)
                            {
                                strReturn = LoadDataXPath("qualities.xml", token: token)
                                            .SelectSingleNodeAndCacheExpression(
                                                strImprovedSourceName == "SEEKER_WIL"
                                                    ? "/chummer/qualities/quality[name = \"Cyber-Singularity Seeker\"]/translate"
                                                    : "/chummer/qualities/quality[name = \"Redliner\"]/translate")
                                            ?.Value;
                            }

                            if (string.IsNullOrEmpty(strReturn))
                                strReturn = strImprovedSourceName == "SEEKER_WIL"
                                    ? "Cyber-Singularity Seeker"
                                    : "Redliner";
                            return strReturn;
                        }

                        foreach (Quality objQuality in Qualities)
                        {
                            if (objQuality.InternalId == strImprovedSourceName)
                            {
                                return objQuality.DisplayNameShort(strLanguage);
                            }
                        }

                        break;
                    }

                    case Improvement.ImprovementSource.MartialArtTechnique:
                        foreach (MartialArtTechnique objTechnique in MartialArts.SelectMany(x => x.Techniques))
                        {
                            if (objTechnique.InternalId == strImprovedSourceName)
                            {
                                return objTechnique.DisplayName(strLanguage);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.MentorSpirit:
                        foreach (MentorSpirit objMentorSpirit in MentorSpirits)
                        {
                            if (objMentorSpirit.InternalId == strImprovedSourceName)
                            {
                                return objMentorSpirit.DisplayNameShort(strLanguage);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.Heritage:
                        return LanguageManager.GetString("String_Priority", strLanguage, token: token);

                    case Improvement.ImprovementSource.Initiation:
                        return LanguageManager.GetString("Tab_Initiation", strLanguage, token: token);

                    case Improvement.ImprovementSource.Submersion:
                        return LanguageManager.GetString("Tab_Submersion", strLanguage, token: token);

                    case Improvement.ImprovementSource.Encumbrance:
                        return LanguageManager.GetString("String_Encumbrance", strLanguage, token: token);

                    case Improvement.ImprovementSource.ArmorEncumbrance:
                        return LanguageManager.GetString("String_ArmorEncumbrance", strLanguage, token: token);

                    case Improvement.ImprovementSource.Tradition:
                        return LanguageManager.GetString("String_Tradition", strLanguage, token: token);

                    case Improvement.ImprovementSource.AstralReputation:
                        return LanguageManager.GetString("String_AstralReputation", strLanguage, token: token);

                    case Improvement.ImprovementSource.CyberadeptDaemon:
                        return LoadDataXPath("qualities.xml", strLanguage, token: token)
                               .SelectSingleNode(
                                   "/chummer/qualities/quality[name = \"Resonant Stream: Cyberadept\"]/translate")
                               ?.Value ?? "Resonant Stream: Cyberadept";

                    default:
                    {
                        if (objImprovement.ImproveType == Improvement.ImprovementType.ArmorEncumbrancePenalty)
                            return LanguageManager.GetString("String_ArmorEncumbrance", strLanguage, token: token);
                        // If this comes from a custom Improvement, use the name the player gave it instead of showing a GUID.
                        if (!string.IsNullOrEmpty(objImprovement.CustomName))
                            return objImprovement.CustomName;
                        string strReturn = strImprovedSourceName;
                        if (string.IsNullOrEmpty(strReturn) || strReturn.IsGuid())
                        {
                            string strTemp = LanguageManager.GetString("String_" + objImprovement.ImproveSource,
                                                                       strLanguage, false, token: token);
                            if (!string.IsNullOrEmpty(strTemp))
                                strReturn = strTemp;
                        }

                        return strReturn;
                    }
                }
            }

            return string.Empty;
        }

        /// <summary>
        /// Retrieve the name of the Object that created an Improvement.
        /// </summary>
        /// <param name="objImprovement">Improvement to check.</param>
        /// <param name="strLanguage">Language in which to fetch name.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public async Task<string> GetObjectNameAsync(Improvement objImprovement, string strLanguage = "", CancellationToken token = default)
        {
            if (objImprovement == null)
                return string.Empty;
            if (string.IsNullOrEmpty(strLanguage))
                strLanguage = GlobalSettings.Language;
            string strSpace = await LanguageManager.GetStringAsync("String_Space", strLanguage, token: token).ConfigureAwait(false);
            string strImprovedSourceName = objImprovement.SourceName.TrimEndOnce("Pair");
            bool blnWireless = false;

            if (strImprovedSourceName.EndsWith("Wireless", StringComparison.Ordinal))
            {
                blnWireless = true;
                strImprovedSourceName = strImprovedSourceName.TrimEndOnce("Wireless", true);
            }

            Improvement.ImprovementSource eSource = objImprovement.ImproveSource;
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                switch (eSource)
                {
                    case Improvement.ImprovementSource.Bioware:
                    case Improvement.ImprovementSource.Cyberware:
                        {
                            Cyberware objCyberware = Cyberware.DeepFirstOrDefault(x => x.Children,
                                                                                  x => x.InternalId == strImprovedSourceName
                                                                                      && x.SourceType == eSource);
                            if (objCyberware != null)
                            {
                                string strWareReturn = await objCyberware.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false);
                                if (objCyberware.Parent != null)
                                    strWareReturn += strSpace + '(' + await objCyberware.Parent.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false)
                                                     + ')';
                                if (blnWireless)
                                    strWareReturn += strSpace + await LanguageManager.GetStringAsync("String_Wireless", strLanguage, token: token).ConfigureAwait(false);
                                return strWareReturn;
                            }

                            foreach (Vehicle objVehicle in Vehicles)
                            {
                                foreach (VehicleMod objVehicleMod in objVehicle.Mods)
                                {
                                    objCyberware = objVehicleMod.Cyberware.DeepFirstOrDefault(x => x.Children,
                                        x => x.InternalId == strImprovedSourceName);
                                    if (objCyberware != null)
                                    {
                                        string strWareReturn
                                            = await objCyberware.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + strSpace + '('
                                              + await objVehicle.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ','
                                              + strSpace + await objVehicleMod.DisplayNameShortAsync(strLanguage, token: token).ConfigureAwait(false);
                                        if (objCyberware.Parent != null)
                                            strWareReturn += ',' + strSpace
                                                                 + await objCyberware.Parent.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false);
                                        strWareReturn += ')';
                                        if (blnWireless)
                                            strWareReturn
                                                += strSpace + await LanguageManager.GetStringAsync("String_Wireless", strLanguage, token: token).ConfigureAwait(false);
                                        return strWareReturn;
                                    }
                                }

                                foreach (WeaponMount objMount in objVehicle.WeaponMounts)
                                {
                                    foreach (VehicleMod objVehicleMod in objMount.Mods)
                                    {
                                        objCyberware = objVehicleMod.Cyberware.DeepFirstOrDefault(x => x.Children,
                                            x => x.InternalId == strImprovedSourceName);
                                        if (objCyberware != null)
                                        {
                                            string strWareReturn
                                                = await objCyberware.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + strSpace + '('
                                                  + await objVehicle.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ',' + strSpace
                                                  + await objMount.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ','
                                                  + strSpace + await objVehicleMod.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false);
                                            if (objCyberware.Parent != null)
                                                strWareReturn += ',' + strSpace
                                                                     + await objCyberware.Parent.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false);
                                            strWareReturn += ')';
                                            if (blnWireless)
                                                strWareReturn += strSpace
                                                                 + await LanguageManager.GetStringAsync(
                                                                     "String_Wireless", strLanguage, token: token).ConfigureAwait(false);
                                            return strWareReturn;
                                        }
                                    }
                                }
                            }

                            break;
                        }
                    case Improvement.ImprovementSource.Gear:
                        {
                            Gear objReturnGear =
                                Gear.DeepFirstOrDefault(x => x.Children, x => x.InternalId == strImprovedSourceName);
                            if (objReturnGear != null)
                            {
                                string strGearReturn = await objReturnGear.DisplayNameShortAsync(strLanguage, token: token).ConfigureAwait(false);
                                if (objReturnGear.Parent is Gear parent)
                                    strGearReturn += strSpace + '(' + await parent.DisplayNameShortAsync(strLanguage, token: token).ConfigureAwait(false) + ')';
                                if (blnWireless)
                                    strGearReturn += strSpace + await LanguageManager.GetStringAsync("String_Wireless", strLanguage, token: token).ConfigureAwait(false);
                                return strGearReturn;
                            }

                            objReturnGear
                                = Weapons.FindWeaponGear(strImprovedSourceName, out WeaponAccessory objGearAccessory);

                            if (objReturnGear != null)
                            {
                                string strGearReturn = await objReturnGear.DisplayNameShortAsync(strLanguage, token: token).ConfigureAwait(false);
                                if (objReturnGear.Parent is Gear parent)
                                    strGearReturn += strSpace + '(' + await objGearAccessory.Parent.DisplayNameShortAsync(strLanguage, token: token).ConfigureAwait(false)
                                                     + ','
                                                     + strSpace
                                                     + await objGearAccessory.DisplayNameShortAsync(strLanguage, token: token).ConfigureAwait(false) + ',' + strSpace
                                                     + await parent.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ')';
                                else
                                    strGearReturn += strSpace + '(' + await objGearAccessory.Parent.DisplayNameShortAsync(strLanguage, token: token).ConfigureAwait(false)
                                                     + ','
                                                     + strSpace + await objGearAccessory.DisplayNameShortAsync(strLanguage, token: token).ConfigureAwait(false) + ')';
                                if (blnWireless)
                                    strGearReturn
                                        += strSpace + await LanguageManager.GetStringAsync("String_Wireless", strLanguage, token: token).ConfigureAwait(false);
                                return strGearReturn;
                            }

                            objReturnGear
                                = Armor.FindArmorGear(strImprovedSourceName, out Armor objArmor, out ArmorMod objArmorMod);
                            if (objReturnGear != null)
                            {
                                string strGearReturn = await objReturnGear.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false);
                                if (objReturnGear.Parent is Gear objParent)
                                {
                                    strGearReturn += strSpace + '(' + await objArmor.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ','
                                                     + strSpace
                                                     + await objArmorMod.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ',' + strSpace
                                                     + await objParent.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ')';
                                }
                                else if (objArmorMod != null)
                                    strGearReturn += strSpace + '(' + await objArmor.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ','
                                                     + strSpace
                                                     + await objArmorMod.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ')';
                                else
                                    strGearReturn += strSpace + '(' + await objArmor.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ')';

                                if (blnWireless)
                                    strGearReturn += strSpace + await LanguageManager.GetStringAsync("String_Wireless", strLanguage, token: token).ConfigureAwait(false);
                                return strGearReturn;
                            }

                            objReturnGear
                                = Cyberware.FindCyberwareGear(strImprovedSourceName, out Cyberware objGearCyberware);

                            if (objReturnGear != null)
                            {
                                string strGearReturn = await objReturnGear.DisplayNameShortAsync(strLanguage, token: token).ConfigureAwait(false);
                                if (objReturnGear.Parent is Gear parent)
                                    strGearReturn += strSpace + '(' + await objGearCyberware.DisplayNameShortAsync(strLanguage, token: token).ConfigureAwait(false) + ','
                                                     + strSpace
                                                     + strSpace + await parent.DisplayNameShortAsync(strLanguage, token: token).ConfigureAwait(false) + ')';
                                else
                                    strGearReturn += strSpace + '(' + await objGearCyberware.DisplayNameShortAsync(strLanguage, token: token).ConfigureAwait(false) + ')';
                                if (blnWireless)
                                    strGearReturn += strSpace + await LanguageManager.GetStringAsync("String_Wireless", strLanguage, token: token).ConfigureAwait(false);
                                return strGearReturn;
                            }

                            foreach (Vehicle objVehicle in Vehicles)
                            {
                                objReturnGear = objVehicle.GearChildren.DeepFirstOrDefault(x => x.Children,
                                    x => x.InternalId == strImprovedSourceName);
                                if (objReturnGear != null)
                                {
                                    string strGearReturn = await objReturnGear.DisplayNameShortAsync(strLanguage, token: token).ConfigureAwait(false);
                                    if (objReturnGear.Parent is Gear parent)
                                        strGearReturn += strSpace + '(' + await objVehicle.DisplayNameShortAsync(strLanguage, token: token).ConfigureAwait(false) + ','
                                                         + strSpace
                                                         + strSpace + await parent.DisplayNameShortAsync(strLanguage, token: token).ConfigureAwait(false) + ')';
                                    else
                                        strGearReturn += strSpace + '(' + await objVehicle.DisplayNameShortAsync(strLanguage, token: token).ConfigureAwait(false) + ')';
                                    if (blnWireless)
                                        strGearReturn
                                            += strSpace + await LanguageManager.GetStringAsync("String_Wireless", strLanguage, token: token).ConfigureAwait(false);
                                    return strGearReturn;
                                }

                                foreach (Weapon objWeapon in objVehicle.Weapons.DeepWhere(x => x.Children,
                                             x => x.WeaponAccessories.Any(y => y.GearChildren.Count > 0)))
                                {
                                    foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                                    {
                                        objReturnGear = objAccessory.GearChildren.DeepFirstOrDefault(x => x.Children,
                                            x => x.InternalId == strImprovedSourceName);
                                        if (objReturnGear != null)
                                        {
                                            string strGearReturn = await objReturnGear.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false);
                                            if (objReturnGear.Parent is Gear parent)
                                                strGearReturn
                                                    += strSpace + '(' + await objVehicle.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ','
                                                       + strSpace
                                                       + await objWeapon.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ',' + strSpace
                                                       + await objAccessory.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ','
                                                       + strSpace + await parent.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ')';
                                            else
                                                strGearReturn
                                                    += strSpace + '(' + await objVehicle.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ','
                                                       + strSpace
                                                       + await objWeapon.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ',' + strSpace
                                                       + await objAccessory.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ')';
                                            if (blnWireless)
                                                strGearReturn += strSpace
                                                                 + await LanguageManager.GetStringAsync(
                                                                     "String_Wireless", strLanguage, token: token).ConfigureAwait(false);
                                            return strGearReturn;
                                        }
                                    }
                                }

                                foreach (VehicleMod objVehicleMod in objVehicle.Mods)
                                {
                                    foreach (Weapon objWeapon in objVehicleMod.Weapons.DeepWhere(x => x.Children,
                                                 x => x.WeaponAccessories.Any(y => y.GearChildren.Count > 0)))
                                    {
                                        foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                                        {
                                            objReturnGear = objAccessory.GearChildren.DeepFirstOrDefault(x => x.Children,
                                                x => x.InternalId == strImprovedSourceName);
                                            if (objReturnGear != null)
                                            {
                                                string strGearReturn = await objReturnGear.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false);
                                                if (objReturnGear.Parent is Gear parent)
                                                    strGearReturn
                                                        += strSpace + '(' + await objVehicle.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ','
                                                           + strSpace + await objVehicleMod.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false)
                                                           + ',' + strSpace + await objWeapon.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ','
                                                           + strSpace + await objAccessory.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false)
                                                           + ',' + strSpace + await parent.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ')';
                                                else
                                                    strGearReturn
                                                        += strSpace + '(' + await objVehicle.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ','
                                                           + strSpace + await objVehicleMod.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false)
                                                           + ',' + strSpace + await objWeapon.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ','
                                                           + strSpace + await objAccessory.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ')';
                                                if (blnWireless)
                                                    strGearReturn += strSpace
                                                                     + await LanguageManager.GetStringAsync(
                                                                         "String_Wireless", strLanguage, token: token).ConfigureAwait(false);
                                                return strGearReturn;
                                            }
                                        }
                                    }

                                    foreach (Cyberware objCyberware in objVehicleMod.Cyberware.DeepWhere(x => x.Children,
                                                 x => x.GearChildren.Count > 0))
                                    {
                                        objReturnGear = objCyberware.GearChildren.DeepFirstOrDefault(x => x.Children,
                                            x => x.InternalId == strImprovedSourceName);
                                        if (objReturnGear != null)
                                        {
                                            string strGearReturn = await objReturnGear.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false);
                                            if (objReturnGear.Parent is Gear parent)
                                                strGearReturn
                                                    += strSpace + '(' + await objVehicle.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ','
                                                       + strSpace + await objVehicleMod.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false)
                                                       + ',' + strSpace + await objCyberware.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ','
                                                       + strSpace + await parent.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ')';
                                            else
                                                strGearReturn
                                                    += strSpace + '(' + await objVehicle.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ','
                                                       + strSpace + await objVehicleMod.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false)
                                                       + ',' + strSpace + await objCyberware.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ')';
                                            if (blnWireless)
                                                strGearReturn += strSpace
                                                                 + await LanguageManager.GetStringAsync(
                                                                     "String_Wireless", strLanguage, token: token).ConfigureAwait(false);
                                            return strGearReturn;
                                        }
                                    }
                                }

                                foreach (WeaponMount objMount in objVehicle.WeaponMounts)
                                {
                                    foreach (VehicleMod objVehicleMod in objMount.Mods)
                                    {
                                        foreach (Weapon objWeapon in objVehicleMod.Weapons.DeepWhere(x => x.Children,
                                                     x => x.WeaponAccessories.Any(y => y.GearChildren.Count > 0)))
                                        {
                                            foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                                            {
                                                objReturnGear = objAccessory.GearChildren.DeepFirstOrDefault(
                                                    x => x.Children,
                                                    x => x.InternalId == strImprovedSourceName);
                                                if (objReturnGear != null)
                                                {
                                                    string strGearReturn = await objReturnGear.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false);
                                                    if (objReturnGear.Parent is Gear parent)
                                                        strGearReturn
                                                            += strSpace + '(' + await objVehicle.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false)
                                                               + ','
                                                               + strSpace + await objMount.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ','
                                                               + strSpace + await objVehicleMod.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false)
                                                               + ',' + strSpace + await objWeapon.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false)
                                                               + ','
                                                               + strSpace + await objAccessory.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false)
                                                               + ',' + strSpace + await parent.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false)
                                                               + ')';
                                                    else
                                                        strGearReturn
                                                            += strSpace + '(' + await objVehicle.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false)
                                                               + ','
                                                               + strSpace + await objMount.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ','
                                                               + strSpace + await objVehicleMod.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false)
                                                               + ',' + strSpace + await objWeapon.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false)
                                                               + ','
                                                               + strSpace + await objAccessory.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false)
                                                               + ')';
                                                    if (blnWireless)
                                                        strGearReturn += strSpace
                                                                         + await LanguageManager.GetStringAsync(
                                                                             "String_Wireless", strLanguage, token: token).ConfigureAwait(false);
                                                    return strGearReturn;
                                                }
                                            }
                                        }

                                        foreach (Cyberware objCyberware in objVehicleMod.Cyberware.DeepWhere(
                                                     x => x.Children,
                                                     x => x.GearChildren.Count > 0))
                                        {
                                            objReturnGear = objCyberware.GearChildren.DeepFirstOrDefault(x => x.Children,
                                                x => x.InternalId == strImprovedSourceName);
                                            if (objReturnGear != null)
                                            {
                                                string strGearReturn = await objReturnGear.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false);
                                                if (objReturnGear.Parent is Gear parent)
                                                    strGearReturn
                                                        += strSpace + '(' + await objVehicle.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ','
                                                           + strSpace + await objMount.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ','
                                                           + strSpace
                                                           + await objVehicleMod.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false)
                                                           + ',' + strSpace + await objCyberware.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false)
                                                           + ','
                                                           + strSpace + await parent.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ')';
                                                else
                                                    strGearReturn
                                                        += strSpace + '(' + await objVehicle.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ','
                                                           + strSpace + await objMount.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ','
                                                           + strSpace
                                                           + await objVehicleMod.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false)
                                                           + ',' + strSpace + await objCyberware.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false)
                                                           + ')';
                                                if (blnWireless)
                                                    strGearReturn += strSpace
                                                                     + await LanguageManager.GetStringAsync(
                                                                         "String_Wireless", strLanguage, token: token).ConfigureAwait(false);
                                                return strGearReturn;
                                            }
                                        }
                                    }
                                }
                            }

                            break;
                        }
                    case Improvement.ImprovementSource.Spell:
                        foreach (Spell objSpell in Spells)
                        {
                            if (objSpell.InternalId == strImprovedSourceName)
                            {
                                return await objSpell.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.Power:
                        foreach (Power objPower in Powers)
                        {
                            if (objPower.InternalId == strImprovedSourceName)
                            {
                                return await objPower.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.CritterPower:
                        foreach (CritterPower objPower in CritterPowers)
                        {
                            if (objPower.InternalId == strImprovedSourceName)
                            {
                                return await objPower.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.Metamagic:
                        foreach (Metamagic objMetamagic in Metamagics)
                        {
                            if (objMetamagic.InternalId == strImprovedSourceName
                                && objMetamagic.SourceType == Improvement.ImprovementSource.Metamagic)
                            {
                                return await objMetamagic.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.Echo:
                        foreach (Metamagic objMetamagic in Metamagics)
                        {
                            if (objMetamagic.InternalId == strImprovedSourceName
                                && objMetamagic.SourceType == Improvement.ImprovementSource.Echo)
                            {
                                return await objMetamagic.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.Art:
                        foreach (Art objArt in Arts)
                        {
                            if (objArt.InternalId == strImprovedSourceName)
                            {
                                return await objArt.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.Enhancement:
                        foreach (Enhancement objEnhancement in Enhancements)
                        {
                            if (objEnhancement.InternalId == strImprovedSourceName)
                            {
                                return await objEnhancement.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.Armor:
                        {
                            foreach (Armor objArmor in Armor)
                            {
                                if (objArmor.InternalId == strImprovedSourceName)
                                {
                                    string strReturnArmor = await objArmor.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false);
                                    if (blnWireless)
                                        strReturnArmor
                                            += strSpace + await LanguageManager.GetStringAsync("String_Wireless", strLanguage, token: token).ConfigureAwait(false);
                                    return strReturnArmor;
                                }
                            }

                            break;
                        }
                    case Improvement.ImprovementSource.ArmorMod:
                        {
                            foreach (Armor objArmor in Armor)
                            {
                                foreach (ArmorMod objMod in objArmor.ArmorMods)
                                {
                                    if (objMod.InternalId == strImprovedSourceName)
                                    {
                                        string strReturnArmorMod = await objMod.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + strSpace + '('
                                                                   + await objArmor.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false) + ')';
                                        if (blnWireless)
                                            strReturnArmorMod
                                                += strSpace + await LanguageManager.GetStringAsync("String_Wireless", strLanguage, token: token).ConfigureAwait(false);
                                        return strReturnArmorMod;
                                    }
                                }
                            }

                            break;
                        }
                    case Improvement.ImprovementSource.ComplexForm:
                        foreach (ComplexForm objComplexForm in ComplexForms)
                        {
                            if (objComplexForm.InternalId == strImprovedSourceName)
                            {
                                return await objComplexForm.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.AIProgram:
                        foreach (AIProgram objProgram in AIPrograms)
                        {
                            if (objProgram.InternalId == strImprovedSourceName)
                            {
                                return await objProgram.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.Quality:
                    {
                        if (strImprovedSourceName.StartsWith("SEEKER", StringComparison.Ordinal))
                        {
                            string strReturn = string.Empty;
                            if (GlobalSettings.Language != GlobalSettings.DefaultLanguage)
                            {
                                strReturn = (await (await LoadDataXPathAsync("qualities.xml", token: token)
                                                       .ConfigureAwait(false))
                                                   .SelectSingleNodeAndCacheExpressionAsync(
                                                       strImprovedSourceName == "SEEKER_WIL"
                                                           ? "/chummer/qualities/quality[name = \"Cyber-Singularity Seeker\"]/translate"
                                                           : "/chummer/qualities/quality[name = \"Redliner\"]/translate",
                                                       token).ConfigureAwait(false))
                                    ?.Value;
                            }

                            if (string.IsNullOrEmpty(strReturn))
                                strReturn = strImprovedSourceName == "SEEKER_WIL"
                                    ? "Cyber-Singularity Seeker"
                                    : "Redliner";
                            return strReturn;
                        }

                        foreach (Quality objQuality in Qualities)
                        {
                            if (objQuality.InternalId == strImprovedSourceName)
                            {
                                return await objQuality.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false);
                            }
                        }

                        break;
                    }

                    case Improvement.ImprovementSource.MartialArtTechnique:
                        foreach (MartialArtTechnique objTechnique in MartialArts.SelectMany(x => x.Techniques))
                        {
                            if (objTechnique.InternalId == strImprovedSourceName)
                            {
                                return await objTechnique.DisplayNameAsync(strLanguage, token).ConfigureAwait(false);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.MentorSpirit:
                        foreach (MentorSpirit objMentorSpirit in MentorSpirits)
                        {
                            if (objMentorSpirit.InternalId == strImprovedSourceName)
                            {
                                return await objMentorSpirit.DisplayNameShortAsync(strLanguage, token).ConfigureAwait(false);
                            }
                        }

                        break;

                    case Improvement.ImprovementSource.Heritage:
                        return await LanguageManager.GetStringAsync("String_Priority", strLanguage, token: token).ConfigureAwait(false);

                    case Improvement.ImprovementSource.Initiation:
                        return await LanguageManager.GetStringAsync("Tab_Initiation", strLanguage, token: token).ConfigureAwait(false);

                    case Improvement.ImprovementSource.Submersion:
                        return await LanguageManager.GetStringAsync("Tab_Submersion", strLanguage, token: token).ConfigureAwait(false);

                    case Improvement.ImprovementSource.Encumbrance:
                        return await LanguageManager.GetStringAsync("String_Encumbrance", strLanguage, token: token).ConfigureAwait(false);

                    case Improvement.ImprovementSource.ArmorEncumbrance:
                        return await LanguageManager.GetStringAsync("String_ArmorEncumbrance", strLanguage, token: token).ConfigureAwait(false);

                    case Improvement.ImprovementSource.Tradition:
                        return await LanguageManager.GetStringAsync("String_Tradition", strLanguage, token: token).ConfigureAwait(false);

                    case Improvement.ImprovementSource.AstralReputation:
                        return await LanguageManager.GetStringAsync("String_AstralReputation", strLanguage, token: token).ConfigureAwait(false);

                    case Improvement.ImprovementSource.CyberadeptDaemon:
                        return (await LoadDataXPathAsync("qualities.xml", strLanguage, token: token).ConfigureAwait(false))
                               .SelectSingleNode(
                                   "/chummer/qualities/quality[name = \"Resonant Stream: Cyberadept\"]/translate")
                               ?.Value ?? "Resonant Stream: Cyberadept";

                    default:
                    {
                        if (objImprovement.ImproveType == Improvement.ImprovementType.ArmorEncumbrancePenalty)
                            return await LanguageManager
                                         .GetStringAsync("String_ArmorEncumbrance", strLanguage, token: token)
                                         .ConfigureAwait(false);
                        // If this comes from a custom Improvement, use the name the player gave it instead of showing a GUID.
                        if (!string.IsNullOrEmpty(objImprovement.CustomName))
                            return objImprovement.CustomName;
                        string strReturn = strImprovedSourceName;
                        if (string.IsNullOrEmpty(strReturn) || strReturn.IsGuid())
                        {
                            string strTemp = await LanguageManager.GetStringAsync(
                                "String_" + objImprovement.ImproveSource,
                                strLanguage, false, token: token).ConfigureAwait(false);
                            if (!string.IsNullOrEmpty(strTemp))
                                strReturn = strTemp;
                        }

                        return strReturn;
                    }
                }
            }

            return string.Empty;
        }

        public void CleanUpOrphanedImprovements(CancellationToken token = default)
        {
            using (LockObject.EnterWriteLock(token))
            {
                int intNewImprovementCount = 0;
                int intOldImprovementCount = Improvements.Count;
                // Loop this until we remove every single orphaned improvement (necessary because orphaned improvements can add other improvements)
                while (intOldImprovementCount != intNewImprovementCount)
                {
                    intOldImprovementCount = Improvements.Count;
                    // Relying on (a lack of) GetObjectName is slower than ideal, but much easier to maintain
                    Improvements.RemoveAll(x => string.IsNullOrEmpty(GetObjectName(x, GlobalSettings.DefaultLanguage, token)), token);
                    intNewImprovementCount = Improvements.Count;
                }
            }
        }

        public async ValueTask CleanUpOrphanedImprovementsAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                int intNewImprovementCount = 0;
                int intOldImprovementCount = await Improvements.GetCountAsync(token).ConfigureAwait(false);
                // Loop this until we remove every single orphaned improvement (necessary because orphaned improvements can add other improvements)
                while (intOldImprovementCount != intNewImprovementCount)
                {
                    intOldImprovementCount = await Improvements.GetCountAsync(token).ConfigureAwait(false);
                    // Relying on (a lack of) GetObjectName is slower than ideal, but much easier to maintain
                    await Improvements.RemoveAllAsync(
                        x => string.IsNullOrEmpty(GetObjectName(x, GlobalSettings.DefaultLanguage, token)), token).ConfigureAwait(false);
                    intNewImprovementCount = await Improvements.GetCountAsync(token).ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public void FormatImprovementModifiers(StringBuilder sbdToolTip, IEnumerable<Improvement.ImprovementType> improvements, string strSpace, int intModifiers, CancellationToken token = default)
        {
            if (sbdToolTip == null)
                return;
            sbdToolTip.Append(strSpace).Append('+').Append(strSpace).Append(LanguageManager.GetString("Tip_Modifiers", token: token));
            bool blnFirstModifier = true;
            using (EnterReadLock.Enter(LockObject, token))
            {
                foreach (Improvement.ImprovementType eType in improvements)
                {
                    foreach (Improvement objLoopImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                 this, eType, token: token))
                    {
                        if (blnFirstModifier)
                        {
                            blnFirstModifier = false;
                            sbdToolTip.Append(LanguageManager.GetString("String_Colon", token: token));
                        }
                        else
                            sbdToolTip.Append(',');

                        sbdToolTip.Append(strSpace).Append(GetObjectName(objLoopImprovement, token: token));
                    }
                }
            }

            sbdToolTip.Append(strSpace).Append('(').Append(intModifiers.ToString(GlobalSettings.CultureInfo)).Append(')');
        }

        /// <summary>
        /// Return an enumerable of CyberwareGrades from XML files.
        /// </summary>
        /// <param name="objSource">Source to load the Grades from, either Bioware or Cyberware.</param>
        /// <param name="blnIgnoreBannedGrades">Whether to ignore grades banned at chargen.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public IEnumerable<Grade> GetGrades(Improvement.ImprovementSource objSource, bool blnIgnoreBannedGrades = false, CancellationToken token = default)
        {
            using (EnterReadLock.Enter(LockObject, token))
            {
                string strXPath;
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdFilter))
                {
                    if (Settings != null)
                    {
                        sbdFilter.Append('(').Append(Settings.BookXPath(token: token)).Append(") and ");
                        if (!IgnoreRules && !Created && !blnIgnoreBannedGrades)
                        {
                            foreach (string strBannedGrade in Settings.BannedWareGrades)
                            {
                                sbdFilter.Append("not(contains(name, ").Append(strBannedGrade.CleanXPath())
                                         .Append(")) and ");
                            }
                        }
                    }

                    if (sbdFilter.Length != 0)
                    {
                        sbdFilter.Length -= 5;
                        strXPath = "/chummer/grades/grade[(" + sbdFilter + ")]";
                    }
                    else
                        strXPath = "/chummer/grades/grade";
                }

                using (XmlNodeList xmlGradeList = LoadData(Grade.GetDataFileNameFromImprovementSource(objSource), token: token)
                           .SelectNodes(strXPath))
                {
                    if (xmlGradeList?.Count > 0)
                    {
                        foreach (XmlNode objNode in xmlGradeList)
                        {
                            Grade objGrade = new Grade(this, objSource);
                            objGrade.Load(objNode);
                            yield return objGrade;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Return a list of CyberwareGrades from XML files.
        /// </summary>
        /// <param name="objSource">Source to load the Grades from, either Bioware or Cyberware.</param>
        /// <param name="blnIgnoreBannedGrades">Whether to ignore grades banned at chargen.</param>
        public List<Grade> GetGradesList(Improvement.ImprovementSource objSource, bool blnIgnoreBannedGrades = false)
        {
            return GetGrades(objSource, blnIgnoreBannedGrades).ToList();
        }

        /// <summary>
        /// Return a list of CyberwareGrades from XML files.
        /// </summary>
        /// <param name="objSource">Source to load the Grades from, either Bioware or Cyberware.</param>
        /// <param name="blnIgnoreBannedGrades">Whether to ignore grades banned at chargen.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public async Task<List<Grade>> GetGradesListAsync(Improvement.ImprovementSource objSource, bool blnIgnoreBannedGrades = false, CancellationToken token = default)
        {
            List<Grade> lstReturn;
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                string strXPath;
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdFilter))
                {
                    if (Settings != null)
                    {
                        sbdFilter.Append('(').Append(await (await GetSettingsAsync(token).ConfigureAwait(false)).BookXPathAsync(token: token).ConfigureAwait(false)).Append(") and ");
                        if (!blnIgnoreBannedGrades && !await GetCreatedAsync(token).ConfigureAwait(false) && !await GetIgnoreRulesAsync(token).ConfigureAwait(false))
                        {
                            foreach (string strBannedGrade in (await GetSettingsAsync(token).ConfigureAwait(false)).BannedWareGrades)
                            {
                                sbdFilter.Append("not(contains(name, ").Append(strBannedGrade.CleanXPath())
                                         .Append(")) and ");
                            }
                        }
                    }

                    if (sbdFilter.Length != 0)
                    {
                        sbdFilter.Length -= 5;
                        strXPath = "/chummer/grades/grade[(" + sbdFilter + ")]";
                    }
                    else
                        strXPath = "/chummer/grades/grade";
                }

                using (XmlNodeList xmlGradeList = (await LoadDataAsync(Grade.GetDataFileNameFromImprovementSource(objSource), token: token).ConfigureAwait(false))
                           .SelectNodes(strXPath))
                {
                    lstReturn = new List<Grade>(xmlGradeList?.Count ?? 0);
                    if (xmlGradeList?.Count > 0)
                    {
                        foreach (XmlNode objNode in xmlGradeList)
                        {
                            Grade objGrade = new Grade(this, objSource);
                            objGrade.Load(objNode);
                            lstReturn.Add(objGrade);
                        }
                    }
                }
            }

            return lstReturn;
        }

        /// <summary>
        /// Calculate the number of Free Spirit Power Points used.
        /// </summary>
        public async ValueTask<string> CalculateFreeSpiritPowerPointsAsync(CancellationToken token = default)
        {
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);

            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (await GetMetatypeAsync(token).ConfigureAwait(false) == "Free Spirit" && !await GetIsCritterAsync(token).ConfigureAwait(false))
                {
                    // PC Free Spirit.
                    decimal decPowerPoints = await (await GetCritterPowersAsync(token).ConfigureAwait(false))
                                                   .SumAsync(x => x.CountTowardsLimit, x => x.PowerPoints, token: token)
                                                   .ConfigureAwait(false);

                    int intPowerPoints = await (await GetAttributeAsync("EDG", token: token).ConfigureAwait(false))
                                               .GetTotalValueAsync(token).ConfigureAwait(false)
                                         + (await ImprovementManager
                                                  .ValueOfAsync(this, Improvement.ImprovementType.FreeSpiritPowerPoints,
                                                                token: token).ConfigureAwait(false)).StandardRound();

                    // If the house rule to base Power Points on the character's MAG value instead, use the character's MAG.
                    if (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetFreeSpiritPowerPointsMAGAsync(token).ConfigureAwait(false))
                        intPowerPoints = await (await GetAttributeAsync("MAG", token: token).ConfigureAwait(false))
                                               .GetTotalValueAsync(token).ConfigureAwait(false)
                                         + (await ImprovementManager
                                                  .ValueOfAsync(this, Improvement.ImprovementType.FreeSpiritPowerPoints,
                                                                token: token).ConfigureAwait(false)).StandardRound();

                    return intPowerPoints.ToString(GlobalSettings.CultureInfo) + strSpace + '('
                           + (intPowerPoints - decPowerPoints).ToString(GlobalSettings.CultureInfo) + strSpace
                           + await LanguageManager.GetStringAsync("String_Remaining", token: token).ConfigureAwait(false) + ')';
                }
                else
                {
                    int intPowerPoints;

                    switch (await GetMetatypeAsync(token).ConfigureAwait(false))
                    {
                        case "Free Spirit":
                            // Critter Free Spirits have a number of Power Points equal to their EDG plus any Free Spirit Power Points Improvements.
                            intPowerPoints = await (await GetAttributeAsync("EDG", token: token).ConfigureAwait(false))
                                                   .GetTotalValueAsync(token).ConfigureAwait(false)
                                             + (await ImprovementManager
                                                      .ValueOfAsync(
                                                          this, Improvement.ImprovementType.FreeSpiritPowerPoints,
                                                          token: token).ConfigureAwait(false)).StandardRound();
                            break;

                        case "Ally Spirit":
                            // Ally Spirits get a number of Power Points equal to their MAG.
                            intPowerPoints = await (await GetAttributeAsync("MAG", token: token).ConfigureAwait(false))
                                                   .GetTotalValueAsync(token).ConfigureAwait(false);
                            break;

                        default:
                            // Spirits get 1 Power Point for every 3 full points of Force (MAG) they possess.
                            intPowerPoints = await (await GetAttributeAsync("MAG", token: token).ConfigureAwait(false))
                                                   .GetTotalValueAsync(token).ConfigureAwait(false) / 3;
                            break;
                    }

                    decimal decUsed = await (await GetCritterPowersAsync(token).ConfigureAwait(false))
                                            .SumAsync(x => x.Category != "Weakness" && x.CountTowardsLimit,
                                                      x => x.PowerPoints, token: token).ConfigureAwait(false);

                    return intPowerPoints.ToString(GlobalSettings.CultureInfo) + strSpace + '('
                           + (intPowerPoints - decUsed).ToString(GlobalSettings.CultureInfo) + strSpace
                           + await LanguageManager.GetStringAsync("String_Remaining", token: token).ConfigureAwait(false) + ')';
                }
            }
        }

        /// <summary>
        /// Calculate the number of Free Sprite Power Points used.
        /// </summary>
        public async ValueTask<string> CalculateFreeSpritePowerPointsAsync(CancellationToken token = default)
        {
            // Free Sprite Power Points.
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                decimal decUsedPowerPoints = await (await GetCritterPowersAsync(token).ConfigureAwait(false))
                                                   .SumAsync(x => x.CountTowardsLimit, x => x.PowerPoints, token)
                                                   .ConfigureAwait(false);

                int intPowerPoints = await (await GetAttributeAsync("EDG", token: token).ConfigureAwait(false))
                                           .GetTotalValueAsync(token).ConfigureAwait(false)
                                     + (await ImprovementManager
                                              .ValueOfAsync(this, Improvement.ImprovementType.FreeSpiritPowerPoints,
                                                            token: token).ConfigureAwait(false)).StandardRound();

                string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);

                return intPowerPoints.ToString(GlobalSettings.CultureInfo) + strSpace + '('
                       + (intPowerPoints - decUsedPowerPoints).ToString(GlobalSettings.CultureInfo)
                       + strSpace + await LanguageManager.GetStringAsync("String_Remaining", token: token).ConfigureAwait(false) + ')';
            }
        }

        /// <summary>
        /// Construct a list of possible places to put a piece of modular cyberware. Names are display names of the given items, values are internalIDs of the given items.
        /// </summary>
        /// <param name="objModularCyberware">Cyberware for which to construct the list.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public IEnumerable<ListItem> ConstructModularCyberlimbList([NotNull] Cyberware objModularCyberware, CancellationToken token = default)
        {
            yield return new ListItem("None", LanguageManager.GetString("String_None", token: token));

            string strSpace = LanguageManager.GetString("String_Space", token: token);

            using (EnterReadLock.Enter(LockObject, token))
            {
                foreach (Cyberware objLoopCyberware in Cyberware.GetAllDescendants(x => x.Children))
                {
                    // Make sure this has an eligible mount location and it's not the selected piece modular cyberware
                    if (objLoopCyberware.HasModularMount == objModularCyberware.PlugsIntoModularMount
                        && (objLoopCyberware.Location == objModularCyberware.Location
                            || string.IsNullOrEmpty(objModularCyberware.Location))
                        && objLoopCyberware.Grade.Name == objModularCyberware.Grade.Name
                        && objLoopCyberware != objModularCyberware
                        // Make sure it's not the place where the mount is already occupied (either by us or something else)
                        && objLoopCyberware.Children.All(
                            x => x.PlugsIntoModularMount != objLoopCyberware.HasModularMount))
                    {
                        string strName = objLoopCyberware.Parent?.CurrentDisplayName
                                         ?? objLoopCyberware.CurrentDisplayName;
                        yield return new ListItem(objLoopCyberware.InternalId, strName);
                    }
                }

                foreach (Vehicle objLoopVehicle in Vehicles)
                {
                    foreach (VehicleMod objLoopVehicleMod in objLoopVehicle.Mods)
                    {
                        foreach (Cyberware objLoopCyberware in objLoopVehicleMod.Cyberware.GetAllDescendants(
                                     x => x.Children))
                        {
                            // Make sure this has an eligible mount location and it's not the selected piece modular cyberware
                            if (objLoopCyberware.HasModularMount == objModularCyberware.PlugsIntoModularMount
                                && objLoopCyberware.Location == objModularCyberware.Location
                                && objLoopCyberware.Grade.Name == objModularCyberware.Grade.Name
                                && objLoopCyberware != objModularCyberware
                                // Make sure it's not the place where the mount is already occupied (either by us or something else)
                                && objLoopCyberware.Children.All(
                                    x => x.PlugsIntoModularMount != objLoopCyberware.HasModularMount))
                            {
                                string strName = objLoopVehicle.CurrentDisplayName
                                                 + strSpace + (objLoopCyberware.Parent?.CurrentDisplayName
                                                               ?? objLoopVehicleMod.CurrentDisplayName);
                                yield return new ListItem(objLoopCyberware.InternalId, strName);
                            }
                        }
                    }

                    foreach (WeaponMount objLoopWeaponMount in objLoopVehicle.WeaponMounts)
                    {
                        foreach (VehicleMod objLoopVehicleMod in objLoopWeaponMount.Mods)
                        {
                            foreach (Cyberware objLoopCyberware in objLoopVehicleMod.Cyberware.GetAllDescendants(
                                         x => x.Children))
                            {
                                // Make sure this has an eligible mount location and it's not the selected piece modular cyberware
                                if (objLoopCyberware.HasModularMount == objModularCyberware.PlugsIntoModularMount
                                    && objLoopCyberware.Location == objModularCyberware.Location
                                    && objLoopCyberware.Grade.Name == objModularCyberware.Grade.Name
                                    && objLoopCyberware != objModularCyberware
                                    // Make sure it's not the place where the mount is already occupied (either by us or something else)
                                    && objLoopCyberware.Children.All(
                                        x => x.PlugsIntoModularMount != objLoopCyberware.HasModularMount))
                                {
                                    string strName = objLoopVehicle.CurrentDisplayName
                                                     + strSpace + (objLoopCyberware.Parent?.CurrentDisplayName
                                                                   ?? objLoopVehicleMod.CurrentDisplayName);
                                    yield return new ListItem(objLoopCyberware.InternalId, strName);
                                }
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Construct a list of possible places to put a piece of modular cyberware. Names are display names of the given items, values are internalIDs of the given items.
        /// </summary>
        /// <param name="objModularCyberware">Cyberware for which to construct the list.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public async Task<List<ListItem>> ConstructModularCyberlimbListAsync([NotNull] Cyberware objModularCyberware, CancellationToken token = default)
        {
            List<ListItem> lstReturn = new List<ListItem>(3)
                {new ListItem("None", await LanguageManager.GetStringAsync("String_None", token: token).ConfigureAwait(false))};

            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);

            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                await (await GetCyberwareAsync(token).ConfigureAwait(false)).GetAllDescendants(x => x.Children).ForEachAsync(async objLoopCyberware =>
                {
                    // Make sure this has an eligible mount location and it's not the selected piece modular cyberware
                    if (objLoopCyberware.HasModularMount == objModularCyberware.PlugsIntoModularMount
                        && (objLoopCyberware.Location == objModularCyberware.Location
                            || string.IsNullOrEmpty(objModularCyberware.Location))
                        && objLoopCyberware.Grade.Name == objModularCyberware.Grade.Name
                        && objLoopCyberware != objModularCyberware
                        // Make sure it's not the place where the mount is already occupied (either by us or something else)
                        && await objLoopCyberware.Children.AllAsync(
                            x => x.PlugsIntoModularMount != objLoopCyberware.HasModularMount, token).ConfigureAwait(false))
                    {
                        string strName = objLoopCyberware.Parent != null
                            ? await objLoopCyberware.Parent.GetCurrentDisplayNameAsync(token).ConfigureAwait(false)
                            : await objLoopCyberware.GetCurrentDisplayNameAsync(token).ConfigureAwait(false);
                        lstReturn.Add(new ListItem(objLoopCyberware.InternalId, strName));
                    }
                }, token).ConfigureAwait(false);

                await (await GetVehiclesAsync(token).ConfigureAwait(false)).ForEachAsync(async objLoopVehicle =>
                {
                    await objLoopVehicle.Mods.ForEachAsync(async objLoopVehicleMod =>
                    {
                        await objLoopVehicleMod.Cyberware.GetAllDescendants(x => x.Children).ForEachAsync(
                            async objLoopCyberware =>
                            {
                                // Make sure this has an eligible mount location and it's not the selected piece modular cyberware
                                if (objLoopCyberware.HasModularMount == objModularCyberware.PlugsIntoModularMount
                                    && objLoopCyberware.Location == objModularCyberware.Location
                                    && objLoopCyberware.Grade.Name == objModularCyberware.Grade.Name
                                    && objLoopCyberware != objModularCyberware
                                    // Make sure it's not the place where the mount is already occupied (either by us or something else)
                                    && await objLoopCyberware.Children.AllAsync(
                                                                 x => x.PlugsIntoModularMount
                                                                      != objLoopCyberware.HasModularMount, token)
                                                             .ConfigureAwait(false))
                                {
                                    string strName
                                        = await objLoopVehicle.GetCurrentDisplayNameAsync(token).ConfigureAwait(false)
                                          + strSpace + (objLoopCyberware.Parent != null
                                              ? await objLoopCyberware.Parent.GetCurrentDisplayNameAsync(token)
                                                                      .ConfigureAwait(false)
                                              : await objLoopVehicleMod.GetCurrentDisplayNameAsync(token)
                                                                       .ConfigureAwait(false));
                                    lstReturn.Add(new ListItem(objLoopCyberware.InternalId, strName));
                                }
                            }, token).ConfigureAwait(false);
                    }, token).ConfigureAwait(false);

                    await objLoopVehicle.WeaponMounts.ForEachAsync(async objLoopWeaponMount =>
                    {
                        await objLoopWeaponMount.Mods.ForEachAsync(async objLoopVehicleMod =>
                        {
                            await objLoopVehicleMod.Cyberware.GetAllDescendants(x => x.Children).ForEachAsync(
                                async objLoopCyberware =>
                                {
                                    // Make sure this has an eligible mount location and it's not the selected piece modular cyberware
                                    if (objLoopCyberware.HasModularMount == objModularCyberware.PlugsIntoModularMount
                                        && objLoopCyberware.Location == objModularCyberware.Location
                                        && objLoopCyberware.Grade.Name == objModularCyberware.Grade.Name
                                        && objLoopCyberware != objModularCyberware
                                        // Make sure it's not the place where the mount is already occupied (either by us or something else)
                                        && await objLoopCyberware.Children.AllAsync(
                                            x => x.PlugsIntoModularMount != objLoopCyberware.HasModularMount, token).ConfigureAwait(false))
                                    {
                                        string strName
                                            = await objLoopVehicle.GetCurrentDisplayNameAsync(token).ConfigureAwait(false)
                                              + strSpace + (objLoopCyberware.Parent != null
                                                  ? await objLoopCyberware.Parent.GetCurrentDisplayNameAsync(token)
                                                                          .ConfigureAwait(false)
                                                  : await objLoopVehicleMod.GetCurrentDisplayNameAsync(token)
                                                                           .ConfigureAwait(false));
                                        lstReturn.Add(new ListItem(objLoopCyberware.InternalId, strName));
                                    }
                                }, token).ConfigureAwait(false);
                        }, token).ConfigureAwait(false);
                    }, token).ConfigureAwait(false);
                }, token).ConfigureAwait(false);
            }

            return lstReturn;
        }

        public async Task<bool> SwitchBuildMethods(CharacterBuildMethod eOldBuildMethod, CharacterBuildMethod eNewBuildMethod, string strOldSettingsKey, CancellationToken token = default)
        {
            DialogResult eResult;
            if (eNewBuildMethod.UsesPriorityTables())
            {
                using (ThreadSafeForm<SelectMetatypePriority> frmSelectMetatype = await ThreadSafeForm<SelectMetatypePriority>.GetAsync(() => new SelectMetatypePriority(this), token).ConfigureAwait(false))
                {
                    eResult = await frmSelectMetatype.ShowDialogSafeAsync(this, token).ConfigureAwait(false);
                }
            }
            else
            {
                using (ThreadSafeForm<SelectMetatypeKarma> frmSelectMetatype = await ThreadSafeForm<SelectMetatypeKarma>.GetAsync(() => new SelectMetatypeKarma(this), token).ConfigureAwait(false))
                {
                    eResult = await frmSelectMetatype.ShowDialogSafeAsync(this, token).ConfigureAwait(false);
                }
            }

            IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                if (eResult != DialogResult.OK)
                {
                    await SetSettingsKeyAsync(strOldSettingsKey, token).ConfigureAwait(false);
                    return false;
                }

                if (eOldBuildMethod == CharacterBuildMethod.LifeModule)
                {
                    ThreadSafeObservableCollection<Quality> lstQualities = await GetQualitiesAsync(token).ConfigureAwait(false);
                    IAsyncDisposable objLocker2 = await lstQualities.LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                    try
                    {
                        for (int i = await lstQualities.GetCountAsync(token).ConfigureAwait(false) - 1; i >= 0; --i)
                        {
                            if (i >= await lstQualities.GetCountAsync(token).ConfigureAwait(false))
                                continue;
                            Quality objQuality = await lstQualities.GetValueAtAsync(i, token).ConfigureAwait(false);
                            if (objQuality.OriginSource == QualitySource.LifeModule)
                                await objQuality.DeleteQualityAsync(token: token).ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        await objLocker2.DisposeAsync().ConfigureAwait(false);
                    }
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }

            return true;
        }

        public async Task<Tuple<string, int>> CalculateKarmaValue(string strLanguage, CultureInfo objCulture, CancellationToken token = default)
        {
            string strColonCharacter = await LanguageManager.GetStringAsync("String_Colon", strLanguage, token: token).ConfigureAwait(false);
            string strSpace = await LanguageManager.GetStringAsync("String_Space", strLanguage, token: token).ConfigureAwait(false);
            string strKarmaString = await LanguageManager.GetStringAsync("String_Karma", strLanguage, token: token).ConfigureAwait(false);
            int intExtraKarmaToRemoveForPointBuyComparison = 0;
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                CharacterSettings objSettings = await GetSettingsAsync(token).ConfigureAwait(false);
                int intReturn = await objSettings.GetBuildKarmaAsync(token).ConfigureAwait(false);

                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdMessage))
                {
                    sbdMessage.AppendLine(await LanguageManager.GetStringAsync("Message_KarmaValue", strLanguage, token: token).ConfigureAwait(false)).AppendLine()
                              .Append(await LanguageManager.GetStringAsync("Label_Base", strLanguage, token: token).ConfigureAwait(false))
                              .Append(strColonCharacter).Append(strSpace)
                              .Append(intReturn.ToString(objCulture))
                              .Append(strSpace).Append(strKarmaString);

                    if (await GetEffectiveBuildMethodUsesPriorityTablesAsync(token).ConfigureAwait(false))
                    {
                        int intMetatypeQualitiesValue = 0;
                        // Karma value of all qualities (we're ignoring metatype cost because Point Buy karma costs don't line up with other methods' values)
                        await (await GetQualitiesAsync(token).ConfigureAwait(false)).ForEachAsync(async objQuality =>
                        {
                            if (objQuality.OriginSource == QualitySource.Metatype
                                || objQuality.OriginSource == QualitySource.MetatypeRemovable)
                            {
                                XPathNavigator xmlQualityNode = await objQuality.GetNodeXPathAsync(token: token).ConfigureAwait(false);
                                if (xmlQualityNode == null)
                                    return;
                                int intLoopKarma = 0;
                                if (xmlQualityNode.TryGetInt32FieldQuickly("karma", ref intLoopKarma))
                                    intMetatypeQualitiesValue += intLoopKarma;
                            }
                        }, token).ConfigureAwait(false);

                        // Subtract extra karma cost of a metatype in priority
                        int intMetatypePriorityKarmaCost = -await GetMetatypeBPAsync(token).ConfigureAwait(false);
                        // For point buy comparisons, we need to use the metatype's Point Buy cost for the comparison, not attributes + metatype qualities.
                        intExtraKarmaToRemoveForPointBuyComparison += intMetatypePriorityKarmaCost + intMetatypeQualitiesValue;
                        int intAttributesValue = 0;
                        // Zeroed to -10 because that's Human's value at default settings
                        int intMetatypeExtraAttributesValue = -2 * objSettings.KarmaAttribute;
                        intExtraKarmaToRemoveForPointBuyComparison -= 2 * objSettings.KarmaAttribute;
                        // Value from attribute points and raised attribute minimums
                        foreach (CharacterAttrib objLoopAttrib in AttributeSection.AttributeList.Concat(AttributeSection
                                     .SpecialAttributeList))
                        {
                            string strAttributeName = objLoopAttrib.Abbrev;
                            if (strAttributeName != "ESS" &&
                                (strAttributeName != "MAGAdept"
                                 || (await GetIsMysticAdeptAsync(token).ConfigureAwait(false) && await objSettings.GetMysAdeptSecondMAGAttributeAsync(token).ConfigureAwait(false)))
                                &&
                                await objLoopAttrib.GetMetatypeMaximumAsync(token).ConfigureAwait(false) > 0)
                            {
                                int intLoopAttribValue
                                    = await objLoopAttrib.GetAttributeValueModifiersAsync(token).ConfigureAwait(false)
                                      + Math.Max(
                                          objLoopAttrib.Base
                                          + await objLoopAttrib.GetFreeBaseAsync(token).ConfigureAwait(false)
                                          + await objLoopAttrib.GetRawMinimumAsync(token).ConfigureAwait(false),
                                          await objLoopAttrib.GetTotalMinimumAsync(token).ConfigureAwait(false));
                                if (intLoopAttribValue > 1)
                                {
                                    bool blnIsRegularAttribute
                                        = strAttributeName != "MAG" && strAttributeName != "MAGAdept" &&
                                          strAttributeName != "RES" && strAttributeName != "DEP";
                                    intMetatypeExtraAttributesValue += ((intLoopAttribValue + 1) * intLoopAttribValue / 2 - 1)
                                                                       * await objSettings.GetKarmaAttributeAsync(token).ConfigureAwait(false);
                                    if (blnIsRegularAttribute)
                                    {
                                        int intMetatypeMinimumDelta = await objLoopAttrib.GetMetatypeMinimumAsync(token)
                                            .ConfigureAwait(false) - 1;
                                        int intVanillaAttribValue
                                            = await objLoopAttrib.GetAttributeValueModifiersAsync(token)
                                                                 .ConfigureAwait(false) + Math.Max(
                                                objLoopAttrib.Base
                                                + await objLoopAttrib.GetFreeBaseAsync(token).ConfigureAwait(false)
                                                + await objLoopAttrib.GetRawMinimumAsync(token).ConfigureAwait(false)
                                                - intMetatypeMinimumDelta,
                                                await objLoopAttrib.GetTotalMinimumAsync(token).ConfigureAwait(false)
                                                - intMetatypeMinimumDelta);
                                        intAttributesValue
                                            += ((intVanillaAttribValue + 1) * intVanillaAttribValue / 2 - 1) *
                                               await objSettings.GetKarmaAttributeAsync(token).ConfigureAwait(false);
                                    }
                                    else
                                        intAttributesValue += ((intLoopAttribValue + 1) * intLoopAttribValue / 2 - 1) *
                                                              await objSettings.GetKarmaAttributeAsync(token).ConfigureAwait(false);

                                    // Separately calculate and apply Point Buy calculation modification from higher metatype minima
                                    if (blnIsRegularAttribute)
                                    {
                                        // All non-regular attributes are forced to start at 0 or 1 anyway, so while it is hacky to
                                        // only consider regular attributes, it is what makes the math work 99% of the time, and
                                        // handling non-regular attributes in a special way would be too complicated in Chummer's setup.
                                        int intMetatypeBaseAttribValue = await objLoopAttrib
                                                                               .GetMetatypeMinimumAsync(token)
                                                                               .ConfigureAwait(false);
                                        if (intMetatypeBaseAttribValue > 1)
                                        {
                                            intExtraKarmaToRemoveForPointBuyComparison
                                                += ((intMetatypeBaseAttribValue + 1) * intMetatypeBaseAttribValue / 2
                                                    - 1) * await objSettings.GetKarmaAttributeAsync(token)
                                                                            .ConfigureAwait(false);
                                        }
                                    }
                                }
                            }
                        }

                        intMetatypeExtraAttributesValue -= intAttributesValue;

                        if (intMetatypePriorityKarmaCost + intMetatypeExtraAttributesValue + intMetatypeQualitiesValue != 0)
                        {
                            sbdMessage.AppendLine()
                                      .Append(await LanguageManager.GetStringAsync("Label_SumtoTenHeritage", strLanguage, token: token).ConfigureAwait(false))
                                      .Append(strSpace)
                                      .Append((intMetatypePriorityKarmaCost + intMetatypeExtraAttributesValue + intMetatypeQualitiesValue).ToString(
                                                  objCulture)).Append(strSpace).Append(strKarmaString);
                            intReturn += intMetatypePriorityKarmaCost + intMetatypeExtraAttributesValue
                                                                      + intMetatypeQualitiesValue;
                        }

                        if (intAttributesValue != 0)
                        {
                            sbdMessage.AppendLine()
                                      .Append(await LanguageManager.GetStringAsync("Label_SumtoTenAttributes", strLanguage, token: token).ConfigureAwait(false))
                                      .Append(strSpace).Append(intAttributesValue.ToString(objCulture))
                                      .Append(strSpace).Append(strKarmaString);
                            intReturn += intAttributesValue;
                        }

                        // Karma needs to be added based on the character's metatype/metavariant Point Buy karma cost because that is what is used in Point Buy,
                        // not the metatype/metavariant attribute/quality costs.
                        int intTemp = 0;
                        if ((await this.GetNodeXPathAsync(token: token).ConfigureAwait(false))?.TryGetInt32FieldQuickly("karma", ref intTemp) == true)
                            intExtraKarmaToRemoveForPointBuyComparison -= intTemp;

                        // This is where "Talent" qualities like Adept and Technomancer get added in
                        int intTalentPriorityQualitiesKarma
                            = await (await GetQualitiesAsync(token).ConfigureAwait(false)).SumAsync(
                                objQuality => objQuality.OriginSource == QualitySource.Heritage, async objQuality =>
                                {
                                    XPathNavigator xmlQualityNode
                                        = await objQuality.GetNodeXPathAsync(token: token).ConfigureAwait(false);
                                    if (xmlQualityNode == null)
                                        return 0;
                                    int intLoopKarma = 0;
                                    xmlQualityNode.TryGetInt32FieldQuickly("karma", ref intLoopKarma);
                                    return intLoopKarma;
                                }, token).ConfigureAwait(false);

                        if (intTalentPriorityQualitiesKarma != 0)
                        {
                            sbdMessage.AppendLine().Append(await LanguageManager.GetStringAsync("String_Qualities", strLanguage, token: token).ConfigureAwait(false))
                                      .Append(strColonCharacter).Append(strSpace)
                                      .Append(intTalentPriorityQualitiesKarma.ToString(objCulture)).Append(strSpace)
                                      .Append(strKarmaString);
                            intReturn += intTalentPriorityQualitiesKarma;
                        }

                        // Value from free spells
                        int intFreeSpellsKarma = await GetFreeSpellsAsync(token).ConfigureAwait(false) * await SpellKarmaCostAsync("Spells", token).ConfigureAwait(false);
                        if (intFreeSpellsKarma != 0)
                        {
                            sbdMessage.AppendLine().Append(await LanguageManager.GetStringAsync("String_FreeSpells", strLanguage, token: token).ConfigureAwait(false))
                                      .Append(strColonCharacter).Append(strSpace)
                                      .Append(intFreeSpellsKarma.ToString(objCulture)).Append(strSpace)
                                      .Append(strKarmaString);
                            intReturn += intFreeSpellsKarma;
                        }

                        // Value from free complex forms
                        int intFreeCFsKarma = await GetCFPLimitAsync(token).ConfigureAwait(false) * await GetComplexFormKarmaCostAsync(token).ConfigureAwait(false);
                        if (intFreeCFsKarma != 0)
                        {
                            sbdMessage.AppendLine().Append(await LanguageManager.GetStringAsync("String_FreeCFs", strLanguage, token: token).ConfigureAwait(false))
                                      .Append(strColonCharacter).Append(strSpace)
                                      .Append(intFreeCFsKarma.ToString(objCulture)).Append(strSpace)
                                      .Append(strKarmaString);
                            intReturn += intFreeCFsKarma;
                        }

                        int intSkillPointsKarma = 0;
                        // Value from skill points
                        await (await (await GetSkillsSectionAsync(token).ConfigureAwait(false)).GetSkillsAsync(token).ConfigureAwait(false)).ForEachAsync(async objLoopActiveSkill =>
                        {
                            SkillGroup objLoopGroup = objLoopActiveSkill.SkillGroupObject;
                            if (objLoopGroup == null || await objLoopGroup.GetBaseAsync(token).ConfigureAwait(false) <= 0)
                            {
                                int intLoopRating = await objLoopActiveSkill.GetBaseAsync(token).ConfigureAwait(false);
                                if (intLoopRating > 0)
                                {
                                    intSkillPointsKarma += await objSettings.GetKarmaNewActiveSkillAsync(token)
                                                                            .ConfigureAwait(false);
                                    intSkillPointsKarma += ((intLoopRating + 1) * intLoopRating / 2 - 1)
                                                           * await objSettings.GetKarmaImproveActiveSkillAsync(token)
                                                                              .ConfigureAwait(false);
                                    if (await GetEffectiveBuildMethodIsLifeModuleAsync(token).ConfigureAwait(false))
                                        intSkillPointsKarma
                                            += await objLoopActiveSkill.Specializations
                                                                       .CountAsync(x => x.Free, token: token)
                                                                       .ConfigureAwait(false) *
                                               await objSettings.GetKarmaSpecializationAsync(token)
                                                                .ConfigureAwait(false);
                                    else if (!await objLoopActiveSkill.GetBuyWithKarmaAsync(token)
                                                                      .ConfigureAwait(false))
                                        intSkillPointsKarma += objLoopActiveSkill.Specializations.Count
                                                               * await objSettings.GetKarmaSpecializationAsync(token)
                                                                   .ConfigureAwait(false);
                                }
                            }
                        }, token).ConfigureAwait(false);

                        if (intSkillPointsKarma != 0)
                        {
                            sbdMessage.AppendLine().Append(await LanguageManager.GetStringAsync("String_SkillPoints", strLanguage, token: token).ConfigureAwait(false))
                                      .Append(strColonCharacter).Append(strSpace)
                                      .Append(intSkillPointsKarma.ToString(objCulture)).Append(strSpace)
                                      .Append(strKarmaString);
                            intReturn += intSkillPointsKarma;
                        }

                        int intSkillGroupPointsKarma = 0;
                        // Value from skill group points
                        await (await (await GetSkillsSectionAsync(token).ConfigureAwait(false)).GetSkillGroupsAsync(token).ConfigureAwait(false)).ForEachAsync(async objLoopGroup =>
                        {
                            int intLoopRating = await objLoopGroup.GetBaseAsync(token).ConfigureAwait(false);
                            if (intLoopRating <= 0)
                                return;
                            intSkillGroupPointsKarma
                                += await objSettings.GetKarmaNewSkillGroupAsync(token).ConfigureAwait(false);
                            intSkillGroupPointsKarma += ((intLoopRating + 1) * intLoopRating / 2 - 1)
                                                        * await objSettings.GetKarmaImproveSkillGroupAsync(token)
                                                                           .ConfigureAwait(false);
                        }, token).ConfigureAwait(false);

                        if (intSkillGroupPointsKarma != 0)
                        {
                            sbdMessage.AppendLine()
                                      .Append(await LanguageManager.GetStringAsync("String_SkillGroupPoints", strLanguage, token: token).ConfigureAwait(false))
                                      .Append(strColonCharacter).Append(strSpace)
                                      .Append(intSkillGroupPointsKarma.ToString(objCulture)).Append(strSpace)
                                      .Append(strKarmaString);
                            intReturn += intSkillGroupPointsKarma;
                        }

                        // Starting Nuyen karma value
                        decimal decBaseStartingNuyen
                            = await CalculateStartingNuyenFromKarmaAsync(Math.Min(await GetNuyenBPAsync(token).ConfigureAwait(false), await GetTotalNuyenMaximumBPAsync(token).ConfigureAwait(false)), await GetStartingNuyenAsync(token).ConfigureAwait(false), token).ConfigureAwait(false);
                        if (decBaseStartingNuyen != 0)
                        {
                            // Start off with the negative value of the karma we put into nuyen to make this calculation work properly for weird, nonlinear scaling
                            int intNuyenKarma = -Math.Min(await GetNuyenBPAsync(token).ConfigureAwait(false), await GetTotalNuyenMaximumBPAsync(token).ConfigureAwait(false)).ToInt32();
                            // This looks horrible, but we cannot use binary search or calculate karma value directly because XPath expressions are so free-form
                            // The only option is to loop through every possible Karma value until we find the lowest one that gives more nuyen than Priority gives
                            for (int i = 0; i < int.MaxValue; ++i)
                            {
                                decimal decLoopNuyen = await CalculateStartingNuyenFromKarmaAsync(i, 0, token).ConfigureAwait(false);
                                // This looks quite wonky when what we're actually looking for is the exact value, but effectively rounds karma requirements up in cases where Nuyen doesn't divide cleanly
                                if (decLoopNuyen >= decBaseStartingNuyen)
                                {
                                    intNuyenKarma += i;
                                    break;
                                }
                            }

                            if (intNuyenKarma != 0)
                            {
                                sbdMessage.AppendLine()
                                          .Append(await LanguageManager.GetStringAsync("Checkbox_CreatePACKSKit_StartingNuyen",
                                                      strLanguage, token: token).ConfigureAwait(false)).Append(strColonCharacter)
                                          .Append(strSpace).Append(intNuyenKarma.ToString(objCulture))
                                          .Append(strSpace).Append(strKarmaString);
                                intReturn += intNuyenKarma;
                            }
                        }
                    }

                    int intContactPointsValue = await GetContactPointsAsync(token).ConfigureAwait(false) * await objSettings.GetKarmaContactAsync(token).ConfigureAwait(false);
                    if (intContactPointsValue != 0)
                    {
                        sbdMessage.AppendLine().Append(await LanguageManager.GetStringAsync("String_Contacts", strLanguage, token: token).ConfigureAwait(false))
                                  .Append(strColonCharacter).Append(strSpace)
                                  .Append(intContactPointsValue.ToString(objCulture)).Append(strSpace)
                                  .Append(strKarmaString);
                        intReturn += intContactPointsValue;
                        intExtraKarmaToRemoveForPointBuyComparison += intContactPointsValue;
                    }

                    int intKnowledgePointsValue = 0;
                    await (await (await GetSkillsSectionAsync(token).ConfigureAwait(false)).GetKnowledgeSkillsAsync(token).ConfigureAwait(false)).ForEachAsync(
                        async objLoopKnowledgeSkill =>
                        {
                            int intLoopRating = await objLoopKnowledgeSkill.GetBaseAsync(token).ConfigureAwait(false);
                            if (intLoopRating > 0)
                            {
                                intKnowledgePointsValue += await objSettings.GetKarmaNewKnowledgeSkillAsync(token)
                                                                            .ConfigureAwait(false);
                                intKnowledgePointsValue += ((intLoopRating + 1) * intLoopRating / 2 - 1) *
                                                           await objSettings.GetKarmaImproveKnowledgeSkillAsync(token)
                                                                            .ConfigureAwait(false);
                                if (await GetEffectiveBuildMethodIsLifeModuleAsync(token).ConfigureAwait(false))
                                    intKnowledgePointsValue
                                        += await objLoopKnowledgeSkill.Specializations.CountAsync(x => x.Free, token)
                                                                      .ConfigureAwait(false) *
                                           await objSettings.GetKarmaKnowledgeSpecializationAsync(token)
                                                            .ConfigureAwait(false);
                                else if (!await objLoopKnowledgeSkill.GetBuyWithKarmaAsync(token).ConfigureAwait(false))
                                    intKnowledgePointsValue += objLoopKnowledgeSkill.Specializations.Count *
                                                               await objSettings
                                                                     .GetKarmaKnowledgeSpecializationAsync(token)
                                                                     .ConfigureAwait(false);
                            }
                        }, token).ConfigureAwait(false);

                    if (intKnowledgePointsValue != 0)
                    {
                        sbdMessage.AppendLine().Append(await LanguageManager.GetStringAsync("Label_KnowledgeSkills", strLanguage, token: token).ConfigureAwait(false))
                                  .Append(strColonCharacter).Append(strSpace)
                                  .Append(intKnowledgePointsValue.ToString(objCulture)).Append(strSpace)
                                  .Append(strKarmaString);
                        intReturn += intKnowledgePointsValue;
                        intExtraKarmaToRemoveForPointBuyComparison += intKnowledgePointsValue;
                    }

                    sbdMessage.AppendLine().AppendLine().Append(await LanguageManager.GetStringAsync("String_Total", strLanguage, token: token).ConfigureAwait(false))
                              .Append(strColonCharacter).Append(strSpace)
                              .Append(intReturn.ToString(objCulture))
                              .Append(strSpace).AppendLine(strKarmaString).AppendLine()
                              .Append(await LanguageManager.GetStringAsync("String_TotalComparisonWithPointBuy", strLanguage, token: token).ConfigureAwait(false))
                              .Append(strColonCharacter).Append(strSpace)
                              .Append((intReturn - intExtraKarmaToRemoveForPointBuyComparison).ToString(
                                          objCulture)).Append(strSpace).Append(strKarmaString);

                    return new Tuple<string, int>(sbdMessage.ToString(), intReturn);
                }
            }
        }

        /// <summary>
        /// Creates a list of keywords for each category of an XML node. Used to preselect whether items of that category are discounted by the Black Market Pipeline quality.
        /// </summary>
        public IEnumerable<string> GenerateBlackMarketMappings(XPathNavigator xmlCategoryList, CancellationToken token = default)
        {
            if (xmlCategoryList == null)
                yield break;
            using (EnterReadLock.Enter(LockObject, token))
            {
                // Character has no Black Market discount qualities. Fail out early.
                if (!BlackMarketDiscount)
                    yield break;
                // if the passed list is still the root, assume we're looking for default categories. Special cases like vehicle modcategories are expected to be passed through by the parameter.
                if (xmlCategoryList.Name == "chummer")
                {
                    xmlCategoryList = xmlCategoryList.SelectSingleNodeAndCacheExpression("categories", token);
                    if (xmlCategoryList == null)
                        yield break;
                }

                // Get all the improved names of the Black Market Pipeline improvements. In most cases this should only be 1 item, but supports custom content.
                using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                out HashSet<string> setNames))
                {
                    foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                 this, Improvement.ImprovementType.BlackMarketDiscount, token: token))
                    {
                        setNames.Add(objImprovement.ImprovedName);
                    }

                    // For each category node, split the comma-separated blackmarket attribute (if present on the node), then add each category where any of those items matches a Black Market Pipeline improvement.
                    foreach (XPathNavigator xmlCategoryNode in xmlCategoryList.SelectAndCacheExpression("category", token))
                    {
                        string strBlackMarketAttribute
                            = xmlCategoryNode.SelectSingleNodeAndCacheExpression("@blackmarket", token)?.Value;
                        if (!string.IsNullOrEmpty(strBlackMarketAttribute) &&
                            strBlackMarketAttribute.SplitNoAlloc(',', StringSplitOptions.RemoveEmptyEntries)
                                                   .Any(x => setNames.Contains(x)))
                        {
                            yield return xmlCategoryNode.Value;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Creates a list of keywords for each category of an XML node. Used to preselect whether items of that category are discounted by the Black Market Pipeline quality.
        /// </summary>
        public async ValueTask<List<string>> GenerateBlackMarketMappingsAsync(XPathNavigator xmlCategoryList, CancellationToken token = default)
        {
            List<string> lstReturn = new List<string>();
            if (xmlCategoryList == null)
                return lstReturn;
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                // Character has no Black Market discount qualities. Fail out early.
                if (!BlackMarketDiscount)
                    return lstReturn;
                // if the passed list is still the root, assume we're looking for default categories. Special cases like vehicle modcategories are expected to be passed through by the parameter.
                if (xmlCategoryList.Name == "chummer")
                {
                    xmlCategoryList = await xmlCategoryList.SelectSingleNodeAndCacheExpressionAsync("categories", token).ConfigureAwait(false);
                    if (xmlCategoryList == null)
                        return lstReturn;
                }

                // Get all the improved names of the Black Market Pipeline improvements. In most cases this should only be 1 item, but supports custom content.
                using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                out HashSet<string> setNames))
                {
                    foreach (Improvement objImprovement in await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                 this, Improvement.ImprovementType.BlackMarketDiscount, token: token).ConfigureAwait(false))
                    {
                        setNames.Add(objImprovement.ImprovedName);
                    }

                    // For each category node, split the comma-separated blackmarket attribute (if present on the node), then add each category where any of those items matches a Black Market Pipeline improvement.
                    foreach (XPathNavigator xmlCategoryNode in await xmlCategoryList.SelectAndCacheExpressionAsync("category", token).ConfigureAwait(false))
                    {
                        string strBlackMarketAttribute
                            = (await xmlCategoryNode.SelectSingleNodeAndCacheExpressionAsync("@blackmarket", token).ConfigureAwait(false))?.Value;
                        if (!string.IsNullOrEmpty(strBlackMarketAttribute) &&
                            strBlackMarketAttribute.SplitNoAlloc(',', StringSplitOptions.RemoveEmptyEntries)
                                                   .Any(x => setNames.Contains(x)))
                        {
                            lstReturn.Add(xmlCategoryNode.Value);
                        }
                    }
                }
            }
            return lstReturn;
        }

        /// <summary>
        /// Book code (using the translated version if applicable) using the character's data files.
        /// </summary>
        /// <param name="strAltCode">Book code to search for.</param>
        /// <param name="strLanguage">Language to load.</param>
        public string LanguageBookCodeFromAltCode(string strAltCode, string strLanguage = "")
        {
            return CommonFunctions.LanguageBookCodeFromAltCode(strAltCode, strLanguage, this);
        }

        /// <summary>
        /// Book code (using the translated version if applicable) using the character's data files.
        /// </summary>
        /// <param name="strAltCode">Book code to search for.</param>
        /// <param name="strLanguage">Language to load.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public ValueTask<string> LanguageBookCodeFromAltCodeAsync(string strAltCode, string strLanguage = "", CancellationToken token = default)
        {
            return CommonFunctions.LanguageBookCodeFromAltCodeAsync(strAltCode, strLanguage, this, token);
        }

        /// <summary>
        /// Book code (using the translated version if applicable) using the character's data files.
        /// </summary>
        /// <param name="strCode">Book code to search for.</param>
        /// <param name="strLanguage">Language to load.</param>
        public string LanguageBookShort(string strCode, string strLanguage = "")
        {
            return CommonFunctions.LanguageBookShort(strCode, strLanguage, this);
        }

        /// <summary>
        /// Book code (using the translated version if applicable) using the character's data files.
        /// </summary>
        /// <param name="strCode">Book code to search for.</param>
        /// <param name="strLanguage">Language to load.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public ValueTask<string> LanguageBookShortAsync(string strCode, string strLanguage = "", CancellationToken token = default)
        {
            return CommonFunctions.LanguageBookShortAsync(strCode, strLanguage, this, token);
        }

        /// <summary>
        /// Book name (using the translated version if applicable) using the character's data files.
        /// </summary>
        /// <param name="strCode">Book code to search for.</param>
        /// <param name="strLanguage">Language to load.</param>
        public string LanguageBookLong(string strCode, string strLanguage = "")
        {
            return CommonFunctions.LanguageBookLong(strCode, strLanguage, this);
        }

        /// <summary>
        /// Book name (using the translated version if applicable) using the character's data files.
        /// </summary>
        /// <param name="strCode">Book code to search for.</param>
        /// <param name="strLanguage">Language to load.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public ValueTask<string> LanguageBookLongAsync(string strCode, string strLanguage = "", CancellationToken token = default)
        {
            return CommonFunctions.LanguageBookLongAsync(strCode, strLanguage, this, token);
        }

        /// <summary>
        /// Attempt to translate any Extra text for an item using the character's data files.
        /// </summary>
        /// <param name="strExtra">Extra string to translate.</param>
        /// <param name="strIntoLanguage">Language into which the string should be translated</param>
        /// <param name="strPreferFile">Name of a file to prefer for extras before all others.</param>
        /// <param name="token">CancellationToken to use.</param>
        public string TranslateExtra(string strExtra, string strIntoLanguage = "", string strPreferFile = "", CancellationToken token = default)
        {
            return LanguageManager.TranslateExtra(strExtra, strIntoLanguage, this, strPreferFile, token);
        }

        /// <summary>
        /// Attempt to translate any Extra text for an item using the character's data files.
        /// </summary>
        /// <param name="strExtra">Extra string to translate.</param>
        /// <param name="strIntoLanguage">Language into which the string should be translated</param>
        /// <param name="strPreferFile">Name of a file to prefer for extras before all others.</param>
        /// <param name="token">CancellationToken to use.</param>
        public Task<string> TranslateExtraAsync(string strExtra, string strIntoLanguage = "", string strPreferFile = "", CancellationToken token = default)
        {
            return LanguageManager.TranslateExtraAsync(strExtra, strIntoLanguage, this, strPreferFile, token);
        }

        /// <summary>
        /// Attempt to translate any Extra text for an item from a foreign language to the default one using the character's data files.
        /// </summary>
        /// <param name="strExtra">Extra string to translate.</param>
        /// <param name="strFromLanguage">Language from which the string should be translated</param>
        /// <param name="strPreferFile">Name of a file to prefer for extras before all others.</param>
        /// <param name="token">CancellationToken to use.</param>
        public string ReverseTranslateExtra(string strExtra, string strFromLanguage = "", string strPreferFile = "", CancellationToken token = default)
        {
            return LanguageManager.ReverseTranslateExtra(strExtra, strFromLanguage, this, strPreferFile, token);
        }

        /// <summary>
        /// Attempt to translate any Extra text for an item from a foreign language to the default one using the character's data files.
        /// </summary>
        /// <param name="strExtra">Extra string to translate.</param>
        /// <param name="strFromLanguage">Language from which the string should be translated</param>
        /// <param name="strPreferFile">Name of a file to prefer for extras before all others.</param>
        /// <param name="token">CancellationToken to use.</param>
        public Task<string> ReverseTranslateExtraAsync(string strExtra, string strFromLanguage = "", string strPreferFile = "", CancellationToken token = default)
        {
            return LanguageManager.ReverseTranslateExtraAsync(strExtra, strFromLanguage, this, strPreferFile, token);
        }

        #endregion Helper Methods

        #region UI Methods

        #region Move TreeNodes

        /// <summary>
        /// Move a Gear TreeNode after Drag and Drop, changing its parent.
        /// </summary>
        /// <param name="objGearNode">Node of gear to move.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public void MoveGearParent(TreeNode objDestination, TreeNode objGearNode, CancellationToken token = default)
        {
            if (objGearNode == null || objDestination == null)
                return;
            // The item cannot be dropped onto itself or onto one of its children.
            for (TreeNode objCheckNode = objDestination;
                objCheckNode != null && objCheckNode.Level >= objDestination.Level;
                objCheckNode = objCheckNode.Parent)
                if (objCheckNode == objGearNode)
                    return;
            if (!(objGearNode.Tag is Gear objGear))
                return;

            // Gear cannot be moved to one if its children.
            bool blnAllowMove = true;
            if (objDestination.Level > 0)
            {
                TreeNode objFindNode = objDestination;
                do
                {
                    objFindNode = objFindNode.Parent;
                    if (objFindNode.Tag == objGear)
                    {
                        blnAllowMove = false;
                        break;
                    }
                } while (objFindNode.Level > 0);
            }

            if (!blnAllowMove)
                return;

            using (LockObject.EnterWriteLock(token))
            {
                // Remove the Gear from the character.
                if (objGear.Parent is IHasChildren<Gear> parent)
                    parent.Children.Remove(objGear);
                else
                    Gear.Remove(objGear);

                switch (objDestination.Tag)
                {
                    case Location objLocation:
                        // The Gear was moved to a location, so add it to the character instead.
                        objGear.Location = objLocation;
                        objLocation.Children.Add(objGear);
                        Gear.Add(objGear);
                        break;

                    case Gear objParent:
                        // Add the Gear as a child of the destination Node and clear its location.
                        objGear.Location = null;
                        objParent.Children.Add(objGear);
                        break;
                }
            }
        }

        /// <summary>
        /// Move a Gear TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodeToMove">Node of gear to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public void MoveGearNode(int intNewIndex, TreeNode objDestination, TreeNode nodeToMove, CancellationToken token = default)
        {
            if (objDestination == null || nodeToMove == null)
                return;
            if (!(nodeToMove.Tag is Gear objGear))
                return;
            TreeNode objNewParent = objDestination;
            while (objNewParent.Level > 0 && !(objNewParent.Tag is Location))
                objNewParent = objNewParent.Parent;

            using (LockObject.EnterWriteLock(token))
            {
                switch (objNewParent.Tag)
                {
                    case Location objLocation:
                        nodeToMove.Remove();
                        objGear.Location = objLocation;
                        objNewParent.Nodes.Insert(0, nodeToMove);
                        break;

                    case string _:
                        objGear.Location = null;
                        intNewIndex = Math.Min(intNewIndex, Gear.Count - 1);
                        Gear.Move(Gear.IndexOf(objGear), intNewIndex);
                        break;
                }
            }
        }

        /// <summary>
        /// Move a Gear Location TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodOldNode">Node of gear location to move.</param>
        public void MoveGearRoot(int intNewIndex, TreeNode objDestination, TreeNode nodOldNode)
        {
            if (!(nodOldNode?.Tag is Location objLocation))
                return;
            if (objDestination != null)
            {
                TreeNode objNewParent = objDestination;
                while (objNewParent.Level > 0)
                    objNewParent = objNewParent.Parent;
                intNewIndex = objNewParent.Index;
                if (!(objNewParent.Tag is Location))
                    intNewIndex = 0;
            }
            GearLocations.Move(GearLocations.IndexOf(objLocation), intNewIndex);
        }

        /// <summary>
        /// Move a Lifestyle TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodLifestyleNode">Node of lifestyle to move.</param>
        public void MoveLifestyleNode(int intNewIndex, TreeNode objDestination, TreeNode nodLifestyleNode)
        {
            if (nodLifestyleNode == null)
                return;
            if (objDestination != null)
            {
                TreeNode objNewParent = objDestination;
                while (objNewParent.Level > 0)
                    objNewParent = objNewParent.Parent;
                intNewIndex = objNewParent.Index;
            }

            if (!(nodLifestyleNode.Tag is Lifestyle objLifestyle))
                return;
            Lifestyles.Move(Lifestyles.IndexOf(objLifestyle), intNewIndex);
        }

        /// <summary>
        /// Move an Armor TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodeToMove">Node of armor to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public void MoveArmorNode(int intNewIndex, TreeNode objDestination, TreeNode nodeToMove, CancellationToken token = default)
        {
            if (objDestination == null)
                return;
            if (!(nodeToMove?.Tag is Armor objArmor))
                return;
            TreeNode objNewParent = objDestination;
            while (objNewParent.Level > 0 && !(objNewParent.Tag is Location))
                objNewParent = objNewParent.Parent;

            using (LockObject.EnterWriteLock(token))
            {
                switch (objNewParent.Tag)
                {
                    case Location objLocation:
                        nodeToMove.Remove();
                        objArmor.Location = objLocation;
                        objNewParent.Nodes.Insert(0, nodeToMove);
                        break;

                    case string _:
                        objArmor.Location = null;
                        intNewIndex = Math.Min(intNewIndex, Armor.Count - 1);
                        Armor.Move(Armor.IndexOf(objArmor), intNewIndex);
                        break;
                }
            }
        }

        /// <summary>
        /// Move an Armor Location TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodOldNode">Node of armor location to move.</param>
        public void MoveArmorRoot(int intNewIndex, TreeNode objDestination, TreeNode nodOldNode)
        {
            if (!(nodOldNode?.Tag is Location objLocation))
                return;
            if (objDestination != null)
            {
                TreeNode objNewParent = objDestination;
                while (objNewParent.Level > 0)
                    objNewParent = objNewParent.Parent;
                intNewIndex = objNewParent.Index;
                if (!(objNewParent.Tag is Location))
                    intNewIndex = 0;
            }
            ArmorLocations.Move(ArmorLocations.IndexOf(objLocation), intNewIndex);
        }

        /// <summary>
        /// Move a Weapon TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodeToMove">Node of weapon to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public void MoveWeaponNode(int intNewIndex, TreeNode objDestination, TreeNode nodeToMove, CancellationToken token = default)
        {
            if (objDestination == null)
                return;
            if (!(nodeToMove?.Tag is Weapon objWeapon))
                return;
            TreeNode objNewParent = objDestination;
            while (objNewParent.Level > 0 && !(objNewParent.Tag is Location))
                objNewParent = objNewParent.Parent;

            using (LockObject.EnterWriteLock(token))
            {
                switch (objNewParent.Tag)
                {
                    case Location objLocation:
                        nodeToMove.Remove();
                        objWeapon.Location = objLocation;
                        objNewParent.Nodes.Insert(0, nodeToMove);
                        break;

                    case string _:
                        objWeapon.Location = null;
                        intNewIndex = Math.Min(intNewIndex, Weapons.Count - 1);
                        Weapons.Move(Weapons.IndexOf(objWeapon), intNewIndex);
                        break;
                }
            }
        }

        /// <summary>
        /// Move a Weapon Location TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodOldNode">Node of weapon location to move.</param>
        public void MoveWeaponRoot(int intNewIndex, TreeNode objDestination, TreeNode nodOldNode)
        {
            if (!(nodOldNode?.Tag is Location objLocation))
                return;
            if (objDestination != null)
            {
                TreeNode objNewParent = objDestination;
                while (objNewParent.Level > 0)
                    objNewParent = objNewParent.Parent;
                intNewIndex = objNewParent.Index;
                if (!(objNewParent.Tag is Location))
                    intNewIndex = 0;
            }
            WeaponLocations.Move(WeaponLocations.IndexOf(objLocation), intNewIndex);
        }

        /// <summary>
        /// Move a Vehicle TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodeToMove">Node of vehicle to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public void MoveVehicleNode(int intNewIndex, TreeNode objDestination, TreeNode nodeToMove, CancellationToken token = default)
        {
            if (objDestination == null)
                return;
            if (!(nodeToMove?.Tag is Vehicle objVehicle))
                return;
            TreeNode objNewParent = objDestination;
            while (objNewParent.Level > 0 && !(objNewParent.Tag is Location))
                objNewParent = objNewParent.Parent;

            using (LockObject.EnterWriteLock(token))
            {
                switch (objNewParent.Tag)
                {
                    case Location objLocation:
                        nodeToMove.Remove();
                        objVehicle.Location = objLocation;
                        objNewParent.Nodes.Insert(0, nodeToMove);
                        break;

                    case string _:
                        objVehicle.Location = null;
                        intNewIndex = Math.Min(intNewIndex, Weapons.Count - 1);
                        Vehicles.Move(Vehicles.IndexOf(objVehicle), intNewIndex);
                        break;
                }
            }
        }

        /// <summary>
        /// Move a Vehicle Gear TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="nodDestination">Destination Node.</param>
        /// <param name="nodGearNode">Node of gear to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public void MoveVehicleGearParent(TreeNode nodDestination, TreeNode nodGearNode, CancellationToken token = default)
        {
            if (nodDestination == null || nodGearNode == null)
                return;
            // The item cannot be dropped onto itself or onto one of its children.
            for (TreeNode objCheckNode = nodDestination;
                objCheckNode != null && objCheckNode.Level >= nodDestination.Level;
                objCheckNode = objCheckNode.Parent)
                if (objCheckNode == nodGearNode)
                    return;
            if (!(nodGearNode.Tag is IHasInternalId nodeId))
                return;
            using (EnterReadLock.Enter(LockObject, token))
            {
                // Locate the currently selected piece of Gear.
                //TODO: Better interface for determining what the parent of a bit of gear is.
                Gear objGear = Vehicles.FindVehicleGear(nodeId.InternalId, out Vehicle objOldVehicle,
                                                        out WeaponAccessory objOldWeaponAccessory,
                                                        out Cyberware objOldCyberware);

                if (objGear == null)
                    return;

                using (LockObject.EnterWriteLock(token))
                {
                    if (nodDestination.Tag is Gear objDestinationGear)
                    {
                        // Remove the Gear from the Vehicle.
                        if (objGear.Parent is IHasChildren<Gear> parent)
                            parent.Children.Remove(objGear);
                        else if (objOldCyberware != null)
                            objOldCyberware.GearChildren.Remove(objGear);
                        else if (objOldWeaponAccessory != null)
                            objOldWeaponAccessory.GearChildren.Remove(objGear);
                        else
                            objOldVehicle.GearChildren.Remove(objGear);

                        // Add the Gear to its new parent.
                        objGear.Location = null;
                        objDestinationGear.Children.Add(objGear);
                    }
                    else
                    {
                        // Determine if this is a Location.
                        TreeNode nodVehicleNode = nodDestination;
                        Location objLocation = null;
                        while (nodVehicleNode.Level > 1)
                        {
                            if (objLocation is null && nodVehicleNode.Tag is Location loc)
                            {
                                objLocation = loc;
                            }

                            nodVehicleNode = nodVehicleNode.Parent;
                        }

                        // Determine if this is a Location in the destination Vehicle.
                        if (nodDestination.Tag is Vehicle objNewVehicle)
                        {
                            // Remove the Gear from the Vehicle.
                            if (objGear.Parent is IHasChildren<Gear> parent)
                                parent.Children.Remove(objGear);
                            else if (objOldCyberware != null)
                                objOldCyberware.GearChildren.Remove(objGear);
                            else if (objOldWeaponAccessory != null)
                                objOldWeaponAccessory.GearChildren.Remove(objGear);
                            else
                                objOldVehicle.GearChildren.Remove(objGear);

                            // Add the Gear to the Vehicle and set its Location.
                            objGear.Parent = objNewVehicle;
                            objNewVehicle.GearChildren.Add(objGear);
                            objLocation?.Children.Add(objGear);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Move an Improvement TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodOldNode">Node of improvement to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public void MoveImprovementNode(TreeNode objDestination, TreeNode nodOldNode, CancellationToken token = default)
        {
            if (objDestination == null)
                return;
            if (!(nodOldNode?.Tag is Improvement objImprovement))
                return;
            TreeNode objNewParent = objDestination;
            while (objNewParent.Level > 0)
                objNewParent = objNewParent.Parent;

            using (LockObject.EnterWriteLock(token))
            {
                objImprovement.CustomGroup = objNewParent.Tag.ToString() == "Node_SelectedImprovements"
                    ? string.Empty
                    : objNewParent.Text;
                Improvements[Improvements.IndexOf(objImprovement)] = objImprovement;
            }
        }

        /// <summary>
        /// Move an Improvement Group TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodOldNode">Node of improvement group to move.</param>
        public void MoveImprovementRoot(int intNewIndex, TreeNode objDestination, TreeNode nodOldNode)
        {
            if (nodOldNode == null)
                return;
            if (objDestination != null)
            {
                TreeNode objNewParent = objDestination;
                while (objNewParent.Level > 0)
                    objNewParent = objNewParent.Parent;
                intNewIndex = objNewParent.Index;
                if (!ImprovementGroups.Contains(objNewParent.Tag?.ToString()))
                    intNewIndex = 0;
            }

            string strLocation = nodOldNode.Tag.ToString();
            ImprovementGroups.Move(ImprovementGroups.IndexOf(strLocation), intNewIndex);
        }

        #endregion Move TreeNodes

        #region Tab clearing

        /// <summary>
        /// Clear all Spell tab elements from the character.
        /// </summary>
        public void ClearMagic(bool blnKeepAdeptEligible, CancellationToken token = default)
        {
            using (EnterReadLock.Enter(LockObject, token))
            {
                if (ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.FreeSpells, token: token)
                        .Count > 0
                    || ImprovementManager
                        .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.FreeSpellsATT, token: token).Count > 0
                    || ImprovementManager
                        .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.FreeSpellsSkill, token: token).Count >
                    0)
                {
                    // Run through all of the Spells and remove their Improvements.
                    using (LockObject.EnterWriteLock(token))
                    {
                        for (int i = Spells.Count - 1; i >= 0; --i)
                        {
                            if (i < Spells.Count)
                            {
                                Spell objToRemove = Spells[i];
                                if (objToRemove.Grade == 0)
                                {
                                    if (blnKeepAdeptEligible && objToRemove.Category == "Rituals" &&
                                        !objToRemove.Descriptors.Contains("Spell"))
                                        continue;
                                    // Remove the Improvements created by the Spell.
                                    ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Spell,
                                        objToRemove.InternalId, token: token);
                                    Spells.RemoveAt(i);
                                }
                            }
                        }
                    }
                }

                using (LockObject.EnterWriteLock(token))
                {
                    for (int i = Spirits.Count - 1; i >= 0; --i)
                    {
                        if (i < Spirits.Count)
                        {
                            Spirit objToRemove = Spirits[i];
                            if (objToRemove.EntityType == SpiritType.Spirit)
                            {
                                Spirits.RemoveAt(i);
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Clear all Adept tab elements from the character.
        /// </summary>
        public void ClearAdeptPowers(CancellationToken token = default)
        {
            using (LockObject.EnterWriteLock(token))
            {
                // Run through all powers and remove the ones not added by improvements or foci
                for (int i = Powers.Count - 1; i >= 0; --i)
                {
                    if (i < Powers.Count)
                    {
                        Power objToRemove = Powers[i];
                        if (objToRemove.FreeLevels == 0 && objToRemove.FreePoints == 0)
                        {
                            // Remove the Improvements created by the Power.
                            ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Power,
                                objToRemove.InternalId, token: token);
                            Powers.RemoveAt(i);
                        }
                        else
                            objToRemove.Rating = 0;
                    }
                }
            }
        }

        /// <summary>
        /// Clear all Technomancer tab elements from the character.
        /// </summary>
        public void ClearResonance(CancellationToken token = default)
        {
            using (LockObject.EnterWriteLock(token))
            {
                // Run through all of the Complex Forms and remove their Improvements.
                for (int i = ComplexForms.Count - 1; i >= 0; --i)
                {
                    if (i < ComplexForms.Count)
                    {
                        ComplexForm objToRemove = ComplexForms[i];
                        if (objToRemove.Grade == 0)
                        {
                            // Remove the Improvements created by the Spell.
                            ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.ComplexForm,
                                objToRemove.InternalId, token: token);
                            ComplexForms.RemoveAt(i);
                        }
                    }
                }

                for (int i = Spirits.Count - 1; i >= 0; --i)
                {
                    if (i < Spirits.Count)
                    {
                        Spirit objToRemove = Spirits[i];
                        if (objToRemove.EntityType == SpiritType.Sprite)
                        {
                            Spirits.RemoveAt(i);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Clear all Advanced Programs tab elements from the character.
        /// </summary>
        public void ClearAdvancedPrograms(CancellationToken token = default)
        {
            using (LockObject.EnterWriteLock(token))
            {
                // Run through all advanced programs and remove the ones not added by improvements
                for (int i = AIPrograms.Count - 1; i >= 0; --i)
                {
                    if (i < AIPrograms.Count)
                    {
                        AIProgram objToRemove = AIPrograms[i];
                        if (objToRemove.CanDelete)
                        {
                            // Remove the Improvements created by the Program.
                            ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.AIProgram,
                                objToRemove.InternalId, token: token);
                            AIPrograms.RemoveAt(i);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Clear all cyberware and bioware implanted on the character.
        /// </summary>
        public void ClearCyberwareTab(CancellationToken token = default)
        {
            using (EnterReadLock.Enter(LockObject, token))
            {
                string strDisabledSource = string.Empty;
                if (Created)
                {
                    Improvement objDisablingImprovement = ImprovementManager
                        .GetCachedImprovementListForValueOf(
                            this,
                            Improvement.ImprovementType.SpecialTab,
                            "Cyberware", token: token)
                        .Find(x => x.UniqueName == "disabletab");
                    if (objDisablingImprovement != null)
                    {
                        strDisabledSource = LanguageManager.GetString("String_Space", token: token) +
                                            '(' + GetObjectName(objDisablingImprovement, GlobalSettings.Language, token: token) +
                                            ')' +
                                            LanguageManager.GetString("String_Space", token: token);
                    }
                }

                using (LockObject.EnterWriteLock(token))
                {
                    foreach (Cyberware objCyberware in Cyberware
                                 .Where(x => x.SourceID != Backend.Equipment.Cyberware.EssenceHoleGUID
                                             && x.SourceID != Backend.Equipment.Cyberware
                                                 .EssenceAntiHoleGUID && x.IsModularCurrentlyEquipped)
                                 .ToList())
                    {
                        if (!string.IsNullOrEmpty(objCyberware.PlugsIntoModularMount))
                        {
                            if (objCyberware.CanRemoveThroughImprovements)
                            {
                                objCyberware.Parent?.Children.Remove(objCyberware);
                                Cyberware.Add(objCyberware);
                                objCyberware.ChangeModularEquip(false);
                            }
                        }
                        else if (objCyberware.CanRemoveThroughImprovements)
                        {
                            objCyberware.DeleteCyberware();
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(this);
                            string strEntry = LanguageManager.GetString(
                                objCyberware.SourceType == Improvement.ImprovementSource.Cyberware
                                    ? "String_ExpenseSoldCyberware"
                                    : "String_ExpenseSoldBioware", token: token);
                            objExpense.Create(0,
                                strEntry + strDisabledSource
                                         + objCyberware.CurrentDisplayNameShort,
                                ExpenseType.Nuyen, DateTime.Now);
                            ExpenseEntries.AddWithSort(objExpense, token: token);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Clear all Critter tab elements from the character.
        /// </summary>
        public void ClearCritterPowers(CancellationToken token = default)
        {
            using (LockObject.EnterWriteLock(token))
            {
                for (int i = CritterPowers.Count - 1; i >= 0; --i)
                {
                    if (i < CritterPowers.Count)
                    {
                        CritterPower objToRemove = CritterPowers[i];
                        if (objToRemove.Grade >= 0)
                        {
                            // Remove the Improvements created by the Metamagic.
                            ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.CritterPower,
                                objToRemove.InternalId, token: token);
                            CritterPowers.RemoveAt(i);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Clear all Initiation tab elements from the character that were not added by improvements.
        /// </summary>
        public void ClearInitiations(CancellationToken token = default)
        {
            using (LockObject.EnterWriteLock(token))
            {
                // Do not update grade numbers until after we're done processing everything
                _blnClearingInitiations = true;
                try
                {
                    // We need to remove grades that can potentially add stuff that adds grades, so we cannot use foreach
                    for (int i = InitiationGrades.Count - 1; i >= 0; --i)
                    {
                        InitiationGrades[i].Remove(false, false);
                    }
                }
                finally
                {
                    _blnClearingInitiations = false;
                }

                // Now update our grade numbers
                InitiateGrade = 0;
                SubmersionGrade = 0;
            }
        }

        /// <summary>
        /// Clear all Initiation tab elements from the character that were not added by improvements.
        /// </summary>
        public async ValueTask ClearInitiationsAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                // Do not update grade numbers until after we're done processing everything
                _blnClearingInitiations = true;
                try
                {
                    // We need to remove grades that can potentially add stuff that adds grades, so we cannot use foreach
                    for (int i = await InitiationGrades.GetCountAsync(token).ConfigureAwait(false) - 1; i >= 0; --i)
                    {
                        await (await InitiationGrades.GetValueAtAsync(i, token).ConfigureAwait(false))
                              .RemoveAsync(false, false, token).ConfigureAwait(false);
                    }
                }
                finally
                {
                    _blnClearingInitiations = false;
                }

                // Now update our grade numbers
                await SetInitiateGradeAsync(0, token).ConfigureAwait(false);
                await SetSubmersionGradeAsync(0, token).ConfigureAwait(false);
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        #endregion Tab clearing

        #endregion UI Methods

        #region Basic Properties

        private CharacterSettings _objSettings;

        /// <summary>
        /// Character Settings object.
        /// </summary>
        public CharacterSettings Settings
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _objSettings;
            }
            private set // Private to make sure this is always in sync with GameplayOption
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    value?.LockObject.EnterReadLock();
                    try
                    {
                        CharacterSettings objOldSettings = Interlocked.Exchange(ref _objSettings, value);
                        objOldSettings?.LockObject.EnterReadLock();
                        try
                        {
                            if (ReferenceEquals(objOldSettings, value))
                                return;
                            bool blnActuallyDifferentSettings = true;
                            if (objOldSettings != null)
                            {
                                blnActuallyDifferentSettings = !objOldSettings.HasIdenticalSettings(value);
                                using (objOldSettings.LockObject.EnterWriteLock())
                                    objOldSettings.PropertyChanged -= OptionsOnPropertyChanged;
                            }

                            if (value != null)
                            {
                                using (value.LockObject.EnterWriteLock())
                                    value.PropertyChanged += OptionsOnPropertyChanged;
                            }

                            if (!blnActuallyDifferentSettings || IsLoading)
                                return;
                            OnPropertyChanged();
                            if (value != null)
                            {
                                Utils.SafelyRunSynchronously(async () =>
                                {
                                    foreach (string strProperty in await value.GetDifferingPropertyNamesAsync(objOldSettings).ConfigureAwait(false))
                                        await DoOptionsOnPropertyChanged(
                                                this, new PropertyChangedEventArgs(strProperty))
                                            .ConfigureAwait(false);
                                });
                            }
                            else
                            {
                                Utils.SafelyRunSynchronously(async () =>
                                {
                                    foreach (string strProperty in await objOldSettings.GetDifferingPropertyNamesAsync(null).ConfigureAwait(false))
                                        await DoOptionsOnPropertyChanged(
                                                this, new PropertyChangedEventArgs(strProperty))
                                            .ConfigureAwait(false);
                                });
                            }
                        }
                        finally
                        {
                            objOldSettings?.LockObject.ExitReadLock();
                        }
                    }
                    finally
                    {
                        value?.LockObject.ExitReadLock();
                    }
                }
            }
        }

        /// <summary>
        /// Character Settings object.
        /// </summary>
        public async ValueTask<CharacterSettings> GetSettingsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _objSettings;
        }

        /// <summary>
        /// Character Settings object.
        /// </summary>
        private async ValueTask SetSettingsAsync(CharacterSettings value, CancellationToken token = default) // Private to make sure this is always in sync with GameplayOption
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (value != null)
                    await value.LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
                try
                {
                    CharacterSettings objOldSettings = Interlocked.Exchange(ref _objSettings, value);
                    if (objOldSettings != null)
                        await objOldSettings.LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
                    try
                    {
                        if (ReferenceEquals(objOldSettings, value))
                            return;
                        bool blnActuallyDifferentSettings = true;
                        if (objOldSettings != null)
                        {
                            blnActuallyDifferentSettings = !await objOldSettings.HasIdenticalSettingsAsync(value, token)
                                .ConfigureAwait(false);
                            IAsyncDisposable objLocker = await objOldSettings.LockObject.EnterWriteLockAsync(token)
                                                                             .ConfigureAwait(false);
                            try
                            {
                                objOldSettings.PropertyChanged -= OptionsOnPropertyChanged;
                            }
                            finally
                            {
                                await objLocker.DisposeAsync().ConfigureAwait(false);
                            }
                        }

                        if (value != null)
                        {
                            IAsyncDisposable objLocker
                                = await value.LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                            try
                            {
                                value.PropertyChanged += OptionsOnPropertyChanged;
                            }
                            finally
                            {
                                await objLocker.DisposeAsync().ConfigureAwait(false);
                            }
                        }

                        if (!blnActuallyDifferentSettings || IsLoading)
                            return;
                        OnPropertyChanged();
                        if (value != null)
                        {
                            foreach (string strProperty in await value.GetDifferingPropertyNamesAsync(objOldSettings, token).ConfigureAwait(false))
                                await DoOptionsOnPropertyChanged(this, new PropertyChangedEventArgs(strProperty))
                                    .ConfigureAwait(false);
                        }
                        else
                        {
                            foreach (string strProperty in await objOldSettings.GetDifferingPropertyNamesAsync(null, token).ConfigureAwait(false))
                                await DoOptionsOnPropertyChanged(this, new PropertyChangedEventArgs(strProperty))
                                    .ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        objOldSettings?.LockObject.ExitReadLock();
                    }
                }
                finally
                {
                    value?.LockObject.ExitReadLock();
                }
            }
        }

        /// <summary>
        /// Name of the file the Character is saved to.
        /// </summary>
        public string FileName
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strFileName;
            }
            set
            {
                if (!string.IsNullOrWhiteSpace(value)
                    && !value.EndsWith(".chum5", StringComparison.OrdinalIgnoreCase)
                    && !value.EndsWith(".chum5lz", StringComparison.OrdinalIgnoreCase))
                {
                    value = Path.GetFileNameWithoutExtension(value) + ".chum5";
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!string.IsNullOrWhiteSpace(_strFileName)
                            && _strFileName.EndsWith(".chum5lz", StringComparison.OrdinalIgnoreCase))
                            value += "lz";
                    }
                }

                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _strFileName, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Last write time of the file to which this character is saved.
        /// </summary>
        public DateTime FileLastWriteTime
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _dateFileLastWriteTime > DateTime.MinValue ? _dateFileLastWriteTime : DateTime.UtcNow;
            }
        }

        /// <summary>
        /// Whether or not the character has been saved as Created and can no longer be modified using the Build system.
        /// </summary>
        [HubTag]
        public bool Created
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnCreated;
            }
        }

        public void SetCreated(bool value, bool blnDoOnPropertyChanged = true)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (_blnCreated == value)
                    return;
                using (LockObject.EnterWriteLock())
                {
                    _blnCreated = value;
                    if (blnDoOnPropertyChanged)
                        OnPropertyChanged();
                }
            }
        }

        public async ValueTask SetCreatedAsync(bool value, bool blnDoOnPropertyChanged = true,
                                               CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (_blnCreated == value)
                    return;
                IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    _blnCreated = value;
                    if (blnDoOnPropertyChanged)
                        OnPropertyChanged();
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
        }

        public async ValueTask<bool> GetCreatedAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _blnCreated;
        }

        /// <summary>
        /// Character's name.
        /// </summary>
        [HubTag]
        public string Name
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strName;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _strName, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's name.
        /// </summary>
        public async ValueTask<string> GetNameAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _strName;
        }

        /// <summary>
        /// Character's portraits encoded using Base64.
        /// </summary>
        public ThreadSafeList<Image> Mugshots
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstMugshots;
            }
        }

        /// <summary>
        /// Character's main portrait encoded using Base64.
        /// </summary>
        public Image MainMugshot
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (MainMugshotIndex >= Mugshots.Count || MainMugshotIndex < 0)
                        return null;

                    return Mugshots[MainMugshotIndex];
                }
            }
            set
            {
                if (value == null)
                {
                    MainMugshotIndex = -1;
                    return;
                }

                using (EnterReadLock.Enter(LockObject))
                {
                    int intNewMainMugshotIndex = Mugshots.IndexOf(value);
                    if (intNewMainMugshotIndex != -1)
                    {
                        MainMugshotIndex = intNewMainMugshotIndex;
                    }
                    else
                    {
                        using (EnterReadLock.Enter(Mugshots))
                        {
                            using (LockObject.EnterWriteLock())
                                Mugshots.Add(value);
                            MainMugshotIndex = Mugshots.IndexOf(value);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Index of Character's main portrait. -1 if set to none.
        /// </summary>
        public int MainMugshotIndex
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intMainMugshotIndex;
            }
            set
            {
                if (value < -1)
                    value = -1;

                using (EnterReadLock.Enter(LockObject))
                {
                    if (value >= Mugshots.Count)
                        value = -1;
                    if (Interlocked.Exchange(ref _intMainMugshotIndex, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        public void SaveMugshots(XmlWriter objWriter, CancellationToken token = default)
        {
            Utils.SafelyRunSynchronously(() => SaveMugshotsCore(true, objWriter, token), token);
        }

        public Task SaveMugshotsAsync(XmlWriter objWriter, CancellationToken token = default)
        {
            return SaveMugshotsCore(false, objWriter, token);
        }

        public async Task SaveMugshotsCore(bool blnSync, XmlWriter objWriter, CancellationToken token = default)
        {
            if (objWriter == null)
                return;

            // ReSharper disable once MethodHasAsyncOverload
            using (blnSync ? EnterReadLock.Enter(LockObject, token) : await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (blnSync)
                {
                    objWriter.WriteElementString("mainmugshotindex",
                                                 MainMugshotIndex.ToString(GlobalSettings.InvariantCultureInfo));
                    // <mugshot>
                    // ReSharper disable once MethodHasAsyncOverload
                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                    using (objWriter.StartElement("mugshots"))
                    {
                        foreach (Image imgMugshot in Mugshots)
                        {
                            // ReSharper disable once MethodHasAsyncOverload
                            objWriter.WriteElementString(
                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                "mugshot", GlobalSettings.ImageToBase64StringForStorage(imgMugshot));
                        }
                    }
                    // </mugshot>
                }
                else
                {
                    await objWriter.WriteElementStringAsync("mainmugshotindex",
                                                            MainMugshotIndex.ToString(
                                                                GlobalSettings.InvariantCultureInfo), token: token).ConfigureAwait(false);
                    // <mugshots>
                    XmlElementWriteHelper objBaseElement = await objWriter.StartElementAsync("mugshots", token: token).ConfigureAwait(false);
                    try
                    {
                        foreach (Image imgMugshot in Mugshots)
                        {
                            await objWriter.WriteElementStringAsync(
                                "mugshot", await GlobalSettings.ImageToBase64StringForStorageAsync(imgMugshot, token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        // </mugshots>
                        await objBaseElement.DisposeAsync().ConfigureAwait(false);
                    }
                }
            }
        }

        public void LoadMugshots(XPathNavigator xmlSavedNode, CancellationToken token = default)
        {
            // Mugshots
            using (LockObject.EnterWriteLock(token))
            {
                xmlSavedNode.TryGetInt32FieldQuickly("mainmugshotindex", ref _intMainMugshotIndex);
                XPathNodeIterator xmlMugshotsList = xmlSavedNode.SelectAndCacheExpression("mugshots/mugshot", token);
                List<string> lstMugshotsBase64 = new List<string>(xmlMugshotsList.Count);
                foreach (XPathNavigator objXmlMugshot in xmlMugshotsList)
                {
                    string strMugshot = objXmlMugshot.Value;
                    if (!string.IsNullOrWhiteSpace(strMugshot))
                    {
                        lstMugshotsBase64.Add(strMugshot);
                    }
                }

                if (lstMugshotsBase64.Count > 1)
                {
                    Image[] objMugshotImages = new Image[lstMugshotsBase64.Count];
                    Parallel.For(0, lstMugshotsBase64.Count,
                                 i => objMugshotImages[i] = lstMugshotsBase64[i].ToImage(PixelFormat.Format32bppPArgb));
                    _lstMugshots.AddRange(objMugshotImages);
                }
                else if (lstMugshotsBase64.Count == 1)
                {
                    _lstMugshots.Add(lstMugshotsBase64[0].ToImage(PixelFormat.Format32bppPArgb));
                }

                // Legacy Shimmer
                if (Mugshots.Count == 0)
                {
                    XPathNavigator objOldMugshotNode = xmlSavedNode.SelectSingleNodeAndCacheExpression("mugshot", token);
                    string strMugshot = objOldMugshotNode?.Value;
                    if (!string.IsNullOrWhiteSpace(strMugshot))
                    {
                        _lstMugshots.Add(strMugshot.ToImage(PixelFormat.Format32bppPArgb));
                        _intMainMugshotIndex = 0;
                    }
                }
            }
        }

        public async Task LoadMugshotsAsync(XPathNavigator xmlSavedNode, CancellationToken token = default)
        {
            // Mugshots
            IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                xmlSavedNode.TryGetInt32FieldQuickly("mainmugshotindex", ref _intMainMugshotIndex);
                XPathNodeIterator xmlMugshotsList = await xmlSavedNode.SelectAndCacheExpressionAsync("mugshots/mugshot", token).ConfigureAwait(false);
                List<string> lstMugshotsBase64 = new List<string>(xmlMugshotsList.Count);
                foreach (XPathNavigator objXmlMugshot in xmlMugshotsList)
                {
                    string strMugshot = objXmlMugshot.Value;
                    if (!string.IsNullOrWhiteSpace(strMugshot))
                    {
                        lstMugshotsBase64.Add(strMugshot);
                    }
                }

                if (lstMugshotsBase64.Count > 1)
                {
                    Task<Bitmap>[] atskMugshotImages = new Task<Bitmap>[lstMugshotsBase64.Count];
                    for (int i = 0; i < lstMugshotsBase64.Count; ++i)
                    {
                        int iLocal = i;
                        atskMugshotImages[i]
                            = Task.Run(() => lstMugshotsBase64[iLocal].ToImageAsync(PixelFormat.Format32bppPArgb, token).AsTask(), token);
                    }
                    await _lstMugshots.AddRangeAsync(await Task.WhenAll(atskMugshotImages).ConfigureAwait(false), token).ConfigureAwait(false);
                }
                else if (lstMugshotsBase64.Count == 1)
                {
                    await _lstMugshots.AddAsync(await lstMugshotsBase64[0].ToImageAsync(PixelFormat.Format32bppPArgb, token).ConfigureAwait(false), token).ConfigureAwait(false);
                }

                // Legacy Shimmer
                if (await Mugshots.GetCountAsync(token).ConfigureAwait(false) == 0)
                {
                    XPathNavigator objOldMugshotNode = await xmlSavedNode.SelectSingleNodeAndCacheExpressionAsync("mugshot", token).ConfigureAwait(false);
                    string strMugshot = objOldMugshotNode?.Value;
                    if (!string.IsNullOrWhiteSpace(strMugshot))
                    {
                        await _lstMugshots.AddAsync(await strMugshot.ToImageAsync(PixelFormat.Format32bppPArgb, token).ConfigureAwait(false), token).ConfigureAwait(false);
                        _intMainMugshotIndex = 0;
                    }
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        public async ValueTask PrintMugshots(XmlWriter objWriter, CancellationToken token = default)
        {
            if (objWriter == null)
                return;
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (Mugshots.Count > 0)
                {
                    // Since IE is retarded and can't handle base64 images before IE9, the image needs to be dumped to a temporary directory and its information rewritten.
                    // If you give it an extension of jpg, gif, or png, it expects the file to be in that format and won't render the image unless it was originally that type.
                    // But if you give it the extension img, it will render whatever you give it (which doesn't make any damn sense, but that's IE for you).
                    string strMugshotsDirectoryPath = Path.Combine(Utils.GetStartupPath, "mugshots");
                    if (!Directory.Exists(strMugshotsDirectoryPath))
                    {
                        try
                        {
                            Directory.CreateDirectory(strMugshotsDirectoryPath);
                        }
                        catch (UnauthorizedAccessException)
                        {
                            Program.ShowScrollableMessageBox(
                                await LanguageManager.GetStringAsync("Message_Insufficient_Permissions_Warning", token: token).ConfigureAwait(false));
                        }
                    }

                    Guid guiImage = Guid.NewGuid();
                    Image imgMainMugshot = MainMugshot;
                    if (imgMainMugshot != null)
                    {
                        string imgMugshotPath = Path.Combine(strMugshotsDirectoryPath,
                                                             guiImage.ToString("N", GlobalSettings.InvariantCultureInfo)
                                                             + ".jpg");
                        imgMainMugshot.Save(imgMugshotPath);
                        // <mainmugshotpath />
                        await objWriter.WriteElementStringAsync("mainmugshotpath",
                                                                "file://" + imgMugshotPath.Replace(
                                                                    Path.DirectorySeparatorChar, '/'), token: token).ConfigureAwait(false);
                        // <mainmugshotbase64 />
                        await objWriter.WriteElementStringAsync("mainmugshotbase64", await imgMainMugshot.ToBase64StringAsJpegAsync(token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                    }

                    // <othermugshots>
                    await objWriter.WriteElementStringAsync("hasothermugshots",
                                                            (imgMainMugshot == null || Mugshots.Count > 1).ToString(
                                                                GlobalSettings.InvariantCultureInfo), token: token).ConfigureAwait(false);

                    // <othermugshots>
                    XmlElementWriteHelper objOtherMugshotsElement = await objWriter.StartElementAsync("othermugshots", token: token).ConfigureAwait(false);
                    try
                    {
                        for (int i = 0; i < Mugshots.Count; ++i)
                        {
                            if (i == MainMugshotIndex)
                                continue;
                            Image imgMugshot = Mugshots[i];

                            // <mugshot>
                            XmlElementWriteHelper objMugshotElement = await objWriter.StartElementAsync("mugshot", token: token).ConfigureAwait(false);
                            try
                            {
                                await objWriter.WriteElementStringAsync(
                                    "stringbase64", await imgMugshot.ToBase64StringAsJpegAsync(token: token).ConfigureAwait(false),
                                    token: token).ConfigureAwait(false);

                                string imgMugshotPath = Path.Combine(strMugshotsDirectoryPath,
                                                                     guiImage.ToString("N", GlobalSettings.InvariantCultureInfo)
                                                                     +
                                                                     i.ToString(GlobalSettings.InvariantCultureInfo) + ".jpg");
                                imgMugshot.Save(imgMugshotPath);
                                await objWriter.WriteElementStringAsync("temppath",
                                                                        "file://" + imgMugshotPath.Replace(
                                                                            Path.DirectorySeparatorChar, '/'), token: token).ConfigureAwait(false);
                            }
                            finally
                            {
                                // </mugshot>
                                await objMugshotElement.DisposeAsync().ConfigureAwait(false);
                            }
                        }
                    }
                    finally
                    {
                        // </othermugshots>
                        await objOtherMugshotsElement.DisposeAsync().ConfigureAwait(false);
                    }
                }
            }
        }

        /// <summary>
        /// Character's Gameplay Option.
        /// </summary>
        [HubTag]
        public string SettingsKey
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strSettingsKey;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strSettingsKey == value)
                        return;
                    if (!SettingsManager.LoadedCharacterSettings.TryGetValue(
                            value, out CharacterSettings objNewSettings))
                        throw new InvalidOperationException(nameof(SettingsKey));
                    using (LockObject.EnterWriteLock())
                    {
                        if (Interlocked.Exchange(ref _strSettingsKey, value) == value)
                            return;
                        Settings = objNewSettings;
                    }
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Gameplay Option.
        /// </summary>
        public async ValueTask<string> GetSettingsKeyAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _strSettingsKey;
        }

        public async Task SetSettingsKeyAsync(string value, CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (_strSettingsKey == value)
                    return;
                (bool blnSuccess, CharacterSettings objNewSettings)
                    = await SettingsManager.LoadedCharacterSettings.TryGetValueAsync(value, token).ConfigureAwait(false);
                if (!blnSuccess)
                    throw new InvalidOperationException(nameof(SettingsKey));
                IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    if (Interlocked.Exchange(ref _strSettingsKey, value) == value)
                        return;
                    await SetSettingsAsync(objNewSettings, token).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
                OnPropertyChanged();
            }
        }

        /// <summary>
        /// Character's Metatype Priority.
        /// </summary>
        [HubTag]
        public string MetatypePriority
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strPriorityMetatype;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _strPriorityMetatype, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Attributes Priority.
        /// </summary>
        [HubTag]
        public string AttributesPriority
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strPriorityAttributes;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _strPriorityAttributes, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Special Priority.
        /// </summary>
        [HubTag]
        public string SpecialPriority
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strPrioritySpecial;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _strPrioritySpecial, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Skills Priority.
        /// </summary>
        [HubTag]
        public string SkillsPriority
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strPrioritySkills;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _strPrioritySkills, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Resources Priority.
        /// </summary>
        [HubTag]
        public string ResourcesPriority
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strPriorityResources;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _strPriorityResources, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Resources Priority.
        /// </summary>
        [HubTag]
        public string TalentPriority
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strPriorityTalent;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _strPriorityTalent, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's list of priority bonus skills.
        /// </summary>
        public ThreadSafeList<string> PriorityBonusSkillList
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstPrioritySkills;
            }
        }

        /// <summary>
        /// Character's gender.
        /// </summary>
        public string Gender
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strGender;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _strGender, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's gender.
        /// </summary>
        public async ValueTask<string> GetGenderAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _strGender;
        }

        private string _strCachedCharacterGrammaticGender = string.Empty;

        public string CharacterGrammaticGender
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (!string.IsNullOrEmpty(_strCachedCharacterGrammaticGender))
                        return _strCachedCharacterGrammaticGender;
                    switch (ReverseTranslateExtra(Gender).ToUpperInvariant())
                    {
                        case "M":
                        case "MALE":
                        case "MAN":
                        case "BOY":
                        case "LORD":
                        case "GENTLEMAN":
                        case "GUY":
                            return _strCachedCharacterGrammaticGender = "male";

                        case "F":
                        case "W":
                        case "FEMALE":
                        case "WOMAN":
                        case "GIRL":
                        case "LADY":
                        case "GAL":
                            return _strCachedCharacterGrammaticGender = "female";

                        default:
                            return _strCachedCharacterGrammaticGender = "neutral";
                    }
                }
            }
        }

        /// <summary>
        /// Character's age.
        /// </summary>
        public string Age
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strAge;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _strAge, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's age.
        /// </summary>
        public async ValueTask<string> GetAgeAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _strAge;
        }

        /// <summary>
        /// Character's eyes.
        /// </summary>
        public string Eyes
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strEyes;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _strEyes, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's height.
        /// </summary>
        public string Height
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strHeight;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _strHeight, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's weight.
        /// </summary>
        public string Weight
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strWeight;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _strWeight, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's skin.
        /// </summary>
        public string Skin
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strSkin;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _strSkin, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's hair.
        /// </summary>
        public string Hair
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strHair;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _strHair, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's description.
        /// </summary>
        public string Description
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strDescription;
            }
            set
            {
                string strNewText = value.RtfToPlainText();
                if (string.IsNullOrWhiteSpace(strNewText))
                    value = string.Empty;
                using (EnterReadLock.Enter(LockObject))
                {
                    string strOldValue = Interlocked.Exchange(ref _strDescription, value);
                    if (strOldValue == value)
                        return;
                    string strNewHtml = value.RtfToHtml();
                    string strOldText = strOldValue.RtfToPlainText();
                    string strOldHtml = strOldValue.RtfToHtml();
                    // There's something wonky with Rtf comparison, so do an HTML comparison to be sure that something was definitely changed
                    if ((!string.IsNullOrWhiteSpace(strOldText) || !string.IsNullOrWhiteSpace(strNewText))
                        && (!string.IsNullOrWhiteSpace(strOldHtml) || !string.IsNullOrWhiteSpace(strNewHtml))
                        && strOldHtml != strNewHtml)
                        OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's background.
        /// </summary>
        public string Background
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strBackground;
            }
            set
            {
                string strNewText = value.RtfToPlainText();
                if (string.IsNullOrWhiteSpace(strNewText))
                    value = string.Empty;
                using (EnterReadLock.Enter(LockObject))
                {
                    string strOldValue = Interlocked.Exchange(ref _strBackground, value);
                    if (strOldValue == value)
                        return;
                    string strNewHtml = value.RtfToHtml();
                    string strOldText = strOldValue.RtfToPlainText();
                    string strOldHtml = strOldValue.RtfToHtml();
                    // There's something wonky with Rtf comparison, so do an HTML comparison to be sure that something was definitely changed
                    if ((!string.IsNullOrWhiteSpace(strOldText) || !string.IsNullOrWhiteSpace(strNewText))
                        && (!string.IsNullOrWhiteSpace(strOldHtml) || !string.IsNullOrWhiteSpace(strNewHtml))
                        && strOldHtml != strNewHtml)
                        OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's concept.
        /// </summary>
        public string Concept
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strConcept;
            }
            set
            {
                string strNewText = value.RtfToPlainText();
                if (string.IsNullOrWhiteSpace(strNewText))
                    value = string.Empty;
                using (EnterReadLock.Enter(LockObject))
                {
                    string strOldValue = Interlocked.Exchange(ref _strConcept, value);
                    if (strOldValue == value)
                        return;
                    string strNewHtml = value.RtfToHtml();
                    string strOldText = strOldValue.RtfToPlainText();
                    string strOldHtml = strOldValue.RtfToHtml();
                    // There's something wonky with Rtf comparison, so do an HTML comparison to be sure that something was definitely changed
                    if ((!string.IsNullOrWhiteSpace(strOldText) || !string.IsNullOrWhiteSpace(strNewText))
                        && (!string.IsNullOrWhiteSpace(strOldHtml) || !string.IsNullOrWhiteSpace(strNewHtml))
                        && strOldHtml != strNewHtml)
                        OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character notes.
        /// </summary>
        public string Notes
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strNotes;
            }
            set
            {
                string strNewText = value.RtfToPlainText();
                if (string.IsNullOrWhiteSpace(strNewText))
                    value = string.Empty;
                using (EnterReadLock.Enter(LockObject))
                {
                    string strOldValue = Interlocked.Exchange(ref _strNotes, value);
                    if (strOldValue == value)
                        return;
                    string strNewHtml = value.RtfToHtml();
                    string strOldText = strOldValue.RtfToPlainText();
                    string strOldHtml = strOldValue.RtfToHtml();
                    // There's something wonky with Rtf comparison, so do an HTML comparison to be sure that something was definitely changed
                    if ((!string.IsNullOrWhiteSpace(strOldText) || !string.IsNullOrWhiteSpace(strNewText))
                        && (!string.IsNullOrWhiteSpace(strOldHtml) || !string.IsNullOrWhiteSpace(strNewHtml))
                        && strOldHtml != strNewHtml)
                        OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// General gameplay notes.
        /// </summary>
        public string GameNotes
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strGameNotes;
            }
            set
            {
                string strNewText = value.RtfToPlainText();
                if (string.IsNullOrWhiteSpace(strNewText))
                    value = string.Empty;
                using (EnterReadLock.Enter(LockObject))
                {
                    string strOldValue = Interlocked.Exchange(ref _strGameNotes, value);
                    if (strOldValue == value)
                        return;
                    string strNewHtml = value.RtfToHtml();
                    string strOldText = strOldValue.RtfToPlainText();
                    string strOldHtml = strOldValue.RtfToHtml();
                    // There's something wonky with Rtf comparison, so do an HTML comparison to be sure that something was definitely changed
                    if ((!string.IsNullOrWhiteSpace(strOldText) || !string.IsNullOrWhiteSpace(strNewText))
                        && (!string.IsNullOrWhiteSpace(strOldHtml) || !string.IsNullOrWhiteSpace(strNewHtml))
                        && strOldHtml != strNewHtml)
                        OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// What is the Characters preferred hand
        /// </summary>
        public string PrimaryArm
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strPrimaryArm;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _strPrimaryArm, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Player name.
        /// </summary>
        [HubTag]
        public string PlayerName
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strPlayerName;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _strPlayerName, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's alias.
        /// </summary>
        [HubTag]
        public string Alias
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strAlias;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _strAlias, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's alias.
        /// </summary>
        public async ValueTask<string> GetAliasAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _strAlias;
        }

        /// <summary>
        /// Character's name to use when loading them in a new tab.
        /// </summary>
        public string CharacterName
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (!string.IsNullOrWhiteSpace(Alias))
                        return Alias;
                    return !string.IsNullOrWhiteSpace(Name)
                        ? Name
                        : LanguageManager.GetString("String_UnnamedCharacter");
                }
            }
        }

        /// <summary>
        /// Character's name to use when loading them in a new tab.
        /// </summary>
        public async ValueTask<string> GetCharacterNameAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                string strAlias = await GetAliasAsync(token).ConfigureAwait(false);
                if (!string.IsNullOrWhiteSpace(strAlias))
                    return strAlias;
                string strName = await GetNameAsync(token).ConfigureAwait(false);
                return !string.IsNullOrWhiteSpace(strName)
                    ? strName
                    : await LanguageManager.GetStringAsync("String_UnnamedCharacter", token: token)
                                           .ConfigureAwait(false);
            }
        }

        public string CurrentDisplayName => CharacterName;

        public ValueTask<string> GetCurrentDisplayNameAsync(CancellationToken token = default) =>
            GetCharacterNameAsync(token);

        /// <summary>
        /// Street Cred.
        /// </summary>
        [HubTag]
        public int StreetCred
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intStreetCred;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _intStreetCred, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Burnt Street Cred.
        /// </summary>
        public int BurntStreetCred
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intBurntStreetCred;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _intBurntStreetCred, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Notoriety.
        /// </summary>
        [HubTag]
        public int Notoriety
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intNotoriety;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _intNotoriety, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Public Awareness.
        /// </summary>
        public int PublicAwareness
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intPublicAwareness;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _intPublicAwareness, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        private bool RefreshAstralReputationImprovements(CancellationToken token = default)
        {
            using (EnterReadLock.Enter(LockObject, token))
            {
                if (IsLoading) // Not all improvements are guaranteed to have been loaded in, so just skip the refresh until the end
                {
                    EnqueuePostLoadMethod(RefreshAstralReputationImprovements, token);
                    return true;
                }

                using (LockObject.EnterWriteLock(token))
                {
                    int intCurrentTotalAstralReputation = TotalAstralReputation;
                    List<Improvement> lstCurrentAstralReputationImprovements = Improvements
                                                                               .Where(x => x.ImproveSource
                                                                                   == Improvement.ImprovementSource
                                                                                       .AstralReputation).ToList();
                    if (lstCurrentAstralReputationImprovements.All(x => x.Value == -intCurrentTotalAstralReputation))
                        return true;
                    ImprovementManager.RemoveImprovements(this, lstCurrentAstralReputationImprovements, token: token);
                    try
                    {
                        ImprovementManager.CreateImprovement(this, "Summoning",
                                                             Improvement.ImprovementSource.AstralReputation,
                                                             nameof(TotalAstralReputation).ToUpperInvariant(),
                                                             Improvement.ImprovementType.Skill,
                                                             Guid.NewGuid()
                                                                 .ToString("D", GlobalSettings.InvariantCultureInfo),
                                                             -intCurrentTotalAstralReputation, token: token);
                        ImprovementManager.CreateImprovement(this, "Binding",
                                                             Improvement.ImprovementSource.AstralReputation,
                                                             nameof(TotalAstralReputation).ToUpperInvariant(),
                                                             Improvement.ImprovementType.Skill,
                                                             Guid.NewGuid()
                                                                 .ToString("D", GlobalSettings.InvariantCultureInfo),
                                                             -intCurrentTotalAstralReputation, token: token);
                        ImprovementManager.CreateImprovement(this, "Banishing",
                                                             Improvement.ImprovementSource.AstralReputation,
                                                             nameof(TotalAstralReputation).ToUpperInvariant(),
                                                             Improvement.ImprovementType.Skill,
                                                             Guid.NewGuid()
                                                                 .ToString("D", GlobalSettings.InvariantCultureInfo),
                                                             -intCurrentTotalAstralReputation, token: token);
                        if (intCurrentTotalAstralReputation >= 3)
                            ImprovementManager.CreateImprovement(this, "Chain Breaker",
                                                                 Improvement.ImprovementSource.AstralReputation,
                                                                 nameof(TotalAstralReputation).ToUpperInvariant(),
                                                                 Improvement.ImprovementType.DisableQuality,
                                                                 Guid.NewGuid()
                                                                     .ToString(
                                                                         "D", GlobalSettings.InvariantCultureInfo),
                                                                 -intCurrentTotalAstralReputation, token: token);
                    }
                    catch
                    {
                        ImprovementManager.Rollback(this, CancellationToken.None);
                        throw;
                    }

                    ImprovementManager.Commit(this);
                    return true;
                }
            }
        }

        /// <summary>
        /// Tooltip to use for Astral Reputation total.
        /// </summary>
        public string AstralReputationTooltip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdReturn))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdReturn.Append(AstralReputation.ToString(GlobalSettings.CultureInfo));

                        foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.AstralReputation))
                        {
                            sbdReturn.Append(strSpace).Append('+').Append(strSpace)
                                     .Append(GetObjectName(objImprovement))
                                     .Append(strSpace).Append('(')
                                     .Append(objImprovement.Value.ToString(GlobalSettings.CultureInfo)).Append(')');
                        }
                    }

                    return sbdReturn.ToString();
                }
            }
        }

        /// <summary>
        /// Astral Reputation (SG 207).
        /// </summary>
        public int TotalAstralReputation
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return Math.Max(
                        0,
                        AstralReputation + ImprovementManager
                                           .ValueOf(this, Improvement.ImprovementType.AstralReputation)
                                           .StandardRound());
            }
        }

        /// <summary>
        /// Points of Astral Reputation that have added or removed manually (latter usually by burning Wild Reputation).
        /// </summary>
        public int AstralReputation
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intBaseAstralReputation;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _intBaseAstralReputation, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Tooltip to use for Wild Reputation total.
        /// </summary>
        public string WildReputationTooltip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdReturn))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdReturn.Append(WildReputation.ToString(GlobalSettings.CultureInfo));

                        foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.AstralReputationWild))
                        {
                            sbdReturn.Append(strSpace).Append('+').Append(strSpace)
                                     .Append(GetObjectName(objImprovement))
                                     .Append(strSpace).Append('(')
                                     .Append(objImprovement.Value.ToString(GlobalSettings.CultureInfo)).Append(')');
                        }
                    }

                    return sbdReturn.ToString();
                }
            }
        }

        /// <summary>
        /// Total Reputation with Wild Spirits (FA 175).
        /// </summary>
        public int TotalWildReputation
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return Math.Max(0,
                                    WildReputation
                                    + ImprovementManager.ValueOf(this, Improvement.ImprovementType.AstralReputationWild)
                                                        .StandardRound());
            }
        }

        /// <summary>
        /// Points of Wild Reputation that have added or removed manually (latter usually by burning it to lower Astral Reputation).
        /// </summary>
        public int WildReputation
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intBaseWildReputation;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _intBaseWildReputation, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Number of Physical Condition Monitor Boxes that are filled.
        /// </summary>
        public int PhysicalCMFilled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (HomeNode is Vehicle objVehicle)
                        return objVehicle.PhysicalCMFilled;

                    return _intPhysicalCMFilled;
                }
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (HomeNode is Vehicle objVehicle)
                    {
                        if (objVehicle.PhysicalCMFilled != value)
                        {
                            using (LockObject.EnterWriteLock())
                            {
                                objVehicle.PhysicalCMFilled = value;
                            }
                            OnPropertyChanged();
                        }
                    }
                    else if (Interlocked.Exchange(ref _intPhysicalCMFilled, value) != value)
                    {
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Number of Stun Condition Monitor Boxes that are filled.
        /// </summary>
        public int StunCMFilled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI && HomeNode != null)
                    {
                        // A.I. do not have a Stun Condition Monitor, but they do have a Matrix Condition Monitor if they are in their home node.
                        return HomeNode.MatrixCMFilled;
                    }

                    return _intStunCMFilled;
                }
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI && HomeNode != null)
                    {
                        // A.I. do not have a Stun Condition Monitor, but they do have a Matrix Condition Monitor if they are in their home node.
                        if (HomeNode.MatrixCMFilled != value)
                        {
                            using (LockObject.EnterWriteLock())
                            {
                                HomeNode.MatrixCMFilled = value;
                            }
                            OnPropertyChanged();
                        }
                    }
                    else if (Interlocked.Exchange(ref _intStunCMFilled, value) != value)
                    {
                        OnPropertyChanged();
                    }
                }
            }
        }

        public bool AddInitiationsAllowed
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return Created || IgnoreRules || Settings.AllowInitiationInCreateMode;
            }
        }

        /// <summary>
        /// Whether or not character creation rules should be ignored.
        /// </summary>
        [HubTag]
        public bool IgnoreRules
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnIgnoreRules;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnIgnoreRules == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnIgnoreRules = value;
                    }
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Whether or not character creation rules should be ignored.
        /// </summary>
        public async ValueTask<bool> GetIgnoreRulesAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _blnIgnoreRules;
        }

        /// <summary>
        /// Contact Points.
        /// </summary>
        public int ContactPoints
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedContactPoints == int.MinValue)
                    {
                        string strExpression = Settings.ContactPointsExpression;
                        if (strExpression.IndexOfAny('{', '+', '-', '*', ',') != -1 || strExpression.Contains("div"))
                        {
                            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                          out StringBuilder sbdValue))
                            {
                                sbdValue.Append(strExpression);
                                AttributeSection.ProcessAttributesInXPath(sbdValue, strExpression);

                                // This is first converted to a decimal and rounded up since some items have a multiplier that is not a whole number, such as 2.5.
                                (bool blnIsSuccess, object objProcess)
                                    = CommonFunctions.EvaluateInvariantXPath(
                                        sbdValue.ToString());
                                _intCachedContactPoints = blnIsSuccess ? ((double)objProcess).StandardRound() : 0;
                            }
                        }
                        else
                            int.TryParse(strExpression, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                         out _intCachedContactPoints);
                    }

                    return _intCachedContactPoints;
                }
            }
        }

        public async ValueTask<int> GetContactPointsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (_intCachedContactPoints == int.MinValue)
                {
                    string strExpression = await (await GetSettingsAsync(token).ConfigureAwait(false)).GetContactPointsExpressionAsync(token).ConfigureAwait(false);
                    if (strExpression.IndexOfAny('{', '+', '-', '*', ',') != -1 || strExpression.Contains("div"))
                    {
                        using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                      out StringBuilder sbdValue))
                        {
                            sbdValue.Append(strExpression);
                            await (await GetAttributeSectionAsync(token).ConfigureAwait(false)).ProcessAttributesInXPathAsync(sbdValue, strExpression, token: token).ConfigureAwait(false);

                            // This is first converted to a decimal and rounded up since some items have a multiplier that is not a whole number, such as 2.5.
                            (bool blnIsSuccess, object objProcess)
                                = await CommonFunctions.EvaluateInvariantXPathAsync(sbdValue.ToString(), token).ConfigureAwait(false);
                            _intCachedContactPoints = blnIsSuccess ? ((double)objProcess).StandardRound() : 0;
                        }
                    }
                    else
                        int.TryParse(strExpression, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                     out _intCachedContactPoints);
                }

                return _intCachedContactPoints;
            }
        }

        /// <summary>
        /// Number of free Contact Points the character has used.
        /// </summary>
        public int ContactPointsUsed
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intContactPointsUsed;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _intContactPointsUsed, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Number of free Contact Points the character has used.
        /// </summary>
        public async ValueTask<int> GetContactPointsUsedAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _intContactPointsUsed;
        }

        public async ValueTask SetContactPointsUsedAsync(int value, CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (Interlocked.Exchange(ref _intContactPointsUsed, value) == value)
                    return;
                OnPropertyChanged();
            }
        }

        /// <summary>
        /// Carry limit (in kg) with added Lift and Carry hits.
        /// </summary>
        public decimal CarryLimit
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return BaseCarryLimit + CurrentLiftCarryHits * 10m;
            }
        }

        /// <summary>
        /// Carry limit (in kg) without added Lift and Carry hits.
        /// </summary>
        public decimal BaseCarryLimit
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    decimal decReturn = _decCachedBaseCarryLimit;
                    if (decReturn != decimal.MinValue)
                        return decReturn;
                    string strExpression = Settings.CarryLimitExpression;
                    if (strExpression.IndexOfAny('{', '+', '-', '*', ',') != -1 || strExpression.Contains("div"))
                    {
                        using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                      out StringBuilder sbdValue))
                        {
                            sbdValue.Append(strExpression);
                            AttributeSection.ProcessAttributesInXPath(sbdValue, strExpression);
                            // This is first converted to a decimal and rounded up since some items have a multiplier that is not a whole number, such as 2.5.
                            (bool blnIsSuccess, object objProcess)
                                = CommonFunctions.EvaluateInvariantXPath(
                                    sbdValue.ToString());
                            return _decCachedBaseCarryLimit = blnIsSuccess ? Convert.ToDecimal((double) objProcess) : 0;
                        }
                    }
                    else if (decimal.TryParse(strExpression, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                              out decReturn))
                    {
                        return _decCachedBaseCarryLimit = decReturn;
                    }

                    return _decCachedBaseCarryLimit = 0;
                }
            }
        }

        /// <summary>
        /// Lift limit (in kg) with added Lift and Carry hits.
        /// </summary>
        public decimal LiftLimit
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return BaseLiftLimit + CurrentLiftCarryHits * 10m;
            }
        }

        /// <summary>
        /// Lift limit (in kg) without added Lift and Carry hits.
        /// </summary>
        public decimal BaseLiftLimit
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    decimal decReturn = _decCachedBaseLiftLimit;
                    if (decReturn != decimal.MinValue)
                        return decReturn;
                    string strExpression = Settings.LiftLimitExpression;
                    if (strExpression.IndexOfAny('{', '+', '-', '*', ',') != -1 || strExpression.Contains("div"))
                    {
                        using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                      out StringBuilder sbdValue))
                        {
                            sbdValue.Append(strExpression);
                            AttributeSection.ProcessAttributesInXPath(sbdValue, strExpression);
                            // This is first converted to a decimal and rounded up since some items have a multiplier that is not a whole number, such as 2.5.
                            (bool blnIsSuccess, object objProcess)
                                = CommonFunctions.EvaluateInvariantXPath(
                                    sbdValue.ToString());
                            return _decCachedBaseLiftLimit = blnIsSuccess ? Convert.ToDecimal((double) objProcess) : 0;
                        }
                    }
                    else if (decimal.TryParse(strExpression, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                              out decReturn))
                    {
                        return _decCachedBaseLiftLimit = decReturn;
                    }

                    return _decCachedBaseLiftLimit = 0;
                }
            }
        }

        /// <summary>
        /// Encumbrance interval (in kg).
        /// </summary>
        public decimal EncumbranceInterval
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    decimal decReturn = _decCachedEncumbranceInterval;
                    if (decReturn != decimal.MinValue)
                        return decReturn;
                    string strExpression = Settings.EncumbranceIntervalExpression;
                    if (strExpression.IndexOfAny('{', '+', '-', '*', ',') != -1 || strExpression.Contains("div"))
                    {
                        using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                      out StringBuilder sbdValue))
                        {
                            sbdValue.Append(strExpression);
                            AttributeSection.ProcessAttributesInXPath(sbdValue, strExpression);
                            // This is first converted to a decimal and rounded up since some items have a multiplier that is not a whole number, such as 2.5.
                            (bool blnIsSuccess, object objProcess)
                                = CommonFunctions.EvaluateInvariantXPath(
                                    sbdValue.ToString());
                            decReturn = blnIsSuccess ? Convert.ToDecimal((double) objProcess) : 0;
                        }
                    }
                    else
                        decimal.TryParse(strExpression, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                         out decReturn);

                    // Need this to make sure our division doesn't go haywire
                    if (decReturn <= 0)
                        decReturn = Convert.ToDecimal(double.Epsilon);

                    return _decCachedEncumbranceInterval = decReturn;
                }
            }
        }

        /// <summary>
        /// CFP Limit.
        /// </summary>
        public int CFPLimit
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intCFPLimit;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _intCFPLimit, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// CFP Limit.
        /// </summary>
        public async ValueTask<int> GetCFPLimitAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _intCFPLimit;
        }

        /// <summary>
        /// Total AI Program Limit.
        /// </summary>
        public int AINormalProgramLimit
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intAINormalProgramLimit;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _intAINormalProgramLimit, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Total AI Program Limit.
        /// </summary>
        public async ValueTask<int> GetAINormalProgramLimitAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _intAINormalProgramLimit;
        }

        /// <summary>
        /// AI Advanced Program Limit.
        /// </summary>
        public int AIAdvancedProgramLimit
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intAIAdvancedProgramLimit;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _intAIAdvancedProgramLimit, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// AI Advanced Program Limit.
        /// </summary>
        public async ValueTask<int> GetAIAdvancedProgramLimitAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _intAIAdvancedProgramLimit;
        }

        /// <summary>
        /// Spell Limit.
        /// </summary>
        public int FreeSpells
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intFreeSpells;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _intFreeSpells, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Spell Limit.
        /// </summary>
        public async ValueTask<int> GetFreeSpellsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _intFreeSpells;
        }

        /// <summary>
        /// Karma.
        /// </summary>
        public int Karma
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intKarma;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _intKarma, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Karma.
        /// </summary>
        public async ValueTask<int> GetKarmaAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _intKarma;
        }

        /// <summary>
        /// Karma.
        /// </summary>
        public async ValueTask SetKarmaAsync(int value, CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (Interlocked.Exchange(ref _intKarma, value) == value)
                    return;
                OnPropertyChanged();
            }
        }

        /// <summary>
        /// Karma.
        /// </summary>
        public async ValueTask ModifyKarmaAsync(int value, CancellationToken token = default)
        {
            if (value == 0)
                return;
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                Interlocked.Add(ref _intKarma, value);
                OnPropertyChanged(nameof(Karma));
            }
        }

        public string DisplayKarma
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return Karma.ToString(GlobalSettings.CultureInfo);
            }
        }

        /// <summary>
        /// Special.
        /// </summary>
        public int Special
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intSpecial;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _intSpecial, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// TotalSpecial.
        /// </summary>
        public int TotalSpecial
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intTotalSpecial;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _intTotalSpecial, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Attributes.
        /// </summary>
        public int Attributes
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intAttributes;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _intAttributes, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// TotalAttributes.
        /// </summary>
        public int TotalAttributes
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intTotalAttributes;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _intTotalAttributes, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        private int _intCachedCareerKarma = int.MinValue;

        /// <summary>
        /// Total amount of Karma the character has earned over the career.
        /// </summary>
        [HubTag]
        public int CareerKarma
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedCareerKarma != int.MinValue)
                        return _intCachedCareerKarma;

                    int intKarma = 0;

                    foreach (ExpenseLogEntry objEntry in _lstExpenseLog)
                    {
                        // Since we're only interested in the amount they have earned, only count values that are greater than 0 and are not refunds.
                        if (objEntry.Type == ExpenseType.Karma && (objEntry.Amount > 0 || objEntry.ForceCareerVisible)
                                                               && !objEntry.Refund)
                            intKarma += objEntry.Amount.StandardRound();
                    }

                    return _intCachedCareerKarma = intKarma;
                }
            }
        }

        public string DisplayCareerKarma
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CareerKarma.ToString(GlobalSettings.CultureInfo);
            }
        }

        private decimal _decCachedCareerNuyen = decimal.MinValue;

        /// <summary>
        /// Total amount of Nuyen the character has earned over the career.
        /// </summary>
        public decimal CareerNuyen
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    decimal decNuyen = _decCachedCareerNuyen;
                    if (decNuyen != decimal.MinValue)
                        return decNuyen;
                    decNuyen = 0;

                    foreach (ExpenseLogEntry objEntry in _lstExpenseLog)
                    {
                        // Since we're only interested in the amount they have earned, only count values that are greater than 0 and are not refunds.
                        if (objEntry.Type == ExpenseType.Nuyen && objEntry.Amount > 0 && !objEntry.Refund)
                            decNuyen += objEntry.Amount;
                    }

                    return _decCachedCareerNuyen = decNuyen;
                }
            }
        }

        public string DisplayCareerNuyen
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CareerNuyen.ToString(Settings.NuyenFormat, GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol");
            }
        }

        /// <summary>
        /// Special.
        /// </summary>
        public int EdgeUsed
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intEdgeUsed;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _intEdgeUsed, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        public int EdgeRemaining
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return EDG.TotalValue - EdgeUsed;
            }
        }

        public string EdgeRemainingString
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return EdgeRemaining.ToString(GlobalSettings.CultureInfo) + LanguageManager.GetString("String_Of")
                                                                              + EDG.TotalValue.ToString(
                                                                                  GlobalSettings.CultureInfo)
                                                                              + LanguageManager.GetString(
                                                                                  "String_Space")
                                                                              + LanguageManager.GetString(
                                                                                  "String_Remaining");
            }
        }

        /// <summary>
        /// Whether or not the character is a Critter.
        /// </summary>
        [HubTag]
        public bool IsCritter
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnIsCritter;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnIsCritter == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnIsCritter = value;
                    }
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Whether or not the character is a Critter.
        /// </summary>
        public async ValueTask<bool> GetIsCritterAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _blnIsCritter;
        }

        /// <summary>
        /// Whether or not the character is a changeling.
        /// </summary>
        [HubTag]
        public bool IsChangeling
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return MetagenicLimit > 0;
            }
        }

        /// <summary>
        /// The highest number of free Metagenic qualities the character can have.
        /// </summary>
        public int MetagenicLimit => ImprovementManager.ValueOf(this, Improvement.ImprovementType.MetageneticLimit)
                                                       .StandardRound();

        /// <summary>
        /// The highest number of free Metagenic qualities the character can have.
        /// </summary>
        public int SpecialModificationLimit =>
            ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpecialModificationLimit)
                              .StandardRound();

        /// <summary>
        /// Whether or not the character is possessed by a Spirit.
        /// </summary>
        public bool Possessed
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnPossessed;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnPossessed == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnPossessed = value;
                    }
                    OnPropertyChanged();
                }
            }
        }

        public int SpellKarmaCost(string strCategory = "")
        {
            using (EnterReadLock.Enter(LockObject))
            {
                decimal decReturn = Settings.KarmaSpell;

                // Unconditional modifiers first (which can be cached)
                decReturn += ImprovementManager.ValueOf(this, Improvement.ImprovementType.NewSpellKarmaCost,
                                                        strImprovedName: strCategory);

                foreach (Improvement objLoopImprovement in Improvements)
                {
                    if (objLoopImprovement.ImproveType != Improvement.ImprovementType.NewSpellKarmaCost)
                        continue;
                    if (!objLoopImprovement.Enabled)
                        continue;
                    switch (objLoopImprovement.Condition)
                    {
                        case "career":
                            if (Created)
                                decReturn += objLoopImprovement.Value;
                            break;

                        case "create":
                            if (!Created)
                                decReturn += objLoopImprovement.Value;
                            break;

                        default:
                            continue;
                    }
                }

                // Unconditional modifiers first (which can be cached)
                decimal decMultiplier = 1.0m;
                foreach (Improvement objLoopImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                             this, Improvement.ImprovementType.NewSpellKarmaCostMultiplier, strCategory))
                {
                    decMultiplier *= objLoopImprovement.Value / 100.0m;
                }

                foreach (Improvement objLoopImprovement in Improvements)
                {
                    if (objLoopImprovement.ImproveType != Improvement.ImprovementType.NewSpellKarmaCostMultiplier)
                        continue;
                    if (!objLoopImprovement.Enabled)
                        continue;
                    switch (objLoopImprovement.Condition)
                    {
                        case "career":
                            if (Created)
                                decMultiplier *= objLoopImprovement.Value / 100.0m;
                            break;

                        case "create":
                            if (!Created)
                                decMultiplier *= objLoopImprovement.Value / 100.0m;
                            break;

                        default:
                            continue;
                    }
                }

                if (decMultiplier != 1.0m)
                    decReturn *= decMultiplier;

                return Math.Max(decReturn.StandardRound(), 0);
            }
        }

        public async ValueTask<int> SpellKarmaCostAsync(string strCategory = "", CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                decimal decReturn = await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKarmaSpellAsync(token).ConfigureAwait(false);

                // Unconditional modifiers first (which can be cached)
                decReturn += await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.NewSpellKarmaCost,
                                                                   strImprovedName: strCategory, token: token).ConfigureAwait(false);

                bool blnCreated = await GetCreatedAsync(token).ConfigureAwait(false);
                decReturn += await (await GetImprovementsAsync(token).ConfigureAwait(false)).SumAsync(
                    x => x.ImproveType == Improvement.ImprovementType.NewSpellKarmaCost && x.Enabled,
                    objLoopImprovement =>
                    {
                        switch (objLoopImprovement.Condition)
                        {
                            case "career":
                                if (blnCreated)
                                    return objLoopImprovement.Value;
                                break;

                            case "create":
                                if (!blnCreated)
                                    return objLoopImprovement.Value;
                                break;
                        }

                        return 0;
                    }, token).ConfigureAwait(false);

                // Unconditional modifiers first (which can be cached)
                decimal decMultiplier = 1.0m;
                foreach (Improvement objLoopImprovement in await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                             this, Improvement.ImprovementType.NewSpellKarmaCostMultiplier, strCategory, token: token).ConfigureAwait(false))
                {
                    decMultiplier *= objLoopImprovement.Value / 100.0m;
                }

                await (await GetImprovementsAsync(token).ConfigureAwait(false)).ForEachAsync(objLoopImprovement =>
                {
                    if (objLoopImprovement.ImproveType != Improvement.ImprovementType.NewSpellKarmaCostMultiplier
                        || !objLoopImprovement.Enabled)
                        return;
                    switch (objLoopImprovement.Condition)
                    {
                        case "career":
                            if (blnCreated)
                                decMultiplier *= objLoopImprovement.Value / 100.0m;
                            break;

                        case "create":
                            if (!blnCreated)
                                decMultiplier *= objLoopImprovement.Value / 100.0m;
                            break;
                    }
                }, token).ConfigureAwait(false);

                if (decMultiplier != 1.0m)
                    decReturn *= decMultiplier;

                return Math.Max(decReturn.StandardRound(), 0);
            }
        }

        public int ComplexFormKarmaCost
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    decimal decReturn = Settings.KarmaNewComplexForm;

                    decimal decMultiplier = 1.0m;
                    foreach (Improvement objLoopImprovement in Improvements)
                    {
                        if ((string.IsNullOrEmpty(objLoopImprovement.Condition)
                             || (objLoopImprovement.Condition == "career") == Created
                             || (objLoopImprovement.Condition == "create") != Created) && objLoopImprovement.Enabled)
                        {
                            switch (objLoopImprovement.ImproveType)
                            {
                                case Improvement.ImprovementType.NewComplexFormKarmaCost:
                                    decReturn += objLoopImprovement.Value;
                                    break;

                                case Improvement.ImprovementType.NewComplexFormKarmaCostMultiplier:
                                    decMultiplier *= objLoopImprovement.Value / 100.0m;
                                    break;
                            }
                        }
                    }

                    if (decMultiplier != 1.0m)
                        decReturn *= decMultiplier;

                    return Math.Max(decReturn.StandardRound(), 0);
                }
            }
        }

        public async ValueTask<int> GetComplexFormKarmaCostAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                decimal decReturn = await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKarmaNewComplexFormAsync(token).ConfigureAwait(false);
                bool blnCreated = await GetCreatedAsync(token).ConfigureAwait(false);
                decimal decMultiplier = 1.0m;
                decReturn += await (await GetImprovementsAsync(token).ConfigureAwait(false)).SumAsync(
                    objLoopImprovement =>
                    {
                        if ((!string.IsNullOrEmpty(objLoopImprovement.Condition)
                             && (objLoopImprovement.Condition == "career") != blnCreated
                             && (objLoopImprovement.Condition == "create") == blnCreated)
                            || !objLoopImprovement.Enabled)
                            return 0;
                        switch (objLoopImprovement.ImproveType)
                        {
                            case Improvement.ImprovementType.NewComplexFormKarmaCost:
                                return objLoopImprovement.Value;

                            case Improvement.ImprovementType.NewComplexFormKarmaCostMultiplier:
                                decMultiplier *= objLoopImprovement.Value / 100.0m;
                                break;
                        }

                        return 0;
                    }, token).ConfigureAwait(false);

                if (decMultiplier != 1.0m)
                    decReturn *= decMultiplier;

                return Math.Max(decReturn.StandardRound(), 0);
            }
        }

        public int AIProgramKarmaCost
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    decimal decReturn = Settings.KarmaNewAIProgram;

                    decimal decMultiplier = 1.0m;
                    foreach (Improvement objLoopImprovement in Improvements)
                    {
                        if ((string.IsNullOrEmpty(objLoopImprovement.Condition)
                             || (objLoopImprovement.Condition == "career") == Created
                             || (objLoopImprovement.Condition == "create") != Created) && objLoopImprovement.Enabled)
                        {
                            switch (objLoopImprovement.ImproveType)
                            {
                                case Improvement.ImprovementType.NewAIProgramKarmaCost:
                                    decReturn += objLoopImprovement.Value;
                                    break;

                                case Improvement.ImprovementType.NewAIProgramKarmaCostMultiplier:
                                    decMultiplier *= objLoopImprovement.Value / 100.0m;
                                    break;
                            }
                        }
                    }

                    if (decMultiplier != 1.0m)
                        decReturn *= decMultiplier;

                    return Math.Max(decReturn.StandardRound(), 0);
                }
            }
        }

        public async ValueTask<int> GetAIProgramKarmaCostAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                decimal decReturn = await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKarmaNewAIProgramAsync(token).ConfigureAwait(false);
                bool blnCreated = await GetCreatedAsync(token).ConfigureAwait(false);
                decimal decMultiplier = 1.0m;
                decReturn += await (await GetImprovementsAsync(token).ConfigureAwait(false)).SumAsync(
                    objLoopImprovement =>
                    {
                        if ((!string.IsNullOrEmpty(objLoopImprovement.Condition)
                             && (objLoopImprovement.Condition == "career") != blnCreated
                             && (objLoopImprovement.Condition == "create") == blnCreated)
                            || !objLoopImprovement.Enabled)
                            return 0;
                        switch (objLoopImprovement.ImproveType)
                        {
                            case Improvement.ImprovementType.NewAIProgramKarmaCost:
                                return objLoopImprovement.Value;

                            case Improvement.ImprovementType.NewAIProgramKarmaCostMultiplier:
                                decMultiplier *= objLoopImprovement.Value / 100.0m;
                                break;
                        }

                        return 0;
                    }, token).ConfigureAwait(false);

                if (decMultiplier != 1.0m)
                    decReturn *= decMultiplier;

                return Math.Max(decReturn.StandardRound(), 0);
            }
        }

        public int AIAdvancedProgramKarmaCost
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    decimal decReturn = Settings.KarmaNewAIAdvancedProgram;

                    decimal decMultiplier = 1.0m;
                    foreach (Improvement objLoopImprovement in Improvements)
                    {
                        if ((string.IsNullOrEmpty(objLoopImprovement.Condition)
                             || (objLoopImprovement.Condition == "career") == Created
                             || (objLoopImprovement.Condition == "create") != Created) && objLoopImprovement.Enabled)
                        {
                            switch (objLoopImprovement.ImproveType)
                            {
                                case Improvement.ImprovementType.NewAIAdvancedProgramKarmaCost:
                                    decReturn += objLoopImprovement.Value;
                                    break;

                                case Improvement.ImprovementType.NewAIAdvancedProgramKarmaCostMultiplier:
                                    decMultiplier *= objLoopImprovement.Value / 100.0m;
                                    break;
                            }
                        }
                    }

                    if (decMultiplier != 1.0m)
                        decReturn *= decMultiplier;

                    return Math.Max(decReturn.StandardRound(), 0);
                }
            }
        }

        public async ValueTask<int> GetAIAdvancedProgramKarmaCostAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                decimal decReturn = await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKarmaNewAIAdvancedProgramAsync(token).ConfigureAwait(false);
                bool blnCreated = await GetCreatedAsync(token).ConfigureAwait(false);
                decimal decMultiplier = 1.0m;
                decReturn += await (await GetImprovementsAsync(token).ConfigureAwait(false)).SumAsync(
                    objLoopImprovement =>
                    {
                        if ((!string.IsNullOrEmpty(objLoopImprovement.Condition)
                             && (objLoopImprovement.Condition == "career") != blnCreated
                             && (objLoopImprovement.Condition == "create") == blnCreated)
                            || !objLoopImprovement.Enabled)
                            return 0;
                        switch (objLoopImprovement.ImproveType)
                        {
                            case Improvement.ImprovementType.NewAIAdvancedProgramKarmaCost:
                                return objLoopImprovement.Value;

                            case Improvement.ImprovementType.NewAIAdvancedProgramKarmaCostMultiplier:
                                decMultiplier *= objLoopImprovement.Value / 100.0m;
                                break;
                        }

                        return 0;
                    }, token).ConfigureAwait(false);

                if (decMultiplier != 1.0m)
                    decReturn *= decMultiplier;

                return Math.Max(decReturn.StandardRound(), 0);
            }
        }

        public bool Ambidextrous => ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Ambidextrous).Count > 0;

        public async ValueTask<bool> GetAmbidextrousAsync(CancellationToken token = default)
        {
            return (await ImprovementManager.GetCachedImprovementListForValueOfAsync(this, Improvement.ImprovementType.Ambidextrous, token: token).ConfigureAwait(false)).Count > 0;
        }

        #endregion Basic Properties

        #region Attributes

        /// <summary>
        /// Get a CharacterAttribute by its name.
        /// </summary>
        /// <param name="strAttribute">CharacterAttribute name to retrieve.</param>
        /// <param name="blnExplicit">Whether to force looking for a specific attribute name.
        /// Mostly expected to be used for gutting Mystic Adept power points.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public CharacterAttrib GetAttribute(string strAttribute, bool blnExplicit = false, CancellationToken token = default)
        {
            using (EnterReadLock.Enter(LockObject, token))
            {
                if (strAttribute == "MAGAdept" && !blnExplicit && (!IsMysticAdept || !Settings.MysAdeptSecondMAGAttribute))
                    strAttribute = "MAG";
                return AttributeSection.GetAttributeByName(strAttribute, token);
            }
        }

        /// <summary>
        /// Get a CharacterAttribute by its name.
        /// </summary>
        /// <param name="strAttribute">CharacterAttribute name to retrieve.</param>
        /// <param name="blnExplicit">Whether to force looking for a specific attribute name.
        /// Mostly expected to be used for gutting Mystic Adept power points.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public async ValueTask<CharacterAttrib> GetAttributeAsync(string strAttribute, bool blnExplicit = false, CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (strAttribute == "MAGAdept" && !blnExplicit && (!await GetIsMysticAdeptAsync(token).ConfigureAwait(false) || !await Settings.GetMysAdeptSecondMAGAttributeAsync(token).ConfigureAwait(false)))
                    strAttribute = "MAG";
                return await (await GetAttributeSectionAsync(token).ConfigureAwait(false)).GetAttributeByNameAsync(strAttribute, token).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Get all CharacterAttributes that have a particular abbreviation.
        /// </summary>
        /// <param name="strAttribute">CharacterAttribute name to retrieve.</param>
        /// <param name="blnExplicit">Whether to force looking for a specific attribute name.
        /// Mostly expected to be used for gutting Mystic Adept power points.</param>
        public IEnumerable<CharacterAttrib> GetAllAttributes(string strAttribute, bool blnExplicit = false)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (strAttribute == "MAGAdept" && (!IsMysticAdept || !Settings.MysAdeptSecondMAGAttribute)
                                               && !blnExplicit)
                    strAttribute = "MAG";
                foreach (CharacterAttrib objLoop in AttributeSection.AttributeList)
                {
                    if (objLoop.Abbrev == strAttribute)
                        yield return objLoop;
                }

                foreach (CharacterAttrib objLoop in AttributeSection.SpecialAttributeList)
                {
                    if (objLoop.Abbrev == strAttribute)
                        yield return objLoop;
                }
            }
        }

        /// <summary>
        /// Body (BOD) CharacterAttribute.
        /// </summary>
        public CharacterAttrib BOD
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AttributeSection.GetAttributeByName("BOD");
            }
        }

        /// <summary>
        /// Agility (AGI) CharacterAttribute.
        /// </summary>
        public CharacterAttrib AGI
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AttributeSection.GetAttributeByName("AGI");
            }
        }

        /// <summary>
        /// Reaction (REA) CharacterAttribute.
        /// </summary>
        public CharacterAttrib REA
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AttributeSection.GetAttributeByName("REA");
            }
        }

        /// <summary>
        /// Strength (STR) CharacterAttribute.
        /// </summary>
        public CharacterAttrib STR
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AttributeSection.GetAttributeByName("STR");
            }
        }

        /// <summary>
        /// Charisma (CHA) CharacterAttribute.
        /// </summary>
        public CharacterAttrib CHA
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AttributeSection.GetAttributeByName("CHA");
            }
        }

        /// <summary>
        /// Intuition (INT) CharacterAttribute.
        /// </summary>
        public CharacterAttrib INT
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AttributeSection.GetAttributeByName("INT");
            }
        }

        /// <summary>
        /// Logic (LOG) CharacterAttribute.
        /// </summary>
        public CharacterAttrib LOG
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AttributeSection.GetAttributeByName("LOG");
            }
        }

        /// <summary>
        /// Willpower (WIL) CharacterAttribute.
        /// </summary>
        public CharacterAttrib WIL
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AttributeSection.GetAttributeByName("WIL");
            }
        }

        /// <summary>
        /// Edge (EDG) CharacterAttribute.
        /// </summary>
        public CharacterAttrib EDG
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AttributeSection.GetAttributeByName("EDG");
            }
        }

        /// <summary>
        /// Magic (MAG) CharacterAttribute.
        /// </summary>
        public CharacterAttrib MAG
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AttributeSection.GetAttributeByName("MAG");
            }
        }

        /// <summary>
        /// Reflection of MAG (hide it, if it is not enabled!)
        /// </summary>
        [HubTag("Magic")]
        public CharacterAttrib ReflectionMAG
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return MAGEnabled ? MAG : null;
            }
        }

        /// <summary>
        /// Magic (MAG) CharacterAttribute for Adept powers of Mystic Adepts when the appropriate house rule is enabled.
        /// </summary>
        public CharacterAttrib MAGAdept
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Settings.MysAdeptSecondMAGAttribute && IsMysticAdept)
                        return AttributeSection.GetAttributeByName("MAGAdept");
                    return MAG;
                }
            }
        }

        /// <summary>
        /// Reflection of MAGAdept (hide it, if it is not enabled!)
        /// </summary>
        [HubTag("MagicAdept")]
        public CharacterAttrib ReflectionMAGAdept
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return MAGEnabled ? MAGAdept : null;
            }
        }

        /// <summary>
        /// Resonance (RES) CharacterAttribute.
        /// </summary>
        public CharacterAttrib RES
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AttributeSection.GetAttributeByName("RES");
            }
        }

        /// <summary>
        /// Reflection of RES (hide it, if it is not enabled!)
        /// </summary>
        [HubTag("Resonance")]
        public CharacterAttrib ReflectionRES
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return RESEnabled ? RES : null;
            }
        }

        /// <summary>
        /// Depth (DEP) Attribute.
        /// </summary>
        public CharacterAttrib DEP
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AttributeSection.GetAttributeByName("DEP");
            }
        }

        /// <summary>
        /// Reflection of DEP (hide it, if it is not enabled!)
        /// </summary>
        [HubTag("Depth")]
        public CharacterAttrib ReflectionDEP
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return DEPEnabled ? DEP : null;
            }
        }

        /// <summary>
        /// Essence (ESS) Attribute.
        /// </summary>
        public CharacterAttrib ESS => AttributeSection.GetAttributeByName("ESS");

        /// <summary>
        /// Is the MAG CharacterAttribute enabled?
        /// </summary>
        [HubTag]
        public bool MAGEnabled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnMAGEnabled;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnMAGEnabled == value)
                        return;
                    if (IsLoading)
                    {
                        using (LockObject.EnterWriteLock())
                            _blnMAGEnabled = value;
                        OnPropertyChanged();
                        return;
                    }
                    using (LockObject.EnterWriteLock())
                    {
                        _blnMAGEnabled = value;
                        if (value)
                        {
                            // Career mode, so no extra calculations need to be done for EssenceAtSpecialStart
                            if (Created)
                            {
                                ResetCachedEssence();
                                EssenceAtSpecialStart = Essence(true, "MAG");
                            }
                            // EssenceAtSpecialStart needs to be calculated by assuming that the character took the MAG-enabling quality with the highest essence penalty first, as that would be the most optimal
                            else
                            {
                                // If this character has any MAG-enabling bonuses that could be granted before all others (because they're priority and/or metatype-given),
                                // it has to be assumed those are taken first.
                                List<Improvement> lstAttributeImprovements = ImprovementManager
                                    .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Attribute,
                                                                        "MAG");
                                bool blnCountOnlyPriorityOrMetatypeGivenBonuses = lstAttributeImprovements.Any(
                                    x => x.ImproveSource
                                         == Improvement.ImprovementSource
                                                       .Metatype
                                         || x.ImproveSource
                                         == Improvement.ImprovementSource
                                                       .Metavariant
                                         || x.ImproveSource
                                         == Improvement.ImprovementSource
                                                       .Heritage);
                                if (!blnCountOnlyPriorityOrMetatypeGivenBonuses)
                                {
                                    List<string> lstMAGEnablingQualityIds = lstAttributeImprovements
                                                                            .Where(x => x.ImproveSource
                                                                                == Improvement.ImprovementSource
                                                                                    .Quality).Select(
                                                                                x => x.SourceName).ToList();
                                    // Can't use foreach because new items can get added to this list while it is looping
                                    for (int i = 0; i < lstMAGEnablingQualityIds.Count; ++i)
                                    {
                                        Quality objQuality
                                            = Qualities.FirstOrDefault(
                                                x => x.InternalId == lstMAGEnablingQualityIds[i]);
                                        if (objQuality != null)
                                        {
                                            if (objQuality.OriginSource == QualitySource.Metatype
                                                || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                                || objQuality.OriginSource == QualitySource.BuiltIn
                                                || objQuality.OriginSource == QualitySource.LifeModule
                                                || objQuality.OriginSource == QualitySource.Heritage)
                                            {
                                                blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                                break;
                                            }

                                            if (objQuality.OriginSource == QualitySource.Improvement)
                                            {
                                                List<Improvement> lstSpecificQualityImprovements = ImprovementManager
                                                    .GetCachedImprovementListForValueOf(
                                                        this, Improvement.ImprovementType.SpecificQuality,
                                                        objQuality.InternalId);
                                                if (lstSpecificQualityImprovements.Any(x =>
                                                        x.ImproveSource == Improvement.ImprovementSource.Metatype
                                                        || x.ImproveSource == Improvement.ImprovementSource
                                                            .Metavariant
                                                        || x.ImproveSource
                                                        == Improvement.ImprovementSource.Heritage))
                                                {
                                                    blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                                    break;
                                                }

                                                // Qualities that add other qualities get added to the list to be checked, too
                                                lstMAGEnablingQualityIds.AddRange(
                                                    lstSpecificQualityImprovements
                                                        .Where(
                                                            x => x.ImproveSource
                                                                 == Improvement.ImprovementSource.Quality)
                                                        .Select(x => x.SourceName));
                                            }
                                        }
                                    }
                                }

                                Dictionary<string, decimal> dicImprovementEssencePenalties =
                                    new Dictionary<string, decimal>(Improvements.Count);
                                foreach (Improvement objImprovement in Improvements)
                                {
                                    if (!objImprovement.Enabled)
                                        continue;
                                    bool blnCountImprovement = !blnCountOnlyPriorityOrMetatypeGivenBonuses
                                                               || objImprovement.ImproveSource
                                                               == Improvement.ImprovementSource.Metatype
                                                               || objImprovement.ImproveSource
                                                               == Improvement.ImprovementSource.Metavariant
                                                               || objImprovement.ImproveSource
                                                               == Improvement.ImprovementSource.Heritage;
                                    if (!blnCountImprovement && objImprovement.ImproveSource
                                        == Improvement.ImprovementSource.Quality)
                                    {
                                        Quality objQuality
                                            = Qualities.FirstOrDefault(x => x.InternalId == objImprovement.SourceName);
                                        while (objQuality != null)
                                        {
                                            if (objQuality.OriginSource == QualitySource.Metatype
                                                || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                                || objQuality.OriginSource == QualitySource.BuiltIn
                                                || objQuality.OriginSource == QualitySource.LifeModule
                                                || objQuality.OriginSource == QualitySource.Heritage)
                                            {
                                                blnCountImprovement = true;
                                                break;
                                            }

                                            if (objQuality.OriginSource == QualitySource.Improvement)
                                            {
                                                Improvement objParentImprovement = ImprovementManager
                                                    .GetCachedImprovementListForValueOf(
                                                        this,
                                                        Improvement.ImprovementType
                                                                   .SpecificQuality,
                                                        objQuality.InternalId)
                                                    .FirstOrDefault();
                                                if (objParentImprovement == null)
                                                    break;
                                                if (objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Metatype
                                                    || objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Metavariant
                                                    || objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Heritage)
                                                {
                                                    blnCountImprovement = true;
                                                    break;
                                                }

                                                if (objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Quality)
                                                {
                                                    // Qualities that add other qualities get added to the list to be checked, too
                                                    objQuality = Qualities.FirstOrDefault(
                                                        x => x.InternalId == objParentImprovement.SourceName);
                                                }
                                                else
                                                    break;
                                            }
                                            else
                                                break;
                                        }
                                    }

                                    if (blnCountImprovement)
                                    {
                                        decimal decLoopEssencePenalty = 0;
                                        switch (objImprovement.ImproveType)
                                        {
                                            case Improvement.ImprovementType.EssencePenalty:
                                                decLoopEssencePenalty += objImprovement.Value;
                                                break;

                                            case Improvement.ImprovementType.EssencePenaltyT100:
                                            case Improvement.ImprovementType.EssencePenaltyMAGOnlyT100:
                                                decLoopEssencePenalty += objImprovement.Value / 100.0m;
                                                break;
                                        }

                                        if (decLoopEssencePenalty != 0)
                                        {
                                            if (dicImprovementEssencePenalties.TryGetValue(
                                                    objImprovement.SourceName, out decimal decExistingPenalty))
                                                dicImprovementEssencePenalties[objImprovement.SourceName]
                                                    = decExistingPenalty + decLoopEssencePenalty;
                                            else
                                                dicImprovementEssencePenalties.Add(objImprovement.SourceName,
                                                    decLoopEssencePenalty);
                                        }
                                    }
                                }

                                if (dicImprovementEssencePenalties.Count > 0)
                                    EssenceAtSpecialStart =
                                        ESS.MetatypeMaximum + dicImprovementEssencePenalties.Values.Min();
                                else
                                    EssenceAtSpecialStart = ESS.MetatypeMaximum;
                            }
                        }
                        else
                        {
                            if (!RESEnabled)
                            {
                                ClearInitiations();
                                MagicTradition.ResetTradition();
                            }
                            else
                            {
                                XmlNode xmlTraditionListDataNode
                                    = LoadData("streams.xml").SelectSingleNode("/chummer/traditions");
                                if (xmlTraditionListDataNode != null)
                                {
                                    XmlNode xmlTraditionDataNode
                                        = xmlTraditionListDataNode.SelectSingleNode("tradition[name = \"Default\"]");
                                    if (xmlTraditionDataNode != null)
                                    {
                                        if (!MagicTradition.Create(xmlTraditionDataNode, true))
                                            MagicTradition.ResetTradition();
                                    }
                                    else
                                        MagicTradition.ResetTradition();
                                }
                                else
                                    MagicTradition.ResetTradition();
                            }

                            if (!Created && !RESEnabled && !DEPEnabled)
                                EssenceAtSpecialStart = decimal.MinValue;
                        }
                    }
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Is the MAG CharacterAttribute enabled?
        /// </summary>
        public async ValueTask<bool> GetMAGEnabledAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _blnMAGEnabled;
        }

        /// <summary>
        /// Is the MAG CharacterAttribute enabled?
        /// </summary>
        public async ValueTask SetMAGEnabledAsync(bool value, CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (_blnMAGEnabled == value)
                    return;
                if (IsLoading)
                {
                    IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                    try
                    {
                        _blnMAGEnabled = value;
                    }
                    finally
                    {
                        await objLocker2.DisposeAsync().ConfigureAwait(false);
                    }
                    OnPropertyChanged();
                    return;
                }
                IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    _blnMAGEnabled = value;
                    if (value)
                    {
                        // Career mode, so no extra calculations need to be done for EssenceAtSpecialStart
                        if (await GetCreatedAsync(token).ConfigureAwait(false))
                        {
                            await ResetCachedEssenceAsync(token).ConfigureAwait(false);
                            await SetEssenceAtSpecialStartAsync(
                                    await EssenceAsync(true, "MAG", token).ConfigureAwait(false), token)
                                .ConfigureAwait(false);
                        }
                        // EssenceAtSpecialStart needs to be calculated by assuming that the character took the MAG-enabling quality with the highest essence penalty first, as that would be the most optimal
                        else
                        {
                            // If this character has any MAG-enabling bonuses that could be granted before all others (because they're priority and/or metatype-given),
                            // it has to be assumed those are taken first.
                            List<Improvement> lstAttributeImprovements = await ImprovementManager
                                                                               .GetCachedImprovementListForValueOfAsync(
                                                                                   this,
                                                                                   Improvement.ImprovementType
                                                                                       .Attribute,
                                                                                   "MAG", token: token)
                                                                               .ConfigureAwait(false);
                            bool blnCountOnlyPriorityOrMetatypeGivenBonuses = lstAttributeImprovements.Any(
                                x => x.ImproveSource
                                     == Improvement.ImprovementSource
                                                   .Metatype
                                     || x.ImproveSource
                                     == Improvement.ImprovementSource
                                                   .Metavariant
                                     || x.ImproveSource
                                     == Improvement.ImprovementSource
                                                   .Heritage);
                            if (!blnCountOnlyPriorityOrMetatypeGivenBonuses)
                            {
                                List<string> lstMAGEnablingQualityIds = lstAttributeImprovements
                                                                        .Where(x => x.ImproveSource
                                                                                   == Improvement.ImprovementSource
                                                                                       .Quality).Select(
                                                                            x => x.SourceName).ToList();
                                // Can't use foreach because new items can get added to this list while it is looping
                                for (int i = 0; i < lstMAGEnablingQualityIds.Count; ++i)
                                {
                                    int i1 = i;
                                    Quality objQuality
                                        = await Qualities.FirstOrDefaultAsync(
                                                             x => x.InternalId == lstMAGEnablingQualityIds[i1],
                                                             token: token)
                                                         .ConfigureAwait(false);
                                    if (objQuality != null)
                                    {
                                        if (objQuality.OriginSource == QualitySource.Metatype
                                            || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                            || objQuality.OriginSource == QualitySource.BuiltIn
                                            || objQuality.OriginSource == QualitySource.LifeModule
                                            || objQuality.OriginSource == QualitySource.Heritage)
                                        {
                                            blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                            break;
                                        }

                                        if (objQuality.OriginSource == QualitySource.Improvement)
                                        {
                                            List<Improvement> lstSpecificQualityImprovements = await ImprovementManager
                                                .GetCachedImprovementListForValueOfAsync(
                                                    this, Improvement.ImprovementType.SpecificQuality,
                                                    objQuality.InternalId, token: token).ConfigureAwait(false);
                                            if (lstSpecificQualityImprovements.Any(x =>
                                                    x.ImproveSource == Improvement.ImprovementSource.Metatype
                                                    || x.ImproveSource == Improvement.ImprovementSource
                                                        .Metavariant
                                                    || x.ImproveSource
                                                    == Improvement.ImprovementSource.Heritage))
                                            {
                                                blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                                break;
                                            }

                                            // Qualities that add other qualities get added to the list to be checked, too
                                            lstMAGEnablingQualityIds.AddRange(
                                                lstSpecificQualityImprovements
                                                    .Where(
                                                        x => x.ImproveSource
                                                             == Improvement.ImprovementSource.Quality)
                                                    .Select(x => x.SourceName));
                                        }
                                    }
                                }
                            }

                            Dictionary<string, decimal> dicImprovementEssencePenalties =
                                new Dictionary<string, decimal>(
                                    await Improvements.GetCountAsync(token).ConfigureAwait(false));
                            foreach (Improvement objImprovement in Improvements)
                            {
                                if (!objImprovement.Enabled)
                                    continue;
                                bool blnCountImprovement = !blnCountOnlyPriorityOrMetatypeGivenBonuses
                                                           || objImprovement.ImproveSource
                                                           == Improvement.ImprovementSource.Metatype
                                                           || objImprovement.ImproveSource
                                                           == Improvement.ImprovementSource.Metavariant
                                                           || objImprovement.ImproveSource
                                                           == Improvement.ImprovementSource.Heritage;
                                if (!blnCountImprovement && objImprovement.ImproveSource
                                    == Improvement.ImprovementSource.Quality)
                                {
                                    Quality objQuality
                                        = await Qualities.FirstOrDefaultAsync(
                                                             x => x.InternalId == objImprovement.SourceName,
                                                             token: token)
                                                         .ConfigureAwait(false);
                                    while (objQuality != null)
                                    {
                                        if (objQuality.OriginSource == QualitySource.Metatype
                                            || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                            || objQuality.OriginSource == QualitySource.BuiltIn
                                            || objQuality.OriginSource == QualitySource.LifeModule
                                            || objQuality.OriginSource == QualitySource.Heritage)
                                        {
                                            blnCountImprovement = true;
                                            break;
                                        }

                                        if (objQuality.OriginSource == QualitySource.Improvement)
                                        {
                                            Improvement objParentImprovement = (await ImprovementManager
                                                    .GetCachedImprovementListForValueOfAsync(
                                                        this,
                                                        Improvement.ImprovementType
                                                                   .SpecificQuality,
                                                        objQuality.InternalId, token: token).ConfigureAwait(false))
                                                .FirstOrDefault();
                                            if (objParentImprovement == null)
                                                break;
                                            if (objParentImprovement.ImproveSource
                                                == Improvement.ImprovementSource.Metatype
                                                || objParentImprovement.ImproveSource
                                                == Improvement.ImprovementSource.Metavariant
                                                || objParentImprovement.ImproveSource
                                                == Improvement.ImprovementSource.Heritage)
                                            {
                                                blnCountImprovement = true;
                                                break;
                                            }

                                            if (objParentImprovement.ImproveSource
                                                == Improvement.ImprovementSource.Quality)
                                            {
                                                // Qualities that add other qualities get added to the list to be checked, too
                                                objQuality = await Qualities.FirstOrDefaultAsync(
                                                                                x => x.InternalId
                                                                                    == objParentImprovement.SourceName,
                                                                                token: token)
                                                                            .ConfigureAwait(false);
                                            }
                                            else
                                                break;
                                        }
                                        else
                                            break;
                                    }
                                }

                                if (blnCountImprovement)
                                {
                                    decimal decLoopEssencePenalty = 0;
                                    switch (objImprovement.ImproveType)
                                    {
                                        case Improvement.ImprovementType.EssencePenalty:
                                            decLoopEssencePenalty += objImprovement.Value;
                                            break;

                                        case Improvement.ImprovementType.EssencePenaltyT100:
                                        case Improvement.ImprovementType.EssencePenaltyMAGOnlyT100:
                                            decLoopEssencePenalty += objImprovement.Value / 100.0m;
                                            break;
                                    }

                                    if (decLoopEssencePenalty != 0)
                                    {
                                        if (dicImprovementEssencePenalties.TryGetValue(
                                                objImprovement.SourceName, out decimal decExistingPenalty))
                                            dicImprovementEssencePenalties[objImprovement.SourceName]
                                                = decExistingPenalty + decLoopEssencePenalty;
                                        else
                                            dicImprovementEssencePenalties.Add(objImprovement.SourceName,
                                                                               decLoopEssencePenalty);
                                    }
                                }
                            }

                            if (dicImprovementEssencePenalties.Count > 0)
                                await SetEssenceAtSpecialStartAsync(
                                    await ESS.GetMetatypeMaximumAsync(token).ConfigureAwait(false)
                                    + dicImprovementEssencePenalties.Values.Min(), token).ConfigureAwait(false);
                            else
                                await SetEssenceAtSpecialStartAsync(
                                        await ESS.GetMetatypeMaximumAsync(token).ConfigureAwait(false), token)
                                    .ConfigureAwait(false);
                        }
                    }
                    else
                    {
                        if (!await GetRESEnabledAsync(token).ConfigureAwait(false))
                        {
                            await ClearInitiationsAsync(token).ConfigureAwait(false);
                            await MagicTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                        }
                        else
                        {
                            XmlNode xmlTraditionListDataNode
                                = (await LoadDataAsync("streams.xml", token: token).ConfigureAwait(false))
                                .SelectSingleNode("/chummer/traditions");
                            if (xmlTraditionListDataNode != null)
                            {
                                XmlNode xmlTraditionDataNode
                                    = xmlTraditionListDataNode.SelectSingleNode("tradition[name = \"Default\"]");
                                if (xmlTraditionDataNode != null)
                                {
                                    if (!MagicTradition.Create(xmlTraditionDataNode, true))
                                        await MagicTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                                }
                                else
                                    await MagicTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                            }
                            else
                                await MagicTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                        }

                        if (!await GetCreatedAsync(token).ConfigureAwait(false)
                            && !await GetRESEnabledAsync(token).ConfigureAwait(false)
                            && !await GetDEPEnabledAsync(token).ConfigureAwait(false))
                            await SetEssenceAtSpecialStartAsync(decimal.MinValue, token).ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
                OnPropertyChanged(nameof(MAGEnabled));
            }
        }

        /// <summary>
        /// Maximum force of spirits summonable/bindable by the character. Limited to MAG at creation.
        /// </summary>
        public int MaxSpiritForce
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    int intReturn = Settings.SpiritForceBasedOnTotalMAG ? MAG.TotalValue : MAG.Value;
                    if (intReturn <= 0)
                        return 0;
                    if (Created)
                        intReturn *= 2;
                    return intReturn;
                }
            }
        }

        public int BoundSpiritLimit
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intBoundSpiritLimit == int.MinValue)
                    {
                        string strExpression = Settings.BoundSpiritExpression;
                        if (strExpression.IndexOfAny('{', '+', '-', '*', ',') != -1 || strExpression.Contains("div"))
                        {
                            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                          out StringBuilder sbdValue))
                            {
                                sbdValue.Append(strExpression);
                                AttributeSection.ProcessAttributesInXPath(sbdValue, strExpression);

                                // This is first converted to a decimal and rounded up since some items have a multiplier that is not a whole number, such as 2.5.
                                (bool blnIsSuccess, object objProcess)
                                    = CommonFunctions.EvaluateInvariantXPath(
                                        sbdValue.ToString());
                                _intBoundSpiritLimit = blnIsSuccess ? ((double)objProcess).StandardRound() : 0;
                            }
                        }
                        else
                            int.TryParse(strExpression, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                         out _intBoundSpiritLimit);
                    }

                    return _intBoundSpiritLimit;
                }
            }
        }

        /// <summary>
        /// Maximum level of sprites compilable/registrable by the character. Limited to RES at creation.
        /// </summary>
        public int MaxSpriteLevel
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    int intReturn = RES.TotalValue;
                    if (intReturn <= 0)
                        return 0;
                    if (Created)
                        intReturn *= 2;
                    return intReturn;
                }
            }
        }

        public int RegisteredSpriteLimit
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intRegisteredSpriteLimit == int.MinValue)
                    {
                        string strExpression = Settings.RegisteredSpriteExpression;
                        if (strExpression.IndexOfAny('{', '+', '-', '*', ',') != -1 || strExpression.Contains("div"))
                        {
                            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                          out StringBuilder sbdValue))
                            {
                                sbdValue.Append(strExpression);
                                AttributeSection.ProcessAttributesInXPath(sbdValue, strExpression);

                                // This is first converted to a decimal and rounded up since some items have a multiplier that is not a whole number, such as 2.5.
                                (bool blnIsSuccess, object objProcess)
                                    = CommonFunctions.EvaluateInvariantXPath(
                                        sbdValue.ToString());
                                _intRegisteredSpriteLimit = blnIsSuccess ? ((double)objProcess).StandardRound() : 0;
                            }
                        }
                        else
                            int.TryParse(strExpression, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                         out _intRegisteredSpriteLimit);
                    }

                    return _intRegisteredSpriteLimit;
                }
            }
        }

        /// <summary>
        /// Amount of Power Points for Mystic Adepts.
        /// </summary>
        public int MysticAdeptPowerPoints
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intMAGAdept;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    value = Math.Min(value, MAG.TotalValue);
                    if (Interlocked.Exchange(ref _intMAGAdept, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Amount of Power Points for Mystic Adepts.
        /// </summary>
        public async ValueTask<int> GetMysticAdeptPowerPointsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _intMAGAdept;
        }

        /// <summary>
        /// Total Amount of Power Points this character has.
        /// </summary>
        public decimal PowerPointsTotal
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    decimal decMAG = UseMysticAdeptPPs ? MysticAdeptPowerPoints : MAGAdept.TotalValue;

                    // Add any Power Point Improvements to MAG.
                    decMAG += ImprovementManager.ValueOf(this, Improvement.ImprovementType.AdeptPowerPoints);

                    return Math.Max(decMAG, 0);
                }
            }
        }

        /// <summary>
        /// Total Amount of Power Points this character has.
        /// </summary>
        public async ValueTask<decimal> GetPowerPointsTotalAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                decimal decMAG = await GetUseMysticAdeptPPsAsync(token).ConfigureAwait(false)
                    ? await GetMysticAdeptPowerPointsAsync(token).ConfigureAwait(false)
                    : await (await GetAttributeAsync("MAGAdept", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false);

                // Add any Power Point Improvements to MAG.
                decMAG += await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.AdeptPowerPoints, token: token).ConfigureAwait(false);

                return Math.Max(decMAG, 0);
            }
        }

        private decimal _decCachedPowerPointsUsed = decimal.MinValue;

        public decimal PowerPointsUsed
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    decimal decReturn = _decCachedPowerPointsUsed;
                    if (decReturn != decimal.MinValue)
                        return decReturn;
                    return _decCachedPowerPointsUsed = Powers.Sum(objPower => objPower.PowerPoints);
                }
            }
        }

        public async ValueTask<decimal> GetPowerPointsUsedAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                decimal decReturn = _decCachedPowerPointsUsed;
                if (decReturn != decimal.MinValue)
                    return decReturn;
                return _decCachedPowerPointsUsed = await (await GetPowersAsync(token).ConfigureAwait(false))
                                                         .SumAsync(
                                                             objPower => objPower.GetPowerPointsAsync(token).AsTask(),
                                                             token).ConfigureAwait(false);
            }
        }

        public string DisplayPowerPointsRemaining
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                    return PowerPointsTotal.ToString(GlobalSettings.CultureInfo) + strSpace + '(' +
                           (PowerPointsTotal - PowerPointsUsed).ToString(GlobalSettings.CultureInfo) + strSpace +
                           LanguageManager.GetString("String_Remaining") + ')';
            }
        }

        public async ValueTask<string> GetDisplayPowerPointsRemainingAsync(CancellationToken token = default)
        {
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                decimal decTotal = await GetPowerPointsTotalAsync(token).ConfigureAwait(false);
                return decTotal.ToString(GlobalSettings.CultureInfo) + strSpace + '(' +
                       (decTotal - await GetPowerPointsUsedAsync(token).ConfigureAwait(false)).ToString(
                           GlobalSettings.CultureInfo) + strSpace +
                       await LanguageManager.GetStringAsync("String_Remaining", token: token).ConfigureAwait(false)
                       + ')';
            }
        }

        public bool AnyPowerAdeptWayDiscountEnabled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return Powers.Any(objPower => objPower.AdeptWayDiscountEnabled);
            }
        }

        /// <summary>
        /// Magician's Tradition.
        /// </summary>
        [HubTag("Tradition", "", "MagicTradition", false)]
        public Tradition MagicTradition
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _objTradition;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_objTradition == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        if (Interlocked.Exchange(ref _objTradition, value) != value)
                            OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Magician's Tradition.
        /// </summary>
        public async ValueTask<Tradition> GetMagicTraditionAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _objTradition;
        }

        /// <summary>
        /// Initiate Grade.
        /// </summary>
        [HubTag]
        public int InitiateGrade
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intInitiateGrade;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intInitiateGrade == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        int intOldValue = Interlocked.Exchange(ref _intInitiateGrade, value);
                        if (intOldValue == value)
                            return;
                        bool blnFirstInitiation = intOldValue == 0;
                        // Remove any existing Initiation Improvements.
                        if (value == 0)
                        {
                            ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Initiation);
                            // Update any Metamagic Improvements the character might have.
                            foreach (Metamagic objMetamagic in Metamagics.Where(
                                         x => x.SourceType == Improvement.ImprovementSource.Metamagic
                                              && x.Bonus?.InnerXml.Contains("Rating") == true))
                            {
                                ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Metamagic,
                                                                      objMetamagic.InternalId);
                            }
                        }
                        else if (blnFirstInitiation)
                        {
                            try
                            {
                                // Create the new Improvement.
                                ImprovementManager.CreateImprovement(this, "MAG",
                                                                     Improvement.ImprovementSource.Initiation,
                                                                     string.Empty,
                                                                     Improvement.ImprovementType.Attribute,
                                                                     string.Empty, 0, value, 0, 1);
                                ImprovementManager.CreateImprovement(this, "MAGAdept",
                                                                     Improvement.ImprovementSource.Initiation,
                                                                     string.Empty,
                                                                     Improvement.ImprovementType.Attribute,
                                                                     string.Empty, 0, value, 0, 1);
                                // Update any Metamagic Improvements the character might have.
                                foreach (Metamagic objMetamagic in Metamagics.Where(
                                             x => x.SourceType == Improvement.ImprovementSource.Metamagic
                                                  && x.Bonus?.InnerXml.Contains("Rating") == true))
                                {
                                    ImprovementManager.CreateImprovements(this, Improvement.ImprovementSource.Metamagic,
                                                                          objMetamagic.InternalId, objMetamagic.Bonus,
                                                                          value,
                                                                          objMetamagic.CurrentDisplayNameShort);
                                }
                            }
                            catch
                            {
                                ImprovementManager.Rollback(this, CancellationToken.None);
                                throw;
                            }

                            ImprovementManager.Commit(this);
                        }
                        else
                        {
                            bool blnFoundImprovement = false;
                            // ReSharper disable once ForCanBeConvertedToForeach
                            for (int i = 0; i < Improvements.Count; ++i)
                            {
                                Improvement objImprovement = Improvements[i];
                                if (objImprovement.ImproveSource == Improvement.ImprovementSource.Initiation)
                                {
                                    blnFoundImprovement = true;
                                    objImprovement.Rating = value;
                                }
                            }
                            if (!blnFoundImprovement)
                            {
                                // Create the new Improvement.
                                try
                                {
                                    ImprovementManager.CreateImprovement(this, "MAG",
                                                                         Improvement.ImprovementSource.Initiation,
                                                                         string.Empty,
                                                                         Improvement.ImprovementType.Attribute,
                                                                         string.Empty, 0, value, 0, 1);
                                    ImprovementManager.CreateImprovement(this, "MAGAdept",
                                                                         Improvement.ImprovementSource.Initiation,
                                                                         string.Empty,
                                                                         Improvement.ImprovementType.Attribute,
                                                                         string.Empty, 0, value, 0, 1);
                                }
                                catch
                                {
                                    ImprovementManager.Rollback(this, CancellationToken.None);
                                    throw;
                                }

                                ImprovementManager.Commit(this);
                            }

                            // Update any Metamagic Improvements the character might have.
                            foreach (Metamagic objMetamagic in Metamagics.Where(
                                         x => x.SourceType == Improvement.ImprovementSource.Metamagic
                                              && x.Bonus?.InnerXml.Contains("Rating") == true))
                            {
                                blnFoundImprovement = false;
                                string strMetamagicId = objMetamagic.InternalId;
                                // ReSharper disable once ForCanBeConvertedToForeach
                                for (int i = 0; i < Improvements.Count; ++i)
                                {
                                    Improvement objImprovement = Improvements[i];
                                    if (objImprovement.SourceName == strMetamagicId &&
                                        objImprovement.ImproveSource == Improvement.ImprovementSource.Metamagic)
                                    {
                                        blnFoundImprovement = true;
                                        objImprovement.Rating = value;
                                    }
                                }
                                // If the Bonus contains "Rating", refresh ratings of existing Improvements.
                                if (!blnFoundImprovement)
                                {
                                    try
                                    {
                                        ImprovementManager.CreateImprovements(
                                            this, Improvement.ImprovementSource.Metamagic,
                                            strMetamagicId, objMetamagic.Bonus, value,
                                            objMetamagic.CurrentDisplayNameShort);
                                    }
                                    catch
                                    {
                                        ImprovementManager.Rollback(this, CancellationToken.None);
                                        throw;
                                    }

                                    ImprovementManager.Commit(this);
                                }
                            }
                        }

                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Initiate Grade.
        /// </summary>
        public async ValueTask<int> GetInitiateGradeAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _intInitiateGrade;
        }

        /// <summary>
        /// Initiate Grade.
        /// </summary>
        public async ValueTask SetInitiateGradeAsync(int value, CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (_intInitiateGrade == value)
                    return;
                IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    int intOldValue = Interlocked.Exchange(ref _intInitiateGrade, value);
                    if (intOldValue == value)
                        return;
                    bool blnFirstInitiation = intOldValue == 0;
                    // Remove any existing Initiation Improvements.
                    if (value == 0)
                    {
                        await ImprovementManager
                              .RemoveImprovementsAsync(this, Improvement.ImprovementSource.Initiation, token: token)
                              .ConfigureAwait(false);
                        // Update any Metamagic Improvements the character might have.
                        await Metamagics.ForEachAsync(async objMetamagic =>
                        {
                            if (objMetamagic.SourceType == Improvement.ImprovementSource.Metamagic
                                && objMetamagic.Bonus?.InnerXml.Contains("Rating") == true)
                            {
                                await ImprovementManager.RemoveImprovementsAsync(
                                    this, Improvement.ImprovementSource.Metamagic,
                                    objMetamagic.InternalId, token).ConfigureAwait(false);
                            }
                        }, token).ConfigureAwait(false);
                    }
                    else if (blnFirstInitiation)
                    {
                        try
                        {
                            // Create the new Improvement.
                            await ImprovementManager.CreateImprovementAsync(
                                this, "MAG", Improvement.ImprovementSource.Initiation,
                                string.Empty, Improvement.ImprovementType.Attribute,
                                string.Empty, 0, value, 0, 1, token: token).ConfigureAwait(false);
                            await ImprovementManager.CreateImprovementAsync(this, "MAGAdept",
                                                                            Improvement.ImprovementSource.Initiation,
                                                                            string.Empty,
                                                                            Improvement.ImprovementType.Attribute,
                                                                            string.Empty, 0, value, 0, 1, token: token)
                                                    .ConfigureAwait(false);
                            // Update any Metamagic Improvements the character might have.
                            await Metamagics.ForEachAsync(async objMetamagic =>
                            {
                                if (objMetamagic.SourceType == Improvement.ImprovementSource.Metamagic
                                    && objMetamagic.Bonus?.InnerXml.Contains("Rating") == true)
                                {
                                    await ImprovementManager.CreateImprovementsAsync(
                                        this, Improvement.ImprovementSource.Metamagic, objMetamagic.InternalId,
                                        objMetamagic.Bonus, value,
                                        await objMetamagic.GetCurrentDisplayNameShortAsync(token).ConfigureAwait(false),
                                        token: token).ConfigureAwait(false);
                                }
                            }, token).ConfigureAwait(false);
                        }
                        catch
                        {
                            await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }

                        ImprovementManager.Commit(this);
                    }
                    else
                    {
                        bool blnFoundImprovement = false;
                        // ReSharper disable once ForCanBeConvertedToForeach
                        for (int i = 0; i < await Improvements.GetCountAsync(token).ConfigureAwait(false); ++i)
                        {
                            Improvement objImprovement
                                = await Improvements.GetValueAtAsync(i, token).ConfigureAwait(false);
                            if (objImprovement.ImproveSource == Improvement.ImprovementSource.Initiation)
                            {
                                blnFoundImprovement = true;
                                objImprovement.Rating = value;
                            }
                        }
                        if (!blnFoundImprovement)
                        {
                            // Create the new Improvement.
                            try
                            {
                                await ImprovementManager.CreateImprovementAsync(this, "MAG",
                                                            Improvement.ImprovementSource.Initiation,
                                                            string.Empty,
                                                            Improvement.ImprovementType.Attribute,
                                                            string.Empty, 0, value, 0, 1, token: token)
                                                        .ConfigureAwait(false);
                                await ImprovementManager.CreateImprovementAsync(this, "MAGAdept",
                                                            Improvement.ImprovementSource.Initiation,
                                                            string.Empty,
                                                            Improvement.ImprovementType.Attribute,
                                                            string.Empty, 0, value, 0, 1, token: token)
                                                        .ConfigureAwait(false);
                            }
                            catch
                            {
                                await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                                throw;
                            }

                            ImprovementManager.Commit(this);
                        }

                        // Update any Metamagic Improvements the character might have.
                        await Metamagics.ForEachAsync(async objMetamagic =>
                        {
                            if (objMetamagic.SourceType == Improvement.ImprovementSource.Metamagic
                                && objMetamagic.Bonus?.InnerXml.Contains("Rating") == true)
                            {
                                blnFoundImprovement = false;
                                string strMetamagicId = objMetamagic.InternalId;
                                // ReSharper disable once ForCanBeConvertedToForeach
                                for (int i = 0;
                                     i < await Improvements.GetCountAsync(token).ConfigureAwait(false);
                                     ++i)
                                {
                                    Improvement objImprovement = await Improvements.GetValueAtAsync(i, token)
                                        .ConfigureAwait(false);
                                    if (objImprovement.SourceName == strMetamagicId && objImprovement.ImproveSource
                                        == Improvement.ImprovementSource.Initiation)
                                    {
                                        blnFoundImprovement = true;
                                        objImprovement.Rating = value;
                                    }
                                }
                                // If the Bonus contains "Rating", refresh ratings of existing Improvements.
                                if (!blnFoundImprovement)
                                {
                                    try
                                    {
                                        await ImprovementManager.CreateImprovementsAsync(
                                            this, Improvement.ImprovementSource.Metamagic, strMetamagicId,
                                            objMetamagic.Bonus, value,
                                            await objMetamagic.GetCurrentDisplayNameShortAsync(token)
                                                              .ConfigureAwait(false),
                                            token: token).ConfigureAwait(false);
                                    }
                                    catch
                                    {
                                        await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                                        throw;
                                    }

                                    ImprovementManager.Commit(this);
                                }
                            }
                        }, token).ConfigureAwait(false);
                    }

                    OnPropertyChanged(nameof(InitiateGrade));
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
        }

        /// <summary>
        /// Is the RES CharacterAttribute enabled?
        /// </summary>
        [HubTag]
        public bool RESEnabled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnRESEnabled;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnRESEnabled == value)
                        return;
                    if (IsLoading)
                    {
                        using (LockObject.EnterWriteLock())
                            _blnRESEnabled = value;
                        OnPropertyChanged();
                        return;
                    }
                    using (LockObject.EnterWriteLock())
                    {
                        _blnRESEnabled = value;
                        if (value)
                        {
                            // Career mode, so no extra calculations need to be done for EssenceAtSpecialStart
                            if (Created)
                            {
                                ResetCachedEssence();
                                EssenceAtSpecialStart = Essence(true, "RES");
                            }
                            // EssenceAtSpecialStart needs to be calculated by assuming that the character took the RES-enabling quality with the highest essence penalty first, as that would be the most optimal
                            else
                            {
                                // If this character has any RES-enabling bonuses that could be granted before all others (because they're priority and/or metatype-given),
                                // it has to be assumed those are taken first.
                                List<Improvement> lstAttributeImprovements = ImprovementManager
                                    .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Attribute,
                                                                        "RES");
                                bool blnCountOnlyPriorityOrMetatypeGivenBonuses = lstAttributeImprovements.Any(
                                    x => x.ImproveSource
                                         == Improvement.ImprovementSource
                                                       .Metatype
                                         || x.ImproveSource
                                         == Improvement.ImprovementSource
                                                       .Metavariant
                                         || x.ImproveSource
                                         == Improvement.ImprovementSource
                                                       .Heritage);
                                if (!blnCountOnlyPriorityOrMetatypeGivenBonuses)
                                {
                                    List<string> lstRESEnablingQualityIds = lstAttributeImprovements
                                                                            .Where(x => x.ImproveSource
                                                                                == Improvement.ImprovementSource
                                                                                    .Quality).Select(
                                                                                x => x.SourceName).ToList();
                                    // Can't use foreach because new items can get added to this list while it is looping
                                    for (int i = 0; i < lstRESEnablingQualityIds.Count; ++i)
                                    {
                                        Quality objQuality
                                            = Qualities.FirstOrDefault(
                                                x => x.InternalId == lstRESEnablingQualityIds[i]);
                                        if (objQuality != null)
                                        {
                                            if (objQuality.OriginSource == QualitySource.Metatype
                                                || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                                || objQuality.OriginSource == QualitySource.BuiltIn
                                                || objQuality.OriginSource == QualitySource.LifeModule
                                                || objQuality.OriginSource == QualitySource.Heritage)
                                            {
                                                blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                                break;
                                            }

                                            if (objQuality.OriginSource == QualitySource.Improvement)
                                            {
                                                List<Improvement> lstSpecificQualityImprovements = ImprovementManager
                                                    .GetCachedImprovementListForValueOf(
                                                        this, Improvement.ImprovementType.SpecificQuality,
                                                        objQuality.InternalId);
                                                if (lstSpecificQualityImprovements.Any(x =>
                                                        x.ImproveSource == Improvement.ImprovementSource.Metatype
                                                        || x.ImproveSource == Improvement.ImprovementSource
                                                            .Metavariant
                                                        || x.ImproveSource
                                                        == Improvement.ImprovementSource.Heritage))
                                                {
                                                    blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                                    break;
                                                }

                                                // Qualities that add other qualities get added to the list to be checked, too
                                                lstRESEnablingQualityIds.AddRange(
                                                    lstSpecificQualityImprovements
                                                        .Where(
                                                            x => x.ImproveSource
                                                                 == Improvement.ImprovementSource.Quality)
                                                        .Select(x => x.SourceName));
                                            }
                                        }
                                    }
                                }

                                Dictionary<string, decimal> dicImprovementEssencePenalties =
                                    new Dictionary<string, decimal>(Improvements.Count);
                                foreach (Improvement objImprovement in Improvements)
                                {
                                    if (!objImprovement.Enabled)
                                        continue;
                                    bool blnCountImprovement = !blnCountOnlyPriorityOrMetatypeGivenBonuses
                                                               || objImprovement.ImproveSource
                                                               == Improvement.ImprovementSource.Metatype
                                                               || objImprovement.ImproveSource
                                                               == Improvement.ImprovementSource.Metavariant
                                                               || objImprovement.ImproveSource
                                                               == Improvement.ImprovementSource.Heritage;
                                    if (!blnCountImprovement
                                        && objImprovement.ImproveSource == Improvement.ImprovementSource.Quality)
                                    {
                                        Quality objQuality
                                            = Qualities.FirstOrDefault(x => x.InternalId == objImprovement.SourceName);
                                        while (objQuality != null)
                                        {
                                            if (objQuality.OriginSource == QualitySource.Metatype
                                                || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                                || objQuality.OriginSource == QualitySource.BuiltIn
                                                || objQuality.OriginSource == QualitySource.LifeModule
                                                || objQuality.OriginSource == QualitySource.Heritage)
                                            {
                                                blnCountImprovement = true;
                                                break;
                                            }

                                            if (objQuality.OriginSource == QualitySource.Improvement)
                                            {
                                                Improvement objParentImprovement = ImprovementManager
                                                    .GetCachedImprovementListForValueOf(
                                                        this,
                                                        Improvement.ImprovementType
                                                                   .SpecificQuality,
                                                        objQuality.InternalId)
                                                    .FirstOrDefault();
                                                if (objParentImprovement == null)
                                                    break;
                                                if (objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Metatype
                                                    || objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Metavariant
                                                    || objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Heritage)
                                                {
                                                    blnCountImprovement = true;
                                                    break;
                                                }

                                                if (objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Quality)
                                                {
                                                    // Qualities that add other qualities get added to the list to be checked, too
                                                    objQuality = Qualities.FirstOrDefault(
                                                        x => x.InternalId == objParentImprovement.SourceName);
                                                }
                                                else
                                                    break;
                                            }
                                            else
                                                break;
                                        }
                                    }

                                    if (blnCountImprovement)
                                    {
                                        decimal decLoopEssencePenalty = 0;
                                        switch (objImprovement.ImproveType)
                                        {
                                            case Improvement.ImprovementType.EssencePenalty:
                                                decLoopEssencePenalty += objImprovement.Value;
                                                break;

                                            case Improvement.ImprovementType.EssencePenaltyT100:
                                            case Improvement.ImprovementType.EssencePenaltyRESOnlyT100:
                                                decLoopEssencePenalty += objImprovement.Value / 100.0m;
                                                break;
                                        }

                                        if (decLoopEssencePenalty != 0)
                                        {
                                            if (dicImprovementEssencePenalties.TryGetValue(
                                                    objImprovement.SourceName, out decimal decExistingPenalty))
                                                dicImprovementEssencePenalties[objImprovement.SourceName]
                                                    = decExistingPenalty + decLoopEssencePenalty;
                                            else
                                                dicImprovementEssencePenalties.Add(objImprovement.SourceName,
                                                    decLoopEssencePenalty);
                                        }
                                    }
                                }

                                if (dicImprovementEssencePenalties.Count > 0)
                                    EssenceAtSpecialStart =
                                        ESS.MetatypeMaximum + dicImprovementEssencePenalties.Values.Min();
                                else
                                    EssenceAtSpecialStart = ESS.MetatypeMaximum;
                            }

                            XmlNode xmlTraditionListDataNode
                                = LoadData("streams.xml").SelectSingleNode("/chummer/traditions");
                            if (xmlTraditionListDataNode != null)
                            {
                                XmlNode xmlTraditionDataNode
                                    = xmlTraditionListDataNode.SelectSingleNode("tradition[name = \"Default\"]");
                                if (xmlTraditionDataNode != null)
                                {
                                    if (!MagicTradition.Create(xmlTraditionDataNode, true))
                                        MagicTradition.ResetTradition();
                                }
                                else
                                {
                                    xmlTraditionDataNode = xmlTraditionListDataNode["tradition"];
                                    if (xmlTraditionDataNode != null
                                        && !MagicTradition.Create(xmlTraditionDataNode, true))
                                    {
                                        MagicTradition.ResetTradition();
                                    }
                                }
                            }
                        }
                        else
                        {
                            if (!MAGEnabled)
                            {
                                ClearInitiations();
                                MagicTradition.ResetTradition();
                            }
                            else
                            {
                                XmlNode xmlTraditionListDataNode
                                    = LoadData("traditions.xml").SelectSingleNode("/chummer/traditions");
                                if (xmlTraditionListDataNode != null)
                                {
                                    XmlNode xmlTraditionDataNode
                                        = xmlTraditionListDataNode.TryGetNodeByNameOrId("tradition", Tradition.CustomMagicalTraditionGuid);
                                    if (xmlTraditionDataNode != null)
                                    {
                                        if (!MagicTradition.Create(xmlTraditionDataNode))
                                            MagicTradition.ResetTradition();
                                    }
                                    else
                                        MagicTradition.ResetTradition();
                                }
                                else
                                    MagicTradition.ResetTradition();
                            }

                            if (!Created && !DEPEnabled && !MAGEnabled)
                                EssenceAtSpecialStart = decimal.MinValue;
                        }

                        ImprovementManager.ClearCachedValue(this, Improvement.ImprovementType.MatrixInitiativeDice);
                    }
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Is the RES CharacterAttribute enabled?
        /// </summary>
        public async ValueTask<bool> GetRESEnabledAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _blnRESEnabled;
        }

        /// <summary>
        /// Is the RES CharacterAttribute enabled?
        /// </summary>
        public async ValueTask SetRESEnabledAsync(bool value, CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (_blnRESEnabled == value)
                    return;
                if (IsLoading)
                {
                    IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                    try
                    {
                        _blnRESEnabled = value;
                    }
                    finally
                    {
                        await objLocker2.DisposeAsync().ConfigureAwait(false);
                    }
                    OnPropertyChanged();
                    return;
                }
                IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    _blnRESEnabled = value;
                    if (value)
                    {
                        // Career mode, so no extra calculations need to be done for EssenceAtSpecialStart
                        if (await GetCreatedAsync(token).ConfigureAwait(false))
                        {
                            await ResetCachedEssenceAsync(token).ConfigureAwait(false);
                            await SetEssenceAtSpecialStartAsync(
                                    await EssenceAsync(true, "RES", token).ConfigureAwait(false), token)
                                .ConfigureAwait(false);
                        }
                        // EssenceAtSpecialStart needs to be calculated by assuming that the character took the RES-enabling quality with the highest essence penalty first, as that would be the most optimal
                        else
                        {
                            // If this character has any RES-enabling bonuses that could be granted before all others (because they're priority and/or metatype-given),
                            // it has to be assumed those are taken first.
                            List<Improvement> lstAttributeImprovements = await ImprovementManager
                                                                               .GetCachedImprovementListForValueOfAsync(
                                                                                   this,
                                                                                   Improvement.ImprovementType
                                                                                       .Attribute,
                                                                                   "RES", token: token)
                                                                               .ConfigureAwait(false);
                            bool blnCountOnlyPriorityOrMetatypeGivenBonuses = lstAttributeImprovements.Any(
                                x => x.ImproveSource
                                     == Improvement.ImprovementSource
                                                   .Metatype
                                     || x.ImproveSource
                                     == Improvement.ImprovementSource
                                                   .Metavariant
                                     || x.ImproveSource
                                     == Improvement.ImprovementSource
                                                   .Heritage);
                            if (!blnCountOnlyPriorityOrMetatypeGivenBonuses)
                            {
                                List<string> lstRESEnablingQualityIds = lstAttributeImprovements
                                                                        .Where(x => x.ImproveSource
                                                                                   == Improvement.ImprovementSource
                                                                                       .Quality).Select(
                                                                            x => x.SourceName).ToList();
                                // Can't use foreach because new items can get added to this list while it is looping
                                for (int i = 0; i < lstRESEnablingQualityIds.Count; ++i)
                                {
                                    int i1 = i;
                                    Quality objQuality
                                        = await Qualities.FirstOrDefaultAsync(
                                                             x => x.InternalId == lstRESEnablingQualityIds[i1],
                                                             token: token)
                                                         .ConfigureAwait(false);
                                    if (objQuality != null)
                                    {
                                        if (objQuality.OriginSource == QualitySource.Metatype
                                            || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                            || objQuality.OriginSource == QualitySource.BuiltIn
                                            || objQuality.OriginSource == QualitySource.LifeModule
                                            || objQuality.OriginSource == QualitySource.Heritage)
                                        {
                                            blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                            break;
                                        }

                                        if (objQuality.OriginSource == QualitySource.Improvement)
                                        {
                                            List<Improvement> lstSpecificQualityImprovements = await ImprovementManager
                                                .GetCachedImprovementListForValueOfAsync(
                                                    this, Improvement.ImprovementType.SpecificQuality,
                                                    objQuality.InternalId, token: token).ConfigureAwait(false);
                                            if (lstSpecificQualityImprovements.Any(x =>
                                                    x.ImproveSource == Improvement.ImprovementSource.Metatype
                                                    || x.ImproveSource == Improvement.ImprovementSource
                                                        .Metavariant
                                                    || x.ImproveSource
                                                    == Improvement.ImprovementSource.Heritage))
                                            {
                                                blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                                break;
                                            }

                                            // Qualities that add other qualities get added to the list to be checked, too
                                            lstRESEnablingQualityIds.AddRange(
                                                lstSpecificQualityImprovements
                                                    .Where(
                                                        x => x.ImproveSource
                                                             == Improvement.ImprovementSource.Quality)
                                                    .Select(x => x.SourceName));
                                        }
                                    }
                                }
                            }

                            Dictionary<string, decimal> dicImprovementEssencePenalties =
                                new Dictionary<string, decimal>(
                                    await Improvements.GetCountAsync(token).ConfigureAwait(false));
                            foreach (Improvement objImprovement in Improvements)
                            {
                                if (!objImprovement.Enabled)
                                    continue;
                                bool blnCountImprovement = !blnCountOnlyPriorityOrMetatypeGivenBonuses
                                                           || objImprovement.ImproveSource
                                                           == Improvement.ImprovementSource.Metatype
                                                           || objImprovement.ImproveSource
                                                           == Improvement.ImprovementSource.Metavariant
                                                           || objImprovement.ImproveSource
                                                           == Improvement.ImprovementSource.Heritage;
                                if (!blnCountImprovement && objImprovement.ImproveSource
                                    == Improvement.ImprovementSource.Quality)
                                {
                                    Quality objQuality
                                        = await Qualities.FirstOrDefaultAsync(
                                                             x => x.InternalId == objImprovement.SourceName,
                                                             token: token)
                                                         .ConfigureAwait(false);
                                    while (objQuality != null)
                                    {
                                        if (objQuality.OriginSource == QualitySource.Metatype
                                            || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                            || objQuality.OriginSource == QualitySource.BuiltIn
                                            || objQuality.OriginSource == QualitySource.LifeModule
                                            || objQuality.OriginSource == QualitySource.Heritage)
                                        {
                                            blnCountImprovement = true;
                                            break;
                                        }

                                        if (objQuality.OriginSource == QualitySource.Improvement)
                                        {
                                            Improvement objParentImprovement = (await ImprovementManager
                                                    .GetCachedImprovementListForValueOfAsync(
                                                        this,
                                                        Improvement.ImprovementType
                                                                   .SpecificQuality,
                                                        objQuality.InternalId, token: token).ConfigureAwait(false))
                                                .FirstOrDefault();
                                            if (objParentImprovement == null)
                                                break;
                                            if (objParentImprovement.ImproveSource
                                                == Improvement.ImprovementSource.Metatype
                                                || objParentImprovement.ImproveSource
                                                == Improvement.ImprovementSource.Metavariant
                                                || objParentImprovement.ImproveSource
                                                == Improvement.ImprovementSource.Heritage)
                                            {
                                                blnCountImprovement = true;
                                                break;
                                            }

                                            if (objParentImprovement.ImproveSource
                                                == Improvement.ImprovementSource.Quality)
                                            {
                                                // Qualities that add other qualities get added to the list to be checked, too
                                                objQuality = await Qualities.FirstOrDefaultAsync(
                                                                                x => x.InternalId
                                                                                    == objParentImprovement.SourceName,
                                                                                token: token)
                                                                            .ConfigureAwait(false);
                                            }
                                            else
                                                break;
                                        }
                                        else
                                            break;
                                    }
                                }

                                if (blnCountImprovement)
                                {
                                    decimal decLoopEssencePenalty = 0;
                                    switch (objImprovement.ImproveType)
                                    {
                                        case Improvement.ImprovementType.EssencePenalty:
                                            decLoopEssencePenalty += objImprovement.Value;
                                            break;

                                        case Improvement.ImprovementType.EssencePenaltyT100:
                                        case Improvement.ImprovementType.EssencePenaltyRESOnlyT100:
                                            decLoopEssencePenalty += objImprovement.Value / 100.0m;
                                            break;
                                    }

                                    if (decLoopEssencePenalty != 0)
                                    {
                                        if (dicImprovementEssencePenalties.TryGetValue(
                                                objImprovement.SourceName, out decimal decExistingPenalty))
                                            dicImprovementEssencePenalties[objImprovement.SourceName]
                                                = decExistingPenalty + decLoopEssencePenalty;
                                        else
                                            dicImprovementEssencePenalties.Add(objImprovement.SourceName,
                                                                               decLoopEssencePenalty);
                                    }
                                }
                            }

                            if (dicImprovementEssencePenalties.Count > 0)
                                await SetEssenceAtSpecialStartAsync(
                                    await ESS.GetMetatypeMaximumAsync(token).ConfigureAwait(false)
                                    + dicImprovementEssencePenalties.Values.Min(), token).ConfigureAwait(false);
                            else
                                await SetEssenceAtSpecialStartAsync(
                                        await ESS.GetMetatypeMaximumAsync(token).ConfigureAwait(false), token)
                                    .ConfigureAwait(false);
                        }
                    }
                    else
                    {
                        if (!await GetMAGEnabledAsync(token).ConfigureAwait(false))
                        {
                            await ClearInitiationsAsync(token).ConfigureAwait(false);
                            await MagicTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                        }
                        else
                        {
                            XmlNode xmlTraditionListDataNode
                                = (await LoadDataAsync("streams.xml", token: token).ConfigureAwait(false))
                                .SelectSingleNode("/chummer/traditions");
                            if (xmlTraditionListDataNode != null)
                            {
                                XmlNode xmlTraditionDataNode
                                    = xmlTraditionListDataNode.SelectSingleNode("tradition[name = \"Default\"]");
                                if (xmlTraditionDataNode != null)
                                {
                                    if (!MagicTradition.Create(xmlTraditionDataNode, true))
                                        await MagicTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                                }
                                else
                                    await MagicTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                            }
                            else
                                await MagicTradition.ResetTraditionAsync(token).ConfigureAwait(false);
                        }

                        if (!await GetCreatedAsync(token).ConfigureAwait(false)
                            && !await GetMAGEnabledAsync(token).ConfigureAwait(false)
                            && !await GetDEPEnabledAsync(token).ConfigureAwait(false))
                            await SetEssenceAtSpecialStartAsync(decimal.MinValue, token).ConfigureAwait(false);
                    }

                    await ImprovementManager.ClearCachedValueAsync(this, Improvement.ImprovementType.MatrixInitiativeDice, token: token).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
                OnPropertyChanged(nameof(RESEnabled));
            }
        }

        /// <summary>
        /// Is the DEP CharacterAttribute enabled?
        /// </summary>
        [HubTag]
        public bool DEPEnabled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnDEPEnabled;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnDEPEnabled == value)
                        return;
                    if (IsLoading)
                    {
                        using (LockObject.EnterWriteLock())
                            _blnDEPEnabled = value;
                        OnPropertyChanged();
                        return;
                    }
                    using (LockObject.EnterWriteLock())
                    {
                        _blnDEPEnabled = value;
                        if (value)
                        {
                            // Career mode, so no extra calculations need to be done for EssenceAtSpecialStart
                            if (Created)
                            {
                                ResetCachedEssence();
                                EssenceAtSpecialStart = Essence(true, "DEP");
                            }
                            // EssenceAtSpecialStart needs to be calculated by assuming that the character took the DEP-enabling quality with the highest essence penalty first, as that would be the most optimal
                            else
                            {
                                // If this character has any DEP-enabling bonuses that could be granted before all others (because they're priority and/or metatype-given),
                                // it has to be assumed those are taken first.
                                List<Improvement> lstAttributeImprovements = ImprovementManager
                                    .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Attribute,
                                                                        "DEP");
                                bool blnCountOnlyPriorityOrMetatypeGivenBonuses = lstAttributeImprovements.Any(
                                    x => x.ImproveSource
                                         == Improvement.ImprovementSource
                                                       .Metatype
                                         || x.ImproveSource
                                         == Improvement.ImprovementSource
                                                       .Metavariant
                                         || x.ImproveSource
                                         == Improvement.ImprovementSource
                                                       .Heritage);
                                if (!blnCountOnlyPriorityOrMetatypeGivenBonuses)
                                {
                                    List<string> lstDEPEnablingQualityIds = lstAttributeImprovements
                                                                            .Where(x => x.ImproveSource
                                                                                == Improvement.ImprovementSource
                                                                                    .Quality).Select(
                                                                                x => x.SourceName).ToList();
                                    // Can't use foreach because new items can get added to this list while it is looping
                                    for (int i = 0; i < lstDEPEnablingQualityIds.Count; ++i)
                                    {
                                        Quality objQuality
                                            = Qualities.FirstOrDefault(
                                                x => x.InternalId == lstDEPEnablingQualityIds[i]);
                                        if (objQuality != null)
                                        {
                                            if (objQuality.OriginSource == QualitySource.Metatype
                                                || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                                || objQuality.OriginSource == QualitySource.BuiltIn
                                                || objQuality.OriginSource == QualitySource.LifeModule
                                                || objQuality.OriginSource == QualitySource.Heritage)
                                            {
                                                blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                                break;
                                            }

                                            if (objQuality.OriginSource == QualitySource.Improvement)
                                            {
                                                List<Improvement> lstSpecificQualityImprovements = ImprovementManager
                                                    .GetCachedImprovementListForValueOf(
                                                        this, Improvement.ImprovementType.SpecificQuality,
                                                        objQuality.InternalId);
                                                if (lstSpecificQualityImprovements.Any(x =>
                                                        x.ImproveSource == Improvement.ImprovementSource.Metatype
                                                        || x.ImproveSource == Improvement.ImprovementSource
                                                            .Metavariant
                                                        || x.ImproveSource
                                                        == Improvement.ImprovementSource.Heritage))
                                                {
                                                    blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                                    break;
                                                }

                                                // Qualities that add other qualities get added to the list to be checked, too
                                                lstDEPEnablingQualityIds.AddRange(
                                                    lstSpecificQualityImprovements
                                                        .Where(
                                                            x => x.ImproveSource
                                                                 == Improvement.ImprovementSource.Quality)
                                                        .Select(x => x.SourceName));
                                            }
                                        }
                                    }
                                }

                                Dictionary<string, decimal> dicImprovementEssencePenalties =
                                    new Dictionary<string, decimal>(Improvements.Count);
                                foreach (Improvement objImprovement in Improvements)
                                {
                                    if (!objImprovement.Enabled)
                                        continue;
                                    bool blnCountImprovement = !blnCountOnlyPriorityOrMetatypeGivenBonuses
                                                               || objImprovement.ImproveSource
                                                               == Improvement.ImprovementSource.Metatype
                                                               || objImprovement.ImproveSource
                                                               == Improvement.ImprovementSource.Metavariant
                                                               || objImprovement.ImproveSource
                                                               == Improvement.ImprovementSource.Heritage;
                                    if (!blnCountImprovement
                                        && objImprovement.ImproveSource == Improvement.ImprovementSource.Quality)
                                    {
                                        Quality objQuality
                                            = Qualities.FirstOrDefault(x => x.InternalId == objImprovement.SourceName);
                                        while (objQuality != null)
                                        {
                                            if (objQuality.OriginSource == QualitySource.Metatype
                                                || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                                || objQuality.OriginSource == QualitySource.BuiltIn
                                                || objQuality.OriginSource == QualitySource.LifeModule
                                                || objQuality.OriginSource == QualitySource.Heritage)
                                            {
                                                blnCountImprovement = true;
                                                break;
                                            }

                                            if (objQuality.OriginSource == QualitySource.Improvement)
                                            {
                                                Improvement objParentImprovement = ImprovementManager
                                                    .GetCachedImprovementListForValueOf(
                                                        this,
                                                        Improvement.ImprovementType
                                                                   .SpecificQuality,
                                                        objQuality.InternalId)
                                                    .FirstOrDefault();
                                                if (objParentImprovement == null)
                                                    break;
                                                if (objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Metatype
                                                    || objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Metavariant
                                                    || objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Heritage)
                                                {
                                                    blnCountImprovement = true;
                                                    break;
                                                }

                                                if (objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Quality)
                                                {
                                                    // Qualities that add other qualities get added to the list to be checked, too
                                                    objQuality = Qualities.FirstOrDefault(
                                                        x => x.InternalId == objParentImprovement.SourceName);
                                                }
                                                else
                                                    break;
                                            }
                                            else
                                                break;
                                        }
                                    }

                                    if (blnCountImprovement)
                                    {
                                        decimal decLoopEssencePenalty = 0;
                                        switch (objImprovement.ImproveType)
                                        {
                                            case Improvement.ImprovementType.EssencePenalty:
                                                decLoopEssencePenalty += objImprovement.Value;
                                                break;

                                            case Improvement.ImprovementType.EssencePenaltyT100:
                                            case Improvement.ImprovementType.EssencePenaltyDEPOnlyT100:
                                                decLoopEssencePenalty += objImprovement.Value / 100.0m;
                                                break;
                                        }

                                        if (decLoopEssencePenalty != 0)
                                        {
                                            if (dicImprovementEssencePenalties.TryGetValue(
                                                    objImprovement.SourceName, out decimal decExistingPenalty))
                                                dicImprovementEssencePenalties[objImprovement.SourceName]
                                                    = decExistingPenalty + decLoopEssencePenalty;
                                            else
                                                dicImprovementEssencePenalties.Add(objImprovement.SourceName,
                                                    decLoopEssencePenalty);
                                        }
                                    }
                                }

                                if (dicImprovementEssencePenalties.Count > 0)
                                    EssenceAtSpecialStart =
                                        ESS.MetatypeMaximum + dicImprovementEssencePenalties.Values.Min();
                                else
                                    EssenceAtSpecialStart = ESS.MetatypeMaximum;
                            }
                        }
                        else if (!Created && !RESEnabled && !MAGEnabled)
                            EssenceAtSpecialStart = decimal.MinValue;
                    }
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Is the DEP CharacterAttribute enabled?
        /// </summary>
        public async ValueTask<bool> GetDEPEnabledAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _blnDEPEnabled;
        }

        /// <summary>
        /// Is the DEP CharacterAttribute enabled?
        /// </summary>
        public async ValueTask SetDEPEnabledAsync(bool value, CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (_blnDEPEnabled == value)
                    return;
                if (IsLoading)
                {
                    IAsyncDisposable objLocker2 = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                    try
                    {
                        _blnDEPEnabled = value;
                    }
                    finally
                    {
                        await objLocker2.DisposeAsync().ConfigureAwait(false);
                    }
                    OnPropertyChanged();
                    return;
                }
                IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    _blnDEPEnabled = value;
                    if (value)
                    {
                        // Career mode, so no extra calculations need to be done for EssenceAtSpecialStart
                        if (await GetCreatedAsync(token).ConfigureAwait(false))
                        {
                            await ResetCachedEssenceAsync(token).ConfigureAwait(false);
                            await SetEssenceAtSpecialStartAsync(
                                    await EssenceAsync(true, "DEP", token).ConfigureAwait(false), token)
                                .ConfigureAwait(false);
                        }
                        // EssenceAtSpecialStart needs to be calculated by assuming that the character took the DEP-enabling quality with the highest essence penalty first, as that would be the most optimal
                        else
                        {
                            // If this character has any DEP-enabling bonuses that could be granted before all others (because they're priority and/or metatype-given),
                            // it has to be assumed those are taken first.
                            List<Improvement> lstAttributeImprovements = await ImprovementManager
                                                                               .GetCachedImprovementListForValueOfAsync(
                                                                                   this,
                                                                                   Improvement.ImprovementType
                                                                                       .Attribute,
                                                                                   "DEP", token: token)
                                                                               .ConfigureAwait(false);
                            bool blnCountOnlyPriorityOrMetatypeGivenBonuses = lstAttributeImprovements.Any(
                                x => x.ImproveSource
                                     == Improvement.ImprovementSource
                                                   .Metatype
                                     || x.ImproveSource
                                     == Improvement.ImprovementSource
                                                   .Metavariant
                                     || x.ImproveSource
                                     == Improvement.ImprovementSource
                                                   .Heritage);
                            if (!blnCountOnlyPriorityOrMetatypeGivenBonuses)
                            {
                                List<string> lstDEPEnablingQualityIds = lstAttributeImprovements
                                                                        .Where(x => x.ImproveSource
                                                                                   == Improvement.ImprovementSource
                                                                                       .Quality).Select(
                                                                            x => x.SourceName).ToList();
                                // Can't use foreach because new items can get added to this list while it is looping
                                for (int i = 0; i < lstDEPEnablingQualityIds.Count; ++i)
                                {
                                    int i1 = i;
                                    Quality objQuality
                                        = await Qualities.FirstOrDefaultAsync(
                                                             x => x.InternalId == lstDEPEnablingQualityIds[i1],
                                                             token: token)
                                                         .ConfigureAwait(false);
                                    if (objQuality != null)
                                    {
                                        if (objQuality.OriginSource == QualitySource.Metatype
                                            || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                            || objQuality.OriginSource == QualitySource.BuiltIn
                                            || objQuality.OriginSource == QualitySource.LifeModule
                                            || objQuality.OriginSource == QualitySource.Heritage)
                                        {
                                            blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                            break;
                                        }

                                        if (objQuality.OriginSource == QualitySource.Improvement)
                                        {
                                            List<Improvement> lstSpecificQualityImprovements = await ImprovementManager
                                                .GetCachedImprovementListForValueOfAsync(
                                                    this, Improvement.ImprovementType.SpecificQuality,
                                                    objQuality.InternalId, token: token).ConfigureAwait(false);
                                            if (lstSpecificQualityImprovements.Any(x =>
                                                    x.ImproveSource == Improvement.ImprovementSource.Metatype
                                                    || x.ImproveSource == Improvement.ImprovementSource
                                                        .Metavariant
                                                    || x.ImproveSource
                                                    == Improvement.ImprovementSource.Heritage))
                                            {
                                                blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                                break;
                                            }

                                            // Qualities that add other qualities get added to the list to be checked, too
                                            lstDEPEnablingQualityIds.AddRange(
                                                lstSpecificQualityImprovements
                                                    .Where(
                                                        x => x.ImproveSource
                                                             == Improvement.ImprovementSource.Quality)
                                                    .Select(x => x.SourceName));
                                        }
                                    }
                                }
                            }

                            Dictionary<string, decimal> dicImprovementEssencePenalties =
                                new Dictionary<string, decimal>(
                                    await Improvements.GetCountAsync(token).ConfigureAwait(false));
                            foreach (Improvement objImprovement in Improvements)
                            {
                                if (!objImprovement.Enabled)
                                    continue;
                                bool blnCountImprovement = !blnCountOnlyPriorityOrMetatypeGivenBonuses
                                                           || objImprovement.ImproveSource
                                                           == Improvement.ImprovementSource.Metatype
                                                           || objImprovement.ImproveSource
                                                           == Improvement.ImprovementSource.Metavariant
                                                           || objImprovement.ImproveSource
                                                           == Improvement.ImprovementSource.Heritage;
                                if (!blnCountImprovement && objImprovement.ImproveSource
                                    == Improvement.ImprovementSource.Quality)
                                {
                                    Quality objQuality
                                        = await Qualities.FirstOrDefaultAsync(
                                                             x => x.InternalId == objImprovement.SourceName,
                                                             token: token)
                                                         .ConfigureAwait(false);
                                    while (objQuality != null)
                                    {
                                        if (objQuality.OriginSource == QualitySource.Metatype
                                            || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                            || objQuality.OriginSource == QualitySource.BuiltIn
                                            || objQuality.OriginSource == QualitySource.LifeModule
                                            || objQuality.OriginSource == QualitySource.Heritage)
                                        {
                                            blnCountImprovement = true;
                                            break;
                                        }

                                        if (objQuality.OriginSource == QualitySource.Improvement)
                                        {
                                            Improvement objParentImprovement = (await ImprovementManager
                                                    .GetCachedImprovementListForValueOfAsync(
                                                        this,
                                                        Improvement.ImprovementType
                                                                   .SpecificQuality,
                                                        objQuality.InternalId, token: token).ConfigureAwait(false))
                                                .FirstOrDefault();
                                            if (objParentImprovement == null)
                                                break;
                                            if (objParentImprovement.ImproveSource
                                                == Improvement.ImprovementSource.Metatype
                                                || objParentImprovement.ImproveSource
                                                == Improvement.ImprovementSource.Metavariant
                                                || objParentImprovement.ImproveSource
                                                == Improvement.ImprovementSource.Heritage)
                                            {
                                                blnCountImprovement = true;
                                                break;
                                            }

                                            if (objParentImprovement.ImproveSource
                                                == Improvement.ImprovementSource.Quality)
                                            {
                                                // Qualities that add other qualities get added to the list to be checked, too
                                                objQuality = await Qualities.FirstOrDefaultAsync(
                                                                                x => x.InternalId
                                                                                    == objParentImprovement.SourceName,
                                                                                token: token)
                                                                            .ConfigureAwait(false);
                                            }
                                            else
                                                break;
                                        }
                                        else
                                            break;
                                    }
                                }

                                if (blnCountImprovement)
                                {
                                    decimal decLoopEssencePenalty = 0;
                                    switch (objImprovement.ImproveType)
                                    {
                                        case Improvement.ImprovementType.EssencePenalty:
                                            decLoopEssencePenalty += objImprovement.Value;
                                            break;

                                        case Improvement.ImprovementType.EssencePenaltyT100:
                                        case Improvement.ImprovementType.EssencePenaltyDEPOnlyT100:
                                            decLoopEssencePenalty += objImprovement.Value / 100.0m;
                                            break;
                                    }

                                    if (decLoopEssencePenalty != 0)
                                    {
                                        if (dicImprovementEssencePenalties.TryGetValue(
                                                objImprovement.SourceName, out decimal decExistingPenalty))
                                            dicImprovementEssencePenalties[objImprovement.SourceName]
                                                = decExistingPenalty + decLoopEssencePenalty;
                                        else
                                            dicImprovementEssencePenalties.Add(objImprovement.SourceName,
                                                                               decLoopEssencePenalty);
                                    }
                                }
                            }

                            if (dicImprovementEssencePenalties.Count > 0)
                                await SetEssenceAtSpecialStartAsync(
                                    await ESS.GetMetatypeMaximumAsync(token).ConfigureAwait(false)
                                    + dicImprovementEssencePenalties.Values.Min(), token).ConfigureAwait(false);
                            else
                                await SetEssenceAtSpecialStartAsync(
                                        await ESS.GetMetatypeMaximumAsync(token).ConfigureAwait(false), token)
                                    .ConfigureAwait(false);
                        }
                    }
                    else if (!await GetCreatedAsync(token).ConfigureAwait(false)
                             && !await GetRESEnabledAsync(token).ConfigureAwait(false)
                             && !await GetMAGEnabledAsync(token).ConfigureAwait(false))
                        await SetEssenceAtSpecialStartAsync(decimal.MinValue, token).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
                OnPropertyChanged(nameof(DEPEnabled));
            }
        }

        [HubTag]
        public bool IsAI
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return DEPEnabled && BOD?.MetatypeMaximum == 0;
            }
        }

        public async ValueTask<bool> GetIsAIAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (!await GetDEPEnabledAsync(token).ConfigureAwait(false))
                    return false;
                CharacterAttrib objBody = await GetAttributeAsync("BOD", token: token).ConfigureAwait(false);
                return objBody == null || await objBody.GetMetatypeMaximumAsync(token).ConfigureAwait(false) == 0;
            }
        }

        /// <summary>
        /// Submersion Grade.
        /// </summary>
        [HubTag]
        public int SubmersionGrade
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intSubmersionGrade;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intSubmersionGrade == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        int intOldValue = Interlocked.Exchange(ref _intSubmersionGrade, value);
                        if (intOldValue == value)
                            return;
                        bool blnFirstSubmersion = intOldValue == 0;
                        // Remove any existing Submersion Improvements.
                        if (value == 0)
                        {
                            ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Submersion);
                            // Update any Echo Improvements the character might have.
                            foreach (Metamagic objMetamagic in Metamagics.Where(
                                         x => x.SourceType == Improvement.ImprovementSource.Echo
                                              && x.Bonus?.InnerXml.Contains("Rating") == true))
                            {
                                ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Echo,
                                                                      objMetamagic.InternalId);
                            }
                        }
                        else if (blnFirstSubmersion)
                        {
                            try
                            {
                                // Create the new Improvement.
                                ImprovementManager.CreateImprovement(this, "RES", Improvement.ImprovementSource.Submersion,
                                                                     string.Empty, Improvement.ImprovementType.Attribute,
                                                                     string.Empty, 0, value, 0, 1);
                                // Update any Echo Improvements the character might have.
                                foreach (Metamagic objMetamagic in Metamagics.Where(
                                             x => x.SourceType == Improvement.ImprovementSource.Echo
                                                  && x.Bonus?.InnerXml.Contains("Rating") == true))
                                {
                                    ImprovementManager.CreateImprovements(this, Improvement.ImprovementSource.Echo,
                                                                          objMetamagic.InternalId, objMetamagic.Bonus,
                                                                          value,
                                                                          objMetamagic.CurrentDisplayNameShort);
                                }
                            }
                            catch
                            {
                                ImprovementManager.Rollback(this, CancellationToken.None);
                                throw;
                            }

                            ImprovementManager.Commit(this);
                        }
                        else
                        {
                            bool blnFoundImprovement = false;
                            // ReSharper disable once ForCanBeConvertedToForeach
                            for (int i = 0; i < Improvements.Count; ++i)
                            {
                                Improvement objImprovement = Improvements[i];
                                if (objImprovement.ImproveSource == Improvement.ImprovementSource.Submersion)
                                {
                                    blnFoundImprovement = true;
                                    objImprovement.Rating = value;
                                }
                            }
                            if (!blnFoundImprovement)
                            {
                                // Create the new Improvement.
                                try
                                {
                                    ImprovementManager.CreateImprovement(this, "RES",
                                                                         Improvement.ImprovementSource.Submersion,
                                                                         string.Empty,
                                                                         Improvement.ImprovementType.Attribute,
                                                                         string.Empty, 0, value, 0, 1);
                                }
                                catch
                                {
                                    ImprovementManager.Rollback(this, CancellationToken.None);
                                    throw;
                                }

                                ImprovementManager.Commit(this);
                            }

                            // Update any Echo Improvements the character might have.
                            foreach (Metamagic objMetamagic in Metamagics.Where(
                                         x => x.SourceType == Improvement.ImprovementSource.Echo
                                              && x.Bonus?.InnerXml.Contains("Rating") == true))
                            {
                                blnFoundImprovement = false;
                                string strMetamagicId = objMetamagic.InternalId;
                                // ReSharper disable once ForCanBeConvertedToForeach
                                for (int i = 0; i < Improvements.Count; ++i)
                                {
                                    Improvement objImprovement = Improvements[i];
                                    if (objImprovement.SourceName == strMetamagicId &&
                                        objImprovement.ImproveSource == Improvement.ImprovementSource.Echo)
                                    {
                                        blnFoundImprovement = true;
                                        objImprovement.Rating = value;
                                    }
                                }
                                // If the Bonus contains "Rating", refresh ratings of existing Improvements.
                                if (!blnFoundImprovement)
                                {
                                    try
                                    {
                                        ImprovementManager.CreateImprovements(this, Improvement.ImprovementSource.Echo,
                                                                              strMetamagicId, objMetamagic.Bonus, value,
                                                                              objMetamagic.CurrentDisplayNameShort);
                                    }
                                    catch
                                    {
                                        ImprovementManager.Rollback(this, CancellationToken.None);
                                        throw;
                                    }

                                    ImprovementManager.Commit(this);
                                }
                            }
                        }
                    }
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Submersion Grade.
        /// </summary>
        public async ValueTask<int> GetSubmersionGradeAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _intSubmersionGrade;
        }

        /// <summary>
        /// Submersion Grade.
        /// </summary>
        public async ValueTask SetSubmersionGradeAsync(int value, CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (_intSubmersionGrade == value)
                    return;
                IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    int intOldValue = Interlocked.Exchange(ref _intSubmersionGrade, value);
                    if (intOldValue == value)
                        return;
                    bool blnFirstSubmersion = intOldValue == 0;
                    // Remove any existing Submersion Improvements.
                    if (value == 0)
                    {
                        await ImprovementManager
                              .RemoveImprovementsAsync(this, Improvement.ImprovementSource.Submersion, token: token)
                              .ConfigureAwait(false);
                        // Update any Echo Improvements the character might have.
                        await Metamagics.ForEachAsync(async objMetamagic =>
                        {
                            if (objMetamagic.SourceType == Improvement.ImprovementSource.Echo
                                && objMetamagic.Bonus?.InnerXml.Contains("Rating") == true)
                            {
                                await ImprovementManager.RemoveImprovementsAsync(
                                                            this, Improvement.ImprovementSource.Echo,
                                                            objMetamagic.InternalId, token: token)
                                                        .ConfigureAwait(false);
                            }
                        }, token).ConfigureAwait(false);
                    }
                    else if (blnFirstSubmersion)
                    {
                        try
                        {
                            // Create the new Improvement.
                            await ImprovementManager.CreateImprovementAsync(
                                this, "RES", Improvement.ImprovementSource.Submersion,
                                string.Empty, Improvement.ImprovementType.Attribute,
                                string.Empty, 0, value, 0, 1, token: token).ConfigureAwait(false);
                            // Update any Echo Improvements the character might have.
                            await Metamagics.ForEachAsync(async objMetamagic =>
                            {
                                if (objMetamagic.SourceType == Improvement.ImprovementSource.Echo
                                    && objMetamagic.Bonus?.InnerXml.Contains("Rating") == true)
                                {
                                    await ImprovementManager.CreateImprovementsAsync(
                                        this, Improvement.ImprovementSource.Echo, objMetamagic.InternalId,
                                        objMetamagic.Bonus, value,
                                        await objMetamagic.GetCurrentDisplayNameShortAsync(token).ConfigureAwait(false),
                                        token: token).ConfigureAwait(false);
                                }
                            }, token).ConfigureAwait(false);
                        }
                        catch
                        {
                            await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }

                        ImprovementManager.Commit(this);
                    }
                    else
                    {
                        bool blnFoundImprovement = false;
                        // ReSharper disable once ForCanBeConvertedToForeach
                        for (int i = 0; i < await Improvements.GetCountAsync(token).ConfigureAwait(false); ++i)
                        {
                            Improvement objImprovement
                                = await Improvements.GetValueAtAsync(i, token).ConfigureAwait(false);
                            if (objImprovement.ImproveSource == Improvement.ImprovementSource.Submersion)
                            {
                                blnFoundImprovement = true;
                                objImprovement.Rating = value;
                            }
                        }
                        if (!blnFoundImprovement)
                        {
                            // Create the new Improvement.
                            try
                            {
                                await ImprovementManager.CreateImprovementAsync(this, "RES",
                                                            Improvement.ImprovementSource.Submersion,
                                                            string.Empty,
                                                            Improvement.ImprovementType.Attribute,
                                                            string.Empty, 0, value, 0, 1, token: token)
                                                        .ConfigureAwait(false);
                            }
                            catch
                            {
                                await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                                throw;
                            }

                            ImprovementManager.Commit(this);
                        }

                        // Update any Echo Improvements the character might have.
                        await Metamagics.ForEachAsync(async objMetamagic =>
                        {
                            if (objMetamagic.SourceType == Improvement.ImprovementSource.Echo
                                && objMetamagic.Bonus?.InnerXml.Contains("Rating") == true)
                            {
                                blnFoundImprovement = false;
                                string strMetamagicId = objMetamagic.InternalId;
                                // ReSharper disable once ForCanBeConvertedToForeach
                                for (int i = 0;
                                     i < await Improvements.GetCountAsync(token).ConfigureAwait(false);
                                     ++i)
                                {
                                    Improvement objImprovement = await Improvements.GetValueAtAsync(i, token)
                                        .ConfigureAwait(false);
                                    if (objImprovement.SourceName == strMetamagicId && objImprovement.ImproveSource
                                        == Improvement.ImprovementSource.Echo)
                                    {
                                        blnFoundImprovement = true;
                                        objImprovement.Rating = value;
                                    }
                                }
                                // If the Bonus contains "Rating", refresh ratings of existing Improvements.
                                if (!blnFoundImprovement)
                                {
                                    try
                                    {
                                        await ImprovementManager.CreateImprovementsAsync(
                                            this, Improvement.ImprovementSource.Echo, strMetamagicId,
                                            objMetamagic.Bonus,
                                            value,
                                            await objMetamagic.GetCurrentDisplayNameShortAsync(token)
                                                              .ConfigureAwait(false),
                                            token: token).ConfigureAwait(false);
                                    }
                                    catch
                                    {
                                        await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                                        throw;
                                    }
                                    ImprovementManager.Commit(this);
                                }
                            }
                        }, token).ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
                OnPropertyChanged(nameof(SubmersionGrade));
            }
        }

        /// <summary>
        /// Whether or not the character is a member of a Group or Network.
        /// </summary>
        public bool GroupMember
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnGroupMember;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnGroupMember == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnGroupMember = value;
                    }
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Whether or not the character is a member of a Group or Network.
        /// </summary>
        public async ValueTask<bool> GetGroupMemberAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _blnGroupMember;
        }

        /// <summary>
        /// The name of the Group the Initiate has joined.
        /// </summary>
        [HubTag]
        public string GroupName
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strGroupName;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _strGroupName, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Notes for the Group the Initiate has joined.
        /// </summary>
        public string GroupNotes
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strGroupNotes;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _strGroupNotes, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Essence the character had when the first gained access to MAG/RES.
        /// </summary>
        public decimal EssenceAtSpecialStart
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _decEssenceAtSpecialStart;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_decEssenceAtSpecialStart == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _decEssenceAtSpecialStart = value;
                        RefreshEssenceLossImprovements();
                    }
                }
            }
        }

        /// <summary>
        /// Essence the character had when the first gained access to MAG/RES.
        /// </summary>
        public async ValueTask<decimal> GetEssenceAtSpecialStartAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _decEssenceAtSpecialStart;
        }

        /// <summary>
        /// Essence the character had when the first gained access to MAG/RES.
        /// </summary>
        public async ValueTask SetEssenceAtSpecialStartAsync(decimal value, CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (_decEssenceAtSpecialStart == value)
                    return;
                IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    _decEssenceAtSpecialStart = value;
                    await RefreshEssenceLossImprovementsAsync(token).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
        }

        private decimal _decCachedEssence = decimal.MinValue;
        private readonly AsyncFriendlyReaderWriterLock _objCachedEssenceLock = new AsyncFriendlyReaderWriterLock();

        public void ResetCachedEssence(CancellationToken token = default)
        {
            using (_objCachedEssenceLock.EnterWriteLock(token))
                _decCachedEssence = decimal.MinValue;
        }

        public async ValueTask ResetCachedEssenceAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker2 = await _objCachedEssenceLock.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                _decCachedEssence = decimal.MinValue;
            }
            finally
            {
                await objLocker2.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's Essence.
        /// </summary>
        /// <param name="blnAttributeSpecific">Whether fetched Essence is to be used to calculate the penalty that a specific attribute should receive from lost Essence (true) or not (false).</param>
        /// <param name="strAttribute">If <paramref name="blnAttributeSpecific"/> is true, the abbreviation of the attribute to use.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public decimal Essence(bool blnAttributeSpecific = false, string strAttribute = "", CancellationToken token = default)
        {
            using (EnterReadLock.Enter(LockObject, token))
            {
                decimal decExtraEss = 0.0m;
                IDisposable objLocker = null;
                if (blnAttributeSpecific)
                {
                    switch (strAttribute)
                    {
                        case "MAG":
                        case "MAGAdept":
                            decExtraEss = ImprovementManager.ValueOf(
                                          this, Improvement.ImprovementType.EssencePenaltyMAGOnlyT100,
                                          token: token)
                                      / 100.0m;
                            break;
                        case "RES":
                            decExtraEss = ImprovementManager.ValueOf(
                                              this, Improvement.ImprovementType.EssencePenaltyRESOnlyT100,
                                              token: token)
                                          / 100.0m;
                            break;
                        case "DEP":
                            decExtraEss = ImprovementManager.ValueOf(
                                              this, Improvement.ImprovementType.EssencePenaltyDEPOnlyT100,
                                              token: token)
                                          / 100.0m;
                            break;
                    }
                    if (decExtraEss == 0)
                        return Essence(token: token);
                }
                else
                    objLocker = EnterReadLock.Enter(_objCachedEssenceLock, token);

                try
                {
                    decimal decReturn = _decCachedEssence;
                    if (decReturn != decimal.MinValue && !blnAttributeSpecific)
                        return decReturn;
                    IDisposable objWriteLocker = null;
                    if (!blnAttributeSpecific)
                        objWriteLocker = _objCachedEssenceLock.EnterWriteLock(token);
                    try
                    {
                        // Another check in case this was already cached in between requesting the lock and obtaining the lock
                        decReturn = _decCachedEssence;
                        if (decReturn != decimal.MinValue && !blnAttributeSpecific)
                            return decReturn;
                        // If the character has a fixed Essence Improvement, permanently fix their Essence at its value.
                        if (ImprovementManager
                            .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.CyborgEssence,
                                                                token: token).Count
                            > 0)
                        {
                            if (!blnAttributeSpecific)
                                _decCachedEssence = 0.1m;
                            return 0.1m;
                        }

                        decimal decESS = ESS.MetatypeMaximum + decExtraEss;
                        decESS += ImprovementManager.ValueOf(this, Improvement.ImprovementType.EssencePenalty,
                                                             token: token);
                        decESS += ImprovementManager.ValueOf(this, Improvement.ImprovementType.EssencePenaltyT100,
                                                             token: token)
                                  / 100.0m;

                        // Run through all of the pieces of Cyberware and include their Essence cost.
                        decESS -= Cyberware.Sum(objCyberware => objCyberware.CalculatedESS);

                        //1781 Essence is not printing
                        //ESS.Base = Convert.ToInt32(decESS); -- Disabled because this messes up Character Validity, and it really shouldn't be what "Base" of an attribute is supposed to be (it's supposed to be extra levels gained)

                        if (!blnAttributeSpecific)
                            _decCachedEssence = decESS;
                        return decESS;
                    }
                    finally
                    {
                        objWriteLocker?.Dispose();
                    }
                }
                finally
                {
                    objLocker?.Dispose();
                }
            }
        }

        /// <summary>
        /// Character's Essence.
        /// </summary>
        /// <param name="blnAttributeSpecific">Whether fetched Essence is to be used to calculate the penalty that a specific attribute should receive from lost Essence (true) or not (false).</param>
        /// <param name="strAttribute">If <paramref name="blnAttributeSpecific"/> is true, the abbreviation of the attribute to use.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public async ValueTask<decimal> EssenceAsync(bool blnAttributeSpecific = false, string strAttribute = "", CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                decimal decExtraEss = 0.0m;
                IDisposable objLocker = null;
                if (blnAttributeSpecific)
                {
                    switch (strAttribute)
                    {
                        case "MAG":
                        case "MAGAdept":
                            decExtraEss = await ImprovementManager.ValueOfAsync(
                                              this, Improvement.ImprovementType.EssencePenaltyMAGOnlyT100,
                                              token: token).ConfigureAwait(false)
                                          / 100.0m;
                            break;
                        case "RES":
                            decExtraEss = await ImprovementManager.ValueOfAsync(
                                              this, Improvement.ImprovementType.EssencePenaltyRESOnlyT100,
                                              token: token).ConfigureAwait(false)
                                          / 100.0m;
                            break;
                        case "DEP":
                            decExtraEss = await ImprovementManager.ValueOfAsync(
                                              this, Improvement.ImprovementType.EssencePenaltyDEPOnlyT100,
                                              token: token).ConfigureAwait(false)
                                          / 100.0m;
                            break;
                    }
                    if (decExtraEss == 0)
                        return await EssenceAsync(token: token).ConfigureAwait(false);
                }
                else
                    objLocker = await EnterReadLock.EnterAsync(_objCachedEssenceLock, token).ConfigureAwait(false);

                try
                {
                    IAsyncDisposable objWriteLocker = null;
                    if (!blnAttributeSpecific)
                    {
                        decimal decReturn = _decCachedEssence;
                        if (decReturn != decimal.MinValue)
                            return decReturn;
                        objWriteLocker = await _objCachedEssenceLock.EnterWriteLockAsync(token).ConfigureAwait(false);
                    }

                    try
                    {
                        // Another check in case this was already cached in between requesting the lock and obtaining the lock
                        decimal decReturn = _decCachedEssence;
                        if (decReturn != decimal.MinValue && !blnAttributeSpecific)
                            return decReturn;
                        // If the character has a fixed Essence Improvement, permanently fix their Essence at its value.
                        if ((await ImprovementManager
                                   .GetCachedImprovementListForValueOfAsync(
                                       this, Improvement.ImprovementType.CyborgEssence, token: token)
                                   .ConfigureAwait(false)).Count
                            > 0)
                        {
                            if (!blnAttributeSpecific)
                                _decCachedEssence = 0.1m;
                            return 0.1m;
                        }

                        decimal decESS = await ESS.GetMetatypeMaximumAsync(token).ConfigureAwait(false) + decExtraEss;
                        decESS += await ImprovementManager
                                        .ValueOfAsync(this, Improvement.ImprovementType.EssencePenalty, token: token)
                                        .ConfigureAwait(false);
                        decESS += await ImprovementManager
                                        .ValueOfAsync(this, Improvement.ImprovementType.EssencePenaltyT100,
                                                      token: token).ConfigureAwait(false)
                                  / 100.0m;

                        // Run through all of the pieces of Cyberware and include their Essence cost.
                        decESS -= await Cyberware
                                        .SumAsync(objCyberware => objCyberware.GetCalculatedESSAsync(token),
                                                  token: token).ConfigureAwait(false);

                        //1781 Essence is not printing
                        //ESS.Base = Convert.ToInt32(decESS); -- Disabled because this messes up Character Validity, and it really shouldn't be what "Base" of an attribute is supposed to be (it's supposed to be extra levels gained)

                        if (!blnAttributeSpecific)
                            _decCachedEssence = decESS;
                        return decESS;
                    }
                    finally
                    {
                        if (objWriteLocker != null)
                            await objWriteLocker.DisposeAsync().ConfigureAwait(false);
                    }
                }
                finally
                {
                    objLocker?.Dispose();
                }
            }
        }

        private decimal _decCachedCyberwareEssence = decimal.MinValue;

        /// <summary>
        /// Essence consumed by Cyberware.
        /// </summary>
        public decimal CyberwareEssence
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    decimal decReturn = _decCachedCyberwareEssence;
                    if (decReturn != decimal.MinValue)
                        return decReturn;
                    // Run through all of the pieces of Cyberware and include their Essence cost. Cyberware and Bioware costs are calculated separately.
                    return _decCachedCyberwareEssence = Cyberware
                        .Sum(objCyberware =>
                                 objCyberware.SourceType
                                 == Improvement.ImprovementSource.Cyberware
                                 && !objCyberware.SourceID.Equals(
                                     Backend.Equipment.Cyberware.EssenceHoleGUID)
                                 && !objCyberware.SourceID.Equals(
                                     Backend.Equipment.Cyberware.EssenceAntiHoleGUID),
                             objCyberware => objCyberware.CalculatedESS);
                }
            }
        }

        private decimal _decCachedBiowareEssence = decimal.MinValue;

        /// <summary>
        /// Essence consumed by Bioware.
        /// </summary>
        public decimal BiowareEssence
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    decimal decReturn = _decCachedBiowareEssence;
                    if (decReturn != decimal.MinValue)
                        return decReturn;
                    // Run through all of the pieces of Cyberware and include their Essence cost. Cyberware and Bioware costs are calculated separately.
                    return _decCachedBiowareEssence = Cyberware
                        .Sum(objCyberware =>
                                 objCyberware.SourceType
                                 == Improvement.ImprovementSource.Bioware
                                 && !objCyberware.SourceID.Equals(
                                     Backend.Equipment.Cyberware.EssenceHoleGUID)
                                 && !objCyberware.SourceID.Equals(
                                     Backend.Equipment.Cyberware.EssenceAntiHoleGUID),
                             objCyberware => objCyberware.CalculatedESS);
                }
            }
        }

        private decimal _decCachedEssenceHole = decimal.MinValue;

        /// <summary>
        /// Essence consumed by Essence Holes.
        /// </summary>
        public decimal EssenceHole
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    decimal decReturn = _decCachedEssenceHole;
                    if (decReturn != decimal.MinValue)
                        return decReturn;
                    // Find the total Essence Cost of all Essence Hole objects.
                    return _decCachedEssenceHole = Cyberware
                        .Sum(objCyberware =>
                                 objCyberware.SourceID.Equals(
                                     Backend.Equipment.Cyberware.EssenceHoleGUID)
                                 || objCyberware.SourceID.Equals(
                                     Backend.Equipment.Cyberware.EssenceAntiHoleGUID),
                             objCyberware => objCyberware.CalculatedESS);
                }
            }
        }

        public void IncreaseEssenceHole(decimal decEssence, bool blnOverflowIntoHole = true)
        {
            IncreaseEssenceHole((decEssence * 100).StandardRound(), blnOverflowIntoHole);
        }

        public void IncreaseEssenceHole(int intCentiessence, bool blnOverflowIntoHole = true)
        {
            using (LockObject.EnterWriteLock())
            {
                Cyberware objAntiHole
                    = Cyberware.FirstOrDefault(x => x.SourceID == Backend.Equipment.Cyberware.EssenceAntiHoleGUID);
                if (objAntiHole != null)
                {
                    if (objAntiHole.Rating > intCentiessence)
                    {
                        objAntiHole.Rating -= intCentiessence;
                        return;
                    }

                    intCentiessence -= objAntiHole.Rating;
                    objAntiHole.DeleteCyberware();
                }

                if (blnOverflowIntoHole)
                {
                    Cyberware objHole
                        = Cyberware.FirstOrDefault(x => x.SourceID == Backend.Equipment.Cyberware.EssenceHoleGUID);
                    if (objHole == null)
                    {
                        XmlNode xmlEssHole = LoadData("cyberware.xml")
                            .TryGetNodeById("/chummer/cyberwares/cyberware",
                                            Backend.Equipment.Cyberware.EssenceHoleGUID);
                        objHole = new Cyberware(this);
                        List<Weapon> lstWeapons = new List<Weapon>(1);
                        List<Vehicle> lstVehicles = new List<Vehicle>(1);
                        objHole.Create(
                            xmlEssHole,
                            GetGrades(Improvement.ImprovementSource.Cyberware, true)
                                .FirstOrDefault(x => x.Name == "None"), Improvement.ImprovementSource.Cyberware,
                            intCentiessence, lstWeapons,
                            lstVehicles);

                        Cyberware.Add(objHole);

                        foreach (Weapon objWeapon in lstWeapons)
                        {
                            Weapons.Add(objWeapon);
                        }

                        foreach (Vehicle objVehicle in lstVehicles)
                        {
                            Vehicles.Add(objVehicle);
                        }
                    }
                    else
                    {
                        objHole.Rating += intCentiessence;
                    }

                    if (objHole.Rating == 0 && Cyberware.Contains(objHole))
                        Cyberware.Remove(objHole);
                }

                if (objAntiHole?.Rating == 0 && Cyberware.Contains(objAntiHole))
                    Cyberware.Remove(objAntiHole);
            }
        }

        public void DecreaseEssenceHole(decimal decEssence, bool blnOverflowIntoHole = true)
        {
            DecreaseEssenceHole((decEssence * 100).StandardRound(), blnOverflowIntoHole);
        }

        /// <summary>
        /// Decrease or create an Essence Hole, if required.
        /// </summary>
        /// <param name="intCentiessence">Hundredths of Essence to push into a new Essence Hole or Antihole.</param>
        /// <param name="blnOverflowIntoAntiHole">Should we increase or create an Essence Antihole to handle any overflow. Remember, Essence Holes are consumed first.</param>
        public void DecreaseEssenceHole(int intCentiessence, bool blnOverflowIntoAntiHole = true)
        {
            using (LockObject.EnterWriteLock())
            {
                Cyberware objHole
                    = Cyberware.FirstOrDefault(x => x.SourceID == Backend.Equipment.Cyberware.EssenceHoleGUID);

                if (objHole != null)
                {
                    if (objHole.Rating > intCentiessence)
                    {
                        objHole.Rating -= intCentiessence;
                        return;
                    }

                    intCentiessence -= objHole.Rating;
                    objHole.DeleteCyberware();
                }

                if (blnOverflowIntoAntiHole && intCentiessence != 0)
                {
                    Cyberware objAntiHole
                        = Cyberware.FirstOrDefault(x => x.SourceID == Backend.Equipment.Cyberware.EssenceAntiHoleGUID);
                    if (objAntiHole == null)
                    {
                        XmlNode xmlEssAntiHole = LoadData("cyberware.xml")
                            .TryGetNodeById("/chummer/cyberwares/cyberware",
                                            Backend.Equipment.Cyberware.EssenceAntiHoleGUID);
                        objAntiHole = new Cyberware(this);
                        List<Weapon> lstWeapons = new List<Weapon>(1);
                        List<Vehicle> lstVehicles = new List<Vehicle>(1);
                        objAntiHole.Create(xmlEssAntiHole,
                                           GetGrades(Improvement.ImprovementSource.Cyberware, true)
                                               .FirstOrDefault(x => x.Name == "None"),
                                           Improvement.ImprovementSource.Cyberware, intCentiessence, lstWeapons,
                                           lstVehicles);

                        Cyberware.Add(objAntiHole);

                        foreach (Weapon objWeapon in lstWeapons)
                        {
                            Weapons.Add(objWeapon);
                        }

                        foreach (Vehicle objVehicle in lstVehicles)
                        {
                            Vehicles.Add(objVehicle);
                        }
                    }
                    else
                    {
                        objAntiHole.Rating += intCentiessence;
                    }

                    if (objAntiHole.Rating == 0 && Cyberware.Contains(objAntiHole))
                        Cyberware.Remove(objAntiHole);
                }

                if (objHole?.Rating == 0 && Cyberware.Contains(objHole))
                    Cyberware.Remove(objHole);
            }
        }

        private decimal _decCachedPrototypeTranshumanEssenceUsed = decimal.MinValue;

        /// <summary>
        /// Essence consumed by Prototype Transhuman 'ware
        /// </summary>
        public decimal PrototypeTranshumanEssenceUsed
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    decimal decReturn = _decCachedPrototypeTranshumanEssenceUsed;
                    if (decReturn != decimal.MinValue)
                        return decReturn;
                    // Find the total Essence Cost of all Prototype Transhuman 'ware.
                    if (!IsPrototypeTranshuman)
                        return _decCachedPrototypeTranshumanEssenceUsed = 0.0m;
                    return _decCachedPrototypeTranshumanEssenceUsed = Cyberware
                        .Sum(objCyberware => objCyberware.PrototypeTranshuman,
                             objCyberware => objCyberware.CalculatedESSPrototypeInvariant);
                }
            }
        }

        public string DisplayEssence
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return EssenceDecimal.ToString(Settings.EssenceFormat, GlobalSettings.CultureInfo);
            }
        }

        /// <summary>
        /// This is only here for Reflection
        /// </summary>
        [HubTag("Essence")]
        public decimal EssenceDecimal => Essence();

        public string DisplayCyberwareEssence
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CyberwareEssence.ToString(Settings.EssenceFormat, GlobalSettings.CultureInfo);
            }
        }

        public string DisplayBiowareEssence
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return BiowareEssence.ToString(Settings.EssenceFormat, GlobalSettings.CultureInfo);
            }
        }

        public string DisplayEssenceHole
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return EssenceHole.ToString(Settings.EssenceFormat, GlobalSettings.CultureInfo);
            }
        }

        public string DisplayPrototypeTranshumanEssenceUsed
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                    return PrototypeTranshumanEssenceUsed.ToString(Settings.EssenceFormat, GlobalSettings.CultureInfo)
                           + strSpace + '/' + strSpace +
                           PrototypeTranshuman.ToString(Settings.EssenceFormat, GlobalSettings.CultureInfo);
            }
        }

        #region Initiative

        #region Physical

        /// <summary>
        /// Physical Initiative.
        /// </summary>
        public string Initiative
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return GetInitiative(GlobalSettings.CultureInfo, GlobalSettings.Language);
            }
        }

        public string GetInitiative(CultureInfo objCulture, string strLanguage)
        {
            using (EnterReadLock.Enter(LockObject))
                return string.Format(objCulture, LanguageManager.GetString("String_Initiative", strLanguage),
                                     InitiativeValue.ToString(objCulture),
                                     InitiativeDice.ToString(objCulture));
        }

        public string InitiativeToolTip
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    int intINTAttributeModifiers = INT.AttributeModifiers;
                    int intREAAttributeModifiers = REA.AttributeModifiers;
                    string strSpace = LanguageManager.GetString("String_Space");

                    string strInit = REA.DisplayAbbrev + strSpace + '(' + REA.Value.ToString(GlobalSettings.CultureInfo)
                                     + ')'
                                     + strSpace + '+' + strSpace + INT.DisplayAbbrev + strSpace + '('
                                     + INT.Value.ToString(GlobalSettings.CultureInfo) + ')';
                    if (ImprovementManager.ValueOf(this, Improvement.ImprovementType.Initiative) != 0
                        || intINTAttributeModifiers != 0 || intREAAttributeModifiers != 0 || WoundModifier != 0)
                    {
                        strInit += strSpace + '+' + strSpace + LanguageManager.GetString("Tip_Modifiers") + strSpace
                                   + '('
                                   + (ImprovementManager.ValueOf(this, Improvement.ImprovementType.Initiative)
                                      + intINTAttributeModifiers + intREAAttributeModifiers + WoundModifier)
                                   .ToString(GlobalSettings.CultureInfo) + ')';
                    }

                    return string.Format(GlobalSettings.CultureInfo, LanguageManager.GetString("String_Initiative"),
                                         strInit, InitiativeDice.ToString(GlobalSettings.CultureInfo));
                }
            }
        }

        /// <summary>
        /// Initiative Dice.
        /// </summary>
        [HubTag]
        public int InitiativeDice
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    int intExtraIP = _intInitiativeDice
                                     + ImprovementManager.ValueOf(this, Improvement.ImprovementType.InitiativeDice)
                                                         .StandardRound()
                                     + ImprovementManager.ValueOf(this, Improvement.ImprovementType.InitiativeDiceAdd)
                                                         .StandardRound();

                    return Math.Min(intExtraIP, Settings.MaxInitiativeDice);
                }
            }
        }

        [HubTag]
        public int InitiativeValue
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if ((INT == null) || (REA == null))
                    {
                        Utils.BreakIfDebug();
                        return 0;
                    }

                    int intINI = INT.TotalValue + REA.TotalValue + WoundModifier;
                    intINI += ImprovementManager.ValueOf(this, Improvement.ImprovementType.Initiative).StandardRound();
                    if (intINI < 0)
                        intINI = 0;
                    return intINI;
                }
            }
        }

        #endregion Physical

        #region Astral

        /// <summary>
        /// Astral Initiative.
        /// </summary>
        public string AstralInitiative
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return GetAstralInitiative(GlobalSettings.CultureInfo, GlobalSettings.Language);
            }
        }

        public string GetAstralInitiative(CultureInfo objCulture, string strLanguageToPrint)
        {
            using (EnterReadLock.Enter(LockObject))
                return string.Format(objCulture, LanguageManager.GetString("String_Initiative", strLanguageToPrint),
                                     AstralInitiativeValue.ToString(objCulture),
                                     AstralInitiativeDice.ToString(objCulture));
        }

        public string AstralInitiativeToolTip
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (!MAGEnabled)
                        return string.Empty;
                    int intINTAttributeModifiers = INT.AttributeModifiers;
                    string strSpace = LanguageManager.GetString("String_Space");
                    string strInit = INT.DisplayAbbrev + strSpace + '(' + INT.Value.ToString(GlobalSettings.CultureInfo)
                                     + ')' + strSpace + '' + strSpace + 2.ToString(GlobalSettings.CultureInfo);
                    if (intINTAttributeModifiers != 0 || WoundModifier != 0)
                        strInit += LanguageManager.GetString("Tip_Modifiers") + strSpace + '('
                                   + (intINTAttributeModifiers + WoundModifier).ToString(GlobalSettings.CultureInfo)
                                   + ')';
                    return string.Format(GlobalSettings.CultureInfo, LanguageManager.GetString("String_Initiative"),
                                         strInit, AstralInitiativeDice.ToString(GlobalSettings.CultureInfo));
                }
            }
        }

        /// <summary>
        /// Astral Initiative Value.
        /// </summary>
        public int AstralInitiativeValue
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return (INT.TotalValue * 2) + WoundModifier;
            }
        }

        /// <summary>
        /// Astral Initiative Dice.
        /// </summary>
        public int AstralInitiativeDice
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    int intReturn = Settings.MinAstralInitiativeDice;
                    return Math.Min(intReturn, Settings.MaxAstralInitiativeDice);
                }
            }
        }

        #endregion Astral

        #region Matrix

        #region AR

        /// <summary>
        /// Formatted AR Matrix Initiative.
        /// </summary>
        public string MatrixInitiative
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return GetMatrixInitiative(GlobalSettings.CultureInfo, GlobalSettings.Language);
            }
        }

        public string GetMatrixInitiative(CultureInfo objCulture, string strLanguageToPrint)
        {
            using (EnterReadLock.Enter(LockObject))
                return string.Format(objCulture, LanguageManager.GetString("String_Initiative", strLanguageToPrint),
                                     MatrixInitiativeValue, MatrixInitiativeDice);
        }

        public string MatrixInitiativeToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                {
                    int intINTAttributeModifiers = INT.AttributeModifiers;

                    string strInit;
                    if (IsAI)
                    {
                        strInit = INT.DisplayAbbrev + strSpace + '(' + INT.Value.ToString(GlobalSettings.CultureInfo)
                                  + ')';

                        if (HomeNode != null)
                        {
                            int intHomeNodeDP = HomeNode.GetTotalMatrixAttribute("Data Processing");
                            if (HomeNode is Vehicle objHomeNodeVehicle)
                            {
                                int intHomeNodePilot = objHomeNodeVehicle.Pilot;
                                if (intHomeNodePilot > intHomeNodeDP)
                                    intHomeNodeDP = intHomeNodePilot;
                            }

                            strInit += strSpace + '+' + strSpace + LanguageManager.GetString("String_DataProcessing") +
                                       strSpace + '(' + intHomeNodeDP.ToString(GlobalSettings.CultureInfo) + ')';
                        }

                        if (intINTAttributeModifiers != 0 || WoundModifier != 0)
                        {
                            strInit += strSpace + '+' + strSpace + LanguageManager.GetString("Tip_Modifiers") + strSpace
                                       +
                                       '(' +
                                       (intINTAttributeModifiers + WoundModifier).ToString(GlobalSettings.CultureInfo)
                                       + ')';
                        }
                    }
                    else
                    {
                        int intREAAttributeModifiers = REA.AttributeModifiers;

                        strInit = REA.DisplayAbbrev + strSpace + '(' + REA.Value.ToString(GlobalSettings.CultureInfo)
                                  + ')' +
                                  strSpace + '+' + strSpace + INT.DisplayAbbrev + strSpace + '(' +
                                  INT.Value.ToString(GlobalSettings.CultureInfo) + ')';
                        if (ImprovementManager.ValueOf(this, Improvement.ImprovementType.Initiative) != 0
                            || intINTAttributeModifiers != 0 || intREAAttributeModifiers != 0 || WoundModifier != 0)
                        {
                            strInit += strSpace + '+' + strSpace + LanguageManager.GetString("Tip_Modifiers") + strSpace
                                       +
                                       '(' + (ImprovementManager.ValueOf(this, Improvement.ImprovementType.Initiative) +
                                              intINTAttributeModifiers + intREAAttributeModifiers + WoundModifier)
                                       .ToString(GlobalSettings.CultureInfo) + ')';
                        }
                    }

                    return string.Format(GlobalSettings.CultureInfo, LanguageManager.GetString("String_Initiative"),
                                         strInit, MatrixInitiativeDice);
                }
            }
        }

        /// <summary>
        /// AR Matrix Initiative Value.
        /// </summary>
        public int MatrixInitiativeValue
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        int intINI = (INT.TotalValue) + WoundModifier;
                        if (HomeNode != null)
                        {
                            int intHomeNodeDP = HomeNode.GetTotalMatrixAttribute("Data Processing");
                            if (HomeNode is Vehicle objHomeNodeVehicle)
                            {
                                int intHomeNodePilot = objHomeNodeVehicle.Pilot;
                                if (intHomeNodePilot > intHomeNodeDP)
                                    intHomeNodeDP = intHomeNodePilot;
                            }

                            intINI += intHomeNodeDP;
                        }

                        return intINI;
                    }

                    return InitiativeValue;
                }
            }
        }

        /// <summary>
        /// AR Matrix Initiative Dice.
        /// </summary>
        public int MatrixInitiativeDice
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    int intReturn;
                    // A.I.s always have 4 Matrix Initiative Dice.
                    if (IsAI)
                        intReturn = Settings.MinHotSimInitiativeDice + ImprovementManager
                                                                       .ValueOf(
                                                                           this,
                                                                           Improvement.ImprovementType
                                                                               .MatrixInitiativeDice).StandardRound();
                    else
                        intReturn = InitiativeDice;

                    // Add in any additional Matrix Initiative Pass bonuses.
                    intReturn += ImprovementManager.ValueOf(this, Improvement.ImprovementType.MatrixInitiativeDiceAdd)
                                                   .StandardRound();

                    return Math.Min(intReturn, Settings.MaxInitiativeDice);
                }
            }
        }

        #endregion AR

        #region Cold Sim

        /// <summary>
        /// Matrix Initiative via VR with Cold Sim.
        /// </summary>
        public string MatrixInitiativeCold
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return GetMatrixInitiativeCold(GlobalSettings.CultureInfo, GlobalSettings.Language);
            }
        }

        public string GetMatrixInitiativeCold(CultureInfo objCulture, string strLanguageToPrint)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (IsAI)
                {
                    return GetMatrixInitiative(objCulture, strLanguageToPrint);
                }

                return string.Format(
                    objCulture,
                    LanguageManager.GetString(ActiveCommlink == null ? "String_MatrixInitiative" : "String_Initiative",
                                              strLanguageToPrint),
                    MatrixInitiativeColdValue, MatrixInitiativeColdDice);
            }
        }

        public string MatrixInitiativeColdToolTip
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        return MatrixInitiativeToolTip;
                    }

                    int intINTAttributeModifiers = INT.AttributeModifiers;

                    string strSpace = LanguageManager.GetString("String_Space");

                    string strInit = INT.DisplayAbbrev + strSpace + '(' + INT.Value.ToString(GlobalSettings.CultureInfo)
                                     + ')';
                    if (ActiveCommlink != null)
                    {
                        strInit += strSpace + '+' + strSpace + LanguageManager.GetString("String_DataProcessing") +
                                   strSpace + '(' + ActiveCommlink.GetTotalMatrixAttribute("Data Processing")
                                                                  .ToString(GlobalSettings.CultureInfo) + ')';
                    }

                    if (ImprovementManager.ValueOf(this, Improvement.ImprovementType.MatrixInitiative) != 0
                        || intINTAttributeModifiers != 0 || WoundModifier != 0)
                    {
                        strInit += strSpace + '+' + strSpace + LanguageManager.GetString("Tip_Modifiers") + strSpace
                                   + '(' +
                                   (ImprovementManager.ValueOf(this, Improvement.ImprovementType.MatrixInitiative) +
                                    intINTAttributeModifiers + WoundModifier).ToString(GlobalSettings.CultureInfo)
                                   + ')';
                    }

                    return string.Format(GlobalSettings.CultureInfo,
                                         LanguageManager.GetString(
                                             ActiveCommlink == null
                                                 ? "String_MatrixInitiativeLong"
                                                 : "String_Initiative"),
                                         strInit, MatrixInitiativeColdDice);
                }
            }
        }

        /// <summary>
        /// Cold Sim Matrix Initiative Value.
        /// </summary>
        public int MatrixInitiativeColdValue
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        return MatrixInitiativeValue;
                    }

                    int intCommlinkDP = ActiveCommlink?.GetTotalMatrixAttribute("Data Processing") ?? 0;
                    return INT.TotalValue + intCommlinkDP + WoundModifier +
                           ImprovementManager.ValueOf(this, Improvement.ImprovementType.MatrixInitiative)
                                             .StandardRound();
                }
            }
        }

        /// <summary>
        /// Cold Sim Matrix Initiative Dice.
        /// </summary>
        public int MatrixInitiativeColdDice
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        return MatrixInitiativeDice;
                    }

                    return Math.Min(
                        Settings.MinColdSimInitiativeDice + ImprovementManager
                                                            .ValueOf(
                                                                this, Improvement.ImprovementType.MatrixInitiativeDice)
                                                            .StandardRound(),
                        Settings.MaxColdSimInitiativeDice);
                }
            }
        }

        #endregion Cold Sim

        #region Hot Sim

        /// <summary>
        /// Matrix Initiative via VR with Hot Sim.
        /// </summary>
        public string MatrixInitiativeHot
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return GetMatrixInitiativeHot(GlobalSettings.CultureInfo, GlobalSettings.Language);
            }
        }

        public string GetMatrixInitiativeHot(CultureInfo objCulture, string strLanguageToPrint)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (IsAI)
                {
                    return GetMatrixInitiative(objCulture, strLanguageToPrint);
                }

                return string.Format(
                    objCulture,
                    LanguageManager.GetString(ActiveCommlink == null ? "String_MatrixInitiative" : "String_Initiative",
                                              strLanguageToPrint),
                    MatrixInitiativeHotValue, MatrixInitiativeHotDice);
            }
        }

        public string MatrixInitiativeHotToolTip
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        return MatrixInitiativeToolTip;
                    }

                    int intINTAttributeModifiers = INT.AttributeModifiers;

                    string strSpace = LanguageManager.GetString("String_Space");

                    string strInit = INT.DisplayAbbrev + strSpace + '(' + INT.Value.ToString(GlobalSettings.CultureInfo)
                                     + ')';
                    if (ActiveCommlink != null)
                    {
                        strInit += strSpace + '+' + strSpace + LanguageManager.GetString("String_DataProcessing") +
                                   strSpace + '(' + ActiveCommlink.GetTotalMatrixAttribute("Data Processing")
                                                                  .ToString(GlobalSettings.CultureInfo) + ')';
                    }

                    if (ImprovementManager.ValueOf(this, Improvement.ImprovementType.MatrixInitiative) != 0
                        || intINTAttributeModifiers != 0 || WoundModifier != 0)
                    {
                        strInit += strSpace + '+' + strSpace + LanguageManager.GetString("Tip_Modifiers") + strSpace
                                   + '(' +
                                   (ImprovementManager.ValueOf(this, Improvement.ImprovementType.MatrixInitiative) +
                                    intINTAttributeModifiers + WoundModifier).ToString(GlobalSettings.CultureInfo)
                                   + ')';
                    }

                    return string.Format(GlobalSettings.CultureInfo,
                                         LanguageManager.GetString(
                                             ActiveCommlink == null
                                                 ? "String_MatrixInitiativeLong"
                                                 : "String_Initiative"),
                                         strInit, MatrixInitiativeHotDice);
                }
            }
        }

        /// <summary>
        /// Hot Sim Matrix Initiative Value.
        /// </summary>
        public int MatrixInitiativeHotValue
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        return MatrixInitiativeValue;
                    }

                    int intCommlinkDP = ActiveCommlink?.GetTotalMatrixAttribute("Data Processing") ?? 0;
                    return INT.TotalValue + intCommlinkDP + WoundModifier +
                           ImprovementManager.ValueOf(this, Improvement.ImprovementType.MatrixInitiative)
                                             .StandardRound();
                }
            }
        }

        /// <summary>
        /// Hot Sim Matrix Initiative Dice.
        /// </summary>
        public int MatrixInitiativeHotDice
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        return MatrixInitiativeDice;
                    }

                    return Math.Min(
                        Settings.MinHotSimInitiativeDice + ImprovementManager
                                                           .ValueOf(
                                                               this, Improvement.ImprovementType.MatrixInitiativeDice)
                                                           .StandardRound(),
                        Settings.MaxHotSimInitiativeDice);
                }
            }
        }

        #endregion Hot Sim

        #region XPath Processing

        /// <summary>
        /// Replaces substring in the form of {Skill} with the total dicepool of the skill.
        /// </summary>
        /// <param name="strInput">Stringbuilder object that contains the input.</param>
        /// <param name="dicValueOverrides">Alternative dictionary to use for value lookup instead of SkillsSection.GetActiveSkill.</param>
        public string ProcessMatrixAttributesInXPath(string strInput, IReadOnlyDictionary<string, int> dicValueOverrides = null)
        {
            if (string.IsNullOrEmpty(strInput))
                return strInput;
            string strReturn = strInput;
            using (EnterReadLock.Enter(LockObject))
            {
                foreach (string strAttributeName in MatrixAttributes.MatrixAttributeStrings)
                {
                    strReturn = strReturn
                        .CheapReplace('{' + strAttributeName + '}', () =>
                                          dicValueOverrides?.ContainsKey(strAttributeName) == true
                                              ? dicValueOverrides[strAttributeName].ToString()
                                              : ActiveCommlink?.GetTotalMatrixAttribute(strAttributeName).ToString());
                }
            }

            return strReturn;
        }

        /// <summary>
        /// Replaces stringbuilder content in the form of {MatrixAttribute} with the total pool of the Matrix Attribute of the Active Commlink, if any.
        /// </summary>
        /// <param name="sbdInput">Stringbuilder object that contains the input.</param>
        /// <param name="dicValueOverrides">Alternative dictionary to use for value lookup instead of SkillsSection.GetActiveSkill.</param>
        public void ProcessMatrixAttributesInXPath(StringBuilder sbdInput, IReadOnlyDictionary<string, int> dicValueOverrides = null)
        {
            if (sbdInput == null || sbdInput.Length <= 0)
                return;
            using (EnterReadLock.Enter(LockObject))
            {
                foreach (string strAttributeName in MatrixAttributes.MatrixAttributeStrings)
                {
                    sbdInput.CheapReplace('{' + strAttributeName + '}', () =>
                                              dicValueOverrides?.ContainsKey(strAttributeName) == true
                                                  ? dicValueOverrides[strAttributeName].ToString()
                                                  : ActiveCommlink?.GetTotalMatrixAttribute(strAttributeName)
                                                                  .ToString());
                }
            }
        }

        #endregion XPath Processing

        #endregion Matrix

        #endregion Initiative

        /// <summary>
        /// Character's total Spell Resistance from qualities and metatype properties.
        /// </summary>
        public int SpellResistance => ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance).StandardRound();

        #endregion Attributes

        #region Special CharacterAttribute Tests

        /// <summary>
        /// Composure (WIL + CHA).
        /// </summary>
        public int Composure
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return WIL.TotalValue + CHA.TotalValue +
                           ImprovementManager.ValueOf(this, Improvement.ImprovementType.Composure).StandardRound()
                           + WoundModifier
                           + SustainingPenalty;
            }
        }

        public string ComposureToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(CHA.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(CHA.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(LanguageManager.GetString("Tip_Skill_Wounds"))
                                  .Append(strSpace).Append('(')
                                  .Append(WoundModifier.ToString(GlobalSettings.CultureInfo))
                                  .Append(')').Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Tip_Skill_Sustain")).Append(strSpace).Append('(')
                                  .Append(SustainingPenalty.ToString(GlobalSettings.CultureInfo)).Append(')');
                        foreach (Improvement objLoopImprovement in
                                 ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.Composure))
                        {
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                      .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        /// <summary>
        /// Judge Intentions (INT + CHA).
        /// </summary>
        public int JudgeIntentions
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return INT.TotalValue + CHA.TotalValue +
                           (ImprovementManager.ValueOf(this, Improvement.ImprovementType.JudgeIntentions)
                            + ImprovementManager.ValueOf(this, Improvement.ImprovementType.JudgeIntentionsOffense))
                           .StandardRound()
                           + SustainingPenalty
                           + WoundModifier;
            }
        }

        public string JudgeIntentionsToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(CHA.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(CHA.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(INT.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(INT.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(LanguageManager.GetString("Tip_Skill_Wounds"))
                                  .Append(strSpace).Append('(')
                                  .Append(WoundModifier.ToString(GlobalSettings.CultureInfo))
                                  .Append(')').Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Tip_Skill_Sustain")).Append(strSpace).Append('(')
                                  .Append(SustainingPenalty.ToString(GlobalSettings.CultureInfo)).Append(')');
                        foreach (Improvement objLoopImprovement in
                                 ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.JudgeIntentions))
                        {
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                      .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');
                        }

                        foreach (Improvement objLoopImprovement in
                                 ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.JudgeIntentionsOffense))
                        {
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                      .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        /// <summary>
        /// Judge Intentions Resist (CHA + WIL).
        /// </summary>
        public int JudgeIntentionsResist
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CHA.TotalValue + WIL.TotalValue +
                           (ImprovementManager.ValueOf(this, Improvement.ImprovementType.JudgeIntentions)
                            + ImprovementManager.ValueOf(this, Improvement.ImprovementType.JudgeIntentionsDefense))
                           .StandardRound();
            }
        }

        public string JudgeIntentionsResistToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(CHA.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(CHA.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');
                        foreach (Improvement objLoopImprovement in
                                 ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.JudgeIntentions))
                        {
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                      .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');
                        }

                        foreach (Improvement objLoopImprovement in
                                 ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.JudgeIntentionsDefense))
                        {
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                      .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        /// <summary>
        /// Lifting and Carrying (STR + BOD).
        /// </summary>
        public int LiftAndCarry
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return STR.TotalValue + BOD.TotalValue +
                           ImprovementManager.ValueOf(this, Improvement.ImprovementType.LiftAndCarry).StandardRound()
                           + WoundModifier
                           + SustainingPenalty;
            }
        }

        public string LiftAndCarryToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(BOD.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(BOD.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(STR.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(STR.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(LanguageManager.GetString("Tip_Skill_Wounds"))
                                  .Append(strSpace).Append('(')
                                  .Append(WoundModifier.ToString(GlobalSettings.CultureInfo))
                                  .Append(')').Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Tip_Skill_Sustain")).Append(strSpace).Append('(')
                                  .Append(SustainingPenalty.ToString(GlobalSettings.CultureInfo)).Append(')');
                        foreach (Improvement objLoopImprovement in
                                 ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.LiftAndCarry))
                        {
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                      .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public string LiftAndCarryLimits
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return string.Format(GlobalSettings.CultureInfo,
                                         LanguageManager.GetString("Label_OtherLiftAndCarryLimitsFormat"),
                                         LiftLimit.ToString(
                                             Settings.WeightFormat, GlobalSettings.CultureInfo),
                                         CarryLimit.ToString(
                                             Settings.WeightFormat, GlobalSettings.CultureInfo));
            }
        }

        /// <summary>
        /// Memory (LOG + WIL).
        /// </summary>
        public int Memory
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return LOG.TotalValue + WIL.TotalValue +
                           ImprovementManager.ValueOf(this, Improvement.ImprovementType.Memory).StandardRound()
                           + WoundModifier
                           + SustainingPenalty;
            }
        }

        public string MemoryToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(LOG.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(LOG.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(LanguageManager.GetString("Tip_Skill_Wounds"))
                                  .Append(strSpace).Append('(')
                                  .Append(WoundModifier.ToString(GlobalSettings.CultureInfo))
                                  .Append(')').Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Tip_Skill_Sustain")).Append(strSpace).Append('(')
                                  .Append(SustainingPenalty.ToString(GlobalSettings.CultureInfo)).Append(')');
                        foreach (Improvement objLoopImprovement in
                                 ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.Memory))
                        {
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                      .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        /// <summary>
        /// Resist test to Fatigue damage (BOD + WIL).
        /// </summary>
        public int FatigueResist
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return BOD.TotalValue + WIL.TotalValue +
                           ImprovementManager.ValueOf(this, Improvement.ImprovementType.FatigueResist).StandardRound();
            }
        }

        /// <summary>
        /// Resist test to Radiation damage (BOD + WIL).
        /// </summary>
        public int RadiationResist
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return BOD.TotalValue + WIL.TotalValue +
                           ImprovementManager.ValueOf(this, Improvement.ImprovementType.RadiationResist)
                                             .StandardRound();
            }
        }

        /// <summary>
        /// Resist test to Sonic Attacks damage (WIL).
        /// </summary>
        public int SonicResist
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return WIL.TotalValue + ImprovementManager.ValueOf(this, Improvement.ImprovementType.SonicResist)
                                                              .StandardRound();
            }
        }

        /// <summary>
        /// Resist test to Contact-vector Toxins (BOD + WIL).
        /// </summary>
        public string ToxinContactResist(string strLanguage, CultureInfo objCulture)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (IsAI || ImprovementManager
                            .GetCachedImprovementListForValueOf(
                                this, Improvement.ImprovementType.ToxinContactImmune).Count > 0)
                    return LanguageManager.GetString("String_Immune", strLanguage);
                return (BOD.TotalValue + WIL.TotalValue +
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.ToxinContactResist)
                                          .StandardRound())
                    .ToString(objCulture);
            }
        }

        /// <summary>
        /// Resist test to Ingestion-vector Toxins (BOD + WIL).
        /// </summary>
        public string ToxinIngestionResist(string strLanguage, CultureInfo objCulture)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (IsAI || ImprovementManager
                            .GetCachedImprovementListForValueOf(
                                this, Improvement.ImprovementType.ToxinIngestionImmune).Count > 0)
                    return LanguageManager.GetString("String_Immune", strLanguage);
                return (BOD.TotalValue + WIL.TotalValue +
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.ToxinIngestionResist)
                                          .StandardRound())
                    .ToString(objCulture);
            }
        }

        /// <summary>
        /// Resist test to Inhalation-vector Toxins (BOD + WIL).
        /// </summary>
        public string ToxinInhalationResist(string strLanguage, CultureInfo objCulture)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (IsAI || ImprovementManager
                            .GetCachedImprovementListForValueOf(
                                this, Improvement.ImprovementType.ToxinInhalationImmune).Count > 0)
                    return LanguageManager.GetString("String_Immune", strLanguage);
                return (BOD.TotalValue + WIL.TotalValue +
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.ToxinInhalationResist)
                                          .StandardRound())
                    .ToString(objCulture);
            }
        }

        /// <summary>
        /// Resist test to Injection-vector Toxins (BOD + WIL).
        /// </summary>
        public string ToxinInjectionResist(string strLanguage, CultureInfo objCulture)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (IsAI || ImprovementManager
                            .GetCachedImprovementListForValueOf(
                                this, Improvement.ImprovementType.ToxinInjectionImmune).Count > 0)
                    return LanguageManager.GetString("String_Immune", strLanguage);
                return (BOD.TotalValue + WIL.TotalValue +
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.ToxinInjectionResist)
                                          .StandardRound())
                    .ToString(objCulture);
            }
        }

        /// <summary>
        /// Resist test to Contact-vector Pathogens (BOD + WIL).
        /// </summary>
        public string PathogenContactResist(string strLanguage, CultureInfo objCulture)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (IsAI || ImprovementManager
                            .GetCachedImprovementListForValueOf(
                                this, Improvement.ImprovementType.PathogenContactImmune).Count > 0)
                    return LanguageManager.GetString("String_Immune", strLanguage);
                return (BOD.TotalValue + WIL.TotalValue +
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.PathogenContactResist)
                                          .StandardRound())
                    .ToString(objCulture);
            }
        }

        /// <summary>
        /// Resist test to Ingestion-vector Pathogens (BOD + WIL).
        /// </summary>
        public string PathogenIngestionResist(string strLanguage, CultureInfo objCulture)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (IsAI || ImprovementManager
                            .GetCachedImprovementListForValueOf(
                                this, Improvement.ImprovementType.PathogenIngestionImmune).Count > 0)
                    return LanguageManager.GetString("String_Immune", strLanguage);
                return (BOD.TotalValue + WIL.TotalValue +
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.PathogenIngestionResist)
                                          .StandardRound())
                    .ToString(objCulture);
            }
        }

        /// <summary>
        /// Resist test to Inhalation-vector Pathogens (BOD + WIL).
        /// </summary>
        public string PathogenInhalationResist(string strLanguage, CultureInfo objCulture)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (IsAI || ImprovementManager
                            .GetCachedImprovementListForValueOf(
                                this, Improvement.ImprovementType.PathogenInhalationImmune).Count > 0)
                    return LanguageManager.GetString("String_Immune", strLanguage);
                return (BOD.TotalValue + WIL.TotalValue +
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.PathogenInhalationResist)
                                          .StandardRound())
                    .ToString(objCulture);
            }
        }

        /// <summary>
        /// Resist test to Injection-vector Pathogens (BOD + WIL).
        /// </summary>
        public string PathogenInjectionResist(string strLanguage, CultureInfo objCulture)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (IsAI || ImprovementManager
                            .GetCachedImprovementListForValueOf(
                                this, Improvement.ImprovementType.PathogenInjectionImmune).Count > 0)
                    return LanguageManager.GetString("String_Immune", strLanguage);
                return (BOD.TotalValue + WIL.TotalValue +
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.PathogenInjectionResist)
                                          .StandardRound())
                    .ToString(objCulture);
            }
        }

        /// <summary>
        /// Resist test to Physiological Addiction (BOD + WIL) if you are not addicted yet.
        /// </summary>
        public int PhysiologicalAddictionResistFirstTime
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return BOD.TotalValue + WIL.TotalValue + ImprovementManager.ValueOf(this,
                                                                                   Improvement.ImprovementType
                                                                                       .PhysiologicalAddictionFirstTime)
                                                                               .StandardRound();
            }
        }

        /// <summary>
        /// Resist test to Psychological Addiction (LOG + WIL) if you are not addicted yet.
        /// </summary>
        public int PsychologicalAddictionResistFirstTime
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return LOG.TotalValue + WIL.TotalValue + ImprovementManager.ValueOf(this,
                                                                                   Improvement.ImprovementType
                                                                                       .PsychologicalAddictionFirstTime)
                                                                               .StandardRound();
            }
        }

        /// <summary>
        /// Resist test to Physiological Addiction (BOD + WIL) if you are already addicted.
        /// </summary>
        public int PhysiologicalAddictionResistAlreadyAddicted
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return BOD.TotalValue + WIL.TotalValue + ImprovementManager.ValueOf(this,
                                                                                   Improvement.ImprovementType
                                                                                       .PhysiologicalAddictionAlreadyAddicted)
                                                                               .StandardRound();
            }
        }

        /// <summary>
        /// Resist test to Psychological Addiction (LOG + WIL) if you are already addicted.
        /// </summary>
        public int PsychologicalAddictionResistAlreadyAddicted
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return LOG.TotalValue + WIL.TotalValue + ImprovementManager.ValueOf(this,
                                                                                   Improvement.ImprovementType
                                                                                       .PsychologicalAddictionAlreadyAddicted)
                                                                               .StandardRound();
            }
        }

        /// <summary>
        /// Dicepool for natural recovery from Stun CM box damage (BOD + WIL).
        /// </summary>
        public int StunCMNaturalRecovery
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    // Matrix damage for A.I.s is not naturally repaired
                    if (IsAI)
                        return 0;
                    int intReturn = BOD.TotalValue + WIL.TotalValue +
                                    ImprovementManager.ValueOf(this, Improvement.ImprovementType.StunCMRecovery)
                                                      .StandardRound();
                    if (ImprovementManager
                        .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.AddESStoStunCMRecovery)
                        .Count
                        > 0)
                        intReturn += Essence().ToInt32();
                    return intReturn;
                }
            }
        }

        /// <summary>
        /// Dicepool for natural recovery from Physical CM box damage (2 x BOD).
        /// </summary>
        public int PhysicalCMNaturalRecovery
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        if (HomeNode is Vehicle)
                            return 0;

                        // A.I.s can restore Core damage via Software + Depth [Data Processing] (1 day) Extended Test
                        int intAIReturn =
                            (SkillsSection.GetActiveSkill("Software")?.PoolOtherAttribute("DEP") ??
                             DEP.TotalValue - 1) +
                            ImprovementManager.ValueOf(this, Improvement.ImprovementType.PhysicalCMRecovery)
                                              .StandardRound();
                        if (ImprovementManager
                            .GetCachedImprovementListForValueOf(
                                this, Improvement.ImprovementType.AddESStoPhysicalCMRecovery).Count
                            > 0)
                            intAIReturn += Essence().ToInt32();
                        return intAIReturn;
                    }

                    int intReturn = 2 * BOD.TotalValue +
                                    ImprovementManager.ValueOf(this, Improvement.ImprovementType.PhysicalCMRecovery)
                                                      .StandardRound();
                    if (ImprovementManager
                        .GetCachedImprovementListForValueOf(
                            this, Improvement.ImprovementType.AddESStoPhysicalCMRecovery).Count
                        > 0)
                        intReturn += Essence().ToInt32();
                    return intReturn;
                }
            }
        }

        #endregion Special CharacterAttribute Tests

        #region Reputation

        /// <summary>
        /// Amount of Street Cred the character has earned through standard means.
        /// </summary>
        public int CalculatedStreetCred
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    // Street Cred = Career Karma / 10, rounded down
                    int intReturn = CareerKarma /
                                    (10 + ImprovementManager.ValueOf(this,
                                                                     Improvement.ImprovementType.StreetCredMultiplier)
                                                            .StandardRound());

                    // Deduct burnt Street Cred.
                    intReturn -= BurntStreetCred;

                    return intReturn;
                }
            }
        }

        /// <summary>
        /// Character's total amount of Street Cred (earned + GM awarded).
        /// </summary>
        public int TotalStreetCred
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return Math.Max(
                        CalculatedStreetCred + StreetCred +
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.StreetCred).StandardRound(), 0);
            }
        }

        public string CareerDisplayStreetCred
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    int intTotalStreetCred = TotalStreetCred;
                    int intCalculatedStreetCred = intTotalStreetCred - StreetCred;
                    return (intCalculatedStreetCred >= 0
                               ? " + " + intCalculatedStreetCred.ToString(GlobalSettings.CultureInfo)
                               : " - " + (-intCalculatedStreetCred).ToString(GlobalSettings.CultureInfo)) + " = " +
                           intTotalStreetCred.ToString(GlobalSettings.CultureInfo);
                }
            }
        }

        public bool CanBurnStreetCred
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return Created && TotalStreetCred >= 2;
            }
        }

        /// <summary>
        /// Street Cred Tooltip.
        /// </summary>
        public string StreetCredTooltip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdReturn))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdReturn.Append(StreetCred.ToString(GlobalSettings.CultureInfo));

                        foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.StreetCred))
                        {
                            sbdReturn.Append(strSpace).Append('+').Append(strSpace)
                                     .Append(GetObjectName(objImprovement))
                                     .Append(strSpace).Append('(')
                                     .Append(objImprovement.Value.ToString(GlobalSettings.CultureInfo)).Append(')');
                        }

                        sbdReturn.Append(strSpace).Append('+').Append(strSpace).Append('[')
                                 .Append(LanguageManager.GetString("String_CareerKarma")).Append(strSpace).Append('')
                                 .Append(strSpace)
                                 .Append((10 + ImprovementManager.ValueOf(
                                             this, Improvement.ImprovementType.StreetCredMultiplier))
                                         .ToString(GlobalSettings.CultureInfo)).Append(']').Append(strSpace).Append('(')
                                 .Append(
                                     (CareerKarma
                                      / (10 + ImprovementManager.ValueOf(
                                          this, Improvement.ImprovementType.StreetCredMultiplier)))
                                     .ToString(GlobalSettings.CultureInfo)).Append(')');

                        if (BurntStreetCred != 0)
                            sbdReturn.Append(strSpace).Append('-').Append(strSpace)
                                     .Append(LanguageManager.GetString("String_BurntStreetCred")).Append(strSpace)
                                     .Append('(')
                                     .Append(BurntStreetCred.ToString(GlobalSettings.CultureInfo)).Append(')');
                    }

                    return sbdReturn.ToString();
                }
            }
        }

        /// <summary>
        /// Amount of Notoriety the character has earned through standard means.
        /// </summary>
        public int CalculatedNotoriety
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    // Notoriety is simply the total value of Notoriety Improvements + the number of Enemies they have.
                    int intReturn = ImprovementManager.ValueOf(this, Improvement.ImprovementType.Notoriety)
                                                      .StandardRound() -
                                    (BurntStreetCred / 2); // + Contacts.Count(x => x.EntityType == ContactType.Enemy);

                    return intReturn;
                }
            }
        }

        /// <summary>
        /// Character's total amount of Notoriety (earned + GM awarded - burnt Street Cred).
        /// </summary>
        public int TotalNotoriety
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CalculatedNotoriety + Notoriety;
            }
        }

        public string CareerDisplayNotoriety
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                {
                    int intCalculatedNotoriety = CalculatedNotoriety;
                    return (intCalculatedNotoriety >= 0
                               ? strSpace + '+' + strSpace +
                                 intCalculatedNotoriety.ToString(GlobalSettings.CultureInfo)
                               : strSpace + '-' + strSpace +
                                 (-intCalculatedNotoriety).ToString(GlobalSettings.CultureInfo)) + strSpace + '=' +
                           strSpace + TotalNotoriety.ToString(GlobalSettings.CultureInfo);
                }
            }
        }

        /// <summary>
        /// Tooltip to use for Notoriety total.
        /// </summary>
        public string NotorietyTooltip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdReturn))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdReturn.Append(Notoriety.ToString(GlobalSettings.CultureInfo));

                        foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.Notoriety))
                        {
                            sbdReturn.Append(strSpace).Append('+').Append(strSpace)
                                     .Append(GetObjectName(objImprovement))
                                     .Append(strSpace).Append('(')
                                     .Append(objImprovement.Value.ToString(GlobalSettings.CultureInfo)).Append(')');
                        }

                        if (BurntStreetCred > 0)
                            sbdReturn.Append(strSpace).Append('-').Append(strSpace)
                                     .Append(LanguageManager.GetString("String_BurntStreetCred")).Append(
                                         strSpace).Append('(')
                                     .Append((BurntStreetCred / 2).ToString(GlobalSettings.CultureInfo)).Append(')');
                    }

                    return sbdReturn.ToString();
                }
            }
        }

        /// <summary>
        /// Amount of Public Awareness the character has earned through standard means.
        /// </summary>
        public int CalculatedPublicAwareness
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    int intReturn = ImprovementManager.ValueOf(this, Improvement.ImprovementType.PublicAwareness)
                                                      .StandardRound();
                    if (Settings.UseCalculatedPublicAwareness)
                    {
                        // Public Awareness is calculated as (Street Cred + Notoriety) / 3, rounded down.
                        intReturn += (TotalStreetCred + TotalNotoriety) / 3;
                    }

                    return intReturn;
                }
            }
        }

        /// <summary>
        /// Character's total amount of Public Awareness (earned + GM awarded).
        /// </summary>
        public int TotalPublicAwareness
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    int intReturn = PublicAwareness + CalculatedPublicAwareness;
                    if (Erased && intReturn >= 1)
                        return 1;
                    return intReturn;
                }
            }
        }

        public string CareerDisplayPublicAwareness
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                {
                    int intTotalPublicAwareness = TotalPublicAwareness;
                    int intCalculatedPublicAwareness = intTotalPublicAwareness - PublicAwareness;
                    return (intCalculatedPublicAwareness >= 0
                               ? strSpace + '+' + strSpace +
                                 intCalculatedPublicAwareness.ToString(GlobalSettings.CultureInfo)
                               : strSpace + '-' + strSpace +
                                 (-intCalculatedPublicAwareness).ToString(GlobalSettings.CultureInfo)) + strSpace +
                           '=' + strSpace + intTotalPublicAwareness.ToString(GlobalSettings.CultureInfo);
                }
            }
        }

        /// <summary>
        /// Public Awareness Tooltip.
        /// </summary>
        public string PublicAwarenessTooltip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdReturn))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdReturn.Append(PublicAwareness.ToString(GlobalSettings.CultureInfo));

                        foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.PublicAwareness))
                        {
                            sbdReturn.Append(strSpace).Append('+').Append(strSpace)
                                     .Append(GetObjectName(objImprovement))
                                     .Append(strSpace).Append('(')
                                     .Append(objImprovement.Value.ToString(GlobalSettings.CultureInfo)).Append(')');
                        }

                        if (Settings.UseCalculatedPublicAwareness)
                        {
                            sbdReturn.Append(strSpace).Append('+').Append(strSpace).Append('[')
                                     .Append(LanguageManager.GetString("String_StreetCred")).Append(strSpace)
                                     .Append('+')
                                     .Append(strSpace).Append(LanguageManager.GetString("String_Notoriety")).Append(']')
                                     .Append(strSpace).Append('').Append(strSpace)
                                     .Append(3.ToString(GlobalSettings.CultureInfo)).Append(strSpace).Append('(')
                                     .Append(((TotalStreetCred + TotalNotoriety) / 3).ToString(
                                                 GlobalSettings.CultureInfo))
                                     .Append(')');
                        }

                        if (Erased)
                        {
                            int intTotalPublicAwareness = PublicAwareness + CalculatedPublicAwareness;
                            if (intTotalPublicAwareness > 1)
                            {
                                string strErasedString = Qualities.FirstOrDefault(x => x.Name == "Erased")
                                                                  ?.CurrentDisplayNameShort;
                                if (string.IsNullOrEmpty(strErasedString))
                                {
                                    XPathNavigator xmlErasedQuality = LoadDataXPath("qualities.xml")
                                        .SelectSingleNodeAndCacheExpression("chummer/qualities/quality[name = \"Erased\"]");
                                    if (xmlErasedQuality != null)
                                    {
                                        strErasedString
                                            = xmlErasedQuality.SelectSingleNodeAndCacheExpression("translate")?.Value
                                              ?? "Erased";
                                    }
                                }

                                sbdReturn.Append(strSpace).Append('-').Append(strSpace).Append(strErasedString)
                                         .Append(strSpace)
                                         .Append('(')
                                         .Append((intTotalPublicAwareness - 1).ToString(GlobalSettings.CultureInfo))
                                         .Append(')');
                            }
                        }
                    }

                    return sbdReturn.ToString();
                }
            }
        }

        #endregion Reputation

        #region List Properties

        /// <summary>
        /// Improvements.
        /// </summary>
        public ThreadSafeObservableCollection<Improvement> Improvements
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstImprovements;
            }
        }

        /// <summary>
        /// Improvements.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<Improvement>> GetImprovementsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _lstImprovements;
        }

        /// <summary>
        /// Mentor spirits.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<MentorSpirit> MentorSpirits
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstMentorSpirits;
            }
        }

        /// <summary>
        /// Contacts and Enemies.
        /// </summary>
        public ThreadSafeObservableCollection<Contact> Contacts
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstContacts;
            }
        }

        public async ValueTask<ThreadSafeObservableCollection<Contact>> GetContactsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _lstContacts;
        }

        /// <summary>
        /// Spirits and Sprites.
        /// </summary>
        public ThreadSafeObservableCollection<Spirit> Spirits
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstSpirits;
            }
        }

        /// <summary>
        /// Spirits and Sprites.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<Spirit>> GetSpiritsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _lstSpirits;
        }

        /// <summary>
        /// Magician Spells.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<Spell> Spells
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstSpells;
            }
        }

        /// <summary>
        /// Magician Spells.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<Spell>> GetSpellsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _lstSpells;
        }

        /// <summary>
        /// Sustained Spells
        /// </summary>
        public ThreadSafeObservableCollection<SustainedObject> SustainedCollection
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstSustainedObjects;
            }
        }

        /// <summary>
        /// Sustained Spells.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<SustainedObject>> GetSustainedCollectionAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _lstSustainedObjects;
        }

        /// <summary>
        /// Foci.
        /// </summary>
        public ThreadSafeList<Focus> Foci
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstFoci;
            }
        }

        /// <summary>
        /// Foci.
        /// </summary>
        public async ValueTask<ThreadSafeList<Focus>> GetFociAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _lstFoci;
        }

        /// <summary>
        /// Stacked Foci.
        /// </summary>
        public ThreadSafeList<StackedFocus> StackedFoci
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstStackedFoci;
            }
        }

        /// <summary>
        /// Stacked Foci.
        /// </summary>
        public async ValueTask<ThreadSafeList<StackedFocus>> GetStackedFociAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _lstStackedFoci;
        }

        /// <summary>
        /// Adept Powers.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeBindingList<Power> Powers
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstPowers;
            }
        }

        /// <summary>
        /// Adept Powers.
        /// </summary>
        public async ValueTask<ThreadSafeBindingList<Power>> GetPowersAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _lstPowers;
        }

        /// <summary>
        /// Technomancer Complex Forms.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<ComplexForm> ComplexForms
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstComplexForms;
            }
        }

        /// <summary>
        /// Technomancer Complex Forms.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<ComplexForm>> GetComplexFormsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _lstComplexForms;
        }

        /// <summary>
        /// AI Programs and Advanced Programs
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<AIProgram> AIPrograms
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstAIPrograms;
            }
        }

        /// <summary>
        /// AI Programs and Advanced Programs
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<AIProgram>> GetAIProgramsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _lstAIPrograms;
        }

        /// <summary>
        /// Martial Arts.
        /// </summary>
        public ThreadSafeObservableCollection<MartialArt> MartialArts
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstMartialArts;
            }
        }

        /// <summary>
        /// Martial Arts.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<MartialArt>> GetMartialArtsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _lstMartialArts;
        }

        /// <summary>
        /// Limit Modifiers.
        /// </summary>
        public ThreadSafeObservableCollection<LimitModifier> LimitModifiers
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstLimitModifiers;
            }
        }

        /// <summary>
        /// Limit Modifiers.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<LimitModifier>> GetLimitModifiersAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _lstLimitModifiers;
        }

        /// <summary>
        /// Armor.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<Armor> Armor
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstArmor;
            }
        }

        /// <summary>
        /// Armor.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<Armor>> GetArmorAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _lstArmor;
        }

        /// <summary>
        /// Cyberware and Bioware.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<Cyberware> Cyberware
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstCyberware;
            }
        }

        /// <summary>
        /// Cyberware and Bioware.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<Cyberware>> GetCyberwareAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _lstCyberware;
        }

        /// <summary>
        /// Weapons.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<Weapon> Weapons
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstWeapons;
            }
        }

        /// <summary>
        /// Weapons.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<Weapon>> GetWeaponsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _lstWeapons;
        }

        /// <summary>
        /// Lifestyles.
        /// </summary>
        public ThreadSafeObservableCollection<Lifestyle> Lifestyles
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstLifestyles;
            }
        }

        /// <summary>
        /// Lifestyles.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<Lifestyle>> GetLifestylesAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _lstLifestyles;
        }

        /// <summary>
        /// Gear.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<Gear> Gear
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstGear;
            }
        }

        /// <summary>
        /// Gear.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<Gear>> GetGearAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _lstGear;
        }

        /// <summary>
        /// Vehicles.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<Vehicle> Vehicles
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstVehicles;
            }
        }

        /// <summary>
        /// Vehicles.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<Vehicle>> GetVehiclesAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _lstVehicles;
        }

        /// <summary>
        /// Metamagics and Echoes.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<Metamagic> Metamagics
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstMetamagics;
            }
        }

        /// <summary>
        /// Metamagics and Echoes.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<Metamagic>> GetMetamagicsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _lstMetamagics;
        }

        /// <summary>
        /// Enhancements.
        /// </summary>
        public ThreadSafeObservableCollection<Enhancement> Enhancements
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstEnhancements;
            }
        }

        /// <summary>
        /// Enhancements.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<Enhancement>> GetEnhancementsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _lstEnhancements;
        }

        /// <summary>
        /// Arts.
        /// </summary>
        public ThreadSafeObservableCollection<Art> Arts
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstArts;
            }
        }

        /// <summary>
        /// Arts.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<Art>> GetArtsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _lstArts;
        }

        /// <summary>
        /// Critter Powers.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<CritterPower> CritterPowers
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstCritterPowers;
            }
        }

        /// <summary>
        /// Critter Powers.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<CritterPower>> GetCritterPowersAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _lstCritterPowers;
        }

        /// <summary>
        /// Initiation and Submersion Grades.
        /// </summary>
        public ThreadSafeObservableCollection<InitiationGrade> InitiationGrades
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstInitiationGrades;
            }
        }

        /// <summary>
        /// Initiation and Submersion Grades.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<InitiationGrade>> GetInitiationGradesAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _lstInitiationGrades;
        }

        /// <summary>
        /// Expenses (Karma and Nuyen).
        /// </summary>
        public ThreadSafeObservableCollection<ExpenseLogEntry> ExpenseEntries
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstExpenseLog;
            }
        }

        /// <summary>
        /// Qualities (Positive and Negative).
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<Quality> Qualities
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstQualities;
            }
        }

        /// <summary>
        /// Qualities (Positive and Negative).
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<Quality>> GetQualitiesAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _lstQualities;
        }

        /*
        /// <summary>
        /// Life modules
        /// </summary>
        public List<LifeModule> LifeModules
        {
            get { return _lstLifeModules; }
        }
        */

        /// <summary>
        /// Locations.
        /// </summary>
        public ThreadSafeObservableCollection<Location> GearLocations
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstGearLocations;
            }
        }

        /// <summary>
        /// Armor Bundles.
        /// </summary>
        public ThreadSafeObservableCollection<Location> ArmorLocations
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstArmorLocations;
            }
        }

        /// <summary>
        /// Vehicle Locations.
        /// </summary>
        public ThreadSafeObservableCollection<Location> VehicleLocations
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstVehicleLocations;
            }
        }

        /// <summary>
        /// Weapon Locations.
        /// </summary>
        public ThreadSafeObservableCollection<Location> WeaponLocations
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstWeaponLocations;
            }
        }

        /// <summary>
        /// Improvement Groups.
        /// </summary>
        public ThreadSafeObservableCollection<string> ImprovementGroups
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstImprovementGroups;
            }
        }

        /// <summary>
        /// Calendar.
        /// </summary>
        public ThreadSafeBindingList<CalendarWeek> Calendar
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstCalendar;
            }
        }

        /// <summary>
        /// Take out the list of internal IDs that need their improvements re-applied (and then immediately re-apply them).
        /// </summary>
        public ConcurrentBag<string> TakeInternalIdsNeedingReapplyImprovements(CancellationToken token = default)
        {
            // Only need read lock because we use interlocked to make sure access is still write-safe
            using (EnterReadLock.Enter(LockObject, token))
                return Interlocked.Exchange(ref _lstInternalIdsNeedingReapplyImprovements, null);
        }

        /// <summary>
        /// Take out the list of internal IDs that need their improvements re-applied (and then immediately re-apply them).
        /// </summary>
        public async ValueTask<ConcurrentBag<string>> TakeInternalIdsNeedingReapplyImprovementsAsync(CancellationToken token = default)
        {
            // Only need read lock because we use interlocked to make sure access is still write-safe
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return Interlocked.Exchange(ref _lstInternalIdsNeedingReapplyImprovements, null);
        }

        #endregion List Properties

        #region Armor Properties

        public int GetArmorRating(Improvement.ImprovementType eDamageType = Improvement.ImprovementType.Armor)
        {
            return GetArmorRatingWithImprovement(eDamageType, out int _, out List<Improvement> _);
        }

        public int GetArmorRatingWithImprovement(Improvement.ImprovementType eDamageType, out int intFromEquippedArmorImprovements, out List<Improvement> lstUsedImprovements)
        {
            intFromEquippedArmorImprovements = 0;
            if (eDamageType == Improvement.ImprovementType.None)
            {
                lstUsedImprovements = new List<Improvement>();
                return 0;
            }

            using (EnterReadLock.Enter(LockObject))
            {
                List<Armor> lstArmorsToConsider = Armor.Where(objArmor => objArmor.Equipped).ToList();
                decimal decBaseArmorImprovement
                    = ImprovementManager.ValueOf(this, eDamageType, out lstUsedImprovements);
                if (eDamageType != Improvement.ImprovementType.Armor)
                {
                    decBaseArmorImprovement += ImprovementManager.ValueOf(
                        this, Improvement.ImprovementType.Armor, out List<Improvement> lstUsedImprovementsExtra);
                    lstUsedImprovements.AddRange(lstUsedImprovementsExtra);
                }

                if (lstArmorsToConsider.Count == 0)
                    return decBaseArmorImprovement.StandardRound();
                decimal decGeneralArmorImprovementValue = decBaseArmorImprovement;
                Dictionary<Armor, decimal> dicArmorImprovementValues
                    = lstArmorsToConsider.ToDictionary(x => x, y => decBaseArmorImprovement);
                foreach (Improvement objImprovement in lstUsedImprovements)
                {
                    if (objImprovement.ImproveSource != Improvement.ImprovementSource.Armor &&
                        objImprovement.ImproveSource != Improvement.ImprovementSource.ArmorMod)
                        continue;
                    Armor objSourceArmor =
                        lstArmorsToConsider.Find(x => x.InternalId == objImprovement.SourceName)
                        ?? lstArmorsToConsider.FindArmorMod(objImprovement.SourceName)?.Parent;
                    if (objSourceArmor == null)
                        continue;
                    decGeneralArmorImprovementValue -= objImprovement.Value;
                    foreach (Armor objArmor in lstArmorsToConsider)
                    {
                        if (objArmor != objSourceArmor)
                            dicArmorImprovementValues[objArmor] -= objImprovement.Value;
                    }
                }

                int intAverageStrength = Settings.UncappedArmorAccessoryBonuses ? int.MaxValue : STR.TotalValue;

                // Run through the list of Armor currently worn and look at armors that start with '+' since they stack with the highest Armor, but only up to STR.
                Dictionary<Armor, int> dicArmorStackingValues
                    = lstArmorsToConsider.ToDictionary(x => x, y => 0);
                int intNakedStackingValue = 0;
                foreach (Armor objArmor in lstArmorsToConsider)
                {
                    if (!objArmor.ArmorValue.StartsWith('+')
                        && !objArmor.ArmorValue.StartsWith('-')
                        && !objArmor.ArmorOverrideValue.StartsWith('+')
                        && !objArmor.ArmorOverrideValue.StartsWith('-'))
                        continue;
                    string strCustomFitName = string.Empty;
                    foreach (ArmorMod objMod in objArmor.ArmorMods)
                    {
                        if (objMod.Name == "Custom Fit (Stack)" && objMod.Equipped)
                        {
                            strCustomFitName = objMod.Extra;
                            break;
                        }
                    }

                    foreach (Armor objInnerArmor in lstArmorsToConsider)
                    {
                        if (objInnerArmor == objArmor
                            || objInnerArmor.ArmorValue.StartsWith('+')
                            || objInnerArmor.ArmorValue.StartsWith('-'))
                            continue;
                        if (string.IsNullOrEmpty(strCustomFitName) || strCustomFitName != objInnerArmor.Name)
                        {
                            if (objArmor.ArmorValue.StartsWith('+') || objArmor.ArmorValue.StartsWith('-'))
                                dicArmorStackingValues[objInnerArmor] += objArmor.TotalArmor;
                        }
                        else if (objArmor.ArmorOverrideValue.StartsWith('+') || objArmor.ArmorOverrideValue.StartsWith('-'))
                        {
                            dicArmorStackingValues[objInnerArmor] += objArmor.TotalOverrideArmor;
                        }
                    }

                    if (intNakedStackingValue < intAverageStrength
                        && (objArmor.ArmorValue.StartsWith('+') || objArmor.ArmorValue.StartsWith('-')))
                        intNakedStackingValue
                            = Math.Min(intNakedStackingValue + objArmor.TotalArmor, intAverageStrength);
                }

                // Run through list of Armor again to cap off any whose stacking bonuses are greater than STR
                foreach (Armor objArmor in lstArmorsToConsider)
                {
                    if (dicArmorStackingValues.TryGetValue(objArmor, out int intStack) && intStack > intAverageStrength)
                        dicArmorStackingValues[objArmor] = intAverageStrength;
                }

                // Run through the list of Armor a third time to retrieve the highest total Armor rating.
                Armor objHighestArmor = null;
                int intHighest = 0;
                foreach (Armor objArmor in lstArmorsToConsider)
                {
                    if (objArmor.ArmorValue.StartsWith('+')
                        || objArmor.ArmorValue.StartsWith('-'))
                        continue;

                    int intArmorValue = objArmor.TotalArmor + dicArmorStackingValues[objArmor] + dicArmorImprovementValues[objArmor].StandardRound();
                    if (intArmorValue > intHighest)
                    {
                        intHighest = intArmorValue;
                        intFromEquippedArmorImprovements = (dicArmorImprovementValues[objArmor] - decGeneralArmorImprovementValue).StandardRound();
                        objHighestArmor = objArmor;
                    }
                }

                int intArmor = objHighestArmor != null
                    ? intHighest
                    : intNakedStackingValue + decGeneralArmorImprovementValue.StandardRound();

                return intArmor;
            }
        }

        public async ValueTask<int> GetArmorRatingAsync(Improvement.ImprovementType eDamageType = Improvement.ImprovementType.Armor, CancellationToken token = default)
        {
            return (await GetArmorRatingWithImprovementAsync(eDamageType, token).ConfigureAwait(false)).Item1;
        }

        public async ValueTask<Tuple<int, int, List<Improvement>>> GetArmorRatingWithImprovementAsync(Improvement.ImprovementType eDamageType, CancellationToken token = default)
        {
            if (eDamageType == Improvement.ImprovementType.None)
            {
                return new Tuple<int, int, List<Improvement>>(0, 0, new List<Improvement>());
            }

            int intFromEquippedArmorImprovements = 0;
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                List<Armor> lstArmorsToConsider = await (await GetArmorAsync(token).ConfigureAwait(false)).ToListAsync(objArmor => objArmor.Equipped, token: token).ConfigureAwait(false);
                (decimal decBaseArmorImprovement, List<Improvement> lstUsedImprovements)
                    = await ImprovementManager.ValueOfTupleAsync(this, eDamageType, token: token).ConfigureAwait(false);
                if (eDamageType != Improvement.ImprovementType.Armor)
                {
                    (decimal decExtra, List<Improvement> lstUsedImprovementsExtra)
                        = await ImprovementManager.ValueOfTupleAsync(this, Improvement.ImprovementType.Armor, token: token).ConfigureAwait(false);
                    decBaseArmorImprovement += decExtra;
                    lstUsedImprovements.AddRange(lstUsedImprovementsExtra);
                }

                if (lstArmorsToConsider.Count == 0)
                    return new Tuple<int, int, List<Improvement>>(decBaseArmorImprovement.StandardRound(), intFromEquippedArmorImprovements, lstUsedImprovements);
                decimal decGeneralArmorImprovementValue = decBaseArmorImprovement;
                Dictionary<Armor, decimal> dicArmorImprovementValues
                    = lstArmorsToConsider.ToDictionary(x => x, y => decBaseArmorImprovement);
                foreach (Improvement objImprovement in lstUsedImprovements)
                {
                    if (objImprovement.ImproveSource != Improvement.ImprovementSource.Armor &&
                        objImprovement.ImproveSource != Improvement.ImprovementSource.ArmorMod)
                        continue;
                    Armor objSourceArmor =
                        lstArmorsToConsider.Find(x => x.InternalId == objImprovement.SourceName)
                        ?? lstArmorsToConsider.FindArmorMod(objImprovement.SourceName)?.Parent;
                    if (objSourceArmor == null)
                        continue;
                    decGeneralArmorImprovementValue -= objImprovement.Value;
                    foreach (Armor objArmor in lstArmorsToConsider)
                    {
                        if (objArmor != objSourceArmor)
                            dicArmorImprovementValues[objArmor] -= objImprovement.Value;
                    }
                }

                int intAverageStrength = Settings.UncappedArmorAccessoryBonuses
                    ? int.MaxValue
                    : await (await GetAttributeAsync("STR", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false);

                // Run through the list of Armor currently worn and look at armors that start with '+' since they stack with the highest Armor, but only up to STR.
                Dictionary<Armor, int> dicArmorStackingValues
                    = lstArmorsToConsider.ToDictionary(x => x, y => 0);
                int intNakedStackingValue = 0;
                foreach (Armor objArmor in lstArmorsToConsider)
                {
                    if (!objArmor.ArmorValue.StartsWith('+')
                        && !objArmor.ArmorValue.StartsWith('-')
                        && !objArmor.ArmorOverrideValue.StartsWith('+')
                        && !objArmor.ArmorOverrideValue.StartsWith('-'))
                        continue;
                    string strCustomFitName = string.Empty;
                    foreach (ArmorMod objMod in objArmor.ArmorMods)
                    {
                        if (objMod.Name == "Custom Fit (Stack)" && objMod.Equipped)
                        {
                            strCustomFitName = objMod.Extra;
                            break;
                        }
                    }

                    foreach (Armor objInnerArmor in lstArmorsToConsider)
                    {
                        if (objInnerArmor == objArmor
                            || objInnerArmor.ArmorValue.StartsWith('+')
                            || objInnerArmor.ArmorValue.StartsWith('-'))
                            continue;
                        if (string.IsNullOrEmpty(strCustomFitName) || strCustomFitName != objInnerArmor.Name)
                        {
                            if (objArmor.ArmorValue.StartsWith('+') || objArmor.ArmorValue.StartsWith('-'))
                                dicArmorStackingValues[objInnerArmor] += objArmor.TotalArmor;
                        }
                        else if (objArmor.ArmorOverrideValue.StartsWith('+') || objArmor.ArmorOverrideValue.StartsWith('-'))
                        {
                            dicArmorStackingValues[objInnerArmor] += objArmor.TotalOverrideArmor;
                        }
                    }

                    if (intNakedStackingValue < intAverageStrength
                        && (objArmor.ArmorValue.StartsWith('+') || objArmor.ArmorValue.StartsWith('-')))
                        intNakedStackingValue
                            = Math.Min(intNakedStackingValue + objArmor.TotalArmor, intAverageStrength);
                }

                // Run through list of Armor again to cap off any whose stacking bonuses are greater than STR
                foreach (Armor objArmor in lstArmorsToConsider)
                {
                    if (dicArmorStackingValues.TryGetValue(objArmor, out int intStack) && intStack > intAverageStrength)
                        dicArmorStackingValues[objArmor] = intAverageStrength;
                }

                // Run through the list of Armor a third time to retrieve the highest total Armor rating.
                Armor objHighestArmor = null;
                int intHighest = 0;
                foreach (Armor objArmor in lstArmorsToConsider)
                {
                    if (objArmor.ArmorValue.StartsWith('+')
                        || objArmor.ArmorValue.StartsWith('-'))
                        continue;

                    int intArmorValue = objArmor.TotalArmor + dicArmorStackingValues[objArmor] + dicArmorImprovementValues[objArmor].StandardRound();
                    if (intArmorValue > intHighest)
                    {
                        intHighest = intArmorValue;
                        intFromEquippedArmorImprovements = (dicArmorImprovementValues[objArmor] - decGeneralArmorImprovementValue).StandardRound();
                        objHighestArmor = objArmor;
                    }
                }

                int intArmor = objHighestArmor != null
                    ? intHighest
                    : intNakedStackingValue + decGeneralArmorImprovementValue.StandardRound();

                return new Tuple<int, int, List<Improvement>>(intArmor, intFromEquippedArmorImprovements, lstUsedImprovements);
            }
        }

        public int DamageResistancePool
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    int intBody = 0;
                    if (IsAI)
                    {
                        if (HomeNode is Vehicle objVehicle)
                            intBody = objVehicle.TotalBody;
                    }
                    else
                        intBody = BOD.TotalValue;

                    return intBody +
                           TotalArmorRating +
                           ImprovementManager.ValueOf(this, Improvement.ImprovementType.DamageResistance)
                                             .StandardRound();
                }
            }
        }

        public string DamageResistancePoolToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                {
                    int intBody;
                    string strBodyAbbrev;
                    if (IsAI)
                    {
                        intBody = HomeNode is Vehicle objVehicle ? objVehicle.TotalBody : 0;
                        strBodyAbbrev = LanguageManager.GetString("String_VehicleBody");
                    }
                    else
                    {
                        intBody = BOD.TotalValue;
                        strBodyAbbrev = BOD.DisplayAbbrev;
                    }

                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append(strBodyAbbrev).Append(strSpace).Append('(')
                                  .Append(intBody.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                                  .Append('+').Append(strSpace).Append(LanguageManager.GetString("Tip_Armor"))
                                  .Append(strSpace).Append('(')
                                  .Append(TotalArmorRating.ToString(GlobalSettings.CultureInfo)).Append(')');

                        foreach (Improvement objLoopImprovement in
                                 ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.DamageResistance))
                        {
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                      .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        public int CurrentCounterspellingDice
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intCurrentCounterspellingDice;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _intCurrentCounterspellingDice, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        public int CurrentLiftCarryHits
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intCurrentLiftCarryHits;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _intCurrentLiftCarryHits, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        #region Dodge

        public int Dodge
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return REA.TotalValue + INT.TotalValue + TotalBonusDodgeRating + WoundModifier + SustainingPenalty;
            }
        }

        public string DisplayDodge
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return Dodge.ToString(GlobalSettings.CultureInfo);
            }
        }

        public string DodgeToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(REA.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(REA.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(INT.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(INT.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(LanguageManager.GetString("Tip_Skill_Wounds"))
                                  .Append(strSpace).Append('(')
                                  .Append(WoundModifier.ToString(GlobalSettings.CultureInfo))
                                  .Append(')').Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Tip_Skill_Sustain")).Append(strSpace).Append('(')
                                  .Append(SustainingPenalty.ToString(GlobalSettings.CultureInfo)).Append(')');

                        int intModifiers = TotalBonusDodgeRating;

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                Improvement.ImprovementType.Dodge.Yield(),
                                strSpace,
                                intModifiers);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        #endregion Dodge

        #region Spell Defense

        #region Indirect Dodge

        public int SpellDefenseIndirectDodge
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return Dodge;
            }
        }

        public string DisplaySpellDefenseIndirectDodge
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseIndirectDodge.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseIndirectDodge.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseIndirectDodge + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseIndirectDodgeToolTip
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    string strToolTip = DodgeToolTip;

                    if (CurrentCounterspellingDice != 0)
                    {
                        string strSpace = LanguageManager.GetString("String_Space");
                        strToolTip += strSpace + '+' + strSpace + LanguageManager.GetString("Label_CounterspellingDice")
                                      +
                                      strSpace + '(' + CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo)
                                      + ')';
                    }

                    return strToolTip;
                }
            }
        }

        #endregion Indirect Dodge

        #region Indirect Soak

        public int SpellDefenseIndirectSoak
        {
            get
            {
                int intAttributes = 0;
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        if (HomeNode is Vehicle objVehicle)
                            intAttributes = objVehicle.TotalBody;
                    }
                    else
                        intAttributes = BOD.TotalValue;

                    return intAttributes +
                           GetArmorRating(Improvement.ImprovementType.SpellResistance) +
                           ImprovementManager.ValueOf(this, Improvement.ImprovementType.DamageResistance)
                                             .StandardRound();
                }
            }
        }

        public string DisplaySpellDefenseIndirectSoak
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseIndirectSoak.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseIndirectSoak.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseIndirectSoak + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseIndirectSoakToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                {
                    int intBody;
                    string strBodyAbbrev;
                    if (IsAI)
                    {
                        intBody = HomeNode is Vehicle objVehicle ? objVehicle.TotalBody : 0;
                        strBodyAbbrev = LanguageManager.GetString("String_VehicleBody");
                    }
                    else
                    {
                        intBody = BOD.TotalValue;
                        strBodyAbbrev = BOD.DisplayAbbrev;
                    }

                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append(strBodyAbbrev).Append(strSpace).Append('(')
                                  .Append(intBody.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Tip_Armor"))
                                  .Append(strSpace).Append('(')
                                  .Append(TotalArmorRating.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');

                        if (CurrentCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                      .Append('(')
                                      .Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DamageResistance)).StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                Improvement.ImprovementType.DamageResistance.Yield(),
                                strSpace,
                                intModifiers);
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        #endregion Indirect Soak

        #region Direct Soak Mana

        public int SpellDefenseDirectSoakMana
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return WIL.TotalValue
                           + (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                              + ImprovementManager.ValueOf(this, Improvement.ImprovementType.DirectManaSpellResist))
                           .StandardRound();
            }
        }

        public string DisplaySpellDefenseDirectSoakMana
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseDirectSoakMana.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseDirectSoakMana.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseDirectSoakMana + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseDirectSoakManaToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                        if (CurrentCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                      .Append('(')
                                      .Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DirectManaSpellResist)).StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                Improvement.ImprovementType.SpellResistance.Yield(),
                                strSpace,
                                intModifiers);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        #endregion Direct Soak Mana

        #region Direct Soak Physical

        public int SpellDefenseDirectSoakPhysical
        {
            get
            {
                int intAttributes = 0;
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        if (HomeNode is Vehicle objVehicle)
                            intAttributes = objVehicle.TotalBody;
                    }
                    else
                        intAttributes = BOD.TotalValue;

                    return intAttributes +
                           (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance) +
                            ImprovementManager.ValueOf(this, Improvement.ImprovementType.DirectPhysicalSpellResist))
                           .StandardRound();
                }
            }
        }

        public string DisplaySpellDefenseDirectSoakPhysical
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseDirectSoakPhysical.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseDirectSoakPhysical.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseDirectSoakPhysical + CurrentCounterspellingDice).ToString(
                              GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseDirectSoakPhysicalToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                {
                    int intBody;
                    string strBodyAbbrev;
                    if (IsAI)
                    {
                        intBody = HomeNode is Vehicle objVehicle ? objVehicle.TotalBody : 0;
                        strBodyAbbrev = LanguageManager.GetString("String_VehicleBody");
                    }
                    else
                    {
                        intBody = BOD.TotalValue;
                        strBodyAbbrev = BOD.DisplayAbbrev;
                    }

                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append(strBodyAbbrev).Append(strSpace).Append('(')
                                  .Append(intBody.ToString(GlobalSettings.CultureInfo)).Append(')');

                        if (CurrentCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                      .Append('(')
                                      .Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DirectPhysicalSpellResist))
                            .StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                new[]
                                {
                                    Improvement.ImprovementType.SpellResistance,
                                    Improvement.ImprovementType.DirectPhysicalSpellResist
                                },
                                strSpace,
                                intModifiers);
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        #endregion Direct Soak Physical

        #region Detection

        public int SpellDefenseDetection
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return LOG.TotalValue + WIL.TotalValue + SpellResistance +
                           ImprovementManager.ValueOf(this, Improvement.ImprovementType.DetectionSpellResist)
                                             .StandardRound();
            }
        }

        public string DisplaySpellDefenseDetection
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseDetection.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseDetection.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseDetection + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseDetectionToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(LOG.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(LOG.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                        if (CurrentCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                      .Append('(')
                                      .Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DetectionSpellResist)).StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                new[]
                                {
                                    Improvement.ImprovementType.SpellResistance,
                                    Improvement.ImprovementType.DetectionSpellResist
                                },
                                strSpace,
                                intModifiers);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        #endregion Detection

        #region Decrease Attributes

        public int SpellDefenseDecreaseBOD
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return BOD.TotalValue + WIL.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.DecreaseBODResist))
                                          .StandardRound();
            }
        }

        public string DisplaySpellDefenseDecreaseBOD
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseDecreaseBOD.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseDecreaseBOD.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseDecreaseBOD + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseDecreaseBODToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(BOD.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(BOD.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                        if (CurrentCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                      .Append('(')
                                      .Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DecreaseBODResist)).StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                new[]
                                {
                                    Improvement.ImprovementType.SpellResistance,
                                    Improvement.ImprovementType.DecreaseBODResist
                                },
                                strSpace,
                                intModifiers);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public int SpellDefenseDecreaseAGI
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AGI.TotalValue + WIL.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.DecreaseAGIResist))
                                          .StandardRound();
            }
        }

        public string DisplaySpellDefenseDecreaseAGI
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseDecreaseAGI.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseDecreaseAGI.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseDecreaseAGI + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseDecreaseAGIToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(AGI.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(AGI.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                        if (CurrentCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                      .Append('(')
                                      .Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DecreaseAGIResist)).StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                new[]
                                {
                                    Improvement.ImprovementType.SpellResistance,
                                    Improvement.ImprovementType.DecreaseAGIResist
                                },
                                strSpace,
                                intModifiers);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public int SpellDefenseDecreaseREA
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return REA.TotalValue + WIL.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.DecreaseREAResist))
                                          .StandardRound();
            }
        }

        public string DisplaySpellDefenseDecreaseREA
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseDecreaseREA.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseDecreaseREA.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseDecreaseREA + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseDecreaseREAToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(REA.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(REA.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                        if (CurrentCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                      .Append('(')
                                      .Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DecreaseREAResist)).StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                new[]
                                {
                                    Improvement.ImprovementType.SpellResistance,
                                    Improvement.ImprovementType.DecreaseREAResist
                                },
                                strSpace,
                                intModifiers);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public int SpellDefenseDecreaseSTR
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return STR.TotalValue + WIL.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.DecreaseSTRResist))
                                          .StandardRound();
            }
        }

        public string DisplaySpellDefenseDecreaseSTR
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseDecreaseSTR.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseDecreaseSTR.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseDecreaseSTR + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseDecreaseSTRToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(STR.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(STR.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                        if (CurrentCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                      .Append('(')
                                      .Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DecreaseSTRResist)).StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                Improvement.ImprovementType.SpellResistance.Yield(),
                                strSpace,
                                intModifiers);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public int SpellDefenseDecreaseCHA
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CHA.TotalValue + WIL.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.DecreaseCHAResist))
                                          .StandardRound();
            }
        }

        public string DisplaySpellDefenseDecreaseCHA
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseDecreaseCHA.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseDecreaseCHA.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseDecreaseCHA + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseDecreaseCHAToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(CHA.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(CHA.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                        if (CurrentCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                      .Append('(')
                                      .Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DecreaseCHAResist)).StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                new[]
                                {
                                    Improvement.ImprovementType.SpellResistance,
                                    Improvement.ImprovementType.DecreaseCHAResist
                                },
                                strSpace,
                                intModifiers);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public int SpellDefenseDecreaseINT
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return INT.TotalValue + WIL.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.DecreaseINTResist))
                                          .StandardRound();
            }
        }

        public string DisplaySpellDefenseDecreaseINT
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseDecreaseINT.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseDecreaseINT.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseDecreaseINT + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseDecreaseINTToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(INT.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(INT.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                        if (CurrentCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                      .Append('(')
                                      .Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DecreaseINTResist)).StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                new[]
                                {
                                    Improvement.ImprovementType.SpellResistance,
                                    Improvement.ImprovementType.DecreaseINTResist
                                },
                                strSpace,
                                intModifiers);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public int SpellDefenseDecreaseLOG
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return LOG.TotalValue + WIL.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.DecreaseLOGResist))
                                          .StandardRound();
            }
        }

        public string DisplaySpellDefenseDecreaseLOG
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseDecreaseLOG.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseDecreaseLOG.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseDecreaseLOG + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseDecreaseLOGToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(LOG.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(LOG.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                        if (CurrentCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                      .Append('(')
                                      .Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DecreaseLOGResist)).StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                new[]
                                {
                                    Improvement.ImprovementType.SpellResistance,
                                    Improvement.ImprovementType.DecreaseLOGResist
                                },
                                strSpace,
                                intModifiers);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public int SpellDefenseDecreaseWIL
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return WIL.TotalValue + WIL.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.DecreaseWILResist))
                                          .StandardRound();
            }
        }

        public string DisplaySpellDefenseDecreaseWIL
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseDecreaseWIL.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseDecreaseWIL.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseDecreaseWIL + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseDecreaseWILToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                        if (CurrentCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                      .Append('(')
                                      .Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DecreaseWILResist)).StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                new[]
                                {
                                    Improvement.ImprovementType.SpellResistance,
                                    Improvement.ImprovementType.DecreaseWILResist
                                },
                                strSpace,
                                intModifiers);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        #endregion Decrease Attributes

        #endregion Spell Defense

        public int Surprise
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return REA.TotalValue + INT.TotalValue
                                          + ImprovementManager.ValueOf(this, Improvement.ImprovementType.Surprise)
                                                              .StandardRound()
                                          + WoundModifier
                                          + SustainingPenalty;
            }
        }

        public string SurpriseToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(REA.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(REA.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(INT.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(INT.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(LanguageManager.GetString("Tip_Skill_Wounds"))
                                  .Append(strSpace).Append('(')
                                  .Append(WoundModifier.ToString(GlobalSettings.CultureInfo))
                                  .Append(')').Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Tip_Skill_Sustain")).Append(strSpace).Append('(')
                                  .Append(SustainingPenalty.ToString(GlobalSettings.CultureInfo)).Append(')');

                        int intModifiers = ImprovementManager.ValueOf(this, Improvement.ImprovementType.Surprise)
                                                             .StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                Improvement.ImprovementType.Surprise.Yield(),
                                strSpace,
                                intModifiers);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        private int _intCachedTotalArmorRating = int.MinValue;
        private int _intCachedTotalFireArmorRating = int.MinValue;
        private int _intCachedTotalColdArmorRating = int.MinValue;
        private int _intCachedTotalElectricityArmorRating = int.MinValue;
        private int _intCachedTotalAcidArmorRating = int.MinValue;
        private int _intCachedTotalFallingArmorRating = int.MinValue;

        /// <summary>
        /// The Character's total Armor Rating.
        /// </summary>
        [HubTag]
        public int TotalArmorRating
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedTotalArmorRating == int.MinValue)
                        _intCachedTotalArmorRating = GetArmorRating();
                    return _intCachedTotalArmorRating;
                }
            }
        }

        /// <summary>
        /// The Character's total Armor Rating.
        /// </summary>
        public async ValueTask<int> GetTotalArmorRatingAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (_intCachedTotalArmorRating == int.MinValue)
                    _intCachedTotalArmorRating = await GetArmorRatingAsync(token: token).ConfigureAwait(false);
                return _intCachedTotalArmorRating;
            }
        }

        public string TotalArmorRatingToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                {
                    int intArmor
                        = GetArmorRatingWithImprovement(Improvement.ImprovementType.Armor,
                                                        out int intFromHighestArmorImprovements,
                                                        out List<Improvement> lstUsedImprovements)
                          - ImprovementManager.ValueOf(this, Improvement.ImprovementType.Armor).StandardRound()
                          + intFromHighestArmorImprovements;

                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append(LanguageManager.GetString("Tip_Armor")).Append(strSpace).Append('(')
                                  .Append(intArmor.ToString(GlobalSettings.CultureInfo)).Append(')');
                        foreach (Improvement objLoopImprovement in lstUsedImprovements)
                        {
                            if (objLoopImprovement.ImproveSource != Improvement.ImprovementSource.Armor
                                && objLoopImprovement.ImproveSource != Improvement.ImprovementSource.ArmorMod)
                            {
                                sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                          .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                          .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                          .Append(')');
                            }
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against Fire attacks.
        /// </summary>
        public int TotalFireArmorRating
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedTotalFireArmorRating == int.MinValue)
                        _intCachedTotalFireArmorRating = GetArmorRating(Improvement.ImprovementType.FireArmor);
                    return _intCachedTotalFireArmorRating;
                }
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against Fire attacks.
        /// </summary>
        public async ValueTask<int> GetTotalFireArmorRatingAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (_intCachedTotalFireArmorRating == int.MinValue)
                    _intCachedTotalFireArmorRating = await GetArmorRatingAsync(Improvement.ImprovementType.FireArmor, token: token).ConfigureAwait(false);
                return _intCachedTotalFireArmorRating;
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against Cold attacks.
        /// </summary>
        public int TotalColdArmorRating
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedTotalColdArmorRating == int.MinValue)
                        _intCachedTotalColdArmorRating = GetArmorRating(Improvement.ImprovementType.ColdArmor);
                    return _intCachedTotalColdArmorRating;
                }
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against Cold attacks.
        /// </summary>
        public async ValueTask<int> GetTotalColdArmorRatingAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (_intCachedTotalColdArmorRating == int.MinValue)
                    _intCachedTotalColdArmorRating = await GetArmorRatingAsync(Improvement.ImprovementType.ColdArmor, token: token).ConfigureAwait(false);
                return _intCachedTotalColdArmorRating;
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against Electricity attacks.
        /// </summary>
        public int TotalElectricityArmorRating
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedTotalElectricityArmorRating == int.MinValue)
                        _intCachedTotalElectricityArmorRating
                            = GetArmorRating(Improvement.ImprovementType.ElectricityArmor);
                    return _intCachedTotalElectricityArmorRating;
                }
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against Electricity attacks.
        /// </summary>
        public async ValueTask<int> GetTotalElectricityArmorRatingAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (_intCachedTotalElectricityArmorRating == int.MinValue)
                    _intCachedTotalElectricityArmorRating = await GetArmorRatingAsync(Improvement.ImprovementType.ElectricityArmor, token: token).ConfigureAwait(false);
                return _intCachedTotalElectricityArmorRating;
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against Acid attacks.
        /// </summary>
        public int TotalAcidArmorRating
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedTotalAcidArmorRating == int.MinValue)
                        _intCachedTotalAcidArmorRating = GetArmorRating(Improvement.ImprovementType.AcidArmor);
                    return _intCachedTotalAcidArmorRating;
                }
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against Acid attacks.
        /// </summary>
        public async ValueTask<int> GetTotalAcidArmorRatingAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (_intCachedTotalAcidArmorRating == int.MinValue)
                    _intCachedTotalAcidArmorRating = await GetArmorRatingAsync(Improvement.ImprovementType.AcidArmor, token: token).ConfigureAwait(false);
                return _intCachedTotalAcidArmorRating;
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against falling damage (AP -4 not factored in).
        /// </summary>
        public int TotalFallingArmorRating
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedTotalFallingArmorRating == int.MinValue)
                        _intCachedTotalFallingArmorRating = GetArmorRating(Improvement.ImprovementType.FallingArmor);
                    return _intCachedTotalFallingArmorRating;
                }
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against falling damage (AP -4 not factored in).
        /// </summary>
        public async ValueTask<int> GetTotalFallingArmorRatingAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (_intCachedTotalFallingArmorRating == int.MinValue)
                    _intCachedTotalFallingArmorRating = await GetArmorRatingAsync(Improvement.ImprovementType.FallingArmor, token: token).ConfigureAwait(false);
                return _intCachedTotalFallingArmorRating;
            }
        }

        /// <summary>
        /// The Character's total bonus to Dodge Rating (to add on top of REA + INT).
        /// </summary>
        public int TotalBonusDodgeRating => ImprovementManager.ValueOf(this, Improvement.ImprovementType.Dodge).StandardRound();

        /// <summary>
        /// Encumbrance modifier for carrying more stuff than carry limit
        /// </summary>
        public int Encumbrance
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    decimal decCarryLimit = CarryLimit;

                    decimal decCarriedWeight = TotalCarriedWeight;

                    return decCarriedWeight > decCarryLimit
                        ? -((decCarriedWeight - decCarryLimit) / EncumbranceInterval).StandardRound()
                        : 0;
                }
            }
        }

        /// <summary>
        /// Total amount of stuff the character is currently carrying on their person (via Equipped)
        /// </summary>
        public decimal TotalCarriedWeight
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    decimal decReturn = _decCachedTotalCarriedWeight;
                    if (decReturn != decimal.MinValue)
                        return decReturn;
                    return _decCachedTotalCarriedWeight = Armor.Sum(x => x.Equipped, x => x.TotalWeight)
                                                          + Weapons.Sum(x => x.Equipped, x => x.TotalWeight)
                                                          + Gear.Sum(x => x.Equipped, x => x.TotalWeight)
                                                          + Cyberware.Sum(
                                                              x => x.IsModularCurrentlyEquipped, x => x.TotalWeight);
                }
            }
        }

        /// <summary>
        /// String used to show the current carried weight status in the toolstrip of character forms
        /// </summary>
        public string DisplayTotalCarriedWeight
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                    return TotalCarriedWeight.ToString(Settings.WeightFormat, GlobalSettings.CultureInfo) + strSpace
                        + "kg"
                        + strSpace + '/' + strSpace
                        + CarryLimit.ToString(Settings.WeightFormat, GlobalSettings.CultureInfo) + strSpace + "kg";
            }
        }

        /// <summary>
        /// Armor Encumbrance modifier from Armor.
        /// </summary>
        public int ArmorEncumbrance
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Settings.NoArmorEncumbrance)
                        return 0;
                    List<Armor> lstArmorsToConsider = Armor.Where(objArmor => objArmor.Equipped).ToList();
                    if (lstArmorsToConsider.Count == 0 || lstArmorsToConsider.All(objArmor => !objArmor.Encumbrance))
                        return 0;
                    int intAverageStrength = STR?.TotalValue ?? 0;
                    // Run through the list of Armor currently worn and look at armors that start with '+' since they stack with the highest Armor, but only up to STR.
                    Dictionary<Armor, Tuple<int, int>> dicArmorStackingValues
                        = lstArmorsToConsider.ToDictionary(x => x, y => new Tuple<int, int>(0, 0));
                    int intNakedEncumbranceValue = 0;
                    foreach (Armor objArmor in lstArmorsToConsider)
                    {
                        if (!objArmor.ArmorValue.StartsWith('+')
                            && !objArmor.ArmorValue.StartsWith('-')
                            && !objArmor.ArmorOverrideValue.StartsWith('+')
                            && !objArmor.ArmorOverrideValue.StartsWith('-'))
                            continue;
                        string strCustomFitName = string.Empty;
                        foreach (ArmorMod objMod in objArmor.ArmorMods)
                        {
                            if (objMod.Name == "Custom Fit (Stack)" && objMod.Equipped)
                            {
                                strCustomFitName = objMod.Extra;
                                break;
                            }
                        }

                        int intLoopStack = objArmor.ArmorValue.StartsWith('+') || objArmor.ArmorValue.StartsWith('-')
                            ? objArmor.TotalArmor
                            : 0;
                        foreach (Armor objInnerArmor in lstArmorsToConsider)
                        {
                            if (objInnerArmor == objArmor
                                || objInnerArmor.ArmorValue.StartsWith('+')
                                || objInnerArmor.ArmorValue.StartsWith('-'))
                                continue;
                            if (string.IsNullOrEmpty(strCustomFitName) || strCustomFitName != objInnerArmor.Name)
                            {
                                (int intI, int intJ) = dicArmorStackingValues[objInnerArmor];
                                if (objArmor.Encumbrance)
                                    dicArmorStackingValues[objInnerArmor]
                                        = new Tuple<int, int>(intI + intLoopStack, intJ + intLoopStack);
                                else
                                    dicArmorStackingValues[objInnerArmor]
                                        = new Tuple<int, int>(intI + intLoopStack, intJ);
                            }
                            else if (objArmor.ArmorOverrideValue.StartsWith('+') || objArmor.ArmorOverrideValue.StartsWith('-'))
                            {
                                int intLoopCustomFitStack = objArmor.TotalOverrideArmor;
                                (int intI, int intJ) = dicArmorStackingValues[objInnerArmor];
                                if (objArmor.Encumbrance)
                                    dicArmorStackingValues[objInnerArmor]
                                        = new Tuple<int, int>(intI + intLoopCustomFitStack,
                                                              intJ + intLoopCustomFitStack);
                                else
                                    dicArmorStackingValues[objInnerArmor] = new Tuple<int, int>(intI + intLoopCustomFitStack, intJ);
                            }
                        }

                        if (objArmor.Encumbrance)
                            intNakedEncumbranceValue += intLoopStack;
                    }

                    // Run through list of Armor again to cap off any whose stacking bonuses are greater than STR
                    if (!Settings.UncappedArmorAccessoryBonuses)
                    {
                        foreach (Armor objArmor in lstArmorsToConsider)
                        {
                            if (dicArmorStackingValues.TryGetValue(objArmor, out var tupStack)
                                && tupStack.Item1 > intAverageStrength)
                                dicArmorStackingValues[objArmor]
                                    = new Tuple<int, int>(intAverageStrength, tupStack.Item2);
                        }
                    }

                    Armor objHighestArmor = null;
                    int intHighest = 0;
                    int intLowestEncumbrance = int.MaxValue;
                    // Run through the list of Armor a third time to retrieve the highest total Armor rating.
                    foreach (Armor objArmor in lstArmorsToConsider)
                    {
                        if (objArmor.ArmorValue.StartsWith('+')
                            || objArmor.ArmorValue.StartsWith('-'))
                            continue;
                        (int intLoopStack, int intLoopEncumbrance) = dicArmorStackingValues[objArmor];
                        int intLoopTotal = objArmor.TotalArmor + intLoopStack;
                        if (intLoopTotal >= intHighest && (intLoopTotal > intHighest || intLoopEncumbrance < intLowestEncumbrance))
                        {
                            intHighest = intLoopTotal;
                            intLowestEncumbrance = intLoopEncumbrance;
                            objHighestArmor = objArmor;
                        }
                    }

                    if (objHighestArmor == null)
                        intLowestEncumbrance = intNakedEncumbranceValue;

                    // calculate armor encumbrance
                    if (intLowestEncumbrance > intAverageStrength + 1)
                        return (intAverageStrength - intLowestEncumbrance) / 2; // a negative number is expected
                    return 0;
                }
            }
        }

        /// <summary>
        /// Armor Encumbrance modifier from Armor.
        /// </summary>
        public async ValueTask<int> GetArmorEncumbranceAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (Settings.NoArmorEncumbrance)
                    return 0;
                List<Armor> lstArmorsToConsider = await Armor.ToListAsync(objArmor => objArmor.Equipped, token: token).ConfigureAwait(false);
                if (lstArmorsToConsider.Count == 0 || lstArmorsToConsider.All(objArmor => !objArmor.Encumbrance))
                    return 0;
                CharacterAttrib objStrength = await GetAttributeAsync("STR", token: token).ConfigureAwait(false);
                int intAverageStrength = objStrength != null ? await objStrength.GetTotalValueAsync(token).ConfigureAwait(false) : 0;
                // Run through the list of Armor currently worn and look at armors that start with '+' since they stack with the highest Armor, but only up to STR.
                Dictionary<Armor, Tuple<int, int>> dicArmorStackingValues
                    = lstArmorsToConsider.ToDictionary(x => x, y => new Tuple<int, int>(0, 0));
                int intNakedEncumbranceValue = 0;
                foreach (Armor objArmor in lstArmorsToConsider)
                {
                    if (!objArmor.ArmorValue.StartsWith('+')
                        && !objArmor.ArmorValue.StartsWith('-')
                        && !objArmor.ArmorOverrideValue.StartsWith('+')
                        && !objArmor.ArmorOverrideValue.StartsWith('-'))
                        continue;
                    string strCustomFitName = string.Empty;
                    foreach (ArmorMod objMod in objArmor.ArmorMods)
                    {
                        if (objMod.Name == "Custom Fit (Stack)" && objMod.Equipped)
                        {
                            strCustomFitName = objMod.Extra;
                            break;
                        }
                    }

                    int intLoopStack = objArmor.ArmorValue.StartsWith('+') || objArmor.ArmorValue.StartsWith('-')
                        ? objArmor.TotalArmor
                        : 0;
                    foreach (Armor objInnerArmor in lstArmorsToConsider)
                    {
                        if (objInnerArmor == objArmor
                            || objInnerArmor.ArmorValue.StartsWith('+')
                            || objInnerArmor.ArmorValue.StartsWith('-'))
                            continue;
                        if (string.IsNullOrEmpty(strCustomFitName) || strCustomFitName != objInnerArmor.Name)
                        {
                            (int intI, int intJ) = dicArmorStackingValues[objInnerArmor];
                            if (objArmor.Encumbrance)
                                dicArmorStackingValues[objInnerArmor]
                                    = new Tuple<int, int>(intI + intLoopStack, intJ + intLoopStack);
                            else
                                dicArmorStackingValues[objInnerArmor]
                                    = new Tuple<int, int>(intI + intLoopStack, intJ);
                        }
                        else if (objArmor.ArmorOverrideValue.StartsWith('+')
                                 || objArmor.ArmorOverrideValue.StartsWith('-'))
                        {
                            int intLoopCustomFitStack = objArmor.TotalOverrideArmor;
                            (int intI, int intJ) = dicArmorStackingValues[objInnerArmor];
                            if (objArmor.Encumbrance)
                                dicArmorStackingValues[objInnerArmor]
                                    = new Tuple<int, int>(intI + intLoopCustomFitStack,
                                                          intJ + intLoopCustomFitStack);
                            else
                                dicArmorStackingValues[objInnerArmor]
                                    = new Tuple<int, int>(intI + intLoopCustomFitStack, intJ);
                        }
                    }

                    if (objArmor.Encumbrance)
                        intNakedEncumbranceValue += intLoopStack;
                }

                // Run through list of Armor again to cap off any whose stacking bonuses are greater than STR
                if (!Settings.UncappedArmorAccessoryBonuses)
                {
                    foreach (Armor objArmor in lstArmorsToConsider)
                    {
                        if (dicArmorStackingValues.TryGetValue(objArmor, out var tupStack)
                            && tupStack.Item1 > intAverageStrength)
                            dicArmorStackingValues[objArmor]
                                = new Tuple<int, int>(intAverageStrength, tupStack.Item2);
                    }
                }

                Armor objHighestArmor = null;
                int intHighest = 0;
                int intLowestEncumbrance = int.MaxValue;
                // Run through the list of Armor a third time to retrieve the highest total Armor rating.
                foreach (Armor objArmor in lstArmorsToConsider)
                {
                    if (objArmor.ArmorValue.StartsWith('+')
                        || objArmor.ArmorValue.StartsWith('-'))
                        continue;
                    (int intLoopStack, int intLoopEncumbrance) = dicArmorStackingValues[objArmor];
                    int intLoopTotal = objArmor.TotalArmor + intLoopStack;
                    if (intLoopTotal >= intHighest
                        && (intLoopTotal > intHighest || intLoopEncumbrance < intLowestEncumbrance))
                    {
                        intHighest = intLoopTotal;
                        intLowestEncumbrance = intLoopEncumbrance;
                        objHighestArmor = objArmor;
                    }
                }

                if (objHighestArmor == null)
                    intLowestEncumbrance = intNakedEncumbranceValue;

                // calculate armor encumbrance
                if (intLowestEncumbrance > intAverageStrength + 1)
                    return (intAverageStrength - intLowestEncumbrance) / 2; // a negative number is expected
                return 0;
            }
        }

        #endregion Armor Properties

        #region Spell Defense

        public int SpellDefenseIllusionMana
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return LOG.TotalValue + WIL.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.ManaIllusionResist))
                                          .StandardRound();
            }
        }

        public string DisplaySpellDefenseIllusionMana
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseIllusionMana.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseIllusionMana.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseIllusionMana + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseIllusionManaToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(LOG.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(LOG.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                    if (CurrentCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                  .Append('(').Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');

                    int intModifiers = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                        + ImprovementManager.ValueOf(
                                            this, Improvement.ImprovementType.ManaIllusionResist))
                        .StandardRound();

                    if (intModifiers != 0)
                    {
                        FormatImprovementModifiers(
                            sbdToolTip,
                            new[]
                            {
                                Improvement.ImprovementType.SpellResistance,
                                Improvement.ImprovementType.ManaIllusionResist
                            },
                            strSpace,
                            intModifiers);
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public int SpellDefenseIllusionPhysical
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return LOG.TotalValue + INT.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.PhysicalIllusionResist))
                                          .StandardRound();
            }
        }

        public string DisplaySpellDefenseIllusionPhysical
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseIllusionPhysical.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseIllusionPhysical.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseIllusionPhysical + CurrentCounterspellingDice).ToString(
                              GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseIllusionPhysicalToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(LOG.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(LOG.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(INT.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(INT.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                    if (CurrentCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                  .Append('(').Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');

                    int intModifiers = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                        + ImprovementManager.ValueOf(
                                            this, Improvement.ImprovementType.PhysicalIllusionResist)).StandardRound();

                    if (intModifiers != 0)
                    {
                        FormatImprovementModifiers(
                            sbdToolTip,
                            new[]
                            {
                                Improvement.ImprovementType.SpellResistance,
                                Improvement.ImprovementType.PhysicalIllusionResist
                            },
                            strSpace,
                            intModifiers);
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public int SpellDefenseManipulationMental
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return LOG.TotalValue + WIL.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.MentalManipulationResist))
                                          .StandardRound();
            }
        }

        public string DisplaySpellDefenseManipulationMental
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseManipulationMental.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseManipulationMental.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseManipulationMental + CurrentCounterspellingDice).ToString(
                              GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseManipulationMentalToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(LOG.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(LOG.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                    if (CurrentCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                  .Append('(').Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');

                    int intModifiers = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                        + ImprovementManager.ValueOf(
                                            this, Improvement.ImprovementType.MentalManipulationResist))
                        .StandardRound();

                    if (intModifiers != 0)
                    {
                        FormatImprovementModifiers(
                            sbdToolTip,
                            new[]
                            {
                                Improvement.ImprovementType.SpellResistance,
                                Improvement.ImprovementType.MentalManipulationResist
                            },
                            strSpace,
                            intModifiers);
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public int SpellDefenseManipulationPhysical
        {
            get
            {
                int intAttributes = 0;
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        if (HomeNode is Vehicle objVehicle)
                            intAttributes = objVehicle.TotalBody * 2;
                    }
                    else
                        intAttributes = BOD.TotalValue + STR.TotalValue;

                    return intAttributes +
                           (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance) +
                            ImprovementManager.ValueOf(this, Improvement.ImprovementType.PhysicalManipulationResist))
                           .StandardRound();
                }
            }
        }

        public string DisplaySpellDefenseManipulationPhysical
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseManipulationPhysical.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseManipulationPhysical.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseManipulationPhysical + CurrentCounterspellingDice).ToString(
                              GlobalSettings.CultureInfo) + ')';
            }
        }

        public string SpellDefenseManipulationPhysicalToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                {
                    int intBody;
                    int intStrength;
                    string strBodyAbbrev;
                    string strStrengthAbbrev;
                    if (IsAI)
                    {
                        intBody = intStrength = (HomeNode is Vehicle objVehicle ? objVehicle.TotalBody : 0);
                        strBodyAbbrev = strStrengthAbbrev = LanguageManager.GetString("String_VehicleBody");
                    }
                    else
                    {
                        intBody = BOD.TotalValue;
                        intStrength = STR.TotalValue;
                        strBodyAbbrev = BOD.DisplayAbbrev;
                        strStrengthAbbrev = STR.DisplayAbbrev;
                    }

                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append(strBodyAbbrev).Append(strSpace).Append('(')
                                  .Append(intBody.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                                  .Append('+').Append(strSpace).Append(strStrengthAbbrev).Append(strSpace).Append('(')
                                  .Append(intStrength.ToString(GlobalSettings.CultureInfo)).Append(')');

                        if (CurrentCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                      .Append('(')
                                      .Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance) +
                               ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.PhysicalManipulationResist))
                            .StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                new[]
                                {
                                    Improvement.ImprovementType.SpellResistance,
                                    Improvement.ImprovementType.PhysicalManipulationResist
                                },
                                strSpace,
                                intModifiers);
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        #endregion Spell Defense

        /// <summary>
        /// Custom Drugs created by the character.
        /// </summary>
        public ThreadSafeObservableCollection<Drug> Drugs
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstDrugs;
            }
        }

        /// <summary>
        /// Custom Drugs created by the character.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<Drug>> GetDrugsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _lstDrugs;
        }

        #region Condition Monitors

        /// <summary>
        /// Number of Physical Condition Monitor boxes.
        /// </summary>
        public int PhysicalCM
        {
            get
            {
                int intCMPhysical = 8;
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        if (HomeNode is Vehicle objVehicle)
                        {
                            return objVehicle.PhysicalCM;
                        }

                        if (DEP != null)
                            // A.I.s use Core Condition Monitors instead of Physical Condition Monitors if they are not in a vehicle or drone.
                            intCMPhysical += (DEP.TotalValue + 1) / 2;
                    }
                    else
                    {
                        if (BOD != null)
                            intCMPhysical += (BOD.TotalValue + 1) / 2;
                    }

                    // Include Improvements in the Condition Monitor values.
                    intCMPhysical += ImprovementManager.ValueOf(this, Improvement.ImprovementType.PhysicalCM)
                                                       .StandardRound();
                }

                return intCMPhysical;
            }
        }

        /// <summary>
        /// Number of Physical Condition Monitor boxes.
        /// </summary>
        public async ValueTask<int> GetPhysicalCMAsync(CancellationToken token = default)
        {
            int intCMPhysical = 8;
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    if (HomeNode is Vehicle objVehicle)
                    {
                        return objVehicle.PhysicalCM;
                    }

                    CharacterAttrib objDepth = await GetAttributeAsync("BOD", token: token).ConfigureAwait(false);
                    if (objDepth != null)
                        // A.I.s use Core Condition Monitors instead of Physical Condition Monitors if they are not in a vehicle or drone.
                        intCMPhysical += (await objDepth.GetTotalValueAsync(token).ConfigureAwait(false) + 1) / 2;
                }
                else
                {
                    CharacterAttrib objBody = await GetAttributeAsync("BOD", token: token).ConfigureAwait(false);
                    if (objBody != null)
                        intCMPhysical += (await objBody.GetTotalValueAsync(token).ConfigureAwait(false) + 1) / 2;
                }

                // Include Improvements in the Condition Monitor values.
                intCMPhysical += (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.PhysicalCM, token: token).ConfigureAwait(false))
                                                   .StandardRound();
            }

            return intCMPhysical;
        }

        public string PhysicalCMLabelText
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return IsAI
                        ? LanguageManager.GetString(HomeNode is Vehicle ? "Label_OtherPhysicalCM" : "Label_OtherCoreCM")
                        : LanguageManager.GetString("Label_OtherPhysicalCM");
            }
        }

        public string PhysicalCMToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                string strModifiers = LanguageManager.GetString("Tip_Modifiers");
                string strCM;
                using (EnterReadLock.Enter(LockObject))
                {
                    int intBonus;
                    if (IsAI)
                    {
                        if (HomeNode is Vehicle objVehicleHomeNode)
                        {
                            strCM = objVehicleHomeNode.BasePhysicalBoxes.ToString(GlobalSettings.CultureInfo) + strSpace
                                +
                                '+' + strSpace + '(' + BOD.DisplayAbbrev + '' + 2.ToString(GlobalSettings.CultureInfo)
                                +
                                ')' + strSpace + '(' +
                                ((objVehicleHomeNode.TotalBody + 1) / 2).ToString(GlobalSettings.CultureInfo) + ')';

                            intBonus = objVehicleHomeNode.Mods.Sum(objMod => objMod.ConditionMonitor);
                            if (intBonus != 0)
                                strCM += strSpace + '+' + strSpace + strModifiers + strSpace + '('
                                         + intBonus.ToString(GlobalSettings.CultureInfo) + ')';
                        }
                        else
                        {
                            strCM = 8.ToString(GlobalSettings.CultureInfo) + strSpace + '+' + strSpace + '(' +
                                    DEP.DisplayAbbrev + '' + 2.ToString(GlobalSettings.CultureInfo) + ')' + strSpace
                                    + '(' +
                                    ((DEP.TotalValue + 1) / 2).ToString(GlobalSettings.CultureInfo) + ')';

                            intBonus = ImprovementManager.ValueOf(this, Improvement.ImprovementType.PhysicalCM)
                                                         .StandardRound();
                            if (intBonus != 0)
                                strCM += strSpace + '+' + strSpace + strModifiers + strSpace + '('
                                         + intBonus.ToString(GlobalSettings.CultureInfo) + ')';
                        }
                    }
                    else
                    {
                        strCM = 8.ToString(GlobalSettings.CultureInfo) + strSpace + '+' + strSpace + '(' +
                                BOD.DisplayAbbrev + '' + 2.ToString(GlobalSettings.CultureInfo) + ')' + strSpace + '('
                                +
                                ((BOD.TotalValue + 1) / 2).ToString(GlobalSettings.CultureInfo) + ')';

                        intBonus = ImprovementManager.ValueOf(this, Improvement.ImprovementType.PhysicalCM)
                                                     .StandardRound();
                        if (intBonus != 0)
                            strCM += strSpace + '+' + strSpace + strModifiers + strSpace + '('
                                     + intBonus.ToString(GlobalSettings.CultureInfo) + ')';
                    }
                }

                return strCM;
            }
        }

        /// <summary>
        /// Number of Stun Condition Monitor boxes.
        /// </summary>
        public int StunCM
        {
            get
            {
                int intCMStun = 0;
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        // A.I. do not have a Stun Condition Monitor, but they do have a Matrix Condition Monitor if they are in their home node.
                        if (HomeNode != null)
                        {
                            intCMStun = HomeNode.MatrixCM;
                        }
                    }
                    else
                    {
                        intCMStun = 8 + (WIL.TotalValue + 1) / 2;
                        // Include Improvements in the Condition Monitor values.
                        intCMStun += ImprovementManager.ValueOf(this, Improvement.ImprovementType.StunCM)
                                                       .StandardRound();
                    }
                }

                return intCMStun;
            }
        }

        /// <summary>
        /// Number of Stun Condition Monitor boxes.
        /// </summary>
        public async ValueTask<int> GetStunCMAsync(CancellationToken token = default)
        {
            int intCMStun = 0;
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    // A.I. do not have a Stun Condition Monitor, but they do have a Matrix Condition Monitor if they are in their home node.
                    if (HomeNode != null)
                    {
                        intCMStun = HomeNode.MatrixCM;
                    }
                }
                else
                {
                    intCMStun = 8;
                    CharacterAttrib objWillpower = await GetAttributeAsync("WIL", token: token).ConfigureAwait(false);
                    if (objWillpower != null)
                        intCMStun += (await objWillpower.GetTotalValueAsync(token).ConfigureAwait(false) + 1) / 2;
                    // Include Improvements in the Condition Monitor values.
                    intCMStun += (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.StunCM, token: token).ConfigureAwait(false))
                                                   .StandardRound();
                }
            }

            return intCMStun;
        }

        public bool StunCMVisible
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return !IsAI || HomeNode != null;
            }
        }

        public string StunCMLabelText
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        return HomeNode == null ? string.Empty : LanguageManager.GetString("Label_OtherMatrixCM");
                    }

                    return LanguageManager.GetString("Label_OtherStunCM");
                }
            }
        }

        public string StunCMToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                string strModifiers = LanguageManager.GetString("Tip_Modifiers");
                string strCM;
                using (EnterReadLock.Enter(LockObject))
                {
                    int intBonus;
                    if (IsAI)
                    {
                        if (HomeNode == null)
                            return string.Empty;
                        strCM = 8.ToString(GlobalSettings.CultureInfo) + strSpace + '+' + strSpace + '(' +
                                LanguageManager.GetString("String_DeviceRating") + '' +
                                2.ToString(GlobalSettings.CultureInfo) + ')' + strSpace + '(' +
                                ((HomeNode.GetTotalMatrixAttribute("Device Rating") + 1) / 2).ToString(GlobalSettings
                                    .CultureInfo) + ')';

                        intBonus = HomeNode.TotalBonusMatrixBoxes;
                        if (intBonus != 0)
                            strCM += strSpace + '+' + strSpace + strModifiers + strSpace + '(' +
                                     intBonus.ToString(GlobalSettings.CultureInfo) + ')';
                    }
                    else
                    {
                        strCM = 8.ToString(GlobalSettings.CultureInfo) + strSpace + '+' + strSpace + '(' +
                                WIL.DisplayAbbrev + '' + 2.ToString(GlobalSettings.CultureInfo) + ')' + strSpace + '('
                                +
                                ((WIL.TotalValue + 1) / 2).ToString(GlobalSettings.CultureInfo) + ')';

                        intBonus = ImprovementManager.ValueOf(this, Improvement.ImprovementType.StunCM).StandardRound();
                        if (intBonus != 0)
                            strCM += strSpace + '+' + strSpace + strModifiers + strSpace + '(' +
                                     intBonus.ToString(GlobalSettings.CultureInfo) + ')';
                    }
                }

                return strCM;
            }
        }

        /// <summary>
        /// Number of Condition Monitor boxes are needed to reach a Condition Monitor Threshold.
        /// </summary>
        public int CMThreshold
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    int intCMThreshold = 3 + ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMThreshold)
                                                               .StandardRound();
                    return intCMThreshold;
                }
            }
        }

        /// <summary>
        /// Number of Condition Monitor boxes are needed to reach a Condition Monitor Threshold.
        /// </summary>
        public async ValueTask<int> GetCMThresholdAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                int intCMThreshold = 3 + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.CMThreshold, token: token).ConfigureAwait(false))
                                                           .StandardRound();
                return intCMThreshold;
            }
        }

        /// <summary>
        /// Returns PhysicalCMThresholdOffset and StunCMThresholdOffset as a pair.
        /// </summary>
        public Tuple<int, int> CMThresholdOffsets
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return new Tuple<int, int>(PhysicalCMThresholdOffset, StunCMThresholdOffset);
            }
        }

        /// <summary>
        /// Returns PhysicalCMThresholdOffset and StunCMThresholdOffset as a pair.
        /// </summary>
        public async ValueTask<Tuple<int, int>> GetCMThresholdOffsetsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return new Tuple<int, int>(await GetPhysicalCMThresholdOffsetAsync(token).ConfigureAwait(false), await GetStunCMThresholdOffsetAsync(token).ConfigureAwait(false));
        }

        /// <summary>
        /// Number of additional boxes appear before the first Physical Condition Monitor penalty.
        /// </summary>
        public int PhysicalCMThresholdOffset
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (ImprovementManager
                        .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.IgnoreCMPenaltyPhysical)
                        .Count
                        > 0)
                        return int.MaxValue;
                    if (IsAI || ImprovementManager
                                .GetCachedImprovementListForValueOf(
                                    this, Improvement.ImprovementType.IgnoreCMPenaltyStun)
                                .Count > 0)
                        return (ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMThresholdOffset) +
                                ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMSharedThresholdOffset))
                            .StandardRound();

                    decimal decCMThresholdOffset =
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMThresholdOffset);
                    // We're subtracting CM Threshold from the amount of CM boxes filled because you only need to ignore wounds up to your first wound threshold, not all wounds
                    decimal decCMSharedThresholdOffset = decCMThresholdOffset +
                                                         ImprovementManager.ValueOf(this,
                                                             Improvement.ImprovementType.CMSharedThresholdOffset) -
                                                         Math.Max(StunCMFilled - CMThreshold - decCMThresholdOffset, 0);
                    return Math.Max(decCMThresholdOffset, decCMSharedThresholdOffset).StandardRound();
                }
            }
        }

        /// <summary>
        /// Number of additional boxes appear before the first Physical Condition Monitor penalty.
        /// </summary>
        public async ValueTask<int> GetPhysicalCMThresholdOffsetAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if ((await ImprovementManager
                           .GetCachedImprovementListForValueOfAsync(this, Improvement.ImprovementType.IgnoreCMPenaltyPhysical, token: token).ConfigureAwait(false))
                    .Count
                    > 0)
                    return int.MaxValue;
                if (await GetIsAIAsync(token).ConfigureAwait(false) || (await ImprovementManager
                                                                              .GetCachedImprovementListForValueOfAsync(
                                                                                  this, Improvement.ImprovementType.IgnoreCMPenaltyStun, token: token).ConfigureAwait(false))
                            .Count > 0)
                    return (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.CMThresholdOffset, token: token).ConfigureAwait(false) +
                            await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.CMSharedThresholdOffset, token: token).ConfigureAwait(false))
                        .StandardRound();

                decimal decCMThresholdOffset =
                    await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.CMThresholdOffset, token: token).ConfigureAwait(false);
                // We're subtracting CM Threshold from the amount of CM boxes filled because you only need to ignore wounds up to your first wound threshold, not all wounds
                decimal decCMSharedThresholdOffset = decCMThresholdOffset +
                                                     await ImprovementManager.ValueOfAsync(this,
                                                         Improvement.ImprovementType.CMSharedThresholdOffset, token: token).ConfigureAwait(false) -
                                                     Math.Max(StunCMFilled - await GetCMThresholdAsync(token).ConfigureAwait(false) - decCMThresholdOffset, 0);
                return Math.Max(decCMThresholdOffset, decCMSharedThresholdOffset).StandardRound();
            }
        }

        /// <summary>
        /// Number of additional boxes appear before the first Stun Condition Monitor penalty.
        /// </summary>
        public int StunCMThresholdOffset
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    // A.I.s don't get wound penalties from Matrix damage
                    if (IsAI)
                        return int.MaxValue;
                    if (ImprovementManager
                        .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.IgnoreCMPenaltyStun)
                        .Count > 0)
                        return int.MaxValue;
                    if (ImprovementManager
                        .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.IgnoreCMPenaltyPhysical)
                        .Count
                        > 0)
                        return (ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMThresholdOffset) +
                                ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMSharedThresholdOffset))
                            .StandardRound();

                    decimal decCMThresholdOffset =
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMThresholdOffset);
                    // We're subtracting CM Threshold from the amount of CM boxes filled because you only need to ignore wounds up to your first wound threshold, not all wounds
                    decimal decCMSharedThresholdOffset = decCMThresholdOffset +
                                                         ImprovementManager.ValueOf(this,
                                                             Improvement.ImprovementType.CMSharedThresholdOffset) -
                                                         Math.Max(PhysicalCMFilled - CMThreshold - decCMThresholdOffset,
                                                                  0);
                    return Math.Max(decCMThresholdOffset, decCMSharedThresholdOffset).StandardRound();
                }
            }
        }

        /// <summary>
        /// Number of additional boxes appear before the first Stun Condition Monitor penalty.
        /// </summary>
        public async ValueTask<int> GetStunCMThresholdOffsetAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                // A.I.s don't get wound penalties from Matrix damage
                if (await GetIsAIAsync(token).ConfigureAwait(false))
                    return int.MaxValue;
                if ((await ImprovementManager
                           .GetCachedImprovementListForValueOfAsync(this, Improvement.ImprovementType.IgnoreCMPenaltyStun, token: token).ConfigureAwait(false))
                    .Count > 0)
                    return int.MaxValue;
                if ((await ImprovementManager
                           .GetCachedImprovementListForValueOfAsync(this, Improvement.ImprovementType.IgnoreCMPenaltyPhysical, token: token).ConfigureAwait(false))
                    .Count
                    > 0)
                    return (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.CMThresholdOffset, token: token).ConfigureAwait(false) +
                            await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.CMSharedThresholdOffset, token: token).ConfigureAwait(false))
                        .StandardRound();

                decimal decCMThresholdOffset =
                    await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.CMThresholdOffset, token: token).ConfigureAwait(false);
                // We're subtracting CM Threshold from the amount of CM boxes filled because you only need to ignore wounds up to your first wound threshold, not all wounds
                decimal decCMSharedThresholdOffset = decCMThresholdOffset +
                                                     await ImprovementManager.ValueOfAsync(this,
                                                         Improvement.ImprovementType.CMSharedThresholdOffset, token: token).ConfigureAwait(false) -
                                                     Math.Max(PhysicalCMFilled - await GetCMThresholdAsync(token).ConfigureAwait(false) - decCMThresholdOffset,
                                                              0);
                return Math.Max(decCMThresholdOffset, decCMSharedThresholdOffset).StandardRound();
            }
        }

        /// <summary>
        /// Number of Overflow Condition Monitor boxes.
        /// </summary>
        public int CMOverflow
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    int intCMOverflow = 0;
                    // A.I. do not have an Overflow Condition Monitor.
                    if (!IsAI)
                    {
                        // Characters get a number of overflow boxes equal to their BOD (plus any Improvements). One more boxes is added to mark the character as dead.
                        intCMOverflow = BOD.TotalValue +
                                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMOverflow)
                                                          .StandardRound() + 1;
                    }

                    return intCMOverflow;
                }
            }
        }

        /// <summary>
        /// Number of Overflow Condition Monitor boxes.
        /// </summary>
        public async ValueTask<int> GetCMOverflowAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                int intCMOverflow = 0;
                // A.I. do not have an Overflow Condition Monitor.
                if (!await GetIsAIAsync(token).ConfigureAwait(false))
                {
                    // Characters get a number of overflow boxes equal to their BOD (plus any Improvements). One more boxes is added to mark the character as dead.
                    intCMOverflow = await (await GetAttributeAsync("BOD", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false) +
                                    (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.CMOverflow, token: token).ConfigureAwait(false))
                                                      .StandardRound() + 1;
                }

                return intCMOverflow;
            }
        }

        #endregion Condition Monitors

        #region Build Properties

        /// <summary>
        /// Method being used to build the character.
        /// </summary>
        public CharacterBuildMethod EffectiveBuildMethod
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return IsCritter ? CharacterBuildMethod.Karma : Settings.BuildMethod;
            }
        }

        public bool EffectiveBuildMethodUsesPriorityTables
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return EffectiveBuildMethod.UsesPriorityTables();
            }
        }

        public async ValueTask<bool> GetEffectiveBuildMethodUsesPriorityTablesAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return EffectiveBuildMethod.UsesPriorityTables();
        }

        public bool EffectiveBuildMethodIsLifeModule
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return EffectiveBuildMethod == CharacterBuildMethod.LifeModule;
            }
        }

        public async ValueTask<bool> GetEffectiveBuildMethodIsLifeModuleAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return EffectiveBuildMethod == CharacterBuildMethod.LifeModule;
        }

        public bool EnableAutomaticStoryButton
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return EffectiveBuildMethodIsLifeModule && Settings.AutomaticBackstory;
            }
        }

        /// <summary>
        /// Amount of Nuyen the character has.
        /// </summary>
        public decimal Nuyen
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _decNuyen;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_decNuyen == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _decNuyen = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Amount of Nuyen the character has.
        /// </summary>
        public async ValueTask<decimal> GetNuyenAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _decNuyen;
        }

        /// <summary>
        /// Amount of Nuyen the character has.
        /// </summary>
        public async ValueTask SetNuyenAsync(decimal value, CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (_decNuyen == value)
                    return;
                IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    _decNuyen = value;
                    OnPropertyChanged(nameof(Nuyen));
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
        }

        public decimal StolenNuyen
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _decStolenNuyen;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_decStolenNuyen == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _decStolenNuyen = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        public async ValueTask<decimal> GetStolenNuyenAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _decStolenNuyen;
        }

        public async ValueTask SetStolenNuyenAsync(decimal value, CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (_decStolenNuyen == value)
                    return;
                IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    _decStolenNuyen = value;
                    OnPropertyChanged(nameof(StolenNuyen));
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
        }

        public string DisplayNuyen
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return Nuyen.ToString(Settings.NuyenFormat, GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol");
            }
        }

        public string DisplayStolenNuyen
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return StolenNuyen.ToString(Settings.NuyenFormat, GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol");
            }
        }

        /// <summary>
        /// Amount of Nuyen the character started with via the priority system.
        /// </summary>
        public decimal StartingNuyen
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _decStartingNuyen;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_decStartingNuyen == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _decStartingNuyen = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        public async ValueTask<decimal> GetStartingNuyenAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _decStartingNuyen;
        }

        private decimal _decCachedTotalStartingNuyen = decimal.MinValue;

        public decimal TotalStartingNuyen
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    decimal decReturn = _decCachedTotalStartingNuyen;
                    if (decReturn != decimal.MinValue)
                        return decReturn;
                    decimal decFromKarma
                        = CalculateStartingNuyenFromKarma(Math.Min(NuyenBP, TotalNuyenMaximumBP), StartingNuyen);
                    return _decCachedTotalStartingNuyen = decFromKarma +
                                                          ImprovementManager.ValueOf(
                                                              this, Improvement.ImprovementType.Nuyen) -
                                                          ImprovementManager.ValueOf(
                                                              this, Improvement.ImprovementType.Nuyen,
                                                              strImprovedName: "Stolen");
                }
            }
        }

        public async ValueTask<decimal> GetTotalStartingNuyenAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                decimal decReturn = _decCachedTotalStartingNuyen;
                if (decReturn != decimal.MinValue)
                    return decReturn;
                decimal decFromKarma
                    = await CalculateStartingNuyenFromKarmaAsync(
                        Math.Min(await GetNuyenBPAsync(token).ConfigureAwait(false), await GetTotalNuyenMaximumBPAsync(token).ConfigureAwait(false)),
                        await GetStartingNuyenAsync(token).ConfigureAwait(false), token).ConfigureAwait(false);
                return _decCachedTotalStartingNuyen = decFromKarma +
                                               await ImprovementManager.ValueOfAsync(
                                                   this, Improvement.ImprovementType.Nuyen, token: token).ConfigureAwait(false) -
                                               await ImprovementManager.ValueOfAsync(
                                                   this, Improvement.ImprovementType.Nuyen,
                                                   strImprovedName: "Stolen", token: token).ConfigureAwait(false);
            }
        }

        private decimal CalculateStartingNuyenFromKarma(decimal decKarma, decimal decStartingNuyen)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                decimal decFromKarma = 0.0m;
                string strExpression = Settings.ChargenKarmaToNuyenExpression
                                               .Replace("{Karma}",
                                                        decKarma.ToString(GlobalSettings.InvariantCultureInfo))
                                               .Replace("{PriorityNuyen}",
                                                        decStartingNuyen.ToString(GlobalSettings.InvariantCultureInfo));
                if (strExpression.IndexOfAny('{', '+', '-', '*', ',') != -1 || strExpression.Contains("div"))
                {
                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdValue))
                    {
                        sbdValue.Append(strExpression);
                        AttributeSection.ProcessAttributesInXPath(sbdValue, strExpression);

                        // This is first converted to a decimal and rounded up since some items have a multiplier that is not a whole number, such as 2.5.
                        (bool blnIsSuccess, object objProcess) =
                            CommonFunctions.EvaluateInvariantXPath(sbdValue.ToString());
                        if (blnIsSuccess)
                            decFromKarma = Convert.ToDecimal((double)objProcess);
                    }
                }
                else
                    decimal.TryParse(strExpression, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                     out decFromKarma);

                return decFromKarma;
            }
        }

        private async ValueTask<decimal> CalculateStartingNuyenFromKarmaAsync(decimal decKarma, decimal decStartingNuyen, CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                decimal decFromKarma = 0.0m;
                string strExpression = (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetChargenKarmaToNuyenExpressionAsync(token).ConfigureAwait(false))
                                       .Replace("{Karma}",
                                                decKarma.ToString(GlobalSettings.InvariantCultureInfo))
                                       .Replace("{PriorityNuyen}",
                                                decStartingNuyen.ToString(GlobalSettings.InvariantCultureInfo));
                if (strExpression.IndexOfAny('{', '+', '-', '*', ',') != -1 || strExpression.Contains("div"))
                {
                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdValue))
                    {
                        sbdValue.Append(strExpression);
                        await (await GetAttributeSectionAsync(token).ConfigureAwait(false)).ProcessAttributesInXPathAsync(sbdValue, strExpression, token: token).ConfigureAwait(false);

                        // This is first converted to a decimal and rounded up since some items have a multiplier that is not a whole number, such as 2.5.
                        (bool blnIsSuccess, object objProcess)
                            = await CommonFunctions.EvaluateInvariantXPathAsync(sbdValue.ToString(), token).ConfigureAwait(false);
                        if (blnIsSuccess)
                            decFromKarma = Convert.ToDecimal((double)objProcess);
                    }
                }
                else
                    decimal.TryParse(strExpression, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                     out decFromKarma);

                return decFromKarma;
            }
        }

        public string DisplayTotalStartingNuyen
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return '=' + LanguageManager.GetString("String_Space") +
                           TotalStartingNuyen.ToString(Settings.NuyenFormat, GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol");
            }
        }

        /// <summary>
        /// Number of Build Points put into Nuyen.
        /// </summary>
        public decimal NuyenBP
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _decNuyenBP;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    value = Math.Max(Math.Min(value, TotalNuyenMaximumBP), 0);
                    if (_decNuyenBP == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _decNuyenBP = value;
                    }
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Number of Build Points put into Nuyen.
        /// </summary>
        public async ValueTask<decimal> GetNuyenBPAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _decNuyenBP;
        }

        public decimal TotalNuyenMaximumBP
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    const decimal decMaxValue = int.MaxValue;
                    // If UnrestrictedNuyen is enabled, return the maximum possible value
                    if (IgnoreRules || Settings.UnrestrictedNuyen)
                    {
                        return decMaxValue;
                    }

                    return Math.Max(Math.Min(decMaxValue,
                                             Settings.NuyenMaximumBP
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.NuyenMaxBP)), 0);
                }
            }
        }

        /// <summary>
        /// Number of Build Points put into Nuyen.
        /// </summary>
        public async ValueTask<decimal> GetTotalNuyenMaximumBPAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                const decimal decMaxValue = int.MaxValue;
                // If UnrestrictedNuyen is enabled, return the maximum possible value
                if (await GetIgnoreRulesAsync(token).ConfigureAwait(false))
                {
                    return decMaxValue;
                }

                CharacterSettings objSettings = await GetSettingsAsync(token).ConfigureAwait(false);
                if (await objSettings.GetUnrestrictedNuyenAsync(token).ConfigureAwait(false))
                {
                    return decMaxValue;
                }

                return Math.Max(Math.Min(decMaxValue,
                                         await objSettings.GetNuyenMaximumBPAsync(token).ConfigureAwait(false)
                                         + await ImprovementManager.ValueOfAsync(
                                             this, Improvement.ImprovementType.NuyenMaxBP, token: token).ConfigureAwait(false)), 0);
            }
        }

        /// <summary>
        /// The calculated Astral Limit.
        /// </summary>
        public int LimitAstral
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return Math.Max(LimitMental, LimitSocial);
            }
        }

        public string LimitAstralToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                    return string.Concat(LanguageManager.GetString("Label_Options_Maximum"),
                                         strSpace, "(", LanguageManager.GetString("String_LimitMentalShort"),
                                         strSpace, "[", LimitMental.ToString(GlobalSettings.CultureInfo), "],",
                                         strSpace, LanguageManager.GetString("String_LimitSocialShort"),
                                         strSpace, "[", LimitSocial.ToString(GlobalSettings.CultureInfo), "])");
            }
        }

        /// <summary>
        /// The calculated Physical Limit.
        /// </summary>
        public int LimitPhysical
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        Vehicle objHomeNodeVehicle = HomeNode as Vehicle;
                        return objHomeNodeVehicle?.Handling ?? 0;
                    }

                    int intLimit = (STR.TotalValue * 2 + BOD.TotalValue + REA.TotalValue + 2) / 3;
                    return intLimit + ImprovementManager.ValueOf(this, Improvement.ImprovementType.PhysicalLimit)
                                                        .StandardRound();
                }
            }
        }

        public string LimitPhysicalToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        Vehicle objHomeNodeVehicle = HomeNode as Vehicle;
                        return string.Concat(LanguageManager.GetString("String_Handling"),
                                             strSpace, "[",
                                             (objHomeNodeVehicle?.Handling ?? 0).ToString(GlobalSettings.CultureInfo),
                                             "]");
                    }

                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append('(').Append(STR.DisplayAbbrev).Append(strSpace).Append('[')
                                  .Append(STR.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(']')
                                  .Append(strSpace)
                                  .Append('').Append(strSpace).Append(2.ToString(GlobalSettings.CultureInfo))
                                  .Append(strSpace).Append('+').Append(strSpace).Append(BOD.DisplayAbbrev)
                                  .Append(strSpace)
                                  .Append('[').Append(BOD.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(']')
                                  .Append(strSpace).Append('+').Append(strSpace).Append(REA.DisplayAbbrev)
                                  .Append(strSpace)
                                  .Append('[').Append(REA.TotalValue.ToString(GlobalSettings.CultureInfo)).Append("])")
                                  .Append(strSpace).Append('/').Append(strSpace)
                                  .Append(3.ToString(GlobalSettings.CultureInfo));
                        foreach (Improvement objLoopImprovement in
                                 ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.PhysicalLimit))
                        {
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                      .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        /// <summary>
        /// The calculated Mental Limit.
        /// </summary>
        public int LimitMental
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    int intLimit = (LOG.TotalValue * 2 + INT.TotalValue + WIL.TotalValue + 2) / 3;
                    if (IsAI && HomeNode != null)
                    {
                        if (HomeNode is Vehicle objHomeNodeVehicle)
                        {
                            int intHomeNodeSensor = objHomeNodeVehicle.CalculatedSensor;
                            if (intHomeNodeSensor > intLimit)
                            {
                                intLimit = intHomeNodeSensor;
                            }
                        }

                        int intHomeNodeDP = HomeNode.GetTotalMatrixAttribute("Data Processing");
                        if (intHomeNodeDP > intLimit)
                        {
                            intLimit = intHomeNodeDP;
                        }
                    }

                    return intLimit + ImprovementManager.ValueOf(this, Improvement.ImprovementType.MentalLimit)
                                                        .StandardRound();
                }
            }
        }

        public string LimitMentalToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                {
                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append('(').Append(LOG.DisplayAbbrev).Append(strSpace).Append('[')
                                  .Append(LOG.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(']')
                                  .Append(strSpace)
                                  .Append('').Append(strSpace).Append(2.ToString(GlobalSettings.CultureInfo))
                                  .Append(strSpace).Append('+').Append(strSpace).Append(INT.DisplayAbbrev)
                                  .Append(strSpace)
                                  .Append('[').Append(INT.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(']')
                                  .Append(strSpace).Append('+').Append(strSpace).Append(WIL.DisplayAbbrev)
                                  .Append(strSpace)
                                  .Append('[').Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append("])")
                                  .Append(strSpace).Append('/').Append(strSpace)
                                  .Append(3.ToString(GlobalSettings.CultureInfo));

                        if (IsAI && HomeNode != null)
                        {
                            int intLimit = (LOG.TotalValue * 2 + INT.TotalValue + WIL.TotalValue + 2) / 3;
                            if (HomeNode is Vehicle objHomeNodeVehicle)
                            {
                                int intHomeNodeSensor = objHomeNodeVehicle.CalculatedSensor;
                                if (intHomeNodeSensor > intLimit)
                                {
                                    intLimit = intHomeNodeSensor;
                                    sbdToolTip.Clear();
                                    sbdToolTip.Append(LanguageManager.GetString("String_Sensor")).Append(strSpace)
                                              .Append('[').Append(intLimit.ToString(GlobalSettings.CultureInfo))
                                              .Append(']');
                                }
                            }

                            int intHomeNodeDP = HomeNode.GetTotalMatrixAttribute("Data Processing");
                            if (intHomeNodeDP > intLimit)
                            {
                                intLimit = intHomeNodeDP;
                                sbdToolTip.Clear();
                                sbdToolTip.Append(LanguageManager.GetString("String_DataProcessing")).Append(strSpace)
                                          .Append('[').Append(intLimit.ToString(GlobalSettings.CultureInfo))
                                          .Append(']');
                            }
                        }

                        foreach (Improvement objLoopImprovement in
                                 ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.MentalLimit))
                        {
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                      .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        /// <summary>
        /// The calculated Social Limit.
        /// </summary>
        public int LimitSocial
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    int intLimit;
                    if (IsAI && HomeNode != null)
                    {
                        int intHomeNodeDP = HomeNode.GetTotalMatrixAttribute("Data Processing");

                        if (HomeNode is Vehicle objHomeNodeVehicle)
                        {
                            int intHomeNodePilot = objHomeNodeVehicle.Pilot;
                            if (intHomeNodePilot > intHomeNodeDP)
                                intHomeNodeDP = intHomeNodePilot;
                        }

                        intLimit = (CHA.TotalValue + intHomeNodeDP + WIL.TotalValue + Essence().StandardRound() + 2)
                                   / 3;
                    }
                    else
                    {
                        intLimit = (CHA.TotalValue * 2 + WIL.TotalValue + Essence().StandardRound() + 2) / 3;
                    }

                    return intLimit + ImprovementManager.ValueOf(this, Improvement.ImprovementType.SocialLimit)
                                                        .StandardRound();
                }
            }
        }

        public string LimitSocialToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                {
                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append('(').Append(CHA.DisplayAbbrev).Append(strSpace).Append('[')
                                  .Append(CHA.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(']');
                        if (IsAI && HomeNode != null)
                        {
                            int intHomeNodeDP = HomeNode.GetTotalMatrixAttribute("Data Processing");
                            string strDPString = LanguageManager.GetString("String_DataProcessing");
                            if (HomeNode is Vehicle objHomeNodeVehicle)
                            {
                                int intHomeNodePilot = objHomeNodeVehicle.Pilot;
                                if (intHomeNodePilot > intHomeNodeDP)
                                {
                                    intHomeNodeDP = intHomeNodePilot;
                                    strDPString = LanguageManager.GetString("String_Pilot");
                                }
                            }

                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace).Append(strDPString)
                                      .Append(strSpace)
                                      .Append('[').Append(intHomeNodeDP.ToString(GlobalSettings.CultureInfo))
                                      .Append(']');
                        }
                        else
                        {
                            sbdToolTip.Append(strSpace).Append('').Append(strSpace)
                                      .Append(2.ToString(GlobalSettings.CultureInfo));
                        }

                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace).Append(WIL.DisplayAbbrev)
                                  .Append(strSpace)
                                  .Append('[').Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(']')
                                  .Append(strSpace).Append('+').Append(strSpace).Append(ESS.DisplayAbbrev)
                                  .Append(strSpace)
                                  .Append('[').Append(DisplayEssence).Append("])").Append(strSpace).Append('/')
                                  .Append(strSpace)
                                  .Append(3.ToString(GlobalSettings.CultureInfo));

                        foreach (Improvement objLoopImprovement in
                                 ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.SocialLimit))
                        {
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                      .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        public bool HasMentorSpirit
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return MentorSpirits.Count > 0;
            }
        }

        public string FirstMentorSpiritDisplayName
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return MentorSpirits.Count > 0
                        ? MentorSpirits[0].CurrentDisplayNameShort
                        : string.Empty;
            }
        }

        public string FirstMentorSpiritDisplayInformation
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (MentorSpirits.Count == 0)
                        return string.Empty;

                    MentorSpirit objMentorSpirit = MentorSpirits[0];
                    string strSpace = LanguageManager.GetString("String_Space");
                    return (LanguageManager.GetString("Label_SelectMentorSpirit_Advantage") + strSpace
                        + objMentorSpirit.DisplayAdvantage(GlobalSettings.Language)
                        + Environment.NewLine + Environment.NewLine
                        + LanguageManager.GetString("Label_SelectMetamagic_Disadvantage") + strSpace
                        + objMentorSpirit.DisplayDisadvantage(GlobalSettings.Language)).WordWrap();
                }
            }
        }

        #endregion Build Properties

        #region Metatype/Metavariant Information

        /// <summary>
        /// Character's Metatype.
        /// </summary>
        public string Metatype
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strMetatype;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _strMetatype, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Metatype.
        /// </summary>
        public async ValueTask<string> GetMetatypeAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _strMetatype;
        }

        public Guid MetatypeGuid
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _guiMetatype;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_guiMetatype == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _guiMetatype = value;
                    }
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// The name of the metatype as it should appear on printouts (translated name only).
        /// </summary>
        public string DisplayMetatype(string strLanguage)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (strLanguage.Equals(GlobalSettings.DefaultLanguage, StringComparison.OrdinalIgnoreCase))
                    return Metatype;

                return GetNodeXPath(true, strLanguage)?.SelectSingleNodeAndCacheExpression("translate")?.Value
                       ?? Metatype;
            }
        }

        /// <summary>
        /// The name of the metatype as it should appear on printouts (translated name only).
        /// </summary>
        public async ValueTask<string> DisplayMetatypeAsync(string strLanguage, CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (strLanguage.Equals(GlobalSettings.DefaultLanguage, StringComparison.OrdinalIgnoreCase))
                    return Metatype;

                XPathNavigator objNode = await GetNodeXPathAsync(true, strLanguage, token).ConfigureAwait(false);
                return objNode != null
                    ? (await objNode.SelectSingleNodeAndCacheExpressionAsync("translate", token: token).ConfigureAwait(false))
                    ?.Value ?? Metatype
                    : Metatype;
            }
        }

        /// <summary>
        /// Character's Metavariant.
        /// </summary>
        public string Metavariant
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strMetavariant;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _strMetavariant, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Metavariant.
        /// </summary>
        public async ValueTask<string> GetMetavariantAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _strMetavariant;
        }

        public Guid MetavariantGuid
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _guiMetavariant;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_guiMetavariant == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _guiMetavariant = value;
                    }
                    OnPropertyChanged();
                }
            }
        }

        public async ValueTask<Guid> GetMetavariantGuidAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _guiMetavariant;
        }

        /// <summary>
        /// The name of the metatype as it should appear on printouts (translated name only).
        /// </summary>
        public string DisplayMetavariant(string strLanguage)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (strLanguage.Equals(GlobalSettings.DefaultLanguage, StringComparison.OrdinalIgnoreCase))
                    return Metavariant;

                return GetNodeXPath(false, strLanguage)?.SelectSingleNodeAndCacheExpression("translate")?.Value
                       ?? Metavariant;
            }
        }

        /// <summary>
        /// The name of the metatype as it should appear on printouts (translated name only).
        /// </summary>
        public async ValueTask<string> DisplayMetavariantAsync(string strLanguage, CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (strLanguage.Equals(GlobalSettings.DefaultLanguage, StringComparison.OrdinalIgnoreCase))
                    return Metavariant;

                XPathNavigator objNode = await GetNodeXPathAsync(false, strLanguage, token).ConfigureAwait(false);
                return objNode != null
                    ? (await objNode.SelectSingleNodeAndCacheExpressionAsync("translate", token: token).ConfigureAwait(false))
                             ?.Value ?? Metavariant
                    : Metavariant;
            }
        }

        public string FormattedMetatype => FormattedMetatypeMethod(GlobalSettings.Language);

        /// <summary>
        /// The metatype, including metavariant if any, in an appropriate language.
        /// </summary>
        /// <param name="strLanguage">Language to be used. Defaults to GlobalSettings.Language</param>
        public string FormattedMetatypeMethod(string strLanguage = "")
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (string.IsNullOrEmpty(strLanguage))
                    strLanguage = GlobalSettings.Language;
                string strMetatype = DisplayMetatype(strLanguage);

                if (MetavariantGuid != Guid.Empty)
                {
                    strMetatype += LanguageManager.GetString("String_Space") + '(' + DisplayMetavariant(strLanguage)
                                   + ')';
                }

                return strMetatype;
            }
        }

        /// <summary>
        /// The metatype, including metavariant if any, in an appropriate language.
        /// </summary>
        /// <param name="strLanguage">Language to be used. Defaults to GlobalSettings.Language</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public async ValueTask<string> FormattedMetatypeMethodAsync(string strLanguage = "", CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (string.IsNullOrEmpty(strLanguage))
                    strLanguage = GlobalSettings.Language;
                string strMetatype = await DisplayMetatypeAsync(strLanguage, token).ConfigureAwait(false);

                if (MetavariantGuid != Guid.Empty)
                {
                    strMetatype += await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false) + '('
                        + await DisplayMetavariantAsync(strLanguage, token).ConfigureAwait(false) + ')';
                }

                return strMetatype;
            }
        }

        /// <summary>
        /// Metatype Category.
        /// </summary>
        public string MetatypeCategory
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strMetatypeCategory;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    string strOldValue = Interlocked.Exchange(ref _strMetatypeCategory, value);
                    if (strOldValue == value)
                        return;
                    OnPropertyChanged();
                    if (strOldValue == "Cyberzombie" || value == "Cyberzombie")
                        RefreshEssenceLossImprovements();
                }
            }
        }

        /// <summary>
        /// Metatype Category.
        /// </summary>
        public async ValueTask<string> GetMetatypeCategoryAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _strMetatypeCategory;
        }

        public int LimbCount(string strLimbSlot = "")
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (string.IsNullOrEmpty(strLimbSlot))
                {
                    return Settings.LimbCount + ImprovementManager.ValueOf(this, Improvement.ImprovementType.AddLimb)
                                                                  .StandardRound();
                }

                int intReturn =
                    1 + ImprovementManager.ValueOf(this, Improvement.ImprovementType.AddLimb, false, strLimbSlot)
                                          .StandardRound();
                if (strLimbSlot == "arm" || strLimbSlot == "leg")
                    ++intReturn;
                return intReturn;
            }
        }

        public async ValueTask<int> LimbCountAsync(string strLimbSlot = "", CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (string.IsNullOrEmpty(strLimbSlot))
                {
                    return Settings.LimbCount + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.AddLimb, token: token).ConfigureAwait(false))
                                                                  .StandardRound();
                }

                int intReturn =
                    1 + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.AddLimb, false, strLimbSlot, token: token).ConfigureAwait(false))
                                          .StandardRound();
                if (strLimbSlot == "arm" || strLimbSlot == "leg")
                    ++intReturn;
                return intReturn;
            }
        }

        public string DisplayMovement
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return GetMovement(GlobalSettings.CultureInfo, GlobalSettings.Language);
            }
        }

        /// <summary>
        /// Character's Movement rate (Culture-dependent).
        /// </summary>
        public string GetMovement(CultureInfo objCulture, string strLanguage)
        {
            using (EnterReadLock.Enter(LockObject))
                // Don't attempt to do anything if the character's Movement is "Special" (typically for A.I.s).
                return Movement == "Special"
                    ? LanguageManager.GetString("String_ModeSpecial", strLanguage)
                    : CalculatedMovement("Ground", true, objCulture, strLanguage);
        }

        /// <summary>
        /// Character's Movement rate (Culture-dependent).
        /// </summary>
        public async ValueTask<string> GetMovementAsync(CultureInfo objCulture, string strLanguage, CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                // Don't attempt to do anything if the character's Movement is "Special" (typically for A.I.s).
                return await GetMovementAsync(token).ConfigureAwait(false) == "Special"
                    ? await LanguageManager.GetStringAsync("String_ModeSpecial", strLanguage, token: token).ConfigureAwait(false)
                    : await CalculatedMovementAsync("Ground", true, objCulture, strLanguage, token).ConfigureAwait(false);
        }

        /// <summary>
        /// Character's Movement rate data string.
        /// </summary>
        public string Movement
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (string.IsNullOrWhiteSpace(_strMovement))
                    {
                        _strMovement = this.GetNodeXPath()?.SelectSingleNodeAndCacheExpression("movement")?.Value
                                       ?? GetNodeXPath(true)?.SelectSingleNodeAndCacheExpression("movement")?.Value
                                       ?? string.Empty;
                    }

                    return _strMovement;
                }
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _strMovement, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Movement rate data string.
        /// </summary>
        public async ValueTask<string> GetMovementAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (string.IsNullOrWhiteSpace(_strMovement))
                {
                    XPathNavigator xmlDataNode = await this.GetNodeXPathAsync(token: token).ConfigureAwait(false);
                    if (xmlDataNode != null)
                        _strMovement
                            = (await xmlDataNode.SelectSingleNodeAndCacheExpressionAsync("movement", token: token).ConfigureAwait(false))?.Value
                              ?? string.Empty;
                    if (xmlDataNode == null || string.IsNullOrEmpty(_strMovement))
                    {
                        xmlDataNode = await GetNodeXPathAsync(true, token: token).ConfigureAwait(false);
                        if (xmlDataNode != null)
                            _strMovement
                                = (await xmlDataNode.SelectSingleNodeAndCacheExpressionAsync("movement", token: token).ConfigureAwait(false))?.Value
                                  ?? string.Empty;
                        else
                            _strMovement = string.Empty;
                    }
                }

                return _strMovement;
            }
        }

        /// <summary>
        /// Character's Run rate data string.
        /// </summary>
        public string RunString
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (string.IsNullOrWhiteSpace(_strRun))
                    {
                        _strRun = this.GetNodeXPath()?.SelectSingleNodeAndCacheExpression("run")?.Value
                                  ?? GetNodeXPath(true)?.SelectSingleNodeAndCacheExpression("run")?.Value
                                  ?? string.Empty;
                    }

                    return _strRun;
                }
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _strRun, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Run rate data string.
        /// </summary>
        public async ValueTask<string> GetRunStringAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (string.IsNullOrWhiteSpace(_strRun))
                {
                    XPathNavigator xmlDataNode = await this.GetNodeXPathAsync(token: token).ConfigureAwait(false);
                    if (xmlDataNode != null)
                        _strRun
                            = (await xmlDataNode.SelectSingleNodeAndCacheExpressionAsync("run", token: token).ConfigureAwait(false))?.Value
                              ?? string.Empty;
                    if (xmlDataNode == null || string.IsNullOrEmpty(_strRun))
                    {
                        xmlDataNode = await GetNodeXPathAsync(true, token: token).ConfigureAwait(false);
                        if (xmlDataNode != null)
                            _strRun
                                = (await xmlDataNode.SelectSingleNodeAndCacheExpressionAsync("run", token: token).ConfigureAwait(false))?.Value
                                  ?? string.Empty;
                        else
                            _strRun = string.Empty;
                    }
                }

                return _strRun;
            }
        }

        /// <summary>
        /// Character's Alternate Run rate data string.
        /// </summary>
        public string RunAltString
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (string.IsNullOrWhiteSpace(_strRunAlt))
                    {
                        _strRunAlt = this.GetNodeXPath()?.SelectSingleNodeAndCacheExpression("run")
                                         ?.GetAttribute("alt", string.Empty)
                                     ?? GetNodeXPath(true)?.SelectSingleNodeAndCacheExpression("run")
                                                          ?.GetAttribute("alt", string.Empty)
                                     ?? string.Empty;
                    }

                    return _strRunAlt;
                }
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _strRunAlt, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Alternate Run rate data string.
        /// </summary>
        public async ValueTask<string> GetRunAltStringAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (string.IsNullOrWhiteSpace(_strRunAlt))
                {
                    XPathNavigator xmlDataNode = await this.GetNodeXPathAsync(token: token).ConfigureAwait(false);
                    if (xmlDataNode != null)
                        _strRunAlt
                            = (await xmlDataNode.SelectSingleNodeAndCacheExpressionAsync("run", token: token).ConfigureAwait(false))?.GetAttribute("alt", string.Empty)
                              ?? string.Empty;
                    if (xmlDataNode == null || string.IsNullOrEmpty(_strRunAlt))
                    {
                        xmlDataNode = await GetNodeXPathAsync(true, token: token).ConfigureAwait(false);
                        if (xmlDataNode != null)
                            _strRunAlt
                                = (await xmlDataNode.SelectSingleNodeAndCacheExpressionAsync("run", token: token).ConfigureAwait(false))?.GetAttribute("alt", string.Empty)
                                  ?? string.Empty;
                        else
                            _strRunAlt = string.Empty;
                    }
                }

                return _strRunAlt;
            }
        }

        /// <summary>
        /// Character's Walk rate data string.
        /// </summary>
        public string WalkString
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (string.IsNullOrWhiteSpace(_strWalk))
                    {
                        _strWalk = this.GetNodeXPath()?.SelectSingleNodeAndCacheExpression("walk")?.Value
                                   ?? GetNodeXPath(true)?.SelectSingleNodeAndCacheExpression("walk")?.Value
                                   ?? string.Empty;
                    }

                    return _strWalk;
                }
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _strWalk, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Walk rate data string.
        /// </summary>
        public async ValueTask<string> GetWalkStringAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (string.IsNullOrWhiteSpace(_strWalk))
                {
                    XPathNavigator xmlDataNode = await this.GetNodeXPathAsync(token: token).ConfigureAwait(false);
                    if (xmlDataNode != null)
                        _strWalk
                            = (await xmlDataNode.SelectSingleNodeAndCacheExpressionAsync("walk", token: token).ConfigureAwait(false))?.Value
                              ?? string.Empty;
                    if (xmlDataNode == null || string.IsNullOrEmpty(_strWalk))
                    {
                        xmlDataNode = await GetNodeXPathAsync(true, token: token).ConfigureAwait(false);
                        if (xmlDataNode != null)
                            _strWalk
                                = (await xmlDataNode.SelectSingleNodeAndCacheExpressionAsync("walk", token: token).ConfigureAwait(false))?.Value
                                  ?? string.Empty;
                        else
                            _strWalk = string.Empty;
                    }
                }

                return _strWalk;
            }
        }

        /// <summary>
        /// Character's Alternate Walk rate data string.
        /// </summary>
        public string WalkAltString
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (string.IsNullOrWhiteSpace(_strWalkAlt))
                    {
                        _strWalkAlt = this.GetNodeXPath()?.SelectSingleNodeAndCacheExpression("walk")
                                          ?.GetAttribute("alt", string.Empty)
                                      ?? GetNodeXPath(true)?.SelectSingleNodeAndCacheExpression("walk")
                                                           ?.GetAttribute("alt", string.Empty)
                                      ?? string.Empty;
                    }

                    return _strWalkAlt;
                }
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _strWalkAlt, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Alternate Walk rate data string.
        /// </summary>
        public async ValueTask<string> GetWalkAltStringAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (string.IsNullOrWhiteSpace(_strWalkAlt))
                {
                    XPathNavigator xmlDataNode = await this.GetNodeXPathAsync(token: token).ConfigureAwait(false);
                    if (xmlDataNode != null)
                        _strWalkAlt
                            = (await xmlDataNode.SelectSingleNodeAndCacheExpressionAsync("walk", token: token).ConfigureAwait(false))?.GetAttribute("alt", string.Empty)
                              ?? string.Empty;
                    if (xmlDataNode == null || string.IsNullOrEmpty(_strWalkAlt))
                    {
                        xmlDataNode = await GetNodeXPathAsync(true, token: token).ConfigureAwait(false);
                        if (xmlDataNode != null)
                            _strWalkAlt
                                = (await xmlDataNode.SelectSingleNodeAndCacheExpressionAsync("walk", token: token).ConfigureAwait(false))?.GetAttribute("alt", string.Empty)
                                  ?? string.Empty;
                        else
                            _strWalkAlt = string.Empty;
                    }
                }

                return _strWalkAlt;
            }
        }

        /// <summary>
        /// Character's Sprint rate data string.
        /// </summary>
        public string SprintString
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (string.IsNullOrWhiteSpace(_strSprint))
                    {
                        _strSprint = this.GetNodeXPath()?.SelectSingleNodeAndCacheExpression("sprint")?.Value
                                     ?? GetNodeXPath(true)?.SelectSingleNodeAndCacheExpression("sprint")?.Value
                                     ?? string.Empty;
                    }

                    return _strSprint;
                }
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _strSprint, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Spring rate data string.
        /// </summary>
        public async ValueTask<string> GetSprintStringAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (string.IsNullOrWhiteSpace(_strSprint))
                {
                    XPathNavigator xmlDataNode = await this.GetNodeXPathAsync(token: token).ConfigureAwait(false);
                    if (xmlDataNode != null)
                        _strSprint
                            = (await xmlDataNode.SelectSingleNodeAndCacheExpressionAsync("sprint", token: token).ConfigureAwait(false))?.Value
                              ?? string.Empty;
                    if (xmlDataNode == null || string.IsNullOrEmpty(_strSprint))
                    {
                        xmlDataNode = await GetNodeXPathAsync(true, token: token).ConfigureAwait(false);
                        if (xmlDataNode != null)
                            _strSprint
                                = (await xmlDataNode.SelectSingleNodeAndCacheExpressionAsync("sprint", token: token).ConfigureAwait(false))?.Value
                                  ?? string.Empty;
                        else
                            _strSprint = string.Empty;
                    }
                }

                return _strSprint;
            }
        }

        /// <summary>
        /// Character's Alternate Sprint rate data string.
        /// </summary>
        public string SprintAltString
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (string.IsNullOrWhiteSpace(_strSprintAlt))
                    {
                        _strSprintAlt = this.GetNodeXPath()?.SelectSingleNodeAndCacheExpression("sprint")
                                            ?.GetAttribute("alt", string.Empty)
                                        ?? GetNodeXPath(true)?.SelectSingleNodeAndCacheExpression("sprint")
                                                             ?.GetAttribute("alt", string.Empty)
                                        ?? string.Empty;
                    }

                    return _strSprintAlt;
                }
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _strSprintAlt, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Character's Alternate Sprint rate data string.
        /// </summary>
        public async ValueTask<string> GetSprintAltStringAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (string.IsNullOrWhiteSpace(_strSprintAlt))
                {
                    XPathNavigator xmlDataNode = await this.GetNodeXPathAsync(token: token).ConfigureAwait(false);
                    if (xmlDataNode != null)
                        _strSprintAlt
                            = (await xmlDataNode.SelectSingleNodeAndCacheExpressionAsync("sprint", token: token).ConfigureAwait(false))?.GetAttribute("alt", string.Empty)
                              ?? string.Empty;
                    if (xmlDataNode == null || string.IsNullOrEmpty(_strSprintAlt))
                    {
                        xmlDataNode = await GetNodeXPathAsync(true, token: token).ConfigureAwait(false);
                        if (xmlDataNode != null)
                            _strSprintAlt
                                = (await xmlDataNode.SelectSingleNodeAndCacheExpressionAsync("sprint", token: token).ConfigureAwait(false))?.GetAttribute("alt", string.Empty)
                                  ?? string.Empty;
                        else
                            _strSprintAlt = string.Empty;
                    }
                }

                return _strSprintAlt;
            }
        }

        public string CurrentWalkingRateString
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AttributeSection.AttributeCategory == CharacterAttrib.AttributeCategory.Standard
                        ? WalkString
                        : WalkAltString;
            }
        }

        public string CurrentRunningRateString
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AttributeSection.AttributeCategory == CharacterAttrib.AttributeCategory.Standard
                        ? RunString
                        : RunAltString;
            }
        }

        public string CurrentSprintingRateString
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AttributeSection.AttributeCategory == CharacterAttrib.AttributeCategory.Standard
                        ? SprintString
                        : SprintAltString;
            }
        }

        public async ValueTask<string> GetCurrentWalkingRateStringAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                return await (await GetAttributeSectionAsync(token).ConfigureAwait(false))
                             .GetAttributeCategoryAsync(token).ConfigureAwait(false)
                       != CharacterAttrib.AttributeCategory.Standard
                    ? await GetWalkAltStringAsync(token).ConfigureAwait(false)
                    : await GetWalkStringAsync(token).ConfigureAwait(false);
            }
        }

        public async ValueTask<string> GetCurrentRunningRateStringAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                return await (await GetAttributeSectionAsync(token).ConfigureAwait(false))
                             .GetAttributeCategoryAsync(token).ConfigureAwait(false)
                       != CharacterAttrib.AttributeCategory.Standard
                    ? await GetRunAltStringAsync(token).ConfigureAwait(false)
                    : await GetRunStringAsync(token).ConfigureAwait(false);
            }
        }

        public async ValueTask<string> GetCurrentSprintingRateStringAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                return await (await GetAttributeSectionAsync(token).ConfigureAwait(false))
                             .GetAttributeCategoryAsync(token).ConfigureAwait(false)
                       != CharacterAttrib.AttributeCategory.Standard
                    ? await GetSprintAltStringAsync(token).ConfigureAwait(false)
                    : await GetSprintStringAsync(token).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Character's running Movement rate.
        /// <param name="strType">Takes one of three parameters: Ground, 2 for Swim, 3 for Fly. Returns 0 if the requested type isn't found.</param>
        /// </summary>
        public decimal WalkingRate(string strType = "Ground")
        {
            using (EnterReadLock.Enter(LockObject))
            {
                decimal decTmp = decimal.MinValue;
                foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                             this, Improvement.ImprovementType.WalkSpeed, strType))
                    decTmp = Math.Max(decTmp, objImprovement.Value);

                if (decTmp != decimal.MinValue)
                    return decTmp;

                int intIndexToGet = 0;
                switch (strType)
                {
                    case "Fly":
                        intIndexToGet = 2;
                        break;

                    case "Swim":
                        intIndexToGet = 1;
                        break;
                }

                string strReturn = CurrentWalkingRateString.SplitNoAlloc('/', StringSplitOptions.RemoveEmptyEntries)
                                                           .ElementAtOrDefault(intIndexToGet);
                if (strReturn != null)
                    decimal.TryParse(strReturn, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                     out decTmp);
                return decTmp;
            }
        }

        /// <summary>
        /// Character's running Movement rate.
        /// <param name="strType">Takes one of three parameters: Ground, 2 for Swim, 3 for Fly. Returns 0 if the requested type isn't found.</param>
        /// </summary>
        public async ValueTask<decimal> WalkingRateAsync(string strType = "Ground", CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                decimal decTmp = decimal.MinValue;
                foreach (Improvement objImprovement in await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                             this, Improvement.ImprovementType.WalkSpeed, strType, token: token).ConfigureAwait(false))
                    decTmp = Math.Max(decTmp, objImprovement.Value);

                if (decTmp != decimal.MinValue)
                    return decTmp;

                int intIndexToGet = 0;
                switch (strType)
                {
                    case "Fly":
                        intIndexToGet = 2;
                        break;

                    case "Swim":
                        intIndexToGet = 1;
                        break;
                }

                string strReturn = (await GetCurrentWalkingRateStringAsync(token).ConfigureAwait(false))
                                   .SplitNoAlloc('/', StringSplitOptions.RemoveEmptyEntries)
                                   .ElementAtOrDefault(intIndexToGet);
                if (strReturn != null)
                    decimal.TryParse(strReturn, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                     out decTmp);
                return decTmp;
            }
        }

        /// <summary>
        /// Character's running Movement rate.
        /// <param name="strType">Takes one of three parameters: Ground, 2 for Swim, 3 for Fly. Returns 0 if the requested type isn't found.</param>
        /// </summary>
        public decimal RunningRate(string strType = "Ground")
        {
            using (EnterReadLock.Enter(LockObject))
            {
                decimal decTmp = decimal.MinValue;
                foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                             this, Improvement.ImprovementType.RunSpeed, strType))
                    decTmp = Math.Max(decTmp, objImprovement.Value);

                if (decTmp != decimal.MinValue)
                    return decTmp;

                int intIndexToGet = 0;
                switch (strType)
                {
                    case "Fly":
                        intIndexToGet = 2;
                        break;

                    case "Swim":
                        intIndexToGet = 1;
                        break;
                }

                string strReturn = CurrentRunningRateString.SplitNoAlloc('/', StringSplitOptions.RemoveEmptyEntries)
                                                           .ElementAtOrDefault(intIndexToGet);
                if (strReturn != null)
                    decimal.TryParse(strReturn, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                     out decTmp);
                return decTmp;
            }
        }

        /// <summary>
        /// Character's running Movement rate.
        /// <param name="strType">Takes one of three parameters: Ground, 2 for Swim, 3 for Fly. Returns 0 if the requested type isn't found.</param>
        /// </summary>
        public async ValueTask<decimal> RunningRateAsync(string strType = "Ground", CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                decimal decTmp = decimal.MinValue;
                foreach (Improvement objImprovement in await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                             this, Improvement.ImprovementType.RunSpeed, strType, token: token).ConfigureAwait(false))
                    decTmp = Math.Max(decTmp, objImprovement.Value);

                if (decTmp != decimal.MinValue)
                    return decTmp;

                int intIndexToGet = 0;
                switch (strType)
                {
                    case "Fly":
                        intIndexToGet = 2;
                        break;

                    case "Swim":
                        intIndexToGet = 1;
                        break;
                }

                string strReturn = (await GetCurrentRunningRateStringAsync(token).ConfigureAwait(false))
                                   .SplitNoAlloc('/', StringSplitOptions.RemoveEmptyEntries)
                                   .ElementAtOrDefault(intIndexToGet);
                if (strReturn != null)
                    decimal.TryParse(strReturn, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                     out decTmp);
                return decTmp;
            }
        }

        /// <summary>
        /// Character's sprinting Movement rate (meters per hit).
        /// <param name="strType">Takes one of three parameters: Ground, 2 for Swim, 3 for Fly. Returns 0 if the requested type isn't found.</param>
        /// </summary>
        public decimal SprintingRate(string strType = "Ground")
        {
            using (EnterReadLock.Enter(LockObject))
            {
                decimal decTmp = decimal.MinValue;
                foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                             this, Improvement.ImprovementType.SprintSpeed, strType))
                    decTmp = Math.Max(decTmp, objImprovement.Value / 100.0m);

                if (decTmp != decimal.MinValue)
                    return decTmp;

                int intIndexToGet = 0;
                switch (strType)
                {
                    case "Fly":
                        intIndexToGet = 2;
                        break;

                    case "Swim":
                        intIndexToGet = 1;
                        break;
                }

                string strReturn = CurrentSprintingRateString.SplitNoAlloc('/', StringSplitOptions.RemoveEmptyEntries)
                                                             .ElementAtOrDefault(intIndexToGet);
                if (strReturn != null)
                    decimal.TryParse(strReturn, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                     out decTmp);
                return decTmp;
            }
        }

        /// <summary>
        /// Character's sprinting Movement rate (meters per hit).
        /// <param name="strType">Takes one of three parameters: Ground, 2 for Swim, 3 for Fly. Returns 0 if the requested type isn't found.</param>
        /// </summary>
        public async ValueTask<decimal> SprintingRateAsync(string strType = "Ground", CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                decimal decTmp = decimal.MinValue;
                foreach (Improvement objImprovement in await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                             this, Improvement.ImprovementType.SprintSpeed, strType, token: token).ConfigureAwait(false))
                    decTmp = Math.Max(decTmp, objImprovement.Value / 100.0m);

                if (decTmp != decimal.MinValue)
                    return decTmp;

                int intIndexToGet = 0;
                switch (strType)
                {
                    case "Fly":
                        intIndexToGet = 2;
                        break;

                    case "Swim":
                        intIndexToGet = 1;
                        break;
                }

                string strReturn = (await GetCurrentSprintingRateStringAsync(token).ConfigureAwait(false))
                                   .SplitNoAlloc('/', StringSplitOptions.RemoveEmptyEntries)
                                   .ElementAtOrDefault(intIndexToGet);
                if (strReturn != null)
                    decimal.TryParse(strReturn, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                     out decTmp);
                return decTmp;
            }
        }

        public string CalculatedMovement(string strMovementType, bool blnUseCyberlegs = false,
            CultureInfo objCulture = null, string strLanguage = "")
        {
            using (EnterReadLock.Enter(LockObject))
            {
                decimal decSprint = SprintingRate(strMovementType) +
                                    ImprovementManager.ValueOf(this, Improvement.ImprovementType.SprintBonus, false,
                                                               strMovementType) / 100.0m;
                decimal decRun = RunningRate(strMovementType) + ImprovementManager.ValueOf(this,
                    Improvement.ImprovementType.RunMultiplier, false, strMovementType);
                decimal decWalk = WalkingRate(strMovementType) + ImprovementManager.ValueOf(this,
                    Improvement.ImprovementType.WalkMultiplier, false, strMovementType);
                // Everything else after this just multiplies values, so zeroes can be checked for here
                if (decWalk == 0 && decRun == 0 && decSprint == 0)
                {
                    return "0";
                }

                decSprint *= 1.0m + ImprovementManager.ValueOf(this, Improvement.ImprovementType.SprintBonusPercent,
                                                               false,
                                                               strMovementType) / 100.0m;
                decRun *= 1.0m + ImprovementManager.ValueOf(this, Improvement.ImprovementType.RunMultiplierPercent,
                                                            false,
                                                            strMovementType) / 100.0m;
                decWalk *= 1.0m + ImprovementManager.ValueOf(this, Improvement.ImprovementType.WalkMultiplierPercent,
                                                             false,
                                                             strMovementType) / 100.0m;

                //Swimming uses all limbs
                bool blnIsSwimming = strMovementType == "Swim";
                int intAGI = AGI.CalculatedTotalValue(!blnIsSwimming);
                if (blnIsSwimming)
                {
                    int intSTR = STR.CalculatedTotalValue();
                    decWalk *= (intAGI + intSTR) * 0.5m;
                    decRun *= (intAGI + intSTR) * 0.5m;
                }
                else
                {
                    if (Settings.CyberlegMovement && blnUseCyberlegs)
                    {
                        int intTempAGI = int.MaxValue;
                        int intLegs = 0;
                        foreach (Cyberware objCyber in Cyberware.Where(objCyber => objCyber.LimbSlot == "leg"))
                        {
                            intLegs += objCyber.LimbSlotCount;
                            intTempAGI = Math.Min(intTempAGI, objCyber.GetAttributeTotalValue("AGI"));
                        }

                        if (intTempAGI != int.MaxValue && intLegs >= 2)
                        {
                            intAGI = intTempAGI;
                        }
                    }
                    decWalk *= intAGI;
                    decRun *= intAGI;
                }

                if (objCulture == null)
                    objCulture = GlobalSettings.CultureInfo;
                string strReturn = string.Empty;
                if (decWalk != 0)
                {
                    if (decRun != 0)
                        strReturn = decWalk.ToString("#,0.##", objCulture) + '/'
                                                                           + decRun.ToString("#,0.##", objCulture);
                    else
                        strReturn = decWalk.ToString("#,0.##", objCulture);
                }
                else if (decRun != 0 || decSprint != 0)
                    strReturn = decRun.ToString("#,0.##", objCulture);

                if (decSprint != 0)
                {
                    if (!string.IsNullOrEmpty(strReturn))
                        strReturn += ';' + LanguageManager.GetString("String_Space", strLanguage);
                    strReturn += decSprint.ToString("#,0.##", objCulture)
                                 + LanguageManager.GetString("String_MetersPerHit", strLanguage);
                }

                return strReturn;
            }
        }

        public async ValueTask<string> CalculatedMovementAsync(string strMovementType, bool blnUseCyberlegs = false,
            CultureInfo objCulture = null, string strLanguage = "", CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                decimal decSprint = await SprintingRateAsync(strMovementType, token).ConfigureAwait(false)
                                    + await ImprovementManager.ValueOfAsync(
                                        this, Improvement.ImprovementType.SprintBonus, false, strMovementType,
                                        token: token).ConfigureAwait(false) / 100.0m;
                decimal decRun = await RunningRateAsync(strMovementType, token).ConfigureAwait(false)
                                 + await ImprovementManager.ValueOfAsync(
                                     this, Improvement.ImprovementType.RunMultiplier, false, strMovementType,
                                     token: token).ConfigureAwait(false);
                decimal decWalk = await WalkingRateAsync(strMovementType, token).ConfigureAwait(false)
                                  + await ImprovementManager.ValueOfAsync(
                                      this, Improvement.ImprovementType.WalkMultiplier, false, strMovementType,
                                      token: token).ConfigureAwait(false);
                // Everything else after this just multiplies values, so zeroes can be checked for here
                if (decWalk == 0 && decRun == 0 && decSprint == 0)
                {
                    return "0";
                }

                decSprint *= 1.0m + await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SprintBonusPercent,
                                                                          false,
                                                                          strMovementType, token: token).ConfigureAwait(false) / 100.0m;
                decRun *= 1.0m + await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.RunMultiplierPercent,
                                                                       false,
                                                                       strMovementType, token: token).ConfigureAwait(false) / 100.0m;
                decWalk *= 1.0m + await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.WalkMultiplierPercent,
                                                                        false,
                                                                        strMovementType, token: token).ConfigureAwait(false) / 100.0m;

                //Swimming uses all limbs
                bool blnIsSwimming = strMovementType == "Swim";
                int intAGI = await (await GetAttributeAsync("AGI", token: token).ConfigureAwait(false)).CalculatedTotalValueAsync(!blnIsSwimming, token).ConfigureAwait(false);
                if (blnIsSwimming)
                {
                    int intSTR = await (await GetAttributeAsync("STR", token: token).ConfigureAwait(false)).CalculatedTotalValueAsync(true, token).ConfigureAwait(false);
                    decWalk *= (intAGI + intSTR) * 0.5m;
                    decRun *= (intAGI + intSTR) * 0.5m;
                }
                else
                {
                    if (blnUseCyberlegs && await (await GetSettingsAsync(token).ConfigureAwait(false)).GetCyberlegMovementAsync(token).ConfigureAwait(false))
                    {
                        int intTempAGI = int.MaxValue;
                        int intLegs = 0;
                        await (await GetCyberwareAsync(token).ConfigureAwait(false)).ForEachAsync(async objCyber =>
                        {
                            if (objCyber.LimbSlot != "leg")
                                return;
                            intLegs += objCyber.LimbSlotCount;
                            intTempAGI = Math.Min(intTempAGI, await objCyber.GetAttributeTotalValueAsync("AGI", token).ConfigureAwait(false));
                        }, token).ConfigureAwait(false);

                        if (intTempAGI != int.MaxValue && intLegs >= 2)
                        {
                            intAGI = intTempAGI;
                        }
                    }
                    decWalk *= intAGI;
                    decRun *= intAGI;
                }

                if (objCulture == null)
                    objCulture = GlobalSettings.CultureInfo;
                string strReturn = string.Empty;
                if (decWalk != 0)
                {
                    if (decRun != 0)
                        strReturn = decWalk.ToString("#,0.##", objCulture) + '/'
                                                                           + decRun.ToString("#,0.##", objCulture);
                    else
                        strReturn = decWalk.ToString("#,0.##", objCulture);
                }
                else if (decRun != 0 || decSprint != 0)
                    strReturn = decRun.ToString("#,0.##", objCulture);

                if (decSprint != 0)
                {
                    if (!string.IsNullOrEmpty(strReturn))
                        strReturn += ';' + await LanguageManager.GetStringAsync("String_Space", strLanguage, token: token).ConfigureAwait(false);
                    strReturn += decSprint.ToString("#,0.##", objCulture)
                                 + await LanguageManager.GetStringAsync("String_MetersPerHit", strLanguage, token: token).ConfigureAwait(false);
                }

                return strReturn;
            }
        }

        public string DisplaySwim
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return GetSwim(GlobalSettings.CultureInfo, GlobalSettings.Language);
            }
        }

        /// <summary>
        /// Character's Swim rate.
        /// </summary>
        public string GetSwim(CultureInfo objCulture, string strLanguage)
        {
            using (EnterReadLock.Enter(LockObject))
                // Don't attempt to do anything if the character's Movement is "Special" (typically for A.I.s).
                return Movement == "Special"
                    ? LanguageManager.GetString("String_ModeSpecial", strLanguage)
                    : CalculatedMovement("Swim", false, objCulture, strLanguage);
        }

        /// <summary>
        /// Character's Swim rate.
        /// </summary>
        public async ValueTask<string> GetSwimAsync(CultureInfo objCulture, string strLanguage, CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                // Don't attempt to do anything if the character's Movement is "Special" (typically for A.I.s).
                return await GetMovementAsync(token).ConfigureAwait(false) == "Special"
                    ? await LanguageManager.GetStringAsync("String_ModeSpecial", strLanguage, token: token).ConfigureAwait(false)
                    : await CalculatedMovementAsync("Swim", false, objCulture, strLanguage, token).ConfigureAwait(false);
        }

        public string DisplayFly
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return GetFly(GlobalSettings.CultureInfo, GlobalSettings.Language);
            }
        }

        /// <summary>
        /// Character's Fly rate.
        /// </summary>
        public string GetFly(CultureInfo objCulture, string strLanguage)
        {
            using (EnterReadLock.Enter(LockObject))
                // Don't attempt to do anything if the character's Movement is "Special" (typically for A.I.s).
                return Movement == "Special"
                    ? LanguageManager.GetString("String_ModeSpecial", strLanguage)
                    : CalculatedMovement("Fly", false, objCulture, strLanguage);
        }

        /// <summary>
        /// Character's Fly rate.
        /// </summary>
        public async ValueTask<string> GetFlyAsync(CultureInfo objCulture, string strLanguage, CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                // Don't attempt to do anything if the character's Movement is "Special" (typically for A.I.s).
                return await GetMovementAsync(token).ConfigureAwait(false) == "Special"
                    ? await LanguageManager.GetStringAsync("String_ModeSpecial", strLanguage, token: token).ConfigureAwait(false)
                    : await CalculatedMovementAsync("Fly", false, objCulture, strLanguage, token).ConfigureAwait(false);
        }

        /// <summary>
        /// Full Movement (Movement, Swim, and Fly) for printouts.
        /// </summary>
        private string FullMovement(CultureInfo objCulture, string strLanguage)
        {
            string strSpace = LanguageManager.GetString("String_Space");
            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdReturn))
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    string strGroundMovement = GetMovement(objCulture, strLanguage);
                    string strSwimMovement = GetSwim(objCulture, strLanguage);
                    string strFlyMovement = GetFly(objCulture, strLanguage);
                    if (!string.IsNullOrEmpty(strGroundMovement) && strGroundMovement != "0")
                        sbdReturn.Append(strGroundMovement).Append(',').Append(strSpace);
                    if (!string.IsNullOrEmpty(strSwimMovement) && strSwimMovement != "0")
                        sbdReturn.Append(LanguageManager.GetString("Label_OtherSwim", strLanguage)).Append(strSpace)
                                 .Append(strSwimMovement).Append(',').Append(strSpace);
                    if (!string.IsNullOrEmpty(strFlyMovement) && strFlyMovement != "0")
                        sbdReturn.Append(LanguageManager.GetString("Label_OtherFly", strLanguage)).Append(strSpace)
                                 .Append(strFlyMovement).Append(',').Append(strSpace);
                }

                // Remove the trailing ", ".
                if (sbdReturn.Length > 0)
                    sbdReturn.Length -= 2;

                return sbdReturn.ToString();
            }
        }

        /// <summary>
        /// Full Movement (Movement, Swim, and Fly) for printouts.
        /// </summary>
        private async ValueTask<string> FullMovementAsync(CultureInfo objCulture, string strLanguage, CancellationToken token = default)
        {
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdReturn))
            {
                using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                {
                    string strGroundMovement = await GetMovementAsync(objCulture, strLanguage, token).ConfigureAwait(false);
                    string strSwimMovement = await GetSwimAsync(objCulture, strLanguage, token).ConfigureAwait(false);
                    string strFlyMovement = await GetFlyAsync(objCulture, strLanguage, token).ConfigureAwait(false);
                    if (!string.IsNullOrEmpty(strGroundMovement) && strGroundMovement != "0")
                        sbdReturn.Append(strGroundMovement).Append(',').Append(strSpace);
                    if (!string.IsNullOrEmpty(strSwimMovement) && strSwimMovement != "0")
                        sbdReturn.Append(await LanguageManager.GetStringAsync("Label_OtherSwim", strLanguage, token: token).ConfigureAwait(false)).Append(strSpace)
                                 .Append(strSwimMovement).Append(',').Append(strSpace);
                    if (!string.IsNullOrEmpty(strFlyMovement) && strFlyMovement != "0")
                        sbdReturn.Append(await LanguageManager.GetStringAsync("Label_OtherFly", strLanguage, token: token).ConfigureAwait(false)).Append(strSpace)
                                 .Append(strFlyMovement).Append(',').Append(strSpace);
                }

                // Remove the trailing ", ".
                if (sbdReturn.Length > 0)
                    sbdReturn.Length -= 2;

                return sbdReturn.ToString();
            }
        }

        /// <summary>
        /// BP cost of character's Metatype.
        /// </summary>
        public int MetatypeBP
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intMetatypeBP;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _intMetatypeBP, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        public async ValueTask<int> GetMetatypeBPAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _intMetatypeBP;
        }

        /// <summary>
        /// MetatypeBP as a string, including Karma string and multiplied by options as relevant.
        /// TODO: Belongs in a viewmodel for frmCreate rather than the main character class?
        /// </summary>
        public string DisplayMetatypeBP
        {
            get
            {
                string s = string.Empty;
                using (EnterReadLock.Enter(LockObject))
                {
                    switch (EffectiveBuildMethod)
                    {
                        case CharacterBuildMethod.Karma:
                        case CharacterBuildMethod.LifeModule:
                            s = (MetatypeBP * Settings.MetatypeCostsKarmaMultiplier).ToString(
                                GlobalSettings.CultureInfo);
                            break;

                        case CharacterBuildMethod.Priority:
                        case CharacterBuildMethod.SumtoTen:
                            s = MetatypeBP.ToString(GlobalSettings.CultureInfo);
                            break;
                    }
                }

                s += LanguageManager.GetString("String_Space") + LanguageManager.GetString("String_Karma");
                return s;
            }
        }

        /// <summary>
        /// Whether or not the character is a non-Free Sprite.
        /// </summary>
        public bool IsSprite
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return MetatypeCategory.EndsWith("Sprites", StringComparison.Ordinal) && !IsFreeSprite;
            }
        }

        /// <summary>
        /// Whether or not the character is a Free Sprite.
        /// </summary>
        public bool IsFreeSprite
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return MetatypeCategory == "Free Sprite";
            }
        }

        /// <summary>
        /// Whether or not the character is a Free Sprite.
        /// </summary>
        public async ValueTask<bool> GetIsFreeSpriteAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return MetatypeCategory == "Free Sprite";
        }

        #endregion Metatype/Metavariant Information

        #region Special Functions and Enabled Check Properties

        /// <summary>
        /// Whether or not Adept options are enabled.
        /// </summary>
        public bool AdeptEnabled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnAdeptEnabled;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnAdeptEnabled == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnAdeptEnabled = value;
                        if (!value)
                            ClearAdeptPowers();

                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Whether or not Adept options are enabled.
        /// </summary>
        public async ValueTask<bool> GetAdeptEnabledAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _blnAdeptEnabled;
        }

        /// <summary>
        /// Whether or not Magician options are enabled.
        /// </summary>
        public bool MagicianEnabled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnMagicianEnabled;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnMagicianEnabled == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnMagicianEnabled = value;
                        if (!value)
                            ClearMagic(AdeptEnabled);

                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Whether or not Magician options are enabled.
        /// </summary>
        public async ValueTask<bool> GetMagicianEnabledAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _blnMagicianEnabled;
        }

        /// <summary>
        /// Whether or not Technomancer options are enabled.
        /// </summary>
        public bool TechnomancerEnabled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnTechnomancerEnabled;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnTechnomancerEnabled == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnTechnomancerEnabled = value;
                        if (!value)
                            ClearResonance();

                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Whether or not Technomancer options are enabled.
        /// </summary>
        public async ValueTask<bool> GetTechnomancerEnabledAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _blnTechnomancerEnabled;
        }

        /// <summary>
        /// Whether or not the Drug Psyche is active
        /// </summary>
        public bool PsycheActive
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnPsycheActive;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnPsycheActive == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnPsycheActive = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Whether or not Advanced Program options are enabled.
        /// </summary>
        public bool AdvancedProgramsEnabled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnAdvancedProgramsEnabled;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnAdvancedProgramsEnabled == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnAdvancedProgramsEnabled = value;
                        if (!value)
                            ClearAdvancedPrograms();

                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Whether or not Cyberware options are disabled.
        /// </summary>
        public bool CyberwareDisabled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnCyberwareDisabled;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnCyberwareDisabled == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnCyberwareDisabled = value;
                        if (value)
                            ClearCyberwareTab();

                        OnPropertyChanged();
                    }
                }
            }
        }

        public bool AddCyberwareEnabled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return !CyberwareDisabled && !IsAI
                                              && ImprovementManager
                                                 .GetCachedImprovementListForValueOf(
                                                     this, Improvement.ImprovementType.DisableCyberware)
                                                 .Count == 0;
            }
        }

        public bool AddBiowareEnabled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return !CyberwareDisabled && !IsAI
                                              && ImprovementManager
                                                 .GetCachedImprovementListForValueOf(
                                                     this, Improvement.ImprovementType.DisableBioware)
                                                 .Count == 0;
            }
        }

        private int _intCachedInitiationEnabled = int.MinValue;

        /// <summary>
        /// Whether or not the Initiation tab should be shown (override for BP mode).
        /// </summary>
        public bool InitiationEnabled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedInitiationEnabled < 0)
                    {
                        _intCachedInitiationEnabled = (!InitiationForceDisabled && (MAGEnabled || RESEnabled)).ToInt32();
                    }

                    return _intCachedInitiationEnabled > 0;
                }
            }
        }

        public bool InitiationForceDisabled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnInitiationDisabled;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnInitiationDisabled == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnInitiationDisabled = value;
                        if (value)
                            ClearInitiations();

                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Whether or not Critter options are enabled.
        /// </summary>
        public bool CritterEnabled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnCritterEnabled;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnCritterEnabled == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnCritterEnabled = value;
                        if (!value)
                            ClearCritterPowers();

                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Whether or not Black Market Discount is enabled.
        /// </summary>
        public bool DealerConnectionDiscount => ImprovementManager
                                                .GetCachedImprovementListForValueOf(
                                                    this, Improvement.ImprovementType.DealerConnection).Count > 0;

        public void RefreshDealerConnectionDiscounts(CancellationToken token = default)
        {
            using (EnterReadLock.Enter(LockObject, token))
            {
                // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
                if (IsLoading)
                    return;

                if (Created)
                    return; // Don't need to refresh properties in Career mode because costs are calculated immediately upon purchasing stuff

                if (DealerConnectionDiscount)
                    return;

                using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                out HashSet<string> setDealerConnectionMaps))
                {
                    foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                 this, Improvement.ImprovementType.DealerConnection, token: token))
                    {
                        token.ThrowIfCancellationRequested();
                        setDealerConnectionMaps.Add(objImprovement.UniqueName);
                    }

                    foreach (Vehicle objVehicle in Vehicles)
                    {
                        token.ThrowIfCancellationRequested();
                        objVehicle.DealerConnectionDiscount = objVehicle.DealerConnectionDiscount
                                                              && Vehicle.DoesDealerConnectionApply(
                                                                  setDealerConnectionMaps, objVehicle.Category);
                    }
                }
            }
        }

        public async ValueTask RefreshDealerConnectionDiscountsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
                if (IsLoading)
                    return;

                if (await GetCreatedAsync(token).ConfigureAwait(false))
                    return; // Don't need to refresh properties in Career mode because costs are calculated immediately upon purchasing stuff

                if (DealerConnectionDiscount)
                    return;

                using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                out HashSet<string> setDealerConnectionMaps))
                {
                    foreach (Improvement objImprovement in await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                 this, Improvement.ImprovementType.DealerConnection, token: token).ConfigureAwait(false))
                    {
                        token.ThrowIfCancellationRequested();
                        setDealerConnectionMaps.Add(objImprovement.UniqueName);
                    }

                    await Vehicles.ForEachAsync(objVehicle =>
                    {
                        objVehicle.DealerConnectionDiscount = objVehicle.DealerConnectionDiscount
                                                              && Vehicle.DoesDealerConnectionApply(
                                                                  setDealerConnectionMaps, objVehicle.Category);
                    }, token).ConfigureAwait(false);
                }
            }
        }

        /// <summary>
        /// Whether or not Black Market Discount is enabled.
        /// </summary>
        public bool BlackMarketDiscount => ImprovementManager
                                           .GetCachedImprovementListForValueOf(
                                               this, Improvement.ImprovementType.BlackMarketDiscount).Count
                                           > 0;

        /// <summary>
        /// Whether or not Black Market Discount is enabled.
        /// </summary>
        public async ValueTask<bool> GetBlackMarketDiscountAsync(CancellationToken token = default)
        {
            return (await ImprovementManager
                          .GetCachedImprovementListForValueOfAsync(
                              this, Improvement.ImprovementType.BlackMarketDiscount, token: token).ConfigureAwait(false)).Count
                   > 0;
        }

        public void RefreshBlackMarketDiscounts(CancellationToken token = default)
        {
            using (EnterReadLock.Enter(LockObject, token))
            {
                // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
                if (IsLoading)
                    return;

                if (Created)
                    return; // Don't need to refresh properties in Career mode because costs are calculated immediately upon purchasing stuff

                if (BlackMarketDiscount)
                {
                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                    out HashSet<string> setArmorBlackMarketMaps))
                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                    out HashSet<string> setArmorModBlackMarketMaps))
                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                    out HashSet<string> setBiowareBlackMarketMaps))
                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                    out HashSet<string> setCyberwareBlackMarketMaps))
                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                    out HashSet<string> setGearBlackMarketMaps))
                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                    out HashSet<string> setVehicleBlackMarketMaps))
                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                    out HashSet<string> setVehicleModBlackMarketMaps))
                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                    out HashSet<string> setWeaponMountBlackMarketMaps))
                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                    out HashSet<string> setWeaponBlackMarketMaps))
                    {
                        setArmorBlackMarketMaps.AddRange(GenerateBlackMarketMappings(LoadDataXPath("armor.xml", token: token)
                                                             .SelectSingleNodeAndCacheExpression("/chummer", token), token));
                        setArmorModBlackMarketMaps.AddRange(GenerateBlackMarketMappings(LoadDataXPath("armor.xml", token: token)
                                                                .SelectSingleNodeAndCacheExpression(
                                                                    "/chummer/modcategories", token), token));
                        setBiowareBlackMarketMaps.AddRange(GenerateBlackMarketMappings(LoadDataXPath("bioware.xml", token: token)
                                                               .SelectSingleNodeAndCacheExpression("/chummer", token), token));
                        setCyberwareBlackMarketMaps.AddRange(GenerateBlackMarketMappings(LoadDataXPath("cyberware.xml", token: token)
                                                                 .SelectSingleNodeAndCacheExpression("/chummer", token), token));
                        setGearBlackMarketMaps.AddRange(GenerateBlackMarketMappings(LoadDataXPath("gear.xml", token: token)
                                                            .SelectSingleNodeAndCacheExpression("/chummer", token), token));
                        setVehicleBlackMarketMaps.AddRange(GenerateBlackMarketMappings(LoadDataXPath("vehicles.xml", token: token)
                                                               .SelectSingleNodeAndCacheExpression("/chummer", token), token));
                        setVehicleModBlackMarketMaps.AddRange(GenerateBlackMarketMappings(LoadDataXPath("vehicles.xml", token: token)
                                                                  .SelectSingleNodeAndCacheExpression(
                                                                      "/chummer/modcategories", token), token));
                        setWeaponMountBlackMarketMaps.AddRange(GenerateBlackMarketMappings(LoadDataXPath("vehicles.xml", token: token)
                                                                   .SelectSingleNodeAndCacheExpression(
                                                                       "/chummer/weaponmountcategories", token), token));
                        setWeaponBlackMarketMaps.AddRange(GenerateBlackMarketMappings(LoadDataXPath("weapons.xml", token: token)
                                                              .SelectSingleNodeAndCacheExpression("/chummer", token), token));

                        foreach (Armor objArmor in Armor)
                        {
                            token.ThrowIfCancellationRequested();
                            objArmor.DiscountCost
                                = objArmor.DiscountCost && setArmorBlackMarketMaps.Contains(objArmor.Category);
                            foreach (ArmorMod objMod in objArmor.ArmorMods)
                            {
                                token.ThrowIfCancellationRequested();
                                objMod.DiscountCost = objMod.DiscountCost
                                                      && setArmorModBlackMarketMaps.Contains(objMod.Category);
                                foreach (Gear objGear in objMod.GearChildren.GetAllDescendants(x => x.Children))
                                {
                                    token.ThrowIfCancellationRequested();
                                    objGear.DiscountCost = objGear.DiscountCost
                                                           && setGearBlackMarketMaps.Contains(objGear.Category);
                                }
                            }

                            foreach (Gear objGear in objArmor.GearChildren.GetAllDescendants(x => x.Children))
                            {
                                token.ThrowIfCancellationRequested();
                                objGear.DiscountCost
                                    = objGear.DiscountCost && setGearBlackMarketMaps.Contains(objGear.Category);
                            }
                        }

                        foreach (Cyberware objCyberware in Cyberware.GetAllDescendants(x => x.Children))
                        {
                            token.ThrowIfCancellationRequested();
                            if (objCyberware.DiscountCost)
                            {
                                objCyberware.DiscountCost
                                    = (objCyberware.SourceType == Improvement.ImprovementSource.Bioware
                                        ? setBiowareBlackMarketMaps
                                        : setCyberwareBlackMarketMaps).Contains(objCyberware.Category);
                            }

                            foreach (Gear objGear in objCyberware.GearChildren.GetAllDescendants(x => x.Children))
                            {
                                token.ThrowIfCancellationRequested();
                                objGear.DiscountCost
                                    = objGear.DiscountCost && setGearBlackMarketMaps.Contains(objGear.Category);
                            }
                        }

                        foreach (Gear objGear in Gear.GetAllDescendants(x => x.Children))
                        {
                            token.ThrowIfCancellationRequested();
                            objGear.DiscountCost
                                = objGear.DiscountCost && setGearBlackMarketMaps.Contains(objGear.Category);
                        }

                        foreach (Vehicle objVehicle in Vehicles)
                        {
                            token.ThrowIfCancellationRequested();
                            objVehicle.DiscountCost = objVehicle.DiscountCost
                                                      && setVehicleBlackMarketMaps.Contains(objVehicle.Category);
                            foreach (Gear objGear in objVehicle.GearChildren.GetAllDescendants(x => x.Children))
                            {
                                token.ThrowIfCancellationRequested();
                                objGear.DiscountCost
                                    = objGear.DiscountCost && setGearBlackMarketMaps.Contains(objGear.Category);
                            }

                            foreach (VehicleMod objMod in objVehicle.Mods)
                            {
                                token.ThrowIfCancellationRequested();
                                objMod.DiscountCost = objMod.DiscountCost
                                                      && setVehicleModBlackMarketMaps.Contains(objMod.Category);
                                foreach (Cyberware objCyberware in objMod.Cyberware.GetAllDescendants(
                                             x => x.Children))
                                {
                                    token.ThrowIfCancellationRequested();
                                    if (objCyberware.DiscountCost)
                                    {
                                        objCyberware.DiscountCost
                                            = (objCyberware.SourceType == Improvement.ImprovementSource.Bioware
                                                ? setBiowareBlackMarketMaps
                                                : setCyberwareBlackMarketMaps).Contains(objCyberware.Category);
                                    }

                                    foreach (Gear objGear in objCyberware.GearChildren.GetAllDescendants(
                                                 x => x.Children))
                                    {
                                        token.ThrowIfCancellationRequested();
                                        objGear.DiscountCost = objGear.DiscountCost
                                                               && setGearBlackMarketMaps.Contains(objGear.Category);
                                    }
                                }
                            }

                            foreach (Weapon objWeapon in objVehicle.Weapons.GetAllDescendants(x => x.Children))
                            {
                                token.ThrowIfCancellationRequested();
                                objWeapon.DiscountCost = objWeapon.DiscountCost
                                                         && setWeaponBlackMarketMaps.Contains(objWeapon.Category);
                                foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                                {
                                    token.ThrowIfCancellationRequested();
                                    objAccessory.DiscountCost = objAccessory.DiscountCost
                                                                && setWeaponBlackMarketMaps
                                                                    .Contains(objWeapon.Category);
                                    foreach (Gear objGear in objAccessory.GearChildren.GetAllDescendants(
                                                 x => x.Children))
                                    {
                                        token.ThrowIfCancellationRequested();
                                        objGear.DiscountCost = objGear.DiscountCost
                                                               && setGearBlackMarketMaps.Contains(objGear.Category);
                                    }
                                }
                            }

                            foreach (WeaponMount objMount in objVehicle.WeaponMounts)
                            {
                                token.ThrowIfCancellationRequested();
                                objMount.DiscountCost = objMount.DiscountCost
                                                        && setWeaponMountBlackMarketMaps
                                                            .Contains(objMount.Category);
                                foreach (VehicleMod objMod in objMount.Mods)
                                {
                                    token.ThrowIfCancellationRequested();
                                    objMod.DiscountCost = objMod.DiscountCost
                                                          && setVehicleModBlackMarketMaps.Contains(objMod.Category);
                                    foreach (Cyberware objCyberware in objMod.Cyberware.GetAllDescendants(
                                                 x => x.Children))
                                    {
                                        token.ThrowIfCancellationRequested();
                                        if (objCyberware.DiscountCost)
                                        {
                                            objCyberware.DiscountCost
                                                = (objCyberware.SourceType == Improvement.ImprovementSource.Bioware
                                                    ? setBiowareBlackMarketMaps
                                                    : setCyberwareBlackMarketMaps).Contains(objCyberware.Category);
                                        }

                                        foreach (Gear objGear in objCyberware.GearChildren.GetAllDescendants(
                                                     x => x.Children))
                                        {
                                            token.ThrowIfCancellationRequested();
                                            objGear.DiscountCost = objGear.DiscountCost
                                                                   && setGearBlackMarketMaps.Contains(
                                                                       objGear.Category);
                                        }
                                    }
                                }

                                foreach (Weapon objWeapon in objMount.Weapons.GetAllDescendants(x => x.Children))
                                {
                                    token.ThrowIfCancellationRequested();
                                    objWeapon.DiscountCost = objWeapon.DiscountCost
                                                             && setWeaponBlackMarketMaps.Contains(
                                                                 objWeapon.Category);
                                    foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                                    {
                                        token.ThrowIfCancellationRequested();
                                        objAccessory.DiscountCost = objAccessory.DiscountCost
                                                                    && setWeaponBlackMarketMaps
                                                                        .Contains(objWeapon.Category);
                                        foreach (Gear objGear in objAccessory.GearChildren.GetAllDescendants(
                                                     x => x.Children))
                                        {
                                            token.ThrowIfCancellationRequested();
                                            objGear.DiscountCost = objGear.DiscountCost
                                                                   && setGearBlackMarketMaps.Contains(
                                                                       objGear.Category);
                                        }
                                    }
                                }
                            }
                        }

                        foreach (Weapon objWeapon in Weapons.GetAllDescendants(x => x.Children))
                        {
                            token.ThrowIfCancellationRequested();
                            objWeapon.DiscountCost = objWeapon.DiscountCost
                                                     && setWeaponBlackMarketMaps.Contains(objWeapon.Category);
                            foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                            {
                                token.ThrowIfCancellationRequested();
                                objAccessory.DiscountCost = objAccessory.DiscountCost
                                                            && setWeaponBlackMarketMaps
                                                                .Contains(objWeapon.Category);
                                foreach (Gear objGear in objAccessory.GearChildren.GetAllDescendants(
                                             x => x.Children))
                                {
                                    token.ThrowIfCancellationRequested();
                                    objGear.DiscountCost = objGear.DiscountCost
                                                           && setGearBlackMarketMaps.Contains(objGear.Category);
                                }
                            }
                        }
                    }
                }
                else
                {
                    // Forcefully disable all Black Market Discounts that don't apply.
                    foreach (Armor objArmor in Armor)
                    {
                        token.ThrowIfCancellationRequested();
                        objArmor.DiscountCost = false;
                        foreach (ArmorMod objMod in objArmor.ArmorMods)
                        {
                            token.ThrowIfCancellationRequested();
                            objMod.DiscountCost = false;
                            foreach (Gear objGear in objMod.GearChildren.GetAllDescendants(x => x.Children))
                            {
                                token.ThrowIfCancellationRequested();
                                objGear.DiscountCost = false;
                            }
                        }

                        foreach (Gear objGear in objArmor.GearChildren.GetAllDescendants(x => x.Children))
                        {
                            token.ThrowIfCancellationRequested();
                            objGear.DiscountCost = false;
                        }
                    }

                    foreach (Cyberware objCyberware in Cyberware.GetAllDescendants(x => x.Children))
                    {
                        token.ThrowIfCancellationRequested();
                        objCyberware.DiscountCost = false;
                        foreach (Gear objGear in objCyberware.GearChildren.GetAllDescendants(x => x.Children))
                        {
                            token.ThrowIfCancellationRequested();
                            objGear.DiscountCost = false;
                        }
                    }

                    foreach (Gear objGear in Gear.GetAllDescendants(x => x.Children))
                    {
                        token.ThrowIfCancellationRequested();
                        objGear.DiscountCost = false;
                    }

                    foreach (Vehicle objVehicle in Vehicles)
                    {
                        token.ThrowIfCancellationRequested();
                        objVehicle.DiscountCost = false;
                        foreach (Gear objGear in objVehicle.GearChildren.GetAllDescendants(x => x.Children))
                        {
                            token.ThrowIfCancellationRequested();
                            objGear.DiscountCost = false;
                        }

                        foreach (VehicleMod objMod in objVehicle.Mods)
                        {
                            token.ThrowIfCancellationRequested();
                            objMod.DiscountCost = false;
                            foreach (Cyberware objCyberware in objMod.Cyberware.GetAllDescendants(x => x.Children))
                            {
                                token.ThrowIfCancellationRequested();
                                objCyberware.DiscountCost = false;
                                foreach (Gear objGear in objCyberware.GearChildren.GetAllDescendants(
                                             x => x.Children))
                                {
                                    token.ThrowIfCancellationRequested();
                                    objGear.DiscountCost = false;
                                }
                            }
                        }

                        foreach (Weapon objWeapon in objVehicle.Weapons.GetAllDescendants(x => x.Children))
                        {
                            token.ThrowIfCancellationRequested();
                            objWeapon.DiscountCost = false;
                            foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                            {
                                token.ThrowIfCancellationRequested();
                                objAccessory.DiscountCost = false;
                                foreach (Gear objGear in objAccessory.GearChildren.GetAllDescendants(
                                             x => x.Children))
                                {
                                    token.ThrowIfCancellationRequested();
                                    objGear.DiscountCost = false;
                                }
                            }
                        }

                        foreach (WeaponMount objMount in objVehicle.WeaponMounts)
                        {
                            token.ThrowIfCancellationRequested();
                            objMount.DiscountCost = false;
                            foreach (VehicleMod objMod in objMount.Mods)
                            {
                                token.ThrowIfCancellationRequested();
                                objMod.DiscountCost = false;
                                foreach (Cyberware objCyberware in objMod.Cyberware.GetAllDescendants(
                                             x => x.Children))
                                {
                                    token.ThrowIfCancellationRequested();
                                    objCyberware.DiscountCost = false;
                                    foreach (Gear objGear in objCyberware.GearChildren.GetAllDescendants(
                                                 x => x.Children))
                                    {
                                        token.ThrowIfCancellationRequested();
                                        objGear.DiscountCost = false;
                                    }
                                }
                            }

                            foreach (Weapon objWeapon in objMount.Weapons.GetAllDescendants(x => x.Children))
                            {
                                token.ThrowIfCancellationRequested();
                                objWeapon.DiscountCost = false;
                                foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                                {
                                    token.ThrowIfCancellationRequested();
                                    objAccessory.DiscountCost = false;
                                    foreach (Gear objGear in objAccessory.GearChildren.GetAllDescendants(
                                                 x => x.Children))
                                    {
                                        token.ThrowIfCancellationRequested();
                                        objGear.DiscountCost = false;
                                    }
                                }
                            }
                        }
                    }

                    foreach (Weapon objWeapon in Weapons.GetAllDescendants(x => x.Children))
                    {
                        token.ThrowIfCancellationRequested();
                        objWeapon.DiscountCost = false;
                        foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                        {
                            token.ThrowIfCancellationRequested();
                            objAccessory.DiscountCost = false;
                            foreach (Gear objGear in objAccessory.GearChildren.GetAllDescendants(x => x.Children))
                            {
                                token.ThrowIfCancellationRequested();
                                objGear.DiscountCost = false;
                            }
                        }
                    }
                }
            }
        }

        public async ValueTask RefreshBlackMarketDiscountsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
                if (IsLoading)
                    return;

                if (await GetCreatedAsync(token).ConfigureAwait(false))
                    return; // Don't need to refresh properties in Career mode because costs are calculated immediately upon purchasing stuff

                if (await GetBlackMarketDiscountAsync(token).ConfigureAwait(false))
                {
                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                    out HashSet<string> setArmorBlackMarketMaps))
                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                    out HashSet<string> setArmorModBlackMarketMaps))
                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                    out HashSet<string> setBiowareBlackMarketMaps))
                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                    out HashSet<string> setCyberwareBlackMarketMaps))
                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                    out HashSet<string> setGearBlackMarketMaps))
                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                    out HashSet<string> setVehicleBlackMarketMaps))
                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                    out HashSet<string> setVehicleModBlackMarketMaps))
                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                    out HashSet<string> setWeaponMountBlackMarketMaps))
                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                    out HashSet<string> setWeaponBlackMarketMaps))
                    {
                        setArmorBlackMarketMaps.AddRange(await GenerateBlackMarketMappingsAsync(await (await LoadDataXPathAsync("armor.xml", token: token).ConfigureAwait(false))
                                                             .SelectSingleNodeAndCacheExpressionAsync("/chummer", token).ConfigureAwait(false), token).ConfigureAwait(false));
                        setArmorModBlackMarketMaps.AddRange(await GenerateBlackMarketMappingsAsync(await (await LoadDataXPathAsync("armor.xml", token: token).ConfigureAwait(false))
                                                                .SelectSingleNodeAndCacheExpressionAsync(
                                                                    "/chummer/modcategories", token).ConfigureAwait(false), token).ConfigureAwait(false));
                        setBiowareBlackMarketMaps.AddRange(await GenerateBlackMarketMappingsAsync(await (await LoadDataXPathAsync("bioware.xml", token: token).ConfigureAwait(false))
                                                               .SelectSingleNodeAndCacheExpressionAsync("/chummer", token).ConfigureAwait(false), token).ConfigureAwait(false));
                        setCyberwareBlackMarketMaps.AddRange(await GenerateBlackMarketMappingsAsync(await (await LoadDataXPathAsync("cyberware.xml", token: token).ConfigureAwait(false))
                                                                 .SelectSingleNodeAndCacheExpressionAsync("/chummer", token).ConfigureAwait(false), token).ConfigureAwait(false));
                        setGearBlackMarketMaps.AddRange(await GenerateBlackMarketMappingsAsync(await (await LoadDataXPathAsync("gear.xml", token: token).ConfigureAwait(false))
                                                            .SelectSingleNodeAndCacheExpressionAsync("/chummer", token).ConfigureAwait(false), token).ConfigureAwait(false));
                        setVehicleBlackMarketMaps.AddRange(await GenerateBlackMarketMappingsAsync(await (await LoadDataXPathAsync("vehicles.xml", token: token).ConfigureAwait(false))
                                                               .SelectSingleNodeAndCacheExpressionAsync("/chummer", token).ConfigureAwait(false), token).ConfigureAwait(false));
                        setVehicleModBlackMarketMaps.AddRange(await GenerateBlackMarketMappingsAsync(await (await LoadDataXPathAsync("vehicles.xml", token: token).ConfigureAwait(false))
                                                                  .SelectSingleNodeAndCacheExpressionAsync(
                                                                      "/chummer/modcategories", token).ConfigureAwait(false), token).ConfigureAwait(false));
                        setWeaponMountBlackMarketMaps.AddRange(await GenerateBlackMarketMappingsAsync(await (await LoadDataXPathAsync("vehicles.xml", token: token).ConfigureAwait(false))
                                                                   .SelectSingleNodeAndCacheExpressionAsync(
                                                                       "/chummer/weaponmountcategories", token).ConfigureAwait(false), token).ConfigureAwait(false));
                        setWeaponBlackMarketMaps.AddRange(await GenerateBlackMarketMappingsAsync(await (await LoadDataXPathAsync("weapons.xml", token: token).ConfigureAwait(false))
                                                              .SelectSingleNodeAndCacheExpressionAsync("/chummer", token).ConfigureAwait(false), token).ConfigureAwait(false));

                        await Armor.ForEachAsync(async objArmor =>
                        {
                            objArmor.DiscountCost
                                = objArmor.DiscountCost && setArmorBlackMarketMaps.Contains(objArmor.Category);
                            await objArmor.ArmorMods.ForEachAsync(objMod =>
                            {
                                objMod.DiscountCost = objMod.DiscountCost
                                                      && setArmorModBlackMarketMaps.Contains(objMod.Category);
                                foreach (Gear objGear in objMod.GearChildren.GetAllDescendants(x => x.Children))
                                {
                                    token.ThrowIfCancellationRequested();
                                    objGear.DiscountCost = objGear.DiscountCost
                                                           && setGearBlackMarketMaps.Contains(objGear.Category);
                                }
                            }, token).ConfigureAwait(false);

                            foreach (Gear objGear in objArmor.GearChildren.GetAllDescendants(x => x.Children))
                            {
                                token.ThrowIfCancellationRequested();
                                objGear.DiscountCost
                                    = objGear.DiscountCost && setGearBlackMarketMaps.Contains(objGear.Category);
                            }
                        }, token).ConfigureAwait(false);

                        foreach (Cyberware objCyberware in Cyberware.GetAllDescendants(x => x.Children))
                        {
                            token.ThrowIfCancellationRequested();
                            if (objCyberware.DiscountCost)
                            {
                                objCyberware.DiscountCost
                                    = (objCyberware.SourceType == Improvement.ImprovementSource.Bioware
                                        ? setBiowareBlackMarketMaps
                                        : setCyberwareBlackMarketMaps).Contains(objCyberware.Category);
                            }

                            foreach (Gear objGear in objCyberware.GearChildren.GetAllDescendants(x => x.Children))
                            {
                                token.ThrowIfCancellationRequested();
                                objGear.DiscountCost
                                    = objGear.DiscountCost && setGearBlackMarketMaps.Contains(objGear.Category);
                            }
                        }

                        foreach (Gear objGear in Gear.GetAllDescendants(x => x.Children))
                        {
                            token.ThrowIfCancellationRequested();
                            objGear.DiscountCost
                                = objGear.DiscountCost && setGearBlackMarketMaps.Contains(objGear.Category);
                        }

                        await Vehicles.ForEachAsync(async objVehicle =>
                        {
                            objVehicle.DiscountCost = objVehicle.DiscountCost
                                                      && setVehicleBlackMarketMaps.Contains(objVehicle.Category);
                            foreach (Gear objGear in objVehicle.GearChildren.GetAllDescendants(x => x.Children))
                            {
                                token.ThrowIfCancellationRequested();
                                objGear.DiscountCost
                                    = objGear.DiscountCost && setGearBlackMarketMaps.Contains(objGear.Category);
                            }

                            await objVehicle.Mods.ForEachAsync(objMod =>
                            {
                                objMod.DiscountCost = objMod.DiscountCost
                                                      && setVehicleModBlackMarketMaps.Contains(objMod.Category);
                                foreach (Cyberware objCyberware in objMod.Cyberware.GetAllDescendants(
                                             x => x.Children))
                                {
                                    token.ThrowIfCancellationRequested();
                                    if (objCyberware.DiscountCost)
                                    {
                                        objCyberware.DiscountCost
                                            = (objCyberware.SourceType == Improvement.ImprovementSource.Bioware
                                                ? setBiowareBlackMarketMaps
                                                : setCyberwareBlackMarketMaps).Contains(objCyberware.Category);
                                    }

                                    foreach (Gear objGear in objCyberware.GearChildren.GetAllDescendants(
                                                 x => x.Children))
                                    {
                                        token.ThrowIfCancellationRequested();
                                        objGear.DiscountCost = objGear.DiscountCost
                                                               && setGearBlackMarketMaps.Contains(objGear.Category);
                                    }
                                }
                            }, token).ConfigureAwait(false);

                            foreach (Weapon objWeapon in objVehicle.Weapons.GetAllDescendants(x => x.Children))
                            {
                                token.ThrowIfCancellationRequested();
                                objWeapon.DiscountCost = objWeapon.DiscountCost
                                                         && setWeaponBlackMarketMaps.Contains(objWeapon.Category);
                                await objWeapon.WeaponAccessories.ForEachAsync(objAccessory =>
                                {
                                    objAccessory.DiscountCost = objAccessory.DiscountCost
                                                                && setWeaponBlackMarketMaps
                                                                    .Contains(objWeapon.Category);
                                    foreach (Gear objGear in objAccessory.GearChildren.GetAllDescendants(
                                                 x => x.Children))
                                    {
                                        token.ThrowIfCancellationRequested();
                                        objGear.DiscountCost = objGear.DiscountCost
                                                               && setGearBlackMarketMaps.Contains(objGear.Category);
                                    }
                                }, token).ConfigureAwait(false);
                            }

                            await objVehicle.WeaponMounts.ForEachAsync(async objMount =>
                            {
                                objMount.DiscountCost = objMount.DiscountCost
                                                        && setWeaponMountBlackMarketMaps
                                                            .Contains(objMount.Category);
                                await objMount.Mods.ForEachAsync(objMod =>
                                {
                                    objMod.DiscountCost = objMod.DiscountCost
                                                          && setVehicleModBlackMarketMaps.Contains(objMod.Category);
                                    foreach (Cyberware objCyberware in objMod.Cyberware.GetAllDescendants(
                                                 x => x.Children))
                                    {
                                        token.ThrowIfCancellationRequested();
                                        if (objCyberware.DiscountCost)
                                        {
                                            objCyberware.DiscountCost
                                                = (objCyberware.SourceType == Improvement.ImprovementSource.Bioware
                                                    ? setBiowareBlackMarketMaps
                                                    : setCyberwareBlackMarketMaps).Contains(objCyberware.Category);
                                        }

                                        foreach (Gear objGear in objCyberware.GearChildren.GetAllDescendants(
                                                     x => x.Children))
                                        {
                                            token.ThrowIfCancellationRequested();
                                            objGear.DiscountCost = objGear.DiscountCost
                                                                   && setGearBlackMarketMaps.Contains(
                                                                       objGear.Category);
                                        }
                                    }
                                }, token).ConfigureAwait(false);

                                foreach (Weapon objWeapon in objMount.Weapons.GetAllDescendants(x => x.Children))
                                {
                                    token.ThrowIfCancellationRequested();
                                    objWeapon.DiscountCost = objWeapon.DiscountCost
                                                             && setWeaponBlackMarketMaps.Contains(
                                                                 objWeapon.Category);
                                    await objWeapon.WeaponAccessories.ForEachAsync(objAccessory =>
                                    {
                                        token.ThrowIfCancellationRequested();
                                        objAccessory.DiscountCost = objAccessory.DiscountCost
                                                                    && setWeaponBlackMarketMaps
                                                                        .Contains(objWeapon.Category);
                                        foreach (Gear objGear in objAccessory.GearChildren.GetAllDescendants(
                                                     x => x.Children))
                                        {
                                            token.ThrowIfCancellationRequested();
                                            objGear.DiscountCost = objGear.DiscountCost
                                                                   && setGearBlackMarketMaps.Contains(
                                                                       objGear.Category);
                                        }
                                    }, token).ConfigureAwait(false);
                                }
                            }, token).ConfigureAwait(false);
                        }, token).ConfigureAwait(false);

                        foreach (Weapon objWeapon in Weapons.GetAllDescendants(x => x.Children))
                        {
                            token.ThrowIfCancellationRequested();
                            objWeapon.DiscountCost = objWeapon.DiscountCost
                                                     && setWeaponBlackMarketMaps.Contains(objWeapon.Category);
                            await objWeapon.WeaponAccessories.ForEachAsync(objAccessory =>
                            {
                                token.ThrowIfCancellationRequested();
                                objAccessory.DiscountCost = objAccessory.DiscountCost
                                                            && setWeaponBlackMarketMaps
                                                                .Contains(objWeapon.Category);
                                foreach (Gear objGear in objAccessory.GearChildren.GetAllDescendants(
                                             x => x.Children))
                                {
                                    token.ThrowIfCancellationRequested();
                                    objGear.DiscountCost = objGear.DiscountCost
                                                           && setGearBlackMarketMaps.Contains(objGear.Category);
                                }
                            }, token).ConfigureAwait(false);
                        }
                    }
                }
                else
                {
                    // Forcefully disable all Black Market Discounts that don't apply.
                    await Armor.ForEachAsync(async objArmor =>
                    {
                        objArmor.DiscountCost = false;
                        await objArmor.ArmorMods.ForEachAsync(objMod =>
                        {
                            objMod.DiscountCost = false;
                            foreach (Gear objGear in objMod.GearChildren.GetAllDescendants(x => x.Children))
                            {
                                token.ThrowIfCancellationRequested();
                                objGear.DiscountCost = false;
                            }
                        }, token).ConfigureAwait(false);

                        foreach (Gear objGear in objArmor.GearChildren.GetAllDescendants(x => x.Children))
                        {
                            token.ThrowIfCancellationRequested();
                            objGear.DiscountCost = false;
                        }
                    }, token).ConfigureAwait(false);

                    foreach (Cyberware objCyberware in Cyberware.GetAllDescendants(x => x.Children))
                    {
                        token.ThrowIfCancellationRequested();
                        objCyberware.DiscountCost = false;
                        foreach (Gear objGear in objCyberware.GearChildren.GetAllDescendants(x => x.Children))
                        {
                            token.ThrowIfCancellationRequested();
                            objGear.DiscountCost = false;
                        }
                    }

                    foreach (Gear objGear in Gear.GetAllDescendants(x => x.Children))
                    {
                        token.ThrowIfCancellationRequested();
                        objGear.DiscountCost = false;
                    }

                    await Vehicles.ForEachAsync(async objVehicle =>
                    {
                        objVehicle.DiscountCost = false;
                        foreach (Gear objGear in objVehicle.GearChildren.GetAllDescendants(x => x.Children))
                        {
                            token.ThrowIfCancellationRequested();
                            objGear.DiscountCost = false;
                        }

                        await objVehicle.Mods.ForEachAsync(objMod =>
                        {
                            objMod.DiscountCost = false;
                            foreach (Cyberware objCyberware in objMod.Cyberware.GetAllDescendants(x => x.Children))
                            {
                                token.ThrowIfCancellationRequested();
                                objCyberware.DiscountCost = false;
                                foreach (Gear objGear in objCyberware.GearChildren.GetAllDescendants(
                                             x => x.Children))
                                {
                                    token.ThrowIfCancellationRequested();
                                    objGear.DiscountCost = false;
                                }
                            }
                        }, token).ConfigureAwait(false);

                        foreach (Weapon objWeapon in objVehicle.Weapons.GetAllDescendants(x => x.Children))
                        {
                            token.ThrowIfCancellationRequested();
                            objWeapon.DiscountCost = false;
                            await objWeapon.WeaponAccessories.ForEachAsync(objAccessory =>
                            {
                                objAccessory.DiscountCost = false;
                                foreach (Gear objGear in objAccessory.GearChildren.GetAllDescendants(
                                             x => x.Children))
                                {
                                    token.ThrowIfCancellationRequested();
                                    objGear.DiscountCost = false;
                                }
                            }, token).ConfigureAwait(false);
                        }

                        await objVehicle.WeaponMounts.ForEachAsync(async objMount =>
                        {
                            objMount.DiscountCost = false;
                            await objMount.Mods.ForEachAsync(objMod =>
                            {
                                objMod.DiscountCost = false;
                                foreach (Cyberware objCyberware in objMod.Cyberware.GetAllDescendants(
                                             x => x.Children))
                                {
                                    token.ThrowIfCancellationRequested();
                                    objCyberware.DiscountCost = false;
                                    foreach (Gear objGear in objCyberware.GearChildren.GetAllDescendants(
                                                 x => x.Children))
                                    {
                                        token.ThrowIfCancellationRequested();
                                        objGear.DiscountCost = false;
                                    }
                                }
                            }, token).ConfigureAwait(false);

                            foreach (Weapon objWeapon in objMount.Weapons.GetAllDescendants(x => x.Children))
                            {
                                token.ThrowIfCancellationRequested();
                                objWeapon.DiscountCost = false;
                                await objWeapon.WeaponAccessories.ForEachAsync(objAccessory =>
                                {
                                    objAccessory.DiscountCost = false;
                                    foreach (Gear objGear in objAccessory.GearChildren.GetAllDescendants(
                                                 x => x.Children))
                                    {
                                        token.ThrowIfCancellationRequested();
                                        objGear.DiscountCost = false;
                                    }
                                }, token).ConfigureAwait(false);
                            }
                        }, token).ConfigureAwait(false);
                    }, token).ConfigureAwait(false);

                    foreach (Weapon objWeapon in Weapons.GetAllDescendants(x => x.Children))
                    {
                        token.ThrowIfCancellationRequested();
                        objWeapon.DiscountCost = false;
                        await objWeapon.WeaponAccessories.ForEachAsync(objAccessory =>
                        {
                            objAccessory.DiscountCost = false;
                            foreach (Gear objGear in objAccessory.GearChildren.GetAllDescendants(
                                         x => x.Children))
                            {
                                token.ThrowIfCancellationRequested();
                                objGear.DiscountCost = false;
                            }
                        }, token).ConfigureAwait(false);
                    }
                }
            }
        }

        /// <summary>
        /// Whether or not this character can quicken spells.
        /// </summary>
        public bool QuickeningEnabled =>
            ImprovementManager
                .GetCachedImprovementListForValueOf(
                    this, Improvement.ImprovementType.QuickeningMetamagic).Count > 0;

        /// <summary>
        /// Whether or not user is getting free bioware from Prototype Transhuman.
        /// </summary>
        public decimal PrototypeTranshuman
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _decPrototypeTranshuman;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_decPrototypeTranshuman == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _decPrototypeTranshuman = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Whether or not user is getting free bioware from Prototype Transhuman.
        /// </summary>
        public async ValueTask<decimal> GetPrototypeTranshumanAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _decPrototypeTranshuman;
        }

        public bool IsPrototypeTranshuman => PrototypeTranshuman > 0;

        public async ValueTask<bool> GetIsPrototypeTranshumanAsync(CancellationToken token = default) =>
            await GetPrototypeTranshumanAsync(token).ConfigureAwait(false) > 0;

        /// <summary>
        /// Whether or not Friends in High Places is enabled.
        /// </summary>
        public bool FriendsInHighPlaces => ImprovementManager
                                           .GetCachedImprovementListForValueOf(
                                               this, Improvement.ImprovementType.FriendsInHighPlaces).Count > 0;

        public async ValueTask<bool> GetFriendsInHighPlacesAsync(CancellationToken token = default)
        {
            return (await ImprovementManager
                          .GetCachedImprovementListForValueOfAsync(
                              this, Improvement.ImprovementType.FriendsInHighPlaces, token: token).ConfigureAwait(false)).Count > 0;
        }

        /// <summary>
        /// Whether or not ExCon is enabled.
        /// </summary>
        public bool ExCon => ImprovementManager
                             .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.ExCon).Count > 0;

        private int _intCachedTrustFund = int.MinValue;

        /// <summary>
        /// Value of the Trust Fund quality.
        /// </summary>
        public int TrustFund
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedTrustFund != int.MinValue)
                        return _intCachedTrustFund;

                    List<Improvement> lstTrustFundImprovements = ImprovementManager
                        .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.TrustFund);
                    return _intCachedTrustFund = lstTrustFundImprovements.Count > 0
                        ? lstTrustFundImprovements.Max(x => x.Value).StandardRound()
                        : 0;
                }
            }
        }

        private int _intCachedRestrictedGear = int.MinValue;

        /// <summary>
        /// The maximum availability for Restricted Gear if this character has it. If they do not, this is 0.
        /// </summary>
        public int RestrictedGear
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedRestrictedGear < 0)
                    {
                        foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.RestrictedGear))
                        {
                            _intCachedRestrictedGear
                                = Math.Max(_intCachedRestrictedGear, objImprovement.Value.StandardRound());
                        }
                    }

                    return _intCachedRestrictedGear;
                }
            }
        }

        /// <summary>
        /// The maximum availability for Restricted Gear if this character has it. If they do not, this is 0.
        /// </summary>
        public async ValueTask<int> GetRestrictedGearAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (_intCachedRestrictedGear < 0)
                {
                    foreach (Improvement objImprovement in await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                 this, Improvement.ImprovementType.RestrictedGear, token: token).ConfigureAwait(false))
                    {
                        _intCachedRestrictedGear
                            = Math.Max(_intCachedRestrictedGear, objImprovement.Value.StandardRound());
                    }
                }

                return _intCachedRestrictedGear;
            }
        }

        /// <summary>
        /// Whether or not Overclocker is enabled.
        /// </summary>
        public bool Overclocker => ImprovementManager
                                   .GetCachedImprovementListForValueOf(
                                       this, Improvement.ImprovementType.Overclocker).Count > 0;

        /// <summary>
        /// Whether or not MadeMan is enabled.
        /// </summary>
        public bool MadeMan => ImprovementManager
                               .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.MadeMan).Count > 0;

        /// <summary>
        /// Whether or not Fame is enabled.
        /// </summary>
        public bool Fame => ImprovementManager
                            .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Fame).Count
                            > 0;

        /// <summary>
        /// Whether or not Erased is enabled.
        /// </summary>
        public bool Erased => ImprovementManager
                              .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Erased).Count
                              > 0;

        /// <summary>
        /// Whether or not the character is allowed to Fetter sprites. See Kill Code 91 (Sprite Pet)
        /// </summary>
        public bool AllowSpriteFettering => ImprovementManager
                                            .GetCachedImprovementListForValueOf(
                                                this, Improvement.ImprovementType.AllowSpriteFettering).Count
                                            > 0;

        /// <summary>
        /// Extended Availability Test information for an item based on the character's Negotiate Skill.
        /// </summary>
        /// <param name="decCost">Item's cost.</param>
        /// <param name="strAvail">Item's Availability.</param>
        public string AvailTest(decimal decCost, string strAvail)
        {
            if (string.IsNullOrEmpty(strAvail))
                return LanguageManager.GetString("String_None");
            bool blnShowTest = false;
            string strTestSuffix = LanguageManager.GetString("String_AvailRestricted");
            if (strAvail.EndsWith(strTestSuffix, StringComparison.Ordinal))
            {
                blnShowTest = true;
                strAvail = strAvail.TrimEndOnce(strTestSuffix, true);
            }
            else
            {
                strTestSuffix = LanguageManager.GetString("String_AvailForbidden");
                if (strAvail.EndsWith(strTestSuffix, StringComparison.Ordinal))
                {
                    blnShowTest = true;
                    strAvail = strAvail.TrimEndOnce(strTestSuffix, true);
                }
            }

            if (int.TryParse(strAvail, out int intAvail) && (intAvail != 0 || blnShowTest))
            {
                return GetAvailTestString(decCost, intAvail);
            }

            return LanguageManager.GetString("String_None");
        }

        /// <summary>
        /// Extended Availability Test information for an item based on the character's Negotiate Skill.
        /// </summary>
        /// <param name="decCost">Item's cost.</param>
        /// <param name="objAvailability">Item's Availability.</param>
        public string AvailTest(decimal decCost, AvailabilityValue objAvailability)
        {
            if (objAvailability.Value != 0 || objAvailability.Suffix == 'R' || objAvailability.Suffix == 'F')
            {
                return GetAvailTestString(decCost, objAvailability.Value);
            }

            return LanguageManager.GetString("String_None");
        }

        /// <summary>
        /// Extended Availability Test information for an item based on the character's Negotiate Skill.
        /// </summary>
        /// <param name="decCost">Item's cost.</param>
        /// <param name="strAvail">Item's Availability.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public async Task<string> AvailTestAsync(decimal decCost, string strAvail, CancellationToken token = default)
        {
            if (string.IsNullOrEmpty(strAvail))
                return await LanguageManager.GetStringAsync("String_None", token: token).ConfigureAwait(false);
            bool blnShowTest = false;
            string strTestSuffix = await LanguageManager.GetStringAsync("String_AvailRestricted", token: token).ConfigureAwait(false);
            if (strAvail.EndsWith(strTestSuffix, StringComparison.Ordinal))
            {
                blnShowTest = true;
                strAvail = strAvail.TrimEndOnce(strTestSuffix, true);
            }
            else
            {
                strTestSuffix = await LanguageManager.GetStringAsync("String_AvailForbidden", token: token).ConfigureAwait(false);
                if (strAvail.EndsWith(strTestSuffix, StringComparison.Ordinal))
                {
                    blnShowTest = true;
                    strAvail = strAvail.TrimEndOnce(strTestSuffix, true);
                }
            }

            if (int.TryParse(strAvail, out int intAvail) && (intAvail != 0 || blnShowTest))
            {
                return await GetAvailTestStringAsync(decCost, intAvail, token).ConfigureAwait(false);
            }

            return await LanguageManager.GetStringAsync("String_None", token: token).ConfigureAwait(false);
        }

        /// <summary>
        /// Extended Availability Test information for an item based on the character's Negotiate Skill.
        /// </summary>
        /// <param name="decCost">Item's cost.</param>
        /// <param name="objAvailability">Item's Availability.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public Task<string> AvailTestAsync(decimal decCost, AvailabilityValue objAvailability, CancellationToken token = default)
        {
            if (objAvailability.Value != 0 || objAvailability.Suffix == 'R' || objAvailability.Suffix == 'F')
            {
                return GetAvailTestStringAsync(decCost, objAvailability.Value, token);
            }

            return LanguageManager.GetStringAsync("String_None", token: token);
        }

        private string GetAvailTestString(decimal decCost, int intAvailValue)
        {
            string strSpace = LanguageManager.GetString("String_Space");
            using (EnterReadLock.Enter(LockObject))
            {
                // Find the character's Negotiation total.
                int intPool = SkillsSection.GetActiveSkill("Negotiation")?.Pool ?? 0;
                if (_dicAvailabilityMap == null || GlobalSettings.LiveCustomData)
                {
                    using (LockObject.EnterWriteLock())
                    {
                        if (_dicAvailabilityMap == null || GlobalSettings.LiveCustomData)
                        {
                            SortedDictionary<decimal, Tuple<string, string>> dicAvailabilityMap
                                = Interlocked.Exchange(ref _dicAvailabilityMap, null)
                                  ?? new SortedDictionary<decimal, Tuple<string, string>>();
                            dicAvailabilityMap.Clear();
                            foreach (XPathNavigator objNode in LoadDataXPath("options.xml")
                                         .SelectAndCacheExpression("/chummer/availmap/avail"))
                            {
                                decimal decValue = 0;
                                if (objNode.TryGetDecFieldQuickly("value", ref decValue)
                                    && !dicAvailabilityMap.ContainsKey(decValue))
                                {
                                    dicAvailabilityMap.Add(
                                        decValue,
                                        new Tuple<string, string>(
                                            objNode.SelectSingleNodeAndCacheExpression("duration").Value,
                                            objNode.SelectSingleNodeAndCacheExpression("interval")
                                                   .Value));
                                }
                            }
                            Interlocked.CompareExchange(ref _dicAvailabilityMap, dicAvailabilityMap, null);
                        }
                    }
                }

                KeyValuePair<decimal, Tuple<string, string>>
                    item = _dicAvailabilityMap.FirstOrDefault(
                        x => decCost
                             < x.Key); //Assumes that the keys are sorted lowest to highest. Maybe not safe for custom content?
                // Determine the interval based on the item's price.
                string strInterval = item.Value.Item1 + strSpace + LanguageManager.GetString(item.Value.Item2);

                return intPool.ToString(GlobalSettings.CultureInfo) + strSpace + '('
                       + intAvailValue.ToString(GlobalSettings.CultureInfo) + ',' + strSpace + strInterval + ')';
            }
        }

        private async Task<string> GetAvailTestStringAsync(decimal decCost, int intAvailValue, CancellationToken token = default)
        {
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                // Find the character's Negotiation total.
                Skill objSkill = await (await GetSkillsSectionAsync(token).ConfigureAwait(false)).GetActiveSkillAsync("Negotiation", token).ConfigureAwait(false);
                int intPool = objSkill != null ? await objSkill.GetPoolAsync(token).ConfigureAwait(false) : 0;
                if (_dicAvailabilityMap == null || GlobalSettings.LiveCustomData)
                {
                    IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                    try
                    {
                        if (_dicAvailabilityMap == null || GlobalSettings.LiveCustomData)
                        {
                            SortedDictionary<decimal, Tuple<string, string>> dicAvailabilityMap
                                = Interlocked.Exchange(ref _dicAvailabilityMap, null)
                                  ?? new SortedDictionary<decimal, Tuple<string, string>>();
                            dicAvailabilityMap.Clear();
                            foreach (XPathNavigator objNode in await (await LoadDataXPathAsync(
                                                                         "options.xml", token: token).ConfigureAwait(false))
                                                                     .SelectAndCacheExpressionAsync("/chummer/availmap/avail", token).ConfigureAwait(false))
                            {
                                decimal decValue = 0;
                                if (objNode.TryGetDecFieldQuickly("value", ref decValue)
                                    && !dicAvailabilityMap.ContainsKey(decValue))
                                {
                                    dicAvailabilityMap.Add(
                                        decValue,
                                        new Tuple<string, string>(
                                            (await objNode.SelectSingleNodeAndCacheExpressionAsync("duration", token).ConfigureAwait(false))
                                            .Value,
                                            (await objNode.SelectSingleNodeAndCacheExpressionAsync("interval", token).ConfigureAwait(false))
                                            .Value));
                                }
                            }

                            Interlocked.CompareExchange(ref _dicAvailabilityMap, dicAvailabilityMap, null);
                        }
                    }
                    finally
                    {
                        await objLocker.DisposeAsync().ConfigureAwait(false);
                    }
                }

                KeyValuePair<decimal, Tuple<string, string>>
                    item = _dicAvailabilityMap.FirstOrDefault(
                        x => decCost
                             < x.Key); //Assumes that the keys are sorted lowest to highest. Maybe not safe for custom content?
                // Determine the interval based on the item's price.
                string strInterval = item.Value.Item1 + strSpace + await LanguageManager.GetStringAsync(item.Value.Item2, token: token).ConfigureAwait(false);

                return intPool.ToString(GlobalSettings.CultureInfo) + strSpace + '('
                       + intAvailValue.ToString(GlobalSettings.CultureInfo) + ',' + strSpace + strInterval + ')';
            }
        }

        /// <summary>
        /// Whether or not Adapsin is enabled.
        /// </summary>
        public bool AdapsinEnabled =>
            ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Adapsin)
                              .Count > 0;

        /// <summary>
        /// Whether or not Burnout's Way is enabled.
        /// </summary>
        public bool BurnoutEnabled =>
            ImprovementManager
                .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.BurnoutsWay)
                .Count > 0;

        #endregion Special Functions and Enabled Check Properties

        #region Application Properties

        private readonly LockingHashSet<Character> _lstLinkedCharacters = new LockingHashSet<Character>();

        /// <summary>
        /// Characters referenced by some member of this character (usually a contact).
        /// </summary>
        public LockingHashSet<Character> LinkedCharacters
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstLinkedCharacters;
            }
        }

        #endregion Application Properties

        #region Old Quality Conversion Code

        /// <summary>
        /// Convert Qualities that are still saved in the old format.
        /// </summary>
        private void ConvertOldQualities(XmlNodeList objXmlQualityList)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                XmlNode xmlRootQualitiesNode = LoadData("qualities.xml").SelectSingleNode("/chummer/qualities");

                if (xmlRootQualitiesNode != null)
                {
                    // Convert the old Qualities.
                    foreach (XmlNode objXmlQuality in objXmlQualityList)
                    {
                        if (objXmlQuality["name"] == null)
                        {
                            XmlNode objXmlQualityNode =
                                xmlRootQualitiesNode.TryGetNodeByNameOrId(
                                    "quality", GetQualityName(objXmlQuality.InnerText));

                            if (objXmlQualityNode != null)
                            {
                                string strForceValue = string.Empty;
                                // Re-create the bonuses for the Quality.
                                if (objXmlQualityNode.InnerXml.Contains("<bonus>"))
                                {
                                    // Look for the existing Improvement.
                                    foreach (Improvement objImprovement in Improvements)
                                    {
                                        if (objImprovement.ImproveSource == Improvement.ImprovementSource.Quality &&
                                            objImprovement.SourceName == objXmlQuality.InnerText
                                            && objImprovement.Enabled)
                                        {
                                            strForceValue = objImprovement.ImprovedName;
                                            using (LockObject.EnterWriteLock())
                                                Improvements.Remove(objImprovement);
                                            break;
                                        }
                                    }
                                }

                                using (LockObject.EnterWriteLock())
                                {
                                    // Convert the item to the new Quality class.
                                    Quality objQuality = new Quality(this);
                                    try
                                    {
                                        objQuality.Create(objXmlQualityNode, QualitySource.Selected, _lstWeapons,
                                                          strForceValue);
                                        Qualities.Add(objQuality);
                                    }
                                    catch
                                    {
                                        objQuality.Dispose();
                                        throw;
                                    }
                                }
                            }
                        }
                    }

                    // Take care of the Metatype information.
                    XmlNode objXmlMetatype = LoadData("metatypes.xml").TryGetNodeByNameOrId("/chummer/metatypes/metatype", Metatype) ??
                                             LoadData("critters.xml").TryGetNodeByNameOrId("/chummer/metatypes/metatype", Metatype);

                    if (objXmlMetatype != null)
                    {
                        // Positive Qualities.
                        using (XmlNodeList xmlMetatypeQualityList =
                               objXmlMetatype.SelectNodes("qualities/positive/quality"))
                        {
                            if (xmlMetatypeQualityList != null)
                            {
                                foreach (XmlNode objXmlMetatypeQuality in xmlMetatypeQualityList)
                                {
                                    bool blnFound = false;
                                    // See if the Quality already exists in the character.
                                    foreach (Quality objCharacterQuality in _lstQualities)
                                    {
                                        if (objCharacterQuality.Name == objXmlMetatypeQuality.InnerText)
                                        {
                                            blnFound = true;
                                            break;
                                        }
                                    }

                                    // If the Quality was not found, create it.
                                    if (!blnFound)
                                    {
                                        string strForceValue =
                                            objXmlMetatypeQuality.Attributes?["select"]?.InnerText ?? string.Empty;
                                        XmlNode objXmlQuality =
                                            xmlRootQualitiesNode.TryGetNodeByNameOrId("quality", objXmlMetatypeQuality.InnerText);
                                        using (LockObject.EnterWriteLock())
                                        {
                                            Quality objQuality = new Quality(this);
                                            try
                                            {
                                                objQuality.Create(objXmlQuality, QualitySource.Metatype, _lstWeapons,
                                                                  strForceValue);
                                                Qualities.Add(objQuality);
                                            }
                                            catch
                                            {
                                                objQuality.Dispose();
                                                throw;
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        // Negative Qualities.
                        using (XmlNodeList xmlMetatypeQualityList =
                               objXmlMetatype.SelectNodes("qualities/negative/quality"))
                        {
                            if (xmlMetatypeQualityList != null)
                            {
                                foreach (XmlNode objXmlMetatypeQuality in xmlMetatypeQualityList)
                                {
                                    bool blnFound = false;
                                    // See if the Quality already exists in the character.
                                    foreach (Quality objCharacterQuality in _lstQualities)
                                    {
                                        if (objCharacterQuality.Name == objXmlMetatypeQuality.InnerText)
                                        {
                                            blnFound = true;
                                            break;
                                        }
                                    }

                                    // If the Quality was not found, create it.
                                    if (!blnFound)
                                    {
                                        string strForceValue =
                                            objXmlMetatypeQuality.Attributes?["select"]?.InnerText ?? string.Empty;
                                        XmlNode objXmlQuality =
                                            xmlRootQualitiesNode.TryGetNodeByNameOrId("quality", objXmlMetatypeQuality.InnerText);
                                        using (LockObject.EnterWriteLock())
                                        {
                                            Quality objQuality = new Quality(this);
                                            try
                                            {
                                                objQuality.Create(objXmlQuality, QualitySource.Metatype, _lstWeapons,
                                                                  strForceValue);
                                                Qualities.Add(objQuality);
                                            }
                                            catch
                                            {
                                                objQuality.Dispose();
                                                throw;
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        // Do it all over again for Metavariants.
                        if (!string.IsNullOrEmpty(_strMetavariant))
                        {
                            objXmlMetatype =
                                objXmlMetatype.TryGetNodeByNameOrId("metavariants/metavariant", Metavariant);

                            if (objXmlMetatype != null)
                            {
                                // Positive Qualities.
                                using (XmlNodeList xmlMetatypeQualityList =
                                       objXmlMetatype.SelectNodes("qualities/positive/quality"))
                                {
                                    if (xmlMetatypeQualityList != null)
                                    {
                                        foreach (XmlNode objXmlMetatypeQuality in xmlMetatypeQualityList)
                                        {
                                            bool blnFound = false;
                                            // See if the Quality already exists in the character.
                                            foreach (Quality objCharacterQuality in _lstQualities)
                                            {
                                                if (objCharacterQuality.Name == objXmlMetatypeQuality.InnerText)
                                                {
                                                    blnFound = true;
                                                    break;
                                                }
                                            }

                                            // If the Quality was not found, create it.
                                            if (!blnFound)
                                            {
                                                string strForceValue =
                                                    objXmlMetatypeQuality.Attributes?["select"]?.InnerText
                                                    ?? string.Empty;
                                                XmlNode objXmlQuality =
                                                    xmlRootQualitiesNode.TryGetNodeByNameOrId("quality", objXmlMetatypeQuality.InnerText);
                                                using (LockObject.EnterWriteLock())
                                                {
                                                    Quality objQuality = new Quality(this);
                                                    try
                                                    {
                                                        objQuality.Create(objXmlQuality, QualitySource.Metatype,
                                                                          _lstWeapons,
                                                                          strForceValue);
                                                        Qualities.Add(objQuality);
                                                    }
                                                    catch
                                                    {
                                                        objQuality.Dispose();
                                                        throw;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }

                                // Negative Qualities.
                                using (XmlNodeList xmlMetatypeQualityList =
                                       objXmlMetatype.SelectNodes("qualities/negative/quality"))
                                {
                                    if (xmlMetatypeQualityList != null)
                                    {
                                        foreach (XmlNode objXmlMetatypeQuality in xmlMetatypeQualityList)
                                        {
                                            bool blnFound = false;
                                            // See if the Quality already exists in the character.
                                            foreach (Quality objCharacterQuality in _lstQualities)
                                            {
                                                if (objCharacterQuality.Name == objXmlMetatypeQuality.InnerText)
                                                {
                                                    blnFound = true;
                                                    break;
                                                }
                                            }

                                            // If the Quality was not found, create it.
                                            if (!blnFound)
                                            {
                                                string strForceValue =
                                                    objXmlMetatypeQuality.Attributes?["select"]?.InnerText
                                                    ?? string.Empty;
                                                XmlNode objXmlQuality =
                                                    xmlRootQualitiesNode.TryGetNodeByNameOrId("quality", objXmlMetatypeQuality.InnerText);
                                                using (LockObject.EnterWriteLock())
                                                {
                                                    Quality objQuality = new Quality(this);
                                                    try
                                                    {
                                                        objQuality.Create(objXmlQuality, QualitySource.Metatype,
                                                                          _lstWeapons,
                                                                          strForceValue);
                                                        Qualities.Add(objQuality);
                                                    }
                                                    catch
                                                    {
                                                        objQuality.Dispose();
                                                        throw;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Get the name of a Quality by parsing out its BP cost.
        /// </summary>
        /// <param name="strQuality">String to parse.</param>
        private static string GetQualityName(string strQuality)
        {
            int intPos = strQuality.IndexOf('[');
            if (intPos != -1)
                strQuality = strQuality.Substring(0, intPos - 1);
            return strQuality;
        }

        /// <summary>
        /// Check for older instances of certain qualities that were manually numbered to be replaced with multiple instances of the first level quality (so that it works with the level system)
        /// Returns true if it's a corrected quality, false otherwise
        /// </summary>
        private bool CorrectedUnleveledQuality(XmlNode xmlOldQuality, XmlNode xmlRootQualitiesNode)
        {
            XmlNode xmlNewQuality = null;
            int intRanks = 0;
            switch (xmlOldQuality["name"]?.InnerText)
            {
                case "Focused Concentration (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Focused Concentration\"]");
                        intRanks = 1;
                        break;
                    }
                case "Focused Concentration (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Focused Concentration\"]");
                        intRanks = 2;
                        break;
                    }
                case "Focused Concentration (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Focused Concentration\"]");
                        intRanks = 3;
                        break;
                    }
                case "Focused Concentration (Rating 4)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Focused Concentration\"]");
                        intRanks = 4;
                        break;
                    }
                case "Focused Concentration (Rating 5)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Focused Concentration\"]");
                        intRanks = 5;
                        break;
                    }
                case "Focused Concentration (Rating 6)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Focused Concentration\"]");
                        intRanks = 6;
                        break;
                    }
                case "High Pain Tolerance (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"High Pain Tolerance\"]");
                        intRanks = 1;
                        break;
                    }
                case "High Pain Tolerance (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"High Pain Tolerance\"]");
                        intRanks = 2;
                        break;
                    }
                case "High Pain Tolerance (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"High Pain Tolerance\"]");
                        intRanks = 3;
                        break;
                    }
                case "Magic Resistance (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Magic Resistance\"]");
                        intRanks = 1;
                        break;
                    }
                case "Magic Resistance (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Magic Resistance\"]");
                        intRanks = 2;
                        break;
                    }
                case "Magic Resistance (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Magic Resistance\"]");
                        intRanks = 3;
                        break;
                    }
                case "Magic Resistance (Rating 4)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Magic Resistance\"]");
                        intRanks = 4;
                        break;
                    }
                case "Will to Live (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Will to Live\"]");
                        intRanks = 1;
                        break;
                    }
                case "Will to Live (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Will to Live\"]");
                        intRanks = 2;
                        break;
                    }
                case "Will to Live (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Will to Live\"]");
                        intRanks = 3;
                        break;
                    }
                case "Gremlins (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Gremlins\"]");
                        intRanks = 1;
                        break;
                    }
                case "Gremlins (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Gremlins\"]");
                        intRanks = 2;
                        break;
                    }
                case "Gremlins (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Gremlins\"]");
                        intRanks = 3;
                        break;
                    }
                case "Gremlins (Rating 4)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Gremlins\"]");
                        intRanks = 4;
                        break;
                    }
                case "Aged (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Aged\"]");
                        intRanks = 1;
                        break;
                    }
                case "Aged (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Aged\"]");
                        intRanks = 2;
                        break;
                    }
                case "Aged (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Aged\"]");
                        intRanks = 3;
                        break;
                    }
                case "Illness (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Illness\"]");
                        intRanks = 1;
                        break;
                    }
                case "Illness (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Illness\"]");
                        intRanks = 2;
                        break;
                    }
                case "Illness (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Illness\"]");
                        intRanks = 3;
                        break;
                    }
                case "Perceptive I":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Perceptive\"]");
                        intRanks = 1;
                        break;
                    }
                case "Perceptive II":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Perceptive\"]");
                        intRanks = 2;
                        break;
                    }
                case "Spike Resistance I":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Spike Resistance\"]");
                        intRanks = 1;
                        break;
                    }
                case "Spike Resistance II":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Spike Resistance\"]");
                        intRanks = 2;
                        break;
                    }
                case "Spike Resistance III":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Spike Resistance\"]");
                        intRanks = 3;
                        break;
                    }
                case "Tough as Nails Physical I":
                    {
                        xmlNewQuality =
                            xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Tough as Nails (Physical)\"]");
                        intRanks = 1;
                        break;
                    }
                case "Tough as Nails Physical II":
                    {
                        xmlNewQuality =
                            xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Tough as Nails (Physical)\"]");
                        intRanks = 2;
                        break;
                    }
                case "Tough as Nails Physical III":
                    {
                        xmlNewQuality =
                            xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Tough as Nails (Physical)\"]");
                        intRanks = 3;
                        break;
                    }
                case "Tough as Nails Stun I":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Tough as Nails (Stun)\"]");
                        intRanks = 1;
                        break;
                    }
                case "Tough as Nails Stun II":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Tough as Nails (Stun)\"]");
                        intRanks = 2;
                        break;
                    }
                case "Tough as Nails Stun III":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Tough as Nails (Stun)\"]");
                        intRanks = 3;
                        break;
                    }
                case "Dimmer Bulb I":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Dimmer Bulb\"]");
                        intRanks = 1;
                        break;
                    }
                case "Dimmer Bulb II":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Dimmer Bulb\"]");
                        intRanks = 2;
                        break;
                    }
                case "Dimmer Bulb III":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Dimmer Bulb\"]");
                        intRanks = 3;
                        break;
                    }
                case "In Debt I":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 1;
                        break;
                    }
                case "In Debt II":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 2;
                        break;
                    }
                case "In Debt III":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 3;
                        break;
                    }
                case "In Debt IV":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 4;
                        break;
                    }
                case "In Debt V":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 5;
                        break;
                    }
                case "In Debt VI":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 6;
                        break;
                    }
                case "In Debt VII":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 7;
                        break;
                    }
                case "In Debt VIII":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 8;
                        break;
                    }
                case "In Debt IX":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 9;
                        break;
                    }
                case "In Debt X":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 10;
                        break;
                    }
                case "In Debt XI":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 11;
                        break;
                    }
                case "In Debt XII":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 12;
                        break;
                    }
                case "In Debt XIII":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 13;
                        break;
                    }
                case "In Debt XIV":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 14;
                        break;
                    }
                case "In Debt XV":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 15;
                        break;
                    }
                case "Infirm I":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Infirm\"]");
                        intRanks = 1;
                        break;
                    }
                case "Infirm II":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Infirm\"]");
                        intRanks = 2;
                        break;
                    }
                case "Infirm III":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Infirm\"]");
                        intRanks = 3;
                        break;
                    }
                case "Infirm IV":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Infirm\"]");
                        intRanks = 4;
                        break;
                    }
                case "Infirm V":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Infirm\"]");
                        intRanks = 5;
                        break;
                    }
                case "Shiva Arms (1 Pair)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Shiva Arms (Pair)\"]");
                        intRanks = 1;
                        break;
                    }
                case "Shiva Arms (2 Pair)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Shiva Arms (Pair)\"]");
                        intRanks = 2;
                        break;
                    }
                case "Arcane Arrester I":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Arcane Arrester\"]");
                        intRanks = 1;
                        break;
                    }
                case "Arcane Arrester II":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Arcane Arrester\"]");
                        intRanks = 2;
                        break;
                    }
                case "Pilot Origins (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Pilot Origins\"]");
                        intRanks = 1;
                        break;
                    }
                case "Pilot Origins (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Pilot Origins\"]");
                        intRanks = 2;
                        break;
                    }
                case "Pilot Origins (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Pilot Origins\"]");
                        intRanks = 3;
                        break;
                    }
                case "Social Appearance Anxiety (Rating 1)":
                    {
                        xmlNewQuality =
                            xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Social Appearance Anxiety\"]");
                        intRanks = 1;
                        break;
                    }
                case "Social Appearance Anxiety (Rating 2)":
                    {
                        xmlNewQuality =
                            xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Social Appearance Anxiety\"]");
                        intRanks = 2;
                        break;
                    }
                case "Social Appearance Anxiety (Rating 3)":
                    {
                        xmlNewQuality =
                            xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Social Appearance Anxiety\"]");
                        intRanks = 3;
                        break;
                    }
            }

            if (intRanks > 0)
            {
                using (LockObject.EnterWriteLock())
                {
                    for (int i = 0; i < intRanks; ++i)
                    {
                        Quality objQuality = new Quality(this);
                        try
                        {
                            if (i == 0 && xmlOldQuality.TryGetField("guid", Guid.TryParse, out Guid guidOld))
                            {
                                ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Quality,
                                                                      guidOld.ToString());
                                objQuality.SetGUID(guidOld);
                            }

                            QualitySource objQualitySource =
                                Quality.ConvertToQualitySource(xmlOldQuality["qualitysource"]?.InnerText);
                            objQuality.Create(xmlNewQuality, objQualitySource, _lstWeapons,
                                              xmlOldQuality["extra"]?.InnerText);
                            if (xmlOldQuality["bp"] != null
                                && int.TryParse(xmlOldQuality["bp"].InnerText, out int intOldBP))
                                objQuality.BP = intOldBP / intRanks;

                            Qualities.Add(objQuality);
                        }
                        catch
                        {
                            objQuality.Dispose();
                            throw;
                        }
                    }
                }

                return true;
            }

            return false;
        }

        #endregion Old Quality Conversion Code

        #region Temporary Properties : Dashboard

        // This region is for properties that are applicable to the Dashboard
        /// <summary>
        /// The Current Initiative roll result including base Initiative
        /// <note>Dashboard</note>
        /// </summary>
        public int InitRoll { get; set; }

        /// <summary>
        /// The Initiative Passes that the player has
        /// <note>Dashboard</note>
        /// </summary>
        public int InitPasses
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    Interlocked.CompareExchange(ref _intInitPasses, InitiativeDice, int.MinValue);
                    return _intInitPasses;
                }
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _intInitPasses, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        private int _intInitPasses = int.MinValue;

        /// <summary>
        /// True iff the character is currently delaying an action
        /// <note>Dashboard</note>
        /// </summary>
        public bool Delayed { get; set; }

        /// <summary>
        /// The current name and initiative of the character
        /// </summary>
        public string DisplayInit
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return Name + " : " + InitRoll.ToString(GlobalSettings.CultureInfo);
            }
        }

        /// <summary>
        /// The initial Initiative of the character
        /// <note>Dashboard</note>
        /// </summary>
        public int InitialInit { get; set; }

        #endregion Temporary Properties : Dashboard

        #region Temporary Properties

        /// <summary>
        /// Takes a semicolon-separated list of book codes and returns a formatted string with displaynames.
        /// </summary>
        /// <param name="strInput"></param>
        /// <param name="strLanguage">Language to fetch</param>
        public string TranslatedBookList(string strInput, string strLanguage = "")
        {
            if (string.IsNullOrEmpty(strInput))
                return string.Empty;
            List<string> lstBooks = new List<string>();
            // Load the Sourcebook information.
            XPathNavigator objXmlDocument = LoadDataXPath("books.xml", strLanguage);

            foreach (string strBook in strInput.TrimEndOnce(';')
                                               .SplitNoAlloc(';', StringSplitOptions.RemoveEmptyEntries))
            {
                XPathNavigator objXmlBook
                    = objXmlDocument.SelectSingleNodeAndCacheExpression("/chummer/books/book[code = " + strBook.CleanXPath() + ']');
                if (objXmlBook != null)
                {
                    string strToAppend = objXmlBook.SelectSingleNodeAndCacheExpression("translate")?.Value;
                    if (!string.IsNullOrEmpty(strToAppend))
                        lstBooks.Add(strToAppend);
                    else
                    {
                        strToAppend = objXmlBook.SelectSingleNodeAndCacheExpression("name")?.Value;
                        if (!string.IsNullOrEmpty(strToAppend))
                            lstBooks.Add(strToAppend);
                        else
                        {
                            strToAppend = objXmlBook.SelectSingleNodeAndCacheExpression("altcode")?.Value ?? strBook;
                            lstBooks.Add(LanguageManager.GetString("String_Unknown", strLanguage)
                                         + LanguageManager.GetString("String_Space", strLanguage) + '('
                                         + strToAppend + ')');
                        }
                    }
                }
                else
                {
                    lstBooks.Add(LanguageManager.GetString("String_Unknown", strLanguage)
                                 + LanguageManager.GetString("String_Space", strLanguage) + strBook);
                }
            }

            lstBooks.Sort();
            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdReturn))
            {
                foreach (string strToAppend in lstBooks)
                    sbdReturn.AppendLine(strToAppend);
                return sbdReturn.ToString();
            }
        }

        /// <summary>
        /// Takes a semicolon-separated list of book codes and returns a formatted string with displaynames.
        /// </summary>
        /// <param name="strInput"></param>
        /// <param name="strLanguage">Language to fetch</param>
        /// <param name="token">Cancellation token to use.</param>
        public async ValueTask<string> TranslatedBookListAsync(string strInput, string strLanguage = "",
                                                          CancellationToken token = default)
        {
            if (string.IsNullOrEmpty(strInput))
                return string.Empty;
            List<string> lstBooks = new List<string>();
            // Load the Sourcebook information.
            XPathNavigator objXmlDocument
                = await LoadDataXPathAsync("books.xml", strLanguage, token: token).ConfigureAwait(false);

            foreach (string strBook in strInput.TrimEndOnce(';')
                                               .SplitNoAlloc(';', StringSplitOptions.RemoveEmptyEntries))
            {
                XPathNavigator objXmlBook
                    = await objXmlDocument.SelectSingleNodeAndCacheExpressionAsync("/chummer/books/book[code = " + strBook.CleanXPath() + ']', token).ConfigureAwait(false);
                if (objXmlBook != null)
                {
                    string strToAppend = (await objXmlBook.SelectSingleNodeAndCacheExpressionAsync("translate", token)
                                                          .ConfigureAwait(false))?.Value;
                    if (!string.IsNullOrEmpty(strToAppend))
                        lstBooks.Add(strToAppend);
                    else
                    {
                        strToAppend = (await objXmlBook.SelectSingleNodeAndCacheExpressionAsync("name", token)
                                                       .ConfigureAwait(false))?.Value;
                        if (!string.IsNullOrEmpty(strToAppend))
                            lstBooks.Add(strToAppend);
                        else
                        {
                            strToAppend = (await objXmlBook.SelectSingleNodeAndCacheExpressionAsync("altcode", token)
                                                           .ConfigureAwait(false))?.Value ?? strBook;
                            lstBooks.Add(await LanguageManager
                                               .GetStringAsync("String_Unknown", strLanguage, token: token)
                                               .ConfigureAwait(false)
                                         + await LanguageManager
                                                 .GetStringAsync("String_Space", strLanguage, token: token)
                                                 .ConfigureAwait(false) + '('
                                         + strToAppend + ')');
                        }
                    }
                }
                else
                {
                    lstBooks.Add(await LanguageManager.GetStringAsync("String_Unknown", strLanguage, token: token)
                                                      .ConfigureAwait(false)
                                 + await LanguageManager.GetStringAsync("String_Space", strLanguage, token: token)
                                                        .ConfigureAwait(false) + strBook);
                }
            }

            lstBooks.Sort();
            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdReturn))
            {
                foreach (string strToAppend in lstBooks)
                    sbdReturn.AppendLine(strToAppend);
                return sbdReturn.ToString();
            }
        }

        #endregion Temporary Properties

        //Can't be at improvementmanager due reasons
        private readonly Lazy<ThreadSafeStack<string>> _stkPushText = new Lazy<ThreadSafeStack<string>>();

        /// <summary>
        /// Push a value that will be used instead of dialog instead in next <selecttext />
        /// </summary>
        public ThreadSafeStack<string> PushText
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _stkPushText.Value;
            }
        }

        private IHasMatrixAttributes _objActiveCommlink;

        /// <summary>
        /// The Active Commlink of the character. Returns null if character has no active commlink.
        /// </summary>
        public IHasMatrixAttributes ActiveCommlink
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _objActiveCommlink;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _objActiveCommlink, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        private IHasMatrixAttributes _objHomeNode;

        /// <summary>
        /// Home Node. Returns null if home node is not set to any item.
        /// </summary>
        public IHasMatrixAttributes HomeNode
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _objHomeNode;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _objHomeNode, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        [HubTag]
        public SkillsSection SkillsSection
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _objSkillsSection;
            }
        }

        public async ValueTask<SkillsSection> GetSkillsSectionAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _objSkillsSection;
        }

        public int RedlinerBonus
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    int intReturn = _intCachedRedlinerBonus;
                    while (intReturn == int.MinValue)
                    {
                        RefreshRedlinerImprovements();
                        intReturn = _intCachedRedlinerBonus;
                    }

                    return intReturn;
                }
            }
        }

        private bool RefreshRedlinerImprovements(CancellationToken token = default)
        {
            using (EnterReadLock.Enter(LockObject, token))
            {
                if (IsLoading) // If we are in the middle of loading, just queue a single refresh to happen at the end of the process
                {
                    EnqueuePostLoadMethod(RefreshRedlinerImprovements, token);
                    return true;
                }

                //Get attributes affected by redliner/cyber singularity seeker
                List<Improvement> lstSeekerImprovements = new List<Improvement>(Improvements.Count);
                lstSeekerImprovements.AddRange(ImprovementManager
                                               .GetCachedImprovementListForValueOf(
                                                   this, Improvement.ImprovementType.Attribute, token: token)
                                               .Where(objLoopImprovement =>
                                                          objLoopImprovement.SourceName.Contains("SEEKER")));
                lstSeekerImprovements.AddRange(ImprovementManager
                                               .GetCachedImprovementListForValueOf(
                                                   this, Improvement.ImprovementType.PhysicalCM, token: token)
                                               .Where(objLoopImprovement =>
                                                          objLoopImprovement.SourceName.Contains("SEEKER")));
                List<string> lstSeekerAttributes = ImprovementManager
                                                   .GetCachedImprovementListForValueOf(
                                                       this, Improvement.ImprovementType.Seeker, token: token)
                                                   .ConvertAll(objImprovement => objImprovement.ImprovedName);
                lstSeekerAttributes.RemoveAll(x => x != "BOX" && !AttributeSection.AttributeStrings.Contains(x));
                //if neither contains anything, it is safe to exit
                if (lstSeekerImprovements.Count == 0 && lstSeekerAttributes.Count == 0)
                {
                    _intCachedRedlinerBonus = 0;
                    return true;
                }

                //Calculate bonus from cyberlimbs
                int intCount = Cyberware.Sum(x => x.GetCyberlimbCount(Settings.RedlinerExcludes));

                intCount = Math.Min(intCount / 2, 2);
                using (LockObject.EnterWriteLock(token))
                {
                    _intCachedRedlinerBonus = lstSeekerAttributes.Any(x => x == "STR" || x == "AGI")
                        ? intCount
                        : 0;

                    if (lstSeekerImprovements.Count == lstSeekerAttributes.Count)
                    {
                        for (int i = lstSeekerAttributes.Count - 1; i >= 0; --i)
                        {
                            string strSeekerAttribute = "SEEKER_" + lstSeekerAttributes[i];
                            int intCountToTarget = strSeekerAttribute == "SEEKER_BOX" ? intCount * -3 : intCount;
                            Improvement objImprovement
                                = lstSeekerImprovements.Find(x => x.SourceName == strSeekerAttribute
                                                                  && x.Value == intCountToTarget);
                            if (objImprovement != null)
                            {
                                lstSeekerAttributes.RemoveAt(i);
                                lstSeekerImprovements.Remove(objImprovement);
                            }
                        }
                        if (lstSeekerImprovements.Count == 0 && lstSeekerAttributes.Count == 0)
                            return true;
                    }

                    //Improvement manager defines the functions needed to manipulate improvements
                    //When the locals (someday) gets moved to this class, this can be removed and use
                    //the local

                    // Remove which qualities have been removed or which values have changed
                    ImprovementManager.RemoveImprovements(this, lstSeekerImprovements, token: token);

                    try
                    {
                        // Add new improvements or old improvements with new values
                        foreach (string strAttribute in lstSeekerAttributes)
                        {
                            if (strAttribute == "BOX")
                            {
                                ImprovementManager.CreateImprovement(this, strAttribute,
                                                                     Improvement.ImprovementSource.Quality,
                                                                     "SEEKER_BOX",
                                                                     Improvement.ImprovementType.PhysicalCM,
                                                                     Guid.NewGuid()
                                                                         .ToString(
                                                                             "D", GlobalSettings.InvariantCultureInfo),
                                                                     intCount * -3, token: token);
                            }
                            else
                            {
                                ImprovementManager.CreateImprovement(this, strAttribute,
                                                                     Improvement.ImprovementSource.Quality,
                                                                     "SEEKER_" + strAttribute,
                                                                     Improvement.ImprovementType.Attribute,
                                                                     Guid.NewGuid()
                                                                         .ToString(
                                                                             "D", GlobalSettings.InvariantCultureInfo),
                                                                     intCount, 1, 0, 0,
                                                                     intCount, token: token);
                            }
                        }
                    }
                    catch
                    {
                        ImprovementManager.Rollback(this, CancellationToken.None);
                        throw;
                    }

                    ImprovementManager.Commit(this);
                }
                return true;
            }
        }

        public void RefreshEssenceLossImprovements(CancellationToken token = default)
        {
            using (EnterReadLock.Enter(LockObject, token))
            {
                // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
                if (IsLoading)
                    return;

                // Only worry about essence loss attribute modifiers if this character actually has any attributes that would be affected by essence loss
                // (which means EssenceAtSpecialStart is not set to decimal.MinValue)
                if (EssenceAtSpecialStart != decimal.MinValue)
                {
                    decimal decSpecialAttBurnMultiplier = 1.0m;
                    decimal decTotalSpecialAttBurnMultiplier = 1.0m;
                    List<Improvement> lstUsedImprovements =
                        ImprovementManager.GetCachedImprovementListForValueOf(
                            this, Improvement.ImprovementType.SpecialAttBurn, token: token);
                    if (lstUsedImprovements.Count != 0)
                    {
                        foreach (Improvement objImprovement in lstUsedImprovements)
                            decSpecialAttBurnMultiplier -= 1m - objImprovement.Value / 100m;
                    }

                    List<Improvement> lstUsedImprovements2 =
                        ImprovementManager.GetCachedImprovementListForValueOf(
                            this, Improvement.ImprovementType.SpecialAttTotalBurnMultiplier, token: token);
                    if (lstUsedImprovements2.Count != 0)
                    {
                        foreach (Improvement objImprovement in lstUsedImprovements2)
                            decTotalSpecialAttBurnMultiplier *= objImprovement.Value / 100m;
                    }

                    decimal decESSMag = Essence(true, "MAG", token);
                    decimal decESSRes = Essence(true, "RES", token);
                    decimal decESSDep = Essence(true, "DEP", token);
                    if (!Settings.DontRoundEssenceInternally)
                    {
                        int intESSDecimals = Settings.EssenceDecimals;
                        decESSMag = decimal.Round(decESSMag, intESSDecimals, MidpointRounding.AwayFromZero);
                        decESSRes = decimal.Round(decESSRes, intESSDecimals, MidpointRounding.AwayFromZero);
                        decESSDep = decimal.Round(decESSDep, intESSDecimals, MidpointRounding.AwayFromZero);
                    }

                    // Reduce a character's MAG and RES from Essence Loss.
                    decimal decMetatypeMaximumESS = ESS.MetatypeMaximum;
                    int intMagMaxReduction
                        = ((decMetatypeMaximumESS - decESSMag) * decSpecialAttBurnMultiplier
                                                               * decTotalSpecialAttBurnMultiplier).StandardRound();
                    int intResMaxReduction
                        = ((decMetatypeMaximumESS - decESSRes) * decSpecialAttBurnMultiplier
                                                               * decTotalSpecialAttBurnMultiplier).StandardRound();
                    int intDepMaxReduction
                        = ((decMetatypeMaximumESS - decESSDep) * decSpecialAttBurnMultiplier
                                                               * decTotalSpecialAttBurnMultiplier).StandardRound();
                    // Character has the option set where essence loss just acts as an augmented malus, so just replace old essence loss improvements with new ones that apply an augmented malus
                    // equal to the amount by which the attribute's maximum would normally be reduced.
                    if (Settings.SpecialKarmaCostBasedOnShownValue)
                    {
                        Improvement.ImprovementSource eEssenceLossSource = Created
                            ? Improvement.ImprovementSource.EssenceLoss
                            : Improvement.ImprovementSource.EssenceLossChargen;
                        using (LockObject.EnterWriteLock(token))
                        {
                            ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.EssenceLoss, token: token);
                            ImprovementManager.RemoveImprovements(
                                this, Improvement.ImprovementSource.EssenceLossChargen, token: token);
                            // With this house rule, Cyberadept Daemon just negates a penalty from Essence based on Grade instead of restoring Resonance, so delete all old improvements
                            ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.CyberadeptDaemon, token: token);
                            try
                            {
                                if (intMagMaxReduction != 0)
                                {
                                    ImprovementManager.CreateImprovement(this, "MAG", eEssenceLossSource, string.Empty,
                                                                         Improvement.ImprovementType.Attribute,
                                                                         string.Empty, 0,
                                                                         1, 0, 0, -intMagMaxReduction, token: token);
                                    ImprovementManager.CreateImprovement(
                                        this, "MAGAdept", eEssenceLossSource, string.Empty,
                                        Improvement.ImprovementType.Attribute,
                                        string.Empty, 0,
                                        1, 0, 0, -intMagMaxReduction, token: token);
                                    // If this is a Mystic Adept using special Mystic Adept PP rules (i.e. no second MAG attribute), Mystic Adepts lose PPs even if they have fewer PPs than their MAG
                                    if (UseMysticAdeptPPs)
                                        ImprovementManager.CreateImprovement(this, string.Empty, eEssenceLossSource,
                                                                             string.Empty,
                                                                             Improvement.ImprovementType
                                                                                 .AdeptPowerPoints,
                                                                             string.Empty, -intMagMaxReduction,
                                                                             token: token);
                                }

                                if (intResMaxReduction != 0)
                                {
                                    int intRESReduction = intResMaxReduction;
                                    if (TechnomancerEnabled && SubmersionGrade > 0 && ImprovementManager
                                            .GetCachedImprovementListForValueOf(this,
                                                Improvement.ImprovementType
                                                           .CyberadeptDaemon, token: token)
                                            .Count > 0)
                                    {
                                        decimal decNonCyberwareEssence = BiowareEssence + EssenceHole;
                                        int intMaxCyberadeptDaemonBonus = Math.Ceiling(decNonCyberwareEssence) ==
                                                                          Math.Floor(decNonCyberwareEssence)
                                            ? (int) Math.Ceiling(CyberwareEssence)
                                            : (int) Math.Floor(CyberwareEssence);
                                        int intCyberadeptDaemonBonus = 0;
                                        for (int i = 1; i <= SubmersionGrade; ++i)
                                        {
                                            intCyberadeptDaemonBonus += i.DivAwayFromZero(2);
                                        }

                                        intRESReduction
                                            -= Math.Min(intCyberadeptDaemonBonus, intMaxCyberadeptDaemonBonus);
                                        if (intRESReduction < 0)
                                            intRESReduction = 0;
                                    }

                                    if (intRESReduction != 0)
                                        ImprovementManager.CreateImprovement(
                                            this, "RES", eEssenceLossSource, string.Empty,
                                            Improvement.ImprovementType.Attribute,
                                            string.Empty, 0, 1, 0, 0, -intRESReduction, token: token);
                                }

                                if (intDepMaxReduction != 0)
                                {
                                    ImprovementManager.CreateImprovement(this, "DEP", eEssenceLossSource, string.Empty,
                                                                         Improvement.ImprovementType.Attribute,
                                                                         string.Empty, 0,
                                                                         1, 0, 0, -intDepMaxReduction, token: token);
                                }
                            }
                            catch
                            {
                                ImprovementManager.Rollback(this, CancellationToken.None);
                                throw;
                            }

                            if (intMagMaxReduction != 0 || intResMaxReduction != 0 || intDepMaxReduction != 0)
                                ImprovementManager.Commit(this);
                        }
                    }
                    // RAW Career mode: complicated. Similar to RAW Create mode, but with the extra possibility of burning current karma levels and/or PPs instead of pure minima reduction,
                    // plus the need to account for cases where a character will burn "past" 0 (i.e. to a current value that should be negative), but then upgrade to 1 afterwards.
                    else if (Created)
                    {
                        // "Base" minimum reduction. This is the amount by which the character's special attribute minima would be reduced across career and create modes if there wasn't any funny business
                        int intMagMinReduction
                            = ((EssenceAtSpecialStart - decESSMag) * decSpecialAttBurnMultiplier
                                                                   * decTotalSpecialAttBurnMultiplier)
                            .StandardRound();
                        int intResMinReduction
                            = ((EssenceAtSpecialStart - decESSRes) * decSpecialAttBurnMultiplier
                                                                   * decTotalSpecialAttBurnMultiplier)
                            .StandardRound();
                        int intDepMinReduction
                            = ((EssenceAtSpecialStart - decESSDep) * decSpecialAttBurnMultiplier
                                                                   * decTotalSpecialAttBurnMultiplier)
                            .StandardRound();

                        // This extra code is needed for legacy shims, to convert proper attribute values for characters who would end up having a higher level than their total attribute maxima
                        // They are extra amounts by which the relevant attributes' karma levels should be burned
                        int intExtraRESBurn = Math.Max(0,
                                                       Math.Max(
                                                           RES.Base + RES.FreeBase + RES.RawMinimum
                                                           + RES.AttributeValueModifiers,
                                                           RES.TotalMinimum) + RES.Karma - RES.TotalMaximum);
                        int intExtraDEPBurn = Math.Max(0,
                                                       Math.Max(
                                                           DEP.Base + DEP.FreeBase + DEP.RawMinimum
                                                           + DEP.AttributeValueModifiers,
                                                           DEP.TotalMinimum) + DEP.Karma - DEP.TotalMaximum);
                        int intExtraMAGBurn = Math.Max(0,
                                                       Math.Max(
                                                           MAG.Base + MAG.FreeBase + MAG.RawMinimum
                                                           + MAG.AttributeValueModifiers,
                                                           MAG.TotalMinimum) + MAG.Karma - MAG.TotalMaximum);
                        int intExtraMAGAdeptBurn = Math.Max(0,
                                                            Math.Max(
                                                                MAGAdept.Base + MAGAdept.FreeBase
                                                                              + MAGAdept.RawMinimum +
                                                                              MAGAdept.AttributeValueModifiers,
                                                                MAGAdept.TotalMinimum) + MAGAdept.Karma
                                                            - MAGAdept.TotalMaximum);
                        // Old values for minimum reduction from essence loss in career mode. These are used to determine if any karma needs to get burned.
                        int intOldRESCareerMinimumReduction = 0;
                        int intOldDEPCareerMinimumReduction = 0;
                        int intOldMAGCareerMinimumReduction = 0;
                        int intOldMAGAdeptCareerMinimumReduction = 0;
                        foreach (Improvement objImprovement in
                                 ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.Attribute, token: token))
                        {
                            if (objImprovement.ImproveSource == Improvement.ImprovementSource.EssenceLoss)
                            {
                                // Values get subtracted because negative modifier = positive reduction, positive modifier = negative reduction
                                // Augmented values also get factored in in case the character is switching off the option to treat essence loss as an augmented malus
                                switch (objImprovement.ImprovedName)
                                {
                                    case "RES":
                                        intOldRESCareerMinimumReduction -=
                                            objImprovement.Minimum + objImprovement.Augmented.StandardRound();
                                        break;

                                    case "DEP":
                                        intOldDEPCareerMinimumReduction -=
                                            objImprovement.Minimum + objImprovement.Augmented.StandardRound();
                                        break;

                                    case "MAG":
                                        intOldMAGCareerMinimumReduction -=
                                            objImprovement.Minimum + objImprovement.Augmented.StandardRound();
                                        break;

                                    case "MAGAdept":
                                        intOldMAGAdeptCareerMinimumReduction -=
                                            objImprovement.Minimum + objImprovement.Augmented.StandardRound();
                                        break;
                                }
                            }
                        }

                        using (LockObject.EnterWriteLock(token))
                        {
                            // Remove any Improvements from MAG, RES, and DEP from Essence Loss that were added in career.
                            ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.EssenceLoss, token: token);

                            // Career Minimum and Maximum reduction relies on whether there's any extra reduction since chargen.
                            // This is the step where create mode attribute loss regarding attribute maximum loss gets factored out.
                            int intMAGMaximumReduction
                                = intMagMaxReduction + MAG.TotalMaximum - MAG.MaximumNoEssenceLoss();
                            int intMAGAdeptMaximumReduction = intMagMaxReduction + MAGAdept.TotalMaximum
                                                              - MAGAdept.MaximumNoEssenceLoss();
                            int intRESMaximumReduction
                                = intResMaxReduction + RES.TotalMaximum - RES.MaximumNoEssenceLoss();
                            int intDEPMaximumReduction
                                = intDepMaxReduction + DEP.TotalMaximum - DEP.MaximumNoEssenceLoss();

                            if (intMagMaxReduction > 0
                                || intMagMinReduction > 0
                                || intMAGMaximumReduction != 0
                                || intMAGAdeptMaximumReduction != 0)
                            {
                                // This is the step where create mode attribute loss regarding attribute minimum loss gets factored out.
                                int intMAGMinimumReduction;
                                int intMAGAdeptMinimumReduction;
                                // If only maxima would be reduced, use the attribute's current total value instead of its current maximum, as this makes sure minima will only get reduced if the maximum reduction would eat into the current value
                                if (Settings.ESSLossReducesMaximumOnly)
                                {
                                    intMAGMinimumReduction = Math.Max(0,
                                                                      intMagMinReduction + MAG.TotalValue
                                                                      - MAG.MaximumNoEssenceLoss(true));
                                    intMAGAdeptMinimumReduction = Math.Max(0,
                                                                           intMagMinReduction + MAGAdept.TotalValue
                                                                           - MAGAdept.MaximumNoEssenceLoss(true));
                                }
                                else
                                {
                                    intMAGMinimumReduction =
                                        intMagMinReduction + MAG.TotalMaximum - MAG.MaximumNoEssenceLoss(true);
                                    intMAGAdeptMinimumReduction =
                                        intMagMinReduction + MAGAdept.TotalMaximum
                                        - MAGAdept.MaximumNoEssenceLoss(true);
                                }

                                // If the new MAG reduction is greater than the old one...
                                int intMAGMinimumReductionDelta
                                    = intMAGMinimumReduction - intOldMAGCareerMinimumReduction;
                                if (intMAGMinimumReductionDelta > 0)
                                {
                                    // ... and adding minimum reducing-improvements wouldn't do anything, start burning karma.
                                    if (intMAGMinimumReduction >
                                        MAG.Base + MAG.FreeBase + MAG.RawMinimum + MAG.AttributeValueModifiers)
                                    {
                                        // intMAGMinimumReduction is not actually reduced so that karma doesn't get burned away each time this function is called.
                                        // Besides, this only fires if intMAGMinimumReduction is already at a level where increasing it any more wouldn't have any effect on the character.
                                        intExtraMAGBurn += Math.Min(MAG.Karma, intMAGMinimumReductionDelta);
                                        MAG.Karma -= intExtraMAGBurn;
                                    }

                                    // Mystic Adept PPs may need to be burned away based on the change of our MAG attribute
                                    if (UseMysticAdeptPPs)
                                    {
                                        // First burn away PPs gained during chargen...
                                        int intChargenPPBurn =
                                            Math.Min(MysticAdeptPowerPoints, intMAGMinimumReductionDelta);
                                        MysticAdeptPowerPoints -= intChargenPPBurn;
                                        // ... now burn away PPs gained from initiations.
                                        decimal decPPBurn = Math.Min(intMAGMinimumReductionDelta - intChargenPPBurn,
                                                                     ImprovementManager.ValueOf(
                                                                         this,
                                                                         Improvement.ImprovementType.AdeptPowerPoints, token: token));
                                        // Source needs to be EssenceLossChargen so that it doesn't get wiped in career mode.
                                        if (decPPBurn != 0)
                                        {
                                            try
                                            {
                                                ImprovementManager.CreateImprovement(this, string.Empty,
                                                    Improvement.ImprovementSource
                                                               .EssenceLossChargen, string.Empty,
                                                    Improvement.ImprovementType
                                                               .AdeptPowerPoints, string.Empty,
                                                    -decPPBurn, token: token);
                                            }
                                            catch
                                            {
                                                ImprovementManager.Rollback(this, CancellationToken.None);
                                                throw;
                                            }

                                            ImprovementManager.Commit(this);
                                        }
                                    }
                                }
                                // If the new MAG reduction is less than our old one, the character doesn't actually get any new values back
                                else
                                {
                                    intMAGMinimumReduction = intOldMAGCareerMinimumReduction;
                                }

                                // Make sure we only attempt to burn MAGAdept karma levels if it's actually a separate attribute from MAG
                                if (MAGAdept != MAG)
                                {
                                    // If the new MAGAdept reduction is greater than the old one...
                                    int intMAGAdeptMinimumReductionDelta =
                                        intMAGAdeptMinimumReduction - intOldMAGAdeptCareerMinimumReduction;
                                    if (intMAGAdeptMinimumReductionDelta > 0)
                                    {
                                        // ... and adding minimum reducing-improvements wouldn't do anything, start burning karma.
                                        if (intMAGAdeptMinimumReduction > MAGAdept.Base + MAGAdept.FreeBase +
                                            MAGAdept.RawMinimum + MAGAdept.AttributeValueModifiers)
                                        {
                                            // intMAGAdeptMinimumReduction is not actually reduced so that karma doesn't get burned away each time this function is called.
                                            // Besides, this only fires if intMAGAdeptMinimumReduction is already at a level where increasing it any more wouldn't have any effect on the character.
                                            intExtraMAGAdeptBurn += Math.Min(MAGAdept.Karma,
                                                                             intMAGAdeptMinimumReductionDelta);
                                            MAGAdept.Karma -= intExtraMAGAdeptBurn;
                                        }
                                    }
                                    // If the new MAGAdept reduction is less than our old one, the character doesn't actually get any new values back
                                    else
                                    {
                                        intMAGAdeptMinimumReduction = intOldMAGAdeptCareerMinimumReduction;
                                    }
                                }
                                // Otherwise make sure that if the new MAGAdept reduction is less than our old one, the character doesn't actually get any new values back
                                else if (intMAGAdeptMinimumReduction < intOldMAGAdeptCareerMinimumReduction)
                                {
                                    intMAGAdeptMinimumReduction = intOldMAGAdeptCareerMinimumReduction;
                                }

                                // Create Improvements
                                try
                                {
                                    if (intMAGMinimumReduction != 0 || intMAGMaximumReduction != 0)
                                        ImprovementManager.CreateImprovement(this, "MAG",
                                                                             Improvement.ImprovementSource.EssenceLoss,
                                                                             string.Empty,
                                                                             Improvement.ImprovementType.Attribute,
                                                                             string.Empty, 0, 1,
                                                                             -intMAGMinimumReduction,
                                                                             -intMAGMaximumReduction, token: token);
                                    if (intMAGAdeptMinimumReduction != 0 || intMAGAdeptMaximumReduction != 0)
                                        ImprovementManager.CreateImprovement(this, "MAGAdept",
                                                                             Improvement.ImprovementSource.EssenceLoss,
                                                                             string.Empty,
                                                                             Improvement.ImprovementType.Attribute,
                                                                             string.Empty, 0, 1,
                                                                             -intMAGAdeptMinimumReduction,
                                                                             -intMAGAdeptMaximumReduction,
                                                                             token: token);
                                }
                                catch
                                {
                                    ImprovementManager.Rollback(this, CancellationToken.None);
                                    throw;
                                }

                                if (intMAGMinimumReduction != 0 || intMAGMaximumReduction != 0 ||
                                    intMAGAdeptMinimumReduction != 0 || intMAGAdeptMaximumReduction != 0)
                                    ImprovementManager.Commit(this);
                            }

                            // Create the Essence Loss (or gain, in case of essence restoration and increasing maxima) Improvements.
                            if (intResMaxReduction > 0
                                || intResMinReduction > 0
                                || intRESMaximumReduction != 0)
                            {
                                // This is the step where create mode attribute loss regarding attribute minimum loss gets factored out.
                                int intRESMinimumReduction;
                                // If only maxima would be reduced, use the attribute's current total value instead of its current maximum, as this makes sure minima will only get reduced if the maximum reduction would eat into the current value
                                if (Settings.ESSLossReducesMaximumOnly)
                                {
                                    intRESMinimumReduction = Math.Max(0,
                                                                      intResMinReduction + RES.TotalValue
                                                                      - RES.MaximumNoEssenceLoss(true));
                                }
                                else
                                {
                                    intRESMinimumReduction =
                                        intResMinReduction + RES.TotalMaximum - RES.MaximumNoEssenceLoss(true);
                                }

                                // If the new RES reduction is greater than the old one...
                                int intRESMinimumReductionDelta
                                    = intRESMinimumReduction - intOldRESCareerMinimumReduction;
                                if (intRESMinimumReductionDelta > 0)
                                {
                                    // ... and adding minimum reducing-improvements wouldn't do anything, start burning karma.
                                    if (intRESMinimumReduction >
                                        RES.Base + RES.FreeBase + RES.RawMinimum + RES.AttributeValueModifiers)
                                    {
                                        // intRESMinimumReduction is not actually reduced so that karma doesn't get burned away each time this function is called.
                                        // Besides, this only fires if intRESMinimumReduction is already at a level where increasing it any more wouldn't have any effect on the character.
                                        intExtraRESBurn += Math.Min(RES.Karma, intRESMinimumReductionDelta);
                                        RES.Karma -= intExtraRESBurn;
                                    }
                                }
                                // If the new RES reduction is less than our old one, the character doesn't actually get any new values back
                                else
                                {
                                    intRESMinimumReduction = intOldRESCareerMinimumReduction;
                                }

                                // Create Improvements
                                if (intRESMinimumReduction != 0 || intRESMaximumReduction != 0)
                                {
                                    try
                                    {
                                        ImprovementManager.CreateImprovement(this, "RES",
                                                                             Improvement.ImprovementSource.EssenceLoss,
                                                                             string.Empty,
                                                                             Improvement.ImprovementType.Attribute,
                                                                             string.Empty, 0, 1,
                                                                             -intRESMinimumReduction,
                                                                             -intRESMaximumReduction, token: token);
                                    }
                                    catch
                                    {
                                        ImprovementManager.Rollback(this, CancellationToken.None);
                                        throw;
                                    }
                                    ImprovementManager.Commit(this);
                                }
                            }

                            if (intDepMaxReduction > 0
                                || intDepMinReduction > 0
                                || intDEPMaximumReduction != 0)
                            {
                                // This is the step where create mode attribute loss regarding attribute minimum loss gets factored out.
                                int intDEPMinimumReduction;
                                // If only maxima would be reduced, use the attribute's current total value instead of its current maximum, as this makes sure minima will only get reduced if the maximum reduction would eat into the current value
                                if (Settings.ESSLossReducesMaximumOnly)
                                {
                                    intDEPMinimumReduction = Math.Max(0,
                                                                      intDepMinReduction + DEP.TotalValue
                                                                      - DEP.MaximumNoEssenceLoss(true));
                                }
                                else
                                {
                                    intDEPMinimumReduction =
                                        intDepMinReduction + DEP.TotalMaximum - DEP.MaximumNoEssenceLoss(true);
                                }

                                // If the new DEP reduction is greater than the old one...
                                int intDEPMinimumReductionDelta
                                    = intDEPMinimumReduction - intOldDEPCareerMinimumReduction;
                                if (intDEPMinimumReductionDelta > 0)
                                {
                                    // ... and adding minimum reducing-improvements wouldn't do anything, start burning karma.
                                    if (intDEPMinimumReduction >
                                        DEP.Base + DEP.FreeBase + DEP.RawMinimum + DEP.AttributeValueModifiers)
                                    {
                                        // intDEPMinimumReduction is not actually reduced so that karma doesn't get burned away each time this function is called.
                                        // Besides, this only fires if intDEPMinimumReduction is already at a level where increasing it any more wouldn't have any effect on the character.
                                        intExtraDEPBurn += Math.Min(DEP.Karma, intDEPMinimumReductionDelta);
                                        DEP.Karma -= intExtraDEPBurn;
                                    }
                                }
                                // If the new DEP reduction is less than our old one, the character doesn't actually get any new values back
                                else
                                {
                                    intDEPMinimumReduction = intOldDEPCareerMinimumReduction;
                                }

                                // Create Improvements
                                if (intDEPMinimumReduction != 0 || intDEPMaximumReduction != 0)
                                {
                                    try
                                    {
                                        ImprovementManager.CreateImprovement(this, "DEP",
                                                                             Improvement.ImprovementSource.EssenceLoss,
                                                                             string.Empty,
                                                                             Improvement.ImprovementType.Attribute,
                                                                             string.Empty, 0, 1,
                                                                             -intDEPMinimumReduction,
                                                                             -intDEPMaximumReduction, token: token);
                                    }
                                    catch
                                    {
                                        ImprovementManager.Rollback(this, CancellationToken.None);
                                        throw;
                                    }

                                    ImprovementManager.Commit(this);
                                }
                            }
                        }
                    }
                    // RAW Create mode: Reduce maxima based on max ESS - current ESS, reduce minima based on their essence from the most optimal way in which they could have gotten access to special attributes
                    else
                    {
                        int intMagMinReduction
                            = ((EssenceAtSpecialStart - decESSMag) * decSpecialAttBurnMultiplier
                                                                   * decTotalSpecialAttBurnMultiplier)
                            .StandardRound();
                        int intResMinReduction
                            = ((EssenceAtSpecialStart - decESSRes) * decSpecialAttBurnMultiplier
                                                                   * decTotalSpecialAttBurnMultiplier)
                            .StandardRound();
                        int intDepMinReduction
                            = ((EssenceAtSpecialStart - decESSDep) * decSpecialAttBurnMultiplier
                                                                   * decTotalSpecialAttBurnMultiplier)
                            .StandardRound();
                        int intRESMinimumReduction = intResMinReduction;
                        int intDEPMinimumReduction = intDepMinReduction;
                        int intMAGMinimumReduction = intMagMinReduction;
                        int intMAGAdeptMinimumReduction = intMagMinReduction;
                        if (Settings.ESSLossReducesMaximumOnly)
                        {
                            intMAGMinimumReduction =
                                Math.Max(0, intMagMinReduction + MAG.TotalValue - MAG.TotalMaximum);
                            intMAGAdeptMinimumReduction = Math.Max(0,
                                                                   intMagMinReduction + MAGAdept.TotalValue
                                                                   - MAGAdept.TotalMaximum);
                            intRESMinimumReduction
                                = Math.Max(0, intResMinReduction + RES.TotalValue - RES.TotalMaximum);
                            intDEPMinimumReduction
                                = Math.Max(0, intDepMinReduction + DEP.TotalValue - DEP.TotalMaximum);
                        }

                        using (LockObject.EnterWriteLock(token))
                        {
                            ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.EssenceLoss, token: token);
                            ImprovementManager.RemoveImprovements(
                                this, Improvement.ImprovementSource.EssenceLossChargen, token: token);

                            if (intMagMaxReduction != 0 || intMAGMinimumReduction != 0
                                                        || intMAGAdeptMinimumReduction != 0)
                            {
                                ImprovementManager.CreateImprovement(this, "MAG",
                                                                     Improvement.ImprovementSource.EssenceLossChargen,
                                                                     string.Empty,
                                                                     Improvement.ImprovementType.Attribute,
                                                                     string.Empty, 0, 1, -intMAGMinimumReduction,
                                                                     -intMagMaxReduction, token: token);
                                ImprovementManager.CreateImprovement(this, "MAGAdept",
                                                                     Improvement.ImprovementSource.EssenceLossChargen,
                                                                     string.Empty,
                                                                     Improvement.ImprovementType.Attribute,
                                                                     string.Empty, 0, 1, -intMAGAdeptMinimumReduction,
                                                                     -intMagMaxReduction, token: token);
                            }

                            try
                            {
                                if (intResMaxReduction != 0 || intRESMinimumReduction != 0)
                                {
                                    ImprovementManager.CreateImprovement(this, "RES",
                                                                         Improvement.ImprovementSource
                                                                             .EssenceLossChargen,
                                                                         string.Empty,
                                                                         Improvement.ImprovementType.Attribute,
                                                                         string.Empty, 0, 1, -intRESMinimumReduction,
                                                                         -intResMaxReduction, token: token);
                                }

                                if (intDepMaxReduction != 0 || intDEPMinimumReduction != 0)
                                {
                                    ImprovementManager.CreateImprovement(this, "DEP",
                                                                         Improvement.ImprovementSource
                                                                             .EssenceLossChargen,
                                                                         string.Empty,
                                                                         Improvement.ImprovementType.Attribute,
                                                                         string.Empty, 0, 1, -intDEPMinimumReduction,
                                                                         -intDepMaxReduction, token: token);
                                }
                            }
                            catch
                            {
                                ImprovementManager.Rollback(this, CancellationToken.None);
                                throw;
                            }

                            ImprovementManager.Commit(this);
                        }

                        // If the character is in Career mode, it is possible for them to be forced to burn out.
                        if (Created)
                        {
                            // If the CharacterAttribute reaches 0, the character has burned out.
                            if (MAGEnabled)
                            {
                                if (Settings.SpecialKarmaCostBasedOnShownValue)
                                {
                                    if (Settings.MysAdeptSecondMAGAttribute && IsMysticAdept)
                                    {
                                        if (intMagMaxReduction >= MAG.TotalMaximum)
                                        {
                                            MAG.AssignBaseKarmaLimits(MAGAdept.Base, MAGAdept.Karma,
                                                                      MAGAdept.RawMetatypeMinimum,
                                                                      MAGAdept.RawMetatypeMaximum,
                                                                      MAGAdept.RawMetatypeAugmentedMaximum);
                                            MAGAdept.AssignBaseKarmaLimits(0, 0, 0, 0, 0);

                                            MagicianEnabled = false;
                                        }

                                        if (intMagMaxReduction >= MAGAdept.TotalMaximum)
                                        {
                                            MAGAdept.AssignBaseKarmaLimits(0, 0, 0, 0, 0);

                                            AdeptEnabled = false;
                                        }

                                        if (!MagicianEnabled && !AdeptEnabled)
                                            MAGEnabled = false;
                                    }
                                    else if (intMagMaxReduction >= MAG.TotalMaximum)
                                    {
                                        MAG.AssignBaseKarmaLimits(0, 0, 0, 0, 0);

                                        MagicianEnabled = false;
                                        AdeptEnabled = false;
                                        MAGEnabled = false;
                                    }
                                }
                                else if (Settings.MysAdeptSecondMAGAttribute && IsMysticAdept)
                                {
                                    if (MAG.TotalMaximum < 1)
                                    {
                                        MAG.AssignBaseKarmaLimits(MAGAdept.Base, MAGAdept.Karma,
                                                                  MAGAdept.RawMetatypeMinimum,
                                                                  MAGAdept.RawMetatypeMaximum,
                                                                  MAGAdept.RawMetatypeAugmentedMaximum);
                                        MAGAdept.AssignBaseKarmaLimits(0, 0, 0, 0, 0);

                                        MagicianEnabled = false;
                                    }

                                    if (MAGAdept.TotalMaximum < 1)
                                    {
                                        MAGAdept.AssignBaseKarmaLimits(0, 0, 0, 0, 0);

                                        AdeptEnabled = false;
                                    }

                                    if (!MagicianEnabled && !AdeptEnabled)
                                        MAGEnabled = false;
                                }
                                else if (MAG.TotalMaximum < 1)
                                {
                                    MAG.AssignBaseKarmaLimits(0, 0, 0, 0, 0);

                                    MagicianEnabled = false;
                                    AdeptEnabled = false;
                                    MAGEnabled = false;
                                }
                            }

                            if (RESEnabled
                                && (Settings.SpecialKarmaCostBasedOnShownValue
                                    && intResMaxReduction >= RES.TotalMaximum
                                    || !Settings.SpecialKarmaCostBasedOnShownValue
                                    && RES.TotalMaximum < 1))
                            {
                                RES.AssignBaseKarmaLimits(0, 0, 0, 0, 0);

                                RESEnabled = false;
                                TechnomancerEnabled = false;
                            }
                        }
                    }
                }
                // Otherwise any essence loss improvements that might have been left need to be deleted (e.g. character is in create mode and had access to special attributes, but that access was removed)
                else
                {
                    using (LockObject.EnterWriteLock(token))
                    {
                        try
                        {
                            ImprovementManager.RemoveImprovements(
                                this, Improvement.ImprovementSource.EssenceLossChargen, token: token);
                            ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.EssenceLoss,
                                                                  token: token);
                        }
                        catch
                        {
                            ImprovementManager.Rollback(this, CancellationToken.None);
                            throw;
                        }

                        ImprovementManager.Commit(this);
                    }
                }

                // If the character is Cyberzombie, adjust their Attributes based on their Essence.
                if (MetatypeCategory == "Cyberzombie")
                {
                    int intESSModifier = (-Essence(token: token)).StandardRound();
                    using (LockObject.EnterWriteLock(token))
                    {
                        ImprovementManager.RemoveImprovements(this,
                                                              Improvements.Where(x =>
                                                                  x.ImproveSource == Improvement
                                                                      .ImprovementSource
                                                                      .Cyberzombie &&
                                                                  x.ImproveType == Improvement
                                                                      .ImprovementType
                                                                      .Attribute).ToList(), token: token);
                        if (intESSModifier != 0)
                        {
                            try
                            {
                                ImprovementManager.CreateImprovement(this, "BOD",
                                                                     Improvement.ImprovementSource.Cyberzombie,
                                                                     string.Empty,
                                                                     Improvement.ImprovementType.Attribute,
                                                                     string.Empty, 0, 1, 0, intESSModifier,
                                                                     token: token);
                                ImprovementManager.CreateImprovement(this, "AGI",
                                                                     Improvement.ImprovementSource.Cyberzombie,
                                                                     string.Empty,
                                                                     Improvement.ImprovementType.Attribute,
                                                                     string.Empty, 0, 1, 0, intESSModifier,
                                                                     token: token);
                                ImprovementManager.CreateImprovement(this, "REA",
                                                                     Improvement.ImprovementSource.Cyberzombie,
                                                                     string.Empty,
                                                                     Improvement.ImprovementType.Attribute,
                                                                     string.Empty, 0, 1, 0, intESSModifier,
                                                                     token: token);
                                ImprovementManager.CreateImprovement(this, "STR",
                                                                     Improvement.ImprovementSource.Cyberzombie,
                                                                     string.Empty,
                                                                     Improvement.ImprovementType.Attribute,
                                                                     string.Empty, 0, 1, 0, intESSModifier,
                                                                     token: token);
                                ImprovementManager.CreateImprovement(this, "CHA",
                                                                     Improvement.ImprovementSource.Cyberzombie,
                                                                     string.Empty,
                                                                     Improvement.ImprovementType.Attribute,
                                                                     string.Empty, 0, 1, 0, intESSModifier,
                                                                     token: token);
                                ImprovementManager.CreateImprovement(this, "INT",
                                                                     Improvement.ImprovementSource.Cyberzombie,
                                                                     string.Empty,
                                                                     Improvement.ImprovementType.Attribute,
                                                                     string.Empty, 0, 1, 0, intESSModifier,
                                                                     token: token);
                                ImprovementManager.CreateImprovement(this, "LOG",
                                                                     Improvement.ImprovementSource.Cyberzombie,
                                                                     string.Empty,
                                                                     Improvement.ImprovementType.Attribute,
                                                                     string.Empty, 0, 1, 0, intESSModifier,
                                                                     token: token);
                                ImprovementManager.CreateImprovement(this, "WIL",
                                                                     Improvement.ImprovementSource.Cyberzombie,
                                                                     string.Empty,
                                                                     Improvement.ImprovementType.Attribute,
                                                                     string.Empty, 0, 1, 0, intESSModifier,
                                                                     token: token);
                            }
                            catch
                            {
                                ImprovementManager.Rollback(this, CancellationToken.None);
                                throw;
                            }

                            ImprovementManager.Commit(this);
                        }
                    }
                }
            }
        }

        public async ValueTask RefreshEssenceLossImprovementsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
                if (IsLoading)
                    return;

                // Only worry about essence loss attribute modifiers if this character actually has any attributes that would be affected by essence loss
                // (which means EssenceAtSpecialStart is not set to decimal.MinValue)
                if (EssenceAtSpecialStart != decimal.MinValue)
                {
                    decimal decSpecialAttBurnMultiplier = 1.0m;
                    decimal decTotalSpecialAttBurnMultiplier = 1.0m;
                    List<Improvement> lstUsedImprovements =
                        await ImprovementManager
                              .GetCachedImprovementListForValueOfAsync(
                                  this, Improvement.ImprovementType.SpecialAttBurn, token: token)
                              .ConfigureAwait(false);
                    if (lstUsedImprovements.Count != 0)
                    {
                        foreach (Improvement objImprovement in lstUsedImprovements)
                            decSpecialAttBurnMultiplier -= 1m - objImprovement.Value / 100m;
                    }

                    List<Improvement> lstUsedImprovements2 =
                        await ImprovementManager
                              .GetCachedImprovementListForValueOfAsync(
                                  this, Improvement.ImprovementType.SpecialAttTotalBurnMultiplier, token: token)
                              .ConfigureAwait(false);
                    if (lstUsedImprovements2.Count != 0)
                    {
                        foreach (Improvement objImprovement in lstUsedImprovements2)
                            decTotalSpecialAttBurnMultiplier *= objImprovement.Value / 100m;
                    }

                    decimal decESSMag = await EssenceAsync(true, "MAG", token).ConfigureAwait(false);
                    decimal decESSRes = await EssenceAsync(true, "RES", token).ConfigureAwait(false);
                    decimal decESSDep = await EssenceAsync(true, "DEP", token).ConfigureAwait(false);
                    if (!Settings.DontRoundEssenceInternally)
                    {
                        int intESSDecimals = Settings.EssenceDecimals;
                        decESSMag = decimal.Round(decESSMag, intESSDecimals, MidpointRounding.AwayFromZero);
                        decESSRes = decimal.Round(decESSRes, intESSDecimals, MidpointRounding.AwayFromZero);
                        decESSDep = decimal.Round(decESSDep, intESSDecimals, MidpointRounding.AwayFromZero);
                    }

                    // Reduce a character's MAG and RES from Essence Loss.
                    decimal decMetatypeMaximumESS = await ESS.GetMetatypeMaximumAsync(token).ConfigureAwait(false);
                    int intMagMaxReduction
                        = ((decMetatypeMaximumESS - decESSMag) * decSpecialAttBurnMultiplier
                                                               * decTotalSpecialAttBurnMultiplier).StandardRound();
                    int intResMaxReduction
                        = ((decMetatypeMaximumESS - decESSRes) * decSpecialAttBurnMultiplier
                                                               * decTotalSpecialAttBurnMultiplier).StandardRound();
                    int intDepMaxReduction
                        = ((decMetatypeMaximumESS - decESSDep) * decSpecialAttBurnMultiplier
                                                               * decTotalSpecialAttBurnMultiplier).StandardRound();
                    // Character has the option set where essence loss just acts as an augmented malus, so just replace old essence loss improvements with new ones that apply an augmented malus
                    // equal to the amount by which the attribute's maximum would normally be reduced.
                    if (Settings.SpecialKarmaCostBasedOnShownValue)
                    {
                        Improvement.ImprovementSource eEssenceLossSource = Created
                            ? Improvement.ImprovementSource.EssenceLoss
                            : Improvement.ImprovementSource.EssenceLossChargen;
                        IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                        try
                        {
                            await ImprovementManager.RemoveImprovementsAsync(
                                                        this, Improvement.ImprovementSource.EssenceLoss,
                                                        token: token)
                                                    .ConfigureAwait(false);
                            await ImprovementManager.RemoveImprovementsAsync(
                                                        this, Improvement.ImprovementSource.EssenceLossChargen,
                                                        token: token)
                                                    .ConfigureAwait(false);
                            // With this house rule, Cyberadept Daemon just negates a penalty from Essence based on Grade instead of restoring Resonance, so delete all old improvements
                            await ImprovementManager.RemoveImprovementsAsync(
                                                        this, Improvement.ImprovementSource.CyberadeptDaemon,
                                                        token: token)
                                                    .ConfigureAwait(false);

                            try
                            {
                                if (intMagMaxReduction != 0)
                                {
                                    await ImprovementManager.CreateImprovementAsync(
                                        this, "MAG", eEssenceLossSource, string.Empty,
                                        Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, 0,
                                        -intMagMaxReduction, token: token).ConfigureAwait(false);
                                    await ImprovementManager.CreateImprovementAsync(
                                        this, "MAGAdept", eEssenceLossSource, string.Empty,
                                        Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, 0,
                                        -intMagMaxReduction, token: token).ConfigureAwait(false);
                                    // If this is a Mystic Adept using special Mystic Adept PP rules (i.e. no second MAG attribute), Mystic Adepts lose PPs even if they have fewer PPs than their MAG
                                    if (UseMysticAdeptPPs)
                                        await ImprovementManager.CreateImprovementAsync(
                                            this, string.Empty, eEssenceLossSource,
                                            string.Empty,
                                            Improvement.ImprovementType.AdeptPowerPoints, string.Empty,
                                            -intMagMaxReduction,
                                            token: token).ConfigureAwait(false);
                                }

                                if (intResMaxReduction != 0)
                                {
                                    int intRESReduction = intResMaxReduction;
                                    if (TechnomancerEnabled && SubmersionGrade > 0 && (await ImprovementManager
                                            .GetCachedImprovementListForValueOfAsync(this,
                                                Improvement.ImprovementType
                                                           .CyberadeptDaemon, token: token).ConfigureAwait(false))
                                        .Count > 0)
                                    {
                                        decimal decNonCyberwareEssence = BiowareEssence + EssenceHole;
                                        int intMaxCyberadeptDaemonBonus = Math.Ceiling(decNonCyberwareEssence) ==
                                                                          Math.Floor(decNonCyberwareEssence)
                                            ? (int) Math.Ceiling(CyberwareEssence)
                                            : (int) Math.Floor(CyberwareEssence);
                                        int intCyberadeptDaemonBonus = 0;
                                        for (int i = 1; i <= SubmersionGrade; ++i)
                                        {
                                            intCyberadeptDaemonBonus += i.DivAwayFromZero(2);
                                        }

                                        intRESReduction
                                            -= Math.Min(intCyberadeptDaemonBonus, intMaxCyberadeptDaemonBonus);
                                        if (intRESReduction < 0)
                                            intRESReduction = 0;
                                    }

                                    if (intRESReduction != 0)
                                        await ImprovementManager.CreateImprovementAsync(
                                            this, "RES", eEssenceLossSource, string.Empty,
                                            Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, 0,
                                            -intRESReduction, token: token).ConfigureAwait(false);
                                }

                                if (intDepMaxReduction != 0)
                                {
                                    await ImprovementManager.CreateImprovementAsync(
                                        this, "DEP", eEssenceLossSource, string.Empty,
                                        Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, 0,
                                        -intDepMaxReduction, token: token).ConfigureAwait(false);
                                }
                            }
                            catch
                            {
                                await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                                throw;
                            }

                            if (intMagMaxReduction != 0 || intResMaxReduction != 0 || intDepMaxReduction != 0)
                                ImprovementManager.Commit(this);
                        }
                        finally
                        {
                            await objLocker.DisposeAsync().ConfigureAwait(false);
                        }
                    }
                    // RAW Career mode: complicated. Similar to RAW Create mode, but with the extra possibility of burning current karma levels and/or PPs instead of pure minima reduction,
                    // plus the need to account for cases where a character will burn "past" 0 (i.e. to a current value that should be negative), but then upgrade to 1 afterwards.
                    else if (Created)
                    {
                        // "Base" minimum reduction. This is the amount by which the character's special attribute minima would be reduced across career and create modes if there wasn't any funny business
                        int intMagMinReduction
                            = ((EssenceAtSpecialStart - decESSMag) * decSpecialAttBurnMultiplier
                                                                   * decTotalSpecialAttBurnMultiplier)
                            .StandardRound();
                        int intResMinReduction
                            = ((EssenceAtSpecialStart - decESSRes) * decSpecialAttBurnMultiplier
                                                                   * decTotalSpecialAttBurnMultiplier)
                            .StandardRound();
                        int intDepMinReduction
                            = ((EssenceAtSpecialStart - decESSDep) * decSpecialAttBurnMultiplier
                                                                   * decTotalSpecialAttBurnMultiplier)
                            .StandardRound();

                        // This extra code is needed for legacy shims, to convert proper attribute values for characters who would end up having a higher level than their total attribute maxima
                        // They are extra amounts by which the relevant attributes' karma levels should be burned
                        int intExtraRESBurn = Math.Max(0,
                                                       Math.Max(
                                                           RES.Base + await RES.GetFreeBaseAsync(token)
                                                                               .ConfigureAwait(false)
                                                                    + await RES.GetRawMinimumAsync(token)
                                                                               .ConfigureAwait(false)
                                                                    + await RES.GetAttributeValueModifiersAsync(
                                                                                   token)
                                                                               .ConfigureAwait(false),
                                                           await RES.GetTotalMinimumAsync(token)
                                                                    .ConfigureAwait(false)) + RES.Karma
                                                       - await RES.GetTotalMaximumAsync(token)
                                                                  .ConfigureAwait(false));
                        int intExtraDEPBurn = Math.Max(0,
                                                       Math.Max(
                                                           DEP.Base + await DEP.GetFreeBaseAsync(token)
                                                                               .ConfigureAwait(false)
                                                                    + await DEP.GetRawMinimumAsync(token)
                                                                               .ConfigureAwait(false)
                                                                    + await DEP.GetAttributeValueModifiersAsync(
                                                                                   token)
                                                                               .ConfigureAwait(false),
                                                           await DEP.GetTotalMinimumAsync(token)
                                                                    .ConfigureAwait(false)) + DEP.Karma
                                                       - await DEP.GetTotalMaximumAsync(token)
                                                                  .ConfigureAwait(false));
                        int intExtraMAGBurn = Math.Max(0,
                                                       Math.Max(
                                                           MAG.Base + await MAG.GetFreeBaseAsync(token)
                                                                               .ConfigureAwait(false)
                                                                    + await MAG.GetRawMinimumAsync(token)
                                                                               .ConfigureAwait(false)
                                                                    + await MAG.GetAttributeValueModifiersAsync(
                                                                                   token)
                                                                               .ConfigureAwait(false),
                                                           await MAG.GetTotalMinimumAsync(token)
                                                                    .ConfigureAwait(false)) + MAG.Karma
                                                       - await MAG.GetTotalMaximumAsync(token)
                                                                  .ConfigureAwait(false));
                        int intExtraMAGAdeptBurn = MAG == MAGAdept
                            ? intExtraMAGBurn
                            : Math.Max(0,
                                       Math.Max(
                                           MAGAdept.Base
                                           + await MAGAdept.GetFreeBaseAsync(token).ConfigureAwait(false)
                                           + await MAGAdept.GetRawMinimumAsync(token).ConfigureAwait(false)
                                           +
                                           await MAGAdept.GetAttributeValueModifiersAsync(token)
                                                         .ConfigureAwait(false),
                                           await MAGAdept.GetTotalMinimumAsync(token).ConfigureAwait(false))
                                       + MAGAdept.Karma
                                       - await MAGAdept.GetTotalMaximumAsync(token).ConfigureAwait(false));
                        // Old values for minimum reduction from essence loss in career mode. These are used to determine if any karma needs to get burned.
                        int intOldRESCareerMinimumReduction = 0;
                        int intOldDEPCareerMinimumReduction = 0;
                        int intOldMAGCareerMinimumReduction = 0;
                        int intOldMAGAdeptCareerMinimumReduction = 0;
                        foreach (Improvement objImprovement in await ImprovementManager
                                                                     .GetCachedImprovementListForValueOfAsync(
                                                                         this,
                                                                         Improvement.ImprovementType.Attribute,
                                                                         token: token).ConfigureAwait(false))
                        {
                            if (objImprovement.ImproveSource == Improvement.ImprovementSource.EssenceLoss)
                            {
                                // Values get subtracted because negative modifier = positive reduction, positive modifier = negative reduction
                                // Augmented values also get factored in in case the character is switching off the option to treat essence loss as an augmented malus
                                switch (objImprovement.ImprovedName)
                                {
                                    case "RES":
                                        intOldRESCareerMinimumReduction -=
                                            objImprovement.Minimum + objImprovement.Augmented.StandardRound();
                                        break;

                                    case "DEP":
                                        intOldDEPCareerMinimumReduction -=
                                            objImprovement.Minimum + objImprovement.Augmented.StandardRound();
                                        break;

                                    case "MAG":
                                        intOldMAGCareerMinimumReduction -=
                                            objImprovement.Minimum + objImprovement.Augmented.StandardRound();
                                        break;

                                    case "MAGAdept":
                                        intOldMAGAdeptCareerMinimumReduction -=
                                            objImprovement.Minimum + objImprovement.Augmented.StandardRound();
                                        break;
                                }
                            }
                        }

                        IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                        try
                        {
                            // Remove any Improvements from MAG, RES, and DEP from Essence Loss that were added in career.
                            await ImprovementManager.RemoveImprovementsAsync(
                                                        this, Improvement.ImprovementSource.EssenceLoss,
                                                        token: token)
                                                    .ConfigureAwait(false);

                            // Career Minimum and Maximum reduction relies on whether there's any extra reduction since chargen.
                            // This is the step where create mode attribute loss regarding attribute maximum loss gets factored out.
                            int intMAGMaximumReduction
                                = intMagMaxReduction + await MAG.GetTotalMaximumAsync(token).ConfigureAwait(false)
                                  - await MAG.MaximumNoEssenceLossAsync(token: token).ConfigureAwait(false);
                            int intMAGAdeptMaximumReduction =
                                intMagMaxReduction
                                + await MAGAdept.GetTotalMaximumAsync(token: token).ConfigureAwait(false)
                                - await MAGAdept.MaximumNoEssenceLossAsync(token: token).ConfigureAwait(false);
                            int intRESMaximumReduction
                                = intResMaxReduction + await RES.GetTotalMaximumAsync(token).ConfigureAwait(false)
                                  - await RES.MaximumNoEssenceLossAsync(token: token).ConfigureAwait(false);
                            int intDEPMaximumReduction
                                = intDepMaxReduction + await DEP.GetTotalMaximumAsync(token).ConfigureAwait(false)
                                  - await DEP.MaximumNoEssenceLossAsync(token: token).ConfigureAwait(false);

                            // Create the Essence Loss (or gain, in case of essence restoration and increasing maxima) Improvements.

                            if (intMagMaxReduction > 0
                                || intMagMinReduction > 0
                                || intMAGMaximumReduction != 0
                                || intMAGAdeptMaximumReduction != 0)
                            {
                                // This is the step where create mode attribute loss regarding attribute minimum loss gets factored out.
                                int intMAGMinimumReduction;
                                int intMAGAdeptMinimumReduction;
                                // If only maxima would be reduced, use the attribute's current total value instead of its current maximum, as this makes sure minima will only get reduced if the maximum reduction would eat into the current value
                                if (Settings.ESSLossReducesMaximumOnly)
                                {
                                    intMAGMinimumReduction = Math.Max(0,
                                                                      intMagMinReduction
                                                                      + await MAG.GetTotalValueAsync(token)
                                                                          .ConfigureAwait(false)
                                                                      - await MAG.MaximumNoEssenceLossAsync(
                                                                              true, token)
                                                                          .ConfigureAwait(false));
                                    intMAGAdeptMinimumReduction = Math.Max(0,
                                                                           intMagMinReduction
                                                                           + await MAGAdept
                                                                               .GetTotalValueAsync(token)
                                                                               .ConfigureAwait(false)
                                                                           - await MAGAdept
                                                                               .MaximumNoEssenceLossAsync(
                                                                                   true, token)
                                                                               .ConfigureAwait(false));
                                }
                                else
                                {
                                    intMAGMinimumReduction =
                                        intMagMinReduction
                                        + await MAG.GetTotalMaximumAsync(token).ConfigureAwait(false)
                                        - await MAG.MaximumNoEssenceLossAsync(true, token).ConfigureAwait(false);
                                    intMAGAdeptMinimumReduction =
                                        intMagMinReduction
                                        + await MAGAdept.GetTotalMaximumAsync(token).ConfigureAwait(false)
                                        - await MAGAdept.MaximumNoEssenceLossAsync(true, token)
                                                        .ConfigureAwait(false);
                                }

                                // If the new MAG reduction is greater than the old one...
                                int intMAGMinimumReductionDelta
                                    = intMAGMinimumReduction - intOldMAGCareerMinimumReduction;
                                if (intMAGMinimumReductionDelta > 0)
                                {
                                    // ... and adding minimum reducing-improvements wouldn't do anything, start burning karma.
                                    if (intMAGMinimumReduction >
                                        MAG.Base + await MAG.GetFreeBaseAsync(token).ConfigureAwait(false)
                                                 + await MAG.GetRawMinimumAsync(token).ConfigureAwait(false)
                                                 + await MAG.GetAttributeValueModifiersAsync(token)
                                                            .ConfigureAwait(false))
                                    {
                                        // intMAGMinimumReduction is not actually reduced so that karma doesn't get burned away each time this function is called.
                                        // Besides, this only fires if intMAGMinimumReduction is already at a level where increasing it any more wouldn't have any effect on the character.
                                        intExtraMAGBurn += Math.Min(MAG.Karma, intMAGMinimumReductionDelta);
                                        MAG.Karma -= intExtraMAGBurn;
                                    }

                                    // Mystic Adept PPs may need to be burned away based on the change of our MAG attribute
                                    if (UseMysticAdeptPPs)
                                    {
                                        // First burn away PPs gained during chargen...
                                        int intChargenPPBurn =
                                            Math.Min(MysticAdeptPowerPoints, intMAGMinimumReductionDelta);
                                        MysticAdeptPowerPoints -= intChargenPPBurn;
                                        // ... now burn away PPs gained from initiations.
                                        decimal decPPBurn = Math.Min(intMAGMinimumReductionDelta - intChargenPPBurn,
                                                                     await ImprovementManager.ValueOfAsync(
                                                                         this,
                                                                         Improvement.ImprovementType
                                                                             .AdeptPowerPoints,
                                                                         token: token).ConfigureAwait(false));
                                        // Source needs to be EssenceLossChargen so that it doesn't get wiped in career mode.
                                        if (decPPBurn != 0)
                                        {
                                            try
                                            {
                                                await ImprovementManager.CreateImprovementAsync(this, string.Empty,
                                                    Improvement.ImprovementSource.EssenceLossChargen, string.Empty,
                                                    Improvement.ImprovementType.AdeptPowerPoints, string.Empty,
                                                    -decPPBurn,
                                                    token: token).ConfigureAwait(false);
                                            }
                                            catch
                                            {
                                                await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                                                throw;
                                            }

                                            ImprovementManager.Commit(this);
                                        }
                                    }
                                }
                                // If the new MAG reduction is less than our old one, the character doesn't actually get any new values back
                                else
                                {
                                    intMAGMinimumReduction = intOldMAGCareerMinimumReduction;
                                }

                                // Make sure we only attempt to burn MAGAdept karma levels if it's actually a separate attribute from MAG
                                if (MAGAdept != MAG)
                                {
                                    // If the new MAGAdept reduction is greater than the old one...
                                    int intMAGAdeptMinimumReductionDelta =
                                        intMAGAdeptMinimumReduction - intOldMAGAdeptCareerMinimumReduction;
                                    if (intMAGAdeptMinimumReductionDelta > 0)
                                    {
                                        // ... and adding minimum reducing-improvements wouldn't do anything, start burning karma.
                                        if (intMAGAdeptMinimumReduction > MAGAdept.Base
                                            + await MAGAdept.GetFreeBaseAsync(token).ConfigureAwait(false) +
                                            await MAGAdept.GetRawMinimumAsync(token).ConfigureAwait(false)
                                            + await MAGAdept.GetAttributeValueModifiersAsync(token)
                                                            .ConfigureAwait(false))
                                        {
                                            // intMAGAdeptMinimumReduction is not actually reduced so that karma doesn't get burned away each time this function is called.
                                            // Besides, this only fires if intMAGAdeptMinimumReduction is already at a level where increasing it any more wouldn't have any effect on the character.
                                            intExtraMAGAdeptBurn += Math.Min(MAGAdept.Karma,
                                                                             intMAGAdeptMinimumReductionDelta);
                                            MAGAdept.Karma -= intExtraMAGAdeptBurn;
                                        }
                                    }
                                    // If the new MAGAdept reduction is less than our old one, the character doesn't actually get any new values back
                                    else
                                    {
                                        intMAGAdeptMinimumReduction = intOldMAGAdeptCareerMinimumReduction;
                                    }
                                }
                                // Otherwise make sure that if the new MAGAdept reduction is less than our old one, the character doesn't actually get any new values back
                                else if (intMAGAdeptMinimumReduction < intOldMAGAdeptCareerMinimumReduction)
                                {
                                    intMAGAdeptMinimumReduction = intOldMAGAdeptCareerMinimumReduction;
                                }

                                // Create Improvements
                                try
                                {
                                    if (intMAGMinimumReduction != 0 || intMAGMaximumReduction != 0)
                                        await ImprovementManager.CreateImprovementAsync(this, "MAG",
                                                                    Improvement.ImprovementSource.EssenceLoss,
                                                                    string.Empty, Improvement.ImprovementType.Attribute,
                                                                    string.Empty, 0, 1,
                                                                    -intMAGMinimumReduction, -intMAGMaximumReduction,
                                                                    token: token)
                                                                .ConfigureAwait(false);
                                    if (intMAGAdeptMinimumReduction != 0 || intMAGAdeptMaximumReduction != 0)
                                        await ImprovementManager.CreateImprovementAsync(this, "MAGAdept",
                                            Improvement.ImprovementSource.EssenceLoss, string.Empty,
                                            Improvement.ImprovementType.Attribute, string.Empty, 0, 1,
                                            -intMAGAdeptMinimumReduction,
                                            -intMAGAdeptMaximumReduction, token: token).ConfigureAwait(false);
                                }
                                catch
                                {
                                    await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                                    throw;
                                }

                                if (intMAGMinimumReduction != 0 || intMAGMaximumReduction != 0 ||
                                    intMAGAdeptMinimumReduction != 0 || intMAGAdeptMaximumReduction != 0)
                                    ImprovementManager.Commit(this);
                            }

                            if (intResMaxReduction > 0
                                || intResMinReduction > 0
                                || intRESMaximumReduction != 0)
                            {
                                // This is the step where create mode attribute loss regarding attribute minimum loss gets factored out.
                                int intRESMinimumReduction;
                                // If only maxima would be reduced, use the attribute's current total value instead of its current maximum, as this makes sure minima will only get reduced if the maximum reduction would eat into the current value
                                if (Settings.ESSLossReducesMaximumOnly)
                                {
                                    intRESMinimumReduction = Math.Max(0,
                                                                      intResMinReduction
                                                                      + await RES.GetTotalValueAsync(token)
                                                                          .ConfigureAwait(false)
                                                                      - await RES.MaximumNoEssenceLossAsync(
                                                                              true, token)
                                                                          .ConfigureAwait(false));
                                }
                                else
                                {
                                    intRESMinimumReduction =
                                        intResMinReduction
                                        + await RES.GetTotalMaximumAsync(token).ConfigureAwait(false)
                                        - await RES.MaximumNoEssenceLossAsync(true, token).ConfigureAwait(false);
                                }

                                // If the new RES reduction is greater than the old one...
                                int intRESMinimumReductionDelta
                                    = intRESMinimumReduction - intOldRESCareerMinimumReduction;
                                if (intRESMinimumReductionDelta > 0)
                                {
                                    // ... and adding minimum reducing-improvements wouldn't do anything, start burning karma.
                                    if (intRESMinimumReduction >
                                        RES.Base + await RES.GetFreeBaseAsync(token).ConfigureAwait(false)
                                                 + await RES.GetRawMinimumAsync(token).ConfigureAwait(false)
                                                 + await RES.GetAttributeValueModifiersAsync(token)
                                                            .ConfigureAwait(false))
                                    {
                                        // intRESMinimumReduction is not actually reduced so that karma doesn't get burned away each time this function is called.
                                        // Besides, this only fires if intRESMinimumReduction is already at a level where increasing it any more wouldn't have any effect on the character.
                                        intExtraRESBurn += Math.Min(RES.Karma, intRESMinimumReductionDelta);
                                        RES.Karma -= intExtraRESBurn;
                                    }
                                }
                                // If the new RES reduction is less than our old one, the character doesn't actually get any new values back
                                else
                                {
                                    intRESMinimumReduction = intOldRESCareerMinimumReduction;
                                }

                                // Create Improvements
                                if (intRESMinimumReduction != 0 || intRESMaximumReduction != 0)
                                {
                                    try
                                    {
                                        await ImprovementManager.CreateImprovementAsync(this, "RES",
                                                                    Improvement.ImprovementSource.EssenceLoss,
                                                                    string.Empty, Improvement.ImprovementType.Attribute,
                                                                    string.Empty, 0, 1,
                                                                    -intRESMinimumReduction, -intRESMaximumReduction,
                                                                    token: token)
                                                                .ConfigureAwait(false);
                                    }
                                    catch
                                    {
                                        await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                                        throw;
                                    }

                                    ImprovementManager.Commit(this);
                                }
                            }

                            if (intDepMaxReduction > 0
                                || intDepMinReduction > 0
                                || intDEPMaximumReduction != 0)
                            {
                                // This is the step where create mode attribute loss regarding attribute minimum loss gets factored out.
                                int intDEPMinimumReduction;
                                // If only maxima would be reduced, use the attribute's current total value instead of its current maximum, as this makes sure minima will only get reduced if the maximum reduction would eat into the current value
                                if (Settings.ESSLossReducesMaximumOnly)
                                {
                                    intDEPMinimumReduction = Math.Max(0,
                                                                      intDepMinReduction
                                                                      + await DEP.GetTotalValueAsync(token)
                                                                          .ConfigureAwait(false)
                                                                      - await DEP.MaximumNoEssenceLossAsync(
                                                                              true, token)
                                                                          .ConfigureAwait(false));
                                }
                                else
                                {
                                    intDEPMinimumReduction =
                                        intDepMinReduction
                                        + await DEP.GetTotalMaximumAsync(token).ConfigureAwait(false)
                                        - await DEP.MaximumNoEssenceLossAsync(true, token).ConfigureAwait(false);
                                }

                                // If the new DEP reduction is greater than the old one...
                                int intDEPMinimumReductionDelta
                                    = intDEPMinimumReduction - intOldDEPCareerMinimumReduction;
                                if (intDEPMinimumReductionDelta > 0)
                                {
                                    // ... and adding minimum reducing-improvements wouldn't do anything, start burning karma.
                                    if (intDEPMinimumReduction >
                                        DEP.Base + await DEP.GetFreeBaseAsync(token).ConfigureAwait(false)
                                                 + await DEP.GetRawMinimumAsync(token).ConfigureAwait(false)
                                                 + await DEP.GetAttributeValueModifiersAsync(token)
                                                            .ConfigureAwait(false))
                                    {
                                        // intDEPMinimumReduction is not actually reduced so that karma doesn't get burned away each time this function is called.
                                        // Besides, this only fires if intDEPMinimumReduction is already at a level where increasing it any more wouldn't have any effect on the character.
                                        intExtraDEPBurn += Math.Min(DEP.Karma, intDEPMinimumReductionDelta);
                                        DEP.Karma -= intExtraDEPBurn;
                                    }
                                }
                                // If the new DEP reduction is less than our old one, the character doesn't actually get any new values back
                                else
                                {
                                    intDEPMinimumReduction = intOldDEPCareerMinimumReduction;
                                }

                                // Create Improvements
                                if (intDEPMinimumReduction != 0 || intDEPMaximumReduction != 0)
                                {
                                    try
                                    {
                                        await ImprovementManager.CreateImprovementAsync(this, "DEP",
                                                                    Improvement.ImprovementSource.EssenceLoss,
                                                                    string.Empty, Improvement.ImprovementType.Attribute,
                                                                    string.Empty, 0, 1,
                                                                    -intDEPMinimumReduction, -intDEPMaximumReduction,
                                                                    token: token)
                                                                .ConfigureAwait(false);
                                    }
                                    catch
                                    {
                                        await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                                        throw;
                                    }

                                    ImprovementManager.Commit(this);
                                }
                            }
                        }
                        finally
                        {
                            await objLocker.DisposeAsync().ConfigureAwait(false);
                        }
                    }
                    // RAW Create mode: Reduce maxima based on max ESS - current ESS, reduce minima based on their essence from the most optimal way in which they could have gotten access to special attributes
                    else
                    {
                        int intMagMinReduction
                            = ((EssenceAtSpecialStart - decESSMag) * decSpecialAttBurnMultiplier
                                                                   * decTotalSpecialAttBurnMultiplier)
                            .StandardRound();
                        int intResMinReduction
                            = ((EssenceAtSpecialStart - decESSRes) * decSpecialAttBurnMultiplier
                                                                   * decTotalSpecialAttBurnMultiplier)
                            .StandardRound();
                        int intDepMinReduction
                            = ((EssenceAtSpecialStart - decESSDep) * decSpecialAttBurnMultiplier
                                                                   * decTotalSpecialAttBurnMultiplier)
                            .StandardRound();
                        int intMAGMinimumReduction = intMagMinReduction;
                        int intMAGAdeptMinimumReduction = intMagMinReduction;
                        int intRESMinimumReduction = intResMinReduction;
                        int intDEPMinimumReduction = intDepMinReduction;
                        if (Settings.ESSLossReducesMaximumOnly)
                        {
                            intMAGMinimumReduction =
                                Math.Max(
                                    0,
                                    intMagMinReduction + await MAG.GetTotalValueAsync(token).ConfigureAwait(false)
                                    - await MAG.GetTotalMaximumAsync(token).ConfigureAwait(false));
                            intMAGAdeptMinimumReduction = Math.Max(0,
                                                                   intMagMinReduction
                                                                   + await MAGAdept.GetTotalValueAsync(token)
                                                                       .ConfigureAwait(false)
                                                                   - await MAGAdept.GetTotalMaximumAsync(token)
                                                                       .ConfigureAwait(false));
                            intRESMinimumReduction
                                = Math.Max(
                                    0,
                                    intResMinReduction + await RES.GetTotalValueAsync(token).ConfigureAwait(false)
                                    - await RES.GetTotalMaximumAsync(token).ConfigureAwait(false));
                            intDEPMinimumReduction
                                = Math.Max(
                                    0,
                                    intDepMinReduction + await DEP.GetTotalValueAsync(token).ConfigureAwait(false)
                                    - await DEP.GetTotalMaximumAsync(token).ConfigureAwait(false));
                        }

                        IAsyncDisposable objLocker
                            = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                        try
                        {
                            await ImprovementManager.RemoveImprovementsAsync(
                                                        this, Improvement.ImprovementSource.EssenceLoss,
                                                        token: token)
                                                    .ConfigureAwait(false);
                            await ImprovementManager.RemoveImprovementsAsync(
                                                        this, Improvement.ImprovementSource.EssenceLossChargen,
                                                        token: token)
                                                    .ConfigureAwait(false);

                            try
                            {
                                if (intMagMaxReduction != 0 || intMAGMinimumReduction != 0
                                                            || intMAGAdeptMinimumReduction != 0)
                                {
                                    await ImprovementManager.CreateImprovementAsync(this, "MAG",
                                        Improvement.ImprovementSource
                                                   .EssenceLossChargen, string.Empty,
                                        Improvement.ImprovementType.Attribute,
                                        string.Empty, 0, 1, -intMAGMinimumReduction,
                                        -intMagMaxReduction, token: token).ConfigureAwait(false);
                                    await ImprovementManager.CreateImprovementAsync(this, "MAGAdept",
                                        Improvement.ImprovementSource
                                                   .EssenceLossChargen, string.Empty,
                                        Improvement.ImprovementType.Attribute,
                                        string.Empty, 0, 1,
                                        -intMAGAdeptMinimumReduction,
                                        -intMagMaxReduction, token: token).ConfigureAwait(false);
                                }

                                if (intResMaxReduction != 0 || intRESMinimumReduction != 0)
                                {
                                    await ImprovementManager.CreateImprovementAsync(this, "RES",
                                        Improvement.ImprovementSource
                                                   .EssenceLossChargen, string.Empty,
                                        Improvement.ImprovementType.Attribute,
                                        string.Empty, 0, 1, -intRESMinimumReduction,
                                        -intResMaxReduction, token: token).ConfigureAwait(false);
                                }

                                if (intDepMaxReduction != 0 || intDEPMinimumReduction != 0)
                                {
                                    await ImprovementManager.CreateImprovementAsync(this, "DEP",
                                        Improvement.ImprovementSource
                                                   .EssenceLossChargen, string.Empty,
                                        Improvement.ImprovementType.Attribute,
                                        string.Empty, 0, 1, -intDEPMinimumReduction,
                                        -intDepMaxReduction, token: token).ConfigureAwait(false);
                                }
                            }
                            catch
                            {
                                await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                                throw;
                            }

                            ImprovementManager.Commit(this);

                            // If the character is in Career mode, it is possible for them to be forced to burn out.
                            if (await GetCreatedAsync(token).ConfigureAwait(false))
                            {
                                // If the CharacterAttribute reaches 0, the character has burned out.
                                if (await GetMAGEnabledAsync(token).ConfigureAwait(false))
                                {
                                    if (Settings.SpecialKarmaCostBasedOnShownValue)
                                    {
                                        if (Settings.MysAdeptSecondMAGAttribute && IsMysticAdept)
                                        {
                                            if (intMagMaxReduction
                                                >= await MAG.GetTotalMaximumAsync(token).ConfigureAwait(false))
                                            {
                                                await MAG.AssignBaseKarmaLimitsAsync(
                                                             MAGAdept.Base, MAGAdept.Karma, MAGAdept.RawMetatypeMinimum,
                                                             MAGAdept.RawMetatypeMaximum,
                                                             MAGAdept.RawMetatypeAugmentedMaximum,
                                                             token)
                                                         .ConfigureAwait(false);
                                                await MAGAdept.AssignBaseKarmaLimitsAsync(0, 0, 0, 0, 0, token)
                                                              .ConfigureAwait(false);

                                                MagicianEnabled = false;
                                            }

                                            if (intMagMaxReduction
                                                >= await MAGAdept.GetTotalMaximumAsync(token).ConfigureAwait(false))
                                            {
                                                await MAGAdept.AssignBaseKarmaLimitsAsync(0, 0, 0, 0, 0, token)
                                                              .ConfigureAwait(false);

                                                AdeptEnabled = false;
                                            }

                                            if (!MagicianEnabled && !AdeptEnabled)
                                                await SetMAGEnabledAsync(false, token).ConfigureAwait(false);
                                        }
                                        else if (intMagMaxReduction
                                                 >= await MAG.GetTotalMaximumAsync(token).ConfigureAwait(false))
                                        {
                                            await MAG.AssignBaseKarmaLimitsAsync(0, 0, 0, 0, 0, token)
                                                     .ConfigureAwait(false);

                                            MagicianEnabled = false;
                                            AdeptEnabled = false;
                                            await SetMAGEnabledAsync(false, token).ConfigureAwait(false);
                                        }
                                    }
                                    else if (Settings.MysAdeptSecondMAGAttribute && IsMysticAdept)
                                    {
                                        if (await MAG.GetTotalMaximumAsync(token).ConfigureAwait(false) < 1)
                                        {
                                            await MAG.AssignBaseKarmaLimitsAsync(
                                                         MAGAdept.Base, MAGAdept.Karma, MAGAdept.RawMetatypeMinimum,
                                                         MAGAdept.RawMetatypeMaximum,
                                                         MAGAdept.RawMetatypeAugmentedMaximum,
                                                         token)
                                                     .ConfigureAwait(false);
                                            await MAGAdept.AssignBaseKarmaLimitsAsync(0, 0, 0, 0, 0, token)
                                                          .ConfigureAwait(false);

                                            MagicianEnabled = false;
                                        }

                                        if (await MAGAdept.GetTotalMaximumAsync(token).ConfigureAwait(false) < 1)
                                        {
                                            await MAGAdept.AssignBaseKarmaLimitsAsync(0, 0, 0, 0, 0, token)
                                                          .ConfigureAwait(false);

                                            AdeptEnabled = false;
                                        }

                                        if (!MagicianEnabled && !AdeptEnabled)
                                            await SetMAGEnabledAsync(false, token).ConfigureAwait(false);
                                    }
                                    else if (await MAG.GetTotalMaximumAsync(token).ConfigureAwait(false) < 1)
                                    {
                                        await MAG.AssignBaseKarmaLimitsAsync(0, 0, 0, 0, 0, token)
                                                 .ConfigureAwait(false);

                                        MagicianEnabled = false;
                                        AdeptEnabled = false;
                                        await SetMAGEnabledAsync(false, token).ConfigureAwait(false);
                                    }
                                }

                                if (await GetRESEnabledAsync(token).ConfigureAwait(false))
                                {
                                    int intResTotalMaximum
                                        = await RES.GetTotalMaximumAsync(token).ConfigureAwait(false);
                                    if (Settings.SpecialKarmaCostBasedOnShownValue
                                        && intResMaxReduction >= intResTotalMaximum
                                        || !Settings.SpecialKarmaCostBasedOnShownValue
                                        && intResTotalMaximum < 1)
                                    {
                                        await RES.AssignBaseKarmaLimitsAsync(0, 0, 0, 0, 0, token)
                                                 .ConfigureAwait(false);

                                        await SetRESEnabledAsync(false, token).ConfigureAwait(false);
                                        TechnomancerEnabled = false;
                                    }
                                }
                            }
                        }
                        finally
                        {
                            await objLocker.DisposeAsync().ConfigureAwait(false);
                        }
                    }
                }
                // Otherwise any essence loss improvements that might have been left need to be deleted (e.g. character is in create mode and had access to special attributes, but that access was removed)
                else
                {
                    IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                    try
                    {
                        try
                        {
                            await ImprovementManager.RemoveImprovementsAsync(
                                                        this, Improvement.ImprovementSource.EssenceLossChargen,
                                                        token: token)
                                                    .ConfigureAwait(false);
                            await ImprovementManager
                                  .RemoveImprovementsAsync(this, Improvement.ImprovementSource.EssenceLoss,
                                                           token: token)
                                  .ConfigureAwait(false);
                        }
                        catch
                        {
                            await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }

                        ImprovementManager.Commit(this);
                    }
                    finally
                    {
                        await objLocker.DisposeAsync().ConfigureAwait(false);
                    }
                }

                // If the character is Cyberzombie, adjust their Attributes based on their Essence.
                if (MetatypeCategory == "Cyberzombie")
                {
                    int intESSModifier = (-await EssenceAsync(token: token).ConfigureAwait(false)).StandardRound();
                    IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                    try
                    {
                        await ImprovementManager.RemoveImprovementsAsync(
                            this,
                            await (await GetImprovementsAsync(token).ConfigureAwait(false)).ToListAsync(
                                    x => x.ImproveSource == Improvement.ImprovementSource.Cyberzombie
                                         && x.ImproveType == Improvement.ImprovementType.Attribute, token)
                                .ConfigureAwait(false), token: token).ConfigureAwait(false);
                        if (intESSModifier != 0)
                        {
                            try
                            {
                                await ImprovementManager.CreateImprovementAsync(
                                    this, "BOD", Improvement.ImprovementSource.Cyberzombie,
                                    string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0,
                                    intESSModifier, token: token).ConfigureAwait(false);
                                await ImprovementManager.CreateImprovementAsync(
                                    this, "AGI", Improvement.ImprovementSource.Cyberzombie,
                                    string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0,
                                    intESSModifier, token: token).ConfigureAwait(false);
                                await ImprovementManager.CreateImprovementAsync(
                                    this, "REA", Improvement.ImprovementSource.Cyberzombie,
                                    string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0,
                                    intESSModifier, token: token).ConfigureAwait(false);
                                await ImprovementManager.CreateImprovementAsync(
                                    this, "STR", Improvement.ImprovementSource.Cyberzombie,
                                    string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0,
                                    intESSModifier, token: token).ConfigureAwait(false);
                                await ImprovementManager.CreateImprovementAsync(
                                    this, "CHA", Improvement.ImprovementSource.Cyberzombie,
                                    string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0,
                                    intESSModifier, token: token).ConfigureAwait(false);
                                await ImprovementManager.CreateImprovementAsync(
                                    this, "INT", Improvement.ImprovementSource.Cyberzombie,
                                    string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0,
                                    intESSModifier, token: token).ConfigureAwait(false);
                                await ImprovementManager.CreateImprovementAsync(
                                    this, "LOG", Improvement.ImprovementSource.Cyberzombie,
                                    string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0,
                                    intESSModifier, token: token).ConfigureAwait(false);
                                await ImprovementManager.CreateImprovementAsync(
                                    this, "WIL", Improvement.ImprovementSource.Cyberzombie,
                                    string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0,
                                    intESSModifier, token: token).ConfigureAwait(false);
                            }
                            catch
                            {
                                await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                                throw;
                            }

                            ImprovementManager.Commit(this);
                        }
                    }
                    finally
                    {
                        await objLocker.DisposeAsync().ConfigureAwait(false);
                    }
                }
            }
        }

        private void ProcessSettingsExpressionsForDependentProperties(ICollection<string> lstPropertyChangedHolder,
                                                                      string strExpressionToFind)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (!Created)
                {
                    if (Settings.ContactPointsExpression.Contains(strExpressionToFind))
                        lstPropertyChangedHolder.Add(nameof(ContactPoints));
                    if (Settings.ChargenKarmaToNuyenExpression.Contains(strExpressionToFind))
                        lstPropertyChangedHolder.Add(nameof(TotalStartingNuyen));
                }

                if (Settings.CarryLimitExpression.Contains(strExpressionToFind))
                    lstPropertyChangedHolder.Add(nameof(BaseCarryLimit));
                if (Settings.LiftLimitExpression.Contains(strExpressionToFind))
                    lstPropertyChangedHolder.Add(nameof(BaseLiftLimit));
                if (Settings.BoundSpiritExpression.Contains(strExpressionToFind))
                    lstPropertyChangedHolder.Add(nameof(BoundSpiritLimit));
                if (Settings.RegisteredSpriteExpression.Contains(strExpressionToFind))
                    lstPropertyChangedHolder.Add(nameof(RegisteredSpriteLimit));
                if (Settings.EncumbranceIntervalExpression.Contains(strExpressionToFind))
                    lstPropertyChangedHolder.Add(nameof(EncumbranceInterval));
                if (Settings.EssenceModifierPostExpression.Contains(strExpressionToFind))
                {
                    lstPropertyChangedHolder.Add(nameof(PrototypeTranshumanEssenceUsed));
                    lstPropertyChangedHolder.Add(nameof(BiowareEssence));
                    lstPropertyChangedHolder.Add(nameof(CyberwareEssence));
                    lstPropertyChangedHolder.Add(nameof(EssenceHole));
                }
            }
        }

        public void RefreshBODDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(16)
                    {
                        nameof(LimitPhysical),
                        nameof(DamageResistancePool),
                        nameof(LiftAndCarry),
                        nameof(FatigueResist),
                        nameof(RadiationResist),
                        nameof(PhysiologicalAddictionResistFirstTime),
                        nameof(PhysiologicalAddictionResistAlreadyAddicted),
                        nameof(StunCMNaturalRecovery),
                        nameof(PhysicalCMNaturalRecovery),
                        nameof(PhysicalCM),
                        nameof(CMOverflow),
                        nameof(SpellDefenseIndirectSoak),
                        nameof(SpellDefenseDirectSoakPhysical),
                        nameof(SpellDefenseDecreaseBOD),
                        nameof(SpellDefenseManipulationPhysical)
                    };
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{BOD}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{BOD}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{BODUnaug}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{BODUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
                case nameof(CharacterAttrib.MetatypeMaximum):
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (DEPEnabled)
                            OnPropertyChanged(nameof(IsAI));
                    }

                    break;
                }
            }
        }

        public void RefreshAGIDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(2)
                    {
                        nameof(SpellDefenseDecreaseAGI),
                        nameof(CalculatedMovement)
                    };
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{AGI}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{AGI}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{AGIUnaug}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{AGIUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
            }
        }

        public void RefreshREADependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(6)
                    {
                        nameof(LimitPhysical),
                        nameof(InitiativeValue),
                        nameof(Dodge),
                        nameof(SpellDefenseDecreaseREA),
                        nameof(Surprise)
                    };
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{REA}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{REA}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{REAUnaug}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{REAUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
            }
        }

        public void RefreshSTRDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(5)
                    {
                        nameof(LimitPhysical),
                        nameof(LiftAndCarry),
                        nameof(SpellDefenseDecreaseSTR),
                        nameof(SpellDefenseManipulationPhysical),
                        nameof(CalculatedMovement),
                        nameof(ArmorEncumbrance)
                    };
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{STR}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{STR}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{STRUnaug}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{STRUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
            }
        }

        public void RefreshCHADependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(6)
                    {
                        nameof(LimitSocial),
                        nameof(Composure),
                        nameof(JudgeIntentions),
                        nameof(JudgeIntentionsResist),
                        nameof(SpellDefenseDecreaseCHA)
                    };
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{CHA}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{CHA}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{CHAUnaug}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{CHAUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
            }
        }

        public void RefreshINTDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(12)
                    {
                        nameof(LimitMental),
                        nameof(JudgeIntentions),
                        nameof(InitiativeValue),
                        nameof(AstralInitiativeValue),
                        nameof(MatrixInitiativeValue),
                        nameof(MatrixInitiativeColdValue),
                        nameof(MatrixInitiativeHotValue),
                        nameof(Dodge),
                        nameof(SpellDefenseDecreaseINT),
                        nameof(SpellDefenseIllusionPhysical),
                        nameof(Surprise)
                    };
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{INT}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{INT}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{INTUnaug}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{INTUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
            }
        }

        public void RefreshLOGDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(10)
                    {
                        nameof(LimitMental),
                        nameof(Memory),
                        nameof(PsychologicalAddictionResistFirstTime),
                        nameof(PsychologicalAddictionResistAlreadyAddicted),
                        nameof(SpellDefenseDetection),
                        nameof(SpellDefenseDecreaseLOG),
                        nameof(SpellDefenseIllusionMana),
                        nameof(SpellDefenseIllusionPhysical),
                        nameof(SpellDefenseManipulationMental)
                    };
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{LOG}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{LOG}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{LOGUnaug}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{LOGUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
            }
        }

        public void RefreshWILDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(27)
                    {
                        nameof(LimitSocial),
                        nameof(LimitMental),
                        nameof(Composure),
                        nameof(Memory),
                        nameof(JudgeIntentionsResist),
                        nameof(FatigueResist),
                        nameof(SonicResist),
                        nameof(RadiationResist),
                        nameof(PhysiologicalAddictionResistFirstTime),
                        nameof(PhysiologicalAddictionResistAlreadyAddicted),
                        nameof(PsychologicalAddictionResistFirstTime),
                        nameof(PsychologicalAddictionResistAlreadyAddicted),
                        nameof(StunCMNaturalRecovery),
                        nameof(StunCM),
                        nameof(SpellDefenseDirectSoakMana),
                        nameof(SpellDefenseDetection),
                        nameof(SpellDefenseDecreaseBOD),
                        nameof(SpellDefenseDecreaseAGI),
                        nameof(SpellDefenseDecreaseREA),
                        nameof(SpellDefenseDecreaseSTR),
                        nameof(SpellDefenseDecreaseCHA),
                        nameof(SpellDefenseDecreaseINT),
                        nameof(SpellDefenseDecreaseLOG),
                        nameof(SpellDefenseDecreaseWIL),
                        nameof(SpellDefenseIllusionMana),
                        nameof(SpellDefenseManipulationMental)
                    };
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{WIL}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{WIL}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{WILUnaug}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{WILUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
            }
        }

        public void RefreshEDGDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(3);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (EdgeUsed > EDG.TotalValue)
                            EdgeUsed = EDG.TotalValue;
                        else
                            lstProperties.Add(nameof(EdgeRemaining));
                    }
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{EDG}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{EDG}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{EDGUnaug}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{EDGUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
            }
        }

        public void RefreshMAGDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(5);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!IsLoading && MysticAdeptPowerPoints > 0)
                        {
                            int intMAGTotalValue = MAG.TotalValue;
                            if (MysticAdeptPowerPoints > intMAGTotalValue)
                                MysticAdeptPowerPoints = intMAGTotalValue;
                        }

                        if (Settings.SpiritForceBasedOnTotalMAG)
                            lstProperties.Add(nameof(MaxSpiritForce));
                        if (MysAdeptAllowPPCareer)
                            lstProperties.Add(nameof(CanAffordCareerPP));
                        if (!UseMysticAdeptPPs && MAG == MAGAdept)
                            lstProperties.Add(nameof(PowerPointsTotal));
                        if (AnyPowerAdeptWayDiscountEnabled)
                            lstProperties.Add(nameof(AllowAdeptWayPowerDiscount));
                    }
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{MAG}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{MAG}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{MAGUnaug}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{MAGUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
            }
        }

        public void RefreshMAGAdeptDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            if (MAG == MAGAdept)
                return;

            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(2);
                    if (!UseMysticAdeptPPs)
                        lstProperties.Add(nameof(MaxSpiritForce));
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{MAGAdept}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{MAGAdept}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{MAGAdeptUnaug}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{MAGAdeptUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
            }
        }

        public void RefreshRESDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(2)
                    {
                        nameof(MaxSpriteLevel)
                    };
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{RES}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{RES}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{RESUnaug}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{RESUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
            }
        }

        public void RefreshDEPDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    if (IsAI)
                        EDG.OnPropertyChanged(nameof(CharacterAttrib.MetatypeMaximum));
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{DEP}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{DEP}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{DEPUnaug}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{DEPUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
            }
        }

        public void RefreshESSDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                // Only ESS.MetatypeMaximum is used for the Essence method/property when it comes to attributes
                case nameof(CharacterAttrib.MetatypeMaximum):
                    this.OnMultiplePropertyChanged(nameof(PrototypeTranshumanEssenceUsed), nameof(BiowareEssence), nameof(CyberwareEssence), nameof(EssenceHole));
                    break;
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{ESS}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{ESS}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{ESSUnaug}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{ESSUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
            }
        }

        public void RefreshEncumbrance(CancellationToken token = default)
        {
            using (EnterReadLock.Enter(LockObject, token))
            {
                // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
                if (IsLoading)
                    return;
                using (LockObject.EnterWriteLock(token))
                {
                    // Remove any Improvements from Armor Encumbrance.
                    ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Encumbrance, token: token);
                    if (!Settings.DoEncumbrancePenaltyPhysicalLimit
                        && !Settings.DoEncumbrancePenaltyMovementSpeed
                        && !Settings.DoEncumbrancePenaltyAgility
                        && !Settings.DoEncumbrancePenaltyReaction)
                        return;
                    // Create the Encumbrance Improvements.
                    int intEncumbrance = Encumbrance;
                    if (intEncumbrance == 0)
                        return;
                    try
                    {
                        if (Settings.DoEncumbrancePenaltyPhysicalLimit)
                            ImprovementManager.CreateImprovement(this, "Physical",
                                                                 Improvement.ImprovementSource.Encumbrance,
                                                                 string.Empty,
                                                                 Improvement.ImprovementType.PhysicalLimit,
                                                                 "precedence-1",
                                                                 intEncumbrance
                                                                 * Settings.EncumbrancePenaltyPhysicalLimit,
                                                                 token: token);
                        if (Settings.DoEncumbrancePenaltyMovementSpeed)
                        {
                            ImprovementManager.CreateImprovement(this, "Ground",
                                                                 Improvement.ImprovementSource.Encumbrance,
                                                                 string.Empty,
                                                                 Improvement.ImprovementType.SprintBonusPercent,
                                                                 "precedence-1",
                                                                 intEncumbrance
                                                                 * Settings.EncumbrancePenaltyMovementSpeed,
                                                                 token: token);
                            ImprovementManager.CreateImprovement(this, "Fly", Improvement.ImprovementSource.Encumbrance,
                                                                 string.Empty,
                                                                 Improvement.ImprovementType.SprintBonusPercent,
                                                                 "precedence-1",
                                                                 intEncumbrance
                                                                 * Settings.EncumbrancePenaltyMovementSpeed,
                                                                 token: token);
                            ImprovementManager.CreateImprovement(this, "Swim",
                                                                 Improvement.ImprovementSource.Encumbrance,
                                                                 string.Empty,
                                                                 Improvement.ImprovementType.SprintBonusPercent,
                                                                 "precedence-1",
                                                                 intEncumbrance
                                                                 * Settings.EncumbrancePenaltyMovementSpeed,
                                                                 token: token);
                            ImprovementManager.CreateImprovement(this, "Ground",
                                                                 Improvement.ImprovementSource.Encumbrance,
                                                                 string.Empty,
                                                                 Improvement.ImprovementType.RunMultiplierPercent,
                                                                 "precedence-1",
                                                                 intEncumbrance
                                                                 * Settings.EncumbrancePenaltyMovementSpeed,
                                                                 token: token);
                            ImprovementManager.CreateImprovement(this, "Fly", Improvement.ImprovementSource.Encumbrance,
                                                                 string.Empty,
                                                                 Improvement.ImprovementType.RunMultiplierPercent,
                                                                 "precedence-1",
                                                                 intEncumbrance
                                                                 * Settings.EncumbrancePenaltyMovementSpeed,
                                                                 token: token);
                            ImprovementManager.CreateImprovement(this, "Swim",
                                                                 Improvement.ImprovementSource.Encumbrance,
                                                                 string.Empty,
                                                                 Improvement.ImprovementType.RunMultiplierPercent,
                                                                 "precedence-1",
                                                                 intEncumbrance
                                                                 * Settings.EncumbrancePenaltyMovementSpeed,
                                                                 token: token);
                            ImprovementManager.CreateImprovement(this, "Ground",
                                                                 Improvement.ImprovementSource.Encumbrance,
                                                                 string.Empty,
                                                                 Improvement.ImprovementType.WalkMultiplierPercent,
                                                                 "precedence-1",
                                                                 intEncumbrance
                                                                 * Settings.EncumbrancePenaltyMovementSpeed,
                                                                 token: token);
                            ImprovementManager.CreateImprovement(this, "Fly", Improvement.ImprovementSource.Encumbrance,
                                                                 string.Empty,
                                                                 Improvement.ImprovementType.WalkMultiplierPercent,
                                                                 "precedence-1",
                                                                 intEncumbrance
                                                                 * Settings.EncumbrancePenaltyMovementSpeed,
                                                                 token: token);
                            ImprovementManager.CreateImprovement(this, "Swim",
                                                                 Improvement.ImprovementSource.Encumbrance,
                                                                 string.Empty,
                                                                 Improvement.ImprovementType.WalkMultiplierPercent,
                                                                 "precedence-1",
                                                                 intEncumbrance
                                                                 * Settings.EncumbrancePenaltyMovementSpeed,
                                                                 token: token);
                        }

                        if (Settings.DoEncumbrancePenaltyAgility)
                            ImprovementManager.CreateImprovement(this, "AGI", Improvement.ImprovementSource.Encumbrance,
                                                                 string.Empty, Improvement.ImprovementType.Attribute,
                                                                 "precedence-1", 0, 1, 0, 0,
                                                                 intEncumbrance * Settings.EncumbrancePenaltyAgility,
                                                                 token: token);
                        if (Settings.DoEncumbrancePenaltyReaction)
                            ImprovementManager.CreateImprovement(this, "REA", Improvement.ImprovementSource.Encumbrance,
                                                                 string.Empty, Improvement.ImprovementType.Attribute,
                                                                 "precedence-1", 0, 1, 0, 0,
                                                                 intEncumbrance * Settings.EncumbrancePenaltyReaction,
                                                                 token: token);
                    }
                    catch
                    {
                        ImprovementManager.Rollback(this, CancellationToken.None);
                        throw;
                    }

                    ImprovementManager.Commit(this);
                }
            }
        }

        public async ValueTask RefreshEncumbranceAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
                if (IsLoading)
                    return;
                IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    // Remove any Improvements from Armor Encumbrance.
                    await ImprovementManager
                          .RemoveImprovementsAsync(this, Improvement.ImprovementSource.Encumbrance, token: token)
                          .ConfigureAwait(false);
                    if (!Settings.DoEncumbrancePenaltyPhysicalLimit
                        && !Settings.DoEncumbrancePenaltyMovementSpeed
                        && !Settings.DoEncumbrancePenaltyAgility
                        && !Settings.DoEncumbrancePenaltyReaction)
                        return;
                    // Create the Encumbrance Improvements.
                    int intEncumbrance = Encumbrance;
                    if (intEncumbrance == 0)
                        return;
                    try
                    {
                        if (Settings.DoEncumbrancePenaltyPhysicalLimit)
                            await ImprovementManager.CreateImprovementAsync(
                                                        this, "Physical", Improvement.ImprovementSource.Encumbrance,
                                                        string.Empty, Improvement.ImprovementType.PhysicalLimit,
                                                        "precedence-1",
                                                        intEncumbrance * Settings.EncumbrancePenaltyPhysicalLimit,
                                                        token: token)
                                                    .ConfigureAwait(false);
                        if (Settings.DoEncumbrancePenaltyMovementSpeed)
                        {
                            await ImprovementManager.CreateImprovementAsync(
                                                        this, "Ground", Improvement.ImprovementSource.Encumbrance,
                                                        string.Empty, Improvement.ImprovementType.SprintBonusPercent,
                                                        "precedence-1",
                                                        intEncumbrance * Settings.EncumbrancePenaltyMovementSpeed,
                                                        token: token)
                                                    .ConfigureAwait(false);
                            await ImprovementManager.CreateImprovementAsync(
                                                        this, "Fly", Improvement.ImprovementSource.Encumbrance,
                                                        string.Empty, Improvement.ImprovementType.SprintBonusPercent,
                                                        "precedence-1",
                                                        intEncumbrance * Settings.EncumbrancePenaltyMovementSpeed,
                                                        token: token)
                                                    .ConfigureAwait(false);
                            await ImprovementManager.CreateImprovementAsync(
                                                        this, "Swim", Improvement.ImprovementSource.Encumbrance,
                                                        string.Empty, Improvement.ImprovementType.SprintBonusPercent,
                                                        "precedence-1",
                                                        intEncumbrance * Settings.EncumbrancePenaltyMovementSpeed,
                                                        token: token)
                                                    .ConfigureAwait(false);
                            await ImprovementManager.CreateImprovementAsync(
                                                        this, "Ground", Improvement.ImprovementSource.Encumbrance,
                                                        string.Empty, Improvement.ImprovementType.RunMultiplierPercent,
                                                        "precedence-1",
                                                        intEncumbrance * Settings.EncumbrancePenaltyMovementSpeed,
                                                        token: token)
                                                    .ConfigureAwait(false);
                            await ImprovementManager.CreateImprovementAsync(
                                                        this, "Fly", Improvement.ImprovementSource.Encumbrance,
                                                        string.Empty, Improvement.ImprovementType.RunMultiplierPercent,
                                                        "precedence-1",
                                                        intEncumbrance * Settings.EncumbrancePenaltyMovementSpeed,
                                                        token: token)
                                                    .ConfigureAwait(false);
                            await ImprovementManager.CreateImprovementAsync(
                                                        this, "Swim", Improvement.ImprovementSource.Encumbrance,
                                                        string.Empty, Improvement.ImprovementType.RunMultiplierPercent,
                                                        "precedence-1",
                                                        intEncumbrance * Settings.EncumbrancePenaltyMovementSpeed,
                                                        token: token)
                                                    .ConfigureAwait(false);
                            await ImprovementManager.CreateImprovementAsync(
                                                        this, "Ground", Improvement.ImprovementSource.Encumbrance,
                                                        string.Empty,
                                                        Improvement.ImprovementType.WalkMultiplierPercent,
                                                        "precedence-1",
                                                        intEncumbrance * Settings.EncumbrancePenaltyMovementSpeed,
                                                        token: token)
                                                    .ConfigureAwait(false);
                            await ImprovementManager.CreateImprovementAsync(
                                                        this, "Fly", Improvement.ImprovementSource.Encumbrance,
                                                        string.Empty,
                                                        Improvement.ImprovementType.WalkMultiplierPercent,
                                                        "precedence-1",
                                                        intEncumbrance * Settings.EncumbrancePenaltyMovementSpeed,
                                                        token: token)
                                                    .ConfigureAwait(false);
                            await ImprovementManager.CreateImprovementAsync(
                                                        this, "Swim", Improvement.ImprovementSource.Encumbrance,
                                                        string.Empty,
                                                        Improvement.ImprovementType.WalkMultiplierPercent,
                                                        "precedence-1",
                                                        intEncumbrance * Settings.EncumbrancePenaltyMovementSpeed,
                                                        token: token)
                                                    .ConfigureAwait(false);
                        }

                        if (Settings.DoEncumbrancePenaltyAgility)
                            await ImprovementManager.CreateImprovementAsync(
                                                        this, "AGI", Improvement.ImprovementSource.Encumbrance,
                                                        string.Empty, Improvement.ImprovementType.Attribute,
                                                        "precedence-1", 0, 1, 0, 0,
                                                        intEncumbrance * Settings.EncumbrancePenaltyAgility,
                                                        token: token)
                                                    .ConfigureAwait(false);
                        if (Settings.DoEncumbrancePenaltyReaction)
                            await ImprovementManager.CreateImprovementAsync(
                                                        this, "REA", Improvement.ImprovementSource.Encumbrance,
                                                        string.Empty, Improvement.ImprovementType.Attribute,
                                                        "precedence-1", 0, 1, 0, 0,
                                                        intEncumbrance * Settings.EncumbrancePenaltyReaction,
                                                        token: token)
                                                    .ConfigureAwait(false);
                    }
                    catch
                    {
                        await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                        throw;
                    }

                    ImprovementManager.Commit(this);
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
        }

        public void RefreshArmorEncumbrance(CancellationToken token = default)
        {
            using (EnterReadLock.Enter(LockObject, token))
            {
                // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
                if (IsLoading)
                    return;
                using (LockObject.EnterWriteLock(token))
                {
                    // Remove any Improvements from Armor Encumbrance.
                    ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.ArmorEncumbrance, token: token);
                    // Create the Armor Encumbrance Improvements.
                    int intEncumbrance = ArmorEncumbrance;
                    if (intEncumbrance != 0)
                    {
                        try
                        {
                            ImprovementManager.CreateImprovement(this, "AGI",
                                                                 Improvement.ImprovementSource.ArmorEncumbrance,
                                                                 string.Empty, Improvement.ImprovementType.Attribute,
                                                                 "precedence-1", 0, 1, 0, 0,
                                                                 intEncumbrance, token: token);
                            ImprovementManager.CreateImprovement(this, "REA",
                                                                 Improvement.ImprovementSource.ArmorEncumbrance,
                                                                 string.Empty, Improvement.ImprovementType.Attribute,
                                                                 "precedence-1", 0, 1, 0, 0,
                                                                 intEncumbrance, token: token);
                        }
                        catch
                        {
                            ImprovementManager.Rollback(this, CancellationToken.None);
                            throw;
                        }

                        ImprovementManager.Commit(this);
                    }
                }
            }
        }

        public async ValueTask RefreshArmorEncumbranceAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
                if (IsLoading)
                    return;
                IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    // Remove any Improvements from Armor Encumbrance.
                    await ImprovementManager
                          .RemoveImprovementsAsync(this, Improvement.ImprovementSource.ArmorEncumbrance, token: token)
                          .ConfigureAwait(false);
                    // Create the Armor Encumbrance Improvements.
                    int intEncumbrance = await GetArmorEncumbranceAsync(token).ConfigureAwait(false);
                    if (intEncumbrance != 0)
                    {
                        try
                        {
                            await ImprovementManager.CreateImprovementAsync(
                                this, "AGI", Improvement.ImprovementSource.ArmorEncumbrance,
                                string.Empty, Improvement.ImprovementType.Attribute,
                                "precedence-1", 0, 1, 0, 0,
                                intEncumbrance, token: token).ConfigureAwait(false);
                            await ImprovementManager.CreateImprovementAsync(
                                this, "REA", Improvement.ImprovementSource.ArmorEncumbrance,
                                string.Empty, Improvement.ImprovementType.Attribute,
                                "precedence-1", 0, 1, 0, 0,
                                intEncumbrance, token: token).ConfigureAwait(false);
                        }
                        catch
                        {
                            await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }

                        ImprovementManager.Commit(this);
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
        }

        public void RefreshWoundPenalties(CancellationToken token = default)
        {
            using (EnterReadLock.Enter(LockObject, token))
            {
                // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
                if (IsLoading)
                    return;
                int intPhysicalCMFilled = Math.Min(PhysicalCMFilled, PhysicalCM);
                int intStunCMFilled = Math.Min(StunCMFilled, StunCM);
                int intCMThreshold = CMThreshold;
                int intStunCMPenalty = ImprovementManager
                                       .GetCachedImprovementListForValueOf(
                                           this, Improvement.ImprovementType.IgnoreCMPenaltyStun, token: token)
                                       .Count > 0
                    ? 0
                    : Math.Min(0, StunCMThresholdOffset - intStunCMFilled) / intCMThreshold;
                int intPhysicalCMPenalty = ImprovementManager
                                           .GetCachedImprovementListForValueOf(
                                               this, Improvement.ImprovementType.IgnoreCMPenaltyPhysical, token: token)
                                           .Count > 0
                    ? 0
                    : Math.Min(0, PhysicalCMThresholdOffset - intPhysicalCMFilled) / intCMThreshold;
                int intWoundModifier = intPhysicalCMPenalty + intStunCMPenalty;
                if (Settings.DoEncumbrancePenaltyWoundModifier && Encumbrance != 0)
                    intWoundModifier += Encumbrance * Settings.EncumbrancePenaltyWoundModifier;
                _intWoundModifier = intWoundModifier;
            }
        }

        public async ValueTask RefreshWoundPenaltiesAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
                if (IsLoading)
                    return;
                int intPhysicalCMFilled = Math.Min(PhysicalCMFilled, await GetPhysicalCMAsync(token).ConfigureAwait(false));
                int intStunCMFilled = Math.Min(StunCMFilled, await GetStunCMAsync(token).ConfigureAwait(false));
                int intCMThreshold = await GetCMThresholdAsync(token).ConfigureAwait(false);
                int intStunCMPenalty = (await ImprovementManager
                                              .GetCachedImprovementListForValueOfAsync(
                                                  this, Improvement.ImprovementType.IgnoreCMPenaltyStun, token: token).ConfigureAwait(false))
                    .Count > 0
                        ? 0
                        : Math.Min(0, await GetStunCMThresholdOffsetAsync(token).ConfigureAwait(false) - intStunCMFilled) / intCMThreshold;
                int intPhysicalCMPenalty = (await ImprovementManager
                                                  .GetCachedImprovementListForValueOfAsync(
                                                      this, Improvement.ImprovementType.IgnoreCMPenaltyPhysical, token: token).ConfigureAwait(false))
                    .Count > 0
                        ? 0
                        : Math.Min(0, await GetPhysicalCMThresholdOffsetAsync(token).ConfigureAwait(false) - intPhysicalCMFilled) / intCMThreshold;
                int intWoundModifier = intPhysicalCMPenalty + intStunCMPenalty;
                if (Settings.DoEncumbrancePenaltyWoundModifier && Encumbrance != 0)
                    intWoundModifier += Encumbrance * Settings.EncumbrancePenaltyWoundModifier;
                _intWoundModifier = intWoundModifier;
            }
        }

        private int _intWoundModifier;

        /// <summary>
        /// Recalculates the Dicepool modifier for sustaining spells or complex forms
        /// </summary>
        public bool RefreshSustainingPenalties(CancellationToken token = default)
        {
            using (EnterReadLock.Enter(LockObject, token))
            {
                if (IsLoading) // If we are in the middle of loading, just queue a single refresh to happen at the end of the process
                {
                    EnqueuePostLoadMethod(RefreshSustainingPenalties, token);
                    return true;
                }

                int intDicePenaltySustainedSpell = Settings.DicePenaltySustaining;

                //The sustaining of Critterpowers doesn't cause any penalties that's why they aren't counted there is no way to change them to self sustained anyway, but just to be sure
                List<SustainedObject> lstSustainedSpells =
                    SustainedCollection.Where(x => x.HasSustainingPenalty).ToList();
                List<Improvement> lstUsedImprovements
                    = ImprovementManager.GetCachedImprovementListForValueOf(
                        this, Improvement.ImprovementType.PenaltyFreeSustain, token: token);
                // Handling of bonuses that let characters sustain some objects for free requires special handling in order to best match the bonus ensemble to the sustained spells ensemble
                if (lstUsedImprovements.Count != 0)
                {
                    // Set up a dictionary where the key is the maximum force/level of the bonus and the value is the number of objects that can be sustained
                    SortedDictionary<decimal, int> dicPenaltyFreeSustains = new SortedDictionary<decimal, int>();
                    foreach (Improvement objImprovement in lstUsedImprovements)
                    {
                        token.ThrowIfCancellationRequested();
                        decimal decForce = objImprovement.Value;
                        if (dicPenaltyFreeSustains.TryGetValue(decForce, out int intExistingRating))
                            dicPenaltyFreeSustains[decForce] = intExistingRating + objImprovement.Rating;
                        else
                            dicPenaltyFreeSustains.Add(decForce, objImprovement.Rating);
                    }

                    // List of supported objects, sorted in descending order of Force
                    List<SustainedObject> lstSupportedObjects = new List<SustainedObject>(lstSustainedSpells.Count);
                    // Go from lowest maximum force/level bonus to highest (that's why we use SortedDictionary) and match each one to the highest possible objects for it.
                    foreach (KeyValuePair<decimal, int> kvpLoop in dicPenaltyFreeSustains)
                    {
                        token.ThrowIfCancellationRequested();
                        int intSupportedForce = kvpLoop.Key.StandardRound();
                        int intNumSupportsPossible = kvpLoop.Value;
                        lstSupportedObjects.Clear();
                        foreach (SustainedObject objLoopObject in lstSustainedSpells)
                        {
                            token.ThrowIfCancellationRequested();
                            int intLoopForce = objLoopObject.Force;
                            if (intLoopForce > intSupportedForce)
                                continue;
                            if (intLoopForce == intSupportedForce)
                            {
                                if (lstSupportedObjects.Count + 1 > intNumSupportsPossible)
                                    // Remove the last element because we know it's the lowest
                                    lstSupportedObjects.RemoveAt(lstSupportedObjects.Count - 1);
                                // Safe to insert object at the top because we cannot get objects with more Force in the list
                                lstSupportedObjects.Insert(0, objLoopObject);
                                if (lstSupportedObjects.Count == intNumSupportsPossible &&
                                    lstSupportedObjects[lstSupportedObjects.Count - 1].Force == intSupportedForce)
                                    // The entire list at this point is saturated with objects with the maximum allowable force, so quit out early
                                    break;
                            }
                            else
                            {
                                if (lstSupportedObjects.Count + 1 > intNumSupportsPossible)
                                {
                                    // Check against the last element because we know it'll be the lowest, only replace item if loop has a higher force than this one
                                    if (intLoopForce <= lstSupportedObjects[lstSupportedObjects.Count - 1].Force)
                                        continue;
                                    lstSupportedObjects.RemoveAt(lstSupportedObjects.Count - 1);
                                }

                                lstSupportedObjects.AddWithSort(objLoopObject,
                                                                (x, y) => y.Force.CompareTo(x.Force), token: token);
                            }
                        }

                        // Remove all sustained objects that supported as penalty-free
                        lstSustainedSpells.RemoveAll(x => lstSupportedObjects.Contains(x));
                        // If we have no more sustained objects in need of penalty removal, exit out early
                        if (lstSustainedSpells.Count == 0)
                            break;
                    }
                }

                int intModifierPerSpell = PsycheActive ? -1 : -intDicePenaltySustainedSpell;
                SustainingPenalty = lstSustainedSpells.Count * intModifierPerSpell;
            }
            return true;
        }

        /// <summary>
        /// Recalculates the Dicepool modifier for sustaining spells or complex forms
        /// </summary>
        public async Task<bool> RefreshSustainingPenaltiesAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (IsLoading) // If we are in the middle of loading, just queue a single refresh to happen at the end of the process
                {
                    await EnqueuePostLoadAsyncMethodAsync(RefreshSustainingPenaltiesAsync, token).ConfigureAwait(false);
                    return true;
                }

                int intDicePenaltySustainedSpell = Settings.DicePenaltySustaining;

                //The sustaining of Critterpowers doesn't cause any penalties that's why they aren't counted there is no way to change them to self sustained anyway, but just to be sure
                List<SustainedObject> lstSustainedSpells =
                    await SustainedCollection.ToListAsync(x => x.HasSustainingPenalty, token: token).ConfigureAwait(false);
                List<Improvement> lstUsedImprovements
                    = await ImprovementManager.GetCachedImprovementListForValueOfAsync(this, Improvement.ImprovementType.PenaltyFreeSustain, token: token).ConfigureAwait(false);
                // Handling of bonuses that let characters sustain some objects for free requires special handling in order to best match the bonus ensemble to the sustained spells ensemble
                if (lstUsedImprovements.Count != 0)
                {
                    // Set up a dictionary where the key is the maximum force/level of the bonus and the value is the number of objects that can be sustained
                    SortedDictionary<decimal, int> dicPenaltyFreeSustains = new SortedDictionary<decimal, int>();
                    foreach (Improvement objImprovement in lstUsedImprovements)
                    {
                        decimal decForce = objImprovement.Value;
                        if (dicPenaltyFreeSustains.TryGetValue(decForce, out int intExistingRating))
                            dicPenaltyFreeSustains[decForce] = intExistingRating + objImprovement.Rating;
                        else
                            dicPenaltyFreeSustains.Add(decForce, objImprovement.Rating);
                    }

                    // List of supported objects, sorted in descending order of Force
                    List<SustainedObject> lstSupportedObjects = new List<SustainedObject>(lstSustainedSpells.Count);
                    // Go from lowest maximum force/level bonus to highest (that's why we use SortedDictionary) and match each one to the highest possible objects for it.
                    foreach (KeyValuePair<decimal, int> kvpLoop in dicPenaltyFreeSustains)
                    {
                        token.ThrowIfCancellationRequested();
                        int intSupportedForce = kvpLoop.Key.StandardRound();
                        int intNumSupportsPossible = kvpLoop.Value;
                        lstSupportedObjects.Clear();
                        foreach (SustainedObject objLoopObject in lstSustainedSpells)
                        {
                            token.ThrowIfCancellationRequested();
                            int intLoopForce = objLoopObject.Force;
                            if (intLoopForce > intSupportedForce)
                                continue;
                            if (intLoopForce == intSupportedForce)
                            {
                                if (lstSupportedObjects.Count + 1 > intNumSupportsPossible)
                                    // Remove the last element because we know it's the lowest
                                    lstSupportedObjects.RemoveAt(lstSupportedObjects.Count - 1);
                                // Safe to insert object at the top because we cannot get objects with more Force in the list
                                lstSupportedObjects.Insert(0, objLoopObject);
                                if (lstSupportedObjects.Count == intNumSupportsPossible &&
                                    lstSupportedObjects[lstSupportedObjects.Count - 1].Force == intSupportedForce)
                                    // The entire list at this point is saturated with objects with the maximum allowable force, so quit out early
                                    break;
                            }
                            else
                            {
                                if (lstSupportedObjects.Count + 1 > intNumSupportsPossible)
                                {
                                    // Check against the last element because we know it'll be the lowest, only replace item if loop has a higher force than this one
                                    if (intLoopForce <= lstSupportedObjects[lstSupportedObjects.Count - 1].Force)
                                        continue;
                                    lstSupportedObjects.RemoveAt(lstSupportedObjects.Count - 1);
                                }

                                lstSupportedObjects.AddWithSort(objLoopObject, (x, y) => y.Force.CompareTo(x.Force), token: token);
                            }
                        }

                        // Remove all sustained objects that supported as penalty-free
                        lstSustainedSpells.RemoveAll(x => lstSupportedObjects.Contains(x));
                        // If we have no more sustained objects in need of penalty removal, exit out early
                        if (lstSustainedSpells.Count == 0)
                            break;
                    }
                }

                int intModifierPerSpell = PsycheActive ? -1 : -intDicePenaltySustainedSpell;
                SustainingPenalty = lstSustainedSpells.Count * intModifierPerSpell;
            }
            return true;
        }

        private int _intSustainingPenalty;

        /// <summary>
        /// Dicepool modifier the character has from wounds. Should be a non-positive number because wound modifiers are always penalties if they are not 0.
        /// </summary>
        public int WoundModifier
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intWoundModifier;
            }
        }

        /// <summary>
        /// Dicepool modified the character has from sustaining spells. Should be negative
        /// </summary>
        public int SustainingPenalty
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intSustainingPenalty;
            }
            private set //Private set instead of read only, to allow inclusion of OnPropertyChanged
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _intSustainingPenalty, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        private bool _blnLoadAsDirty;

        /// <summary>
        /// Whether to immediately mark a character file as dirty when it is loaded in. Used if we're changing a character's settings on load.
        /// </summary>
        public bool LoadAsDirty
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnLoadAsDirty;
            }
            private set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnLoadAsDirty == value)
                        return;
                    using (LockObject.EnterWriteLock())
                        _blnLoadAsDirty = value;
                    OnPropertyChanged();
                }
            }
        }

        public Version LastSavedVersion
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _verSavedVersion;
            }
        }

        /// <summary>
        /// Is the character a mystic adept (MagicianEnabled && AdeptEnabled)? Used for databinding properties.
        /// </summary>
        public bool IsMysticAdept
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AdeptEnabled && MagicianEnabled;
            }
        }

        /// <summary>
        /// Is the character a mystic adept (MagicianEnabled && AdeptEnabled)? Used for databinding properties.
        /// </summary>
        public async ValueTask<bool> GetIsMysticAdeptAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return await GetAdeptEnabledAsync(token).ConfigureAwait(false) && await GetMagicianEnabledAsync(token).ConfigureAwait(false);
        }

        /// <summary>
        /// Whether this character is using special Mystic Adept PP rules (true) or calculate PPs from Mystic Adept's Adept MAG (false)
        /// </summary>
        public bool UseMysticAdeptPPs
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return IsMysticAdept && !Settings.MysAdeptSecondMAGAttribute;
            }
        }

        /// <summary>
        /// Whether this character is using special Mystic Adept PP rules (true) or calculate PPs from Mystic Adept's Adept MAG (false)
        /// </summary>
        public async ValueTask<bool> GetUseMysticAdeptPPsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return await GetIsMysticAdeptAsync(token).ConfigureAwait(false) && !await (await GetSettingsAsync(token).ConfigureAwait(false)).GetMysAdeptSecondMAGAttributeAsync(token).ConfigureAwait(false);
        }

        /// <summary>
        /// Whether this character is a Mystic Adept uses PPs and can purchase PPs in career mode
        /// </summary>
        public bool MysAdeptAllowPPCareer
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return UseMysticAdeptPPs && Settings.MysAdeptAllowPpCareer;
            }
        }

        /// <summary>
        /// Could this character buy Power Points in career mode if the optional/house rule is enabled
        /// </summary>
        public bool CanAffordCareerPP
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    return MysAdeptAllowPPCareer
                           && Karma >= Settings.KarmaMysticAdeptPowerPoint
                           && MAG.TotalValue > MysticAdeptPowerPoints;
                }
            }
        }

        /// <summary>
        /// Whether the character is allowed to gain free spells that are limited to the Touch range.
        /// </summary>
        public Tuple<bool, bool> AllowFreeSpells()
        {
            using (EnterReadLock.Enter(LockObject))
            {
                //Free Spells (typically from Dedicated Spellslinger or custom Improvements) are only handled manually
                //in Career Mode. Create mode manages itself.
                int intFreeGenericSpells = ImprovementManager.ValueOf(this, Improvement.ImprovementType.FreeSpells)
                    .StandardRound();
                int intFreeTouchOnlySpells = 0;
                foreach (Improvement imp in ImprovementManager.GetCachedImprovementListForValueOf(this,
                             Improvement.ImprovementType.FreeSpellsATT))
                {
                    int intAttValue = GetAttribute(imp.ImprovedName).TotalValue;
                    if (imp.UniqueName.Contains("half"))
                        intAttValue = (intAttValue + 1) / 2;
                    if (imp.UniqueName.Contains("touchonly"))
                        intFreeTouchOnlySpells += intAttValue;
                    else
                        intFreeGenericSpells += intAttValue;
                }

                foreach (Improvement imp in ImprovementManager.GetCachedImprovementListForValueOf(this,
                             Improvement.ImprovementType.FreeSpellsSkill))
                {
                    Skill skill = SkillsSection.GetActiveSkill(imp.ImprovedName);
                    int intSkillValue = SkillsSection.GetActiveSkill(imp.ImprovedName).TotalBaseRating;
                    if (imp.UniqueName.Contains("half"))
                        intSkillValue = (intSkillValue + 1) / 2;
                    if (imp.UniqueName.Contains("touchonly"))
                        intFreeTouchOnlySpells += intSkillValue;
                    else
                        intFreeGenericSpells += intSkillValue;
                    //TODO: I don't like this being hardcoded, even though I know full well CGL are never going to reuse this
                    intFreeGenericSpells += skill.Specializations.Count(spec =>
                        Spells.Any(spell => spell.Category == spec.Name && !spell.FreeBonus));
                }

                int intTotalFreeNonTouchSpellsCount = Spells.Count(spell =>
                    spell.FreeBonus && (spell.Range != "T" && spell.Range != "T (A)"));
                int intTotalFreeTouchOnlySpellsCount = Spells.Count(spell =>
                    spell.FreeBonus && (spell.Range == "T" || spell.Range == "T (A)"));
                return new Tuple<bool, bool>(intFreeTouchOnlySpells > intTotalFreeTouchOnlySpellsCount,
                    intFreeGenericSpells > intTotalFreeNonTouchSpellsCount +
                    Math.Max(intTotalFreeTouchOnlySpellsCount - intFreeTouchOnlySpells, 0));
            }
        }

        /// <summary>
        /// Whether the character is allowed to gain free spells that are limited to the Touch range.
        /// </summary>
        public async ValueTask<Tuple<bool, bool>> AllowFreeSpellsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                //Free Spells (typically from Dedicated Spellslinger or custom Improvements) are only handled manually
                //in Career Mode. Create mode manages itself.
                int intFreeGenericSpells = (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.FreeSpells, token: token).ConfigureAwait(false))
                    .StandardRound();
                int intFreeTouchOnlySpells = 0;
                foreach (Improvement imp in await ImprovementManager.GetCachedImprovementListForValueOfAsync(this,
                             Improvement.ImprovementType.FreeSpellsATT, token: token).ConfigureAwait(false))
                {
                    int intAttValue = await (await GetAttributeAsync(imp.ImprovedName, token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false);
                    if (imp.UniqueName.Contains("half"))
                        intAttValue = (intAttValue + 1) / 2;
                    if (imp.UniqueName.Contains("touchonly"))
                        intFreeTouchOnlySpells += intAttValue;
                    else
                        intFreeGenericSpells += intAttValue;
                }

                ThreadSafeObservableCollection<Spell> lstSpells = await GetSpellsAsync(token).ConfigureAwait(false);
                SkillsSection objSkillsSection = await GetSkillsSectionAsync(token).ConfigureAwait(false);
                foreach (Improvement imp in await ImprovementManager.GetCachedImprovementListForValueOfAsync(this,
                             Improvement.ImprovementType.FreeSpellsSkill, token: token).ConfigureAwait(false))
                {
                    Skill skill = await objSkillsSection.GetActiveSkillAsync(imp.ImprovedName, token).ConfigureAwait(false);
                    int intSkillValue = (await objSkillsSection.GetActiveSkillAsync(imp.ImprovedName, token).ConfigureAwait(false)).TotalBaseRating;
                    if (imp.UniqueName.Contains("half"))
                        intSkillValue = (intSkillValue + 1) / 2;
                    if (imp.UniqueName.Contains("touchonly"))
                        intFreeTouchOnlySpells += intSkillValue;
                    else
                        intFreeGenericSpells += intSkillValue;
                    //TODO: I don't like this being hardcoded, even though I know full well CGL are never going to reuse this
                    intFreeGenericSpells += await skill.Specializations.CountAsync(spec =>
                        lstSpells.AnyAsync(spell => spell.Category == spec.Name && !spell.FreeBonus, token: token), token).ConfigureAwait(false);
                }

                int intTotalFreeNonTouchSpellsCount = await lstSpells.CountAsync(spell =>
                    spell.FreeBonus && (spell.Range != "T" && spell.Range != "T (A)"), token: token).ConfigureAwait(false);
                int intTotalFreeTouchOnlySpellsCount = await lstSpells.CountAsync(spell =>
                    spell.FreeBonus && (spell.Range == "T" || spell.Range == "T (A)"), token: token).ConfigureAwait(false);
                return new Tuple<bool, bool>(intFreeTouchOnlySpells > intTotalFreeTouchOnlySpellsCount,
                    intFreeGenericSpells > intTotalFreeNonTouchSpellsCount +
                    Math.Max(intTotalFreeTouchOnlySpellsCount - intFreeTouchOnlySpells, 0));
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;

        // Kept separate for events that are meant to work off of changes to whatever settings the character even if they change
        public event PropertyChangedEventHandler SettingsPropertyChanged;

        #region Static

        //A tree of dependencies. Once some of the properties are changed,
        //anything they depend on, also needs to raise OnChanged
        //This tree keeps track of dependencies
        private static readonly PropertyDependencyGraph<Character> s_CharacterDependencyGraph =
            new PropertyDependencyGraph<Character>(
                    new DependencyGraphNode<string, Character>(nameof(CurrentDisplayName),
                        new DependencyGraphNode<string, Character>(nameof(CharacterName),
                            new DependencyGraphNode<string, Character>(nameof(Alias)),
                            new DependencyGraphNode<string, Character>(nameof(Name), x => string.IsNullOrWhiteSpace(x.Alias),
                                new DependencyGraphNode<string, Character>(nameof(Alias))
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayPowerPointsRemaining),
                        new DependencyGraphNode<string, Character>(nameof(PowerPointsTotal),
                            new DependencyGraphNode<string, Character>(nameof(UseMysticAdeptPPs),
                                new DependencyGraphNode<string, Character>(nameof(IsMysticAdept),
                                    new DependencyGraphNode<string, Character>(nameof(AdeptEnabled)),
                                    new DependencyGraphNode<string, Character>(nameof(MagicianEnabled))
                                )
                            ),
                            new DependencyGraphNode<string, Character>(nameof(MysticAdeptPowerPoints), x => x.UseMysticAdeptPPs,
                                new DependencyGraphNode<string, Character>(nameof(UseMysticAdeptPPs))
                            )
                        ),
                        new DependencyGraphNode<string, Character>(nameof(PowerPointsUsed))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(CanAffordCareerPP),
                        new DependencyGraphNode<string, Character>(nameof(MysAdeptAllowPPCareer),
                            new DependencyGraphNode<string, Character>(nameof(UseMysticAdeptPPs))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(MysticAdeptPowerPoints)),
                        new DependencyGraphNode<string, Character>(nameof(Karma))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(AddInitiationsAllowed),
                        new DependencyGraphNode<string, Character>(nameof(IgnoreRules)),
                        new DependencyGraphNode<string, Character>(nameof(Created))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(InitiationEnabled),
                        new DependencyGraphNode<string, Character>(nameof(MAGEnabled)),
                        new DependencyGraphNode<string, Character>(nameof(RESEnabled)),
                        new DependencyGraphNode<string, Character>(nameof(InitiationForceDisabled))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(InitiativeToolTip),
                        new DependencyGraphNode<string, Character>(nameof(Initiative),
                            new DependencyGraphNode<string, Character>(nameof(InitiativeDice)),
                            new DependencyGraphNode<string, Character>(nameof(InitiativeValue),
                                new DependencyGraphNode<string, Character>(nameof(WoundModifier))
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(AstralInitiativeToolTip),
                        new DependencyGraphNode<string, Character>(nameof(AstralInitiative),
                            new DependencyGraphNode<string, Character>(nameof(AstralInitiativeDice)),
                            new DependencyGraphNode<string, Character>(nameof(AstralInitiativeValue),
                                new DependencyGraphNode<string, Character>(nameof(WoundModifier))
                            )
                        ),
                        new DependencyGraphNode<string, Character>(nameof(MAGEnabled))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeToolTip),
                        new DependencyGraphNode<string, Character>(nameof(MatrixInitiative),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeDice),
                                new DependencyGraphNode<string, Character>(nameof(IsAI)),
                                new DependencyGraphNode<string, Character>(nameof(InitiativeDice), x => !x.IsAI,
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                )
                            ),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeValue),
                                new DependencyGraphNode<string, Character>(nameof(IsAI)),
                                new DependencyGraphNode<string, Character>(nameof(HomeNode), x => x.IsAI,
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                ),
                                new DependencyGraphNode<string, Character>(nameof(WoundModifier), x => x.IsAI,
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                ),
                                new DependencyGraphNode<string, Character>(nameof(InitiativeValue), x => !x.IsAI,
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                )
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeColdToolTip),
                        new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeCold),
                            new DependencyGraphNode<string, Character>(nameof(IsAI)),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiative), x => x.IsAI,
                                new DependencyGraphNode<string, Character>(nameof(IsAI))
                            ),
                            new DependencyGraphNode<string, Character>(nameof(ActiveCommlink), x => !x.IsAI,
                                new DependencyGraphNode<string, Character>(nameof(IsAI))
                            ),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeColdDice),
                                new DependencyGraphNode<string, Character>(nameof(IsAI)),
                                new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeDice), x => x.IsAI,
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                )
                            ),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeColdValue),
                                new DependencyGraphNode<string, Character>(nameof(ActiveCommlink), x => !x.IsAI,
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                ),
                                new DependencyGraphNode<string, Character>(nameof(IsAI)),
                                new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeValue), x => x.IsAI,
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                ),
                                new DependencyGraphNode<string, Character>(nameof(WoundModifier), x => !x.IsAI,
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                )
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeHotToolTip),
                        new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeHot),
                            new DependencyGraphNode<string, Character>(nameof(IsAI)),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiative), x => x.IsAI,
                                new DependencyGraphNode<string, Character>(nameof(IsAI))
                            ),
                            new DependencyGraphNode<string, Character>(nameof(ActiveCommlink), x => !x.IsAI,
                                new DependencyGraphNode<string, Character>(nameof(IsAI))
                            ),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeHotDice),
                                new DependencyGraphNode<string, Character>(nameof(IsAI)),
                                new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeDice), x => x.IsAI,
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                )
                            ),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeHotValue),
                                new DependencyGraphNode<string, Character>(nameof(ActiveCommlink), x => !x.IsAI,
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                ),
                                new DependencyGraphNode<string, Character>(nameof(IsAI)),
                                new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeValue), x => x.IsAI,
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                ),
                                new DependencyGraphNode<string, Character>(nameof(WoundModifier), x => !x.IsAI,
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                )
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(IsSprite),
                        new DependencyGraphNode<string, Character>(nameof(IsFreeSprite),
                            new DependencyGraphNode<string, Character>(nameof(MetatypeCategory))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayMetatypeBP),
                        new DependencyGraphNode<string, Character>(nameof(MetatypeBP))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(PhysicalCMLabelText),
                        new DependencyGraphNode<string, Character>(nameof(IsAI)),
                        new DependencyGraphNode<string, Character>(nameof(HomeNode))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(PhysicalCMToolTip),
                        new DependencyGraphNode<string, Character>(nameof(PhysicalCM))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(StunCMToolTip),
                        new DependencyGraphNode<string, Character>(nameof(StunCM))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(StunCMVisible),
                        new DependencyGraphNode<string, Character>(nameof(IsAI)),
                        new DependencyGraphNode<string, Character>(nameof(HomeNode))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(StunCMLabelText),
                        new DependencyGraphNode<string, Character>(nameof(IsAI)),
                        new DependencyGraphNode<string, Character>(nameof(HomeNode))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SustainingPenalty),
                        new DependencyGraphNode<string, Character>(nameof(PsycheActive))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(WoundModifier),
                        new DependencyGraphNode<string, Character>(nameof(PhysicalCMFilled),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(PhysicalCM),
                            new DependencyGraphNode<string, Character>(nameof(IsAI)),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(StunCMFilled),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(StunCM),
                            new DependencyGraphNode<string, Character>(nameof(IsAI)),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(CMThreshold)),
                        new DependencyGraphNode<string, Character>(nameof(PhysicalCMThresholdOffset),
                            new DependencyGraphNode<string, Character>(nameof(StunCMFilled)),
                            new DependencyGraphNode<string, Character>(nameof(CMThreshold)),
                            new DependencyGraphNode<string, Character>(nameof(IsAI))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(StunCMThresholdOffset),
                            new DependencyGraphNode<string, Character>(nameof(PhysicalCMFilled)),
                            new DependencyGraphNode<string, Character>(nameof(CMThreshold)),
                            new DependencyGraphNode<string, Character>(nameof(IsAI))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(Encumbrance), x => x.Settings.DoEncumbrancePenaltyWoundModifier)
                    ),
                    new DependencyGraphNode<string, Character>(nameof(CMThresholdOffsets),
                        new DependencyGraphNode<string, Character>(nameof(PhysicalCMThresholdOffset)),
                        new DependencyGraphNode<string, Character>(nameof(StunCMThresholdOffset))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(EffectiveBuildMethodUsesPriorityTables),
                        new DependencyGraphNode<string, Character>(nameof(EffectiveBuildMethod),
                            new DependencyGraphNode<string, Character>(nameof(IsCritter))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(EnableAutomaticStoryButton),
                        new DependencyGraphNode<string, Character>(nameof(EffectiveBuildMethodIsLifeModule),
                            new DependencyGraphNode<string, Character>(nameof(EffectiveBuildMethod))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DamageResistancePoolToolTip),
                        new DependencyGraphNode<string, Character>(nameof(DamageResistancePool),
                            new DependencyGraphNode<string, Character>(nameof(TotalArmorRating)),
                            new DependencyGraphNode<string, Character>(nameof(IsAI)),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode), x => x.IsAI,
                                new DependencyGraphNode<string, Character>(nameof(IsAI))
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(IsAI),
                        new DependencyGraphNode<string, Character>(nameof(DEPEnabled))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseIndirectDodgeToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIndirectDodge),
                            new DependencyGraphNode<string, Character>(nameof(TotalBonusDodgeRating))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DodgeToolTip),
                        new DependencyGraphNode<string, Character>(nameof(Dodge),
                            new DependencyGraphNode<string, Character>(nameof(TotalBonusDodgeRating),
                            new DependencyGraphNode<string, Character>(nameof(WoundModifier)),
                            new DependencyGraphNode<string, Character>(nameof(SustainingPenalty))
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseIndirectDodge),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIndirectDodge))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseIndirectSoakToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIndirectSoak),
                            new DependencyGraphNode<string, Character>(nameof(TotalArmorRating)),
                            new DependencyGraphNode<string, Character>(nameof(IsAI)),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode), x => x.IsAI,
                                new DependencyGraphNode<string, Character>(nameof(IsAI))
                            ),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseIndirectSoak),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIndirectSoak))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDirectSoakManaToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDirectSoakMana),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDirectSoakMana),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDirectSoakMana))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDirectSoakPhysicalToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDirectSoakPhysical),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDirectSoakPhysical),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDirectSoakPhysical))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDetectionToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDetection),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDetection),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDetection))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseBODToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseBOD),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseBOD),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseBOD))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseAGIToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseAGI),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseAGI),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseAGI))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseREAToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseREA),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseREA),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseREA))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseSTRToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseSTR),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseSTR),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseSTR))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseCHAToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseCHA),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseCHA),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseCHA))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseINTToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseINT),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseINT),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseINT))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseLOGToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseLOG),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseLOG),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseLOG))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseWILToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseWIL),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseWIL),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseWIL))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseIllusionManaToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIllusionMana),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseIllusionMana),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIllusionMana))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseIllusionPhysicalToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIllusionPhysical),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseIllusionPhysical),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIllusionPhysical))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseManipulationMentalToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseManipulationMental),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseManipulationMental),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseManipulationMental))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseManipulationPhysicalToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseManipulationPhysical),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance)),
                            new DependencyGraphNode<string, Character>(nameof(IsAI)),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode), x => x.IsAI,
                                new DependencyGraphNode<string, Character>(nameof(IsAI))
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseManipulationPhysical),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseManipulationPhysical))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(TotalArmorRatingToolTip),
                        new DependencyGraphNode<string, Character>(nameof(TotalArmorRating),
                            new DependencyGraphNode<string, Character>(nameof(GetArmorRating),
                                new DependencyGraphNode<string, Character>(nameof(GetArmorRatingWithImprovement))
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(TotalFireArmorRating),
                        new DependencyGraphNode<string, Character>(nameof(GetArmorRating))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(TotalColdArmorRating),
                        new DependencyGraphNode<string, Character>(nameof(GetArmorRating))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(TotalElectricityArmorRating),
                        new DependencyGraphNode<string, Character>(nameof(GetArmorRating))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(TotalAcidArmorRating),
                        new DependencyGraphNode<string, Character>(nameof(GetArmorRating))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(TotalFallingArmorRating),
                        new DependencyGraphNode<string, Character>(nameof(GetArmorRating))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayEssence),
                        new DependencyGraphNode<string, Character>(nameof(Essence),
                            new DependencyGraphNode<string, Character>(nameof(CyberwareEssence)),
                            new DependencyGraphNode<string, Character>(nameof(BiowareEssence)),
                            new DependencyGraphNode<string, Character>(nameof(PrototypeTranshumanEssenceUsed)),
                            new DependencyGraphNode<string, Character>(nameof(EssenceHole))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(ComposureToolTip),
                        new DependencyGraphNode<string, Character>(nameof(Composure),
                            new DependencyGraphNode<string, Character>(nameof(SustainingPenalty)),
                            new DependencyGraphNode<string, Character>(nameof(WoundModifier))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SurpriseToolTip),
                        new DependencyGraphNode<string, Character>(nameof(Surprise),
                            new DependencyGraphNode<string, Character>(nameof(WoundModifier)),
                            new DependencyGraphNode<string, Character>(nameof(SustainingPenalty))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(JudgeIntentionsToolTip),
                        new DependencyGraphNode<string, Character>(nameof(JudgeIntentions),
                            new DependencyGraphNode<string, Character>(nameof(WoundModifier)),
                            new DependencyGraphNode<string, Character>(nameof(SustainingPenalty))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(JudgeIntentionsResistToolTip),
                        new DependencyGraphNode<string, Character>(nameof(JudgeIntentionsResist))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(LiftAndCarryToolTip),
                        new DependencyGraphNode<string, Character>(nameof(LiftAndCarry),
                            new DependencyGraphNode<string, Character>(nameof(WoundModifier)),
                            new DependencyGraphNode<string, Character>(nameof(SustainingPenalty))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(MemoryToolTip),
                        new DependencyGraphNode<string, Character>(nameof(Memory),
                            new DependencyGraphNode<string, Character>(nameof(WoundModifier)),
                            new DependencyGraphNode<string, Character>(nameof(SustainingPenalty))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(LiftAndCarryLimits),
                        new DependencyGraphNode<string, Character>(nameof(LiftLimit),
                            new DependencyGraphNode<string, Character>(nameof(BaseLiftLimit)),
                            new DependencyGraphNode<string, Character>(nameof(CurrentLiftCarryHits))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(CarryLimit),
                            new DependencyGraphNode<string, Character>(nameof(BaseCarryLimit)),
                            new DependencyGraphNode<string, Character>(nameof(CurrentLiftCarryHits))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(Encumbrance),
                        new DependencyGraphNode<string, Character>(nameof(CarryLimit)),
                        new DependencyGraphNode<string, Character>(nameof(TotalCarriedWeight)),
                        new DependencyGraphNode<string, Character>(nameof(EncumbranceInterval))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayTotalCarriedWeight),
                        new DependencyGraphNode<string, Character>(nameof(CarryLimit)),
                        new DependencyGraphNode<string, Character>(nameof(TotalCarriedWeight))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayCyberwareEssence),
                        new DependencyGraphNode<string, Character>(nameof(CyberwareEssence))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayBiowareEssence),
                        new DependencyGraphNode<string, Character>(nameof(BiowareEssence))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayEssenceHole),
                        new DependencyGraphNode<string, Character>(nameof(EssenceHole))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayPrototypeTranshumanEssenceUsed),
                        new DependencyGraphNode<string, Character>(nameof(PrototypeTranshumanEssenceUsed)),
                        new DependencyGraphNode<string, Character>(nameof(PrototypeTranshuman))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(IsPrototypeTranshuman),
                        new DependencyGraphNode<string, Character>(nameof(PrototypeTranshuman))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayNuyen),
                        new DependencyGraphNode<string, Character>(nameof(Nuyen))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayStolenNuyen),
                        new DependencyGraphNode<string, Character>(nameof(StolenNuyen))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayKarma),
                        new DependencyGraphNode<string, Character>(nameof(Karma))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayTotalStartingNuyen),
                        new DependencyGraphNode<string, Character>(nameof(TotalStartingNuyen),
                            new DependencyGraphNode<string, Character>(nameof(StartingNuyen)),
                            new DependencyGraphNode<string, Character>(nameof(NuyenBP)),
                            new DependencyGraphNode<string, Character>(nameof(TotalNuyenMaximumBP),
                                new DependencyGraphNode<string, Character>(nameof(StolenNuyen)),
                                new DependencyGraphNode<string, Character>(nameof(IgnoreRules))
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayCareerNuyen),
                        new DependencyGraphNode<string, Character>(nameof(CareerNuyen))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayCareerKarma),
                        new DependencyGraphNode<string, Character>(nameof(CareerKarma))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(StreetCredTooltip),
                        new DependencyGraphNode<string, Character>(nameof(TotalStreetCred),
                            new DependencyGraphNode<string, Character>(nameof(StreetCred)),
                            new DependencyGraphNode<string, Character>(nameof(CalculatedStreetCred),
                                new DependencyGraphNode<string, Character>(nameof(CareerKarma)),
                                new DependencyGraphNode<string, Character>(nameof(BurntStreetCred))
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(CanBurnStreetCred),
                        new DependencyGraphNode<string, Character>(nameof(TotalStreetCred))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(NotorietyTooltip),
                        new DependencyGraphNode<string, Character>(nameof(TotalNotoriety),
                            new DependencyGraphNode<string, Character>(nameof(Notoriety)),
                            new DependencyGraphNode<string, Character>(nameof(CalculatedNotoriety)),
                            new DependencyGraphNode<string, Character>(nameof(BurntStreetCred))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(PublicAwarenessTooltip),
                        new DependencyGraphNode<string, Character>(nameof(TotalPublicAwareness),
                            new DependencyGraphNode<string, Character>(nameof(Erased)),
                            new DependencyGraphNode<string, Character>(nameof(CalculatedPublicAwareness),
                                new DependencyGraphNode<string, Character>(nameof(PublicAwareness)),
                                new DependencyGraphNode<string, Character>(nameof(TotalStreetCred),
                                    x => x.Settings.UseCalculatedPublicAwareness),
                                new DependencyGraphNode<string, Character>(nameof(TotalNotoriety),
                                    x => x.Settings.UseCalculatedPublicAwareness)
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(CareerDisplayStreetCred),
                        new DependencyGraphNode<string, Character>(nameof(TotalStreetCred))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(CareerDisplayNotoriety),
                        new DependencyGraphNode<string, Character>(nameof(TotalNotoriety))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(CareerDisplayPublicAwareness),
                        new DependencyGraphNode<string, Character>(nameof(TotalPublicAwareness))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(AddBiowareEnabled),
                        new DependencyGraphNode<string, Character>(nameof(CyberwareDisabled)),
                        new DependencyGraphNode<string, Character>(nameof(IsAI))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(AddCyberwareEnabled),
                        new DependencyGraphNode<string, Character>(nameof(CyberwareDisabled)),
                        new DependencyGraphNode<string, Character>(nameof(IsAI))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(HasMentorSpirit),
                        new DependencyGraphNode<string, Character>(nameof(MentorSpirits))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(CharacterGrammaticGender),
                        new DependencyGraphNode<string, Character>(nameof(Gender))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(FirstMentorSpiritDisplayName),
                        new DependencyGraphNode<string, Character>(nameof(MentorSpirits))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(FirstMentorSpiritDisplayInformation),
                        new DependencyGraphNode<string, Character>(nameof(MentorSpirits))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(LimitPhysicalToolTip),
                        new DependencyGraphNode<string, Character>(nameof(LimitPhysical),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(LimitMentalToolTip),
                        new DependencyGraphNode<string, Character>(nameof(LimitMental),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(LimitSocialToolTip),
                        new DependencyGraphNode<string, Character>(nameof(LimitSocial),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(LimitAstralToolTip),
                        new DependencyGraphNode<string, Character>(nameof(LimitAstral),
                            new DependencyGraphNode<string, Character>(nameof(LimitMental)),
                            new DependencyGraphNode<string, Character>(nameof(LimitSocial))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayMovement),
                        new DependencyGraphNode<string, Character>(nameof(GetMovement),
                            new DependencyGraphNode<string, Character>(nameof(Movement)),
                            new DependencyGraphNode<string, Character>(nameof(CalculatedMovement),
                                new DependencyGraphNode<string, Character>(nameof(WalkingRate),
                                    new DependencyGraphNode<string, Character>(nameof(CurrentWalkingRateString),
                                        new DependencyGraphNode<string, Character>(nameof(WalkString),
                                            x => x.AttributeSection.AttributeCategory ==
                                                 CharacterAttrib.AttributeCategory.Standard),
                                        new DependencyGraphNode<string, Character>(nameof(WalkAltString),
                                            x => x.AttributeSection.AttributeCategory !=
                                                 CharacterAttrib.AttributeCategory.Standard)
                                    )
                                ),
                                new DependencyGraphNode<string, Character>(nameof(RunningRate),
                                    new DependencyGraphNode<string, Character>(nameof(CurrentRunningRateString),
                                        new DependencyGraphNode<string, Character>(nameof(RunString),
                                            x => x.AttributeSection.AttributeCategory ==
                                                 CharacterAttrib.AttributeCategory.Standard),
                                        new DependencyGraphNode<string, Character>(nameof(RunAltString),
                                            x => x.AttributeSection.AttributeCategory !=
                                                 CharacterAttrib.AttributeCategory.Standard)
                                    )
                                ),
                                new DependencyGraphNode<string, Character>(nameof(SprintingRate),
                                    new DependencyGraphNode<string, Character>(nameof(CurrentSprintingRateString),
                                        new DependencyGraphNode<string, Character>(nameof(SprintString),
                                            x => x.AttributeSection.AttributeCategory ==
                                                 CharacterAttrib.AttributeCategory.Standard),
                                        new DependencyGraphNode<string, Character>(nameof(SprintAltString),
                                            x => x.AttributeSection.AttributeCategory !=
                                                 CharacterAttrib.AttributeCategory.Standard)
                                    )
                                )
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySwim),
                        new DependencyGraphNode<string, Character>(nameof(GetSwim),
                            new DependencyGraphNode<string, Character>(nameof(Movement)),
                            new DependencyGraphNode<string, Character>(nameof(CalculatedMovement))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayFly),
                        new DependencyGraphNode<string, Character>(nameof(GetFly),
                            new DependencyGraphNode<string, Character>(nameof(Movement)),
                            new DependencyGraphNode<string, Character>(nameof(CalculatedMovement))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayNegativeQualityKarma),
                        new DependencyGraphNode<string, Character>(nameof(NegativeQualityKarma),
                            new DependencyGraphNode<string, Character>(nameof(EnemyKarma)),
                            new DependencyGraphNode<string, Character>(nameof(Contacts)),
                            new DependencyGraphNode<string, Character>(nameof(Qualities))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(NegativeQualityLimitKarma),
                            new DependencyGraphNode<string, Character>(nameof(EnemyKarma)),
                            new DependencyGraphNode<string, Character>(nameof(Contacts)),
                            new DependencyGraphNode<string, Character>(nameof(Qualities))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayPositiveQualityKarma),
                        new DependencyGraphNode<string, Character>(nameof(PositiveQualityLimitKarma),
                            new DependencyGraphNode<string, Character>(nameof(Contacts)),
                            new DependencyGraphNode<string, Character>(nameof(Qualities))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(PositiveQualityKarma),
                            new DependencyGraphNode<string, Character>(nameof(Contacts)),
                            new DependencyGraphNode<string, Character>(nameof(Qualities))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayMetagenicQualityKarma),
                        new DependencyGraphNode<string, Character>(nameof(MetagenicPositiveQualityKarma),
                        new DependencyGraphNode<string, Character>(nameof(MetagenicNegativeQualityKarma),
                            new DependencyGraphNode<string, Character>(nameof(IsChangeling)),
                            new DependencyGraphNode<string, Character>(nameof(Qualities))
                        ))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(AstralReputationTooltip),
                        new DependencyGraphNode<string, Character>(nameof(TotalAstralReputation),
                            new DependencyGraphNode<string, Character>(nameof(AstralReputation))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(WildReputationTooltip),
                        new DependencyGraphNode<string, Character>(nameof(TotalWildReputation),
                            new DependencyGraphNode<string, Character>(nameof(WildReputation))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(EdgeRemainingString),
                        new DependencyGraphNode<string, Character>(nameof(EdgeRemaining),
                            new DependencyGraphNode<string, Character>(nameof(EdgeUsed))
                        )
                    )
                );

        #endregion Static

        [NotifyPropertyChangedInvocator]
        public void OnPropertyChanged([CallerMemberName] string strPropertyName = null)
        {
            this.OnMultiplePropertyChanged(strPropertyName);
        }

        private static readonly HashSet<string> s_SetPropertyNamesWithCachedValues = new HashSet<string>
        {
            nameof(CharacterGrammaticGender),
            nameof(TotalStartingNuyen),
            nameof(ContactPoints),
            nameof(BaseCarryLimit),
            nameof(BaseLiftLimit),
            nameof(EncumbranceInterval),
            nameof(TotalArmorRating),
            nameof(TotalFireArmorRating),
            nameof(TotalColdArmorRating),
            nameof(TotalElectricityArmorRating),
            nameof(TotalAcidArmorRating),
            nameof(TotalFallingArmorRating),
            nameof(TrustFund),
            nameof(RestrictedGear),
            nameof(TotalCarriedWeight),
            nameof(PowerPointsUsed),
            nameof(CyberwareEssence),
            nameof(BiowareEssence),
            nameof(EssenceHole),
            nameof(PrototypeTranshumanEssenceUsed),
            nameof(CareerNuyen),
            nameof(CareerKarma),
            nameof(BoundSpiritLimit),
            nameof(RegisteredSpriteLimit),
            nameof(InitiationEnabled),
            nameof(RedlinerBonus),
            nameof(EnemyKarma),
            nameof(Qualities),
            nameof(MetagenicLimit)
        };

        public void OnMultiplePropertyChanged(IReadOnlyCollection<string> lstPropertyNames)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                HashSet<string> setNamesOfChangedProperties = null;
                try
                {
                    foreach (string strPropertyName in lstPropertyNames)
                    {
                        if (setNamesOfChangedProperties == null)
                            setNamesOfChangedProperties
                                = s_CharacterDependencyGraph.GetWithAllDependents(this, strPropertyName, true);
                        else
                        {
                            foreach (string strLoopChangedProperty in s_CharacterDependencyGraph
                                         .GetWithAllDependentsEnumerable(
                                             this, strPropertyName))
                                setNamesOfChangedProperties.Add(strLoopChangedProperty);
                        }
                    }

                    if (setNamesOfChangedProperties == null || setNamesOfChangedProperties.Count == 0)
                        return;

                    if (setNamesOfChangedProperties.Overlaps(s_SetPropertyNamesWithCachedValues))
                    {
                        using (LockObject.EnterWriteLock())
                        {
                            if (setNamesOfChangedProperties.Contains(nameof(CharacterGrammaticGender)))
                                _strCachedCharacterGrammaticGender = string.Empty;
                            if (setNamesOfChangedProperties.Contains(nameof(TotalStartingNuyen)))
                                _decCachedTotalStartingNuyen = decimal.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(ContactPoints)))
                                _intCachedContactPoints = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(BaseCarryLimit)))
                                _decCachedBaseCarryLimit = decimal.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(BaseLiftLimit)))
                                _decCachedBaseLiftLimit = decimal.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(EncumbranceInterval)))
                                _decCachedEncumbranceInterval = decimal.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(TotalArmorRating)))
                                _intCachedTotalArmorRating = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(TotalFireArmorRating)))
                                _intCachedTotalFireArmorRating = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(TotalColdArmorRating)))
                                _intCachedTotalColdArmorRating = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(TotalElectricityArmorRating)))
                                _intCachedTotalElectricityArmorRating = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(TotalAcidArmorRating)))
                                _intCachedTotalAcidArmorRating = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(TotalFallingArmorRating)))
                                _intCachedTotalFallingArmorRating = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(TrustFund)))
                                _intCachedTrustFund = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(RestrictedGear)))
                                _intCachedRestrictedGear = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(TotalCarriedWeight)))
                                _decCachedTotalCarriedWeight = decimal.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(PowerPointsUsed)))
                                _decCachedPowerPointsUsed = decimal.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(CyberwareEssence)))
                                _decCachedCyberwareEssence = decimal.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(BiowareEssence))
                                || setNamesOfChangedProperties.Contains(nameof(PrototypeTranshumanEssenceUsed)))
                            {
                                _decCachedBiowareEssence = decimal.MinValue;
                                _decCachedPrototypeTranshumanEssenceUsed = decimal.MinValue;
                            }
                            if (setNamesOfChangedProperties.Contains(nameof(EssenceHole)))
                                _decCachedEssenceHole = decimal.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(CareerNuyen)))
                                _decCachedCareerNuyen = decimal.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(CareerKarma)))
                                _intCachedCareerKarma = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(BoundSpiritLimit)))
                                _intBoundSpiritLimit = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(RegisteredSpriteLimit)))
                                _intRegisteredSpriteLimit = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(InitiationEnabled)))
                                _intCachedInitiationEnabled = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(RedlinerBonus)))
                                _intCachedRedlinerBonus = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(EnemyKarma)))
                                _intCachedEnemyKarma = int.MinValue;
                            if (setNamesOfChangedProperties.Contains(nameof(Qualities)))
                            {
                                _intCachedNegativeQualities = int.MinValue;
                                _intCachedNegativeQualityLimitKarma = int.MinValue;
                                _intCachedPositiveQualityLimitKarma = int.MinValue;
                                _intCachedPositiveQualities = int.MinValue;
                                _intCachedMetagenicNegativeQualities = int.MinValue;
                                _intCachedMetagenicPositiveQualities = int.MinValue;
                            }
                            else if (setNamesOfChangedProperties.Contains(nameof(MetagenicLimit)))
                            {
                                _intCachedMetagenicNegativeQualities = int.MinValue;
                                _intCachedMetagenicPositiveQualities = int.MinValue;
                            }
                        }
                    }

                    if (setNamesOfChangedProperties.Contains(nameof(DealerConnectionDiscount)))
                        RefreshDealerConnectionDiscounts();
                    if (setNamesOfChangedProperties.Contains(nameof(BlackMarketDiscount)))
                        RefreshBlackMarketDiscounts();
                    if (setNamesOfChangedProperties.Contains(nameof(RedlinerBonus)))
                        RefreshRedlinerImprovements();
                    if (setNamesOfChangedProperties.Contains(nameof(Essence)))
                    {
                        ResetCachedEssence();
                        RefreshEssenceLossImprovements();
                    }

                    if (setNamesOfChangedProperties.Contains(nameof(ArmorEncumbrance)))
                        RefreshArmorEncumbrance();
                    if (setNamesOfChangedProperties.Contains(nameof(WoundModifier)))
                        RefreshWoundPenalties();
                    if (setNamesOfChangedProperties.Contains(nameof(SustainingPenalty)))
                        RefreshSustainingPenalties();
                    if (setNamesOfChangedProperties.Contains(nameof(TotalAstralReputation)))
                        RefreshAstralReputationImprovements();

                    if (PropertyChanged != null)
                    {
                        Utils.RunOnMainThread(() =>
                        {
                            if (PropertyChanged != null)
                            {
                                // ReSharper disable once AccessToModifiedClosure
                                foreach (string strPropertyToChange in setNamesOfChangedProperties)
                                {
                                    PropertyChanged.Invoke(this, new PropertyChangedEventArgs(strPropertyToChange));
                                }
                            }
                        });
                    }

                    if (!Created)
                    {
                        // If in create mode, update the Force for Spirits and Sprites (equal to Magician MAG Rating or RES Rating).
                        if (setNamesOfChangedProperties.Contains(nameof(MaxSpriteLevel)))
                        {
                            if (setNamesOfChangedProperties.Contains(nameof(MaxSpiritForce)))
                            {
                                foreach (Spirit objSpirit in Spirits)
                                {
                                    using (EnterReadLock.Enter(objSpirit.LockObject))
                                    {
                                        switch (objSpirit.EntityType)
                                        {
                                            case SpiritType.Sprite:
                                                objSpirit.Force = MaxSpriteLevel;
                                                break;
                                            case SpiritType.Spirit:
                                                objSpirit.Force = MaxSpiritForce;
                                                break;
                                        }
                                    }
                                }
                            }
                            else
                            {
                                foreach (Spirit objSpirit in Spirits)
                                {
                                    using (EnterReadLock.Enter(objSpirit.LockObject))
                                    {
                                        if (objSpirit.EntityType == SpiritType.Sprite)
                                            objSpirit.Force = MaxSpriteLevel;
                                    }
                                }
                            }
                        }
                        else if (setNamesOfChangedProperties.Contains(nameof(MaxSpiritForce)))
                        {
                            foreach (Spirit objSpirit in Spirits)
                            {
                                using (EnterReadLock.Enter(objSpirit.LockObject))
                                {
                                    if (objSpirit.EntityType == SpiritType.Spirit)
                                        objSpirit.Force = MaxSpiritForce;
                                }
                            }
                        }
                    }
                }
                finally
                {
                    if (setNamesOfChangedProperties != null)
                        Utils.StringHashSetPool.Return(ref setNamesOfChangedProperties);
                }
            }

            if (Program.MainForm == null || IsLoading)
                return;
            foreach (Character objLoopOpenCharacter in Program.OpenCharacters)
            {
                if (objLoopOpenCharacter != this && objLoopOpenCharacter.LinkedCharacters.Contains(this))
                {
                    foreach (Spirit objSpirit in objLoopOpenCharacter.Spirits)
                    {
                        if (objSpirit.LinkedCharacter == this)
                        {
                            objSpirit.OnPropertyChanged(nameof(Spirit.LinkedCharacter));
                        }
                    }

                    foreach (Contact objContact in objLoopOpenCharacter.Contacts)
                    {
                        if (objContact.LinkedCharacter == this)
                        {
                            objContact.OnPropertyChanged(nameof(Contact.LinkedCharacter));
                        }
                    }
                }
            }
        }

        #region Hero Lab Importing

        public static readonly ReadOnlyCollection<string> HeroLabPluginNodeNames = Array.AsReadOnly(new[]
            {"modifications", "accessories", "ammunition", "programs", "othergear"});

        /// <summary>
        /// Load the Character from an XML file.
        /// </summary>
        public bool LoadFromHeroLabFile(string strPorFile, string strCharacterId, string strSettingsKey = "")
        {
            return Utils.SafelyRunSynchronously(() => LoadFromHeroLabFileCoreAsync(true, strPorFile, strCharacterId, strSettingsKey));
        }

        /// <summary>
        /// Load the Character from an XML file.
        /// </summary>
        public Task<bool> LoadFromHeroLabFileAsync(string strPorFile, string strCharacterId, string strSettingsKey = "")
        {
            return LoadFromHeroLabFileCoreAsync(false, strPorFile, strCharacterId, strSettingsKey);
        }

        /// <summary>
        /// Load the Character from an XML file.
        /// </summary>
        public async Task<bool> LoadFromHeroLabFileCoreAsync(bool blnSync, string strPorFile, string strCharacterId, string strSettingsKey = "", CancellationToken token = default)
        {
            if (!File.Exists(strPorFile))
                return false;

            IDisposable objLocker = null;
            IAsyncDisposable objLockerAsync = null;
            if (blnSync)
                // ReSharper disable once MethodHasAsyncOverload
                objLocker = LockObject.EnterWriteLock(token);
            else
                objLockerAsync = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                Dictionary<string, Bitmap> dicImages = new Dictionary<string, Bitmap>(1);
                XPathNavigator xmlStatBlockDocument = null;
                XPathNavigator xmlLeadsDocument = null;
                List<string> lstTextStatBlockLines = null;
                using (CustomActivity op_load = Timekeeper.StartSyncron("LoadFromHeroLabFile", null,
                                                                        CustomActivity.OperationType
                                                                            .DependencyOperation, strPorFile))
                {
                    try
                    {
                        op_load.MyDependencyTelemetry.Type = "loadHeroLab";
                        op_load.MyDependencyTelemetry.Target = strPorFile;

                        try
                        {
                            string strLeadsName = string.Empty;
                            using (ZipArchive zipArchive = ZipFile.Open(strPorFile, ZipArchiveMode.Read,
                                                                        Encoding.GetEncoding(850)))
                            {
                                token.ThrowIfCancellationRequested();
                                foreach (ZipArchiveEntry objEntry in zipArchive.Entries)
                                {
                                    token.ThrowIfCancellationRequested();
                                    string strEntryFullName = objEntry.FullName;
                                    string strKey = Path.GetFileName(strEntryFullName);
                                    if ((xmlStatBlockDocument == null && strEntryFullName.StartsWith(
                                            "statblocks_xml",
                                            StringComparison.OrdinalIgnoreCase)) ||
                                        (string.IsNullOrEmpty(strLeadsName) &&
                                         strEntryFullName.EndsWith("portfolio.xml",
                                                                   StringComparison.OrdinalIgnoreCase)) ||
                                        lstTextStatBlockLines == null && strEntryFullName.StartsWith(
                                            "statblocks_txt",
                                            StringComparison.OrdinalIgnoreCase))
                                    {
                                        if (strEntryFullName.EndsWith(".xml", StringComparison.OrdinalIgnoreCase))
                                        {
                                            try
                                            {
                                                if (blnSync)
                                                    DoLoadStatblocks();
                                                else
                                                    await Task.Run(DoLoadStatblocks, token).ConfigureAwait(false);
                                                void DoLoadStatblocks()
                                                {
                                                    using (Stream objStream = objEntry.Open())
                                                    {
                                                        token.ThrowIfCancellationRequested();
                                                        using (StreamReader objStreamReader =
                                                               new StreamReader(objStream, true))
                                                        {
                                                            token.ThrowIfCancellationRequested();
                                                            using (XmlReader objReader = XmlReader.Create(
                                                                       objStreamReader,
                                                                       GlobalSettings.SafeXmlReaderSettings))
                                                            {
                                                                token.ThrowIfCancellationRequested();
                                                                XPathDocument xmlSourceDoc
                                                                    = new XPathDocument(objReader);
                                                                XPathNavigator objDummy
                                                                    = xmlSourceDoc.CreateNavigator();
                                                                if (strEntryFullName.StartsWith("statblocks_xml",
                                                                        StringComparison.Ordinal))
                                                                {
                                                                    if (objDummy.SelectSingleNode(
                                                                            "/document/public/character[@name = " +
                                                                            strCharacterId.CleanXPath() + ']') != null)
                                                                        xmlStatBlockDocument = objDummy;
                                                                }
                                                                else
                                                                {
                                                                    strLeadsName = objDummy.SelectSingleNode(
                                                                            "/document/portfolio/hero[@heroname = " +
                                                                            strCharacterId.CleanXPath() + "]/@leadfile")
                                                                        ?.Value;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            // If we run into any problems loading the character xml files, fail out early.
                                            catch (IOException e)
                                            {
                                                Log.Info(e);
                                                Utils.BreakIfDebug();
                                            }
                                            catch (XmlException e)
                                            {
                                                Log.Info(e);
                                                Utils.BreakIfDebug();
                                            }
                                        }
                                        else if (strEntryFullName.EndsWith(".txt",
                                                                           StringComparison.OrdinalIgnoreCase)
                                                 && !strKey.Contains('.'))
                                        {
                                            lstTextStatBlockLines = new List<string>(30);
                                            using (Stream objStream = objEntry.Open())
                                            {
                                                token.ThrowIfCancellationRequested();
                                                using (StreamReader objReader = new StreamReader(objStream))
                                                {
                                                    token.ThrowIfCancellationRequested();
                                                    for (string strLine = blnSync
                                                             // ReSharper disable once MethodHasAsyncOverload
                                                             ? objReader.ReadLine()
                                                             : await objReader.ReadLineAsync().ConfigureAwait(false);
                                                         strLine != null;
                                                         strLine = blnSync
                                                             // ReSharper disable once MethodHasAsyncOverload
                                                             ? objReader.ReadLine()
                                                             : await objReader.ReadLineAsync().ConfigureAwait(false))
                                                    {
                                                        token.ThrowIfCancellationRequested();
                                                        // Trim away the newlines and empty spaces at the beginning and end of lines
                                                        strLine = strLine.Trim('\n', '\r', ' ').Trim();

                                                        lstTextStatBlockLines.Add(strLine);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    else if (strEntryFullName.StartsWith("images", StringComparison.Ordinal) &&
                                             strEntryFullName.Contains('.'))
                                    {
                                        using (Stream objStream = objEntry.Open())
                                        {
                                            token.ThrowIfCancellationRequested();
                                            using (Bitmap bmpMugshot = new Bitmap(objStream, true))
                                            {
                                                token.ThrowIfCancellationRequested();
                                                Bitmap bmpNewMugshot =
                                                    bmpMugshot.PixelFormat == PixelFormat.Format32bppPArgb
                                                        ? bmpMugshot
                                                            .Clone() as Bitmap // Clone makes sure file handle is closed
                                                        : bmpMugshot.ConvertPixelFormat(PixelFormat.Format32bppPArgb);
                                                if (dicImages.TryGetValue(strKey, out Bitmap bmpExistingMugshot))
                                                {
                                                    bmpExistingMugshot.Dispose();
                                                    dicImages[strKey] = bmpNewMugshot;
                                                }
                                                else
                                                    dicImages.Add(strKey, bmpNewMugshot);
                                            }
                                        }
                                    }
                                }

                                if (!string.IsNullOrEmpty(strLeadsName))
                                {
                                    // Need a second sweep for the Leads file
                                    foreach (ZipArchiveEntry objEntry in zipArchive.Entries)
                                    {
                                        token.ThrowIfCancellationRequested();
                                        string strEntryFullName = objEntry.FullName;
                                        if (strEntryFullName.EndsWith(strLeadsName,
                                                                      StringComparison.OrdinalIgnoreCase))
                                        {
                                            try
                                            {
                                                if (blnSync)
                                                    DoLoadLeads();
                                                else
                                                    await Task.Run(DoLoadLeads, token).ConfigureAwait(false);
                                                void DoLoadLeads()
                                                {
                                                    using (Stream objStream = objEntry.Open())
                                                    {
                                                        token.ThrowIfCancellationRequested();
                                                        using (StreamReader objStreamReader =
                                                               new StreamReader(objStream, true))
                                                        {
                                                            token.ThrowIfCancellationRequested();
                                                            using (XmlReader objReader = XmlReader.Create(
                                                                       objStreamReader,
                                                                       GlobalSettings.SafeXmlReaderSettings))
                                                            {
                                                                token.ThrowIfCancellationRequested();
                                                                XPathDocument xmlSourceDoc
                                                                    = new XPathDocument(objReader);
                                                                xmlLeadsDocument = xmlSourceDoc.CreateNavigator();
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            // If we run into any problems loading the character xml files, fail out early.
                                            catch (IOException)
                                            {
                                                continue;
                                            }
                                            catch (XmlException)
                                            {
                                                continue;
                                            }

                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        catch (IOException ex)
                        {
                            if (op_load != null)
                            {
                                op_load.SetSuccess(false);
                                op_load.AddBaggage(ex.GetType().Name, ex.Message);
                                Log.Error(ex);
                            }

                            Program.ShowScrollableMessageBox(
                                string.Format(GlobalSettings.CultureInfo,
                                              blnSync
                                                  // ReSharper disable once MethodHasAsyncOverload
                                                  ? LanguageManager.GetString("Message_FailedLoad", token: token)
                                                  : await LanguageManager.GetStringAsync("Message_FailedLoad", token: token).ConfigureAwait(false),
                                              ex.Message),
                                blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? LanguageManager.GetString("MessageTitle_FailedLoad", token: token)
                                    : await LanguageManager.GetStringAsync("MessageTitle_FailedLoad", token: token).ConfigureAwait(false),
                                MessageBoxButtons.OK, MessageBoxIcon.Error);
                            return false;
                        }
                        catch (NotSupportedException ex)
                        {
                            if (op_load != null)
                            {
                                op_load.SetSuccess(false);
                                op_load.AddBaggage(ex.GetType().Name, ex.Message);
                                Log.Error(ex);
                            }

                            Program.ShowScrollableMessageBox(
                                string.Format(GlobalSettings.CultureInfo,
                                              blnSync
                                                  // ReSharper disable once MethodHasAsyncOverload
                                                  ? LanguageManager.GetString("Message_FailedLoad", token: token)
                                                  : await LanguageManager.GetStringAsync("Message_FailedLoad", token: token).ConfigureAwait(false),
                                              ex.Message),
                                blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? LanguageManager.GetString("MessageTitle_FailedLoad", token: token)
                                    : await LanguageManager.GetStringAsync("MessageTitle_FailedLoad", token: token).ConfigureAwait(false),
                                MessageBoxButtons.OK, MessageBoxIcon.Error);
                            return false;
                        }
                        catch (UnauthorizedAccessException ex)
                        {
                            if (op_load != null)
                            {
                                op_load.SetSuccess(false);
                                op_load.AddBaggage(ex.GetType().Name, ex.Message);
                                Log.Error(ex);
                            }

                            Program.ShowScrollableMessageBox(
                                string.Format(GlobalSettings.CultureInfo,
                                              blnSync
                                                  // ReSharper disable once MethodHasAsyncOverload
                                                  ? LanguageManager.GetString("Message_FailedLoad", token: token)
                                                  : await LanguageManager.GetStringAsync("Message_FailedLoad", token: token).ConfigureAwait(false),
                                              ex.Message),
                                blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? LanguageManager.GetString("MessageTitle_FailedLoad", token: token)
                                    : await LanguageManager.GetStringAsync("MessageTitle_FailedLoad", token: token).ConfigureAwait(false),
                                MessageBoxButtons.OK, MessageBoxIcon.Error);
                            return false;
                        }

                        if (xmlLeadsDocument == null || xmlStatBlockDocument == null)
                        {
                            return false;
                        }

                        IsLoading = true;
                        try
                        {
                            XPathNavigator xmlStatBlockBaseNode;
                            XPathNavigator xmlLeadsBaseNode;

                            using (Timekeeper.StartSyncron("load_char_misc", op_load))
                            {
                                _dateFileLastWriteTime = File.GetLastWriteTimeUtc(strPorFile);

                                xmlStatBlockBaseNode =
                                    xmlStatBlockDocument.SelectSingleNode("/document/public/character[@name = " +
                                                                          strCharacterId.CleanXPath() + ']');
                                xmlLeadsBaseNode =
                                    xmlLeadsDocument.SelectSingleNode("/document/hero[@heroname = " +
                                                                      strCharacterId.CleanXPath() +
                                                                      "]");

                                _blnCreated =
                                    ((blnSync
                                        // ReSharper disable once MethodHasAsyncOverload
                                        ? xmlStatBlockBaseNode.SelectSingleNodeAndCacheExpression("karma/@total", token)
                                        : await xmlStatBlockBaseNode.SelectSingleNodeAndCacheExpressionAsync(
                                            "karma/@total", token).ConfigureAwait(false))?.Value ?? "0") !=
                                    "0";
                                if (!_blnCreated)
                                {
                                    XPathNodeIterator xmlJournalEntries = blnSync
                                        // ReSharper disable once MethodHasAsyncOverload
                                        ? xmlStatBlockBaseNode.SelectAndCacheExpression("journals/journal", token)
                                        : await xmlStatBlockBaseNode.SelectAndCacheExpressionAsync("journals/journal", token).ConfigureAwait(false);
                                    if (xmlJournalEntries.Count > 1)
                                    {
                                        _blnCreated = true;
                                    }
                                    else if (xmlJournalEntries.Count == 1 &&
                                             (blnSync
                                                 // ReSharper disable once MethodHasAsyncOverload
                                                 ? xmlJournalEntries.Current.SelectSingleNodeAndCacheExpression("@name", token)?.Value != "Title"
                                                 : (await xmlJournalEntries.Current
                                                                           .SelectSingleNodeAndCacheExpressionAsync(
                                                                               "@name", token).ConfigureAwait(false))?.Value != "Title"))
                                    {
                                        _blnCreated = true;
                                    }
                                }

                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ResetCharacter(token);
                                else
                                    await ResetCharacterAsync(token).ConfigureAwait(false);

                                // Get the name of the settings file in use if possible.
                                if (!string.IsNullOrEmpty(strSettingsKey))
                                {
                                    if (blnSync
                                            ? !SettingsManager.LoadedCharacterSettings.ContainsKey(strSettingsKey)
                                            : !await (await SettingsManager.GetLoadedCharacterSettingsAsync(token).ConfigureAwait(false)).ContainsKeyAsync(strSettingsKey, token).ConfigureAwait(false))
                                        return false;

                                    if (blnSync)
                                        SettingsKey = strSettingsKey;
                                    else
                                        await SetSettingsKeyAsync(strSettingsKey, token).ConfigureAwait(false);
                                }

                                // Metatype information.
                                string strRaceString = blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? xmlStatBlockBaseNode.SelectSingleNodeAndCacheExpression("race/@name", token)?.Value
                                    : (await xmlStatBlockBaseNode.SelectSingleNodeAndCacheExpressionAsync(
                                        "race/@name", token).ConfigureAwait(false))?.Value;
                                if (!string.IsNullOrEmpty(strRaceString))
                                {
                                    if (strRaceString == "Metasapient")
                                        strRaceString = "A.I.";
                                    if (blnSync)
                                    {
                                        // ReSharper disable MethodHasAsyncOverload
                                        foreach (XPathNavigator xmlMetatype in
                                                     LoadDataXPath("metatypes.xml", token: token)
                                                         .SelectAndCacheExpression("/chummer/metatypes/metatype", token))
                                        {
                                            string strMetatypeName
                                                = xmlMetatype.SelectSingleNodeAndCacheExpression("name", token).Value;
                                            if (strMetatypeName == strRaceString)
                                            {
                                                _strMetatype = strMetatypeName;
                                                _strMetatypeCategory = xmlMetatype
                                                                       .SelectSingleNodeAndCacheExpression("category", token)
                                                                       .Value;
                                                _strMetavariant = "None";
                                                
                                                XPathNavigator objRunNode
                                                    = xmlMetatype.SelectSingleNodeAndCacheExpression("run", token);
                                                XPathNavigator objWalkNode
                                                    = xmlMetatype.SelectSingleNodeAndCacheExpression("walk", token);
                                                XPathNavigator objSprintNode
                                                    = xmlMetatype.SelectSingleNodeAndCacheExpression("sprint", token);
                                                
                                                _strMovement
                                                    = xmlMetatype.SelectSingleNodeAndCacheExpression("movement", token)?.Value
                                                      ??
                                                      string.Empty;
                                                _strRun = objRunNode?.Value ?? string.Empty;
                                                _strWalk = objWalkNode?.Value ?? string.Empty;
                                                _strSprint = objSprintNode?.Value ?? string.Empty;
                                                
                                                objRunNode = objRunNode?.SelectSingleNodeAndCacheExpression("@alt", token);
                                                objWalkNode = objWalkNode?.SelectSingleNodeAndCacheExpression("@alt", token);
                                                objSprintNode
                                                    = objSprintNode?.SelectSingleNodeAndCacheExpression("@alt", token);
                                                _strRunAlt = objRunNode?.Value ?? string.Empty;
                                                _strWalkAlt = objWalkNode?.Value ?? string.Empty;
                                                _strSprintAlt = objSprintNode?.Value ?? string.Empty;
                                                break;
                                            }

                                            foreach (XPathNavigator xmlMetavariant in xmlMetatype.Select(
                                                         "metavariants/metavariant"))
                                            {
                                                string strMetavariantName =
                                                    xmlMetavariant.SelectSingleNodeAndCacheExpression("name", token).Value;
                                                if (strMetavariantName == strRaceString)
                                                {
                                                    _strMetatype = strMetatypeName;
                                                    _strMetatypeCategory =
                                                        xmlMetatype.SelectSingleNodeAndCacheExpression("category", token)
                                                                   .Value;
                                                    _strMetavariant = strMetavariantName;
                                                    
                                                    XPathNavigator objRunNode =
                                                        xmlMetavariant?.SelectSingleNodeAndCacheExpression("run", token) ??
                                                        xmlMetatype?.SelectSingleNodeAndCacheExpression("run", token);
                                                    XPathNavigator objWalkNode =
                                                        xmlMetavariant?.SelectSingleNodeAndCacheExpression("walk", token) ??
                                                        xmlMetatype?.SelectSingleNodeAndCacheExpression("walk", token);
                                                    XPathNavigator objSprintNode =
                                                        xmlMetavariant?.SelectSingleNodeAndCacheExpression("sprint", token) ??
                                                        xmlMetatype?.SelectSingleNodeAndCacheExpression("sprint", token);
                                                    
                                                    _strMovement =
                                                        xmlMetavariant?.SelectSingleNodeAndCacheExpression("movement", token)
                                                                      ?.Value ??
                                                        xmlMetatype?.SelectSingleNodeAndCacheExpression("movement", token)
                                                                   ?.Value ??
                                                        string.Empty;
                                                    _strRun = objRunNode?.Value ?? string.Empty;
                                                    _strWalk = objWalkNode?.Value ?? string.Empty;
                                                    _strSprint = objSprintNode?.Value ?? string.Empty;
                                                    
                                                    objRunNode = objRunNode?.SelectSingleNodeAndCacheExpression("@alt", token);
                                                    objWalkNode
                                                        = objWalkNode?.SelectSingleNodeAndCacheExpression("@alt", token);
                                                    objSprintNode
                                                        = objSprintNode?.SelectSingleNodeAndCacheExpression("@alt", token);
                                                    _strRunAlt = objRunNode?.Value ?? string.Empty;
                                                    _strWalkAlt = objWalkNode?.Value ?? string.Empty;
                                                    _strSprintAlt = objSprintNode?.Value ?? string.Empty;
                                                    break;
                                                }
                                            }
                                        }
                                        // ReSharper restore MethodHasAsyncOverload
                                    }
                                    else
                                    {
                                        foreach (XPathNavigator xmlMetatype in await (await LoadDataXPathAsync("metatypes.xml", token: token)
                                                                 .ConfigureAwait(false))
                                                             .SelectAndCacheExpressionAsync(
                                                                 "/chummer/metatypes/metatype", token: token)
                                                             .ConfigureAwait(false))
                                        {
                                            string strMetatypeName
                                                = (await xmlMetatype.SelectSingleNodeAndCacheExpressionAsync("name", token).ConfigureAwait(false)).Value;
                                            if (strMetatypeName == strRaceString)
                                            {
                                                _strMetatype = strMetatypeName;
                                                _strMetatypeCategory = (await xmlMetatype
                                                                              .SelectSingleNodeAndCacheExpressionAsync("category", token).ConfigureAwait(false))
                                                                       .Value;
                                                _strMetavariant = "None";

                                                XPathNavigator objRunNode
                                                    = await xmlMetatype.SelectSingleNodeAndCacheExpressionAsync("run", token).ConfigureAwait(false);
                                                XPathNavigator objWalkNode
                                                    = await xmlMetatype.SelectSingleNodeAndCacheExpressionAsync("walk", token).ConfigureAwait(false);
                                                XPathNavigator objSprintNode
                                                    = await xmlMetatype.SelectSingleNodeAndCacheExpressionAsync("sprint", token).ConfigureAwait(false);

                                                _strMovement
                                                    = (await xmlMetatype.SelectSingleNodeAndCacheExpressionAsync(
                                                          "movement", token).ConfigureAwait(false))?.Value
                                                      ??
                                                      string.Empty;
                                                _strRun = objRunNode?.Value ?? string.Empty;
                                                _strWalk = objWalkNode?.Value ?? string.Empty;
                                                _strSprint = objSprintNode?.Value ?? string.Empty;

                                                objRunNode = objRunNode != null ? await objRunNode.SelectSingleNodeAndCacheExpressionAsync("@alt", token).ConfigureAwait(false) : null;
                                                objWalkNode = objWalkNode != null ? await objWalkNode.SelectSingleNodeAndCacheExpressionAsync("@alt", token).ConfigureAwait(false) : null;
                                                objSprintNode = objSprintNode != null ? await objSprintNode.SelectSingleNodeAndCacheExpressionAsync("@alt", token).ConfigureAwait(false) : null;
                                                _strRunAlt = objRunNode?.Value ?? string.Empty;
                                                _strWalkAlt = objWalkNode?.Value ?? string.Empty;
                                                _strSprintAlt = objSprintNode?.Value ?? string.Empty;
                                                break;
                                            }

                                            foreach (XPathNavigator xmlMetavariant in xmlMetatype.Select(
                                                         "metavariants/metavariant"))
                                            {
                                                string strMetavariantName =
                                                    (await xmlMetavariant.SelectSingleNodeAndCacheExpressionAsync("name", token).ConfigureAwait(false)).Value;
                                                if (strMetavariantName == strRaceString)
                                                {
                                                    _strMetatype = strMetatypeName;
                                                    _strMetatypeCategory =
                                                        (await xmlMetatype.SelectSingleNodeAndCacheExpressionAsync("category", token).ConfigureAwait(false))
                                                                   .Value;
                                                    _strMetavariant = strMetavariantName;

                                                    XPathNavigator objRunNode =
                                                        await xmlMetavariant.SelectSingleNodeAndCacheExpressionAsync("run", token).ConfigureAwait(false) ??
                                                        await xmlMetatype.SelectSingleNodeAndCacheExpressionAsync("run", token).ConfigureAwait(false);
                                                    XPathNavigator objWalkNode =
                                                        await xmlMetavariant.SelectSingleNodeAndCacheExpressionAsync("walk", token).ConfigureAwait(false) ??
                                                        await xmlMetatype.SelectSingleNodeAndCacheExpressionAsync("walk", token).ConfigureAwait(false);
                                                    XPathNavigator objSprintNode =
                                                        await xmlMetavariant.SelectSingleNodeAndCacheExpressionAsync("sprint", token).ConfigureAwait(false) ??
                                                        await xmlMetatype.SelectSingleNodeAndCacheExpressionAsync("sprint", token).ConfigureAwait(false);

                                                    _strMovement =
                                                        (await xmlMetavariant.SelectSingleNodeAndCacheExpressionAsync("movement", token).ConfigureAwait(false))
                                                                      ?.Value ??
                                                        (await xmlMetatype.SelectSingleNodeAndCacheExpressionAsync("movement", token).ConfigureAwait(false))
                                                                   ?.Value ??
                                                        string.Empty;
                                                    _strRun = objRunNode?.Value ?? string.Empty;
                                                    _strWalk = objWalkNode?.Value ?? string.Empty;
                                                    _strSprint = objSprintNode?.Value ?? string.Empty;

                                                    objRunNode = objRunNode != null ? await objRunNode.SelectSingleNodeAndCacheExpressionAsync("@alt", token).ConfigureAwait(false) : null;
                                                    objWalkNode = objWalkNode != null ? await objWalkNode.SelectSingleNodeAndCacheExpressionAsync("@alt", token).ConfigureAwait(false) : null;
                                                    objSprintNode = objSprintNode != null ? await objSprintNode.SelectSingleNodeAndCacheExpressionAsync("@alt", token).ConfigureAwait(false) : null;
                                                    _strRunAlt = objRunNode?.Value ?? string.Empty;
                                                    _strWalkAlt = objWalkNode?.Value ?? string.Empty;
                                                    _strSprintAlt = objSprintNode?.Value ?? string.Empty;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }

                                // General character information.
                                int intAsIndex = strCharacterId.IndexOf(" as ", StringComparison.Ordinal);
                                if (intAsIndex != -1)
                                {
                                    _strName = strCharacterId.Substring(0, intAsIndex);
                                    _strAlias = strCharacterId.Substring(intAsIndex).TrimStart(" as ").Trim('\'');
                                }
                                else
                                {
                                    _strAlias = strCharacterId;
                                }

                                if (blnSync)
                                {
                                    // ReSharper disable MethodHasAsyncOverload
                                    XPathNavigator xmlPersonalNode = xmlStatBlockBaseNode.SelectSingleNodeAndCacheExpression("personal", token);
                                    if (xmlPersonalNode != null)
                                    {
                                        _strBackground = xmlPersonalNode.SelectSingleNodeAndCacheExpression("description", token)?.Value;
                                        _strHeight = xmlPersonalNode.SelectSingleNodeAndCacheExpression("charheight/@text", token)?.Value;
                                        _strWeight = xmlPersonalNode.SelectSingleNodeAndCacheExpression("charweight/@text", token)?.Value;
                                        if (xmlPersonalNode.HasAttributes)
                                        {
                                            _strGender = xmlPersonalNode.SelectSingleNodeAndCacheExpression("@gender", token)?.Value;
                                            _strAge = xmlPersonalNode.SelectSingleNodeAndCacheExpression("@age", token)?.Value;
                                            _strHair = xmlPersonalNode.SelectSingleNodeAndCacheExpression("@hair", token)?.Value;
                                            _strEyes = xmlPersonalNode.SelectSingleNodeAndCacheExpression("@eyes", token)?.Value;
                                            _strSkin = xmlPersonalNode.SelectSingleNodeAndCacheExpression("@skin", token)?.Value;
                                        }
                                    }
                                    // ReSharper enable MethodHasAsyncOverload
                                }
                                else
                                {
                                    XPathNavigator xmlPersonalNode = await xmlStatBlockBaseNode.SelectSingleNodeAndCacheExpressionAsync("personal", token).ConfigureAwait(false);
                                    if (xmlPersonalNode != null)
                                    {
                                        _strBackground = (await xmlPersonalNode.SelectSingleNodeAndCacheExpressionAsync(
                                            "description", token).ConfigureAwait(false))?.Value;
                                        _strHeight = (await xmlPersonalNode.SelectSingleNodeAndCacheExpressionAsync(
                                            "charheight/@text", token).ConfigureAwait(false))?.Value;
                                        _strWeight = (await xmlPersonalNode.SelectSingleNodeAndCacheExpressionAsync(
                                            "charweight/@text", token).ConfigureAwait(false))?.Value;
                                        if (xmlPersonalNode.HasAttributes)
                                        {
                                            _strGender = (await xmlPersonalNode.SelectSingleNodeAndCacheExpressionAsync(
                                                "@gender", token).ConfigureAwait(false))?.Value;
                                            _strAge = (await xmlPersonalNode.SelectSingleNodeAndCacheExpressionAsync(
                                                "@age", token).ConfigureAwait(false))?.Value;
                                            _strHair = (await xmlPersonalNode.SelectSingleNodeAndCacheExpressionAsync(
                                                "@hair", token).ConfigureAwait(false))?.Value;
                                            _strEyes = (await xmlPersonalNode.SelectSingleNodeAndCacheExpressionAsync(
                                                "@eyes", token).ConfigureAwait(false))?.Value;
                                            _strSkin = (await xmlPersonalNode.SelectSingleNodeAndCacheExpressionAsync(
                                                "@skin", token).ConfigureAwait(false))?.Value;
                                        }
                                    }
                                }

                                _strPlayerName
                                    = (blnSync
                                        // ReSharper disable once MethodHasAsyncOverload
                                        ? xmlStatBlockBaseNode.SelectSingleNodeAndCacheExpression("@playername", token)
                                        : await xmlStatBlockBaseNode.SelectSingleNodeAndCacheExpressionAsync(
                                            "@playername", token).ConfigureAwait(false))?.Value;

                                foreach (XPathNavigator xmlImageFileNameNode in xmlStatBlockBaseNode.SelectAndCacheExpression(
                                             "images/image/@filename", token))
                                {
                                    if (dicImages.TryGetValue(xmlImageFileNameNode.Value, out Bitmap objOutput))
                                    {
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstMugshots.Add(objOutput);
                                        else
                                            await _lstMugshots.AddAsync(objOutput, token).ConfigureAwait(false);
                                    }
                                }

                                if (_lstMugshots.Count > 0)
                                    _intMainMugshotIndex = 0;

                                if (string.IsNullOrEmpty(strSettingsKey))
                                {
                                    string strSettingsSummary =
                                        (blnSync
                                            // ReSharper disable once MethodHasAsyncOverload
                                            ? xmlStatBlockBaseNode.SelectSingleNodeAndCacheExpression(
                                                "settings/@summary", token)
                                            : await xmlStatBlockBaseNode.SelectSingleNodeAndCacheExpressionAsync(
                                                "settings/@summary", token).ConfigureAwait(false))?.Value;
                                    if (!string.IsNullOrEmpty(strSettingsSummary))
                                    {
                                        int intCharCreationSystemsIndex =
                                            strSettingsSummary.IndexOf("Character Creation Systems:",
                                                                       StringComparison.OrdinalIgnoreCase);
                                        if (intCharCreationSystemsIndex != -1)
                                        {
                                            int intSemicolonIndex
                                                = strSettingsSummary.IndexOf(';', intCharCreationSystemsIndex);
                                            if (intCharCreationSystemsIndex + 28 <= intSemicolonIndex)
                                            {
                                                string strHeroLabSettingsName = strSettingsSummary.Substring(
                                                        intCharCreationSystemsIndex + 28,
                                                        strSettingsSummary.IndexOf(';', intCharCreationSystemsIndex)
                                                        - 28 - intCharCreationSystemsIndex)
                                                    .Trim();
                                                if (strHeroLabSettingsName == "Established Runners")
                                                    strHeroLabSettingsName = "Standard";

                                                if (strHeroLabSettingsName == "Standard")
                                                {
                                                    bool blnDoFullHouse = false;
                                                    int intSourcebooksIndex
                                                        = strSettingsSummary.IndexOf(
                                                            "Core Rulebooks:", StringComparison.OrdinalIgnoreCase);
                                                    if (intSourcebooksIndex != -1)
                                                    {
                                                        intSemicolonIndex
                                                            = strSettingsSummary.IndexOf(';', intSourcebooksIndex);
                                                        if (intSourcebooksIndex + 16 < intSemicolonIndex)
                                                        {
                                                            blnDoFullHouse
                                                                = true; // We probably have multiple books enabled, so use Full House instead
                                                        }
                                                    }

                                                    bool blnIsKarmaBased = xmlStatBlockBaseNode
                                                                           .SelectSingleNodeAndCacheExpression("creation/bp/@total", token)
                                                                           ?.ValueAsInt > 100;
                                                    if (blnDoFullHouse)
                                                    {
                                                        strHeroLabSettingsName = blnIsKarmaBased
                                                            ? "Full House (Point Buy)"
                                                            : "Full House";
                                                    }
                                                    else if (blnIsKarmaBased)
                                                        strHeroLabSettingsName = "Point Buy";
                                                }

                                                if (blnSync)
                                                {
                                                    CharacterSettings objHeroLabSettings =
                                                        SettingsManager.LoadedCharacterSettings.FirstOrDefault(
                                                            x => x.Value.Name == strHeroLabSettingsName).Value;
                                                    if (objHeroLabSettings != null)
                                                    {
                                                        strSettingsKey = objHeroLabSettings.DictionaryKey;
                                                        SettingsKey = strSettingsKey;
                                                    }
                                                }
                                                else
                                                {
                                                    CharacterSettings objHeroLabSettings =
                                                        (await SettingsManager.LoadedCharacterSettings
                                                                              .FirstOrDefaultAsync(
                                                                                  x => x.Value.Name
                                                                                      == strHeroLabSettingsName, token)
                                                                              .ConfigureAwait(false)).Value;
                                                    if (objHeroLabSettings != null)
                                                    {
                                                        strSettingsKey = await objHeroLabSettings
                                                                               .GetDictionaryKeyAsync(token)
                                                                               .ConfigureAwait(false);
                                                        await SetSettingsKeyAsync(strSettingsKey, token: token)
                                                            .ConfigureAwait(false);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }

                                if (string.IsNullOrEmpty(strSettingsKey))
                                {
                                    if (Program.ShowScrollableMessageBox(
                                            string.Format(GlobalSettings.CultureInfo,
                                                          blnSync
                                                              // ReSharper disable once MethodHasAsyncOverload
                                                              ? LanguageManager.GetString(
                                                                  "Message_MissingGameplayOption", token: token)
                                                              : await LanguageManager
                                                                      .GetStringAsync(
                                                                          "Message_MissingGameplayOption", token: token).ConfigureAwait(false),
                                                          blnSync ? SettingsKey : await GetSettingsKeyAsync(token).ConfigureAwait(false)),
                                            blnSync
                                                // ReSharper disable once MethodHasAsyncOverload
                                                ? LanguageManager.GetString(
                                                    "Message_MissingGameplayOption_Title", token: token)
                                                : await LanguageManager.GetStringAsync(
                                                    "Message_MissingGameplayOption_Title", token: token).ConfigureAwait(false),
                                            MessageBoxButtons.OKCancel, MessageBoxIcon.Error)
                                        == DialogResult.OK)
                                    {
                                        if (blnSync)
                                        {
                                            // ReSharper disable MethodHasAsyncOverload
                                            // ReSharper disable MethodHasAsyncOverloadWithCancellation
                                            using (ThreadSafeForm<SelectBuildMethod> frmPickBP
                                                   = ThreadSafeForm<SelectBuildMethod>.Get(
                                                       () => new SelectBuildMethod(this, true)))
                                            {
                                                if (frmPickBP.ShowDialogSafe(this, token) != DialogResult.OK)
                                                    return false;
                                            }
                                            // ReSharper restore MethodHasAsyncOverloadWithCancellation
                                            // ReSharper restore MethodHasAsyncOverload
                                        }
                                        else
                                        {
                                            using (ThreadSafeForm<SelectBuildMethod> frmPickBP =
                                                   await ThreadSafeForm<SelectBuildMethod>.GetAsync(
                                                       () => new SelectBuildMethod(this, true), token).ConfigureAwait(false))
                                            {
                                                if (await frmPickBP.ShowDialogSafeAsync(this, token).ConfigureAwait(false) != DialogResult.OK)
                                                    return false;
                                            }
                                        }
                                    }
                                    else
                                        return false;
                                }

                                if (EffectiveBuildMethodUsesPriorityTables)
                                {
                                    if (strRaceString == "A.I.")
                                        _strPriorityTalent = "AI";
                                    XPathNavigator xmlPriorityTalentPick =
                                        xmlLeadsBaseNode.SelectSingleNodeAndCacheExpression(
                                            "container/pick[starts-with(@thing, \"qu\") and @source = \"heritage\"]", token);
                                    if (xmlPriorityTalentPick != null)
                                    {
                                        switch (xmlPriorityTalentPick.SelectSingleNodeAndCacheExpression("@thing", token)?.Value)
                                        {
                                            case "quAware":
                                                _strPriorityTalent = "Aware";
                                                break;

                                            case "quEnchanter":
                                                _strPriorityTalent = "Enchanter";
                                                break;

                                            case "quExplorer":
                                                _strPriorityTalent = "Explorer";
                                                break;

                                            case "quApprentice":
                                                _strPriorityTalent = "Apprentice";
                                                break;

                                            case "quAspectedMagician":
                                                _strPriorityTalent = "Aspected Magician";
                                                break;

                                            case "quAdept":
                                                _strPriorityTalent = "Adept";
                                                break;

                                            case "quMagician":
                                                _strPriorityTalent = "Magician";
                                                break;

                                            case "quMysticAdept":
                                                _strPriorityTalent = "Mystic Adept";
                                                break;

                                            case "quTechnoma":
                                                _strPriorityTalent = "Technomancer";
                                                break;
                                        }

                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstPrioritySkills.Clear();
                                        else
                                            await _lstPrioritySkills.ClearAsync(token).ConfigureAwait(false);
                                        foreach (XPathNavigator xmlField in (blnSync
                                                     // ReSharper disable once MethodHasAsyncOverload
                                                     ? xmlPriorityTalentPick.SelectAndCacheExpression("field", token)
                                                     : await xmlPriorityTalentPick.SelectAndCacheExpressionAsync(
                                                         "field", token).ConfigureAwait(false)))
                                        {
                                            string strInnerText = xmlField.Value;
                                            if (!string.IsNullOrEmpty(strInnerText))
                                            {
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    _lstPrioritySkills.Add(strInnerText);
                                                else
                                                    await _lstPrioritySkills.AddAsync(strInnerText, token).ConfigureAwait(false);
                                            }
                                        }
                                    }

                                    if (blnSync)
                                    {
                                        // ReSharper disable MethodHasAsyncOverload
                                        // ReSharper disable MethodHasAsyncOverloadWithCancellation
                                        using (ThreadSafeForm<SelectMetatypePriority> frmSelectMetatype =
                                               ThreadSafeForm<SelectMetatypePriority>.Get(
                                                   () => new SelectMetatypePriority(this)))
                                        {
                                            if (frmSelectMetatype.ShowDialogSafe(this, token) != DialogResult.OK)
                                                return false;
                                        }
                                        // ReSharper restore MethodHasAsyncOverloadWithCancellation
                                        // ReSharper restore MethodHasAsyncOverload
                                    }
                                    else
                                    {
                                        using (ThreadSafeForm<SelectMetatypePriority> frmSelectMetatype =
                                               await ThreadSafeForm<SelectMetatypePriority>.GetAsync(
                                                   () => new SelectMetatypePriority(this), token).ConfigureAwait(false))
                                        {
                                            if (await frmSelectMetatype.ShowDialogSafeAsync(this, token).ConfigureAwait(false) != DialogResult.OK)
                                                return false;
                                        }
                                    }
                                }
                                else
                                {
                                    if (blnSync)
                                    {
                                        // ReSharper disable MethodHasAsyncOverload
                                        // ReSharper disable MethodHasAsyncOverloadWithCancellation
                                        using (ThreadSafeForm<SelectMetatypeKarma> frmSelectMetatype =
                                               ThreadSafeForm<SelectMetatypeKarma>.Get(
                                                   () => new SelectMetatypeKarma(this)))
                                        {
                                            if (frmSelectMetatype.ShowDialogSafe(this, token) != DialogResult.OK)
                                                return false;
                                        }
                                        // ReSharper restore MethodHasAsyncOverloadWithCancellation
                                        // ReSharper restore MethodHasAsyncOverload
                                    }
                                    else
                                    {
                                        using (ThreadSafeForm<SelectMetatypeKarma> frmSelectMetatype =
                                               await ThreadSafeForm<SelectMetatypeKarma>.GetAsync(
                                                   () => new SelectMetatypeKarma(this), token).ConfigureAwait(false))
                                        {
                                            if (await frmSelectMetatype.ShowDialogSafeAsync(this, token: token).ConfigureAwait(false) != DialogResult.OK)
                                                return false;
                                        }
                                    }
                                }

                                XPathNavigator xmlKarmaNode = xmlStatBlockBaseNode.SelectSingleNodeAndCacheExpression("karma", token);
                                if (xmlKarmaNode != null)
                                {
                                    int.TryParse(xmlKarmaNode.SelectSingleNodeAndCacheExpression("@left", token)?.Value, NumberStyles.Any,
                                                 GlobalSettings.InvariantCultureInfo, out _intKarma);
                                    int.TryParse(xmlKarmaNode.SelectSingleNodeAndCacheExpression("@total", token)?.Value, NumberStyles.Any,
                                                 GlobalSettings.InvariantCultureInfo, out _intTotalKarma);
                                }

                                XPathNavigator xmlReputationsNode =
                                    xmlStatBlockBaseNode.SelectSingleNodeAndCacheExpression("reputations", token);
                                if (xmlReputationsNode != null)
                                {
                                    int.TryParse(
                                        xmlReputationsNode
                                            .SelectSingleNodeAndCacheExpression("reputation[@name = \"Street Cred\"]/@value", token)
                                            .Value,
                                        NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                        out _intStreetCred);
                                    int.TryParse(
                                        xmlReputationsNode
                                            .SelectSingleNodeAndCacheExpression("reputation[@name = \"Notoriety\"]/@value", token)
                                            .Value,
                                        NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                        out _intNotoriety);
                                    int.TryParse(
                                        xmlReputationsNode
                                            .SelectSingleNodeAndCacheExpression("reputation[@name = \"Public Awareness\"]/@value", token)
                                            .Value, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                        out _intPublicAwareness);
                                }

                                if (Created)
                                {
                                    decimal.TryParse(xmlStatBlockBaseNode.SelectSingleNodeAndCacheExpression("cash/@total", token)?.Value,
                                                     NumberStyles.Any,
                                                     GlobalSettings.InvariantCultureInfo, out _decNuyen);
                                }

                                /* TODO: Initiation, Submersion Grades
                                objXmlCharacter.TryGetInt32FieldQuickly("initiategrade", ref _intInitiateGrade);
                                objXmlCharacter.TryGetInt32FieldQuickly("submersiongrade", ref _intSubmersionGrade);
                                */
                                //Timekeeper.Finish("load_char_misc");
                            }

                            List<Weapon> lstWeapons = new List<Weapon>(1);
                            List<Vehicle> lstVehicles = new List<Vehicle>(1);

                            using (Timekeeper.StartSyncron("load_char_quality", op_load))
                            {
                                string[] astrLevelLabels =
                                {
                                    " (0)",
                                    " (1)",
                                    " (2)",
                                    " (3)",
                                    " (4)",
                                    " (5)",
                                    " (6)",
                                    " (7)",
                                    " (8)",
                                    " (9)",
                                    " (10)",
                                    " (11)",
                                    " (12)",
                                    " (13)",
                                    " (14)",
                                    " (15)"
                                };
                                // Qualities
                                XmlDocument xmlQualitiesDocument = blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? LoadData("qualities.xml", token: token)
                                    : await LoadDataAsync("qualities.xml", token: token).ConfigureAwait(false);
                                foreach (XPathNavigator xmlQualityToImport in (blnSync
                                             ? xmlStatBlockBaseNode
                                                 .SelectAndCacheExpression(
                                                     "qualities/positive/quality[traitcost/@bp != \"0\"]", token)
                                             : await xmlStatBlockBaseNode.SelectAndCacheExpressionAsync(
                                                 "qualities/positive/quality[traitcost/@bp != \"0\"]", token).ConfigureAwait(false)))
                                {
                                    string strQualityName = (blnSync
                                        ? xmlQualityToImport.SelectSingleNodeAndCacheExpression(
                                            "@name", token)
                                        : await xmlQualityToImport.SelectSingleNodeAndCacheExpressionAsync(
                                            "@name", token).ConfigureAwait(false))?.Value;
                                    if (!string.IsNullOrEmpty(strQualityName))
                                    {
                                        int intDicepoolLabelIndex =
                                            strQualityName.LastIndexOf("dicepool", StringComparison.Ordinal);
                                        if (intDicepoolLabelIndex != -1)
                                        {
                                            int intCullIndex =
                                                strQualityName.LastIndexOf('(', intDicepoolLabelIndex);
                                            if (intCullIndex != -1)
                                                strQualityName = strQualityName.Substring(0, intCullIndex).Trim();
                                        }

                                        int intQuantity = 1;
                                        for (int i = 0; i < astrLevelLabels.Length; ++i)
                                        {
                                            string strLoopString = astrLevelLabels[i];
                                            if (strQualityName.EndsWith(strLoopString, StringComparison.Ordinal))
                                            {
                                                strQualityName = strQualityName.TrimEndOnce(strLoopString, true);
                                                intQuantity = i;
                                                break;
                                            }
                                        }

                                        string strForcedValue = string.Empty;
                                        XmlNode xmlQualityDataNode =
                                            xmlQualitiesDocument.TryGetNodeByNameOrId(
                                                "/chummer/qualities/quality", strQualityName);
                                        if (xmlQualityDataNode == null)
                                        {
                                            string[] astrOriginalNameSplit =
                                                strQualityName.Split(':', StringSplitOptions.RemoveEmptyEntries);
                                            if (astrOriginalNameSplit.Length > 1)
                                            {
                                                string strName = astrOriginalNameSplit[0].Trim();
                                                xmlQualityDataNode =
                                                    xmlQualitiesDocument.TryGetNodeByNameOrId(
                                                        "/chummer/qualities/quality", strName);
                                                if (xmlQualityDataNode != null)
                                                    strForcedValue = astrOriginalNameSplit[1].Trim();
                                            }
                                        }

                                        if (xmlQualityDataNode == null)
                                        {
                                            string[] astrOriginalNameSplit =
                                                strQualityName.Split(',', StringSplitOptions.RemoveEmptyEntries);
                                            if (astrOriginalNameSplit.Length > 1)
                                            {
                                                string strName = astrOriginalNameSplit[0].Trim();
                                                xmlQualityDataNode =
                                                    xmlQualitiesDocument.TryGetNodeByNameOrId(
                                                        "/chummer/qualities/quality", strName);
                                                if (xmlQualityDataNode != null)
                                                    strForcedValue = astrOriginalNameSplit[1].Trim();
                                            }
                                        }

                                        if (xmlQualityDataNode != null)
                                        {
                                            for (int i = 0; i < intQuantity; ++i)
                                            {
                                                Quality objQuality = new Quality(this);
                                                try
                                                {
                                                    objQuality.Create(xmlQualityDataNode, QualitySource.Selected,
                                                                      lstWeapons,
                                                                      strForcedValue);
                                                    objQuality.Notes =
                                                        (blnSync
                                                            ? xmlQualityToImport
                                                                .SelectSingleNodeAndCacheExpression(
                                                                    "description", token)
                                                            : await xmlQualityToImport
                                                                    .SelectSingleNodeAndCacheExpressionAsync(
                                                                        "description", token).ConfigureAwait(false))?.Value ??
                                                        string.Empty;
                                                    if (blnSync)
                                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                        _lstQualities.Add(objQuality);
                                                    else
                                                        await _lstQualities.AddAsync(objQuality, token)
                                                                           .ConfigureAwait(false);
                                                }
                                                catch
                                                {
                                                    if (blnSync)
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        objQuality.Dispose();
                                                    else
                                                        await objQuality.DisposeAsync().ConfigureAwait(false);
                                                    throw;
                                                }
                                            }
                                        }
                                    }
                                }

                                foreach (XPathNavigator xmlQualityToImport in xmlStatBlockBaseNode.SelectAndCacheExpression(
                                             "qualities/negative/quality[traitcost/@bp != \"0\"]", token))
                                {
                                    string strQualityName = (blnSync
                                        ? xmlQualityToImport.SelectSingleNodeAndCacheExpression(
                                            "@name", token)
                                        : await xmlQualityToImport.SelectSingleNodeAndCacheExpressionAsync(
                                            "@name", token).ConfigureAwait(false))?.Value;
                                    if (!string.IsNullOrEmpty(strQualityName))
                                    {
                                        int intDicepoolLabelIndex =
                                            strQualityName.LastIndexOf("dicepool", StringComparison.Ordinal);
                                        if (intDicepoolLabelIndex != -1)
                                        {
                                            int intCullIndex =
                                                strQualityName.LastIndexOf('(', intDicepoolLabelIndex);
                                            if (intCullIndex != -1)
                                                strQualityName = strQualityName.Substring(0, intCullIndex).Trim();
                                        }

                                        switch (strQualityName)
                                        {
                                            case "Reduced (hearing)":
                                                strQualityName = "Reduced Sense (Hearing)";
                                                break;

                                            case "Reduced (smell)":
                                                strQualityName = "Reduced Sense (Smell)";
                                                break;

                                            case "Reduced (taste)":
                                                strQualityName = "Reduced Sense (Taste)";
                                                break;

                                            case "Reduced (touch)":
                                                strQualityName = "Reduced Sense (Touch)";
                                                break;

                                            case "Reduced (sight)":
                                                strQualityName = "Reduced Sense (Sight)";
                                                break;
                                        }

                                        int intQuantity = 1;
                                        for (int i = 0; i < astrLevelLabels.Length; ++i)
                                        {
                                            string strLoopString = astrLevelLabels[i];
                                            if (strQualityName.EndsWith(strLoopString, StringComparison.Ordinal))
                                            {
                                                strQualityName = strQualityName.TrimEndOnce(strLoopString, true);
                                                intQuantity = i;
                                                break;
                                            }
                                        }

                                        string strForcedValue = string.Empty;
                                        XmlNode xmlQualityDataNode =
                                            xmlQualitiesDocument.TryGetNodeByNameOrId(
                                                "/chummer/qualities/quality", strQualityName);
                                        if (xmlQualityDataNode == null)
                                        {
                                            string[] astrOriginalNameSplit =
                                                strQualityName.Split(':', StringSplitOptions.RemoveEmptyEntries);
                                            if (astrOriginalNameSplit.Length > 1)
                                            {
                                                string strName = astrOriginalNameSplit[0].Trim();
                                                xmlQualityDataNode =
                                                    xmlQualitiesDocument.TryGetNodeByNameOrId(
                                                        "/chummer/qualities/quality", strName);
                                                if (xmlQualityDataNode != null)
                                                    strForcedValue = astrOriginalNameSplit[1].Trim();
                                            }
                                        }

                                        if (xmlQualityDataNode == null)
                                        {
                                            string[] astrOriginalNameSplit =
                                                strQualityName.Split(',', StringSplitOptions.RemoveEmptyEntries);
                                            if (astrOriginalNameSplit.Length > 1)
                                            {
                                                string strName = astrOriginalNameSplit[0].Trim();
                                                xmlQualityDataNode =
                                                    xmlQualitiesDocument.TryGetNodeByNameOrId(
                                                        "/chummer/qualities/quality", strName);
                                                if (xmlQualityDataNode != null)
                                                    strForcedValue = astrOriginalNameSplit[1].Trim();
                                            }
                                        }

                                        if (xmlQualityDataNode != null)
                                        {
                                            for (int i = 0; i < intQuantity; ++i)
                                            {
                                                Quality objQuality = new Quality(this);
                                                try
                                                {
                                                    objQuality.Create(xmlQualityDataNode, QualitySource.Selected,
                                                                      lstWeapons,
                                                                      strForcedValue);
                                                    objQuality.Notes =
                                                        (blnSync
                                                            ? xmlQualityToImport
                                                                .SelectSingleNodeAndCacheExpression(
                                                                    "description", token)
                                                            : await xmlQualityToImport
                                                                    .SelectSingleNodeAndCacheExpressionAsync(
                                                                        "description", token).ConfigureAwait(false))?.Value ??
                                                        string.Empty;
                                                    if (blnSync)
                                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                        _lstQualities.Add(objQuality);
                                                    else
                                                        await _lstQualities.AddAsync(objQuality, token: token)
                                                                           .ConfigureAwait(false);
                                                }
                                                catch
                                                {
                                                    if (blnSync)
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        objQuality.Dispose();
                                                    else
                                                        await objQuality.DisposeAsync().ConfigureAwait(false);
                                                    throw;
                                                }
                                            }
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_quality");
                            }

                            AttributeSection.LoadFromHeroLab(xmlStatBlockBaseNode, op_load, token);
                            using (Timekeeper.StartSyncron("load_char_misc2", op_load))
                            {
                                /* TODO: Find some way to get Mystic Adept PPs from Hero Lab files
                                // Attempt to load the split MAG CharacterAttribute information for Mystic Adepts.
                                if (_blnAdeptEnabled && _blnMagicianEnabled)
                                {
                                    xmlCharacterNavigator.TryGetInt32FieldQuickly("magsplitadept", ref _intMAGAdept);
                                    xmlCharacterNavigator.TryGetInt32FieldQuickly("magsplitmagician", ref _intMAGMagician);
                                }
                                */

                                // Attempt to load in the character's tradition
                                XPathNavigator xmlTemp
                                    = blnSync
                                        ? xmlStatBlockBaseNode.SelectSingleNodeAndCacheExpression(
                                            "magic/tradition", token)
                                        : await xmlStatBlockBaseNode.SelectSingleNodeAndCacheExpressionAsync(
                                            "magic/tradition", token).ConfigureAwait(false);
                                if (xmlTemp != null)
                                {
                                    _objTradition.LoadFromHeroLab(xmlTemp);
                                }

                                // Attempt to load Condition Monitor Progress.
                                XPathNavigator xmlPhysicalCMFilledNode =
                                    blnSync
                                        ? xmlLeadsBaseNode.SelectSingleNodeAndCacheExpression(
                                            "usagepool[@id = \"DmgNet\" and @pickindex=\"5\"]/@quantity", token)
                                        : await xmlLeadsBaseNode.SelectSingleNodeAndCacheExpressionAsync(
                                            "usagepool[@id = \"DmgNet\" and @pickindex=\"5\"]/@quantity", token).ConfigureAwait(false);
                                if (xmlPhysicalCMFilledNode != null)
                                    int.TryParse(xmlPhysicalCMFilledNode.Value, NumberStyles.Any,
                                                 GlobalSettings.InvariantCultureInfo, out _intPhysicalCMFilled);
                                XPathNavigator xmlStunCMFilledNode =
                                    blnSync
                                        ? xmlLeadsBaseNode.SelectSingleNodeAndCacheExpression(
                                            "usagepool[@id = \"DmgNet\" and @pickindex=\"6\"]/@quantity", token)
                                        : await xmlLeadsBaseNode.SelectSingleNodeAndCacheExpressionAsync(
                                            "usagepool[@id = \"DmgNet\" and @pickindex=\"6\"]/@quantity", token).ConfigureAwait(false);
                                if (xmlStunCMFilledNode != null)
                                    int.TryParse(xmlStunCMFilledNode.Value, NumberStyles.Any,
                                                 GlobalSettings.InvariantCultureInfo, out _intStunCMFilled);
                                //Timekeeper.Finish("load_char_misc2");
                            }

                            using (CustomActivity op_load_char_skills = Timekeeper.StartSyncron("load_char_skills", op_load)) //slightly messy
                            {
                                SkillsSection.LoadFromHeroLab(
                                    blnSync
                                        ? xmlStatBlockBaseNode.SelectSingleNodeAndCacheExpression("skills", token)
                                        : await xmlStatBlockBaseNode
                                                .SelectSingleNodeAndCacheExpressionAsync("skills", token)
                                                .ConfigureAwait(false),
                                    op_load_char_skills, token);

                                //Timekeeper.Finish("load_char_skills");
                            }

                            /* TODO: Add support for locations from HeroLab
                            Timekeeper.Start("load_char_loc");

                            // Locations.
                            XmlNodeList objXmlLocationList = objXmlCharacter.SelectNodes("gearlocations/gearlocation");
                            foreach (XmlNode objXmlLocation in objXmlLocationList)
                            {
                                Location objLocation = new Location(this, _lstGearLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }

                            objXmlLocationList = objXmlCharacter.SelectNodes("locations/location");
                            foreach (XmlNode objXmlLocation in objXmlLocationList)
                            {
                                Location objLocation = new Location(this, _lstGearLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }

                            objXmlLocationList = objXmlCharacter.SelectNodes("gearlocations/location");
                            foreach (XmlNode objXmlLocation in objXmlLocationList)
                            {
                                Location objLocation = new Location(this, _lstGearLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }

                            Timekeeper.Finish("load_char_loc");
                            Timekeeper.Start("load_char_abundle");

                            // Armor Bundles.
                            objXmlLocationList = objXmlCharacter.SelectNodes("armorbundles/armorbundle");
                            foreach (XmlNode objXmlLocation in objXmlLocationList)
                            {
                                Location objLocation = new Location(this, _lstArmorLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }

                            objXmlLocationList = objXmlCharacter.SelectNodes("armorlocations/armorlocation");
                            foreach (XmlNode objXmlLocation in objXmlLocationList)
                            {
                                Location objLocation = new Location(this, _lstArmorLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }

                            objXmlLocationList = objXmlCharacter.SelectNodes("armorlocations/location");
                            foreach (XmlNode objXmlLocation in objXmlLocationList)
                            {
                                Location objLocation = new Location(this, _lstArmorLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }

                            Timekeeper.Finish("load_char_abundle");
                            Timekeeper.Start("load_char_vloc");

                            // Vehicle Locations.
                            XmlNodeList objXmlVehicleLocationList = objXmlCharacter.SelectNodes("vehiclelocations/vehiclelocation");
                            foreach (XmlNode objXmlLocation in objXmlVehicleLocationList)
                            {
                                Location objLocation = new Location(this, _lstVehicleLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }

                            objXmlVehicleLocationList = objXmlCharacter.SelectNodes("vehiclelocations/location");
                            foreach (XmlNode objXmlLocation in objXmlVehicleLocationList)
                            {
                                Location objLocation = new Location(this, _lstVehicleLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }

                            Timekeeper.Finish("load_char_vloc");
                            Timekeeper.Start("load_char_wloc");

                            // Weapon Locations.
                            XmlNodeList objXmlWeaponLocationList = objXmlCharacter.SelectNodes("weaponlocations/weaponlocation");
                            foreach (XmlNode objXmlLocation in objXmlWeaponLocationList)
                            {
                                Location objLocation = new Location(this, _lstWeaponLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }

                            objXmlWeaponLocationList = objXmlCharacter.SelectNodes("weaponlocations/location");
                            foreach (XmlNode objXmlLocation in objXmlWeaponLocationList)
                            {
                                Location objLocation = new Location(this, _lstWeaponLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }

                            Timekeeper.Finish("load_char_wloc");
                            */
                            using (Timekeeper.StartSyncron("load_char_contacts", op_load))
                            {
                                // Contacts.
                                foreach (XPathNavigator xmlContactToImport in xmlStatBlockBaseNode.SelectAndCacheExpression(
                                             "contacts/contact[@useradded != \"no\"]", token))
                                {
                                    Contact objContact = new Contact(this)
                                    {
                                        EntityType = ContactType.Contact
                                    };
                                    if (blnSync)
                                    {
                                        objContact.Name
                                            = xmlContactToImport.SelectSingleNodeAndCacheExpression("@name", token)
                                                                ?.Value ?? string.Empty;
                                        objContact.Role
                                            = xmlContactToImport.SelectSingleNodeAndCacheExpression("@type", token)
                                                                ?.Value ?? string.Empty;
                                        objContact.Connection =
                                            xmlContactToImport.SelectSingleNodeAndCacheExpression("@connection", token)
                                                              ?.ValueAsInt ?? 1;
                                        objContact.Loyalty = xmlContactToImport
                                                             .SelectSingleNodeAndCacheExpression("@loyalty", token)
                                                             ?.ValueAsInt ?? 1;
                                    }
                                    else
                                    {
                                        objContact.Name
                                            = (await xmlContactToImport.SelectSingleNodeAndCacheExpressionAsync(
                                                "@name", token).ConfigureAwait(false))?.Value ?? string.Empty;
                                        objContact.Role
                                            = (await xmlContactToImport.SelectSingleNodeAndCacheExpressionAsync(
                                                "@type", token).ConfigureAwait(false))?.Value ?? string.Empty;
                                        objContact.Connection =
                                            (await xmlContactToImport.SelectSingleNodeAndCacheExpressionAsync(
                                                "@connection", token).ConfigureAwait(false))?.ValueAsInt ?? 1;
                                        objContact.Loyalty
                                            = (await xmlContactToImport.SelectSingleNodeAndCacheExpressionAsync(
                                                "@loyalty", token).ConfigureAwait(false))?.ValueAsInt ?? 1;
                                    }

                                    string strDescription =
                                        (blnSync
                                            ? xmlContactToImport.SelectSingleNodeAndCacheExpression(
                                                "description", token)
                                            : await xmlContactToImport
                                                    .SelectSingleNodeAndCacheExpressionAsync("description", token)
                                                    .ConfigureAwait(false))?.Value;
                                    using (new FetchSafelyFromPool<StringBuilder>(
                                               Utils.StringBuilderPool, out StringBuilder sbdNotes))
                                    {
                                        foreach (string strLine in strDescription.SplitNoAlloc('\n',
                                                     StringSplitOptions.RemoveEmptyEntries))
                                        {
                                            string[] astrLineColonSplit =
                                                strLine.Split(':', StringSplitOptions.RemoveEmptyEntries);
                                            switch (astrLineColonSplit[0])
                                            {
                                                case "Metatype":
                                                    objContact.Metatype = astrLineColonSplit[1].Trim();
                                                    break;

                                                case "Gender":
                                                    objContact.Gender = astrLineColonSplit[1].Trim();
                                                    break;

                                                case "Age":
                                                    objContact.Age = astrLineColonSplit[1].Trim();
                                                    break;

                                                case "Preferred Payment Method":
                                                    objContact.PreferredPayment = astrLineColonSplit[1].Trim();
                                                    break;

                                                case "Hobbies/Vice":
                                                    objContact.HobbiesVice = astrLineColonSplit[1].Trim();
                                                    break;

                                                case "Personal Life":
                                                    objContact.PersonalLife = astrLineColonSplit[1].Trim();
                                                    break;

                                                case "Type":
                                                    objContact.Type = astrLineColonSplit[1].Trim();
                                                    break;

                                                default:
                                                    sbdNotes.AppendLine(strLine);
                                                    break;
                                            }
                                        }

                                        if (sbdNotes.Length > 0)
                                            sbdNotes.Length -= Environment.NewLine.Length;
                                        objContact.Notes = sbdNotes.ToString();
                                    }

                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstContacts.Add(objContact);
                                    else
                                        await _lstContacts.AddAsync(objContact, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_contacts");
                            }

                            XmlDocument xmlGearDocument;
                            using (Timekeeper.StartSyncron("load_char_armor", op_load))
                            {
                                // Armor.
                                xmlGearDocument = blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? LoadData("gear.xml", token: token)
                                    : await LoadDataAsync("gear.xml", token: token).ConfigureAwait(false);
                                XmlDocument xmlArmorDocument = blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? LoadData("armor.xml", token: token)
                                    : await LoadDataAsync("armor.xml", token: token).ConfigureAwait(false);
                                foreach (XPathNavigator xmlArmorToImport in (blnSync
                                             ? xmlStatBlockBaseNode
                                                 .SelectAndCacheExpression(
                                                     "gear/armor/item[@useradded != \"no\"]", token)
                                             : await xmlStatBlockBaseNode.SelectAndCacheExpressionAsync(
                                                 "gear/armor/item[@useradded != \"no\"]", token).ConfigureAwait(false)))
                                {
                                    string strArmorName = (blnSync
                                        ? xmlArmorToImport.SelectSingleNodeAndCacheExpression(
                                            "@name", token)
                                        : await xmlArmorToImport
                                                .SelectSingleNodeAndCacheExpressionAsync(
                                                    "@name", token).ConfigureAwait(false))?.Value;
                                    if (!string.IsNullOrEmpty(strArmorName))
                                    {
                                        XmlNode xmlArmorData =
                                            xmlArmorDocument.TryGetNodeByNameOrId(
                                                "/chummer/armors/armor", strArmorName);
                                        if (xmlArmorData == null)
                                        {
                                            string[] astrOriginalNameSplit =
                                                strArmorName.Split(':', StringSplitOptions.RemoveEmptyEntries);
                                            if (astrOriginalNameSplit.Length > 1)
                                            {
                                                string strName = astrOriginalNameSplit[0].Trim();
                                                xmlArmorData =
                                                    xmlArmorDocument.TryGetNodeByNameOrId(
                                                        "/chummer/armors/armor", strName);
                                            }

                                            if (xmlArmorData == null)
                                            {
                                                astrOriginalNameSplit = strArmorName.Split(',',
                                                    StringSplitOptions.RemoveEmptyEntries);
                                                if (astrOriginalNameSplit.Length > 1)
                                                {
                                                    string strName = astrOriginalNameSplit[0].Trim();
                                                    xmlArmorData =
                                                        xmlArmorDocument.TryGetNodeByNameOrId(
                                                            "/chummer/armors/armor", strName);
                                                }
                                            }
                                        }

                                        if (xmlArmorData != null)
                                        {
                                            Armor objArmor = new Armor(this);
                                            objArmor.Create(xmlArmorData,
                                                            (blnSync
                                                                ? xmlArmorToImport.SelectSingleNodeAndCacheExpression(
                                                                    "@rating", token)
                                                                : await xmlArmorToImport
                                                                        .SelectSingleNodeAndCacheExpressionAsync(
                                                                            "@rating", token).ConfigureAwait(false))
                                                            ?.ValueAsInt
                                                            ?? 0,
                                                            lstWeapons);
                                            objArmor.Notes = (blnSync
                                                    ? xmlArmorToImport.SelectSingleNodeAndCacheExpression(
                                                        "description", token)
                                                    : await xmlArmorToImport
                                                            .SelectSingleNodeAndCacheExpressionAsync(
                                                                "description", token).ConfigureAwait(false))
                                                ?.Value;
                                            if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                _lstArmor.Add(objArmor);
                                            else
                                                await _lstArmor.AddAsync(objArmor, token).ConfigureAwait(false);

                                            foreach (string strName in HeroLabPluginNodeNames)
                                            {
                                                foreach (XPathNavigator xmlArmorModToImport in xmlArmorToImport
                                                             .Select(
                                                                 strName + "/item[@useradded != \"no\"]"))
                                                {
                                                    string strArmorModName =
                                                        (blnSync
                                                            ? xmlArmorModToImport.SelectSingleNodeAndCacheExpression(
                                                                "@name", token)
                                                            : await xmlArmorModToImport
                                                                    .SelectSingleNodeAndCacheExpressionAsync(
                                                                        "@name", token).ConfigureAwait(false))?.Value;
                                                    if (!string.IsNullOrEmpty(strArmorModName))
                                                    {
                                                        XmlNode xmlArmorModData =
                                                            xmlArmorDocument.TryGetNodeByNameOrId(
                                                                "chummer/mods/mod", strArmorModName);
                                                        if (xmlArmorModData != null)
                                                        {
                                                            ArmorMod objArmorMod = new ArmorMod(this);
                                                            objArmorMod.Create(xmlArmorModData,
                                                                               (blnSync
                                                                                   ? xmlArmorModToImport
                                                                                       // ReSharper disable once MethodHasAsyncOverload
                                                                                       .SelectSingleNodeAndCacheExpression(
                                                                                           "@rating", token)
                                                                                   : await xmlArmorModToImport
                                                                                       .SelectSingleNodeAndCacheExpressionAsync(
                                                                                           "@rating", token)
                                                                                       .ConfigureAwait(false))
                                                                               ?.ValueAsInt ?? 0, lstWeapons);
                                                            objArmorMod.Notes = (blnSync
                                                                    ? xmlArmorModToImport
                                                                        // ReSharper disable once MethodHasAsyncOverload
                                                                        .SelectSingleNodeAndCacheExpression(
                                                                            "description", token)
                                                                    : await xmlArmorModToImport
                                                                            .SelectSingleNodeAndCacheExpressionAsync(
                                                                                "description", token)
                                                                            .ConfigureAwait(false))
                                                                ?.Value;
                                                            objArmorMod.Parent = objArmor;
                                                            if (blnSync)
                                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                                objArmor.ArmorMods.Add(objArmorMod);
                                                            else
                                                                await objArmor.ArmorMods.AddAsync(objArmorMod, token)
                                                                              .ConfigureAwait(false);

                                                            foreach (string strPluginNodeName in
                                                                     HeroLabPluginNodeNames)
                                                            {
                                                                foreach (XPathNavigator xmlPluginToAdd in
                                                                         xmlArmorModToImport
                                                                             .Select(strPluginNodeName +
                                                                                 "/item[@useradded != \"no\"]"))
                                                                {
                                                                    Gear objPlugin = new Gear(this);
                                                                    if (blnSync)
                                                                    {
                                                                        // ReSharper disable once MethodHasAsyncOverload
                                                                        if (objPlugin.ImportHeroLabGear(xmlPluginToAdd,
                                                                                xmlArmorModData,
                                                                                lstWeapons, token))
                                                                        {
                                                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                                            objArmorMod.GearChildren.Add(objPlugin);
                                                                        }
                                                                        else
                                                                            // ReSharper disable once MethodHasAsyncOverload
                                                                            objPlugin.Dispose();
                                                                    }
                                                                    else
                                                                    {
                                                                        if (await objPlugin.ImportHeroLabGearAsync(
                                                                                    xmlPluginToAdd,
                                                                                    xmlArmorModData,
                                                                                    lstWeapons, token)
                                                                                .ConfigureAwait(false))
                                                                            await objArmorMod.GearChildren
                                                                                .AddAsync(objPlugin, token)
                                                                                .ConfigureAwait(false);
                                                                        else
                                                                            await objPlugin.DisposeAsync()
                                                                                .ConfigureAwait(false);
                                                                    }
                                                                }

                                                                foreach (XPathNavigator xmlPluginToAdd in
                                                                         xmlArmorModToImport
                                                                             .Select(strPluginNodeName +
                                                                                 "/item[@useradded = \"no\"]"))
                                                                {
                                                                    string strGearName = xmlPluginToAdd
                                                                        .SelectSingleNodeAndCacheExpression(
                                                                            "@name", token)?.Value;
                                                                    if (!string.IsNullOrEmpty(strGearName))
                                                                    {
                                                                        if (blnSync)
                                                                        {
                                                                            // ReSharper disable MethodHasAsyncOverload
                                                                            Gear objPlugin
                                                                                = objArmorMod.GearChildren
                                                                                    .FirstOrDefault(
                                                                                        x =>
                                                                                            x.IncludedInParent &&
                                                                                            (x.Name.Contains(
                                                                                                    strGearName) ||
                                                                                                strGearName.Contains(
                                                                                                    x.Name)));
                                                                            if (objPlugin != null)
                                                                            {
                                                                                objPlugin.Quantity = xmlPluginToAdd
                                                                                        .SelectSingleNodeAndCacheExpression(
                                                                                            "@quantity", token)
                                                                                        ?.ValueAsInt
                                                                                    ?? 1;
                                                                                objPlugin.Notes = xmlPluginToAdd
                                                                                    .SelectSingleNodeAndCacheExpression(
                                                                                        "description", token)?.Value;
                                                                                objPlugin.ProcessHeroLabGearPlugins(
                                                                                    xmlPluginToAdd,
                                                                                    lstWeapons, token);
                                                                            }
                                                                            // ReSharper restore MethodHasAsyncOverload
                                                                        }
                                                                        else
                                                                        {
                                                                            Gear objPlugin = await objArmorMod
                                                                                .GearChildren
                                                                                .FirstOrDefaultAsync(
                                                                                    x =>
                                                                                        x.IncludedInParent &&
                                                                                        (x.Name.Contains(strGearName) ||
                                                                                            strGearName.Contains(
                                                                                                x.Name)), token)
                                                                                .ConfigureAwait(false);
                                                                            if (objPlugin != null)
                                                                            {
                                                                                objPlugin.Quantity
                                                                                    = (await xmlPluginToAdd
                                                                                        .SelectSingleNodeAndCacheExpressionAsync(
                                                                                            "@quantity", token).ConfigureAwait(false))
                                                                                    ?.ValueAsInt ?? 1;
                                                                                objPlugin.Notes
                                                                                    = (await xmlPluginToAdd
                                                                                        .SelectSingleNodeAndCacheExpressionAsync(
                                                                                            "description", token).ConfigureAwait(false))
                                                                                    ?.Value;
                                                                                await objPlugin
                                                                                    .ProcessHeroLabGearPluginsAsync(
                                                                                        xmlPluginToAdd,
                                                                                        lstWeapons, token).ConfigureAwait(false);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        else
                                                        {
                                                            Gear objPlugin = new Gear(this);
                                                            if (objPlugin.ImportHeroLabGear(xmlArmorModToImport,
                                                                    xmlArmorData,
                                                                    lstWeapons, token))
                                                            {
                                                                if (blnSync)
                                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                                    objArmor.GearChildren.Add(objPlugin);
                                                                else
                                                                    await objArmor.GearChildren
                                                                        .AddAsync(objPlugin, token)
                                                                        .ConfigureAwait(false);
                                                            }
                                                            else if (blnSync)
                                                                // ReSharper disable once MethodHasAsyncOverload
                                                                objPlugin.Dispose();
                                                            else
                                                                await objPlugin.DisposeAsync().ConfigureAwait(false);
                                                        }
                                                    }
                                                }

                                                foreach (XPathNavigator xmlArmorModToImport in xmlArmorToImport
                                                             .Select(
                                                                 strName + "/item[@useradded = \"no\"]"))
                                                {
                                                    string strArmorModName =
                                                        (blnSync
                                                            ? xmlArmorModToImport.SelectSingleNodeAndCacheExpression(
                                                                "@name", token)
                                                            : await xmlArmorModToImport
                                                                    .SelectSingleNodeAndCacheExpressionAsync(
                                                                        "@name", token).ConfigureAwait(false))?.Value;
                                                    if (!string.IsNullOrEmpty(strArmorModName))
                                                    {
                                                        ArmorMod objArmorMod = blnSync
                                                            ? objArmor.ArmorMods.FirstOrDefault(
                                                                x =>
                                                                    x.IncludedInArmor &&
                                                                    (x.Name.Contains(strArmorModName) ||
                                                                     strArmorModName.Contains(x.Name)))
                                                            : await objArmor.ArmorMods.FirstOrDefaultAsync(
                                                                                x =>
                                                                                    x.IncludedInArmor &&
                                                                                    (x.Name.Contains(strArmorModName) ||
                                                                                        strArmorModName
                                                                                            .Contains(x.Name)), token)
                                                                            .ConfigureAwait(false);
                                                        if (objArmorMod != null)
                                                        {
                                                            objArmorMod.Notes = (blnSync
                                                                    ? xmlArmorModToImport
                                                                        .SelectSingleNodeAndCacheExpression(
                                                                            "description", token)
                                                                    : await xmlArmorModToImport
                                                                            .SelectSingleNodeAndCacheExpressionAsync(
                                                                                "description", token)
                                                                            .ConfigureAwait(false))
                                                                ?.Value;
                                                            foreach (string strPluginNodeName in
                                                                     HeroLabPluginNodeNames)
                                                            {
                                                                foreach (XPathNavigator xmlPluginToAdd in
                                                                         xmlArmorModToImport
                                                                             .Select(strPluginNodeName +
                                                                                 "/item[@useradded != \"no\"]"))
                                                                {
                                                                    Gear objPlugin = new Gear(this);
                                                                    if (objPlugin.ImportHeroLabGear(xmlPluginToAdd,
                                                                            blnSync
                                                                                // ReSharper disable once MethodHasAsyncOverload
                                                                                ? objArmorMod.GetNode(token)
                                                                                : await objArmorMod.GetNodeAsync(token)
                                                                                    .ConfigureAwait(false),
                                                                            lstWeapons, token))
                                                                    {
                                                                        if (blnSync)
                                                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                                            objArmorMod.GearChildren.Add(objPlugin);
                                                                        else
                                                                            await objArmorMod.GearChildren
                                                                                .AddAsync(objPlugin, token)
                                                                                .ConfigureAwait(false);
                                                                    }
                                                                    else if (blnSync)
                                                                        // ReSharper disable once MethodHasAsyncOverload
                                                                        objPlugin.Dispose();
                                                                    else
                                                                        await objPlugin.DisposeAsync()
                                                                            .ConfigureAwait(false);
                                                                }

                                                                foreach (XPathNavigator xmlPluginToAdd in
                                                                         xmlArmorModToImport
                                                                             .Select(strPluginNodeName +
                                                                                 "/item[@useradded = \"no\"]"))
                                                                {
                                                                    string strGearName = xmlPluginToAdd
                                                                        .SelectSingleNodeAndCacheExpression(
                                                                            "@name", token)?.Value;
                                                                    if (!string.IsNullOrEmpty(strGearName))
                                                                    {
                                                                        if (blnSync)
                                                                        {
                                                                            // ReSharper disable MethodHasAsyncOverload
                                                                            Gear objPlugin
                                                                                = objArmor.GearChildren.FirstOrDefault(
                                                                                    x =>
                                                                                        x.IncludedInParent &&
                                                                                        (x.Name.Contains(strGearName) ||
                                                                                            strGearName.Contains(
                                                                                                x.Name)));
                                                                            if (objPlugin != null)
                                                                            {
                                                                                objPlugin.Quantity = xmlPluginToAdd
                                                                                        .SelectSingleNodeAndCacheExpression(
                                                                                            "@quantity", token)
                                                                                        ?.ValueAsInt
                                                                                    ?? 1;
                                                                                objPlugin.Notes = xmlPluginToAdd
                                                                                    .SelectSingleNodeAndCacheExpression(
                                                                                        "description", token)?.Value;
                                                                                objPlugin.ProcessHeroLabGearPlugins(
                                                                                    xmlPluginToAdd,
                                                                                    lstWeapons, token);
                                                                            }
                                                                            // ReSharper restore MethodHasAsyncOverload
                                                                        }
                                                                        else
                                                                        {
                                                                            Gear objPlugin = await objArmor.GearChildren
                                                                                .FirstOrDefaultAsync(
                                                                                    x =>
                                                                                        x.IncludedInParent &&
                                                                                        (x.Name.Contains(strGearName) ||
                                                                                            strGearName.Contains(
                                                                                                x.Name)), token)
                                                                                .ConfigureAwait(false);
                                                                            if (objPlugin != null)
                                                                            {
                                                                                objPlugin.Quantity
                                                                                    = (await xmlPluginToAdd
                                                                                        .SelectSingleNodeAndCacheExpressionAsync(
                                                                                            "@quantity", token).ConfigureAwait(false))
                                                                                    ?.ValueAsInt ?? 1;
                                                                                objPlugin.Notes
                                                                                    = (await xmlPluginToAdd
                                                                                        .SelectSingleNodeAndCacheExpressionAsync(
                                                                                            "description", token).ConfigureAwait(false))
                                                                                    ?.Value;
                                                                                await objPlugin
                                                                                    .ProcessHeroLabGearPluginsAsync(
                                                                                        xmlPluginToAdd,
                                                                                        lstWeapons, token).ConfigureAwait(false);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        else if (blnSync)
                                                        {
                                                            // ReSharper disable MethodHasAsyncOverload
                                                            Gear objPlugin = objArmor.GearChildren.FirstOrDefault(
                                                                x =>
                                                                    x.IncludedInParent &&
                                                                    (x.Name.Contains(strArmorModName) ||
                                                                     strArmorModName.Contains(x.Name)));
                                                            if (objPlugin != null)
                                                            {
                                                                objPlugin.Quantity = xmlArmorModToImport
                                                                    .SelectSingleNodeAndCacheExpression(
                                                                        "@quantity", token)?.ValueAsInt ?? 1;
                                                                objPlugin.Notes = xmlArmorModToImport
                                                                    .SelectSingleNodeAndCacheExpression(
                                                                        "description", token)?.Value;
                                                                objPlugin.ProcessHeroLabGearPlugins(
                                                                    xmlArmorModToImport,
                                                                    lstWeapons, token);
                                                            }
                                                            // ReSharper restore MethodHasAsyncOverload
                                                        }
                                                        else
                                                        {
                                                            Gear objPlugin = await objArmor.GearChildren
                                                                .FirstOrDefaultAsync(
                                                                    x =>
                                                                        x.IncludedInParent &&
                                                                        (x.Name.Contains(strArmorModName) ||
                                                                         strArmorModName.Contains(x.Name)), token)
                                                                .ConfigureAwait(false);
                                                            if (objPlugin != null)
                                                            {
                                                                objPlugin.Quantity = (await xmlArmorModToImport
                                                                    .SelectSingleNodeAndCacheExpressionAsync(
                                                                        "@quantity", token).ConfigureAwait(false))?.ValueAsInt ?? 1;
                                                                objPlugin.Notes = (await xmlArmorModToImport
                                                                    .SelectSingleNodeAndCacheExpressionAsync(
                                                                        "description", token).ConfigureAwait(false))?.Value;
                                                                await objPlugin.ProcessHeroLabGearPluginsAsync(
                                                                    xmlArmorModToImport,
                                                                    lstWeapons, token).ConfigureAwait(false);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_armor");
                            }

                            using (Timekeeper.StartSyncron("load_char_weapons", op_load))
                            {
                                // Weapons.
                                foreach (XPathNavigator xmlWeaponToImport in xmlStatBlockBaseNode.Select(
                                             "gear/weapons/item[@useradded != \"no\"]"))
                                {
                                    Weapon objWeapon = new Weapon(this);
                                    if (objWeapon.ImportHeroLabWeapon(xmlWeaponToImport, lstWeapons))
                                    {
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstWeapons.Add(objWeapon);
                                        else
                                            await _lstWeapons.AddAsync(objWeapon, token).ConfigureAwait(false);
                                    }
                                    else if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverload
                                        objWeapon.Dispose();
                                    else
                                        await objWeapon.DisposeAsync().ConfigureAwait(false);
                                }

                                foreach (XPathNavigator xmlPluginToAdd in xmlStatBlockBaseNode.Select(
                                             "gear/weapons/item[@useradded = \"no\"]"))
                                {
                                    string strName
                                        = (blnSync
                                            // ReSharper disable once MethodHasAsyncOverload
                                            ? xmlPluginToAdd.SelectSingleNodeAndCacheExpression("@name", token)
                                            : await xmlPluginToAdd
                                                    .SelectSingleNodeAndCacheExpressionAsync("@name", token)
                                                    .ConfigureAwait(false))?.Value;
                                    if (!string.IsNullOrEmpty(strName))
                                    {
                                        Weapon objWeapon = _lstWeapons.FirstOrDefault(x =>
                                            !string.IsNullOrEmpty(x.ParentID) &&
                                            (x.Name.Contains(strName) || strName.Contains(x.Name)));
                                        if (objWeapon != null)
                                        {
                                            objWeapon.Notes = (blnSync
                                                // ReSharper disable once MethodHasAsyncOverload
                                                ? xmlPluginToAdd.SelectSingleNodeAndCacheExpression(
                                                    "description", token)
                                                : await xmlPluginToAdd
                                                        .SelectSingleNodeAndCacheExpressionAsync("description", token)
                                                        .ConfigureAwait(false))?.Value;
                                            objWeapon.ProcessHeroLabWeaponPlugins(xmlPluginToAdd, lstWeapons);
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_weapons");
                            }

                            using (Timekeeper.StartSyncron("load_char_ware", op_load))
                            {
                                // Cyberware/Bioware.
                                foreach (XPathNavigator xmlCyberwareToImport in xmlStatBlockBaseNode.Select(
                                             "gear/augmentations/cyberware/item[@useradded != \"no\"]"))
                                {
                                    Cyberware objCyberware = new Cyberware(this);
                                    if (objCyberware.ImportHeroLabCyberware(xmlCyberwareToImport, null, lstWeapons,
                                                                            lstVehicles))
                                    {
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstCyberware.Add(objCyberware);
                                        else
                                            await _lstCyberware.AddAsync(objCyberware, token).ConfigureAwait(false);
                                    }
                                    else if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverload
                                        objCyberware.Dispose();
                                    else
                                        await objCyberware.DisposeAsync().ConfigureAwait(false);
                                }

                                foreach (XPathNavigator xmlPluginToAdd in xmlStatBlockBaseNode.Select(
                                             "gear/augmentations/cyberware/item[@useradded = \"no\"]"))
                                {
                                    string strName
                                        = (blnSync
                                            // ReSharper disable once MethodHasAsyncOverload
                                            ? xmlPluginToAdd.SelectSingleNodeAndCacheExpression("@name", token)
                                            : await xmlPluginToAdd
                                                    .SelectSingleNodeAndCacheExpressionAsync("@name", token)
                                                    .ConfigureAwait(false))?.Value;
                                    if (!string.IsNullOrEmpty(strName))
                                    {
                                        Cyberware objPlugin = _lstCyberware.FirstOrDefault(x =>
                                            !string.IsNullOrEmpty(x.ParentID) &&
                                            (x.Name.Contains(strName) || strName.Contains(x.Name)));
                                        if (objPlugin != null)
                                        {
                                            objPlugin.Notes = (blnSync
                                                // ReSharper disable once MethodHasAsyncOverload
                                                ? xmlPluginToAdd.SelectSingleNodeAndCacheExpression(
                                                    "description", token)
                                                : await xmlPluginToAdd
                                                        .SelectSingleNodeAndCacheExpressionAsync("description", token)
                                                        .ConfigureAwait(false))?.Value;
                                            objPlugin.ProcessHeroLabCyberwarePlugins(xmlPluginToAdd,
                                                objPlugin.Grade,
                                                lstWeapons,
                                                lstVehicles);
                                        }
                                    }
                                }

                                foreach (XPathNavigator xmlCyberwareToImport in xmlStatBlockBaseNode.Select(
                                             "gear/augmentations/bioware/item[@useradded != \"no\"]"))
                                {
                                    Cyberware objCyberware = new Cyberware(this);
                                    if (objCyberware.ImportHeroLabCyberware(xmlCyberwareToImport, null, lstWeapons,
                                                                            lstVehicles))
                                    {
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstCyberware.Add(objCyberware);
                                        else
                                            await _lstCyberware.AddAsync(objCyberware, token).ConfigureAwait(false);
                                    }
                                    else if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverload
                                        objCyberware.Dispose();
                                    else
                                        await objCyberware.DisposeAsync().ConfigureAwait(false);
                                }

                                foreach (XPathNavigator xmlPluginToAdd in xmlStatBlockBaseNode.Select(
                                             "gear/augmentations/bioware/item[@useradded = \"no\"]"))
                                {
                                    string strName
                                        = (blnSync
                                            // ReSharper disable once MethodHasAsyncOverload
                                            ? xmlPluginToAdd.SelectSingleNodeAndCacheExpression("@name", token)
                                            : await xmlPluginToAdd
                                                    .SelectSingleNodeAndCacheExpressionAsync("@name", token)
                                                    .ConfigureAwait(false))?.Value;
                                    if (!string.IsNullOrEmpty(strName))
                                    {
                                        Cyberware objPlugin = _lstCyberware.FirstOrDefault(x =>
                                            !string.IsNullOrEmpty(x.ParentID) &&
                                            (x.Name.Contains(strName) || strName.Contains(x.Name)));
                                        if (objPlugin != null)
                                        {
                                            objPlugin.Notes = (blnSync
                                                // ReSharper disable once MethodHasAsyncOverload
                                                ? xmlPluginToAdd.SelectSingleNodeAndCacheExpression(
                                                    "description", token)
                                                : await xmlPluginToAdd
                                                        .SelectSingleNodeAndCacheExpressionAsync("description", token)
                                                        .ConfigureAwait(false))?.Value;
                                            objPlugin.ProcessHeroLabCyberwarePlugins(xmlPluginToAdd,
                                                objPlugin.Grade,
                                                lstWeapons,
                                                lstVehicles);
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_ware");
                            }

                            XPathNodeIterator xmlNodeList;
                            using (Timekeeper.StartSyncron("load_char_spells", op_load))
                            {
                                // Spells.
                                xmlNodeList = blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? xmlStatBlockBaseNode.SelectAndCacheExpression("magic/spells/spell", token)
                                    : await xmlStatBlockBaseNode.SelectAndCacheExpressionAsync("magic/spells/spell", token).ConfigureAwait(false);
                                XmlDocument xmlSpellDocument = blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? LoadData("spells.xml", token: token)
                                    : await LoadDataAsync("spells.xml", token: token).ConfigureAwait(false);
                                foreach (XPathNavigator xmlHeroLabSpell in xmlNodeList)
                                {
                                    string strSpellName
                                        = (blnSync
                                            // ReSharper disable once MethodHasAsyncOverload
                                            ? xmlHeroLabSpell.SelectSingleNodeAndCacheExpression("@name", token)
                                            : await xmlHeroLabSpell
                                                    .SelectSingleNodeAndCacheExpressionAsync("@name", token)
                                                    .ConfigureAwait(false))?.Value;
                                    if (!string.IsNullOrEmpty(strSpellName))
                                    {
                                        bool blnIsLimited =
                                            strSpellName.EndsWith(" (limited)", StringComparison.Ordinal);
                                        if (blnIsLimited)
                                            strSpellName = strSpellName.TrimEndOnce(" (limited)");
                                        string strForcedValue = string.Empty;
                                        switch (strSpellName)
                                        {
                                            case "Increase Body":
                                                strForcedValue = "BOD";
                                                strSpellName = "Increase [Attribute]";
                                                break;

                                            case "Increase Agility":
                                                strForcedValue = "AGI";
                                                strSpellName = "Increase [Attribute]";
                                                break;

                                            case "Increase Reaction":
                                                strForcedValue = "REA";
                                                strSpellName = "Increase [Attribute]";
                                                break;

                                            case "Increase Strength":
                                                strForcedValue = "STR";
                                                strSpellName = "Increase [Attribute]";
                                                break;

                                            case "Increase Charisma":
                                                strForcedValue = "CHA";
                                                strSpellName = "Increase [Attribute]";
                                                break;

                                            case "Increase Intuition":
                                                strForcedValue = "INT";
                                                strSpellName = "Increase [Attribute]";
                                                break;

                                            case "Increase Logic":
                                                strForcedValue = "LOG";
                                                strSpellName = "Increase [Attribute]";
                                                break;

                                            case "Increase Willpower":
                                                strForcedValue = "WIL";
                                                strSpellName = "Increase [Attribute]";
                                                break;

                                            case "Decrease Body":
                                                strForcedValue = "BOD";
                                                strSpellName = "Decrease [Attribute]";
                                                break;

                                            case "Decrease Agility":
                                                strForcedValue = "AGI";
                                                strSpellName = "Decrease [Attribute]";
                                                break;

                                            case "Decrease Reaction":
                                                strForcedValue = "REA";
                                                strSpellName = "Decrease [Attribute]";
                                                break;

                                            case "Decrease Strength":
                                                strForcedValue = "STR";
                                                strSpellName = "Decrease [Attribute]";
                                                break;

                                            case "Decrease Charisma":
                                                strForcedValue = "CHA";
                                                strSpellName = "Decrease [Attribute]";
                                                break;

                                            case "Decrease Intuition":
                                                strForcedValue = "INT";
                                                strSpellName = "Decrease [Attribute]";
                                                break;

                                            case "Decrease Logic":
                                                strForcedValue = "LOG";
                                                strSpellName = "Decrease [Attribute]";
                                                break;

                                            case "Decrease Willpower":
                                                strForcedValue = "WIL";
                                                strSpellName = "Decrease [Attribute]";
                                                break;
                                        }

                                        if (strSpellName.StartsWith("Detect ", StringComparison.Ordinal) &&
                                            strSpellName != "Detect Life" &&
                                            strSpellName != "Detect Life, Extended" &&
                                            strSpellName != "Detect Magic" &&
                                            strSpellName != "Detect Magic, Extended" &&
                                            strSpellName != "Detect Enemies" &&
                                            strSpellName != "Detect Enemies, Extended" &&
                                            strSpellName != "Detect Individual" &&
                                            strSpellName != "Detect Life, Extended")
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Clean ")
                                                                         .TrimEndOnce(", Extended");
                                            if ((blnSync
                                                    // ReSharper disable once MethodHasAsyncOverload
                                                    ? xmlHeroLabSpell.SelectSingleNodeAndCacheExpression("@type", token)
                                                    : await xmlHeroLabSpell
                                                            .SelectSingleNodeAndCacheExpressionAsync("@type", token)
                                                            .ConfigureAwait(false))?.Value == "Physical")
                                                strSpellName = "Detect [Object]";
                                            else if (strSpellName.EndsWith(", Extended", StringComparison.Ordinal))
                                                strSpellName = "Detect [Life Form], Extended";
                                            else
                                                strSpellName = "Detect [Life Form]";
                                        }
                                        else if (strSpellName.StartsWith("Corrode ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Corrode ");
                                            strSpellName = "Corrode [Object]";
                                        }
                                        else if (strSpellName.StartsWith("Melt ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Melt ");
                                            strSpellName = "Melt [Object]";
                                        }
                                        else if (strSpellName.StartsWith("Sludge ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Sludge ");
                                            strSpellName = "Sludge [Object]";
                                        }
                                        else if (strSpellName.StartsWith("Disrupt ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Disrupt ");
                                            strSpellName = "Disrupt [Object]";
                                        }
                                        else if (strSpellName.StartsWith("Destroy ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Destroy ");
                                            strSpellName
                                                = (blnSync
                                                      // ReSharper disable once MethodHasAsyncOverload
                                                      ? xmlHeroLabSpell.SelectSingleNodeAndCacheExpression(
                                                          "@type", token)
                                                      : await xmlHeroLabSpell
                                                              .SelectSingleNodeAndCacheExpressionAsync("@type", token)
                                                              .ConfigureAwait(false))?.Value ==
                                                  "Physical"
                                                    ? "Destroy [Vehicle]"
                                                    : "Destroy [Free Spirit]";
                                        }
                                        else if (strSpellName.StartsWith("Insecticide ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Insecticide ");
                                            strSpellName = "Insecticide [Insect Spirit]";
                                        }
                                        else if (strSpellName.StartsWith("One Less ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("One Less ");
                                            strSpellName = "One Less [Metatype/Species]";
                                        }
                                        else if (strSpellName.StartsWith("Slay ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Slay ");
                                            strSpellName = "Slay [Metatype/Species]";
                                        }
                                        else if (strSpellName.StartsWith("Slaughter ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Slaughter ");
                                            strSpellName = "Slaughter [Metatype/Species]";
                                        }
                                        else if (strSpellName.StartsWith("Ram ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Ram ");
                                            strSpellName = "Ram [Object]";
                                        }
                                        else if (strSpellName.StartsWith("Wreck ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Wreck ");
                                            strSpellName = "Wreck [Object]";
                                        }
                                        else if (strSpellName.StartsWith("Demolish ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Demolish ");
                                            strSpellName = "Demolish [Object]";
                                        }
                                        else if (strSpellName.EndsWith(" Cryptesthesia", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimEndOnce(" Cryptesthesia");
                                            strSpellName = "[Sense] Cryptesthesia";
                                        }
                                        else if (strSpellName.EndsWith(" Removal", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Mass ")
                                                                         .TrimEndOnce(" Removal");
                                            strSpellName =
                                                strSpellName.StartsWith("Mass ", StringComparison.Ordinal)
                                                    ? "Mass [Sense] Removal"
                                                    : "[Sense] Removal";
                                        }
                                        else if (strSpellName.StartsWith("Alleviate ", StringComparison.Ordinal) &&
                                                 strSpellName != "Alleviate Addiction")
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Alleviate ");
                                            strSpellName = "Alleviate [Allergy]";
                                        }
                                        else if (strSpellName.StartsWith("Clean ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Clean ");
                                            strSpellName = "Clean [Element]";
                                        }
                                        else if (strSpellName.EndsWith(" Grenade", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimEndOnce(" Grenade");
                                            strSpellName = "[Element] Grenade";
                                        }
                                        else if (strSpellName.EndsWith(" Aura", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimEndOnce(" Aura");
                                            strSpellName = "[Element] Aura";
                                        }
                                        else if (strSpellName != "Napalm Wall" &&
                                                 strSpellName.EndsWith(" Wall", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimEndOnce(" Wall");
                                            strSpellName = "[Element] Wall";
                                        }
                                        else if (strSpellName.StartsWith("Shape ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Shape ");
                                            strSpellName = "Shape [Material]";
                                        }
                                        else if (strSpellName.EndsWith(" Form", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimEndOnce(" Form");
                                            strSpellName = "[Critter] Form";
                                        }
                                        else if (strSpellName.StartsWith("Calling ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Calling ");
                                            strSpellName = "Calling [Spirit Type]";
                                        }
                                        else if (strSpellName != "Symbolic Link" &&
                                                 strSpellName.EndsWith(" Link", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimEndOnce(" Link");
                                            strSpellName = "[Sense] Link";
                                        }

                                        string strSpellCategory =
                                            (blnSync
                                                // ReSharper disable once MethodHasAsyncOverload
                                                ? xmlHeroLabSpell.SelectSingleNodeAndCacheExpression("@category", token)
                                                : await xmlHeroLabSpell
                                                        .SelectSingleNodeAndCacheExpressionAsync("@category", token)
                                                        .ConfigureAwait(false))?.Value;
                                        XmlNode xmlSpellData = xmlSpellDocument.TryGetNodeByNameOrId(
                                            "chummer/spells/spell", strSpellName,
                                            "category = " + strSpellCategory.CleanXPath());
                                        if (xmlSpellData == null)
                                        {
                                            string[] astrOriginalNameSplit =
                                                strSpellName.Split(':', StringSplitOptions.RemoveEmptyEntries);
                                            if (astrOriginalNameSplit.Length > 1)
                                            {
                                                string strName = astrOriginalNameSplit[0].Trim();
                                                xmlSpellData = xmlSpellDocument.TryGetNodeByNameOrId(
                                                    "chummer/spells/spell", strName,
                                                    "category = " + strSpellCategory.CleanXPath());
                                            }

                                            if (xmlSpellData == null)
                                            {
                                                astrOriginalNameSplit = strSpellName.Split(',',
                                                    StringSplitOptions.RemoveEmptyEntries);
                                                if (astrOriginalNameSplit.Length > 1)
                                                {
                                                    string strName = astrOriginalNameSplit[0].Trim();
                                                    xmlSpellData = xmlSpellDocument.TryGetNodeByNameOrId(
                                                        "chummer/spells/spell", strName,
                                                        "category = " + strSpellCategory.CleanXPath());
                                                }
                                            }
                                        }

                                        if (xmlSpellData != null)
                                        {
                                            Spell objSpell = new Spell(this);
                                            objSpell.Create(xmlSpellData, strForcedValue, blnIsLimited);
                                            objSpell.Notes = (blnSync
                                                // ReSharper disable once MethodHasAsyncOverload
                                                ? xmlHeroLabSpell.SelectSingleNodeAndCacheExpression(
                                                    "description", token)
                                                : await xmlHeroLabSpell
                                                        .SelectSingleNodeAndCacheExpressionAsync("description", token)
                                                        .ConfigureAwait(false))?.Value;
                                            if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                _lstSpells.Add(objSpell);
                                            else
                                                await _lstSpells.AddAsync(objSpell, token).ConfigureAwait(false);
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_spells");
                            }

                            using (Timekeeper.StartSyncron("load_char_powers", op_load))
                            {
                                // Powers.
                                xmlNodeList = blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? xmlStatBlockBaseNode.SelectAndCacheExpression("magic/adeptpowers/adeptpower", token)
                                    : await xmlStatBlockBaseNode.SelectAndCacheExpressionAsync("magic/adeptpowers/adeptpower", token).ConfigureAwait(false);
                                XmlDocument xmlPowersDocument = blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? LoadData("powers.xml", token: token)
                                    : await LoadDataAsync("powers.xml", token: token).ConfigureAwait(false);
                                foreach (XPathNavigator xmlHeroLabPower in xmlNodeList)
                                {
                                    string strPowerName = (blnSync
                                        // ReSharper disable once MethodHasAsyncOverload
                                        ? xmlHeroLabPower.SelectSingleNodeAndCacheExpression(
                                            "@name", token)
                                        : await xmlHeroLabPower.SelectSingleNodeAndCacheExpressionAsync("@name", token)
                                                               .ConfigureAwait(false))?.Value;
                                    if (!string.IsNullOrEmpty(strPowerName))
                                    {
                                        int intRating = 1;
                                        string strForcedValue = string.Empty;
                                        XmlNode xmlPowerData =
                                            xmlPowersDocument.SelectSingleNode(
                                                "chummer/powers/power[contains(name, " + strPowerName.CleanXPath() +
                                                ")]");
                                        if (xmlPowerData == null)
                                        {
                                            string[] astrOriginalNameSplit =
                                                strPowerName.Split(':', StringSplitOptions.RemoveEmptyEntries);
                                            if (astrOriginalNameSplit.Length > 1)
                                            {
                                                string strName = astrOriginalNameSplit[0].Trim();
                                                xmlPowerData =
                                                    xmlPowersDocument.SelectSingleNode(
                                                        "/chummer/powers/power[contains(name, " +
                                                        strName.CleanXPath() +
                                                        ")]");

                                                strForcedValue = astrOriginalNameSplit[1].Trim();
                                                int intForcedValueParenthesesStart = strForcedValue.IndexOf('(');
                                                if (intForcedValueParenthesesStart != -1)
                                                    strForcedValue =
                                                        strForcedValue.Substring(0, intForcedValueParenthesesStart);
                                            }

                                            if (xmlPowerData == null)
                                            {
                                                astrOriginalNameSplit = strPowerName.Split('(',
                                                    StringSplitOptions.RemoveEmptyEntries);
                                                if (astrOriginalNameSplit.Length > 1)
                                                {
                                                    string strName = astrOriginalNameSplit[0].Trim();
                                                    xmlPowerData =
                                                        xmlPowersDocument.SelectSingleNode(
                                                            "/chummer/powers/power[contains(name, " +
                                                            strName.CleanXPath() +
                                                            ")]");

                                                    string strSecondPart = astrOriginalNameSplit[1].Trim();
                                                    int intSecondPartParenthesesEnd = strSecondPart.IndexOf(')');
                                                    if (intSecondPartParenthesesEnd != -1
                                                        && !int.TryParse(
                                                            strSecondPart.Substring(0, intSecondPartParenthesesEnd),
                                                            out intRating))
                                                        intRating = 1;

                                                    astrOriginalNameSplit = strSecondPart.Split(':',
                                                        StringSplitOptions.RemoveEmptyEntries);
                                                    if (astrOriginalNameSplit.Length >= 2)
                                                    {
                                                        strForcedValue = astrOriginalNameSplit[1].Trim();
                                                        int intForcedValueParenthesesStart =
                                                            strForcedValue.IndexOf('(');
                                                        if (intForcedValueParenthesesStart != -1)
                                                            strForcedValue =
                                                                strForcedValue.Substring(0,
                                                                    intForcedValueParenthesesStart);
                                                    }
                                                }
                                            }
                                        }

                                        if (xmlPowerData != null)
                                        {
                                            Power objPower = new Power(this) { Extra = strForcedValue };
                                            objPower.Create(xmlPowerData, intRating);
                                            objPower.Notes = (blnSync
                                                // ReSharper disable once MethodHasAsyncOverload
                                                ? xmlHeroLabPower.SelectSingleNodeAndCacheExpression(
                                                    "description", token)
                                                : await xmlHeroLabPower
                                                        .SelectSingleNodeAndCacheExpressionAsync("description", token)
                                                        .ConfigureAwait(false))?.Value;
                                            if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                _lstPowers.Add(objPower);
                                            else
                                                await _lstPowers.AddAsync(objPower, token).ConfigureAwait(false);
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_powers");
                            }

                            /* TODO: Spirit/Sprite Importing
                            Timekeeper.Start("load_char_spirits");

                            // Spirits/Sprites.
                            foreach (XPathNavigator xmlSpirit in xmlCharacterNavigator.SelectAndCacheExpression("spirits/spirit"))
                            {
                                Spirit objSpirit = new Spirit(this);
                                objSpirit.Load(xmlSpirit);
                                _lstSpirits.Add(objSpirit);
                            }

                            Timekeeper.Finish("load_char_spirits");
                            */
                            using (Timekeeper.StartSyncron("load_char_complex", op_load))
                            {
                                // Complex Forms/Technomancer Programs.
                                string strComplexFormsLine =
                                    lstTextStatBlockLines?.FirstOrDefault(x =>
                                                                              x.StartsWith(
                                                                                  "Complex Forms:",
                                                                                  StringComparison.Ordinal));
                                if (!string.IsNullOrEmpty(strComplexFormsLine))
                                {
                                    XmlDocument xmlComplexFormsDocument = blnSync
                                        // ReSharper disable once MethodHasAsyncOverload
                                        ? LoadData("complexforms.xml", token: token)
                                        : await LoadDataAsync("complexforms.xml", token: token).ConfigureAwait(false);

                                    string[] astrComplexForms =
                                        strComplexFormsLine.TrimStartOnce("Complex Forms:").Trim()
                                                           .Split(',', StringSplitOptions.RemoveEmptyEntries);
                                    foreach (string strComplexFormEntry in astrComplexForms)
                                    {
                                        string strComplexFormName = strComplexFormEntry.Trim();
                                        string strForcedValue = string.Empty;
                                        switch (strComplexFormName)
                                        {
                                            case "Diffusion of Attack":
                                                strComplexFormName = "Diffusion of [Matrix Attribute]";
                                                strForcedValue = "Attack";
                                                break;

                                            case "Diffusion of Sleaze":
                                                strComplexFormName = "Diffusion of [Matrix Attribute]";
                                                strForcedValue = "Sleaze";
                                                break;

                                            case "Diffusion of Data Processing":
                                                strComplexFormName = "Diffusion of [Matrix Attribute]";
                                                strForcedValue = "Data Processing";
                                                break;

                                            case "Diffusion of Firewall":
                                                strComplexFormName = "Diffusion of [Matrix Attribute]";
                                                strForcedValue = "Firewall";
                                                break;

                                            case "Infusion of Attack":
                                                strComplexFormName = "Infusion of [Matrix Attribute]";
                                                strForcedValue = "Attack";
                                                break;

                                            case "Infusion of Sleaze":
                                                strComplexFormName = "Infusion of [Matrix Attribute]";
                                                strForcedValue = "Sleaze";
                                                break;

                                            case "Infusion of Data Processing":
                                                strComplexFormName = "Infusion of [Matrix Attribute]";
                                                strForcedValue = "Data Processing";
                                                break;

                                            case "Infusion of Firewall":
                                                strComplexFormName = "Infusion of [Matrix Attribute]";
                                                strForcedValue = "Firewall";
                                                break;
                                        }

                                        XmlNode xmlComplexFormData =
                                            xmlComplexFormsDocument.TryGetNodeByNameOrId(
                                                "/chummer/complexforms/complexform", strComplexFormName);
                                        if (xmlComplexFormData == null)
                                        {
                                            string[] astrOriginalNameSplit =
                                                strComplexFormName.Split(':',
                                                                         StringSplitOptions.RemoveEmptyEntries);
                                            if (astrOriginalNameSplit.Length > 1)
                                            {
                                                string strName = astrOriginalNameSplit[0].Trim();
                                                xmlComplexFormData =
                                                    xmlComplexFormsDocument.TryGetNodeByNameOrId(
                                                        "/chummer/complexforms/complexform", strName);
                                            }

                                            if (xmlComplexFormData == null)
                                            {
                                                astrOriginalNameSplit = strComplexFormName.Split(',',
                                                    StringSplitOptions.RemoveEmptyEntries);
                                                if (astrOriginalNameSplit.Length > 1)
                                                {
                                                    string strName = astrOriginalNameSplit[0].Trim();
                                                    xmlComplexFormData =
                                                        xmlComplexFormsDocument.TryGetNodeByNameOrId(
                                                            "/chummer/complexforms/complexform", strName);
                                                }
                                            }
                                        }

                                        if (xmlComplexFormData != null)
                                        {
                                            ComplexForm objComplexForm = new ComplexForm(this);
                                            objComplexForm.Create(xmlComplexFormData, strForcedValue);
                                            if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                _lstComplexForms.Add(objComplexForm);
                                            else
                                                await _lstComplexForms.AddAsync(objComplexForm, token).ConfigureAwait(false);
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_complex");
                            }

                            /* TODO: AI Advanced Program Importing
                            Timekeeper.Start("load_char_aiprogram");

                            // AI Advanced Programs.
                            objXmlNodeList = objXmlCharacter.SelectNodes("aiprograms/aiprogram");
                            foreach (XmlNode xmlHeroLabProgram in xmlNodeList)
                            {
                                AIProgram objProgram = new AIProgram(this);
                                objProgram.Load(xmlHeroLabProgram);
                                _lstAIPrograms.Add(objProgram);
                            }

                            Timekeeper.Finish("load_char_aiprogram");
                            */
                            /* TODO: Martial Arts import, which are saved in TXT and HTML statblocks but not in XML statblock
                            Timekeeper.Start("load_char_marts");

                            // Martial Arts.
                            xmlNodeList = objXmlCharacter.SelectNodes("martialarts/martialart");
                            foreach (XmlNode xmlHeroLabArt in xmlNodeList)
                            {
                                MartialArt objMartialArt = new MartialArt(this);
                                objMartialArt.Load(xmlHeroLabArt);
                                _lstMartialArts.Add(objMartialArt);
                            }

                            Timekeeper.Finish("load_char_marts");
                            */
                            using (Timekeeper.StartSyncron("load_char_lifestyle", op_load))
                            {
                                // Lifestyles.
                                XmlNode xmlFakeSINDataNode =
                                    xmlGearDocument.SelectSingleNode("/chummer/gears/gear[name = 'Fake SIN']");
                                XmlNode xmlFakeLicenseDataNode =
                                    xmlGearDocument.SelectSingleNode("/chummer/gears/gear[name = 'Fake License']");
                                xmlNodeList = blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? xmlStatBlockBaseNode.SelectAndCacheExpression("identities/identity", token)
                                    : await xmlStatBlockBaseNode.SelectAndCacheExpressionAsync("identities/identity", token).ConfigureAwait(false);
                                foreach (XPathNavigator xmlHeroLabIdentity in xmlNodeList)
                                {
                                    string strIdentityName
                                        = (blnSync
                                            // ReSharper disable once MethodHasAsyncOverload
                                            ? xmlHeroLabIdentity.SelectSingleNodeAndCacheExpression("@name", token)
                                            : await xmlHeroLabIdentity
                                                    .SelectSingleNodeAndCacheExpressionAsync("@name", token)
                                                    .ConfigureAwait(false))
                                        ?.Value ?? string.Empty;
                                    int intIdentityNameParenthesesStart = strIdentityName.IndexOf('(');
                                    if (intIdentityNameParenthesesStart != -1)
                                        strIdentityName =
                                            strIdentityName.Substring(0, intIdentityNameParenthesesStart);
                                    XPathNavigator xmlHeroLabFakeSINNode =
                                        blnSync
                                            // ReSharper disable once MethodHasAsyncOverload
                                            ? xmlHeroLabIdentity.SelectSingleNodeAndCacheExpression(
                                                "license[@name = \"Fake SIN\"]", token)
                                            : await xmlHeroLabIdentity
                                                    .SelectSingleNodeAndCacheExpressionAsync(
                                                        "license[@name = \"Fake SIN\"]", token).ConfigureAwait(false);
                                    if (xmlHeroLabFakeSINNode != null)
                                    {
                                        Gear objFakeSIN = new Gear(this);
                                        objFakeSIN.Create(xmlFakeSINDataNode,
                                                          (blnSync
                                                              // ReSharper disable once MethodHasAsyncOverload
                                                              ? xmlHeroLabFakeSINNode
                                                                  .SelectSingleNodeAndCacheExpression(
                                                                      "@rating", token)
                                                              : await xmlHeroLabFakeSINNode
                                                                      .SelectSingleNodeAndCacheExpressionAsync(
                                                                          "@rating", token).ConfigureAwait(false))
                                                          ?.ValueAsInt
                                                          ?? 1,
                                                          lstWeapons,
                                                          strIdentityName);
                                        foreach (XPathNavigator xmlHeroLabFakeLicenseNode in xmlHeroLabIdentity
                                                     .Select(
                                                         "license[@name = \"Fake License\"]"))
                                        {
                                            Gear objFakeLicense = new Gear(this);
                                            objFakeLicense.Create(xmlFakeLicenseDataNode,
                                                                  (blnSync
                                                                      // ReSharper disable once MethodHasAsyncOverload
                                                                      ? xmlHeroLabFakeLicenseNode
                                                                          .SelectSingleNodeAndCacheExpression(
                                                                              "@rating", token)
                                                                      : await xmlHeroLabFakeLicenseNode
                                                                              .SelectSingleNodeAndCacheExpressionAsync(
                                                                                  "@rating", token)
                                                                              .ConfigureAwait(false))
                                                                  ?.ValueAsInt ??
                                                                  1,
                                                                  lstWeapons,
                                                                  (blnSync
                                                                      // ReSharper disable once MethodHasAsyncOverload
                                                                      ? xmlHeroLabFakeLicenseNode
                                                                          .SelectSingleNodeAndCacheExpression(
                                                                              "@for", token)
                                                                      : await xmlHeroLabFakeLicenseNode
                                                                              .SelectSingleNodeAndCacheExpressionAsync(
                                                                                  "@for", token).ConfigureAwait(false))
                                                                  ?.Value ?? string.Empty);
                                            objFakeLicense.Parent = objFakeSIN;
                                            if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                objFakeSIN.Children.Add(objFakeLicense);
                                            else
                                                await objFakeSIN.Children.AddAsync(objFakeLicense, token).ConfigureAwait(false);
                                        }

                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstGear.Add(objFakeSIN);
                                        else
                                            await _lstGear.AddAsync(objFakeSIN, token).ConfigureAwait(false);
                                    }

                                    XPathNavigator xmlHeroLabLifestyleNode = blnSync
                                        // ReSharper disable once MethodHasAsyncOverload
                                        ? xmlHeroLabIdentity.SelectSingleNodeAndCacheExpression("lifestyle", token)
                                        : await xmlHeroLabIdentity
                                                .SelectSingleNodeAndCacheExpressionAsync("lifestyle", token)
                                                .ConfigureAwait(false);
                                    if (xmlHeroLabLifestyleNode != null)
                                    {
                                        string strLifestyleType
                                            = (blnSync
                                                  // ReSharper disable once MethodHasAsyncOverload
                                                  ? xmlHeroLabLifestyleNode.SelectSingleNodeAndCacheExpression(
                                                      "@name", token)
                                                  : await xmlHeroLabLifestyleNode
                                                          .SelectSingleNodeAndCacheExpressionAsync("@name", token)
                                                          .ConfigureAwait(false))
                                              ?.Value
                                              .TrimEndOnce(" Lifestyle") ?? string.Empty;

                                        XmlNode xmlLifestyleDataNode =
                                            (blnSync
                                                // ReSharper disable once MethodHasAsyncOverload
                                                ? LoadData("lifestyles.xml", token: token)
                                                : await LoadDataAsync("lifestyles.xml", token: token).ConfigureAwait(false))
                                            .TryGetNodeByNameOrId("/chummer/lifestyles/lifestyle", strLifestyleType);

                                        if (xmlLifestyleDataNode != null)
                                        {
                                            Lifestyle objLifestyle = new Lifestyle(this);
                                            objLifestyle.Create(xmlLifestyleDataNode);
                                            if (int.TryParse(
                                                    (blnSync
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        ? xmlHeroLabLifestyleNode.SelectSingleNodeAndCacheExpression(
                                                            "@months", token)
                                                        : await xmlHeroLabLifestyleNode
                                                                .SelectSingleNodeAndCacheExpressionAsync("@months", token).ConfigureAwait(false))
                                                    ?.Value,
                                                    out int intMonths))
                                            {
                                                objLifestyle.Increments = intMonths;
                                            }

                                            if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                _lstLifestyles.Add(objLifestyle);
                                            else
                                                await _lstLifestyles.AddAsync(objLifestyle, token)
                                                                    .ConfigureAwait(false);
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_lifestyle");
                            }

                            using (Timekeeper.StartSyncron("load_char_gear", op_load))
                            {
                                // <gears>
                                foreach (XPathNavigator xmlGearToImport in xmlStatBlockBaseNode.Select(
                                             "gear/equipment/item[@useradded != \"no\"]"))
                                {
                                    Gear objGear = new Gear(this);
                                    if (objGear.ImportHeroLabGear(xmlGearToImport, null, lstWeapons, token))
                                    {
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstGear.Add(objGear);
                                        else
                                            await _lstGear.AddAsync(objGear, token).ConfigureAwait(false);
                                    }
                                }

                                if (blnSync)
                                {
                                    foreach (XPathNavigator xmlPluginToAdd in xmlStatBlockBaseNode
                                                 // ReSharper disable once MethodHasAsyncOverload
                                                 .SelectAndCacheExpression(
                                                     "gear/equipment/item[@useradded = \"no\"]", token))
                                    {
                                        // ReSharper disable once MethodHasAsyncOverload
                                        string strName = xmlPluginToAdd.SelectSingleNodeAndCacheExpression("@name", token)
                                                                       ?.Value;
                                        if (!string.IsNullOrEmpty(strName))
                                        {
                                            Gear objPlugin = _lstGear.FirstOrDefault(x =>
                                                x.IncludedInParent &&
                                                (x.Name.Contains(strName) || strName.Contains(x.Name)));
                                            if (objPlugin != null)
                                            {
                                                objPlugin.Quantity =
                                                    Convert.ToDecimal(
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        xmlPluginToAdd.SelectSingleNodeAndCacheExpression("@quantity", token)
                                                                      ?.Value ?? "1",
                                                        GlobalSettings.InvariantCultureInfo);
                                                objPlugin.Notes = xmlPluginToAdd
                                                                  // ReSharper disable once MethodHasAsyncOverload
                                                                  .SelectSingleNodeAndCacheExpression("description", token)
                                                                  ?.Value;
                                                // ReSharper disable once MethodHasAsyncOverload
                                                objPlugin.ProcessHeroLabGearPlugins(xmlPluginToAdd, lstWeapons, token);
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    foreach (XPathNavigator xmlPluginToAdd in await xmlStatBlockBaseNode
                                                 .SelectAndCacheExpressionAsync(
                                                     "gear/equipment/item[@useradded = \"no\"]", token)
                                                 .ConfigureAwait(false))
                                    {
                                        string strName = (await xmlPluginToAdd
                                                                .SelectSingleNodeAndCacheExpressionAsync("@name", token)
                                                                .ConfigureAwait(false))
                                            ?.Value;
                                        if (!string.IsNullOrEmpty(strName))
                                        {
                                            Gear objPlugin = await _lstGear.FirstOrDefaultAsync(x =>
                                                                               x.IncludedInParent &&
                                                                               (x.Name.Contains(strName)
                                                                                   || strName.Contains(x.Name)), token)
                                                                           .ConfigureAwait(false);
                                            if (objPlugin != null)
                                            {
                                                objPlugin.Quantity =
                                                    Convert.ToDecimal(
                                                        (await xmlPluginToAdd
                                                               .SelectSingleNodeAndCacheExpressionAsync(
                                                                   "@quantity", token).ConfigureAwait(false))
                                                        ?.Value ?? "1",
                                                        GlobalSettings.InvariantCultureInfo);
                                                objPlugin.Notes = (await xmlPluginToAdd
                                                                         .SelectSingleNodeAndCacheExpressionAsync(
                                                                             "description", token)
                                                                         .ConfigureAwait(false))
                                                    ?.Value;
                                                await objPlugin
                                                      .ProcessHeroLabGearPluginsAsync(xmlPluginToAdd, lstWeapons, token)
                                                      .ConfigureAwait(false);
                                            }
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_gear");
                            }

                            using (Timekeeper.StartSyncron("load_char_car", op_load))
                            {
                                foreach (Vehicle objVehicle in lstVehicles)
                                {
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstVehicles.Add(objVehicle);
                                    else
                                        await _lstVehicles.AddAsync(objVehicle, token).ConfigureAwait(false);
                                }

                                /* TODO: Process HeroLab Vehicles entries, which are present in HTML and TXT statblocks but not in XML
                                // Vehicles.
                                xmlNodeList = objXmlCharacter.SelectNodes("vehicles/vehicle");
                                foreach (XmlNode xmlHeroLabVehicle in xmlNodeList)
                                {
                                    Vehicle objVehicle = new Vehicle(this);
                                    objVehicle.Load(xmlHeroLabVehicle);
                                    _lstVehicles.Add(objVehicle);
                                }
                                */
                                //Timekeeper.Finish("load_char_car");
                            }

                            /* TODO: Process HeroLab Initiation/Submersion and related entries
                            Timekeeper.Start("load_char_mmagic");
                            // Metamagics/Echoes.
                            xmlNodeList = objXmlCharacter.SelectNodes("metamagics/metamagic");
                            foreach (XmlNode xmlHeroLabMetamagic in xmlNodeList)
                            {
                                Metamagic objMetamagic = new Metamagic(this);
                                objMetamagic.Load(xmlHeroLabMetamagic);
                                _lstMetamagics.Add(objMetamagic);
                            }

                            Timekeeper.Finish("load_char_mmagic");
                            Timekeeper.Start("load_char_arts");

                            // Arts
                            xmlNodeList = objXmlCharacter.SelectNodes("arts/art");
                            foreach (XmlNode xmlHeroLabArt in xmlNodeList)
                            {
                                Art objArt = new Art(this);
                                objArt.Load(xmlHeroLabArt);
                                _lstArts.Add(objArt);
                            }

                            Timekeeper.Finish("load_char_arts");
                            Timekeeper.Start("load_char_ench");

                            // Enhancements
                            xmlNodeList = objXmlCharacter.SelectNodes("enhancements/enhancement");
                            foreach (XmlNode xmlHeroLabEnhancement in objXmlNodeList)
                            {
                                Enhancement objEnhancement = new Enhancement(this);
                                objEnhancement.Load(xmlHeroLabEnhancement);
                                _lstEnhancements.Add(objEnhancement);
                            }

                            Timekeeper.Finish("load_char_ench");
                            Timekeeper.Start("load_char_cpow");

                            // Critter Powers.
                            xmlNodeList = objXmlCharacter.SelectNodes("critterpowers/critterpower");
                            foreach (XmlNode xmlHeroLabPower in xmlNodeList)
                            {
                                CritterPower objPower = new CritterPower(this);
                                objPower.Load(xmlHeroLabPower);
                                _lstCritterPowers.Add(objPower);
                            }

                            Timekeeper.Finish("load_char_cpow");
                            Timekeeper.Start("load_char_foci");

                            // Foci.
                            xmlNodeList = objXmlCharacter.SelectNodes("foci/focus");
                            foreach (XmlNode xmlHeroLabFocus in xmlNodeList)
                            {
                                Focus objFocus = new Focus(this);
                                objFocus.Load(xmlHeroLabFocus);
                                _lstFoci.Add(objFocus);
                            }

                            Timekeeper.Finish("load_char_foci");
                            Timekeeper.Start("load_char_init");

                            // Initiation Grades.
                            xmlNodeList = objXmlCharacter.SelectNodes("initiationgrades/initiationgrade");
                            foreach (XmlNode xmlHeroLabGrade in xmlNodeList)
                            {
                                InitiationGrade objGrade = new InitiationGrade(this);
                                objGrade.Load(xmlHeroLabGrade);
                                _lstInitiationGrades.Add(objGrade);
                            }

                            Timekeeper.Finish("load_char_init");
                            */
                            /* TODO: Import HeroLab Expense Logs, which are different from Journal entries
                            Timekeeper.Start("load_char_elog");

                            // Expense Log Entries.
                            XmlNodeList xmlExpenseList = objXmlCharacter.SelectNodes("expenses/expense");
                            foreach (XmlNode xmlHeroLabExpense in xmlExpenseList)
                            {
                                ExpenseLogEntry objExpenseLogEntry = new ExpenseLogEntry(this);
                                objExpenseLogEntry.Load(xmlHeroLabExpense);
                                _lstExpenseLog.Add(objExpenseLogEntry);
                            }

                            Timekeeper.Finish("load_char_elog");
                            */
                            _lstWeapons.AddRange(lstWeapons);

                            using (Timekeeper.StartSyncron("load_char_unarmed", op_load))
                            {
                                // Look for the unarmed attack
                                bool blnFoundUnarmed = false;
                                foreach (Weapon objWeapon in _lstWeapons)
                                {
                                    if (objWeapon.Name == "Unarmed Attack")
                                    {
                                        blnFoundUnarmed = true;
                                        break;
                                    }
                                }

                                if (!blnFoundUnarmed)
                                {
                                    // Add the Unarmed Attack Weapon to the character.
                                    XmlDocument objXmlWeaponDoc = blnSync
                                        // ReSharper disable once MethodHasAsyncOverload
                                        ? LoadData("weapons.xml", token: token)
                                        : await LoadDataAsync("weapons.xml", token: token).ConfigureAwait(false);
                                    XmlNode objXmlWeapon =
                                        objXmlWeaponDoc.SelectSingleNode(
                                            "/chummer/weapons/weapon[name = \"Unarmed Attack\"]");
                                    if (objXmlWeapon != null)
                                    {
                                        Weapon objWeapon = new Weapon(this);
                                        objWeapon.Create(objXmlWeapon, _lstWeapons);
                                        objWeapon.IncludedInWeapon = true; // Unarmed attack can never be removed
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstWeapons.Add(objWeapon);
                                        else
                                            await _lstWeapons.AddAsync(objWeapon, token).ConfigureAwait(false);
                                    }
                                }

                                //Timekeeper.Finish("load_char_unarmed");
                            }
                        }
                        finally
                        {
                            IsLoading = false;
                        }

                        // Refresh certain improvements
                        using (Timekeeper.StartSyncron("load_char_improvementrefreshers2", op_load))
                        {
                            if (blnSync)
                            {
                                // ReSharper disable MethodHasAsyncOverload
                                // Refresh Black Market discounts
                                RefreshBlackMarketDiscounts(token);
                                // Refresh Dealer Connection discounts
                                RefreshDealerConnectionDiscounts(token);
                                // Refresh permanent attribute changes due to essence loss
                                RefreshEssenceLossImprovements(token);
                                // Refresh dicepool modifiers due to filled condition monitor boxes
                                RefreshWoundPenalties(token);
                                // Refresh encumbrance penalties
                                RefreshEncumbrance(token);
                                RefreshArmorEncumbrance(token);
                                // ReSharper restore MethodHasAsyncOverload
                            }
                            else
                            {
                                // Refresh Black Market discounts
                                await RefreshBlackMarketDiscountsAsync(token).ConfigureAwait(false);
                                // Refresh Dealer Connection discounts
                                await RefreshDealerConnectionDiscountsAsync(token).ConfigureAwait(false);
                                // Refresh permanent attribute changes due to essence loss
                                await RefreshEssenceLossImprovementsAsync(token).ConfigureAwait(false);
                                // Refresh dicepool modifiers due to filled condition monitor boxes
                                await RefreshWoundPenaltiesAsync(token).ConfigureAwait(false);
                                // Refresh encumbrance penalties
                                await RefreshEncumbranceAsync(token).ConfigureAwait(false);
                                await RefreshArmorEncumbranceAsync(token).ConfigureAwait(false);
                            }
                            // Curb Mystic Adept power points if the values that were loaded in would be illegal
                            if (MysticAdeptPowerPoints > 0)
                            {
                                int intMAGTotalValue = blnSync
                                    ? MAG.TotalValue
                                    : await (await GetAttributeAsync("MAG", token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false);
                                if (MysticAdeptPowerPoints > intMAGTotalValue)
                                    MysticAdeptPowerPoints = intMAGTotalValue;
                            }

                            if (!InitiationEnabled || !AddInitiationsAllowed)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ClearInitiations(token);
                                else
                                    await ClearInitiationsAsync(token).ConfigureAwait(false);
                            }
                            //Timekeeper.Finish("load_char_improvementrefreshers");
                        }
                    }
                    catch (Exception e)
                    {
                        op_load.SetSuccess(false);
                        TelemetryClient.TrackException(e);
                        Log.Error(e);
                    }
                }

                return true;
            }
            finally
            {
                if (blnSync)
                    // ReSharper disable once MethodHasAsyncOverload
                    objLocker.Dispose();
                else
                    await objLockerAsync.DisposeAsync().ConfigureAwait(false);
            }
        }

        #endregion Hero Lab Importing

        #region Karma Values

        private int _intCachedPositiveQualityLimitKarma = int.MinValue;

        /// <summary>
        /// Total value of positive qualities that count towards the maximum quality limit in create mode.
        /// </summary>
        public int PositiveQualityLimitKarma
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedPositiveQualityLimitKarma == int.MinValue)
                    {
                        int intNewValue
                            = Qualities.Sum(
                                objQuality => objQuality.Type == QualityType.Positive && objQuality.ContributeToLimit,
                                objQuality => objQuality.BP) * Settings.KarmaQuality;
                        // Group contacts are counted as positive qualities
                        intNewValue += Contacts.Sum(x => x.EntityType == ContactType.Contact && x.IsGroup && !x.Free,
                                                    x => x.ContactPoints) * Settings.KarmaContact;

                        // Deduct the amount for free Qualities.
                        intNewValue -=
                            (ImprovementManager.ValueOf(this, Improvement.ImprovementType.FreePositiveQualities) *
                             Settings.KarmaQuality).StandardRound();

                        // If the character is allowed to take as many Positive Qualities as they'd like but all costs in excess are doubled, add the excess to their point cost.
                        if (Settings.ExceedPositiveQualitiesCostDoubled)
                        {
                            int intPositiveQualityExcess = intNewValue - Settings.QualityKarmaLimit;
                            if (intPositiveQualityExcess > 0)
                            {
                                intNewValue += intPositiveQualityExcess;
                            }
                        }

                        _intCachedPositiveQualityLimitKarma = intNewValue;
                    }

                    return _intCachedPositiveQualityLimitKarma;
                }
            }
        }

        private int _intCachedPositiveQualities = int.MinValue;

        /// <summary>
        /// Total value of ALL positive qualities, including those that don't contribute to the quality limit during character creation.
        /// </summary>
        public int PositiveQualityKarma
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedPositiveQualities == int.MinValue)
                    {
                        // Qualities that count towards the Quality Limit are checked first to support the house rule allowing doubling of qualities over said limit.
                        int intNewValue
                            = Qualities.Sum(
                                  objQuality => objQuality.Type == QualityType.Positive && objQuality.ContributeToBP
                                      && objQuality.ContributeToLimit, objQuality => objQuality.BP)
                              * Settings.KarmaQuality;
                        // Group contacts are counted as positive qualities
                        intNewValue += Contacts.Sum(x => x.EntityType == ContactType.Contact && x.IsGroup && !x.Free,
                                                    x => x.ContactPoints) * Settings.KarmaContact;

                        // Deduct the amount for free Qualities.
                        intNewValue -=
                            (ImprovementManager.ValueOf(this, Improvement.ImprovementType.FreePositiveQualities) *
                             Settings.KarmaQuality).StandardRound();

                        if (FreeSpells > 0)
                        {
                            // Factor in any qualities that can be bought with spell points at the end, but before doubled karma costs are calculated.
                            int intMasteryQualityKarmaUsed
                                = Qualities.Sum(objQuality => objQuality.CanBuyWithSpellPoints,
                                                objQuality => objQuality.BP);
                            if (intMasteryQualityKarmaUsed != 0)
                            {
                                // Each spell costs KarmaSpell.
                                int spellCost = SpellKarmaCost("Spells");
                                // It is only karma-efficient to use spell points for Mastery qualities if real spell karma cost is not greater than unmodified spell karma cost
                                if (spellCost <= Settings.KarmaSpell)
                                {
                                    // Assume that every [spell cost] karma spent on a Mastery quality is paid for with a priority-given spell point instead, as that is the most karma-efficient.
                                    int intQualityKarmaToSpellPoints = Settings.KarmaSpell;
                                    if (Settings.KarmaSpell != 0)
                                        intQualityKarmaToSpellPoints
                                            = Math.Min(FreeSpells,
                                                       (intMasteryQualityKarmaUsed * Settings.KarmaQuality)
                                                       / Settings.KarmaSpell);
                                    // Add the karma paid for by spell points back into the available karma pool.
                                    intNewValue -= intQualityKarmaToSpellPoints * Settings.KarmaSpell;
                                }
                            }
                        }

                        // If the character is allowed to take as many Positive Qualities as they'd like but all costs in excess are doubled, add the excess to their point cost.
                        if (Settings.ExceedPositiveQualitiesCostDoubled)
                        {
                            int intPositiveQualityExcess =
                                intNewValue - Settings.QualityKarmaLimit;
                            if (intPositiveQualityExcess > 0)
                            {
                                intNewValue += intPositiveQualityExcess;
                            }
                        }

                        // Qualities that don't count towards the cap are added afterwards.
                        intNewValue += Qualities.Sum(
                            objQuality => objQuality.Type == QualityType.Positive && objQuality.ContributeToBP
                                && !objQuality.ContributeToLimit, objQuality => objQuality.BP) * Settings.KarmaQuality;

                        _intCachedPositiveQualities = intNewValue;
                    }

                    return _intCachedPositiveQualities;
                }
            }
        }

        /// <summary>
        /// Total value of ALL positive qualities, including those that don't contribute to the quality limit during character creation.
        /// </summary>
        public async ValueTask<int> GetPositiveQualityKarmaAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (_intCachedPositiveQualities == int.MinValue)
                {
                    ThreadSafeObservableCollection<Quality> lstQualities = await GetQualitiesAsync(token).ConfigureAwait(false);
                    CharacterSettings objSettings = await GetSettingsAsync(token).ConfigureAwait(false);
                    int intKarmaQuality = await objSettings.GetKarmaQualityAsync(token).ConfigureAwait(false);
                    // Qualities that count towards the Quality Limit are checked first to support the house rule allowing zeroing of qualities over said limit.
                    int intNewValue
                        = await lstQualities.SumAsync(
                              objQuality => objQuality.Type == QualityType.Positive && objQuality.ContributeToBP
                                  && objQuality.ContributeToLimit, objQuality => objQuality.BP, token: token).ConfigureAwait(false)
                          * intKarmaQuality;
                    // Group contacts are counted as positive qualities
                    intNewValue += await (await GetContactsAsync(token).ConfigureAwait(false)).SumAsync(
                                       x => x.EntityType == ContactType.Contact && x.IsGroup && !x.Free,
                                       x => x.ContactPoints, token: token).ConfigureAwait(false)
                                   * await objSettings.GetKarmaContactAsync(token).ConfigureAwait(false);

                    // Deduct the amount for free Qualities.
                    intNewValue -=
                        (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.FreePositiveQualities, token: token).ConfigureAwait(false) *
                         intKarmaQuality).StandardRound();

                    // Factor in any qualities that can be bought with spell points at the end, but before doubled karma costs are calculated.
                    int intMasteryQualityKarmaUsed
                        = await lstQualities.SumAsync(objQuality => objQuality.CanBuyWithSpellPoints,
                                                      objQuality => objQuality.BP, token: token).ConfigureAwait(false);
                    if (intMasteryQualityKarmaUsed != 0)
                    {
                        // Each spell costs KarmaSpell.
                        int spellCost = await SpellKarmaCostAsync("Spells", token).ConfigureAwait(false);
                        int intKarmaSpell = await objSettings.GetKarmaSpellAsync(token).ConfigureAwait(false);
                        int intFreeSpells = await GetFreeSpellsAsync(token).ConfigureAwait(false);
                        // It is only karma-efficient to use spell points for Mastery qualities if real spell karma cost is not greater than unmodified spell karma cost
                        if (spellCost <= intKarmaSpell && intFreeSpells > 0)
                        {
                            // Assume that every [spell cost] karma spent on a Mastery quality is paid for with a priority-given spell point instead, as that is the most karma-efficient.
                            int intQualityKarmaToSpellPoints = intKarmaSpell;
                            if (intKarmaSpell != 0)
                                intQualityKarmaToSpellPoints
                                    = Math.Min(intFreeSpells,
                                               (intMasteryQualityKarmaUsed * intKarmaQuality)
                                               / intKarmaSpell);
                            // Add the karma paid for by spell points back into the available karma pool.
                            intNewValue -= intQualityKarmaToSpellPoints * intKarmaSpell;
                        }
                    }

                    // If the character is allowed to take as many Positive Qualities as they'd like but all costs in excess are doubled, add the excess to their point cost.
                    if (await objSettings.GetExceedPositiveQualitiesCostDoubledAsync(token).ConfigureAwait(false))
                    {
                        int intPositiveQualityExcess =
                            intNewValue - await objSettings.GetQualityKarmaLimitAsync(token).ConfigureAwait(false);
                        if (intPositiveQualityExcess > 0)
                        {
                            intNewValue += intPositiveQualityExcess;
                        }
                    }

                    // Qualities that don't count towards the cap are added afterwards.
                    intNewValue += await lstQualities.SumAsync(
                        objQuality => objQuality.Type == QualityType.Positive && objQuality.ContributeToBP
                                                                              && !objQuality.ContributeToLimit,
                        objQuality => objQuality.BP, token: token).ConfigureAwait(false) * intKarmaQuality;

                    _intCachedPositiveQualities = intNewValue;
                }

                return _intCachedPositiveQualities;
            }
        }

        public string DisplayPositiveQualityKarma
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (PositiveQualityLimitKarma != PositiveQualityKarma)
                    {
                        return string.Format(GlobalSettings.CultureInfo, "{0}{2}/{2}{1}{2}({3}){2}{4}",
                                             PositiveQualityLimitKarma,
                                             Settings.QualityKarmaLimit,
                                             LanguageManager.GetString("String_Space"),
                                             PositiveQualityKarma,
                                             LanguageManager.GetString("String_Karma"));
                    }

                    return string.Format(GlobalSettings.CultureInfo, "{0}/{1}{2}{3}",
                                         PositiveQualityLimitKarma,
                                         Settings.QualityKarmaLimit,
                                         LanguageManager.GetString("String_Space"),
                                         LanguageManager.GetString("String_Karma"));
                }
            }
        }

        private int _intCachedNegativeQualities = int.MinValue;

        public int NegativeQualityKarma
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedNegativeQualities == int.MinValue)
                    {
                        // Qualities that count towards the Quality Limit are checked first to support the house rule allowing zeroing of qualities over said limit.
                        int intNewValue
                            = Qualities.Sum(
                                  objQuality => objQuality.Type == QualityType.Negative && objQuality.ContributeToBP
                                      && objQuality.ContributeToLimit, objQuality => objQuality.BP)
                              * Settings.KarmaQuality;
                        // Group contacts are counted as positive qualities
                        intNewValue += EnemyKarma;

                        // Deduct the amount for free Qualities.
                        intNewValue -=
                            ImprovementManager.ValueOf(this, Improvement.ImprovementType.FreeNegativeQualities)
                                .StandardRound();

                        // If the character is only allowed to gain 25 BP from Negative Qualities but allowed to take as many as they'd like, limit their refunded points.
                        if (Settings.ExceedNegativeQualitiesNoBonus)
                        {
                            int intNegativeQualityLimit = -Settings.QualityKarmaLimit;
                            if (intNewValue < intNegativeQualityLimit)
                            {
                                intNewValue = intNegativeQualityLimit;
                            }
                        }

                        // Qualities that don't count towards the cap are added afterwards.
                        intNewValue += Qualities.Sum(
                            objQuality => objQuality.Type == QualityType.Negative && objQuality.ContributeToBP
                                && !objQuality.ContributeToLimit, objQuality => objQuality.BP) * Settings.KarmaQuality;

                        _intCachedNegativeQualities = -intNewValue;
                    }

                    return _intCachedNegativeQualities;
                }
            }
        }

        public async ValueTask<int> GetNegativeQualityKarmaAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (_intCachedNegativeQualities == int.MinValue)
                {
                    ThreadSafeObservableCollection<Quality> lstQualities = await GetQualitiesAsync(token).ConfigureAwait(false);
                    CharacterSettings objSettings = await GetSettingsAsync(token).ConfigureAwait(false);
                    int intKarmaQuality = await objSettings.GetKarmaQualityAsync(token).ConfigureAwait(false);
                    // Qualities that count towards the Quality Limit are checked first to support the house rule allowing zeroing of qualities over said limit.
                    int intNewValue
                        = await lstQualities.SumAsync(
                              objQuality => objQuality.Type == QualityType.Negative && objQuality.ContributeToBP
                                  && objQuality.ContributeToLimit, objQuality => objQuality.BP, token: token).ConfigureAwait(false)
                          * intKarmaQuality;
                    // Group contacts are counted as positive qualities
                    intNewValue += await GetEnemyKarmaAsync(token).ConfigureAwait(false);

                    // Deduct the amount for free Qualities.
                    intNewValue -=
                        (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.FreeNegativeQualities, token: token).ConfigureAwait(false) * intKarmaQuality)
                            .StandardRound();

                    // If the character is only allowed to gain 25 BP from Negative Qualities but allowed to take as many as they'd like, limit their refunded points.
                    if (await objSettings.GetExceedNegativeQualitiesNoBonusAsync(token).ConfigureAwait(false))
                    {
                        int intNegativeQualityLimit = -await objSettings.GetQualityKarmaLimitAsync(token).ConfigureAwait(false);
                        if (intNewValue < intNegativeQualityLimit)
                        {
                            intNewValue = intNegativeQualityLimit;
                        }
                    }

                    // Qualities that don't count towards the cap are added afterwards.
                    intNewValue += await lstQualities.SumAsync(
                        objQuality => objQuality.Type == QualityType.Negative && objQuality.ContributeToBP
                                                                              && !objQuality.ContributeToLimit, objQuality => objQuality.BP, token: token).ConfigureAwait(false) * intKarmaQuality;

                    _intCachedNegativeQualities = -intNewValue;
                }

                return _intCachedNegativeQualities;
            }
        }

        private int _intCachedNegativeQualityLimitKarma = int.MinValue;

        /// <summary>
        /// Negative qualities that contribute to the character's Quality Limit during character creation.
        /// </summary>
        public int NegativeQualityLimitKarma
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedNegativeQualityLimitKarma == int.MinValue)
                    {
                        int intNewValue
                            = Qualities.Sum(
                                objQuality => objQuality.Type == QualityType.Negative && objQuality.ContributeToLimit,
                                objQuality => objQuality.BP) * Settings.KarmaQuality;
                        // Group contacts are counted as positive qualities
                        if (Settings.EnemyKarmaQualityLimit)
                            intNewValue += EnemyKarma;

                        // Deduct the amount for free Qualities.
                        intNewValue -=
                            ImprovementManager.ValueOf(this, Improvement.ImprovementType.FreeNegativeQualities)
                                .StandardRound();

                        // If the character is only allowed to gain 25 BP from Negative Qualities but allowed to take as many as they'd like, limit their refunded points.
                        if (Settings.ExceedNegativeQualitiesNoBonus)
                        {
                            int intNegativeQualityLimit = -Settings.QualityKarmaLimit;
                            if (intNewValue < intNegativeQualityLimit)
                            {
                                intNewValue = intNegativeQualityLimit;
                            }
                        }

                        _intCachedNegativeQualityLimitKarma = -intNewValue;
                    }

                    return _intCachedNegativeQualityLimitKarma;
                }
            }
        }

        public string DisplayNegativeQualityKarma
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (NegativeQualityLimitKarma != NegativeQualityKarma)
                    {
                        return string.Format(GlobalSettings.CultureInfo, "{0}{2}/{2}{1}{2}({3}){2}{4}",
                                             NegativeQualityLimitKarma,
                                             Settings.QualityKarmaLimit,
                                             LanguageManager.GetString("String_Space"),
                                             NegativeQualityKarma,
                                             LanguageManager.GetString("String_Karma"));
                    }

                    return string.Format(GlobalSettings.CultureInfo, "{0}/{1}{2}{3}",
                                         NegativeQualityLimitKarma,
                                         Settings.QualityKarmaLimit,
                                         LanguageManager.GetString("String_Space"),
                                         LanguageManager.GetString("String_Karma"));
                }
            }
        }

        private int _intCachedMetagenicPositiveQualities = int.MinValue;

        public int MetagenicPositiveQualityKarma
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedMetagenicPositiveQualities == int.MinValue)
                    {
                        _intCachedMetagenicPositiveQualities = Qualities
                            .Sum(
                                objQuality =>
                                    objQuality.Type == QualityType.Positive && objQuality.ContributeToMetagenicLimit,
                                objQuality => objQuality.BP);
                    }

                    return _intCachedMetagenicPositiveQualities;
                }
            }
        }

        public async ValueTask<int> GetMetagenicPositiveQualityKarmaAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (_intCachedMetagenicPositiveQualities == int.MinValue)
                {
                    ThreadSafeObservableCollection<Quality> lstQualities = await GetQualitiesAsync(token).ConfigureAwait(false);
                    _intCachedMetagenicPositiveQualities = await lstQualities.SumAsync(objQuality =>
                            objQuality.Type == QualityType.Positive && objQuality.ContributeToMetagenicLimit,
                        objQuality => objQuality.BP, token: token).ConfigureAwait(false);
                }

                return _intCachedMetagenicPositiveQualities;
            }
        }

        private int _intCachedMetagenicNegativeQualities = int.MinValue;

        public int MetagenicNegativeQualityKarma
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedMetagenicNegativeQualities == int.MinValue)
                    {
                        int intNewValue = Qualities
                            .Sum(
                                objQuality =>
                                    objQuality.Type == QualityType.Negative && objQuality.ContributeToMetagenicLimit,
                                objQuality => objQuality.BP);

                        // Deduct the amount for free Qualities.
                        intNewValue -=
                            ImprovementManager.ValueOf(this, Improvement.ImprovementType.FreeNegativeQualities)
                                .StandardRound();

                        _intCachedMetagenicNegativeQualities = intNewValue;
                    }

                    return _intCachedMetagenicNegativeQualities;
                }
            }
        }

        public async ValueTask<int> GetMetagenicNegativeQualityKarmaAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (_intCachedMetagenicNegativeQualities == int.MinValue)
                {
                    ThreadSafeObservableCollection<Quality> lstQualities = await GetQualitiesAsync(token).ConfigureAwait(false);
                    int intNewValue = await lstQualities.SumAsync(objQuality =>
                            objQuality.Type == QualityType.Negative && objQuality.ContributeToMetagenicLimit,
                        objQuality => objQuality.BP, token: token).ConfigureAwait(false);
                    // Deduct the amount for free Qualities.
                    intNewValue -=
                        (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.FreeNegativeQualities, token: token).ConfigureAwait(false))
                                          .StandardRound();

                    _intCachedMetagenicNegativeQualities = intNewValue;
                }

                return _intCachedMetagenicNegativeQualities;
            }
        }

        public string DisplayMetagenicQualityKarma
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    string strReturn = string.Format(GlobalSettings.CultureInfo,
                        LanguageManager.GetString("Label_MetagenicKarmaValue"), MetagenicPositiveQualityKarma,
                        MetagenicNegativeQualityKarma, MetagenicLimit);
                    if (MetagenicPositiveQualityKarma + MetagenicNegativeQualityKarma == 1)
                        strReturn += LanguageManager.GetString("Label_MetagenicKarmaValueAppend");

                    return strReturn;
                }
            }
        }

        private int _intCachedEnemyKarma = int.MinValue;

        public int EnemyKarma
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedEnemyKarma != int.MinValue)
                        return _intCachedEnemyKarma;
                    if (Settings.EnableEnemyTracking && Settings.KarmaEnemy > 0)
                        return _intCachedEnemyKarma
                            = Contacts.Sum(x => x.IsEnemy && !x.Free, x => x.Connection + x.Loyalty)
                              * Settings.KarmaEnemy;
                    return _intCachedEnemyKarma = 0;
                }
            }
        }

        public async ValueTask<int> GetEnemyKarmaAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (_intCachedEnemyKarma != int.MinValue)
                    return _intCachedEnemyKarma;
                CharacterSettings objSettings = await GetSettingsAsync(token).ConfigureAwait(false);
                if (await objSettings.GetEnableEnemyTrackingAsync(token).ConfigureAwait(false))
                {
                    int intKarmaEnemy = await objSettings.GetKarmaEnemyAsync(token).ConfigureAwait(false);
                    if (intKarmaEnemy > 0)
                    {
                        return _intCachedEnemyKarma
                            = await (await GetContactsAsync(token).ConfigureAwait(false)).SumAsync(x => x.IsEnemy && !x.Free, x => x.Connection + x.Loyalty, token: token).ConfigureAwait(false)
                              * intKarmaEnemy;
                    }
                }

                return _intCachedEnemyKarma = 0;
            }
        }

        public string DisplayEnemyKarma =>
            EnemyKarma.ToString(GlobalSettings.CultureInfo)
            + LanguageManager.GetString("String_Space")
            + LanguageManager.GetString("String_Karma");

        #endregion Karma Values

        #region Source

        private SourceString _objCachedSourceDetail;
        private readonly SkillsSection _objSkillsSection;
        private readonly AttributeSection _objAttributeSection;
        private readonly ConcurrentHashSet<Func<CancellationToken, bool>> _setPostLoadMethods = new ConcurrentHashSet<Func<CancellationToken, bool>>();
        private readonly ConcurrentHashSet<Func<CancellationToken, Task<bool>>> _setPostLoadAsyncMethods = new ConcurrentHashSet<Func<CancellationToken, Task<bool>>>();

        public SourceString SourceDetail
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_objCachedSourceDetail == default || _objCachedSourceDetail.Language != GlobalSettings.Language)
                    {
                        using (LockObject.EnterWriteLock())
                        {
                            _objCachedSourceDetail = SourceString.GetSourceString(Source,
                                DisplayPage(GlobalSettings.Language), GlobalSettings.Language,
                                GlobalSettings.CultureInfo,
                                this);
                        }
                    }
                    return _objCachedSourceDetail;
                }
            }
        }

        /// <summary>
        /// Character's Sourcebook.
        /// </summary>
        public string Source
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strSource;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _strSource, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        /// <summary>
        /// Sourcebook Page Number.
        /// </summary>
        public string Page
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strPage;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Interlocked.Exchange(ref _strPage, value) == value)
                        return;
                    OnPropertyChanged();
                }
            }
        }

        public bool AllowAdeptWayPowerDiscount
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    decimal decMAG;
                    if (IsMysticAdept && Settings.MysAdeptSecondMAGAttribute)
                    {
                        // If both Adept and Magician are enabled, this is a Mystic Adept, so use the MAG amount assigned to this portion.
                        decMAG = MAGAdept.TotalValue;
                    }
                    else
                    {
                        // The character is just an Adept, so use the full value.
                        decMAG = MAG.TotalValue;
                    }

                    // Add any Power Point Improvements to MAG.
                    decMAG += ImprovementManager.ValueOf(this, Improvement.ImprovementType.AdeptPowerPoints);

                    return AnyPowerAdeptWayDiscountEnabled &&
                           Powers.Count(p => p.DiscountedAdeptWay) < (decMAG / 2).ToInt32();
                }
            }
        }

        /// <summary>
        /// Sourcebook Page Number using a given language file.
        /// Returns Page if not found or the string is empty.
        /// </summary>
        /// <param name="strLanguage">Language file keyword to use.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        /// <returns></returns>
        public string DisplayPage(string strLanguage, CancellationToken token = default)
        {
            using (EnterReadLock.Enter(LockObject, token))
            {
                if (strLanguage.Equals(GlobalSettings.DefaultLanguage, StringComparison.OrdinalIgnoreCase))
                    return Page;
                string s = this.GetNodeXPath(token)?.SelectSingleNodeAndCacheExpression("altpage", token)?.Value ?? Page;
                return !string.IsNullOrWhiteSpace(s) ? s : Page;
            }
        }

        /// <summary>
        /// Alias map for SourceDetail control text and tooltip assignation.
        /// </summary>
        /// <param name="sourceControl"></param>
        public void SetSourceDetail(Control sourceControl)
        {
            SourceDetail.SetControl(sourceControl);
        }

        public Task SetSourceDetailAsync(Control sourceControl, CancellationToken token = default)
        {
            return SourceDetail.SetControlAsync(sourceControl, token);
        }

        #endregion Source

        #region Special Methods

        private List<ListItem> _lstCachedContactArchetypes;
        private string _strCachedXmlNodeLanguage = string.Empty;

        public List<ListItem> ContactArchetypes(string strLanguage = "")
        {
            if (string.IsNullOrEmpty(strLanguage))
                strLanguage = GlobalSettings.Language;
            using (EnterReadLock.Enter(this))
            {
                if (_lstCachedContactArchetypes != null && strLanguage == _strCachedXmlNodeLanguage
                                                        && !GlobalSettings.LiveCustomData)
                    return _lstCachedContactArchetypes;
                List<ListItem> lstNew = Utils.ListItemListPool.Get();
                lstNew.Add(ListItem.Blank);
                XPathNavigator xmlContactsBaseNode = LoadDataXPath("contacts.xml", strLanguage)
                    .SelectSingleNodeAndCacheExpression("/chummer");
                if (xmlContactsBaseNode != null)
                {
                    foreach (XPathNavigator xmlNode in xmlContactsBaseNode.SelectAndCacheExpression("contacts/contact"))
                    {
                        string strName = xmlNode.Value;
                        lstNew.Add(
                            new ListItem(
                                strName, xmlNode.SelectSingleNodeAndCacheExpression("@translate")?.Value ?? strName));
                    }

                    lstNew.Sort(CompareListItems.CompareNames);
                }
                _strCachedXmlNodeLanguage = strLanguage;
                List<ListItem> lstOld = Interlocked.Exchange(ref _lstCachedContactArchetypes, lstNew);
                if (lstOld != null)
                    Utils.ListItemListPool.Return(ref lstOld);
                return _lstCachedContactArchetypes;
            }
        }

        public async ValueTask<List<ListItem>> ContactArchetypesAsync(string strLanguage = "", CancellationToken token = default)
        {
            if (string.IsNullOrEmpty(strLanguage))
                strLanguage = GlobalSettings.Language;
            using (await EnterReadLock.EnterAsync(this, token).ConfigureAwait(false))
            {
                if (_lstCachedContactArchetypes != null && strLanguage == _strCachedXmlNodeLanguage
                                                        && !GlobalSettings.LiveCustomData)
                    return _lstCachedContactArchetypes;
                List<ListItem> lstNew = Utils.ListItemListPool.Get();
                lstNew.Add(ListItem.Blank);
                XPathNavigator xmlContactsBaseNode = await (await LoadDataXPathAsync("contacts.xml", strLanguage, token: token).ConfigureAwait(false))
                                                           .SelectSingleNodeAndCacheExpressionAsync("/chummer", token).ConfigureAwait(false);
                if (xmlContactsBaseNode != null)
                {
                    foreach (XPathNavigator xmlNode in await xmlContactsBaseNode.SelectAndCacheExpressionAsync("contacts/contact", token).ConfigureAwait(false))
                    {
                        string strName = xmlNode.Value;
                        lstNew.Add(
                            new ListItem(
                                strName, (await xmlNode.SelectSingleNodeAndCacheExpressionAsync("@translate", token).ConfigureAwait(false))?.Value ?? strName));
                    }

                    lstNew.Sort(CompareListItems.CompareNames);
                }
                _strCachedXmlNodeLanguage = strLanguage;
                List<ListItem> lstOld = Interlocked.Exchange(ref _lstCachedContactArchetypes, lstNew);
                if (lstOld != null)
                    Utils.ListItemListPool.Return(ref lstOld);
                return _lstCachedContactArchetypes;
            }
        }

        public async Task<bool> ConvertCyberzombie(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                bool blnEssence = true;
                string strMessage = await LanguageManager.GetStringAsync("Message_CyberzombieRequirements", token: token).ConfigureAwait(false);

                // Make sure the character has an Essence lower than 0.
                decimal decEssence = await EssenceAsync(token: token).ConfigureAwait(false);
                if (decEssence >= 0)
                {
                    strMessage += Environment.NewLine + '\t' +
                                  await LanguageManager.GetStringAsync("Message_CyberzombieRequirementsEssence", token: token).ConfigureAwait(false);
                    blnEssence = false;
                }

                bool blnEnabled = (await ImprovementManager
                                         .GetCachedImprovementListForValueOfAsync(this, Improvement.ImprovementType.EnableCyberzombie, token: token).ConfigureAwait(false)).Count > 0;

                if (!blnEnabled)
                    strMessage += Environment.NewLine + '\t' +
                                  await LanguageManager.GetStringAsync("Message_CyberzombieRequirementsImprovement", token: token).ConfigureAwait(false);

                if (!blnEssence || !blnEnabled)
                {
                    Program.ShowScrollableMessageBox(strMessage,
                                                     await LanguageManager.GetStringAsync("MessageTitle_CyberzombieRequirements", token: token).ConfigureAwait(false),
                                                     MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return false;
                }

                if (Program.ShowScrollableMessageBox(await LanguageManager.GetStringAsync("Message_CyberzombieConfirm", token: token).ConfigureAwait(false),
                                                     await LanguageManager.GetStringAsync("MessageTitle_CyberzombieConfirm", token: token).ConfigureAwait(false),
                                                     MessageBoxButtons.YesNo, MessageBoxIcon.Question) == DialogResult.No)
                    return false;

                int intWILResult;
                string strText = await LanguageManager.GetStringAsync("String_CyberzombieWILText", token: token).ConfigureAwait(false);
                string strDescription = await LanguageManager.GetStringAsync("String_CyberzombieWILDescription", token: token).ConfigureAwait(false);
                int intDice = await WIL.GetTotalValueAsync(token).ConfigureAwait(false);
                // Get the player to roll Dice to make a WIL Test and record the result.
                using (ThreadSafeForm<SelectDiceHits> frmWILHits = await ThreadSafeForm<SelectDiceHits>.GetAsync(() => new SelectDiceHits
                       {
                           Text = strText,
                           Description = strDescription,
                           Dice = intDice
                       }, token).ConfigureAwait(false))
                {
                    if (await frmWILHits.ShowDialogSafeAsync(this, token).ConfigureAwait(false) != DialogResult.OK)
                        return false;

                    intWILResult = frmWILHits.MyForm.Result;
                }

                // The character gains 10 + ((Threshold - Hits) * 10)BP worth of Negative Qualities.
                int intThreshold = 3 + (decEssence - await ESS.GetMetatypeMaximumAsync(token).ConfigureAwait(false)).ToInt32();
                int intResult = 10;
                if (intWILResult < intThreshold)
                {
                    intResult = (intThreshold - intWILResult) * 10;
                }

                try
                {
                    await ImprovementManager.CreateImprovementAsync(this, string.Empty,
                                                                    Improvement.ImprovementSource.Cyberzombie,
                                                                    string.Empty,
                                                                    Improvement.ImprovementType.FreeNegativeQualities,
                                                                    string.Empty, intResult * -1, token: token)
                                            .ConfigureAwait(false);
                }
                catch
                {
                    await ImprovementManager.RollbackAsync(this, CancellationToken.None).ConfigureAwait(false);
                    throw;
                }

                ImprovementManager.Commit(this);

                // Convert the character.
                // Characters lose access to Resonance.
                await SetRESEnabledAsync(false, token).ConfigureAwait(false);

                // Gain MAG that is permanently set to 1.
                await MAG.AssignBaseKarmaLimitsAsync(0, 0, 1, 1, 1, token).ConfigureAwait(false);

                // Add the Cyberzombie Lifestyle if it is not already taken.
                if (Lifestyles.All(x => x.BaseLifestyle != "Cyberzombie Lifestyle Addition"))
                {
                    XmlDocument objXmlLifestyleDocument = await LoadDataAsync("lifestyles.xml", token: token).ConfigureAwait(false);
                    XmlNode objXmlLifestyle =
                        objXmlLifestyleDocument.SelectSingleNode(
                            "/chummer/lifestyles/lifestyle[name = \"Cyberzombie Lifestyle Addition\"]");

                    if (objXmlLifestyle != null)
                    {
                        Lifestyle objLifestyle = new Lifestyle(this);
                        objLifestyle.Create(objXmlLifestyle);
                        await Lifestyles.AddAsync(objLifestyle, token).ConfigureAwait(false);
                    }
                }

                // Change the MetatypeCategory to Cyberzombie.
                MetatypeCategory = "Cyberzombie";

                // Gain access to Critter Powers.
                CritterEnabled = true;

                // Gain the Dual Natured Critter Power if it does not yet exist.
                if (CritterPowers.All(x => x.Name != "Dual Natured"))
                {
                    XmlNode objXmlPowerNode =
                        (await LoadDataAsync("critterpowers.xml", token: token).ConfigureAwait(false)).SelectSingleNode(
                            "/chummer/powers/power[name = \"Dual Natured\"]");

                    if (objXmlPowerNode != null)
                    {
                        CritterPower objCritterPower = new CritterPower(this);
                        objCritterPower.Create(objXmlPowerNode);
                        await CritterPowers.AddAsync(objCritterPower, token).ConfigureAwait(false);
                    }
                }

                // Gain the Immunity (Normal Weapons) Critter Power if it does not yet exist.
                if (!CritterPowers.Any(x => x.Name == "Immunity" && x.Extra == "Normal Weapons"))
                {
                    XmlNode objXmlPowerNode =
                        (await LoadDataAsync("critterpowers.xml", token: token).ConfigureAwait(false)).SelectSingleNode(
                            "/chummer/powers/power[name = \"Immunity\"]");

                    if (objXmlPowerNode != null)
                    {
                        CritterPower objCritterPower = new CritterPower(this);
                        objCritterPower.Create(objXmlPowerNode, 0, "Normal Weapons");
                        await CritterPowers.AddAsync(objCritterPower, token).ConfigureAwait(false);
                    }
                }

                return true;
            }
        }

        #endregion Special Methods
    }
}
