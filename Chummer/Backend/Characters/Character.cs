/*  This file is part of Chummer5a.
 *
 *  Chummer5a is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  Chummer5a is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with Chummer5a.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  You can obtain the full source code for Chummer5a at
 *  https://github.com/chummer5a/chummer5a
 */
using Chummer.Annotations;
using Chummer.Backend.Attributes;
using Chummer.Backend.Equipment;
using Chummer.Backend.Skills;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Xml;
using System.Xml.XPath;
using Chummer.Backend.Uniques;
using System.Xml.Serialization;
using System.Runtime.Serialization;
using System.Threading;
using Chummer.Plugins;
using Microsoft.ApplicationInsights;
using Newtonsoft.Json;
using NLog;
using Application = System.Windows.Forms.Application;

namespace Chummer
{
    /// <summary>
    /// Class that holds all of the information that makes up a complete Character.
    /// </summary>
    [DebuggerDisplay("{CharacterName} ({FileName})")]
    public sealed class Character : INotifyMultiplePropertyChanged, IHasMugshots, IHasName, IHasSource, IHasXmlDataNode, IHasLockObject
    {
        private static readonly TelemetryClient TelemetryClient = new TelemetryClient();
        private static Logger Log { get; } = LogManager.GetCurrentClassLogger();
        private XmlNode _oldSkillsBackup;
        private XmlNode _oldSkillGroupBackup;
        private string _strFileName = string.Empty;
        private string _strSettingsKey = GlobalSettings.DefaultCharacterSetting;
        private DateTime _dateFileLastWriteTime = DateTime.MinValue;
        private bool _blnIgnoreRules;
        private int _intKarma;
        private int _intTotalKarma;
        private int _intStreetCred;
        private int _intNotoriety;
        private int _intPublicAwareness;
        private int _intBurntStreetCred;
        private decimal _decNuyen;
        private decimal _decStolenNuyen;
        private decimal _decStartingNuyen;
        private decimal _decEssenceAtSpecialStart = decimal.MinValue;
        private int _intSpecial;
        private int _intTotalSpecial;
        private int _intAttributes;
        private int _intTotalAttributes;
        private int _intFreeSpells;
        private int _intCFPLimit;
        private int _intAINormalProgramLimit;
        private int _intAIAdvancedProgramLimit;
        private int _intCachedContactPoints = int.MinValue;
        private int _intContactPointsUsed;
        private int _intCachedRedlinerBonus = int.MinValue;
        private int _intCurrentCounterspellingDice;
        private int _intCurrentLiftCarryHits;
        private int _intEdgeUsed;
        private int _intBoundSpiritLimit = int.MinValue;
        private int _intRegisteredSpriteLimit = int.MinValue;
        private decimal _decCachedBaseCarryLimit = decimal.MinValue;
        private decimal _decCachedBaseLiftLimit = decimal.MinValue;
        private decimal _decCachedTotalCarriedWeight = decimal.MinValue;
        private decimal _decCachedEncumbranceInterval = decimal.MinValue;

        // General character info.
        private string _strName = string.Empty;
        private readonly ThreadSafeList<Image> _lstMugshots = new ThreadSafeList<Image>(3);
        private int _intMainMugshotIndex = -1;
        private string _strGender = string.Empty;
        private string _strAge = string.Empty;
        private string _strEyes = string.Empty;
        private string _strHeight = string.Empty;
        private string _strWeight = string.Empty;
        private string _strSkin = string.Empty;
        private string _strHair = string.Empty;
        private string _strDescription = string.Empty;
        private string _strBackground = string.Empty;
        private string _strConcept = string.Empty;
        private string _strNotes = string.Empty;
        private string _strAlias = string.Empty;
        private string _strPlayerName = string.Empty;
        private string _strGameNotes = string.Empty;
        private string _strPrimaryArm = "Right";

        public static readonly ReadOnlyCollection<string> LimbStrings = Array.AsReadOnly(new[]
            {"skull", "torso", "arm", "leg"});

        // AI Home Node

        // Active Commlink

        // If true, the Character creation has been finalized and is maintained through Karma.
        private bool _blnCreated;

        // Build Points
        private decimal _decNuyenBP;

        // Metatype Information.
        private string _strMetatype = "Human";
        private Guid _guiMetatype = Guid.Empty;
        private string _strMetavariant = string.Empty;
        private Guid _guiMetavariant = Guid.Empty;
        private string _strMetatypeCategory = "Metahuman";
        private string _strMovement = string.Empty;
        private string _strWalk = string.Empty;
        private string _strRun = string.Empty;
        private string _strSprint = string.Empty;
        private string _strWalkAlt = string.Empty;
        private string _strRunAlt = string.Empty;
        private string _strSprintAlt = string.Empty;
        private int _intMetatypeBP;
        private string _strSource;
        private string _strPage;
        private int _intInitiativeDice = 1;

        // Special Flags.

        private bool _blnAdeptEnabled;
        private bool _blnMagicianEnabled;
        private bool _blnTechnomancerEnabled;
        private bool _blnAdvancedProgramsEnabled;
        private bool _blnCyberwareDisabled;
        private bool _blnInitiationDisabled;
        private bool _blnCritterEnabled;
        private bool _blnIsCritter;
        private bool _blnPossessed;
        private decimal _decPrototypeTranshuman;
        private bool _blnMAGEnabled;
        private bool _blnRESEnabled;
        private bool _blnDEPEnabled;
        private bool _blnGroupMember;
        private string _strGroupName = string.Empty;
        private string _strGroupNotes = string.Empty;
        private int _intInitiateGrade;
        private int _intSubmersionGrade;
        private bool _blnPsycheActive;

        // Pseudo-Attributes use for Mystic Adepts.
        private int _intMAGMagician;
        private int _intMAGAdept;

        // Magic Tradition.
        private Tradition _objTradition;

        // Condition Monitor Progress.
        private int _intPhysicalCMFilled;
        private int _intStunCMFilled;

        // Spirit Reputation
        private int _intBaseAstralReputation;
        private int _intBaseWildReputation;

        // Priority Selections.
        private string _strPriorityMetatype = "A";
        private string _strPriorityAttributes = "B";
        private string _strPrioritySpecial = "C";
        private string _strPrioritySkills = "D";
        private string _strPriorityResources = "E";
        private string _strPriorityTalent = string.Empty;
        private readonly ThreadSafeList<string> _lstPrioritySkills = new ThreadSafeList<string>(3);

        // Lists.
        private readonly ThreadSafeObservableCollection<Improvement> _lstImprovements = new ThreadSafeObservableCollection<Improvement>();

        private readonly ThreadSafeObservableCollection<MentorSpirit>
            _lstMentorSpirits = new ThreadSafeObservableCollection<MentorSpirit>();

        private readonly ThreadSafeObservableCollection<Contact> _lstContacts = new ThreadSafeObservableCollection<Contact>();
        private readonly ThreadSafeObservableCollection<Spirit> _lstSpirits = new ThreadSafeObservableCollection<Spirit>();
        private readonly ThreadSafeObservableCollection<Spell> _lstSpells = new ThreadSafeObservableCollection<Spell>();

        private readonly ThreadSafeObservableCollection<SustainedObject> _lstSustainedObjects = new ThreadSafeObservableCollection<SustainedObject>();

        private readonly ThreadSafeList<Focus> _lstFoci = new ThreadSafeList<Focus>(5);
        private readonly ThreadSafeList<StackedFocus> _lstStackedFoci = new ThreadSafeList<StackedFocus>(5);
        private readonly ThreadSafeBindingList<Power> _lstPowers = new ThreadSafeBindingList<Power>();
        private readonly ThreadSafeObservableCollection<ComplexForm> _lstComplexForms = new ThreadSafeObservableCollection<ComplexForm>();
        private readonly ThreadSafeObservableCollection<AIProgram> _lstAIPrograms = new ThreadSafeObservableCollection<AIProgram>();
        private readonly ThreadSafeObservableCollection<MartialArt> _lstMartialArts = new ThreadSafeObservableCollection<MartialArt>();

        private readonly ThreadSafeObservableCollection<LimitModifier> _lstLimitModifiers =
            new ThreadSafeObservableCollection<LimitModifier>();

        private readonly ThreadSafeObservableCollection<Armor> _lstArmor = new ThreadSafeObservableCollection<Armor>();

        private readonly ThreadSafeObservableCollection<Cyberware> _lstCyberware = new ThreadSafeObservableCollection<Cyberware>();

        private readonly ThreadSafeObservableCollection<Weapon> _lstWeapons = new ThreadSafeObservableCollection<Weapon>();
        private readonly ThreadSafeObservableCollection<Quality> _lstQualities = new ThreadSafeObservableCollection<Quality>();
        private readonly ThreadSafeObservableCollection<Lifestyle> _lstLifestyles = new ThreadSafeObservableCollection<Lifestyle>();
        private readonly ThreadSafeObservableCollection<Gear> _lstGear = new ThreadSafeObservableCollection<Gear>();
        private readonly ThreadSafeObservableCollection<Vehicle> _lstVehicles = new ThreadSafeObservableCollection<Vehicle>();
        private readonly ThreadSafeObservableCollection<Metamagic> _lstMetamagics = new ThreadSafeObservableCollection<Metamagic>();
        private readonly ThreadSafeObservableCollection<Art> _lstArts = new ThreadSafeObservableCollection<Art>();
        private readonly ThreadSafeObservableCollection<Enhancement> _lstEnhancements = new ThreadSafeObservableCollection<Enhancement>();

        private readonly ThreadSafeObservableCollection<ExpenseLogEntry> _lstExpenseLog =
            new ThreadSafeObservableCollection<ExpenseLogEntry>();

        private readonly ThreadSafeObservableCollection<CritterPower>
            _lstCritterPowers = new ThreadSafeObservableCollection<CritterPower>();

        private readonly ThreadSafeObservableCollection<InitiationGrade> _lstInitiationGrades =
            new ThreadSafeObservableCollection<InitiationGrade>();

        private readonly ThreadSafeObservableCollection<Location> _lstGearLocations = new ThreadSafeObservableCollection<Location>();
        private readonly ThreadSafeObservableCollection<Location> _lstArmorLocations = new ThreadSafeObservableCollection<Location>();

        private readonly ThreadSafeObservableCollection<Location> _lstVehicleLocations = new ThreadSafeObservableCollection<Location>();

        private readonly ThreadSafeObservableCollection<Location> _lstWeaponLocations = new ThreadSafeObservableCollection<Location>();
        private readonly ThreadSafeObservableCollection<string> _lstImprovementGroups = new ThreadSafeObservableCollection<string>();
        private readonly ThreadSafeBindingList<CalendarWeek> _lstCalendar = new ThreadSafeBindingList<CalendarWeek>();

        private readonly ThreadSafeObservableCollection<Drug> _lstDrugs = new ThreadSafeObservableCollection<Drug>();

        private SortedDictionary<decimal, Tuple<string, string>> _dicAvailabilityMap;
        //private readonly List<LifeModule> _lstLifeModules = new List<LifeModule>(10);
        private readonly ThreadSafeList<string> _lstInternalIdsNeedingReapplyImprovements = new ThreadSafeList<string>(1);

        // Character Version
        private string _strVersionCreated = Application.ProductVersion.FastEscapeOnceFromStart("0.0.");
        private Version _verSavedVersion = new Version();

        public AsyncFriendlyReaderWriterLock LockObject { get; } = new AsyncFriendlyReaderWriterLock();

        private readonly LockingOrderedSet<Func<Character, bool>> _setDoOnSaveCompleted = new LockingOrderedSet<Func<Character, bool>>();
        private readonly LockingOrderedSet<Func<Character, CancellationToken, Task<bool>>> _setDoOnSaveCompletedAsync = new LockingOrderedSet<Func<Character, CancellationToken, Task<bool>>>();

        /// <summary>
        /// Set of unique methods to run after the character's Save() method is otherwise finished.
        /// Input is the character in question, output is if the code resolved without errors.
        /// </summary>
        [JsonIgnore]
        [XmlIgnore]
        [IgnoreDataMember]
        public LockingOrderedSet<Func<Character, bool>> DoOnSaveCompleted
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _setDoOnSaveCompleted;
            }
        }

        /// <summary>
        /// Set of unique async methods to run after the character's Save() method is otherwise finished.
        /// Input is the character in question, output is if the code resolved without errors.
        /// </summary>
        [JsonIgnore]
        [XmlIgnore]
        [IgnoreDataMember]
        public LockingOrderedSet<Func<Character, CancellationToken, Task<bool>>> DoOnSaveCompletedAsync
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _setDoOnSaveCompletedAsync;
            }
        }

        #region Initialization, Save, Load, Print, and Reset Methods

        /// <summary>
        /// Character.
        /// </summary>
        public Character()
        {
            if (Utils.IsDesignerMode || Utils.IsRunningInVisualStudio)
                _objSettings = new CharacterSettings(); // Need this because ExpenseCharts is WPF and needs a Character in design mode.
            else if (!SettingsManager.LoadedCharacterSettings.TryGetValue(GlobalSettings.DefaultCharacterSetting, out _objSettings)
                     && !SettingsManager.LoadedCharacterSettings.TryGetValue(GlobalSettings.DefaultCharacterSettingDefaultValue, out _objSettings))
                _objSettings = SettingsManager.LoadedCharacterSettings.Values.First();

            Settings.PropertyChanged += OptionsOnPropertyChanged;
            _objAttributeSection = new AttributeSection(this);
            AttributeSection.Reset(true);
            AttributeSection.PropertyChanged += AttributeSectionOnPropertyChanged;

            _objSkillsSection = new SkillsSection(this);
            SkillsSection.Reset();

            _lstCyberware.CollectionChanged += CyberwareOnCollectionChanged;
            _lstArmor.CollectionChanged += ArmorOnCollectionChanged;
            _lstWeapons.CollectionChanged += WeaponsOnCollectionChanged;
            _lstGear.CollectionChanged += GearOnCollectionChanged;
            _lstContacts.CollectionChanged += ContactsOnCollectionChanged;
            _lstExpenseLog.CollectionChanged += ExpenseLogOnCollectionChanged;
            _lstMentorSpirits.CollectionChanged += MentorSpiritsOnCollectionChanged;
            _lstPowers.ListChanged += PowersOnListChanged;
            _lstPowers.BeforeRemove += PowersOnBeforeRemove;
            _lstQualities.CollectionChanged += QualitiesCollectionChanged;
            _lstMartialArts.CollectionChanged += MartialArtsOnCollectionChanged;
            _lstMetamagics.CollectionChanged += MetamagicsOnCollectionChanged;
            _lstSpells.CollectionChanged += SustainableOnCollectionChanged;
            _lstComplexForms.CollectionChanged += SustainableOnCollectionChanged;
            _lstCritterPowers.CollectionChanged += SustainableOnCollectionChanged;
            _lstSustainedObjects.CollectionChanged += SustainedObjectsOnCollectionChanged;
            _lstInitiationGrades.CollectionChanged += InitiationGradesOnCollectionChanged;
            _objTradition = new Tradition(this);
        }

        private bool _blnClearingInitiations;
        private async void InitiationGradesOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (_blnClearingInitiations || IsLoading)
                return;
            switch (e.Action)
            {
                case NotifyCollectionChangedAction.Add:
                {
                    int intAddSubmersion = 0;
                    int intAddInitiation = 0;

                    foreach (InitiationGrade objItem in e.NewItems)
                    {
                        if (objItem.Technomancer)
                            ++intAddSubmersion;
                        else
                            ++intAddInitiation;
                    }

                    SubmersionGrade += intAddSubmersion;
                    InitiateGrade += intAddInitiation;
                    break;
                }
                case NotifyCollectionChangedAction.Remove:
                {
                    int intRemoveSubmersion = 0;
                    int intRemoveInitiation = 0;

                    foreach (InitiationGrade objItem in e.OldItems)
                    {
                        if (objItem.Technomancer)
                            ++intRemoveSubmersion;
                        else
                            ++intRemoveInitiation;
                    }

                    if (SubmersionGrade < intRemoveSubmersion)
                        SubmersionGrade = 0;
                    else
                        SubmersionGrade -= intRemoveSubmersion;
                    if (InitiateGrade < intRemoveInitiation)
                        InitiateGrade = 0;
                    else
                        InitiateGrade -= intRemoveInitiation;
                    break;
                }
                case NotifyCollectionChangedAction.Replace:
                {
                    int intAddSubmersion = 0;
                    int intAddInitiation = 0;

                    foreach (InitiationGrade objItem in e.OldItems)
                    {
                        if (objItem.Technomancer)
                            --intAddSubmersion;
                        else
                            --intAddInitiation;
                    }

                    foreach (InitiationGrade objItem in e.NewItems)
                    {
                        if (objItem.Technomancer)
                            ++intAddSubmersion;
                        else
                            ++intAddInitiation;
                    }

                    if (SubmersionGrade + intAddSubmersion < 0)
                        SubmersionGrade = 0;
                    else
                        SubmersionGrade += intAddSubmersion;
                    if (InitiateGrade + intAddInitiation < 0)
                        InitiateGrade = 0;
                    else
                        InitiateGrade += intAddInitiation;
                    break;
                }
                case NotifyCollectionChangedAction.Move:
                    return;
                case NotifyCollectionChangedAction.Reset:
                {
                    int intSubmersion = 0;
                    int intInitiation = 0;

                    using (await EnterReadLock.EnterAsync(LockObject))
                    {
                        foreach (InitiationGrade objItem in InitiationGrades)
                        {
                            if (objItem.Technomancer)
                                ++intSubmersion;
                            else
                                ++intInitiation;
                        }

                        SubmersionGrade = intSubmersion;
                        InitiateGrade = intInitiation;
                    }

                    break;
                }
            }
        }

        private async void SustainableOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (SustainedCollection.Count == 0)
                return;
            switch (e.Action)
            {
                case NotifyCollectionChangedAction.Add:
                    break;
                case NotifyCollectionChangedAction.Remove:
                    foreach (IHasInternalId objItem in e.OldItems)
                    {
                        await SustainedCollection.RemoveAllAsync(x => ReferenceEquals(x.LinkedObject, objItem));
                    }
                    break;
                case NotifyCollectionChangedAction.Replace:
                    foreach (IHasInternalId objItem in e.OldItems)
                    {
                        await SustainedCollection.RemoveAllAsync(x => ReferenceEquals(x.LinkedObject, objItem));
                    }
                    break;
                case NotifyCollectionChangedAction.Move:
                    break;
                case NotifyCollectionChangedAction.Reset:
                    await SustainedCollection.RemoveAllAsync(async x =>
                                                                 !await Spells.AnyAsync(
                                                                     y => ReferenceEquals(y, x.LinkedObject))
                                                                 && !await ComplexForms.AnyAsync(
                                                                     y => ReferenceEquals(y, x.LinkedObject)) &&
                                                                 !await CritterPowers.AnyAsync(
                                                                     y => ReferenceEquals(y, x.LinkedObject)));
                    break;
            }
        }

        public XmlNode GetNode(bool blnReturnMetatypeOnly, string strLanguage = "", CancellationToken token = default)
        {
            return GetNodeCoreAsync(true, blnReturnMetatypeOnly, strLanguage, token).ConfigureAwait(false).GetAwaiter().GetResult();
        }

        public Task<XmlNode> GetNodeAsync(bool blnReturnMetatypeOnly, string strLanguage = "", CancellationToken token = default)
        {
            return GetNodeCoreAsync(false, blnReturnMetatypeOnly, strLanguage, token);
        }

        public Task<XmlNode> GetNodeCoreAsync(bool blnSync, string strLanguage, CancellationToken token = default)
        {
            return GetNodeCoreAsync(blnSync, false, strLanguage, token);
        }

        public async Task<XmlNode> GetNodeCoreAsync(bool blnSync, bool blnReturnMetatypeOnly, string strLanguage, CancellationToken token = default)
        {
            // ReSharper disable once MethodHasAsyncOverload
            using (blnSync ? EnterReadLock.Enter(LockObject, token) : await EnterReadLock.EnterAsync(LockObject, token))
            {
                string strFile = IsCritter ? "critters.xml" : "metatypes.xml";
                XmlDocument xmlDoc = blnSync
                    // ReSharper disable once MethodHasAsyncOverload
                    ? LoadData(strFile, strLanguage, token: token)
                    : await LoadDataAsync(strFile, strLanguage, token: token);
                XmlNode xmlMetatypeNode = xmlDoc.SelectSingleNode(MetatypeGuid == Guid.Empty
                    ? "/chummer/metatypes/metatype[name = "
                      + Metatype.CleanXPath() + ']'
                    : "/chummer/metatypes/metatype[id = " +
                      MetatypeGuid
                          .ToString(
                              "D", GlobalSettings.InvariantCultureInfo)
                          .CleanXPath() + ']');
                if (blnReturnMetatypeOnly)
                    return xmlMetatypeNode;
                if (MetavariantGuid == Guid.Empty || string.IsNullOrEmpty(Metavariant) || xmlMetatypeNode == null)
                    return xmlMetatypeNode;
                XmlNode xmlMetavariantNode = xmlMetatypeNode.SelectSingleNode(MetavariantGuid == Guid.Empty
                    ? "metavariants/metavariant[name = "
                      + Metavariant.CleanXPath() + ']'
                    : "metavariants/metavariant[id = " +
                      MetavariantGuid
                          .ToString(
                              "D",
                              GlobalSettings
                                  .InvariantCultureInfo)
                          .CleanXPath() + ']');
                if (xmlMetavariantNode == null && MetavariantGuid != Guid.Empty)
                {
                    xmlMetavariantNode =
                        xmlMetatypeNode.SelectSingleNode("metavariants/metavariant[name = " + Metavariant.CleanXPath() +
                                                         ']');
                }

                return xmlMetavariantNode ?? xmlMetatypeNode;
            }
        }

        public XPathNavigator GetNodeXPath(bool blnReturnMetatypeOnly, string strLanguage = "", CancellationToken token = default)
        {
            return GetNodeXPathCoreAsync(true, blnReturnMetatypeOnly, strLanguage, token).ConfigureAwait(false).GetAwaiter().GetResult();
        }

        public Task<XPathNavigator> GetNodeXPathAsync(bool blnReturnMetatypeOnly, string strLanguage = "", CancellationToken token = default)
        {
            return GetNodeXPathCoreAsync(false, blnReturnMetatypeOnly, strLanguage, token);
        }

        public Task<XPathNavigator> GetNodeXPathCoreAsync(bool blnSync, string strLanguage, CancellationToken token = default)
        {
            return GetNodeXPathCoreAsync(blnSync, false, strLanguage, token);
        }

        public async Task<XPathNavigator> GetNodeXPathCoreAsync(bool blnSync, bool blnReturnMetatypeOnly, string strLanguage, CancellationToken token = default)
        {
            // ReSharper disable once MethodHasAsyncOverload
            using (blnSync ? EnterReadLock.Enter(LockObject, token) : await EnterReadLock.EnterAsync(LockObject, token))
            {
                string strFile = IsCritter ? "critters.xml" : "metatypes.xml";
                XPathNavigator xmlDoc = blnSync
                    // ReSharper disable once MethodHasAsyncOverload
                    ? LoadDataXPath(strFile, strLanguage, token: token)
                    : await LoadDataXPathAsync(strFile, strLanguage, token: token);
                XPathNavigator xmlMetatypeNode = xmlDoc.SelectSingleNode(MetatypeGuid == Guid.Empty
                    ? "/chummer/metatypes/metatype[name = " + Metatype.CleanXPath() + ']'
                    : "/chummer/metatypes/metatype[id = " +
                      MetatypeGuid.ToString("D", GlobalSettings.InvariantCultureInfo).CleanXPath() + ']');
                if (blnReturnMetatypeOnly)
                    return xmlMetatypeNode;
                if (MetavariantGuid == Guid.Empty || string.IsNullOrEmpty(Metavariant) || xmlMetatypeNode == null)
                    return xmlMetatypeNode;
                XPathNavigator xmlMetavariantNode = xmlMetatypeNode.SelectSingleNode(MetavariantGuid == Guid.Empty
                    ? "metavariants/metavariant[name = " + Metavariant.CleanXPath() + ']'
                    : "metavariants/metavariant[id = " +
                      MetavariantGuid.ToString("D", GlobalSettings.InvariantCultureInfo).CleanXPath() + ']');
                if (xmlMetavariantNode == null && MetavariantGuid != Guid.Empty)
                {
                    xmlMetavariantNode =
                        xmlMetatypeNode.SelectSingleNode("metavariants/metavariant[name = " + Metavariant.CleanXPath() +
                                                         ']');
                }

                return xmlMetavariantNode ?? xmlMetatypeNode;
            }
        }

        public void RefreshAttributeBindings()
        {
            using (LockObject.EnterWriteLock())
            {
                // First remove all existing bindings
                foreach (CharacterAttrib objAttribute in AttributeSection.Attributes)
                {
                    switch (objAttribute.Abbrev)
                    {
                        case "BOD":
                            objAttribute.PropertyChanged -= RefreshBODDependentProperties;
                            break;
                        case "AGI":
                            objAttribute.PropertyChanged -= RefreshAGIDependentProperties;
                            break;
                        case "REA":
                            objAttribute.PropertyChanged -= RefreshREADependentProperties;
                            break;
                        case "STR":
                            objAttribute.PropertyChanged -= RefreshSTRDependentProperties;
                            break;
                        case "CHA":
                            objAttribute.PropertyChanged -= RefreshCHADependentProperties;
                            break;
                        case "INT":
                            objAttribute.PropertyChanged -= RefreshINTDependentProperties;
                            break;
                        case "LOG":
                            objAttribute.PropertyChanged -= RefreshLOGDependentProperties;
                            break;
                        case "WIL":
                            objAttribute.PropertyChanged -= RefreshWILDependentProperties;
                            break;
                        case "EDG":
                            objAttribute.PropertyChanged -= RefreshEDGDependentProperties;
                            break;
                        case "MAG":
                            objAttribute.PropertyChanged -= RefreshMAGDependentProperties;
                            break;
                        case "MAGAdept":
                            objAttribute.PropertyChanged -= RefreshMAGAdeptDependentProperties;
                            break;
                        case "RES":
                            objAttribute.PropertyChanged -= RefreshRESDependentProperties;
                            break;
                        case "DEP":
                            objAttribute.PropertyChanged -= RefreshDEPDependentProperties;
                            break;
                        case "ESS":
                            objAttribute.PropertyChanged -= RefreshESSDependentProperties;
                            break;
                    }
                }

                BOD.PropertyChanged += RefreshBODDependentProperties;
                AGI.PropertyChanged += RefreshAGIDependentProperties;
                REA.PropertyChanged += RefreshREADependentProperties;
                STR.PropertyChanged += RefreshSTRDependentProperties;
                CHA.PropertyChanged += RefreshCHADependentProperties;
                INT.PropertyChanged += RefreshINTDependentProperties;
                LOG.PropertyChanged += RefreshLOGDependentProperties;
                WIL.PropertyChanged += RefreshWILDependentProperties;
                EDG.PropertyChanged += RefreshEDGDependentProperties;
                MAG.PropertyChanged += RefreshMAGDependentProperties;
                RES.PropertyChanged += RefreshRESDependentProperties;
                DEP.PropertyChanged += RefreshDEPDependentProperties;
                ESS.PropertyChanged += RefreshESSDependentProperties;
                // This needs to be explicitly set because a MAGAdept call could redirect to MAG, and we don't want that
                AttributeSection.GetAttributeByName("MAGAdept").PropertyChanged += RefreshMAGAdeptDependentProperties;
            }
        }

        private async void OptionsOnPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            await DoOptionsOnPropertyChanged(sender, e);
        }

        private async Task DoOptionsOnPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterSettings.UseCalculatedPublicAwareness):
                    OnPropertyChanged(nameof(CalculatedPublicAwareness));
                    break;
                case nameof(CharacterSettings.SpiritForceBasedOnTotalMAG):
                    OnPropertyChanged(nameof(MaxSpiritForce));
                    break;
                case nameof(CharacterSettings.CyberlegMovement):
                    OnPropertyChanged(nameof(Movement));
                    break;
                case nameof(CharacterSettings.AllowInitiationInCreateMode):
                    OnPropertyChanged(nameof(AddInitiationsAllowed));
                    break;
                case nameof(CharacterSettings.MysAdeptAllowPpCareer):
                    OnPropertyChanged(nameof(MysAdeptAllowPPCareer));
                    break;
                case nameof(CharacterSettings.MysAdeptSecondMAGAttribute):
                    this.OnMultiplePropertyChanged(nameof(UseMysticAdeptPPs), nameof(AllowAdeptWayPowerDiscount));
                    break;
                case nameof(CharacterSettings.ContactPointsExpression):
                    OnPropertyChanged(nameof(ContactPoints));
                    break;
                case nameof(CharacterSettings.SpecialKarmaCostBasedOnShownValue):
                    await RefreshEssenceLossImprovementsAsync();
                    break;
                case nameof(CharacterSettings.NuyenFormat):
                    this.OnMultiplePropertyChanged(nameof(DisplayNuyen), nameof(DisplayCareerNuyen),
                                                   nameof(DisplayStolenNuyen));
                    break;
                case nameof(CharacterSettings.WeightFormat):
                    this.OnMultiplePropertyChanged(nameof(LiftAndCarryLimits), nameof(DisplayTotalCarriedWeight));
                    break;
                case nameof(CharacterSettings.EssenceFormat):
                case nameof(CharacterSettings.DontRoundEssenceInternally):
                    this.OnMultiplePropertyChanged(nameof(PrototypeTranshumanEssenceUsed), nameof(BiowareEssence),
                                                   nameof(CyberwareEssence), nameof(EssenceHole));
                    break;
                case nameof(CharacterSettings.NuyenMaximumBP):
                case nameof(CharacterSettings.UnrestrictedNuyen):
                    OnPropertyChanged(nameof(TotalNuyenMaximumBP));
                    break;
                case nameof(CharacterSettings.KarmaMysticAdeptPowerPoint):
                    OnPropertyChanged(nameof(CanAffordCareerPP));
                    break;
                case nameof(CharacterSettings.BuildMethod):
                    OnPropertyChanged(nameof(EffectiveBuildMethod));
                    break;
                case nameof(CharacterSettings.AutomaticBackstory):
                    OnPropertyChanged(nameof(EnableAutomaticStoryButton));
                    break;
                case nameof(CharacterSettings.ChargenKarmaToNuyenExpression):
                    OnPropertyChanged(nameof(TotalStartingNuyen));
                    break;
                case nameof(CharacterSettings.LimbCount):
                    OnPropertyChanged(nameof(LimbCount));
                    break;
                case nameof(CharacterSettings.MetatypeCostsKarmaMultiplier):
                    OnPropertyChanged(nameof(DisplayMetatypeBP));
                    break;
                case nameof(CharacterSettings.RedlinerExcludes):
                    OnPropertyChanged(nameof(RedlinerBonus));
                    break;
                case nameof(CharacterSettings.NoArmorEncumbrance):
                    OnPropertyChanged(nameof(ArmorEncumbrance));
                    break;
                case nameof(CharacterSettings.KarmaQuality):
                case nameof(CharacterSettings.QualityKarmaLimit):
                    this.OnMultiplePropertyChanged(nameof(PositiveQualityLimitKarma), nameof(PositiveQualityKarma),
                                                   nameof(NegativeQualityLimitKarma), nameof(NegativeQualityKarma));
                    break;
                case nameof(CharacterSettings.ExceedPositiveQualitiesCostDoubled):
                    this.OnMultiplePropertyChanged(nameof(PositiveQualityLimitKarma), nameof(PositiveQualityKarma));
                    break;
                case nameof(CharacterSettings.EnemyKarmaQualityLimit):
                case nameof(CharacterSettings.ExceedNegativeQualitiesNoBonus):
                    this.OnMultiplePropertyChanged(nameof(NegativeQualityLimitKarma), nameof(NegativeQualityKarma));
                    break;
                case nameof(CharacterSettings.EnableEnemyTracking):
                case nameof(CharacterSettings.KarmaEnemy):
                    OnPropertyChanged(nameof(EnemyKarma));
                    break;
                case nameof(CharacterSettings.DicePenaltySustaining):
                    OnPropertyChanged(nameof(SustainingPenalty));
                    break;
                case nameof(CharacterSettings.KarmaSpell):
                    using (await EnterReadLock.EnterAsync(LockObject))
                    {
                        if (FreeSpells > 0)
                            OnPropertyChanged(nameof(PositiveQualityKarma));
                    }
                    break;
                case nameof(CharacterSettings.MinInitiativeDice):
                    using (await EnterReadLock.EnterAsync(LockObject))
                    {
                        XPathNavigator objNode = await this.GetNodeXPathAsync();
                        if (objNode == null || await objNode.SelectSingleNodeAndCacheExpressionAsync("initiativedice") == null)
                        {
                            _intInitiativeDice = Settings.MinInitiativeDice;
                            OnPropertyChanged(nameof(InitiativeDice));
                        }
                    }
                    break;
                case nameof(CharacterSettings.MaxInitiativeDice):
                    OnPropertyChanged(nameof(InitiativeDice));
                    break;
                case nameof(CharacterSettings.MinAstralInitiativeDice):
                case nameof(CharacterSettings.MaxAstralInitiativeDice):
                    OnPropertyChanged(nameof(AstralInitiativeDice));
                    break;
                case nameof(CharacterSettings.MinColdSimInitiativeDice):
                case nameof(CharacterSettings.MaxColdSimInitiativeDice):
                    OnPropertyChanged(nameof(MatrixInitiativeColdDice));
                    break;
                case nameof(CharacterSettings.MinHotSimInitiativeDice):
                    using (await EnterReadLock.EnterAsync(LockObject))
                    {
                        if (IsAI)
                            this.OnMultiplePropertyChanged(nameof(MatrixInitiativeDice),
                                                           nameof(MatrixInitiativeHotDice));
                        else
                            OnPropertyChanged(nameof(MatrixInitiativeHotDice));
                    }
                    break;
                case nameof(CharacterSettings.MaxHotSimInitiativeDice):
                    OnPropertyChanged(nameof(MatrixInitiativeHotDice));
                    break;
                case nameof(CharacterSettings.LiftLimitExpression):
                    OnPropertyChanged(nameof(BaseLiftLimit));
                    break;
                case nameof(CharacterSettings.CarryLimitExpression):
                    OnPropertyChanged(nameof(BaseCarryLimit));
                    break;
                case nameof(CharacterSettings.EncumbranceIntervalExpression):
                    OnPropertyChanged(nameof(EncumbranceInterval));
                    break;
                case nameof(CharacterSettings.DoEncumbrancePenaltyPhysicalLimit):
                case nameof(CharacterSettings.DoEncumbrancePenaltyMovementSpeed):
                case nameof(CharacterSettings.DoEncumbrancePenaltyAgility):
                case nameof(CharacterSettings.DoEncumbrancePenaltyReaction):
                    OnPropertyChanged(nameof(Encumbrance));
                    break;
                case nameof(CharacterSettings.EncumbrancePenaltyPhysicalLimit):
                    if (Settings.DoEncumbrancePenaltyPhysicalLimit)
                        OnPropertyChanged(nameof(Encumbrance));
                    break;
                case nameof(CharacterSettings.EncumbrancePenaltyMovementSpeed):
                    if (Settings.DoEncumbrancePenaltyMovementSpeed)
                        OnPropertyChanged(nameof(Encumbrance));
                    break;
                case nameof(CharacterSettings.EncumbrancePenaltyAgility):
                    using (await EnterReadLock.EnterAsync(LockObject))
                    {
                        if (Settings.DoEncumbrancePenaltyAgility)
                            OnPropertyChanged(nameof(Encumbrance));
                    }
                    break;
                case nameof(CharacterSettings.EncumbrancePenaltyReaction):
                    using (await EnterReadLock.EnterAsync(LockObject))
                    {
                        if (Settings.DoEncumbrancePenaltyReaction)
                            OnPropertyChanged(nameof(Encumbrance));
                    }
                    break;
                case nameof(CharacterSettings.DoEncumbrancePenaltyWoundModifier):
                    this.OnMultiplePropertyChanged(nameof(WoundModifier), nameof(Encumbrance));
                    break;
                case nameof(CharacterSettings.EncumbrancePenaltyWoundModifier):
                    using (await EnterReadLock.EnterAsync(LockObject))
                    {
                        if (Settings.DoEncumbrancePenaltyWoundModifier)
                            this.OnMultiplePropertyChanged(nameof(WoundModifier), nameof(Encumbrance));
                    }
                    break;
            }

            await Utils.RunOnMainThreadAsync(() => SettingsPropertyChanged?.Invoke(sender, e)).ConfigureAwait(false);
        }

        private void AttributeSectionOnPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == nameof(AttributeSection.AttributeCategory))
            {
                this.OnMultiplePropertyChanged(nameof(CurrentWalkingRateString),
                                               nameof(CurrentRunningRateString),
                                               nameof(CurrentSprintingRateString));
            }
        }

        private void ContactsOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (e.Action != NotifyCollectionChangedAction.Move)
            {
                this.OnMultiplePropertyChanged(nameof(NegativeQualityKarma),
                                               nameof(NegativeQualityLimitKarma),
                                               nameof(PositiveQualityLimitKarma),
                                               nameof(PositiveQualityKarma),
                                               nameof(EnemyKarma));
            }
        }

        private async void PowersOnBeforeRemove(object sender, RemovingOldEventArgs e)
        {
            using (await EnterReadLock.EnterAsync(LockObject))
            {
                if (Powers[e.OldIndex].AdeptWayDiscountEnabled)
                    this.OnMultiplePropertyChanged(nameof(AnyPowerAdeptWayDiscountEnabled),
                                                   nameof(AllowAdeptWayPowerDiscount));
            }
        }

        private async void PowersOnListChanged(object sender, ListChangedEventArgs e)
        {
            using (new FetchSafelyFromPool<Dictionary<INotifyMultiplePropertyChanged, HashSet<string>>>(
                       Utils.DictionaryForMultiplePropertyChangedPool,
                       out Dictionary<INotifyMultiplePropertyChanged, HashSet<string>> dicChangedProperties))
            {
                try
                {
                    switch (e.ListChangedType)
                    {
                        case ListChangedType.Reset:
                        {
                            HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                            strTemp.Add(nameof(PowerPointsUsed));
                            strTemp.Add(nameof(AnyPowerAdeptWayDiscountEnabled));
                            strTemp.Add(nameof(AllowAdeptWayPowerDiscount));
                            dicChangedProperties.Add(this, strTemp);
                        }
                            break;
                        case ListChangedType.ItemAdded:
                        {
                            HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                            strTemp.Add(nameof(PowerPointsUsed));
                            dicChangedProperties.Add(this, strTemp);
                            using (await EnterReadLock.EnterAsync(LockObject))
                            {
                                Power objNewPower = Powers[e.NewIndex];
                                if (!IsLoading)
                                {
                                    // Needed in order to properly process named sources where
                                    // the tooltip was built before the object was added to the character
                                    foreach (Improvement objImprovement in Improvements)
                                    {
                                        if (objImprovement.SourceName != objNewPower.InternalId
                                            || !objImprovement.Enabled)
                                            continue;
                                        foreach ((INotifyMultiplePropertyChanged objItemToUpdate,
                                                  string strPropertyToUpdate) in
                                                 objImprovement.GetRelevantPropertyChangers())
                                        {
                                            if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                    out HashSet<string> setChangedProperties))
                                            {
                                                setChangedProperties = Utils.StringHashSetPool.Get();
                                                dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                            }

                                            setChangedProperties.Add(strPropertyToUpdate);
                                        }
                                    }
                                }

                                if (objNewPower.AdeptWayDiscountEnabled)
                                {
                                    strTemp.Add(nameof(AnyPowerAdeptWayDiscountEnabled));
                                    strTemp.Add(nameof(AllowAdeptWayPowerDiscount));
                                }
                            }
                        }
                            break;
                        case ListChangedType.ItemDeleted:
                        {
                            HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                            strTemp.Add(nameof(PowerPointsUsed));
                            dicChangedProperties.Add(this, strTemp);
                        }
                            break;
                        case ListChangedType.ItemChanged:
                        {
                            if (e.PropertyDescriptor == null)
                            {
                                break;
                            }

                            switch (e.PropertyDescriptor.Name)
                            {
                                case nameof(Power.AdeptWayDiscountEnabled):
                                {
                                    HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                                    strTemp.Add(nameof(AnyPowerAdeptWayDiscountEnabled));
                                    strTemp.Add(nameof(AllowAdeptWayPowerDiscount));
                                    dicChangedProperties.Add(this, strTemp);
                                    break;
                                }
                                case nameof(Power.DiscountedAdeptWay):
                                {
                                    HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                                    strTemp.Add(nameof(PowerPointsUsed));
                                    strTemp.Add(nameof(AnyPowerAdeptWayDiscountEnabled));
                                    strTemp.Add(nameof(AllowAdeptWayPowerDiscount));
                                    dicChangedProperties.Add(this, strTemp);
                                    using (await EnterReadLock.EnterAsync(LockObject))
                                    {
                                        foreach (Power objPower in Powers)
                                        {
                                            if (!dicChangedProperties.TryGetValue(objPower,
                                                    out HashSet<string> setChangedProperties))
                                            {
                                                setChangedProperties = Utils.StringHashSetPool.Get();
                                                dicChangedProperties.Add(objPower, setChangedProperties);
                                            }

                                            setChangedProperties.Add(nameof(Power.AdeptWayDiscountEnabled));
                                        }
                                    }

                                    break;
                                }
                                case nameof(Power.PowerPoints):
                                {
                                    HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                                    strTemp.Add(nameof(PowerPointsUsed));
                                    dicChangedProperties.Add(this, strTemp);
                                    break;
                                }
                            }
                        }
                            break;
                    }

                    foreach (KeyValuePair<INotifyMultiplePropertyChanged, HashSet<string>> kvpToProcess in dicChangedProperties)
                    {
                        kvpToProcess.Key.OnMultiplePropertyChanged(kvpToProcess.Value.ToList());
                    }
                }
                finally
                {
                    foreach (HashSet<string> setToReturn in dicChangedProperties.Values)
                        Utils.StringHashSetPool.Return(setToReturn);
                }
            }
        }

        private async void MentorSpiritsOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (IsLoading)
                return;
            List<MentorSpirit> lstImprovementSourcesToProcess = new List<MentorSpirit>(MentorSpirits.Count);

            switch (e.Action)
            {
                case NotifyCollectionChangedAction.Add:
                case NotifyCollectionChangedAction.Replace:
                    lstImprovementSourcesToProcess.AddRange(e.NewItems.Cast<MentorSpirit>());
                    break;
                case NotifyCollectionChangedAction.Move:
                    return;
                case NotifyCollectionChangedAction.Reset:
                    lstImprovementSourcesToProcess.AddRange(MentorSpirits);
                    break;
            }

            if (lstImprovementSourcesToProcess.Count == 0)
            {
                OnPropertyChanged(nameof(MentorSpirits));
                return;
            }

            using (new FetchSafelyFromPool<Dictionary<INotifyMultiplePropertyChanged, HashSet<string>>>(
                       Utils.DictionaryForMultiplePropertyChangedPool,
                       out Dictionary<INotifyMultiplePropertyChanged, HashSet<string>> dicChangedProperties))
            {
                try
                {
                    HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                    strTemp.Add(nameof(MentorSpirits));
                    dicChangedProperties.Add(this, strTemp);
                    using (await EnterReadLock.EnterAsync(LockObject))
                    {
                        foreach (MentorSpirit objNewItem in lstImprovementSourcesToProcess)
                        {
                            // Needed in order to properly process named sources where
                            // the tooltip was built before the object was added to the character
                            foreach (Improvement objImprovement in Improvements)
                            {
                                if (objImprovement.SourceName != objNewItem.InternalId || !objImprovement.Enabled)
                                    continue;
                                foreach ((INotifyMultiplePropertyChanged objItemToUpdate,
                                          string strPropertyToUpdate) in
                                         objImprovement.GetRelevantPropertyChangers())
                                {
                                    if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                                          out HashSet<string> setChangedProperties))
                                    {
                                        setChangedProperties = Utils.StringHashSetPool.Get();
                                        dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                    }

                                    setChangedProperties.Add(strPropertyToUpdate);
                                }
                            }
                        }
                    }

                    foreach (KeyValuePair<INotifyMultiplePropertyChanged, HashSet<string>> kvpToUpdate in
                             dicChangedProperties)
                    {
                        kvpToUpdate.Key.OnMultiplePropertyChanged(kvpToUpdate.Value.ToList());
                    }
                }
                finally
                {
                    foreach (HashSet<string> setToReturn in dicChangedProperties.Values)
                        Utils.StringHashSetPool.Return(setToReturn);
                }
            }
        }

        private async void QualitiesCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (IsLoading)
                return;
            List<Quality> lstImprovementSourcesToProcess = new List<Quality>(Qualities.Count);

            switch (e.Action)
            {
                case NotifyCollectionChangedAction.Add:
                case NotifyCollectionChangedAction.Replace:
                    lstImprovementSourcesToProcess.AddRange(e.NewItems.Cast<Quality>());
                    break;
                case NotifyCollectionChangedAction.Move:
                    return;
                case NotifyCollectionChangedAction.Reset:
                    lstImprovementSourcesToProcess.AddRange(Qualities);
                    break;
            }

            using (new FetchSafelyFromPool<Dictionary<INotifyMultiplePropertyChanged, HashSet<string>>>(
                       Utils.DictionaryForMultiplePropertyChangedPool,
                       out Dictionary<INotifyMultiplePropertyChanged, HashSet<string>> dicChangedProperties))
            {
                try
                {
                    HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                    strTemp.Add(nameof(Qualities));
                    dicChangedProperties.Add(this, strTemp);
                    using (await EnterReadLock.EnterAsync(LockObject))
                    {
                        foreach (Power objPower in Powers)
                        {
                            HashSet<string> strInnerTemp = Utils.StringHashSetPool.Get();
                            strInnerTemp.Add(nameof(Power.AdeptWayDiscountEnabled));
                            dicChangedProperties.Add(objPower, strInnerTemp);
                        }

                        if (lstImprovementSourcesToProcess.Count > 0)
                        {
                            foreach (Quality objNewItem in lstImprovementSourcesToProcess)
                            {
                                // Needed in order to properly process named sources where
                                // the tooltip was built before the object was added to the character
                                foreach (Improvement objImprovement in Improvements)
                                {
                                    if (objImprovement.SourceName != objNewItem.InternalId
                                        || !objImprovement.Enabled)
                                        continue;
                                    foreach ((INotifyMultiplePropertyChanged objItemToUpdate,
                                              string strPropertyToUpdate) in
                                             objImprovement.GetRelevantPropertyChangers())
                                    {
                                        if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                out HashSet<string> setChangedProperties))
                                        {
                                            setChangedProperties = Utils.StringHashSetPool.Get();
                                            dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                        }

                                        setChangedProperties.Add(strPropertyToUpdate);
                                    }
                                }
                            }
                        }
                    }

                    foreach (KeyValuePair<INotifyMultiplePropertyChanged, HashSet<string>> kvpToUpdate in
                             dicChangedProperties)
                    {
                        kvpToUpdate.Key.OnMultiplePropertyChanged(kvpToUpdate.Value.ToList());
                    }
                }
                finally
                {
                    foreach (HashSet<string> setToReturn in dicChangedProperties.Values)
                        Utils.StringHashSetPool.Return(setToReturn);
                }
            }
        }

        private async void MartialArtsOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (IsLoading)
                return;
            List<MartialArt> lstImprovementSourcesToProcess = new List<MartialArt>(MartialArts.Count);

            switch (e.Action)
            {
                case NotifyCollectionChangedAction.Add:
                case NotifyCollectionChangedAction.Replace:
                    lstImprovementSourcesToProcess.AddRange(e.NewItems.Cast<MartialArt>());
                    break;
                case NotifyCollectionChangedAction.Move:
                    return;
                case NotifyCollectionChangedAction.Reset:
                    lstImprovementSourcesToProcess.AddRange(MartialArts);
                    break;
            }

            if (lstImprovementSourcesToProcess.Count == 0)
            {
                OnPropertyChanged(nameof(MartialArts));
                return;
            }

            using (new FetchSafelyFromPool<Dictionary<INotifyMultiplePropertyChanged, HashSet<string>>>(
                       Utils.DictionaryForMultiplePropertyChangedPool,
                       out Dictionary<INotifyMultiplePropertyChanged, HashSet<string>> dicChangedProperties))
            {
                try
                {
                    HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                    strTemp.Add(nameof(MartialArts));
                    dicChangedProperties.Add(this, strTemp);
                    using (await EnterReadLock.EnterAsync(LockObject))
                    {
                        foreach (MartialArt objNewItem in lstImprovementSourcesToProcess)
                        {
                            // Needed in order to properly process named sources where
                            // the tooltip was built before the object was added to the character
                            foreach (Improvement objImprovement in Improvements)
                            {
                                if (objImprovement.SourceName != objNewItem.InternalId || !objImprovement.Enabled)
                                    continue;
                                foreach ((INotifyMultiplePropertyChanged objItemToUpdate,
                                          string strPropertyToUpdate) in
                                         objImprovement.GetRelevantPropertyChangers())
                                {
                                    if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                                          out HashSet<string> setChangedProperties))
                                    {
                                        setChangedProperties = Utils.StringHashSetPool.Get();
                                        dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                    }

                                    setChangedProperties.Add(strPropertyToUpdate);
                                }
                            }
                        }
                    }

                    foreach (KeyValuePair<INotifyMultiplePropertyChanged, HashSet<string>> kvpToUpdate in
                             dicChangedProperties)
                    {
                        kvpToUpdate.Key.OnMultiplePropertyChanged(kvpToUpdate.Value.ToList());
                    }
                }
                finally
                {
                    foreach (HashSet<string> setToReturn in dicChangedProperties.Values)
                        Utils.StringHashSetPool.Return(setToReturn);
                }
            }
        }

        private async void MetamagicsOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (IsLoading)
                return;
            List<Metamagic> lstImprovementSourcesToProcess = new List<Metamagic>(Metamagics.Count);

            switch (e.Action)
            {
                case NotifyCollectionChangedAction.Add:
                case NotifyCollectionChangedAction.Replace:
                    lstImprovementSourcesToProcess.AddRange(e.NewItems.Cast<Metamagic>());
                    break;
                case NotifyCollectionChangedAction.Move:
                    return;
                case NotifyCollectionChangedAction.Reset:
                    lstImprovementSourcesToProcess.AddRange(Metamagics);
                    break;
            }

            if (lstImprovementSourcesToProcess.Count == 0)
            {
                OnPropertyChanged(nameof(Metamagics));
                return;
            }

            using (new FetchSafelyFromPool<Dictionary<INotifyMultiplePropertyChanged, HashSet<string>>>(
                       Utils.DictionaryForMultiplePropertyChangedPool,
                       out Dictionary<INotifyMultiplePropertyChanged, HashSet<string>> dicChangedProperties))
            {
                try
                {
                    HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                    strTemp.Add(nameof(Metamagics));
                    dicChangedProperties.Add(this, strTemp);
                    using (await EnterReadLock.EnterAsync(LockObject))
                    {
                        foreach (Metamagic objNewItem in lstImprovementSourcesToProcess)
                        {
                            // Needed in order to properly process named sources where
                            // the tooltip was built before the object was added to the character
                            foreach (Improvement objImprovement in Improvements)
                            {
                                if (objImprovement.SourceName != objNewItem.InternalId || !objImprovement.Enabled)
                                    continue;
                                foreach ((INotifyMultiplePropertyChanged objItemToUpdate,
                                          string strPropertyToUpdate) in
                                         objImprovement.GetRelevantPropertyChangers())
                                {
                                    if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                                          out HashSet<string> setChangedProperties))
                                    {
                                        setChangedProperties = Utils.StringHashSetPool.Get();
                                        dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                    }

                                    setChangedProperties.Add(strPropertyToUpdate);
                                }
                            }
                        }
                    }

                    foreach (KeyValuePair<INotifyMultiplePropertyChanged, HashSet<string>> kvpToUpdate in
                             dicChangedProperties)
                    {
                        kvpToUpdate.Key.OnMultiplePropertyChanged(kvpToUpdate.Value.ToList());
                    }
                }
                finally
                {
                    foreach (HashSet<string> setToReturn in dicChangedProperties.Values)
                        Utils.StringHashSetPool.Return(setToReturn);
                }
            }
        }

        private void ExpenseLogOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                            out HashSet<string> setPropertiesToRefresh))
            {
                switch (e.Action)
                {
                    case NotifyCollectionChangedAction.Add:
                        foreach (ExpenseLogEntry objNewItem in e.NewItems)
                        {
                            if ((objNewItem.Amount > 0 || objNewItem.ForceCareerVisible) && !objNewItem.Refund)
                            {
                                setPropertiesToRefresh.Add(objNewItem.Type == ExpenseType.Nuyen
                                                               ? nameof(CareerNuyen)
                                                               : nameof(CareerKarma));
                            }
                        }

                        break;
                    case NotifyCollectionChangedAction.Remove:
                        foreach (ExpenseLogEntry objOldItem in e.OldItems)
                        {
                            if ((objOldItem.Amount > 0 || objOldItem.ForceCareerVisible) && !objOldItem.Refund)
                            {
                                setPropertiesToRefresh.Add(objOldItem.Type == ExpenseType.Nuyen
                                                               ? nameof(CareerNuyen)
                                                               : nameof(CareerKarma));
                            }
                        }

                        break;
                    case NotifyCollectionChangedAction.Replace:
                        foreach (ExpenseLogEntry objOldItem in e.OldItems)
                        {
                            if ((objOldItem.Amount > 0 || objOldItem.ForceCareerVisible) && !objOldItem.Refund)
                            {
                                setPropertiesToRefresh.Add(objOldItem.Type == ExpenseType.Nuyen
                                                               ? nameof(CareerNuyen)
                                                               : nameof(CareerKarma));
                            }
                        }

                        foreach (ExpenseLogEntry objNewItem in e.NewItems)
                        {
                            if ((objNewItem.Amount > 0 || objNewItem.ForceCareerVisible) && !objNewItem.Refund)
                            {
                                setPropertiesToRefresh.Add(objNewItem.Type == ExpenseType.Nuyen
                                                               ? nameof(CareerNuyen)
                                                               : nameof(CareerKarma));
                            }
                        }

                        break;
                    case NotifyCollectionChangedAction.Reset:
                        setPropertiesToRefresh.Add(nameof(CareerNuyen));
                        setPropertiesToRefresh.Add(nameof(CareerKarma));
                        break;
                }

                if (setPropertiesToRefresh.Count > 0)
                    OnMultiplePropertyChanged(setPropertiesToRefresh.ToList());
            }
        }

        private async void GearOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (e.Action == NotifyCollectionChangedAction.Move)
                return;
            bool blnDoEncumbranceRefresh = false;
            using (new FetchSafelyFromPool<Dictionary<INotifyMultiplePropertyChanged, HashSet<string>>>(
                       Utils.DictionaryForMultiplePropertyChangedPool,
                       out Dictionary<INotifyMultiplePropertyChanged, HashSet<string>> dicChangedProperties))
            {
                try
                {
                    switch (e.Action)
                    {
                        case NotifyCollectionChangedAction.Add:
                            foreach (Gear objNewItem in e.NewItems)
                            {
                                if (objNewItem.Equipped)
                                {
                                    blnDoEncumbranceRefresh = true;
                                }

                                using (await EnterReadLock.EnterAsync(LockObject))
                                {
                                    if (!IsLoading)
                                    {
                                        // Needed in order to properly process named sources where
                                        // the tooltip was built before the object was added to the character
                                        foreach (Improvement objImprovement in Improvements)
                                        {
                                            if (objImprovement.SourceName.TrimEndOnce("Wireless")
                                                == objNewItem.InternalId
                                                &&
                                                objImprovement.Enabled)
                                            {
                                                foreach ((INotifyMultiplePropertyChanged objItemToUpdate,
                                                          string strPropertyToUpdate) in
                                                         objImprovement.GetRelevantPropertyChangers())
                                                {
                                                    if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                            out HashSet<string> setChangedProperties))
                                                    {
                                                        setChangedProperties = Utils.StringHashSetPool.Get();
                                                        dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                                    }

                                                    setChangedProperties.Add(strPropertyToUpdate);
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            break;
                        case NotifyCollectionChangedAction.Remove:
                            foreach (Gear objOldItem in e.OldItems)
                            {
                                if (objOldItem.Equipped)
                                {
                                    blnDoEncumbranceRefresh = true;
                                    break;
                                }
                            }

                            break;
                        case NotifyCollectionChangedAction.Replace:
                            foreach (Gear objOldItem in e.OldItems)
                            {
                                if (objOldItem.Equipped)
                                {
                                    blnDoEncumbranceRefresh = true;
                                    break;
                                }
                            }

                            foreach (Gear objNewItem in e.NewItems)
                            {
                                if (objNewItem.Equipped)
                                {
                                    blnDoEncumbranceRefresh = true;
                                }

                                using (await EnterReadLock.EnterAsync(LockObject))
                                {
                                    if (!IsLoading)
                                    {
                                        // Needed in order to properly process named sources where
                                        // the tooltip was built before the object was added to the character
                                        foreach (Improvement objImprovement in Improvements)
                                        {
                                            if (objImprovement.SourceName.TrimEndOnce("Wireless")
                                                == objNewItem.InternalId
                                                &&
                                                objImprovement.Enabled)
                                            {
                                                foreach ((INotifyMultiplePropertyChanged objItemToUpdate,
                                                          string strPropertyToUpdate) in
                                                         objImprovement.GetRelevantPropertyChangers())
                                                {
                                                    if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                            out HashSet<string> setChangedProperties))
                                                    {
                                                        setChangedProperties = Utils.StringHashSetPool.Get();
                                                        dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                                    }

                                                    setChangedProperties.Add(strPropertyToUpdate);
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            break;
                        case NotifyCollectionChangedAction.Reset:
                            blnDoEncumbranceRefresh = true;
                            break;
                    }

                    if (blnDoEncumbranceRefresh)
                    {
                        if (!dicChangedProperties.TryGetValue(this, out HashSet<string> setChangedProperties))
                        {
                            setChangedProperties = Utils.StringHashSetPool.Get();
                            dicChangedProperties.Add(this, setChangedProperties);
                        }
                        setChangedProperties.Add(nameof(TotalCarriedWeight));
                    }

                    foreach (KeyValuePair<INotifyMultiplePropertyChanged, HashSet<string>> kvpToProcess in dicChangedProperties)
                    {
                        kvpToProcess.Key.OnMultiplePropertyChanged(kvpToProcess.Value.ToList());
                    }
                }
                finally
                {
                    foreach (HashSet<string> setToReturn in dicChangedProperties.Values)
                        Utils.StringHashSetPool.Return(setToReturn);
                }
            }
        }

        private async void WeaponsOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (e.Action == NotifyCollectionChangedAction.Move)
                return;
            bool blnDoEncumbranceRefresh = false;
            using (new FetchSafelyFromPool<Dictionary<INotifyMultiplePropertyChanged, HashSet<string>>>(
                       Utils.DictionaryForMultiplePropertyChangedPool,
                       out Dictionary<INotifyMultiplePropertyChanged, HashSet<string>> dicChangedProperties))
            {
                try
                {
                    switch (e.Action)
                    {
                        case NotifyCollectionChangedAction.Add:
                            foreach (Weapon objNewItem in e.NewItems)
                            {
                                if (objNewItem.Equipped)
                                {
                                    blnDoEncumbranceRefresh = true;
                                }

                                using (await EnterReadLock.EnterAsync(LockObject))
                                {
                                    if (!IsLoading)
                                    {
                                        // Needed in order to properly process named sources where
                                        // the tooltip was built before the object was added to the character
                                        foreach (Improvement objImprovement in Improvements)
                                        {
                                            if (objImprovement.SourceName.TrimEndOnce("Wireless")
                                                == objNewItem.InternalId
                                                &&
                                                objImprovement.Enabled)
                                            {
                                                foreach ((INotifyMultiplePropertyChanged objItemToUpdate,
                                                          string strPropertyToUpdate) in
                                                         objImprovement.GetRelevantPropertyChangers())
                                                {
                                                    if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                            out HashSet<string> setChangedProperties))
                                                    {
                                                        setChangedProperties = Utils.StringHashSetPool.Get();
                                                        dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                                    }

                                                    setChangedProperties.Add(strPropertyToUpdate);
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            break;
                        case NotifyCollectionChangedAction.Remove:
                            foreach (Weapon objOldItem in e.OldItems)
                            {
                                if (objOldItem.Equipped)
                                {
                                    blnDoEncumbranceRefresh = true;
                                    break;
                                }
                            }

                            break;
                        case NotifyCollectionChangedAction.Replace:
                            foreach (Weapon objOldItem in e.OldItems)
                            {
                                if (objOldItem.Equipped)
                                {
                                    blnDoEncumbranceRefresh = true;
                                    break;
                                }
                            }

                            foreach (Weapon objNewItem in e.NewItems)
                            {
                                if (objNewItem.Equipped)
                                {
                                    blnDoEncumbranceRefresh = true;
                                }

                                using (await EnterReadLock.EnterAsync(LockObject))
                                {
                                    if (!IsLoading)
                                    {
                                        // Needed in order to properly process named sources where
                                        // the tooltip was built before the object was added to the character
                                        foreach (Improvement objImprovement in Improvements)
                                        {
                                            if (objImprovement.SourceName.TrimEndOnce("Wireless")
                                                == objNewItem.InternalId
                                                &&
                                                objImprovement.Enabled)
                                            {
                                                foreach ((INotifyMultiplePropertyChanged objItemToUpdate,
                                                          string strPropertyToUpdate) in
                                                         objImprovement.GetRelevantPropertyChangers())
                                                {
                                                    if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                            out HashSet<string> setChangedProperties))
                                                    {
                                                        setChangedProperties = Utils.StringHashSetPool.Get();
                                                        dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                                    }

                                                    setChangedProperties.Add(strPropertyToUpdate);
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            break;
                        case NotifyCollectionChangedAction.Reset:
                            blnDoEncumbranceRefresh = true;
                            break;
                    }

                    if (blnDoEncumbranceRefresh)
                    {
                        if (!dicChangedProperties.TryGetValue(this, out HashSet<string> setChangedProperties))
                        {
                            setChangedProperties = Utils.StringHashSetPool.Get();
                            dicChangedProperties.Add(this, setChangedProperties);
                        }
                        setChangedProperties.Add(nameof(TotalCarriedWeight));
                    }

                    foreach (KeyValuePair<INotifyMultiplePropertyChanged, HashSet<string>> kvpToProcess in dicChangedProperties)
                    {
                        kvpToProcess.Key.OnMultiplePropertyChanged(kvpToProcess.Value.ToList());
                    }
                }
                finally
                {
                    foreach (HashSet<string> setToReturn in dicChangedProperties.Values)
                        Utils.StringHashSetPool.Return(setToReturn);
                }
            }
        }

        private async void ArmorOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (e.Action == NotifyCollectionChangedAction.Move)
                return;
            bool blnDoEquippedArmorRefresh = false;
            bool blnDoArmorEncumbranceRefresh = false;
            using (new FetchSafelyFromPool<Dictionary<INotifyMultiplePropertyChanged, HashSet<string>>>(
                       Utils.DictionaryForMultiplePropertyChangedPool,
                       out Dictionary<INotifyMultiplePropertyChanged, HashSet<string>> dicChangedProperties))
            {
                try
                {
                    switch (e.Action)
                    {
                        case NotifyCollectionChangedAction.Add:
                            foreach (Armor objNewItem in e.NewItems)
                            {
                                if (objNewItem.Equipped)
                                {
                                    blnDoEquippedArmorRefresh = true;
                                    if (objNewItem.Encumbrance)
                                        blnDoArmorEncumbranceRefresh = true;
                                }

                                using (await EnterReadLock.EnterAsync(LockObject))
                                {
                                    if (!IsLoading)
                                    {
                                        // Needed in order to properly process named sources where
                                        // the tooltip was built before the object was added to the character
                                        foreach (Improvement objImprovement in Improvements)
                                        {
                                            if (objImprovement.SourceName.TrimEndOnce("Wireless")
                                                == objNewItem.InternalId
                                                &&
                                                objImprovement.Enabled)
                                            {
                                                foreach ((INotifyMultiplePropertyChanged objItemToUpdate,
                                                          string strPropertyToUpdate) in
                                                         objImprovement.GetRelevantPropertyChangers())
                                                {
                                                    if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                            out HashSet<string> setChangedProperties))
                                                    {
                                                        setChangedProperties = Utils.StringHashSetPool.Get();
                                                        dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                                    }

                                                    setChangedProperties.Add(strPropertyToUpdate);
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            break;
                        case NotifyCollectionChangedAction.Remove:
                            foreach (Armor objOldItem in e.OldItems)
                            {
                                if (objOldItem.Equipped)
                                {
                                    blnDoEquippedArmorRefresh = true;
                                    if (objOldItem.Encumbrance)
                                    {
                                        blnDoArmorEncumbranceRefresh = true;
                                        break;
                                    }
                                }
                            }

                            break;
                        case NotifyCollectionChangedAction.Replace:
                            foreach (Armor objOldItem in e.OldItems)
                            {
                                if (objOldItem.Equipped)
                                {
                                    blnDoEquippedArmorRefresh = true;
                                    if (objOldItem.Encumbrance)
                                    {
                                        blnDoArmorEncumbranceRefresh = true;
                                        break;
                                    }
                                }
                            }

                            foreach (Armor objNewItem in e.NewItems)
                            {
                                if (objNewItem.Equipped)
                                {
                                    blnDoEquippedArmorRefresh = true;
                                    if (objNewItem.Encumbrance)
                                        blnDoArmorEncumbranceRefresh = true;
                                }

                                using (await EnterReadLock.EnterAsync(LockObject))
                                {
                                    if (!IsLoading)
                                    {
                                        // Needed in order to properly process named sources where
                                        // the tooltip was built before the object was added to the character
                                        foreach (Improvement objImprovement in Improvements)
                                        {
                                            if (objImprovement.SourceName.TrimEndOnce("Wireless")
                                                == objNewItem.InternalId
                                                &&
                                                objImprovement.Enabled)
                                            {
                                                foreach ((INotifyMultiplePropertyChanged objItemToUpdate,
                                                          string strPropertyToUpdate) in
                                                         objImprovement.GetRelevantPropertyChangers())
                                                {
                                                    if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                            out HashSet<string> setChangedProperties))
                                                    {
                                                        setChangedProperties = Utils.StringHashSetPool.Get();
                                                        dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                                    }

                                                    setChangedProperties.Add(strPropertyToUpdate);
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            break;
                        case NotifyCollectionChangedAction.Reset:
                            blnDoEquippedArmorRefresh = true;
                            blnDoArmorEncumbranceRefresh = true;
                            break;
                    }

                    if (blnDoEquippedArmorRefresh)
                    {
                        if (!dicChangedProperties.TryGetValue(this, out HashSet<string> setChangedProperties))
                        {
                            setChangedProperties = Utils.StringHashSetPool.Get();
                            dicChangedProperties.Add(this, setChangedProperties);
                        }
                        setChangedProperties.Add(nameof(GetArmorRating));
                        setChangedProperties.Add(nameof(TotalCarriedWeight));
                    }

                    if (blnDoArmorEncumbranceRefresh)
                    {
                        if (!dicChangedProperties.TryGetValue(this, out HashSet<string> setChangedProperties))
                        {
                            setChangedProperties = Utils.StringHashSetPool.Get();
                            dicChangedProperties.Add(this, setChangedProperties);
                        }
                        setChangedProperties.Add(nameof(ArmorEncumbrance));
                    }

                    foreach (KeyValuePair<INotifyMultiplePropertyChanged, HashSet<string>> kvpToProcess in dicChangedProperties)
                    {
                        kvpToProcess.Key.OnMultiplePropertyChanged(kvpToProcess.Value.ToList());
                    }
                }
                finally
                {
                    foreach (HashSet<string> setToReturn in dicChangedProperties.Values)
                        Utils.StringHashSetPool.Return(setToReturn);
                }
            }
        }

        private async void CyberwareOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (e.Action == NotifyCollectionChangedAction.Move)
                return;
            bool blnDoEncumbranceRefresh = false;
            bool blnDoCyberlimbAttributesRefresh = false;
            using (new FetchSafelyFromPool<Dictionary<INotifyMultiplePropertyChanged, HashSet<string>>>(
                       Utils.DictionaryForMultiplePropertyChangedPool,
                       out Dictionary<INotifyMultiplePropertyChanged, HashSet<string>> dicChangedProperties))
            {
                try
                {
                    switch (e.Action)
                    {
                        case NotifyCollectionChangedAction.Add:
                        {
                            HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                            strTemp.Add(nameof(RedlinerBonus));
                            dicChangedProperties.Add(this, strTemp);
                            foreach (Cyberware objNewItem in e.NewItems)
                            {
                                if (objNewItem.IsModularCurrentlyEquipped)
                                    blnDoEncumbranceRefresh = true;
                                dicChangedProperties[this].Add(objNewItem.EssencePropertyName);
                                using (await EnterReadLock.EnterAsync(LockObject))
                                {
                                    if (!IsLoading)
                                    {
                                        // Needed in order to properly process named sources where
                                        // the tooltip was built before the object was added to the character
                                        foreach (Improvement objImprovement in Improvements)
                                        {
                                            if (objImprovement.SourceName.TrimEndOnce("Pair").TrimEndOnce("Wireless") ==
                                                objNewItem.InternalId && objImprovement.Enabled)
                                            {
                                                foreach ((INotifyMultiplePropertyChanged objItemToUpdate,
                                                          string strPropertyToUpdate) in
                                                         objImprovement.GetRelevantPropertyChangers())
                                                {
                                                    if (!dicChangedProperties.TryGetValue(objItemToUpdate,
                                                            out HashSet<string> setChangedProperties))
                                                    {
                                                        setChangedProperties = Utils.StringHashSetPool.Get();
                                                        dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                                    }

                                                    setChangedProperties.Add(strPropertyToUpdate);
                                                }
                                            }
                                        }
                                    }

                                    if (!blnDoCyberlimbAttributesRefresh && !Settings.DontUseCyberlimbCalculation &&
                                        objNewItem.Category == "Cyberlimb" && objNewItem.Parent == null &&
                                        objNewItem.ParentVehicle == null &&
                                        !string.IsNullOrWhiteSpace(objNewItem.LimbSlot) &&
                                        !Settings.ExcludeLimbSlot.Contains(objNewItem.LimbSlot))
                                    {
                                        blnDoCyberlimbAttributesRefresh = true;
                                    }
                                }
                            }

                            break;
                        }
                        case NotifyCollectionChangedAction.Remove:
                        {
                            HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                            strTemp.Add(nameof(RedlinerBonus));
                            dicChangedProperties.Add(this, strTemp);
                            foreach (Cyberware objOldItem in e.OldItems)
                            {
                                if (objOldItem.IsModularCurrentlyEquipped)
                                    blnDoEncumbranceRefresh = true;
                                dicChangedProperties[this].Add(objOldItem.EssencePropertyName);
                                using (await EnterReadLock.EnterAsync(LockObject))
                                {
                                    if (!blnDoCyberlimbAttributesRefresh && !Settings.DontUseCyberlimbCalculation &&
                                        objOldItem.Category == "Cyberlimb" && objOldItem.Parent == null &&
                                        objOldItem.ParentVehicle == null &&
                                        !string.IsNullOrWhiteSpace(objOldItem.LimbSlot) &&
                                        !Settings.ExcludeLimbSlot.Contains(objOldItem.LimbSlot))
                                    {
                                        blnDoCyberlimbAttributesRefresh = true;
                                    }
                                }
                            }

                            break;
                        }
                        case NotifyCollectionChangedAction.Replace:
                        {
                            HashSet<string> strTemp = Utils.StringHashSetPool.Get();
                            strTemp.Add(nameof(RedlinerBonus));
                            dicChangedProperties.Add(this, strTemp);
                            using (await EnterReadLock.EnterAsync(LockObject))
                            {
                                if (!Settings.DontUseCyberlimbCalculation)
                                {
                                    foreach (Cyberware objOldItem in e.OldItems)
                                    {
                                        if (objOldItem.IsModularCurrentlyEquipped)
                                            blnDoEncumbranceRefresh = true;
                                        dicChangedProperties[this].Add(objOldItem.EssencePropertyName);
                                        if (!blnDoCyberlimbAttributesRefresh && !Settings.DontUseCyberlimbCalculation &&
                                            objOldItem.Category == "Cyberlimb" && objOldItem.Parent == null &&
                                            objOldItem.ParentVehicle == null &&
                                            !string.IsNullOrWhiteSpace(objOldItem.LimbSlot) &&
                                            !Settings.ExcludeLimbSlot.Contains(objOldItem.LimbSlot))
                                        {
                                            blnDoCyberlimbAttributesRefresh = true;
                                        }
                                    }

                                    foreach (Cyberware objNewItem in e.NewItems)
                                    {
                                        if (objNewItem.IsModularCurrentlyEquipped)
                                            blnDoEncumbranceRefresh = true;
                                        dicChangedProperties[this].Add(objNewItem.EssencePropertyName);
                                        if (!blnDoCyberlimbAttributesRefresh && !Settings.DontUseCyberlimbCalculation &&
                                            objNewItem.Category == "Cyberlimb" && objNewItem.Parent == null &&
                                            objNewItem.ParentVehicle == null &&
                                            !string.IsNullOrWhiteSpace(objNewItem.LimbSlot) &&
                                            !Settings.ExcludeLimbSlot.Contains(objNewItem.LimbSlot))
                                        {
                                            blnDoCyberlimbAttributesRefresh = true;
                                        }
                                    }
                                }
                            }

                            break;
                        }
                        case NotifyCollectionChangedAction.Reset:
                        {
                            blnDoEncumbranceRefresh = true;
                            using (await EnterReadLock.EnterAsync(LockObject))
                                blnDoCyberlimbAttributesRefresh = !Settings.DontUseCyberlimbCalculation;
                            if (!dicChangedProperties.TryGetValue(this,
                                                                  out HashSet<string> setChangedProperties))
                            {
                                setChangedProperties = Utils.StringHashSetPool.Get();
                                dicChangedProperties.Add(this, setChangedProperties);
                            }
                            setChangedProperties.Add(nameof(RedlinerBonus));
                            setChangedProperties.Add(nameof(PrototypeTranshumanEssenceUsed));
                            setChangedProperties.Add(nameof(BiowareEssence));
                            setChangedProperties.Add(nameof(CyberwareEssence));
                            setChangedProperties.Add(nameof(EssenceHole));
                            break;
                        }
                    }

                    if (blnDoEncumbranceRefresh)
                    {
                        if (!dicChangedProperties.TryGetValue(this, out HashSet<string> setChangedProperties))
                        {
                            setChangedProperties = Utils.StringHashSetPool.Get();
                            dicChangedProperties.Add(this, setChangedProperties);
                        }
                        setChangedProperties.Add(nameof(TotalCarriedWeight));
                    }

                    if (blnDoCyberlimbAttributesRefresh)
                    {
                        using (await EnterReadLock.EnterAsync(LockObject))
                        {
                            foreach (string strAbbrev in Backend.Equipment.Cyberware.CyberlimbAttributeAbbrevs)
                            {
                                CharacterAttrib objAttribute = await GetAttributeAsync(strAbbrev);
                                if (objAttribute == null)
                                    continue;
                                if (!dicChangedProperties.TryGetValue(objAttribute,
                                                                      out HashSet<string> setChangedProperties))
                                {
                                    setChangedProperties = Utils.StringHashSetPool.Get();
                                    dicChangedProperties.Add(objAttribute, setChangedProperties);
                                }

                                setChangedProperties.Add(nameof(CharacterAttrib.TotalValue));
                            }
                        }
                    }

                    foreach (KeyValuePair<INotifyMultiplePropertyChanged, HashSet<string>> kvpToProcess in dicChangedProperties)
                    {
                        kvpToProcess.Key.OnMultiplePropertyChanged(kvpToProcess.Value.ToList());
                    }
                }
                finally
                {
                    foreach (HashSet<string> setToReturn in dicChangedProperties.Values)
                        Utils.StringHashSetPool.Return(setToReturn);
                }
            }
        }

        private void SustainedObjectsOnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            bool blnDoRefreshPenalties = false;
            switch (e.Action)
            {
                case NotifyCollectionChangedAction.Add:
                    blnDoRefreshPenalties =
                        e.NewItems.OfType<SustainedObject>().Any(objItem => objItem.HasSustainingPenalty);
                    break;
                case NotifyCollectionChangedAction.Remove:
                    blnDoRefreshPenalties =
                        e.OldItems.OfType<SustainedObject>().Any(objItem => objItem.HasSustainingPenalty);
                    break;
                case NotifyCollectionChangedAction.Replace:
                    blnDoRefreshPenalties =
                        e.OldItems.OfType<SustainedObject>().Any(objItem => objItem.HasSustainingPenalty) ||
                        e.NewItems.OfType<SustainedObject>().Any(objItem => objItem.HasSustainingPenalty);
                    break;
                case NotifyCollectionChangedAction.Move:
                    break;
                case NotifyCollectionChangedAction.Reset:
                    blnDoRefreshPenalties = true;
                    break;
            }
            if (blnDoRefreshPenalties)
                RefreshSustainingPenalties();
        }

        [HubTag]
        public AttributeSection AttributeSection
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _objAttributeSection;
            }
        }

        public async ValueTask<AttributeSection> GetAttributeSectionAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _objAttributeSection;
        }

        #region Create, Save, Load and Print Methods

        /// <summary>
        /// Set up a character with a metatype and new attributes to match.
        /// </summary>
        public void Create(string strSelectedMetatypeCategory, string strMetatypeId, string strMetavariantId, XmlNode objXmlMetatype, int intForce, XmlNode xmlQualityDocumentQualitiesNode = null, XmlNode xmlCritterPowerDocumentPowersNode = null, XmlNode xmlSkillsDocumentKnowledgeSkillsNode = null, string strSelectedPossessionMethod = "", CancellationToken token = default)
        {
            using (LockObject.EnterWriteLock(token))
            {
                if (objXmlMetatype == null)
                    throw new ArgumentNullException(nameof(objXmlMetatype));
                // Remove any Improvements the character received from their Metatype.
                ImprovementManager.RemoveImprovements(this,
                    Improvements.Where(objImprovement =>
                        objImprovement.ImproveSource == Improvement.ImprovementSource.Metatype
                        || objImprovement.ImproveSource == Improvement.ImprovementSource.Metavariant).ToList());

                // Remove any Qualities the character received from their Metatype, then remove the Quality.
                for (int i = Qualities.Count - 1; i >= 0; --i)
                {
                    if (i >= Qualities.Count)
                        continue;
                    Quality objQuality = Qualities[i];
                    if (objQuality.OriginSource == QualitySource.Metatype ||
                        objQuality.OriginSource == QualitySource.MetatypeRemovable ||
                        objQuality.OriginSource == QualitySource.MetatypeRemovedAtChargen)
                        objQuality.DeleteQuality();
                }

                // If this is a Shapeshifter, a Metavariant must be selected. Default to Human if None is selected.
                if (strSelectedMetatypeCategory == "Shapeshifter" && strMetavariantId == Guid.Empty.ToString())
                    strMetavariantId =
                        objXmlMetatype.SelectSingleNode("metavariants/metavariant[name = \"Human\"]/id")?.InnerText ??
                        string.Empty;
                XmlNode objXmlMetavariant =
                    objXmlMetatype.SelectSingleNode("metavariants/metavariant[id = " + strMetavariantId.CleanXPath() +
                                                    ']');

                // Set Metatype information.
                XmlNode charNode =
                    strSelectedMetatypeCategory == "Shapeshifter" || strMetavariantId == Guid.Empty.ToString()
                        ? objXmlMetatype
                        : objXmlMetavariant ?? objXmlMetatype;
                AttributeSection.Create(charNode, intForce, token: token);
                MetatypeGuid = new Guid(strMetatypeId);
                Metatype = objXmlMetatype["name"]?.InnerText ?? "Human";
                MetatypeCategory = strSelectedMetatypeCategory;
                MetavariantGuid = string.IsNullOrEmpty(strMetavariantId) ? Guid.Empty : new Guid(strMetavariantId);
                Metavariant = MetavariantGuid != Guid.Empty ? objXmlMetavariant?["name"]?.InnerText ?? "None" : "None";
                // We only reverted to the base metatype to get the attributes.
                if (strSelectedMetatypeCategory == "Shapeshifter")
                {
                    charNode = objXmlMetavariant ?? objXmlMetatype;
                }

                Source = charNode["source"]?.InnerText ?? "SR5";
                Page = charNode["page"]?.InnerText ?? "0";
                _intMetatypeBP = 0;
                charNode.TryGetInt32FieldQuickly("karma", ref _intMetatypeBP);
                _intInitiativeDice = Settings.MinInitiativeDice;
                charNode.TryGetInt32FieldQuickly("initiativedice", ref _intInitiativeDice);

                Movement = objXmlMetatype["movement"]?.InnerText ?? string.Empty;

                // Determine if the Metatype has any bonuses.
                XmlNode xmlBonusNode = charNode.SelectSingleNode("bonus");
                if (xmlBonusNode != null)
                    ImprovementManager.CreateImprovements(this, Improvement.ImprovementSource.Metatype, strMetatypeId,
                        xmlBonusNode, 1, strMetatypeId);

                List<Weapon> lstWeapons = new List<Weapon>(1);
                // Create the Qualities that come with the Metatype.
                if (xmlQualityDocumentQualitiesNode == null)
                    xmlQualityDocumentQualitiesNode = LoadData("qualities.xml", token: token).SelectSingleNode("/chummer/qualities");
                if (xmlQualityDocumentQualitiesNode != null)
                {
                    using (XmlNodeList xmlQualityList = charNode.SelectNodes("qualities/*/quality"))
                    {
                        if (xmlQualityList != null)
                        {
                            foreach (XmlNode objXmlQualityItem in xmlQualityList)
                            {
                                string strQuality = objXmlQualityItem.InnerText;
                                XmlNode objXmlQuality = strQuality.IsGuid()
                                    ? xmlQualityDocumentQualitiesNode.SelectSingleNode(
                                        "quality[id = " + strQuality.CleanXPath() + ']')
                                    : xmlQualityDocumentQualitiesNode.SelectSingleNode(
                                        "quality[name = " + strQuality.CleanXPath() + ']');
                                if (objXmlQuality != null)
                                {
                                    Quality objQuality = new Quality(this);
                                    string strForceValue =
                                        objXmlQualityItem.Attributes["select"]?.InnerText ?? string.Empty;
                                    QualitySource objSource =
                                        objXmlQualityItem.Attributes["removable"]?.InnerText == bool.TrueString
                                            ? QualitySource.MetatypeRemovable
                                            : QualitySource.Metatype;
                                    objQuality.Create(objXmlQuality, objSource, lstWeapons, strForceValue);
                                    objQuality.ContributeToLimit = false;
                                    Qualities.Add(objQuality);
                                }
                            }
                        }
                    }
                }

                //Load any critter powers the character has.
                if (xmlCritterPowerDocumentPowersNode == null)
                    xmlCritterPowerDocumentPowersNode =
                        LoadData("critterpowers.xml", token: token).SelectSingleNode("/chummer/powers");
                if (xmlCritterPowerDocumentPowersNode != null)
                {
                    foreach (XmlNode objXmlPower in charNode.SelectNodes("powers/power"))
                    {
                        string strCritterPower = objXmlPower.InnerText;
                        XmlNode objXmlCritterPower = strCritterPower.IsGuid()
                            ? xmlCritterPowerDocumentPowersNode.SelectSingleNode(
                                "power[id = " + strCritterPower.CleanXPath() + ']')
                            : xmlCritterPowerDocumentPowersNode.SelectSingleNode(
                                "power[name = " + strCritterPower.CleanXPath() + ']');
                        if (objXmlCritterPower != null)
                        {
                            CritterPower objPower = new CritterPower(this);
                            string strForcedValue = objXmlPower.Attributes["select"]?.InnerText ?? string.Empty;
                            int intRating =
                                CommonFunctions.ExpressionToInt(objXmlPower.Attributes["rating"]?.InnerText, intForce,
                                                                0,
                                                                0);

                            objPower.Create(objXmlCritterPower, intRating, strForcedValue);
                            objPower.CountTowardsLimit = false;
                            CritterPowers.Add(objPower);
                            ImprovementManager.CreateImprovement(this, objPower.InternalId,
                                                                 Improvement.ImprovementSource.Metatype, string.Empty,
                                                                 Improvement.ImprovementType.CritterPower,
                                                                 string.Empty);
                            ImprovementManager.Commit(this);
                        }
                    }
                }

                //Load any natural weapons the character has.
                foreach (XmlNode objXmlNaturalWeapon in charNode.SelectNodes("naturalweapons/naturalweapon"))
                {
                    Weapon objWeapon = new Weapon(this)
                    {
                        Name = objXmlNaturalWeapon["name"].InnerText,
                        Category = LanguageManager.GetString("Tab_Critter", token: token),
                        RangeType = "Melee",
                        Reach =
                            CommonFunctions.ExpressionToInt(objXmlNaturalWeapon["reach"]?.InnerText, intForce, 0, 0),
                        Damage = objXmlNaturalWeapon["damage"]?.InnerText ?? "0S",
                        AP = objXmlNaturalWeapon["ap"]?.InnerText ?? "0",
                        Mode = "0",
                        RC = "0",
                        Concealability = 0,
                        Avail = "0",
                        Cost = "0",
                        UseSkill = objXmlNaturalWeapon["useskill"]?.InnerText,
                        Source = objXmlNaturalWeapon["source"].InnerText,
                        Page = objXmlNaturalWeapon["page"].InnerText
                    };
                    Weapons.Add(objWeapon);
                }

                // Add the Unarmed Attack Weapon to the character.
                if (Weapons.All(x => x.Name != "Unarmed Attack"))
                {
                    XmlNode objXmlWeapon = LoadData("weapons.xml", token: token)
                        .SelectSingleNode("/chummer/weapons/weapon[name = \"Unarmed Attack\"]");
                    if (objXmlWeapon != null)
                    {
                        Weapon objWeapon = new Weapon(this);
                        objWeapon.Create(objXmlWeapon, lstWeapons);
                        objWeapon.ParentID =
                            Guid.NewGuid()
                                .ToString("D",
                                    GlobalSettings.InvariantCultureInfo); // Unarmed Attack can never be removed
                        Weapons.Add(objWeapon);
                    }
                }

                //Set the Active Skill Ratings for the Critter.
                foreach (XmlNode xmlSkill in charNode.SelectNodes("skills/skill"))
                {
                    string strRating = xmlSkill.Attributes?["rating"]?.InnerText;
                    bool bImprovementAdded = false;
                    if (!string.IsNullOrEmpty(strRating))
                    {
                        ImprovementManager.CreateImprovement(this, xmlSkill.InnerText,
                            Improvement.ImprovementSource.Metatype, string.Empty,
                            Improvement.ImprovementType.SkillLevel,
                            string.Empty,
                            CommonFunctions.ExpressionToInt(strRating, intForce, 0, 0));
                        ImprovementManager.Commit(this);
                        bImprovementAdded = true;
                    }

                    string strSkill = xmlSkill.InnerText;
                    string strSpec = xmlSkill.Attributes?["spec"]?.InnerText ?? string.Empty;
                    Skill objSkill = SkillsSection.GetActiveSkill(strSkill);
                    
                    if (objSkill == null && ExoticSkill.IsExoticSkillName(strSkill))
                    {
                        SkillsSection.AddExoticSkill(strSkill, strSpec);
                        continue;
                    }
                    if (objSkill == null)
                    {
                        if (!bImprovementAdded)
                            continue;

                        //This skill does not yet exist but the datafile asks to improve it.
                        //We need to add it so it is not only improved but also shown on the skills tab.
                        SkillsSection.AddSkills(SkillsSection.FilterOption.Name, strSkill);
                        objSkill = SkillsSection.GetActiveSkill(strSkill);
                    }

                    if (objSkill != null) //More or less a safeguard only. Should not be empty at that point any longer.
                    {
                        if (string.IsNullOrEmpty(strSpec)) continue;
                        if (objSkill.Specializations.All(x => x.Name != strSpec))
                        {
                            SkillSpecialization objSpec = new SkillSpecialization(this, strSpec);
                            objSkill.Specializations.Add(objSpec);
                            ImprovementManager.CreateImprovement(this, strSkill, Improvement.ImprovementSource.Metatype,
                                string.Empty, Improvement.ImprovementType.SkillSpecialization, objSpec.InternalId);
                            ImprovementManager.Commit(this);
                        }
                    }
                }

                //Set the Skill Group Ratings for the Critter.
                foreach (XmlNode xmlSkillGroup in charNode.SelectNodes("skills/group"))
                {
                    string strRating = xmlSkillGroup.Attributes?["rating"]?.InnerText;
                    if (!string.IsNullOrEmpty(strRating))
                    {
                        ImprovementManager.CreateImprovement(this, xmlSkillGroup.InnerText,
                            Improvement.ImprovementSource.Metatype, string.Empty,
                            Improvement.ImprovementType.SkillGroupLevel, string.Empty,
                            CommonFunctions.ExpressionToInt(strRating, intForce, 0, 0));
                        ImprovementManager.Commit(this);
                    }
                }

                //Set the Knowledge Skill Ratings for the Critter.
                if (xmlSkillsDocumentKnowledgeSkillsNode == null)
                    xmlSkillsDocumentKnowledgeSkillsNode =
                        LoadData("skills.xml", token: token).SelectSingleNode("/chummer/knowledgeskills");
                if (xmlSkillsDocumentKnowledgeSkillsNode != null)
                {
                    foreach (XmlNode xmlSkill in charNode.SelectNodes("skills/knowledge"))
                    {
                        string strName = xmlSkill.InnerText;
                        if (string.IsNullOrEmpty(strName))
                            continue;
                        string strRating = xmlSkill.Attributes?["rating"]?.InnerText;
                        if (string.IsNullOrEmpty(strRating))
                            continue;
                        if (SkillsSection.KnowledgeSkills.All(x => x.Name != strName))
                        {
                            XmlNode objXmlSkillNode =
                                xmlSkillsDocumentKnowledgeSkillsNode.SelectSingleNode("skill[name = " +
                                    strName.CleanXPath() + ']');
                            if (objXmlSkillNode != null)
                            {
                                Skill objUncastSkill = Skill.FromData(objXmlSkillNode, this, true);
                                if (objUncastSkill is KnowledgeSkill objSkill)
                                    SkillsSection.KnowledgeSkills.Add(objSkill);
                                else
                                {
                                    Utils.BreakIfDebug();
                                    objUncastSkill.Remove();
                                }
                            }
                            else
                            {
                                KnowledgeSkill objSkill = new KnowledgeSkill(this, strName, true)
                                {
                                    Type = xmlSkill.Attributes?["category"]?.InnerText
                                };
                                SkillsSection.KnowledgeSkills.Add(objSkill);
                            }
                        }

                        ImprovementManager.CreateImprovement(this, strName,
                            Improvement.ImprovementSource.Metatype, string.Empty,
                            Improvement.ImprovementType.SkillLevel, string.Empty,
                            CommonFunctions.ExpressionToInt(strRating, intForce, 0, 0));
                        ImprovementManager.Commit(this);
                    }
                }

                // Add any Complex Forms the Critter comes with (typically Sprites)
                XmlDocument xmlComplexFormDocument = LoadData("complexforms.xml", token: token);
                foreach (XmlNode xmlComplexForm in charNode.SelectNodes("complexforms/complexform"))
                {
                    string strComplexForm = xmlComplexForm.InnerText;
                    XmlNode xmlComplexFormData = strComplexForm.IsGuid()
                        ? xmlComplexFormDocument.SelectSingleNode(
                            "/chummer/complexforms/complexform[id = " + strComplexForm.CleanXPath() + ']')
                        : xmlComplexFormDocument.SelectSingleNode(
                            "/chummer/complexforms/complexform[name = " + strComplexForm.CleanXPath() + ']');
                    if (xmlComplexFormData == null)
                        continue;

                    ComplexForm objComplexform = new ComplexForm(this);
                    objComplexform.Create(xmlComplexFormData);
                    if (objComplexform.InternalId.IsEmptyGuid())
                        continue;
                    objComplexform.Grade = -1;

                    ComplexForms.Add(objComplexform);

                    ImprovementManager.CreateImprovement(this, objComplexform.InternalId,
                        Improvement.ImprovementSource.Metatype, string.Empty, Improvement.ImprovementType.ComplexForm,
                        string.Empty);
                    ImprovementManager.Commit(this);
                }

                //Load any cyberware the character has.
                XmlDocument xmlCyberwareDocument = LoadData("cyberware.xml", token: token);
                foreach (XmlNode node in charNode.SelectNodes("cyberwares/cyberware"))
                {
                    string strCyberware = node.InnerText;
                    XmlNode objXmlCyberwareNode = strCyberware.IsGuid()
                        ? xmlCyberwareDocument.SelectSingleNode(
                            "chummer/cyberwares/cyberware[id = " + strCyberware.CleanXPath() + ']')
                        : xmlCyberwareDocument.SelectSingleNode(
                            "chummer/cyberwares/cyberware[name = " + strCyberware.CleanXPath() + ']');
                    if (objXmlCyberwareNode == null)
                        continue;
                    Cyberware objWare = new Cyberware(this);
                    string strForcedValue = node.Attributes["select"]?.InnerText ?? string.Empty;
                    int intRating =
                        CommonFunctions.ExpressionToInt(node.Attributes["rating"]?.InnerText, intForce, 0, 0);

                    objWare.Create(objXmlCyberwareNode,
                        GetGrades(Improvement.ImprovementSource.Cyberware, true, token)
                            .FirstOrDefault(x => x.Name == "None"), Improvement.ImprovementSource.Metatype, intRating,
                        Weapons, Vehicles, true, true, strForcedValue);
                    Cyberware.Add(objWare);
                    ImprovementManager.CreateImprovement(this, objWare.InternalId,
                        Improvement.ImprovementSource.Metatype,
                        string.Empty, Improvement.ImprovementType.FreeWare, string.Empty);
                    ImprovementManager.Commit(this);
                }

                //Load any bioware the character has.
                XmlDocument xmlBiowareDocument = LoadData("bioware.xml", token: token);
                foreach (XmlNode node in charNode.SelectNodes("biowares/bioware"))
                {
                    string strCyberware = node.InnerText;
                    XmlNode objXmlCyberwareNode = strCyberware.IsGuid()
                        ? xmlBiowareDocument.SelectSingleNode(
                            "chummer/biowares/bioware[id = " + strCyberware.CleanXPath() + ']')
                        : xmlBiowareDocument.SelectSingleNode(
                            "chummer/biowares/bioware[name = " + strCyberware.CleanXPath() + ']');
                    if (objXmlCyberwareNode == null)
                        continue;
                    Cyberware objWare = new Cyberware(this);
                    string strForcedValue = node.Attributes["select"]?.InnerText ?? string.Empty;
                    int intRating =
                        CommonFunctions.ExpressionToInt(node.Attributes["rating"]?.InnerText, intForce, 0, 0);

                    objWare.Create(objXmlCyberwareNode,
                        GetGrades(Improvement.ImprovementSource.Bioware, true, token)
                            .FirstOrDefault(x => x.Name == "None"), Improvement.ImprovementSource.Metatype, intRating,
                        Weapons, Vehicles, true, true, strForcedValue);
                    Cyberware.Add(objWare);
                    ImprovementManager.CreateImprovement(this, objWare.InternalId,
                        Improvement.ImprovementSource.Metatype,
                        string.Empty, Improvement.ImprovementType.FreeWare, string.Empty);
                    ImprovementManager.Commit(this);
                }

                // Add any Advanced Programs the Critter comes with (typically A.I.s)
                XmlDocument xmlAIProgramDocument = LoadData("programs.xml", token: token);
                foreach (XmlNode xmlAIProgram in charNode.SelectNodes("programs/program"))
                {
                    string strAIProgram = xmlAIProgram.InnerText;
                    XmlNode xmlAIProgramData = strAIProgram.IsGuid()
                        ? xmlAIProgramDocument.SelectSingleNode(
                            "/chummer/programs/program[id = " + strAIProgram.CleanXPath() + ']')
                        : xmlAIProgramDocument.SelectSingleNode(
                            "/chummer/programs/program[name = " + strAIProgram.CleanXPath() + ']');
                    if (xmlAIProgramData == null)
                        continue;

                    // Check for SelectText.
                    string strExtra = xmlAIProgram.Attributes?["select"]?.InnerText ?? string.Empty;
                    XmlNode xmlSelectText = xmlAIProgramData.SelectSingleNode("bonus/selecttext");
                    if (xmlSelectText != null && !string.IsNullOrWhiteSpace(strExtra))
                    {
                        using (ThreadSafeForm<SelectText> frmPickText = ThreadSafeForm<SelectText>.Get(() => new SelectText
                        {
                            Description = string.Format(GlobalSettings.CultureInfo,
                                       LanguageManager.GetString("String_Improvement_SelectText"),
                                       xmlAIProgramData["translate"]?.InnerText ?? xmlAIProgramData["name"]?.InnerText)
                        }))
                        {
                            // Make sure the dialogue window was not canceled.
                            if (frmPickText.ShowDialogSafe(this, token) == DialogResult.Cancel)
                                continue;
                            strExtra = frmPickText.MyForm.SelectedValue;
                        }
                    }

                    AIProgram objAIProgram = new AIProgram(this);
                    objAIProgram.Create(xmlAIProgram, strExtra, false);
                    if (objAIProgram.InternalId.IsEmptyGuid())
                        continue;

                    AIPrograms.Add(objAIProgram);

                    ImprovementManager.CreateImprovement(this, objAIProgram.InternalId,
                        Improvement.ImprovementSource.Metatype, string.Empty, Improvement.ImprovementType.AIProgram,
                        string.Empty);
                    ImprovementManager.Commit(this);
                }

                // Add any Gear the Critter comes with (typically Programs for A.I.s)
                XmlDocument xmlGearDocument = LoadData("gear.xml", token: token);
                foreach (XmlNode xmlGear in charNode.SelectNodes("gears/gear"))
                {
                    XmlNode xmlGearData = xmlGearDocument.SelectSingleNode("/chummer/gears/gear[name = " +
                                                                           xmlGear["name"].InnerText.CleanXPath() +
                                                                           " and category = " +
                                                                           xmlGear["category"].InnerText.CleanXPath() +
                                                                           "]");
                    if (xmlGearData == null)
                        continue;

                    int intRating = 1;
                    if (xmlGear["rating"] != null)
                        intRating = CommonFunctions.ExpressionToInt(xmlGear["rating"].InnerText, intForce, 0, 0);
                    decimal decQty = 1.0m;
                    if (xmlGear["quantity"] != null)
                        decQty = CommonFunctions.ExpressionToDecimal(xmlGear["quantity"].InnerText, intForce);
                    string strForceValue = xmlGear.Attributes?["select"]?.InnerText ?? string.Empty;

                    Gear objGear = new Gear(this);
                    objGear.Create(xmlGearData, intRating, lstWeapons, strForceValue);

                    if (objGear.InternalId.IsEmptyGuid())
                        continue;

                    objGear.Quantity = decQty;

                    // If a Commlink has just been added, see if the character already has one. If not, make it the active Commlink.
                    if (ActiveCommlink == null && objGear.IsCommlink)
                    {
                        objGear.SetActiveCommlink(this, true);
                    }

                    objGear.Cost = "0";
                    // Create any Weapons that came with this Gear.
                    foreach (Weapon objWeapon in lstWeapons)
                        Weapons.Add(objWeapon);

                    objGear.ParentID = Guid.NewGuid().ToString();

                    Gear.Add(objGear);

                    ImprovementManager.CreateImprovement(this, objGear.InternalId,
                        Improvement.ImprovementSource.Metatype,
                        string.Empty, Improvement.ImprovementType.Gear, string.Empty);
                    ImprovementManager.Commit(this);
                }

                // Add any created Weapons to the character.
                foreach (Weapon objWeapon in lstWeapons)
                    Weapons.Add(objWeapon);

                // Sprites can never have Physical Attributes
                if (DEPEnabled || strSelectedMetatypeCategory?.EndsWith("Sprite", StringComparison.Ordinal) == true ||
                    strSelectedMetatypeCategory?.EndsWith("Sprites", StringComparison.Ordinal) == true)
                {
                    BOD.AssignLimits(0, 0, 0);
                    AGI.AssignLimits(0, 0, 0);
                    REA.AssignLimits(0, 0, 0);
                    STR.AssignLimits(0, 0, 0);
                    MAG.AssignLimits(0, 0, 0);
                    MAGAdept.AssignLimits(0, 0, 0);
                }

                if (strSelectedMetatypeCategory == "Spirits")
                {
                    XmlNode xmlOptionalPowersNode = charNode["optionalpowers"];
                    if (xmlOptionalPowersNode != null && intForce >= 3)
                    {
                        XmlDocument objDummyDocument = new XmlDocument { XmlResolver = null };
                        //For every 3 full points of Force a spirit has, it may gain one Optional Power.
                        for (int i = intForce - 3; i >= 0; i -= 3)
                        {
                            XmlNode bonusNode = objDummyDocument.CreateNode(XmlNodeType.Element, "bonus", null);
                            XmlNode powerNode =
                                objDummyDocument.ImportNode(xmlOptionalPowersNode.CloneNode(true), true);
                            bonusNode.AppendChild(powerNode);
                            objDummyDocument.AppendChild(bonusNode);
                        }

                        foreach (XmlNode bonusNode in objDummyDocument.SelectNodes("/bonus"))
                            ImprovementManager.CreateImprovements(this, Improvement.ImprovementSource.Metatype,
                                strMetatypeId, bonusNode, 1, strMetatypeId);
                    }

                    // Remove the Critter's Materialization Power if they have it. Add the Possession or Inhabitation Power if the Possession-based Tradition checkbox is checked.
                    if (xmlCritterPowerDocumentPowersNode != null)
                    {
                        if (!string.IsNullOrEmpty(strSelectedPossessionMethod))
                        {
                            CritterPower objMaterializationPower =
                                CritterPowers.FirstOrDefault(x => x.Name == "Materialization");
                            if (objMaterializationPower != null)
                                CritterPowers.Remove(objMaterializationPower);

                            if (CritterPowers.All(x => !x.Name.Contains(strSelectedPossessionMethod)))
                            {
                                // Add the selected Power.
                                XmlNode objXmlCritterPower =
                                    xmlCritterPowerDocumentPowersNode.SelectSingleNode("power[name = " +
                                        strSelectedPossessionMethod.CleanXPath() + ']');
                                if (objXmlCritterPower != null)
                                {
                                    CritterPower objPower = new CritterPower(this);
                                    objPower.Create(objXmlCritterPower, 0, string.Empty);
                                    objPower.CountTowardsLimit = false;
                                    CritterPowers.Add(objPower);

                                    ImprovementManager.CreateImprovement(this, objPower.InternalId,
                                        Improvement.ImprovementSource.Metatype, string.Empty,
                                        Improvement.ImprovementType.CritterPower, string.Empty);
                                    ImprovementManager.Commit(this);
                                }
                            }
                        }
                        else if (CritterPowers.All(x =>
                                     x.Name != "Materialization" && !x.Name.Contains("Possession") &&
                                     !x.Name.Contains("Inhabitation")))
                        {
                            // Add the Materialization Power.
                            XmlNode objXmlCritterPower =
                                xmlCritterPowerDocumentPowersNode.SelectSingleNode("power[name = \"Materialization\"]");
                            if (objXmlCritterPower != null)
                            {
                                CritterPower objPower = new CritterPower(this);
                                objPower.Create(objXmlCritterPower, 0, string.Empty);
                                objPower.CountTowardsLimit = false;
                                CritterPowers.Add(objPower);

                                ImprovementManager.CreateImprovement(this, objPower.InternalId,
                                    Improvement.ImprovementSource.Metatype, string.Empty,
                                    Improvement.ImprovementType.CritterPower, string.Empty);
                                ImprovementManager.Commit(this);
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Save the Character to an XML file. Returns true if successful.
        /// </summary>
        public bool Save(string strFileName = "", bool addToMRU = true, bool callOnSaveCallBack = true, CancellationToken token = default)
        {
            return SaveCoreAsync(true, strFileName, addToMRU, callOnSaveCallBack, token).ConfigureAwait(false).GetAwaiter().GetResult();
        }

        /// <summary>
        /// Save the Character to an XML file. Returns true if successful.
        /// </summary>
        public Task<bool> SaveAsync(string strFileName = "", bool addToMRU = true, bool callOnSaveCallBack = true, CancellationToken token = default)
        {
            return SaveCoreAsync(false, strFileName, addToMRU, callOnSaveCallBack, token);
        }

        /// <summary>
        /// Save the Character to an XML file. Returns true if successful.
        /// </summary>
        private async Task<bool> SaveCoreAsync(bool blnSync, string strFileName, bool addToMRU, bool callOnSaveCallBack, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();

            if (string.IsNullOrWhiteSpace(strFileName))
            {
                strFileName = FileName;
                if (string.IsNullOrWhiteSpace(strFileName))
                {
                    return false;
                }
            }

            // ReSharper disable once MethodHasAsyncOverload
            using (blnSync ? EnterReadLock.Enter(LockObject, token) : await EnterReadLock.EnterAsync(LockObject, token))
            {
                bool blnErrorFree = true;

                if (blnSync)
                    DoSave();
                else
                    await Task.Run(() => DoSaveAsync(token), token);

                void DoSave()
                {
                    using (MemoryStream objStream = new MemoryStream())
                    {
                        using (XmlWriter objWriter = Utils.GetStandardXmlWriter(objStream))
                        {
                            objWriter.WriteStartDocument();

                            // <character>
                            objWriter.WriteStartElement("character");

                            // <createdversion />
                            objWriter.WriteElementString("createdversion", _strVersionCreated);
                            // <minimumappversion />
                            objWriter.WriteElementString("minimumappversion", "5.214.1");
                            // <appversion />
                            objWriter.WriteElementString("appversion",
                                Application.ProductVersion.FastEscapeOnceFromStart("0.0."));
                            // <gameedition />
                            objWriter.WriteElementString("gameedition", "SR5");

                            // <settings />
                            objWriter.WriteElementString("settings", _strSettingsKey);
                            // <buildmethod />
                            objWriter.WriteElementString("buildmethod", Settings.BuildMethod.ToString());

                            // <sources>
                            objWriter.WriteStartElement("sources");
                            foreach (string strBook in Settings.Books)
                            {
                                objWriter.WriteElementString("source", strBook);
                            }

                            // </sources>
                            objWriter.WriteEndElement();

                            if (Settings.EnabledCustomDataDirectoryInfos.Count > 0)
                            {
                                // <customdatadirectorynames>
                                objWriter.WriteStartElement("customdatadirectorynames");
                                foreach (string strDirectoryName in Settings.EnabledCustomDataDirectoryInfos.Select(x =>
                                             x.Name))
                                {
                                    objWriter.WriteElementString("directoryname", strDirectoryName);
                                }

                                // </customdatadirectorynames>
                                objWriter.WriteEndElement();
                            }

                            // <metatype />
                            objWriter.WriteElementString("metatype", _strMetatype);
                            // <metatypeid />
                            objWriter.WriteElementString("metatypeid",
                                _guiMetatype.ToString("D", GlobalSettings.InvariantCultureInfo));
                            // <metatypebp />
                            objWriter.WriteElementString("metatypebp",
                                _intMetatypeBP.ToString(GlobalSettings.InvariantCultureInfo));
                            // <metavariant />
                            objWriter.WriteElementString("metavariant", _strMetavariant);
                            // <metavariantid />
                            objWriter.WriteElementString("metavariantid",
                                _guiMetavariant.ToString("D", GlobalSettings.InvariantCultureInfo));
                            // <metatypecategory />
                            objWriter.WriteElementString("metatypecategory", _strMetatypeCategory);
                            // <movement />
                            objWriter.WriteElementString("movement", _strMovement);
                            // <walk />
                            objWriter.WriteElementString("walk", _strWalk);
                            // <run />
                            objWriter.WriteElementString("run", _strRun);
                            // <sprint />
                            objWriter.WriteElementString("sprint", _strSprint);
                            // <walk />
                            objWriter.WriteElementString("walkalt", _strWalk);
                            // <run />
                            objWriter.WriteElementString("runalt", _strRun);
                            // <sprint />
                            objWriter.WriteElementString("sprintalt", _strSprint);
                            // <initiativedice />
                            objWriter.WriteElementString("initiativedice",
                                _intInitiativeDice.ToString(GlobalSettings.InvariantCultureInfo));

                            // <prioritymetatype />
                            objWriter.WriteElementString("prioritymetatype", _strPriorityMetatype);
                            // <priorityattributes />
                            objWriter.WriteElementString("priorityattributes", _strPriorityAttributes);
                            // <priorityspecial />
                            objWriter.WriteElementString("priorityspecial", _strPrioritySpecial);
                            // <priorityskills />
                            objWriter.WriteElementString("priorityskills", _strPrioritySkills);
                            // <priorityresources />
                            objWriter.WriteElementString("priorityresources", _strPriorityResources);
                            // <priorityresources />
                            objWriter.WriteElementString("prioritytalent", _strPriorityTalent);
                            // <priorityskills >
                            objWriter.WriteStartElement("priorityskills");
                            foreach (string strSkill in _lstPrioritySkills)
                            {
                                objWriter.WriteElementString("priorityskill", strSkill);
                            }

                            // </priorityskills>
                            objWriter.WriteEndElement();

                            // <essenceatspecialstart />
                            objWriter.WriteElementString("essenceatspecialstart",
                                _decEssenceAtSpecialStart.ToString(GlobalSettings.InvariantCultureInfo));

                            // <name />
                            objWriter.WriteElementString("name", _strName);
                            SaveMugshots(objWriter, token);

                            // <gender />
                            objWriter.WriteElementString("gender", _strGender);
                            // <age />
                            objWriter.WriteElementString("age", _strAge);
                            // <eyes />
                            objWriter.WriteElementString("eyes", _strEyes);
                            // <height />
                            objWriter.WriteElementString("height", _strHeight);
                            // <weight />
                            objWriter.WriteElementString("weight", _strWeight);
                            // <skin />
                            objWriter.WriteElementString("skin", _strSkin);
                            // <hair />
                            objWriter.WriteElementString("hair", _strHair);
                            // <description />
                            objWriter.WriteElementString("description", _strDescription);
                            // <background />
                            objWriter.WriteElementString("background", _strBackground);
                            // <concept />
                            objWriter.WriteElementString("concept", _strConcept);
                            // <notes />
                            objWriter.WriteElementString("notes", _strNotes.CleanOfInvalidUnicodeChars());
                            // <alias />
                            objWriter.WriteElementString("alias", _strAlias);
                            // <playername />
                            objWriter.WriteElementString("playername", _strPlayerName);
                            // <gamenotes />
                            objWriter.WriteElementString("gamenotes", _strGameNotes);
                            // <primaryarm />
                            objWriter.WriteElementString("primaryarm", _strPrimaryArm);

                            // <ignorerules />
                            if (_blnIgnoreRules)
                                objWriter.WriteElementString("ignorerules",
                                    _blnIgnoreRules.ToString(GlobalSettings.InvariantCultureInfo));
                            // <iscritter />
                            if (_blnIsCritter)
                                objWriter.WriteElementString("iscritter",
                                    _blnIsCritter.ToString(GlobalSettings.InvariantCultureInfo));
                            if (_blnPossessed)
                                objWriter.WriteElementString("possessed",
                                    _blnPossessed.ToString(GlobalSettings.InvariantCultureInfo));
                            // <karma />
                            objWriter.WriteElementString("karma", _intKarma.ToString(GlobalSettings.InvariantCultureInfo));
                            // <special />
                            objWriter.WriteElementString("special",
                                _intSpecial.ToString(GlobalSettings.InvariantCultureInfo));
                            // <totalspecial />
                            objWriter.WriteElementString("totalspecial",
                                _intTotalSpecial.ToString(GlobalSettings.InvariantCultureInfo));
                            // <totalattributes />
                            objWriter.WriteElementString("totalattributes",
                                _intTotalAttributes.ToString(GlobalSettings.InvariantCultureInfo));
                            // <edgeused />
                            objWriter.WriteElementString("edgeused",
                                _intEdgeUsed.ToString(GlobalSettings.InvariantCultureInfo));
                            // <contactpoints />
                            objWriter.WriteElementString("contactpoints",
                                _intCachedContactPoints.ToString(GlobalSettings.InvariantCultureInfo));
                            // <contactpointsused />
                            objWriter.WriteElementString("contactpointsused",
                                _intContactPointsUsed.ToString(GlobalSettings.InvariantCultureInfo));
                            // <spelllimit />
                            objWriter.WriteElementString("spelllimit",
                                _intFreeSpells.ToString(GlobalSettings.InvariantCultureInfo));
                            // <cfplimit />
                            objWriter.WriteElementString("cfplimit",
                                _intCFPLimit.ToString(GlobalSettings.InvariantCultureInfo));
                            // <totalaiprogramlimit />
                            objWriter.WriteElementString("ainormalprogramlimit",
                                _intAINormalProgramLimit.ToString(GlobalSettings.InvariantCultureInfo));
                            // <aiadvancedprogramlimit />
                            objWriter.WriteElementString("aiadvancedprogramlimit",
                                _intAIAdvancedProgramLimit.ToString(GlobalSettings.InvariantCultureInfo));
                            // <currentcounterspellingdice />
                            objWriter.WriteElementString("currentcounterspellingdice",
                                _intCurrentCounterspellingDice.ToString(GlobalSettings.InvariantCultureInfo));
                            // <currentliftcarryhits />
                            objWriter.WriteElementString("currentliftcarryhits",
                                _intCurrentLiftCarryHits.ToString(GlobalSettings.InvariantCultureInfo));
                            // <carrylimit />
                            objWriter.WriteElementString("basecarrylimit",
                                _decCachedBaseCarryLimit.ToString(GlobalSettings.InvariantCultureInfo));
                            // <liftlimit />
                            objWriter.WriteElementString("baseliftlimit",
                                _decCachedBaseLiftLimit.ToString(GlobalSettings.InvariantCultureInfo));
                            // <totalcarriedweight />
                            objWriter.WriteElementString("totalcarriedweight",
                                _decCachedTotalCarriedWeight.ToString(GlobalSettings.InvariantCultureInfo));
                            // <encumbranceinterval />
                            objWriter.WriteElementString("encumbranceinterval",
                                _decCachedEncumbranceInterval.ToString(GlobalSettings.InvariantCultureInfo));
                            // <streetcred />
                            objWriter.WriteElementString("streetcred",
                                _intStreetCred.ToString(GlobalSettings.InvariantCultureInfo));
                            // <notoriety />
                            objWriter.WriteElementString("notoriety",
                                _intNotoriety.ToString(GlobalSettings.InvariantCultureInfo));
                            // <publicaware />
                            objWriter.WriteElementString("publicawareness",
                                _intPublicAwareness.ToString(GlobalSettings.InvariantCultureInfo));
                            // <burntstreetcred />
                            objWriter.WriteElementString("burntstreetcred",
                                _intBurntStreetCred.ToString(GlobalSettings.InvariantCultureInfo));
                            // <baseastralreputation />
                            objWriter.WriteElementString("baseastralreputation",
                                _intBaseAstralReputation.ToString(GlobalSettings.InvariantCultureInfo));
                            // <basewildreputation />
                            objWriter.WriteElementString("basewildreputation",
                                _intBaseWildReputation.ToString(GlobalSettings.InvariantCultureInfo));
                            // <created />
                            objWriter.WriteElementString("created",
                                _blnCreated.ToString(GlobalSettings.InvariantCultureInfo));
                            // <nuyen />
                            objWriter.WriteElementString("nuyen", _decNuyen.ToString(GlobalSettings.InvariantCultureInfo));
                            // <startingnuyen />
                            objWriter.WriteElementString("startingnuyen",
                                _decStartingNuyen.ToString(GlobalSettings.InvariantCultureInfo));

                            // <nuyenbp />
                            objWriter.WriteElementString("nuyenbp",
                                _decNuyenBP.ToString(GlobalSettings.InvariantCultureInfo));

                            // <adept />
                            objWriter.WriteElementString("adept",
                                _blnAdeptEnabled.ToString(GlobalSettings.InvariantCultureInfo));
                            // <magician />
                            objWriter.WriteElementString("magician",
                                _blnMagicianEnabled.ToString(GlobalSettings.InvariantCultureInfo));
                            // <technomancer />
                            objWriter.WriteElementString("technomancer",
                                _blnTechnomancerEnabled.ToString(GlobalSettings.InvariantCultureInfo));
                            // <ai />
                            objWriter.WriteElementString("ai",
                                _blnAdvancedProgramsEnabled.ToString(GlobalSettings.InvariantCultureInfo));
                            // <cyberwaredisabled />
                            objWriter.WriteElementString("cyberwaredisabled",
                                _blnCyberwareDisabled.ToString(GlobalSettings.InvariantCultureInfo));
                            // <initiationdisabled />
                            objWriter.WriteElementString("initiationdisabled",
                                _blnInitiationDisabled.ToString(GlobalSettings.InvariantCultureInfo));
                            // <critter />
                            objWriter.WriteElementString("critter",
                                _blnCritterEnabled.ToString(GlobalSettings.InvariantCultureInfo));

                            // <prototypetranshuman />
                            objWriter.WriteElementString("prototypetranshuman",
                                _decPrototypeTranshuman.ToString(GlobalSettings.InvariantCultureInfo));

                            // <attributes>
                            objWriter.WriteStartElement("attributes");
                            AttributeSection.Save(objWriter, token);
                            // </attributes>
                            objWriter.WriteEndElement();

                            // <magenabled />
                            objWriter.WriteElementString("magenabled",
                                _blnMAGEnabled.ToString(GlobalSettings.InvariantCultureInfo));
                            // <initiategrade />
                            objWriter.WriteElementString("initiategrade",
                                _intInitiateGrade.ToString(GlobalSettings.InvariantCultureInfo));
                            // <resenabled />
                            objWriter.WriteElementString("resenabled",
                                _blnRESEnabled.ToString(GlobalSettings.InvariantCultureInfo));
                            // <submersiongrade />
                            objWriter.WriteElementString("submersiongrade",
                                _intSubmersionGrade.ToString(GlobalSettings.InvariantCultureInfo));
                            // <depenabled />
                            objWriter.WriteElementString("depenabled",
                                _blnDEPEnabled.ToString(GlobalSettings.InvariantCultureInfo));
                            // <groupmember />
                            objWriter.WriteElementString("groupmember",
                                _blnGroupMember.ToString(GlobalSettings.InvariantCultureInfo));
                            // <groupname />
                            objWriter.WriteElementString("groupname", _strGroupName);
                            // <groupnotes />
                            objWriter.WriteElementString("groupnotes", _strGroupNotes);

                            // External reader friendly stuff.
                            objWriter.WriteElementString("totaless",
                                Essence(token: token).ToString(GlobalSettings.InvariantCultureInfo));

                            // Write out the Mystic Adept MAG split info.
                            if (_blnAdeptEnabled && _blnMagicianEnabled)
                            {
                                objWriter.WriteElementString("magsplitadept",
                                    _intMAGAdept.ToString(GlobalSettings.InvariantCultureInfo));
                                objWriter.WriteElementString("magsplitmagician",
                                    _intMAGMagician.ToString(GlobalSettings.InvariantCultureInfo));
                            }

                            _objTradition?.Save(objWriter);

                            // Condition Monitor Progress.
                            // <physicalcmfilled />
                            objWriter.WriteElementString("physicalcmfilled",
                                _intPhysicalCMFilled.ToString(GlobalSettings.InvariantCultureInfo));
                            // <stuncmfilled />
                            objWriter.WriteElementString("stuncmfilled",
                                _intStunCMFilled.ToString(GlobalSettings.InvariantCultureInfo));

                            //<psyche />
                            objWriter.WriteElementString("psyche",
                                _blnPsycheActive.ToString(GlobalSettings.InvariantCultureInfo));

                            ///////////////////////////////////////////SKILLS

                            SkillsSection.Save(objWriter);

                            //Write copy of old skill groups, to not totally fuck a file if error
                            _oldSkillGroupBackup?.WriteTo(objWriter);
                            _oldSkillsBackup?.WriteTo(objWriter);

                            ///////////////////////////////////////////SKILLS

                            // <contacts>
                            objWriter.WriteStartElement("contacts");
                            foreach (Contact objContact in _lstContacts)
                            {
                                objContact.Save(objWriter);
                            }

                            // </contacts>
                            objWriter.WriteEndElement();

                            // <spells>
                            objWriter.WriteStartElement("spells");
                            foreach (Spell objSpell in _lstSpells)
                            {
                                objSpell.Save(objWriter);
                            }

                            // </spells>
                            objWriter.WriteEndElement();

                            // <foci>
                            objWriter.WriteStartElement("foci");
                            foreach (Focus objFocus in _lstFoci)
                            {
                                objFocus.Save(objWriter);
                            }

                            // </foci>
                            objWriter.WriteEndElement();

                            // <stackedfoci>
                            objWriter.WriteStartElement("stackedfoci");
                            foreach (StackedFocus objStack in _lstStackedFoci)
                            {
                                objStack.Save(objWriter);
                            }

                            // </stackedfoci>
                            objWriter.WriteEndElement();

                            // <powers>
                            objWriter.WriteStartElement("powers");
                            foreach (Power objPower in _lstPowers)
                            {
                                objPower.Save(objWriter);
                            }

                            // </powers>
                            objWriter.WriteEndElement();

                            // <spirits>
                            objWriter.WriteStartElement("spirits");
                            foreach (Spirit objSpirit in _lstSpirits)
                            {
                                objSpirit.Save(objWriter);
                            }

                            // </spirits>
                            objWriter.WriteEndElement();

                            // <complexforms>
                            objWriter.WriteStartElement("complexforms");
                            foreach (ComplexForm objComplexForm in _lstComplexForms)
                            {
                                objComplexForm.Save(objWriter);
                            }

                            // </complexforms>
                            objWriter.WriteEndElement();

                            // <aiprograms>
                            objWriter.WriteStartElement("aiprograms");
                            foreach (AIProgram objProgram in _lstAIPrograms)
                            {
                                objProgram.Save(objWriter);
                            }

                            // </aiprograms>
                            objWriter.WriteEndElement();

                            // <martialarts>
                            objWriter.WriteStartElement("martialarts");
                            foreach (MartialArt objMartialArt in _lstMartialArts)
                            {
                                objMartialArt.Save(objWriter);
                            }

                            // </martialarts>
                            objWriter.WriteEndElement();

                            // <limitmodifiers>
                            objWriter.WriteStartElement("limitmodifiers");
                            foreach (LimitModifier objLimitModifier in _lstLimitModifiers)
                            {
                                objLimitModifier.Save(objWriter);
                            }

                            // </limitmodifiers>
                            objWriter.WriteEndElement();

                            // <armors>
                            objWriter.WriteStartElement("armors");
                            foreach (Armor objArmor in _lstArmor)
                            {
                                objArmor.Save(objWriter);
                            }

                            // </armors>
                            objWriter.WriteEndElement();

                            // <weapons>
                            objWriter.WriteStartElement("weapons");
                            foreach (Weapon objWeapon in _lstWeapons)
                            {
                                objWeapon.Save(objWriter);
                            }

                            // </weapons>
                            objWriter.WriteEndElement();

                            // <cyberwares>
                            objWriter.WriteStartElement("cyberwares");
                            foreach (Cyberware objCyberware in _lstCyberware)
                            {
                                objCyberware.Save(objWriter);
                            }

                            // </cyberwares>
                            objWriter.WriteEndElement();

                            // <qualities>
                            objWriter.WriteStartElement("qualities");
                            foreach (Quality objQuality in _lstQualities)
                            {
                                objQuality.Save(objWriter);
                            }

                            // </qualities>
                            objWriter.WriteEndElement();

                            // <lifestyles>
                            objWriter.WriteStartElement("lifestyles");
                            foreach (Lifestyle objLifestyle in _lstLifestyles)
                            {
                                objLifestyle.Save(objWriter);
                            }

                            // </lifestyles>
                            objWriter.WriteEndElement();

                            // <gears>
                            objWriter.WriteStartElement("gears");
                            foreach (Gear objGear in _lstGear)
                            {
                                objGear.Save(objWriter);
                            }

                            // </gears>
                            objWriter.WriteEndElement();

                            // <vehicles>
                            objWriter.WriteStartElement("vehicles");
                            foreach (Vehicle objVehicle in _lstVehicles)
                            {
                                objVehicle.Save(objWriter);
                            }

                            // </vehicles>
                            objWriter.WriteEndElement();

                            // <metamagics>
                            objWriter.WriteStartElement("metamagics");
                            foreach (Metamagic objMetamagic in _lstMetamagics)
                            {
                                objMetamagic.Save(objWriter);
                            }

                            // </metamagics>
                            objWriter.WriteEndElement();

                            // <arts>
                            objWriter.WriteStartElement("arts");
                            foreach (Art objArt in _lstArts)
                            {
                                objArt.Save(objWriter);
                            }

                            // </arts>
                            objWriter.WriteEndElement();

                            // <enhancements>
                            objWriter.WriteStartElement("enhancements");
                            foreach (Enhancement objEnhancement in _lstEnhancements)
                            {
                                objEnhancement.Save(objWriter);
                            }

                            // </enhancements>
                            objWriter.WriteEndElement();

                            // <critterpowers>
                            objWriter.WriteStartElement("critterpowers");
                            foreach (CritterPower objPower in _lstCritterPowers)
                            {
                                objPower.Save(objWriter);
                            }

                            // </critterpowers>
                            objWriter.WriteEndElement();

                            // <initiationgrades>
                            objWriter.WriteStartElement("initiationgrades");
                            foreach (InitiationGrade objGrade in _lstInitiationGrades)
                            {
                                objGrade.Save(objWriter);
                            }

                            // </initiationgrades>
                            objWriter.WriteEndElement();

                            // <improvements>
                            objWriter.WriteStartElement("improvements");
                            foreach (Improvement objImprovement in _lstImprovements)
                            {
                                objImprovement.Save(objWriter);
                            }

                            // </improvements>
                            objWriter.WriteEndElement();

                            // <sustained>
                            objWriter.WriteStartElement("sustainedobjects");
                            foreach (SustainedObject objSustained in _lstSustainedObjects)
                            {
                                objSustained.Save(objWriter);
                            }

                            // </sustained>
                            objWriter.WriteEndElement();

                            // <drugs>
                            objWriter.WriteStartElement("drugs");
                            foreach (Drug objDrug in _lstDrugs)
                            {
                                objDrug.Save(objWriter);
                            }

                            // </drugs>
                            objWriter.WriteEndElement();

                            // <mentorspirits>
                            objWriter.WriteStartElement("mentorspirits");
                            foreach (MentorSpirit objMentor in _lstMentorSpirits)
                            {
                                objMentor.Save(objWriter);
                            }

                            // </mentorspirits>
                            objWriter.WriteEndElement();

                            // <expenses>
                            objWriter.WriteStartElement("expenses");
                            foreach (ExpenseLogEntry objExpenseLogEntry in _lstExpenseLog)
                            {
                                objExpenseLogEntry.Save(objWriter);
                            }

                            // </expenses>
                            objWriter.WriteEndElement();

                            // <locations>
                            objWriter.WriteStartElement("gearlocations");
                            foreach (Location objLocation in _lstGearLocations)
                            {
                                objLocation.Save(objWriter);
                            }

                            // </locations>
                            objWriter.WriteEndElement();

                            // <armorlocations>
                            objWriter.WriteStartElement("armorlocations");
                            foreach (Location objLocation in _lstArmorLocations)
                            {
                                objLocation.Save(objWriter);
                            }

                            // </armorlocations>
                            objWriter.WriteEndElement();

                            // <vehiclelocations>
                            objWriter.WriteStartElement("vehiclelocations");
                            foreach (Location objLocation in _lstVehicleLocations)
                            {
                                objLocation.Save(objWriter);
                            }

                            // </vehiclelocations>
                            objWriter.WriteEndElement();

                            // <weaponlocations>
                            objWriter.WriteStartElement("weaponlocations");
                            foreach (Location objLocation in _lstWeaponLocations)
                            {
                                objLocation.Save(objWriter);
                            }

                            // </weaponlocations>
                            objWriter.WriteEndElement();

                            // <improvementgroups>
                            objWriter.WriteStartElement("improvementgroups");
                            foreach (string strGroup in _lstImprovementGroups)
                            {
                                objWriter.WriteElementString("improvementgroup", strGroup);
                            }

                            // </improvementgroups>
                            objWriter.WriteEndElement();

                            // <calendar>
                            objWriter.WriteStartElement("calendar");
                            foreach (CalendarWeek objWeek in _lstCalendar)
                            {
                                objWeek.Save(objWriter);
                            }

                            // </calendar>
                            objWriter.WriteEndElement();

                            //Plugins
                            if (Program.PluginLoader?.MyActivePlugins?.Count > 0)
                            {
                                // <plugins>
                                objWriter.WriteStartElement("plugins");
                                foreach (IPlugin plugin in Program.PluginLoader.MyActivePlugins)
                                {
                                    try
                                    {
                                        System.Reflection.Assembly pluginAssm = plugin.GetPluginAssembly();
                                        objWriter.WriteStartElement(pluginAssm.GetName().Name);
                                        objWriter.WriteAttributeString("version", pluginAssm.GetName().Version.ToString());
                                        objWriter.WriteString(plugin.GetSaveToFileElement(this));
                                        objWriter.WriteEndElement();
                                    }
                                    catch (Exception e)
                                    {
                                        Log.Warn(e, "Exception while writing saveFileElement for plugin " + plugin + ": ");
                                    }
                                }

                                //</plugins>
                                objWriter.WriteEndElement();
                            }

                            //calculatedValues
                            objWriter.WriteStartElement("calculatedvalues");
                            objWriter.WriteComment(
                                "these values are not loaded and only stored here for third parties, who parse this files (to not have to calculate them themselves)");
                            objWriter.WriteElementString("physicalcm",
                                PhysicalCM.ToString(GlobalSettings.InvariantCultureInfo));
                            objWriter.WriteElementString("physicalcmthresholdoffset",
                                PhysicalCMThresholdOffset.ToString(GlobalSettings.InvariantCultureInfo));
                            objWriter.WriteElementString("physicalcmoverflow",
                                CMOverflow.ToString(GlobalSettings.InvariantCultureInfo));
                            objWriter.WriteElementString("stuncm", StunCM.ToString(GlobalSettings.InvariantCultureInfo));
                            objWriter.WriteElementString("stuncmthresholdoffset",
                                StunCMThresholdOffset.ToString(GlobalSettings.InvariantCultureInfo));
                            objWriter.WriteEndElement();
                            // </calculatedValues>

                            // </character>
                            objWriter.WriteEndElement();

                            objWriter.WriteEndDocument();
                            objWriter.Flush();
                        }

                        objStream.Position = 0;

                        // Validate that the character can save properly. If there's no error, save the file to the listed file location.
                        try
                        {
                            XmlDocument objDoc = new XmlDocument { XmlResolver = null };
                            using (XmlReader objXmlReader
                                   = XmlReader.Create(objStream, GlobalSettings.SafeXmlReaderSettings))
                                objDoc.Load(objXmlReader);
                            objDoc.Save(strFileName);
                        }
                        catch (IOException e)
                        {
                            Log.Error(e);
                            if (Utils.IsUnitTest)
                                throw;
                            // ReSharper disable once MethodHasAsyncOverload
                            Program.ShowMessageBox(LanguageManager.GetString("Message_Save_Error_Warning", token: token));
                            blnErrorFree = false;
                        }
                        catch (XmlException ex)
                        {
                            Log.Warn(ex);
                            if (Utils.IsUnitTest)
                                throw;
                            // ReSharper disable once MethodHasAsyncOverload
                            Program.ShowMessageBox(LanguageManager.GetString("Message_Save_Error_Warning", token: token));
                            blnErrorFree = false;
                        }
                        catch (UnauthorizedAccessException) when (!Utils.IsUnitTest)
                        {
                            // ReSharper disable once MethodHasAsyncOverload
                            Program.ShowMessageBox(LanguageManager.GetString("Message_Save_Error_Warning", token: token));
                            blnErrorFree = false;
                        }
                    }
                }

                async Task DoSaveAsync(CancellationToken innerToken = default)
                {
                    using (MemoryStream objStream = new MemoryStream())
                    {
                        using (XmlWriter objWriter = Utils.GetStandardXmlWriter(objStream))
                        {
                            await objWriter.WriteStartDocumentAsync();

                            // <character>
                            await objWriter.WriteStartElementAsync("character", token: innerToken);

                            // <createdversion />
                            await objWriter.WriteElementStringAsync("createdversion", _strVersionCreated, token: innerToken);
                            // <minimumappversion />
                            await objWriter.WriteElementStringAsync("minimumappversion", "5.214.1", token: innerToken);
                            // <appversion />
                            await objWriter.WriteElementStringAsync("appversion",
                                Application.ProductVersion.FastEscapeOnceFromStart("0.0."), token: innerToken);
                            // <gameedition />
                            await objWriter.WriteElementStringAsync("gameedition", "SR5", token: innerToken);

                            // <settings />
                            await objWriter.WriteElementStringAsync("settings", _strSettingsKey, token: innerToken);
                            // <buildmethod />
                            await objWriter.WriteElementStringAsync("buildmethod", Settings.BuildMethod.ToString(), token: innerToken);

                            // <sources>
                            await objWriter.WriteStartElementAsync("sources", token: innerToken);
                            foreach (string strBook in Settings.Books)
                            {
                                await objWriter.WriteElementStringAsync("source", strBook, token: innerToken);
                            }

                            // </sources>
                            await objWriter.WriteEndElementAsync();

                            if (Settings.EnabledCustomDataDirectoryInfos.Count > 0)
                            {
                                // <customdatadirectorynames>
                                await objWriter.WriteStartElementAsync("customdatadirectorynames", token: innerToken);
                                foreach (string strDirectoryName in Settings.EnabledCustomDataDirectoryInfos.Select(x =>
                                             x.Name))
                                {
                                    await objWriter.WriteElementStringAsync("directoryname", strDirectoryName, token: innerToken);
                                }

                                // </customdatadirectorynames>
                                await objWriter.WriteEndElementAsync();
                            }

                            // <metatype />
                            await objWriter.WriteElementStringAsync("metatype", _strMetatype, token: innerToken);
                            // <metatypeid />
                            await objWriter.WriteElementStringAsync("metatypeid",
                                _guiMetatype.ToString("D", GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <metatypebp />
                            await objWriter.WriteElementStringAsync("metatypebp",
                                _intMetatypeBP.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <metavariant />
                            await objWriter.WriteElementStringAsync("metavariant", _strMetavariant, token: innerToken);
                            // <metavariantid />
                            await objWriter.WriteElementStringAsync("metavariantid",
                                _guiMetavariant.ToString("D", GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <metatypecategory />
                            await objWriter.WriteElementStringAsync("metatypecategory", _strMetatypeCategory, token: innerToken);
                            // <movement />
                            await objWriter.WriteElementStringAsync("movement", _strMovement, token: innerToken);
                            // <walk />
                            await objWriter.WriteElementStringAsync("walk", _strWalk, token: innerToken);
                            // <run />
                            await objWriter.WriteElementStringAsync("run", _strRun, token: innerToken);
                            // <sprint />
                            await objWriter.WriteElementStringAsync("sprint", _strSprint, token: innerToken);
                            // <walk />
                            await objWriter.WriteElementStringAsync("walkalt", _strWalk, token: innerToken);
                            // <run />
                            await objWriter.WriteElementStringAsync("runalt", _strRun, token: innerToken);
                            // <sprint />
                            await objWriter.WriteElementStringAsync("sprintalt", _strSprint, token: innerToken);
                            // <initiativedice />
                            await objWriter.WriteElementStringAsync("initiativedice",
                                _intInitiativeDice.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);

                            // <prioritymetatype />
                            await objWriter.WriteElementStringAsync("prioritymetatype", _strPriorityMetatype, token: innerToken);
                            // <priorityattributes />
                            await objWriter.WriteElementStringAsync("priorityattributes", _strPriorityAttributes, token: innerToken);
                            // <priorityspecial />
                            await objWriter.WriteElementStringAsync("priorityspecial", _strPrioritySpecial, token: innerToken);
                            // <priorityskills />
                            await objWriter.WriteElementStringAsync("priorityskills", _strPrioritySkills, token: innerToken);
                            // <priorityresources />
                            await objWriter.WriteElementStringAsync("priorityresources", _strPriorityResources, token: innerToken);
                            // <priorityresources />
                            await objWriter.WriteElementStringAsync("prioritytalent", _strPriorityTalent, token: innerToken);
                            // <priorityskills >
                            await objWriter.WriteStartElementAsync("priorityskills", token: innerToken);
                            foreach (string strSkill in _lstPrioritySkills)
                            {
                                await objWriter.WriteElementStringAsync("priorityskill", strSkill, token: innerToken);
                            }

                            // </priorityskills>
                            await objWriter.WriteEndElementAsync();

                            // <essenceatspecialstart />
                            await objWriter.WriteElementStringAsync("essenceatspecialstart",
                                _decEssenceAtSpecialStart.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);

                            // <name />
                            await objWriter.WriteElementStringAsync("name", _strName, token: innerToken);
                            await SaveMugshotsAsync(objWriter, innerToken);

                            // <gender />
                            await objWriter.WriteElementStringAsync("gender", _strGender, token: innerToken);
                            // <age />
                            await objWriter.WriteElementStringAsync("age", _strAge, token: innerToken);
                            // <eyes />
                            await objWriter.WriteElementStringAsync("eyes", _strEyes, token: innerToken);
                            // <height />
                            await objWriter.WriteElementStringAsync("height", _strHeight, token: innerToken);
                            // <weight />
                            await objWriter.WriteElementStringAsync("weight", _strWeight, token: innerToken);
                            // <skin />
                            await objWriter.WriteElementStringAsync("skin", _strSkin, token: innerToken);
                            // <hair />
                            await objWriter.WriteElementStringAsync("hair", _strHair, token: innerToken);
                            // <description />
                            await objWriter.WriteElementStringAsync("description", _strDescription, token: innerToken);
                            // <background />
                            await objWriter.WriteElementStringAsync("background", _strBackground, token: innerToken);
                            // <concept />
                            await objWriter.WriteElementStringAsync("concept", _strConcept, token: innerToken);
                            // <notes />
                            await objWriter.WriteElementStringAsync("notes", _strNotes.CleanOfInvalidUnicodeChars(), token: innerToken);
                            // <alias />
                            await objWriter.WriteElementStringAsync("alias", _strAlias, token: innerToken);
                            // <playername />
                            await objWriter.WriteElementStringAsync("playername", _strPlayerName, token: innerToken);
                            // <gamenotes />
                            await objWriter.WriteElementStringAsync("gamenotes", _strGameNotes, token: innerToken);
                            // <primaryarm />
                            await objWriter.WriteElementStringAsync("primaryarm", _strPrimaryArm, token: innerToken);

                            // <ignorerules />
                            if (_blnIgnoreRules)
                                await objWriter.WriteElementStringAsync("ignorerules",
                                    _blnIgnoreRules.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <iscritter />
                            if (_blnIsCritter)
                                await objWriter.WriteElementStringAsync("iscritter",
                                    _blnIsCritter.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            if (_blnPossessed)
                                await objWriter.WriteElementStringAsync("possessed",
                                    _blnPossessed.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <karma />
                            await objWriter.WriteElementStringAsync(
                                "karma", _intKarma.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <special />
                            await objWriter.WriteElementStringAsync("special",
                                _intSpecial.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <totalspecial />
                            await objWriter.WriteElementStringAsync("totalspecial",
                                _intTotalSpecial.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <totalattributes />
                            await objWriter.WriteElementStringAsync("totalattributes",
                                _intTotalAttributes.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <edgeused />
                            await objWriter.WriteElementStringAsync("edgeused",
                                _intEdgeUsed.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <contactpoints />
                            await objWriter.WriteElementStringAsync("contactpoints",
                                _intCachedContactPoints.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <contactpointsused />
                            await objWriter.WriteElementStringAsync("contactpointsused",
                                _intContactPointsUsed.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <spelllimit />
                            await objWriter.WriteElementStringAsync("spelllimit",
                                _intFreeSpells.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <cfplimit />
                            await objWriter.WriteElementStringAsync("cfplimit",
                                _intCFPLimit.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <totalaiprogramlimit />
                            await objWriter.WriteElementStringAsync("ainormalprogramlimit",
                                _intAINormalProgramLimit.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <aiadvancedprogramlimit />
                            await objWriter.WriteElementStringAsync("aiadvancedprogramlimit",
                                _intAIAdvancedProgramLimit.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <currentcounterspellingdice />
                            await objWriter.WriteElementStringAsync("currentcounterspellingdice",
                                _intCurrentCounterspellingDice.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <currentliftcarryhits />
                            await objWriter.WriteElementStringAsync("currentliftcarryhits",
                                _intCurrentLiftCarryHits.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <carrylimit />
                            await objWriter.WriteElementStringAsync("basecarrylimit",
                                _decCachedBaseCarryLimit.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <liftlimit />
                            await objWriter.WriteElementStringAsync("baseliftlimit",
                                _decCachedBaseLiftLimit.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <totalcarriedweight />
                            await objWriter.WriteElementStringAsync("totalcarriedweight",
                                _decCachedTotalCarriedWeight.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <encumbranceinterval />
                            await objWriter.WriteElementStringAsync("encumbranceinterval",
                                _decCachedEncumbranceInterval.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <streetcred />
                            await objWriter.WriteElementStringAsync("streetcred",
                                _intStreetCred.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <notoriety />
                            await objWriter.WriteElementStringAsync("notoriety",
                                _intNotoriety.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <publicaware />
                            await objWriter.WriteElementStringAsync("publicawareness",
                                _intPublicAwareness.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <burntstreetcred />
                            await objWriter.WriteElementStringAsync("burntstreetcred",
                                _intBurntStreetCred.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <baseastralreputation />
                            await objWriter.WriteElementStringAsync("baseastralreputation",
                                _intBaseAstralReputation.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <basewildreputation />
                            await objWriter.WriteElementStringAsync("basewildreputation",
                                _intBaseWildReputation.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <created />
                            await objWriter.WriteElementStringAsync("created",
                                _blnCreated.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <nuyen />
                            await objWriter.WriteElementStringAsync(
                                "nuyen", _decNuyen.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <startingnuyen />
                            await objWriter.WriteElementStringAsync("startingnuyen",
                                _decStartingNuyen.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);

                            // <nuyenbp />
                            await objWriter.WriteElementStringAsync("nuyenbp",
                                _decNuyenBP.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);

                            // <adept />
                            await objWriter.WriteElementStringAsync("adept",
                                _blnAdeptEnabled.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <magician />
                            await objWriter.WriteElementStringAsync("magician",
                                _blnMagicianEnabled.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <technomancer />
                            await objWriter.WriteElementStringAsync("technomancer",
                                _blnTechnomancerEnabled.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <ai />
                            await objWriter.WriteElementStringAsync("ai",
                                _blnAdvancedProgramsEnabled.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <cyberwaredisabled />
                            await objWriter.WriteElementStringAsync("cyberwaredisabled",
                                _blnCyberwareDisabled.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <initiationdisabled />
                            await objWriter.WriteElementStringAsync("initiationdisabled",
                                _blnInitiationDisabled.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <critter />
                            await objWriter.WriteElementStringAsync("critter",
                                _blnCritterEnabled.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);

                            // <prototypetranshuman />
                            await objWriter.WriteElementStringAsync("prototypetranshuman",
                                _decPrototypeTranshuman.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);

                            // <attributes>
                            await objWriter.WriteStartElementAsync("attributes", token: innerToken);
                            AttributeSection.Save(objWriter, token);
                            // </attributes>
                            await objWriter.WriteEndElementAsync();

                            // <magenabled />
                            await objWriter.WriteElementStringAsync("magenabled",
                                _blnMAGEnabled.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <initiategrade />
                            await objWriter.WriteElementStringAsync("initiategrade",
                                _intInitiateGrade.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <resenabled />
                            await objWriter.WriteElementStringAsync("resenabled",
                                _blnRESEnabled.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <submersiongrade />
                            await objWriter.WriteElementStringAsync("submersiongrade",
                                _intSubmersionGrade.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <depenabled />
                            await objWriter.WriteElementStringAsync("depenabled",
                                _blnDEPEnabled.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <groupmember />
                            await objWriter.WriteElementStringAsync("groupmember",
                                _blnGroupMember.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <groupname />
                            await objWriter.WriteElementStringAsync("groupname", _strGroupName, token: innerToken);
                            // <groupnotes />
                            await objWriter.WriteElementStringAsync("groupnotes", _strGroupNotes, token: innerToken);

                            // External reader friendly stuff.
                            await objWriter.WriteElementStringAsync("totaless",
                                (await EssenceAsync(token: innerToken)).ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);

                            // Write out the Mystic Adept MAG split info.
                            if (_blnAdeptEnabled && _blnMagicianEnabled)
                            {
                                await objWriter.WriteElementStringAsync("magsplitadept",
                                    _intMAGAdept.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                                await objWriter.WriteElementStringAsync("magsplitmagician",
                                    _intMAGMagician.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            }

                            _objTradition?.Save(objWriter);

                            // Condition Monitor Progress.
                            // <physicalcmfilled />
                            await objWriter.WriteElementStringAsync("physicalcmfilled",
                                _intPhysicalCMFilled.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            // <stuncmfilled />
                            await objWriter.WriteElementStringAsync("stuncmfilled",
                                _intStunCMFilled.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);

                            //<psyche />
                            await objWriter.WriteElementStringAsync("psyche",
                                _blnPsycheActive.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);

                            ///////////////////////////////////////////SKILLS

                            SkillsSection.Save(objWriter);

                            //Write copy of old skill groups, to not totally fuck a file if error
                            _oldSkillGroupBackup?.WriteTo(objWriter);
                            _oldSkillsBackup?.WriteTo(objWriter);

                            ///////////////////////////////////////////SKILLS

                            // <contacts>
                            await objWriter.WriteStartElementAsync("contacts", token: innerToken);
                            foreach (Contact objContact in _lstContacts)
                            {
                                await objContact.SaveAsync(objWriter);
                            }

                            // </contacts>
                            await objWriter.WriteEndElementAsync();

                            // <spells>
                            await objWriter.WriteStartElementAsync("spells", token: innerToken);
                            foreach (Spell objSpell in _lstSpells)
                            {
                                objSpell.Save(objWriter);
                            }

                            // </spells>
                            await objWriter.WriteEndElementAsync();

                            // <foci>
                            await objWriter.WriteStartElementAsync("foci", token: innerToken);
                            foreach (Focus objFocus in _lstFoci)
                            {
                                objFocus.Save(objWriter);
                            }

                            // </foci>
                            await objWriter.WriteEndElementAsync();

                            // <stackedfoci>
                            await objWriter.WriteStartElementAsync("stackedfoci", token: innerToken);
                            foreach (StackedFocus objStack in _lstStackedFoci)
                            {
                                objStack.Save(objWriter);
                            }

                            // </stackedfoci>
                            await objWriter.WriteEndElementAsync();

                            // <powers>
                            await objWriter.WriteStartElementAsync("powers", token: innerToken);
                            foreach (Power objPower in _lstPowers)
                            {
                                objPower.Save(objWriter);
                            }

                            // </powers>
                            await objWriter.WriteEndElementAsync();

                            // <spirits>
                            await objWriter.WriteStartElementAsync("spirits", token: innerToken);
                            foreach (Spirit objSpirit in _lstSpirits)
                            {
                                await objSpirit.SaveAsync(objWriter);
                            }

                            // </spirits>
                            await objWriter.WriteEndElementAsync();

                            // <complexforms>
                            await objWriter.WriteStartElementAsync("complexforms", token: innerToken);
                            foreach (ComplexForm objComplexForm in _lstComplexForms)
                            {
                                objComplexForm.Save(objWriter);
                            }

                            // </complexforms>
                            await objWriter.WriteEndElementAsync();

                            // <aiprograms>
                            await objWriter.WriteStartElementAsync("aiprograms", token: innerToken);
                            foreach (AIProgram objProgram in _lstAIPrograms)
                            {
                                objProgram.Save(objWriter);
                            }

                            // </aiprograms>
                            await objWriter.WriteEndElementAsync();

                            // <martialarts>
                            await objWriter.WriteStartElementAsync("martialarts", token: innerToken);
                            foreach (MartialArt objMartialArt in _lstMartialArts)
                            {
                                objMartialArt.Save(objWriter);
                            }

                            // </martialarts>
                            await objWriter.WriteEndElementAsync();

                            // <limitmodifiers>
                            await objWriter.WriteStartElementAsync("limitmodifiers", token: innerToken);
                            foreach (LimitModifier objLimitModifier in _lstLimitModifiers)
                            {
                                objLimitModifier.Save(objWriter);
                            }

                            // </limitmodifiers>
                            await objWriter.WriteEndElementAsync();

                            // <armors>
                            await objWriter.WriteStartElementAsync("armors", token: innerToken);
                            foreach (Armor objArmor in _lstArmor)
                            {
                                objArmor.Save(objWriter);
                            }

                            // </armors>
                            await objWriter.WriteEndElementAsync();

                            // <weapons>
                            await objWriter.WriteStartElementAsync("weapons", token: innerToken);
                            foreach (Weapon objWeapon in _lstWeapons)
                            {
                                objWeapon.Save(objWriter);
                            }

                            // </weapons>
                            await objWriter.WriteEndElementAsync();

                            // <cyberwares>
                            await objWriter.WriteStartElementAsync("cyberwares", token: innerToken);
                            foreach (Cyberware objCyberware in _lstCyberware)
                            {
                                objCyberware.Save(objWriter);
                            }

                            // </cyberwares>
                            await objWriter.WriteEndElementAsync();

                            // <qualities>
                            await objWriter.WriteStartElementAsync("qualities", token: innerToken);
                            foreach (Quality objQuality in _lstQualities)
                            {
                                objQuality.Save(objWriter);
                            }

                            // </qualities>
                            await objWriter.WriteEndElementAsync();

                            // <lifestyles>
                            await objWriter.WriteStartElementAsync("lifestyles", token: innerToken);
                            foreach (Lifestyle objLifestyle in _lstLifestyles)
                            {
                                objLifestyle.Save(objWriter);
                            }

                            // </lifestyles>
                            await objWriter.WriteEndElementAsync();

                            // <gears>
                            await objWriter.WriteStartElementAsync("gears", token: innerToken);
                            foreach (Gear objGear in _lstGear)
                            {
                                objGear.Save(objWriter);
                            }

                            // </gears>
                            await objWriter.WriteEndElementAsync();

                            // <vehicles>
                            await objWriter.WriteStartElementAsync("vehicles", token: innerToken);
                            foreach (Vehicle objVehicle in _lstVehicles)
                            {
                                objVehicle.Save(objWriter);
                            }

                            // </vehicles>
                            await objWriter.WriteEndElementAsync();

                            // <metamagics>
                            await objWriter.WriteStartElementAsync("metamagics", token: innerToken);
                            foreach (Metamagic objMetamagic in _lstMetamagics)
                            {
                                objMetamagic.Save(objWriter);
                            }

                            // </metamagics>
                            await objWriter.WriteEndElementAsync();

                            // <arts>
                            await objWriter.WriteStartElementAsync("arts", token: innerToken);
                            foreach (Art objArt in _lstArts)
                            {
                                objArt.Save(objWriter);
                            }

                            // </arts>
                            await objWriter.WriteEndElementAsync();

                            // <enhancements>
                            await objWriter.WriteStartElementAsync("enhancements", token: innerToken);
                            foreach (Enhancement objEnhancement in _lstEnhancements)
                            {
                                objEnhancement.Save(objWriter);
                            }

                            // </enhancements>
                            await objWriter.WriteEndElementAsync();

                            // <critterpowers>
                            await objWriter.WriteStartElementAsync("critterpowers", token: innerToken);
                            foreach (CritterPower objPower in _lstCritterPowers)
                            {
                                objPower.Save(objWriter);
                            }

                            // </critterpowers>
                            await objWriter.WriteEndElementAsync();

                            // <initiationgrades>
                            await objWriter.WriteStartElementAsync("initiationgrades", token: innerToken);
                            foreach (InitiationGrade objGrade in _lstInitiationGrades)
                            {
                                objGrade.Save(objWriter);
                            }

                            // </initiationgrades>
                            await objWriter.WriteEndElementAsync();

                            // <improvements>
                            await objWriter.WriteStartElementAsync("improvements", token: innerToken);
                            foreach (Improvement objImprovement in _lstImprovements)
                            {
                                objImprovement.Save(objWriter);
                            }

                            // </improvements>
                            await objWriter.WriteEndElementAsync();

                            // <sustained>
                            await objWriter.WriteStartElementAsync("sustainedobjects", token: innerToken);
                            foreach (SustainedObject objSustained in _lstSustainedObjects)
                            {
                                objSustained.Save(objWriter);
                            }

                            // </sustained>
                            await objWriter.WriteEndElementAsync();

                            // <drugs>
                            await objWriter.WriteStartElementAsync("drugs", token: innerToken);
                            foreach (Drug objDrug in _lstDrugs)
                            {
                                objDrug.Save(objWriter);
                            }

                            // </drugs>
                            await objWriter.WriteEndElementAsync();

                            // <mentorspirits>
                            await objWriter.WriteStartElementAsync("mentorspirits", token: innerToken);
                            foreach (MentorSpirit objMentor in _lstMentorSpirits)
                            {
                                objMentor.Save(objWriter);
                            }

                            // </mentorspirits>
                            await objWriter.WriteEndElementAsync();

                            // <expenses>
                            await objWriter.WriteStartElementAsync("expenses", token: innerToken);
                            foreach (ExpenseLogEntry objExpenseLogEntry in _lstExpenseLog)
                            {
                                objExpenseLogEntry.Save(objWriter);
                            }

                            // </expenses>
                            await objWriter.WriteEndElementAsync();

                            // <locations>
                            await objWriter.WriteStartElementAsync("gearlocations", token: innerToken);
                            foreach (Location objLocation in _lstGearLocations)
                            {
                                objLocation.Save(objWriter);
                            }

                            // </locations>
                            await objWriter.WriteEndElementAsync();

                            // <armorlocations>
                            await objWriter.WriteStartElementAsync("armorlocations", token: innerToken);
                            foreach (Location objLocation in _lstArmorLocations)
                            {
                                objLocation.Save(objWriter);
                            }

                            // </armorlocations>
                            await objWriter.WriteEndElementAsync();

                            // <vehiclelocations>
                            await objWriter.WriteStartElementAsync("vehiclelocations", token: innerToken);
                            foreach (Location objLocation in _lstVehicleLocations)
                            {
                                objLocation.Save(objWriter);
                            }

                            // </vehiclelocations>
                            await objWriter.WriteEndElementAsync();

                            // <weaponlocations>
                            await objWriter.WriteStartElementAsync("weaponlocations", token: innerToken);
                            foreach (Location objLocation in _lstWeaponLocations)
                            {
                                objLocation.Save(objWriter);
                            }

                            // </weaponlocations>
                            await objWriter.WriteEndElementAsync();

                            // <improvementgroups>
                            await objWriter.WriteStartElementAsync("improvementgroups", token: innerToken);
                            foreach (string strGroup in _lstImprovementGroups)
                            {
                                await objWriter.WriteElementStringAsync("improvementgroup", strGroup, token: innerToken);
                            }

                            // </improvementgroups>
                            await objWriter.WriteEndElementAsync();

                            // <calendar>
                            await objWriter.WriteStartElementAsync("calendar", token: innerToken);
                            foreach (CalendarWeek objWeek in _lstCalendar)
                            {
                                objWeek.Save(objWriter);
                            }

                            await objWriter.WriteEndElementAsync();
                            // </calendar>

                            //Plugins
                            if (Program.PluginLoader?.MyActivePlugins?.Count > 0)
                            {
                                // <plugins>
                                await objWriter.WriteStartElementAsync("plugins", token: innerToken);
                                foreach (IPlugin plugin in Program.PluginLoader.MyActivePlugins)
                                {
                                    try
                                    {
                                        System.Reflection.Assembly pluginAssm = plugin.GetPluginAssembly();
                                        await objWriter.WriteStartElementAsync(pluginAssm.GetName().Name, token: innerToken);
                                        await objWriter.WriteAttributeStringAsync("version", pluginAssm.GetName().Version.ToString(), token: innerToken);
                                        await objWriter.WriteStringAsync(plugin.GetSaveToFileElement(this));
                                        await objWriter.WriteEndElementAsync();
                                    }
                                    catch (Exception e)
                                    {
                                        Log.Warn(e, "Exception while writing saveFileElement for plugin " + plugin + ": ");
                                    }
                                }

                                //</plugins>
                                await objWriter.WriteEndElementAsync();
                            }

                            //calculatedValues
                            await objWriter.WriteStartElementAsync("calculatedvalues", token: innerToken);
                            await objWriter.WriteCommentAsync(
                                "these values are not loaded and only stored here for third parties, who parse this files (to not have to calculate them themselves)");
                            await objWriter.WriteElementStringAsync("physicalcm",
                                PhysicalCM.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            await objWriter.WriteElementStringAsync("physicalcmthresholdoffset",
                                PhysicalCMThresholdOffset.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            await objWriter.WriteElementStringAsync("physicalcmoverflow",
                                CMOverflow.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            await objWriter.WriteElementStringAsync("stuncm", StunCM.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            await objWriter.WriteElementStringAsync("stuncmthresholdoffset",
                                StunCMThresholdOffset.ToString(GlobalSettings.InvariantCultureInfo), token: innerToken);
                            await objWriter.WriteEndElementAsync();
                            // </calculatedValues>

                            // </character>
                            await objWriter.WriteEndElementAsync();

                            await objWriter.WriteEndDocumentAsync();
                            await objWriter.FlushAsync();
                        }

                        objStream.Position = 0;

                        // Validate that the character can save properly. If there's no error, save the file to the listed file location.
                        try
                        {
                            XmlDocument objDoc = new XmlDocument { XmlResolver = null };
                            using (XmlReader objXmlReader
                                   = XmlReader.Create(objStream, GlobalSettings.SafeXmlReaderSettings))
                                objDoc.Load(objXmlReader);
                            objDoc.Save(strFileName);
                        }
                        catch (IOException e)
                        {
                            Log.Error(e);
                            if (Utils.IsUnitTest)
                                throw;
                            Program.ShowMessageBox(await LanguageManager.GetStringAsync("Message_Save_Error_Warning", token: innerToken));
                            blnErrorFree = false;
                        }
                        catch (XmlException ex)
                        {
                            Log.Warn(ex);
                            if (Utils.IsUnitTest)
                                throw;
                            Program.ShowMessageBox(await LanguageManager.GetStringAsync("Message_Save_Error_Warning", token: innerToken));
                            blnErrorFree = false;
                        }
                        catch (UnauthorizedAccessException) when (!Utils.IsUnitTest)
                        {
                            Program.ShowMessageBox(await LanguageManager.GetStringAsync("Message_Save_Error_Warning", token: innerToken));
                            blnErrorFree = false;
                        }
                    }
                }

                if (addToMRU)
                {
                    if (blnSync)
                        // ReSharper disable once MethodHasAsyncOverload
                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                        GlobalSettings.MostRecentlyUsedCharacters.Insert(0, FileName);
                    else
                        await GlobalSettings.MostRecentlyUsedCharacters.InsertAsync(0, FileName, token);
                }

                if (blnSync)
                {
                    // ReSharper disable once MethodHasAsyncOverload
                    using (LockObject.EnterWriteLock(token))
                    {
                        _dateFileLastWriteTime = File.GetLastWriteTimeUtc(strFileName);
                    }
                }
                else
                {
                    IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        _dateFileLastWriteTime = File.GetLastWriteTimeUtc(strFileName);
                    }
                    finally
                    {
                        await objLocker.DisposeAsync();
                    }
                }

                if (callOnSaveCallBack)
                {
                    // Cannot use foreach or LINQ because we need to be able to allow queued functions to add onto the queue
                    if (blnSync)
                    {
                        // ReSharper disable once ForCanBeConvertedToForeach
                        for (int i = 0; i < DoOnSaveCompleted.Count; ++i)
                        {
                            Func<Character, bool> funcLoopToRun = DoOnSaveCompleted[i];
                            if (funcLoopToRun?.Invoke(this) != true)
                                blnErrorFree = false;
                        }

                        // ReSharper disable once ForCanBeConvertedToForeach
                        for (int i = 0; i < DoOnSaveCompletedAsync.Count; ++i)
                        {
                            Func<Character, CancellationToken, Task<bool>> funcLoopToRun = DoOnSaveCompletedAsync[i];
                            Task<bool> tskLoopTask = funcLoopToRun?.Invoke(this, token) ?? Task.FromResult(true);
                            if (tskLoopTask.Status == TaskStatus.Created)
                                tskLoopTask.RunSynchronously();
                            if (tskLoopTask.Exception != null)
                                // ReSharper disable once PossibleNullReferenceException
                                throw tskLoopTask.Exception;
                            if (!tskLoopTask.GetAwaiter().GetResult())
                                blnErrorFree = false;
                        }
                    }
                    else
                    {
                        List<Task<bool>> lstDoOnSaveCompletedAsync = new List<Task<bool>>(Utils.MaxParallelBatchSize);
                        int i = 0;
                        int j = 0;
                        while (i != DoOnSaveCompleted.Count || j != DoOnSaveCompletedAsync.Count)
                        {
                            lstDoOnSaveCompletedAsync.Clear();
                            while
                                (i != DoOnSaveCompleted
                                    .Count) // Set up this way because functions can potentially add more to DoOnSaveCompleted
                            {
                                int intCounter = 0;
                                // ReSharper disable once ForCanBeConvertedToForeach
                                for (; i < DoOnSaveCompleted.Count; ++i)
                                {
                                    token.ThrowIfCancellationRequested();
                                    Func<Character, bool> funcLoopToRun = DoOnSaveCompleted[i];
                                    if (funcLoopToRun != null)
                                    {
                                        lstDoOnSaveCompletedAsync.Add(
                                            Task.Run(() => funcLoopToRun.Invoke(this), token));
                                        if (++intCounter != Utils.MaxParallelBatchSize)
                                            continue;
                                        token.ThrowIfCancellationRequested();
                                        await Task.WhenAll(lstDoOnSaveCompletedAsync);
                                        token.ThrowIfCancellationRequested();
                                        foreach (Task<bool> tskLoop in lstDoOnSaveCompletedAsync)
                                        {
                                            if (!await tskLoop)
                                                blnErrorFree = false;
                                        }
                                        lstDoOnSaveCompletedAsync.Clear();
                                        intCounter = 0;
                                    }
                                }

                                token.ThrowIfCancellationRequested();
                                await Task.WhenAll(lstDoOnSaveCompletedAsync);
                                token.ThrowIfCancellationRequested();
                                foreach (Task<bool> tskLoop in lstDoOnSaveCompletedAsync)
                                {
                                    if (!await tskLoop)
                                        blnErrorFree = false;
                                }
                            }

                            lstDoOnSaveCompletedAsync.Clear();
                            while (j != DoOnSaveCompletedAsync.Count)
                            {
                                int intCounter = 0;
                                // ReSharper disable once ForCanBeConvertedToForeach
                                for (; j < DoOnSaveCompletedAsync.Count; ++j)
                                {
                                    Func<Character, CancellationToken, Task<bool>> funcLoopToRun
                                        = await DoOnSaveCompletedAsync.GetValueAtAsync(j, token);
                                    if (funcLoopToRun != null)
                                    {
                                        lstDoOnSaveCompletedAsync.Add(
                                            Task.Run(() => funcLoopToRun.Invoke(this, token), token));
                                        if (++intCounter != Utils.MaxParallelBatchSize)
                                            continue;
                                        token.ThrowIfCancellationRequested();
                                        await Task.WhenAll(lstDoOnSaveCompletedAsync);
                                        token.ThrowIfCancellationRequested();
                                        foreach (Task<bool> tskLoop in lstDoOnSaveCompletedAsync)
                                        {
                                            if (!await tskLoop)
                                                blnErrorFree = false;
                                        }
                                        lstDoOnSaveCompletedAsync.Clear();
                                        intCounter = 0;
                                    }
                                }

                                token.ThrowIfCancellationRequested();
                                await Task.WhenAll(lstDoOnSaveCompletedAsync);
                                token.ThrowIfCancellationRequested();
                                foreach (Task<bool> tskLoop in lstDoOnSaveCompletedAsync)
                                {
                                    if (!await tskLoop)
                                        blnErrorFree = false;
                                }
                            }
                        }
                    }
                }

                return blnErrorFree;
            }
        }

        /// <summary>
        /// Syntactic sugar for XmlManager.LoadXPath() where we use the current enabled custom data directory list from our options file.
        /// XPathDocuments are usually faster than XmlDocuments, but are read-only and take longer to load if live custom data is enabled
        /// Returns a new XPathNavigator associated with the XPathDocument so that multiple threads each get their own navigator if they're called on the same file
        /// </summary>
        /// <param name="strFileName">Name of the XML file to load.</param>
        /// <param name="strLanguage">Language in which to load the data document.</param>
        /// <param name="blnLoadFile">Whether to force reloading content even if the file already exists.</param>
        /// <param name="token">Cancellation token to use.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public XPathNavigator LoadDataXPath(string strFileName, string strLanguage = "", bool blnLoadFile = false, CancellationToken token = default)
        {
            return XmlManager.LoadXPath(strFileName, Settings.EnabledCustomDataDirectoryPaths, strLanguage, blnLoadFile, token);
        }

        /// <summary>
        /// Syntactic sugar for XmlManager.LoadXPathAsync() where we use the current enabled custom data directory list from our options file.
        /// XPathDocuments are usually faster than XmlDocuments, but are read-only and take longer to load if live custom data is enabled
        /// Returns a new XPathNavigator associated with the XPathDocument so that multiple threads each get their own navigator if they're called on the same file
        /// </summary>
        /// <param name="strFileName">Name of the XML file to load.</param>
        /// <param name="strLanguage">Language in which to load the data document.</param>
        /// <param name="blnLoadFile">Whether to force reloading content even if the file already exists.</param>
        /// <param name="token">Cancellation token to use.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Task<XPathNavigator> LoadDataXPathAsync(string strFileName, string strLanguage = "",
            bool blnLoadFile = false, CancellationToken token = default)
        {
            return XmlManager.LoadXPathAsync(strFileName, Settings.EnabledCustomDataDirectoryPaths, strLanguage,
                blnLoadFile, token);
        }

        /// <summary>
        /// Syntactic sugar for XmlManager.Load() where we use the current enabled custom data directory list from our options file.
        /// </summary>
        /// <param name="strFileName">Name of the XML file to load.</param>
        /// <param name="strLanguage">Language in which to load the data document.</param>
        /// <param name="blnLoadFile">Whether to force reloading content even if the file already exists.</param>
        /// <param name="token">Cancellation token to use.</param>
        [NotNull]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public XmlDocument LoadData(string strFileName, string strLanguage = "", bool blnLoadFile = false, CancellationToken token = default)
        {
            return XmlManager.Load(strFileName, Settings.EnabledCustomDataDirectoryPaths, strLanguage, blnLoadFile, token);
        }

        /// <summary>
        /// Syntactic sugar for XmlManager.LoadAsync() where we use the current enabled custom data directory list from our options file.
        /// </summary>
        /// <param name="strFileName">Name of the XML file to load.</param>
        /// <param name="strLanguage">Language in which to load the data document.</param>
        /// <param name="blnLoadFile">Whether to force reloading content even if the file already exists.</param>
        /// <param name="token">Cancellation token to use.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Task<XmlDocument> LoadDataAsync(string strFileName, string strLanguage = "", bool blnLoadFile = false, CancellationToken token = default)
        {
            return XmlManager.LoadAsync(strFileName, Settings.EnabledCustomDataDirectoryPaths, strLanguage, blnLoadFile, token);
        }

        private bool _blnIsLoading;

        /// <summary>
        /// Set to true while data is being populated by the Load function
        /// </summary>
        public bool IsLoading
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnIsLoading;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnIsLoading == value)
                        return;
                    using (EnterReadLock.Enter(LockObject))
                    {
                        _blnIsLoading = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Queue of methods to execute after loading has finished. Return value signals whether loading should continue after execution (True) or terminate/cancel (False).
        /// </summary>
        public ThreadSafeQueue<Func<bool>> PostLoadMethods
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _quePostLoadMethods;
            }
        }

        /// <summary>
        /// Queue of asynchronous methods to execute after loading has finished. Return value signals whether loading should continue after execution (True) or terminate/cancel (False).
        /// </summary>
        public ThreadSafeQueue<Func<Task<bool>>> PostLoadMethodsAsync
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _quePostLoadMethodsAsync;
            }
        }

        /// <summary>
        /// Load the Character from an XML file synchronously.
        /// </summary>
        /// <param name="frmLoadingForm">Instance of frmLoading to use to update with loading progress. frmLoading::PerformStep() is called 35 times within this method, so plan accordingly.</param>
        /// <param name="showWarnings">Whether warnings about book content and other character content should be loaded.</param>
        /// <param name="token">Cancellation token to use.</param>
        public bool Load(LoadingBar frmLoadingForm = null, bool showWarnings = true, CancellationToken token = default)
        {
            return LoadCoreAysnc(true, frmLoadingForm, showWarnings, token).ConfigureAwait(false).GetAwaiter().GetResult();
        }

        /// <summary>
        /// Load the Character from an XML file asynchronously.
        /// </summary>
        /// <param name="frmLoadingForm">Instance of frmLoading to use to update with loading progress. frmLoading::PerformStep() is called 35 times within this method, so plan accordingly.</param>
        /// <param name="showWarnings">Whether warnings about book content and other character content should be loaded.</param>
        /// <param name="token">Cancellation token to use.</param>
        public Task<bool> LoadAsync(LoadingBar frmLoadingForm = null, bool showWarnings = true, CancellationToken token = default)
        {
            return LoadCoreAysnc(false, frmLoadingForm, showWarnings, token);
        }

        public const int NumLoadingSections = 37;

        /// <summary>
        /// Load the Character from an XML file.
        /// Uses flag hack method design outlined here to avoid locking:
        /// https://docs.microsoft.com/en-us/archive/msdn-magazine/2015/july/async-programming-brownfield-async-development
        /// </summary>
        /// <param name="blnSync">Flag for whether method should always use synchronous code or not.</param>
        /// <param name="frmLoadingForm">Instance of frmLoading to use to update with loading progress. frmLoading::PerformStep() is called NumLoadingSections times within this method, so plan accordingly.</param>
        /// <param name="showWarnings">Whether warnings about book content and other character content should be loaded.</param>
        /// <param name="token">Cancellation token to use.</param>
        private async Task<bool> LoadCoreAysnc(bool blnSync, LoadingBar frmLoadingForm = null, bool showWarnings = true, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (!File.Exists(_strFileName))
                return false;

            IDisposable objLocker = null;
            IAsyncDisposable objLockerAsync = null;
            if (blnSync)
                // ReSharper disable once MethodHasAsyncOverload
                objLocker = LockObject.EnterWriteLock(token);
            else
                objLockerAsync = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                LoadAsDirty = false;
                using (CustomActivity loadActivity = blnSync
                           // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                           ? Timekeeper.StartSyncron("clsCharacter.Load", null,
                                                     CustomActivity.OperationType
                                                                   .DependencyOperation, _strFileName)
                           : await Timekeeper.StartSyncronAsync("clsCharacter.Load", null,
                                                     CustomActivity.OperationType
                                                                   .DependencyOperation, _strFileName, token).ConfigureAwait(false))
                {
                    try
                    {
                        using (_ = blnSync
                                   // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                   ? Timekeeper.StartSyncron("upload_AI_options", loadActivity)
                                   : await Timekeeper.StartSyncronAsync("upload_AI_options", loadActivity, token).ConfigureAwait(false))
                        {
                            UploadObjectAsMetric.UploadObject(TelemetryClient, Settings);
                        }

                        XmlDocument objXmlDocument = new XmlDocument {XmlResolver = null};
                        XmlNode objXmlCharacter = null;
                        XPathNavigator xmlCharacterNavigator = null;
                        Quality objLivingPersonaQuality = null;

                        if (frmLoadingForm != null)
                        {
                            if (blnSync)
                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                frmLoadingForm.PerformStep("XML");
                            else
                                await frmLoadingForm.PerformStepAsync("XML", token: token).ConfigureAwait(false);
                        }

                        using (_ = blnSync
                                   // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                   ? Timekeeper.StartSyncron("load_xml", loadActivity)
                                   : await Timekeeper.StartSyncronAsync("load_xml", loadActivity, token).ConfigureAwait(false))
                        {
                            if (!File.Exists(_strFileName))
                                return false;
                            bool blnKeepLoading = blnSync
                                ? LoadSaveFileDocument()
                                : await Task.Run(LoadSaveFileDocumentAsync, token).ConfigureAwait(false);

                            bool LoadSaveFileDocument()
                            {
                                bool blnErrorCaught = false;
                                do
                                {
                                    try
                                    {
                                        objXmlDocument.LoadStandard(_strFileName, !blnErrorCaught);
                                        blnErrorCaught = false;
                                    }
                                    catch (XmlException ex)
                                    {
                                        if (System.Text.RegularExpressions.Regex.IsMatch(ex.Message,
                                                GlobalSettings.InvalidXmlCharacterRegex))
                                        {
                                            /*If we found a known control character that's preventing the character from
                                            being loaded (Expected to be notes ingested from PDF mostly) prompt the user whether to use unsafe methods.
                                            If yes, restart the load, explicitly ignoring invalid characters.*/

                                            if (Program.ShowMessageBox(
                                                    LanguageManager.GetString("Message_InvalidTextFound", token: token),
                                                    LanguageManager.GetString("Message_InvalidTextFound_Title", token: token),
                                                    MessageBoxButtons.YesNo, MessageBoxIcon.Warning) ==
                                                DialogResult.No)
                                            {
                                                return false;
                                            }

                                            blnErrorCaught = true;
                                        }
                                        else
                                        {
                                            if (showWarnings)
                                            {
                                                Program.ShowMessageBox(
                                                    string.Format(GlobalSettings.CultureInfo,
                                                                  LanguageManager.GetString("Message_FailedLoad", token: token),
                                                                  ex.Message),
                                                    string.Format(GlobalSettings.CultureInfo,
                                                                  LanguageManager.GetString("MessageTitle_FailedLoad", token: token),
                                                                  ex.Message),
                                                    MessageBoxButtons.OK, MessageBoxIcon.Error);
                                            }

                                            return false;
                                        }
                                    }
                                } while (blnErrorCaught);

                                objXmlCharacter = objXmlDocument.SelectSingleNode("/character");
                                xmlCharacterNavigator =
                                    objXmlDocument.GetFastNavigator().SelectSingleNode("/character");
                                return true;
                            }

                            async Task<bool> LoadSaveFileDocumentAsync()
                            {
                                bool blnErrorCaught = false;
                                do
                                {
                                    try
                                    {
                                        objXmlDocument.LoadStandard(_strFileName, !blnErrorCaught);
                                        blnErrorCaught = false;
                                    }
                                    catch (XmlException ex)
                                    {
                                        if (System.Text.RegularExpressions.Regex.IsMatch(ex.Message,
                                                GlobalSettings.InvalidXmlCharacterRegex))
                                        {
                                            /*If we found a known control character that's preventing the character from
                                            being loaded (Expected to be notes ingested from PDF mostly) prompt the user whether to use unsafe methods.
                                            If yes, restart the load, explicitly ignoring invalid characters.*/

                                            if (Program.ShowMessageBox(
                                                    await LanguageManager.GetStringAsync("Message_InvalidTextFound", token: token).ConfigureAwait(false),
                                                    await LanguageManager.GetStringAsync("Message_InvalidTextFound_Title", token: token).ConfigureAwait(false),
                                                    MessageBoxButtons.YesNo, MessageBoxIcon.Warning) ==
                                                DialogResult.No)
                                            {
                                                return false;
                                            }

                                            blnErrorCaught = true;
                                        }
                                        else
                                        {
                                            if (showWarnings)
                                            {
                                                Program.ShowMessageBox(
                                                    string.Format(GlobalSettings.CultureInfo,
                                                                  await LanguageManager.GetStringAsync("Message_FailedLoad", token: token).ConfigureAwait(false),
                                                                  ex.Message),
                                                    string.Format(GlobalSettings.CultureInfo,
                                                                  await LanguageManager.GetStringAsync("MessageTitle_FailedLoad", token: token).ConfigureAwait(false),
                                                                  ex.Message),
                                                    MessageBoxButtons.OK, MessageBoxIcon.Error);
                                            }

                                            return false;
                                        }
                                    }
                                } while (blnErrorCaught);

                                objXmlCharacter = objXmlDocument.SelectSingleNode("/character");
                                xmlCharacterNavigator =
                                    objXmlDocument.GetFastNavigator().SelectSingleNode("/character");
                                return true;
                            }

                            if (!blnKeepLoading || objXmlCharacter == null || xmlCharacterNavigator == null)
                            {
                                return false;
                            }

                            //Timekeeper.Finish("load_xml");
                        }

                        IsLoading = true;

                        try
                        {
                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("String_Settings", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("String_Settings", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_misc", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_misc", loadActivity, token).ConfigureAwait(false))
                            {
                                _dateFileLastWriteTime = File.GetLastWriteTimeUtc(_strFileName);

                                xmlCharacterNavigator.TryGetBoolFieldQuickly("ignorerules", ref _blnIgnoreRules);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("created", ref _blnCreated);

                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ResetCharacter(token);
                                else
                                    await ResetCharacterAsync(token);

                                // Get the game edition of the file if possible and make sure it's intended to be used with this version of the application.
                                string strGameEdition = string.Empty;
                                if (xmlCharacterNavigator.TryGetStringFieldQuickly("gameedition",
                                        ref strGameEdition) &&
                                    !string.IsNullOrEmpty(strGameEdition) && strGameEdition != "SR5" &&
                                    showWarnings &&
                                    !Utils.IsUnitTest)
                                {
                                    Program.ShowMessageBox(
                                        blnSync
                                            // ReSharper disable once MethodHasAsyncOverload
                                            ? LanguageManager.GetString("Message_IncorrectGameVersion_SR4", token: token)
                                            : await LanguageManager.GetStringAsync(
                                                "Message_IncorrectGameVersion_SR4", token: token).ConfigureAwait(false),
                                        blnSync
                                            // ReSharper disable once MethodHasAsyncOverload
                                            ? LanguageManager.GetString("MessageTitle_IncorrectGameVersion", token: token)
                                            : await LanguageManager.GetStringAsync(
                                                "MessageTitle_IncorrectGameVersion", token: token).ConfigureAwait(false),
                                        MessageBoxButtons.YesNo,
                                        MessageBoxIcon.Error);
                                    return false;
                                }

                                string strVersion = string.Empty;
                                //Check to see if the character was created in a version of Chummer later than the currently installed one.
                                if (xmlCharacterNavigator.TryGetStringFieldQuickly("appversion", ref strVersion) &&
                                    !string.IsNullOrEmpty(strVersion))
                                {
                                    strVersion = strVersion.TrimStartOnce("0.");

                                    if (!VersionExtensions.TryParse(strVersion, out _verSavedVersion))
                                    {
                                        _verSavedVersion = Utils.IsUnitTest
                                            ? new Version(int.MaxValue, int.MaxValue, int.MaxValue)
                                            : new Version();
                                    }
                                    // Check for typo in Corrupter quality and correct it
                                    else if (_verSavedVersion?.CompareTo(new Version(5, 188, 34)) == -1)
                                    {
                                        objXmlDocument.InnerXml =
                                            objXmlDocument.InnerXml.Replace("Corruptor", "Corrupter");
                                        xmlCharacterNavigator =
                                            objXmlDocument.GetFastNavigator().SelectSingleNode("/character");
                                        if (xmlCharacterNavigator == null)
                                            return false;
                                    }
                                }
#if !DEBUG
                                if (!Utils.IsUnitTest)
                                {
                                    string strMinimumVersion = string.Empty;
                                    // Check to see if a character has a minimum version set where they will not load properly on anything older
                                    if (xmlCharacterNavigator.TryGetStringFieldQuickly("minimumappversion", ref strMinimumVersion) &&
                                        !string.IsNullOrEmpty(strMinimumVersion))
                                    {
                                        strMinimumVersion = strMinimumVersion.TrimStartOnce("0.");
                                        if (Version.TryParse(strMinimumVersion, out Version objMinimumVersion) && objMinimumVersion > Utils.CurrentChummerVersion)
                                        {
                                            Program.ShowMessageBox(
                                                string.Format(GlobalSettings.CultureInfo,
                                                    LanguageManager.GetString("Message_OlderThanChummerSaveMinimumVersion"),
                                                    objMinimumVersion, Utils.CurrentChummerVersion),
                                                LanguageManager.GetString("MessageTitle_OlderThanChummerSaveMinimumVersion"),
                                                MessageBoxButtons.OK,
                                                MessageBoxIcon.Error);
                                            return false;
                                        }
                                    }
                                    if (_verSavedVersion > Utils.CurrentChummerVersion && DialogResult.Yes != Program.ShowMessageBox(
                                        string.Format(GlobalSettings.CultureInfo, LanguageManager.GetString("Message_OutdatedChummerSave"),
                                            _verSavedVersion, Utils.CurrentChummerVersion),
                                        LanguageManager.GetString("MessageTitle_OutdatedChummerSave"),
                                        MessageBoxButtons.YesNo,
                                        MessageBoxIcon.Warning))
                                    {
                                        return false;
                                    }
                                }
#endif

                                // Get the name of the settings file in use if possible.
                                xmlCharacterNavigator.TryGetStringFieldQuickly("settings", ref _strSettingsKey);

                                bool blnSuccess;

                                // Load the character's settings file.
                                string strDummy = string.Empty;
                                if (!xmlCharacterNavigator.TryGetStringFieldQuickly("buildmethod", ref strDummy)
                                    || !Enum.TryParse(strDummy, true, out CharacterBuildMethod eSavedBuildMethod))
                                {
                                    CharacterSettings objSettings;
                                    if (blnSync)
                                        blnSuccess = SettingsManager.LoadedCharacterSettings.TryGetValue(
                                            GlobalSettings.DefaultCharacterSettingDefaultValue, out objSettings);
                                    else
                                        (blnSuccess, objSettings)
                                            = await (await SettingsManager.GetLoadedCharacterSettingsAsync(token)).TryGetValueAsync(
                                                GlobalSettings.DefaultCharacterSettingDefaultValue, token).ConfigureAwait(false);
                                    eSavedBuildMethod = blnSuccess
                                        ? objSettings.BuildMethod
                                        : CharacterBuildMethod.Priority;
                                }

                                CharacterSettings objDefaultSettings;
                                if (blnSync)
                                    blnSuccess = SettingsManager.LoadedCharacterSettings.TryGetValue(
                                        GlobalSettings.DefaultCharacterSetting, out objDefaultSettings);
                                else
                                    (blnSuccess, objDefaultSettings)
                                        = await (await SettingsManager.GetLoadedCharacterSettingsAsync(token)).TryGetValueAsync(
                                            GlobalSettings.DefaultCharacterSetting, token).ConfigureAwait(false);
                                if (!blnSuccess)
                                {
                                    if (blnSync)
                                        blnSuccess = SettingsManager.LoadedCharacterSettings.TryGetValue(
                                            GlobalSettings.DefaultCharacterSettingDefaultValue, out objDefaultSettings);
                                    else
                                        (blnSuccess, objDefaultSettings)
                                            = await (await SettingsManager.GetLoadedCharacterSettingsAsync(token)).TryGetValueAsync(
                                                GlobalSettings.DefaultCharacterSettingDefaultValue, token).ConfigureAwait(false);
                                    if (!blnSuccess)
                                    {
                                        objDefaultSettings = blnSync
                                            ? SettingsManager.LoadedCharacterSettings.Values.First()
                                            : (await SettingsManager.GetLoadedCharacterSettingsAsync(token)).Values.First();
                                    }
                                }

                                CharacterSettings objProspectiveSettings;
                                bool blnShowSelectBP = false;
                                using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                           out HashSet<string> setSavedBooks))
                                {
                                    foreach (XPathNavigator xmlBook in (blnSync
                                                 // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                 ? xmlCharacterNavigator.SelectAndCacheExpression(
                                                     "sources/source")
                                                 : await xmlCharacterNavigator.SelectAndCacheExpressionAsync(
                                                     "sources/source", token: token).ConfigureAwait(false)))
                                    {
                                        if (!string.IsNullOrEmpty(xmlBook.Value))
                                            setSavedBooks.Add(xmlBook.Value);
                                    }

                                    if (setSavedBooks.Count == 0)
                                        setSavedBooks.AddRange(objDefaultSettings.Books);

                                    XPathNodeIterator xmlCustomDirectoryNames = blnSync
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        ? xmlCharacterNavigator.SelectAndCacheExpression(
                                            "customdatadirectorynames/directoryname")
                                        : await xmlCharacterNavigator.SelectAndCacheExpressionAsync(
                                            "customdatadirectorynames/directoryname", token: token).ConfigureAwait(false);
                                    List<string> lstSavedCustomDataDirectoryNames
                                        = new List<string>(xmlCustomDirectoryNames.Count);
                                    foreach (XPathNavigator xmlCustomDataDirectoryName in xmlCustomDirectoryNames)
                                    {
                                        if (!string.IsNullOrEmpty(xmlCustomDataDirectoryName.Value))
                                            lstSavedCustomDataDirectoryNames.Add(xmlCustomDataDirectoryName.Value);
                                    }

                                    decimal decLegacyMaxNuyen = objDefaultSettings.NuyenMaximumBP;
                                    xmlCharacterNavigator.TryGetDecFieldQuickly("maxnuyen", ref decLegacyMaxNuyen);
                                    int intLegacyMaxKarma = objDefaultSettings.BuildKarma;
                                    xmlCharacterNavigator.TryGetInt32FieldQuickly("maxkarma",
                                        ref intLegacyMaxKarma);

                                    // Calculate a score for a character option that roughly coincides with how suitable it is as a replacement for the current one the character save contains
                                    // Settings with a negative score should not be considered suitable at all
                                    int CalculateCharacterSettingsMatchScore(CharacterSettings objOptionsToCheck)
                                    {
                                        int intReturn = int.MaxValue - ((intLegacyMaxKarma - objOptionsToCheck.BuildKarma).RaiseToPower(2)
                                                                 + (decLegacyMaxNuyen - objOptionsToCheck.NuyenMaximumBP)
                                                                 .RaiseToPower(2))
                                                       .RaiseToPower(0.5m).StandardRound();

                                        int intBaseline = objOptionsToCheck.BuiltInOption ? 5 : 4;
                                        
                                        if (Created && eSavedBuildMethod != CharacterBuildMethod.LifeModule)
                                        {
                                            if (objOptionsToCheck.BuildMethod != eSavedBuildMethod)
                                            {
                                                if (objOptionsToCheck.BuildMethod.UsesPriorityTables() ==
                                                    eSavedBuildMethod.UsesPriorityTables())
                                                    intReturn -= 2;
                                                else
                                                    intReturn -= 4;
                                            }
                                        }
                                        else if (objOptionsToCheck.BuildMethod != eSavedBuildMethod)
                                        {
                                            if (objOptionsToCheck.BuildMethod.UsesPriorityTables() ==
                                                eSavedBuildMethod.UsesPriorityTables())
                                            {
                                                intBaseline += 2;
                                                intReturn -= int.MaxValue / 2;
                                            }
                                            else
                                            {
                                                intBaseline += 4;
                                                intReturn -= int.MaxValue;
                                            }
                                        }

                                        int intBaselineCustomDataCount = objOptionsToCheck.EnabledCustomDataDirectoryInfos.Count;
                                        if (intBaselineCustomDataCount == 0)
                                        {
                                            intBaselineCustomDataCount = lstSavedCustomDataDirectoryNames.Count;
                                            if (intBaselineCustomDataCount > 0)
                                            {
                                                intReturn -= intBaselineCustomDataCount.RaiseToPower(2) * intBaseline;
                                            }
                                        }
                                        else if (lstSavedCustomDataDirectoryNames.Count == 0)
                                        {
                                            intReturn -= intBaselineCustomDataCount.RaiseToPower(2) * intBaseline;
                                        }
                                        else
                                        {
                                            intBaselineCustomDataCount
                                                = Math.Max(lstSavedCustomDataDirectoryNames.Count,
                                                           intBaselineCustomDataCount);
                                            for (int i = 0;
                                                 i < objOptionsToCheck.EnabledCustomDataDirectoryInfos.Count;
                                                 ++i)
                                            {
                                                string strLoopCustomDataName =
                                                    objOptionsToCheck.EnabledCustomDataDirectoryInfos[i].Name;
                                                int intLoopIndex =
                                                    lstSavedCustomDataDirectoryNames.IndexOf(strLoopCustomDataName);
                                                if (intLoopIndex < 0)
                                                    intReturn -= intBaselineCustomDataCount * intBaseline;
                                                else
                                                    intReturn -= Math.Abs(i - intLoopIndex) * intBaseline;
                                            }

                                            foreach (string strLoopCustomDataName in lstSavedCustomDataDirectoryNames)
                                            {
                                                if (objOptionsToCheck.EnabledCustomDataDirectoryInfos.All(
                                                        x => x.Name != strLoopCustomDataName))
                                                    intReturn -= intBaselineCustomDataCount * intBaseline;
                                            }
                                        }

                                        using (new FetchSafelyFromPool<HashSet<string>>(
                                                   Utils.StringHashSetPool, out HashSet<string> setDummyBooks))
                                        {
                                            setDummyBooks.AddRange(setSavedBooks);
                                            int intExtraBooks = 0;
                                            foreach (string strBook in objOptionsToCheck.Books)
                                            {
                                                if (setDummyBooks.Remove(strBook))
                                                    ++intExtraBooks;
                                            }
                                            setDummyBooks.IntersectWith(objOptionsToCheck.Books);
                                            intReturn -= (setDummyBooks.Count * (intBaselineCustomDataCount + 1)
                                                          + intExtraBooks) * intBaseline;
                                        }

                                        return intReturn;
                                    }

                                    if (blnSync)
                                        blnSuccess = SettingsManager.LoadedCharacterSettings.TryGetValue(
                                            _strSettingsKey, out objProspectiveSettings);
                                    else
                                        (blnSuccess, objProspectiveSettings)
                                            = await (await SettingsManager.GetLoadedCharacterSettingsAsync(token)).TryGetValueAsync(
                                                _strSettingsKey, token).ConfigureAwait(false);

                                    if (!blnSuccess)
                                    {
                                        // Prompt if we want to switch options or leave
                                        if (!Utils.IsUnitTest && showWarnings)
                                        {
                                            if (Program.ShowMessageBox(
                                                    string.Format(GlobalSettings.CultureInfo,
                                                                  blnSync
                                                                      // ReSharper disable once MethodHasAsyncOverload
                                                                      ? LanguageManager.GetString(
                                                                          "Message_CharacterOptions_CannotLoadSetting", token: token)
                                                                      : await LanguageManager.GetStringAsync(
                                                                          "Message_CharacterOptions_CannotLoadSetting", token: token).ConfigureAwait(false),
                                                                  Path.GetFileNameWithoutExtension(_strSettingsKey)),
                                                    blnSync
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        ? LanguageManager.GetString(
                                                            "MessageTitle_CharacterOptions_CannotLoadSetting", token: token)
                                                        : await LanguageManager.GetStringAsync(
                                                            "MessageTitle_CharacterOptions_CannotLoadSetting", token: token).ConfigureAwait(false),
                                                    MessageBoxButtons.YesNo) == DialogResult.No)
                                            {
                                                return false;
                                            }

                                            blnShowSelectBP = true;
                                        }

                                        // Set up interim options for selection by build method
                                        string strReplacementSettingsKey = string.Empty;
                                        int intMostSuitable = int.MinValue;
                                        foreach (KeyValuePair<string, CharacterSettings> kvpLoopOptions in
                                                 SettingsManager
                                                     .LoadedCharacterSettings)
                                        {
                                            int intLoopScore
                                                = CalculateCharacterSettingsMatchScore(kvpLoopOptions.Value);
                                            if (intLoopScore > intMostSuitable)
                                            {
                                                intMostSuitable = intLoopScore;
                                                strReplacementSettingsKey = kvpLoopOptions.Key;
                                            }
                                        }

                                        if (string.IsNullOrEmpty(strReplacementSettingsKey))
                                            blnSuccess = false;
                                        else if (blnSync)
                                            blnSuccess = SettingsManager.LoadedCharacterSettings.TryGetValue(
                                                strReplacementSettingsKey, out objProspectiveSettings);
                                        else
                                            (blnSuccess, objProspectiveSettings)
                                                = await (await SettingsManager.GetLoadedCharacterSettingsAsync(token)).TryGetValueAsync(
                                                    strReplacementSettingsKey, token).ConfigureAwait(false);

                                        if (!blnSuccess)
                                        {
                                            strReplacementSettingsKey
                                                = GlobalSettings.DefaultCharacterSettingDefaultValue;
                                            if (blnSync)
                                                blnSuccess = SettingsManager.LoadedCharacterSettings.TryGetValue(
                                                    strReplacementSettingsKey, out objProspectiveSettings);
                                            else
                                                (blnSuccess, objProspectiveSettings)
                                                    = await (await SettingsManager.GetLoadedCharacterSettingsAsync(token)).TryGetValueAsync(
                                                        strReplacementSettingsKey, token).ConfigureAwait(false);
                                            if (!blnSuccess)
                                            {
                                                objProspectiveSettings
                                                    = SettingsManager.LoadedCharacterSettings.Values.First();
                                                strReplacementSettingsKey = objProspectiveSettings.DictionaryKey;
                                            }
                                        }

                                        _strSettingsKey = strReplacementSettingsKey;
                                        LoadAsDirty = true;
                                    }
                                    else if (!Created && objProspectiveSettings.BuildMethod != eSavedBuildMethod)
                                    {
                                        // Prompt if we want to switch options or leave
                                        if (!Utils.IsUnitTest && showWarnings)
                                        {
                                            if (Program.ShowMessageBox(
                                                    string.Format(GlobalSettings.CultureInfo,
                                                                  blnSync
                                                                      // ReSharper disable once MethodHasAsyncOverload
                                                                      ? LanguageManager.GetString(
                                                                          "Message_CharacterOptions_DesyncBuildMethod", token: token)
                                                                      : await LanguageManager.GetStringAsync(
                                                                          "Message_CharacterOptions_DesyncBuildMethod", token: token).ConfigureAwait(false),
                                                                  Path.GetFileNameWithoutExtension(_strSettingsKey),
                                                                  blnSync
                                                                      // ReSharper disable once MethodHasAsyncOverload
                                                                      ? LanguageManager.GetString(
                                                                          "String_" + objProspectiveSettings
                                                                              .BuildMethod, token: token)
                                                                      : await LanguageManager.GetStringAsync(
                                                                          "String_" + objProspectiveSettings
                                                                              .BuildMethod, token: token).ConfigureAwait(false),
                                                                  blnSync
                                                                      // ReSharper disable once MethodHasAsyncOverload
                                                                      ? LanguageManager.GetString(
                                                                          "String_" + eSavedBuildMethod, token: token)
                                                                      : await LanguageManager.GetStringAsync(
                                                                          "String_" + eSavedBuildMethod, token: token).ConfigureAwait(false)),
                                                    blnSync
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        ? LanguageManager.GetString(
                                                            "MessageTitle_CharacterOptions_DesyncBuildMethod", token: token)
                                                        : await LanguageManager.GetStringAsync(
                                                            "MessageTitle_CharacterOptions_DesyncBuildMethod", token: token).ConfigureAwait(false),
                                                    MessageBoxButtons.YesNo) == DialogResult.No)
                                            {
                                                return false;
                                            }

                                            blnShowSelectBP = true;
                                        }

                                        // Set up interim options for selection by build method
                                        string strReplacementSettingsKey = string.Empty;
                                        int intMostSuitable = int.MinValue;
                                        foreach (KeyValuePair<string, CharacterSettings> kvpLoopOptions in
                                                 SettingsManager
                                                     .LoadedCharacterSettings)
                                        {
                                            int intLoopScore
                                                = CalculateCharacterSettingsMatchScore(kvpLoopOptions.Value);
                                            if (intLoopScore > intMostSuitable)
                                            {
                                                intMostSuitable = intLoopScore;
                                                strReplacementSettingsKey = kvpLoopOptions.Key;
                                            }
                                        }

                                        if (string.IsNullOrEmpty(strReplacementSettingsKey))
                                            blnSuccess = false;
                                        else if (blnSync)
                                            blnSuccess = SettingsManager.LoadedCharacterSettings.TryGetValue(
                                                strReplacementSettingsKey, out objProspectiveSettings);
                                        else
                                            (blnSuccess, objProspectiveSettings)
                                                = await (await SettingsManager.GetLoadedCharacterSettingsAsync(token)).TryGetValueAsync(
                                                    strReplacementSettingsKey, token).ConfigureAwait(false);

                                        if (!blnSuccess)
                                        {
                                            strReplacementSettingsKey
                                                = GlobalSettings.DefaultCharacterSettingDefaultValue;
                                            if (blnSync)
                                                blnSuccess = SettingsManager.LoadedCharacterSettings.TryGetValue(
                                                    strReplacementSettingsKey, out objProspectiveSettings);
                                            else
                                                (blnSuccess, objProspectiveSettings)
                                                    = await (await SettingsManager.GetLoadedCharacterSettingsAsync(token)).TryGetValueAsync(
                                                        strReplacementSettingsKey, token).ConfigureAwait(false);
                                            if (!blnSuccess)
                                            {
                                                objProspectiveSettings
                                                    = SettingsManager.LoadedCharacterSettings.Values.First();
                                                strReplacementSettingsKey = objProspectiveSettings.DictionaryKey;
                                            }
                                        }

                                        _strSettingsKey = strReplacementSettingsKey;
                                        LoadAsDirty = true;
                                    }
                                    // Legacy load stuff
                                    else if (!Utils.IsUnitTest && showWarnings &&
                                             (setSavedBooks.Count > 0 ||
                                              lstSavedCustomDataDirectoryNames.Count > 0))
                                    {
                                        CharacterSettings objCurrentlyLoadedSettings = objProspectiveSettings;
                                        // More books is fine, so just test if the stored book list is a subset of the current option's book list
                                        bool blnPromptConfirmSetting =
                                            !setSavedBooks.IsSubsetOf(objCurrentlyLoadedSettings.Books);
                                        if (!blnPromptConfirmSetting)
                                        {
                                            // More custom data directories is not fine because additional ones might apply rules that weren't present before, so prompt
                                            blnPromptConfirmSetting = lstSavedCustomDataDirectoryNames.Count !=
                                                                      objCurrentlyLoadedSettings
                                                                          .EnabledCustomDataDirectoryInfos
                                                                          .Count;
                                            if (!blnPromptConfirmSetting)
                                            {
                                                // Check to make sure all the names are the same
                                                for (int i = 0; i < lstSavedCustomDataDirectoryNames.Count; ++i)
                                                {
                                                    if (lstSavedCustomDataDirectoryNames[i]
                                                        != objCurrentlyLoadedSettings
                                                           .EnabledCustomDataDirectoryInfos[i]
                                                           .Name)
                                                    {
                                                        blnPromptConfirmSetting = true;
                                                        break;
                                                    }
                                                }
                                            }
                                        }

                                        if (blnPromptConfirmSetting)
                                        {
                                            DialogResult eShowBPResult = Program.ShowMessageBox(
                                                string.Format(
                                                    GlobalSettings.CultureInfo,
                                                    blnSync
                                                        // ReSharper disable once MethodHasAsyncOverload
                                                        ? LanguageManager.GetString(
                                                            "Message_CharacterOptions_DesyncBooksOrCustomData", token: token)
                                                        : await LanguageManager.GetStringAsync(
                                                            "Message_CharacterOptions_DesyncBooksOrCustomData", token: token).ConfigureAwait(false),
                                                    objCurrentlyLoadedSettings.Name),
                                                blnSync
                                                    // ReSharper disable once MethodHasAsyncOverload
                                                    ? LanguageManager.GetString(
                                                        "MessageTitle_CharacterOptions_DesyncBooksOrCustomData", token: token)
                                                    : await LanguageManager.GetStringAsync(
                                                        "MessageTitle_CharacterOptions_DesyncBooksOrCustomData", token: token).ConfigureAwait(false),
                                                MessageBoxButtons.YesNoCancel);
                                            if (eShowBPResult == DialogResult.Cancel)
                                            {
                                                return false;
                                            }

                                            blnShowSelectBP = eShowBPResult == DialogResult.Yes;
                                        }
                                    }
                                }

                                if (blnSync)
                                    Settings = objProspectiveSettings;
                                else
                                    await SetSettingsAsync(objProspectiveSettings, token);

                                if (blnShowSelectBP)
                                {
                                    LoadAsDirty = true;
                                    if (blnSync)
                                    {
                                        // ReSharper disable once MethodHasAsyncOverload
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        using (ThreadSafeForm<SelectBuildMethod> frmPickBP = ThreadSafeForm<SelectBuildMethod>.Get(() => new SelectBuildMethod(this, true)))
                                        {
                                            // ReSharper disable once MethodHasAsyncOverload
                                            if (frmPickBP.ShowDialogSafe(this, token) != DialogResult.OK)
                                            {
                                                return false;
                                            }
                                        }
                                    }
                                    else
                                    {
                                        using (ThreadSafeForm<SelectBuildMethod> frmPickBP = await ThreadSafeForm<SelectBuildMethod>.GetAsync(() => new SelectBuildMethod(this, true), token).ConfigureAwait(false))
                                        {
                                            if (await frmPickBP.ShowDialogSafeAsync(this, token).ConfigureAwait(false) != DialogResult.OK)
                                            {
                                                return false;
                                            }
                                        }
                                    }
                                }

                                if (xmlCharacterNavigator.TryGetDecFieldQuickly("essenceatspecialstart",
                                        ref _decEssenceAtSpecialStart) &&
                                    _decEssenceAtSpecialStart > ESS.MetatypeMaximum)
                                {
                                    // fix to work around a mistake made when saving decimal values in previous versions.
                                    _decEssenceAtSpecialStart /= 10;
                                }

                                xmlCharacterNavigator.TryGetStringFieldQuickly("createdversion",
                                                                               ref _strVersionCreated);

                                // Metatype information.
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("iscritter", ref _blnIsCritter);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("metatype", ref _strMetatype);
                                if (!xmlCharacterNavigator.TryGetGuidFieldQuickly("metatypeid", ref _guiMetatype)
                                    && !Guid.TryParse(
                                        // ReSharper disable once MethodHasAsyncOverload
                                        (blnSync ? GetNodeXPath(true, token: token) : await GetNodeXPathAsync(true, token: token).ConfigureAwait(false))
                                        ?.SelectSingleNode("id")?.Value, out _guiMetatype))
                                {
                                    return false;
                                }

                                xmlCharacterNavigator.TryGetStringFieldQuickly("movement", ref _strMovement);

                                xmlCharacterNavigator.TryGetStringFieldQuickly("walk", ref _strWalk);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("run", ref _strRun);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("sprint", ref _strSprint);

                                _strRunAlt = xmlCharacterNavigator.SelectSingleNode("run/@alt")?.Value ??
                                             string.Empty;
                                _strWalkAlt = xmlCharacterNavigator.SelectSingleNode("walk/@alt")?.Value ??
                                              string.Empty;
                                _strSprintAlt = xmlCharacterNavigator.SelectSingleNode("sprint/@alt")?.Value ??
                                                string.Empty;
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("initiativedice",
                                                                              ref _intInitiativeDice);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("metatypebp", ref _intMetatypeBP);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("metavariant", ref _strMetavariant);
                                //Shim for characters created prior to Run Faster Errata
                                if (_strMetavariant == "Cyclopean")
                                {
                                    _strMetavariant = "Cyclops";
                                }

                                //Shim for metavariants that were saved with an incorrect metatype string.
                                if (!string.IsNullOrEmpty(_strMetavariant) && _strMetatype == _strMetavariant)
                                {
                                    // ReSharper disable once MethodHasAsyncOverload
                                    _strMetatype = (blnSync ? GetNodeXPath(true, token: token) : await GetNodeXPathAsync(true, token: token).ConfigureAwait(false))
                                                   .SelectSingleNode("name")?.Value ?? "Human";
                                }

                                if (!xmlCharacterNavigator.TryGetGuidFieldQuickly("metavariantid",
                                        ref _guiMetavariant) &&
                                    !string.IsNullOrEmpty(_strMetavariant))
                                {
                                    _guiMetavariant
                                        = Guid.Parse(
                                            // ReSharper disable once MethodHasAsyncOverload
                                            (blnSync ? this.GetNodeXPath(token: token) : await this.GetNodeXPathAsync(token: token).ConfigureAwait(false))
                                            ?.SelectSingleNode("id")?.Value);
                                }

                                bool blnDoSourceFetch =
                                    !xmlCharacterNavigator.TryGetStringFieldQuickly("source", ref _strSource) ||
                                    string.IsNullOrEmpty(_strSource);
                                // ReSharper disable once ConvertIfToOrExpression
                                if (!xmlCharacterNavigator.TryGetStringFieldQuickly("page", ref _strPage) ||
                                    string.IsNullOrEmpty(_strPage) || _strPage == "0")
                                    blnDoSourceFetch = true;
                                if (blnDoSourceFetch)
                                {
                                    XPathNavigator xmlCharNode
                                        // ReSharper disable once MethodHasAsyncOverload
                                        = blnSync ? this.GetNodeXPath(token: token) : await this.GetNodeXPathAsync(token: token).ConfigureAwait(false);
                                    if (xmlCharNode != null)
                                    {
                                        _strSource = xmlCharNode.SelectSingleNode("source")?.Value ?? _strSource;
                                        _strPage = xmlCharNode.SelectSingleNode("page")?.Value ?? _strPage;
                                    }
                                }

                                xmlCharacterNavigator.TryGetStringFieldQuickly("metatypecategory",
                                                                               ref _strMetatypeCategory);

                                // General character information.
                                xmlCharacterNavigator.TryGetStringFieldQuickly("name", ref _strName);
                                LoadMugshots(xmlCharacterNavigator);
                                if (!xmlCharacterNavigator.TryGetStringFieldQuickly("gender", ref _strGender))
                                    xmlCharacterNavigator.TryGetStringFieldQuickly("sex", ref _strGender);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("age", ref _strAge);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("eyes", ref _strEyes);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("height", ref _strHeight);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("weight", ref _strWeight);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("skin", ref _strSkin);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("hair", ref _strHair);
                                xmlCharacterNavigator.TryGetMultiLineStringFieldQuickly("description",
                                    ref _strDescription);
                                xmlCharacterNavigator.TryGetMultiLineStringFieldQuickly("background",
                                    ref _strBackground);
                                xmlCharacterNavigator.TryGetMultiLineStringFieldQuickly("concept", ref _strConcept);
                                xmlCharacterNavigator.TryGetMultiLineStringFieldQuickly("notes", ref _strNotes);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("alias", ref _strAlias);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("playername", ref _strPlayerName);
                                xmlCharacterNavigator.TryGetMultiLineStringFieldQuickly("gamenotes",
                                    ref _strGameNotes);
                                if (!xmlCharacterNavigator.TryGetStringFieldQuickly("primaryarm",
                                        ref _strPrimaryArm))
                                    _strPrimaryArm = "Right";

                                xmlCharacterNavigator.TryGetStringFieldQuickly("prioritymetatype",
                                                                               ref _strPriorityMetatype);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("priorityattributes",
                                                                               ref _strPriorityAttributes);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("priorityspecial",
                                                                               ref _strPrioritySpecial);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("priorityskills",
                                                                               ref _strPrioritySkills);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("priorityresources",
                                                                               ref _strPriorityResources);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("prioritytalent",
                                                                               ref _strPriorityTalent);

                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    _lstPrioritySkills.Clear();
                                else
                                    await _lstPrioritySkills.ClearAsync(token).ConfigureAwait(false);
                                foreach (XPathNavigator xmlSkillName in (blnSync
                                             // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                             ? xmlCharacterNavigator.SelectAndCacheExpression(
                                                 "priorityskills/priorityskill")
                                             : await xmlCharacterNavigator.SelectAndCacheExpressionAsync(
                                                 "priorityskills/priorityskill", token: token).ConfigureAwait(false)))
                                {
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstPrioritySkills.Add(xmlSkillName.Value);
                                    else
                                        await _lstPrioritySkills.AddAsync(xmlSkillName.Value, token).ConfigureAwait(false);
                                }

                                string strSkill1 = string.Empty;
                                string strSkill2 = string.Empty;
                                if (xmlCharacterNavigator.TryGetStringFieldQuickly("priorityskill1",
                                        ref strSkill1) &&
                                    !string.IsNullOrEmpty(strSkill1))
                                {
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstPrioritySkills.Add(strSkill1);
                                    else
                                        await _lstPrioritySkills.AddAsync(strSkill1, token).ConfigureAwait(false);
                                }

                                if (xmlCharacterNavigator.TryGetStringFieldQuickly("priorityskill2",
                                        ref strSkill2) &&
                                    !string.IsNullOrEmpty(strSkill2))
                                {
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstPrioritySkills.Add(strSkill2);
                                    else
                                        await _lstPrioritySkills.AddAsync(strSkill2, token).ConfigureAwait(false);
                                }

                                xmlCharacterNavigator.TryGetBoolFieldQuickly("possessed", ref _blnPossessed);

                                xmlCharacterNavigator.TryGetInt32FieldQuickly("contactpoints",
                                                                              ref _intCachedContactPoints);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("contactpointsused",
                                                                              ref _intContactPointsUsed);
                                xmlCharacterNavigator.TryGetDecFieldQuickly("basecarrylimit",
                                                                            ref _decCachedBaseCarryLimit);
                                xmlCharacterNavigator.TryGetDecFieldQuickly("baseliftlimit",
                                                                            ref _decCachedBaseLiftLimit);
                                xmlCharacterNavigator.TryGetDecFieldQuickly("totalcarriedweight",
                                                                            ref _decCachedTotalCarriedWeight);
                                xmlCharacterNavigator.TryGetDecFieldQuickly("encumbranceinterval",
                                                                            ref _decCachedEncumbranceInterval);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("cfplimit", ref _intCFPLimit);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("ainormalprogramlimit",
                                                                              ref _intAINormalProgramLimit);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("aiadvancedprogramlimit",
                                                                              ref _intAIAdvancedProgramLimit);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("currentcounterspellingdice",
                                                                              ref _intCurrentCounterspellingDice);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("currentliftcarryhits",
                                                                              ref _intCurrentLiftCarryHits);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("spelllimit", ref _intFreeSpells);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("karma", ref _intKarma);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("totalkarma", ref _intTotalKarma);

                                xmlCharacterNavigator.TryGetInt32FieldQuickly("special", ref _intSpecial);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("totalspecial", ref _intTotalSpecial);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("totalattributes",
                                                                              ref _intTotalAttributes);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("edgeused", ref _intEdgeUsed);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("streetcred", ref _intStreetCred);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("notoriety", ref _intNotoriety);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("publicawareness",
                                                                              ref _intPublicAwareness);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("burntstreetcred",
                                                                              ref _intBurntStreetCred);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("baseastralreputation",
                                                                              ref _intBaseAstralReputation);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("basewildreputation",
                                                                              ref _intBaseWildReputation);
                                xmlCharacterNavigator.TryGetDecFieldQuickly("nuyen", ref _decNuyen);
                                xmlCharacterNavigator.TryGetDecFieldQuickly("startingnuyen", ref _decStartingNuyen);
                                xmlCharacterNavigator.TryGetDecFieldQuickly("nuyenbp", ref _decNuyenBP);

                                xmlCharacterNavigator.TryGetBoolFieldQuickly("adept", ref _blnAdeptEnabled);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("magician", ref _blnMagicianEnabled);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("technomancer",
                                                                             ref _blnTechnomancerEnabled);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("ai", ref _blnAdvancedProgramsEnabled);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("cyberwaredisabled",
                                                                             ref _blnCyberwareDisabled);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("initiationdisabled",
                                                                             ref _blnInitiationDisabled);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("critter", ref _blnCritterEnabled);

                                xmlCharacterNavigator.TryGetDecFieldQuickly("prototypetranshuman",
                                                                            ref _decPrototypeTranshuman);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("magenabled", ref _blnMAGEnabled);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("initiategrade",
                                                                              ref _intInitiateGrade);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("resenabled", ref _blnRESEnabled);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("submersiongrade",
                                                                              ref _intSubmersionGrade);
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("depenabled", ref _blnDEPEnabled);
                                // Legacy shim
                                if (!_blnCreated && !_blnMAGEnabled && !_blnRESEnabled && !_blnDEPEnabled)
                                    _decEssenceAtSpecialStart = decimal.MinValue;
                                xmlCharacterNavigator.TryGetBoolFieldQuickly("groupmember", ref _blnGroupMember);
                                xmlCharacterNavigator.TryGetStringFieldQuickly("groupname", ref _strGroupName);
                                xmlCharacterNavigator.TryGetMultiLineStringFieldQuickly("groupnotes",
                                    ref _strGroupNotes);
                                //end load_char_misc
                            }

                            XmlNodeList objXmlNodeList;
                            XmlNodeList objXmlLocationList;
                            XmlNode xmlRootQualitiesNode;

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("String_MentorSpirit", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("String_MentorSpirit", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_mentorspirit", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_mentorspirit", loadActivity, token).ConfigureAwait(false))
                            {
                                // Improvements.
                                objXmlNodeList = objXmlCharacter.SelectNodes("mentorspirits/mentorspirit");
                                foreach (XmlNode objXmlMentor in objXmlNodeList)
                                {
                                    MentorSpirit objMentor = new MentorSpirit(this, objXmlMentor);
                                    objMentor.Load(objXmlMentor);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstMentorSpirits.Add(objMentor);
                                    else
                                        await _lstMentorSpirits.AddAsync(objMentor, token).ConfigureAwait(false);
                                }

                                //using finish("load_char_mentorspirit");
                            }

                            List<Improvement> lstCyberadeptSweepGrades =
                                new List<Improvement>(InitiationGrades.Count);

                            if (blnSync)
                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                _lstInternalIdsNeedingReapplyImprovements.Clear();
                            else
                                await _lstInternalIdsNeedingReapplyImprovements.ClearAsync(token).ConfigureAwait(false);

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_Improvements", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("Tab_Improvements", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_imp", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_imp", loadActivity, token).ConfigureAwait(false))
                            {
                                // Improvements.
                                objXmlNodeList = objXmlCharacter.SelectNodes("improvements/improvement");
                                string strCharacterInnerXml = objXmlCharacter.InnerXml;
                                bool blnRemoveImprovements = Utils.IsUnitTest;
                                foreach (XmlNode objXmlImprovement in objXmlNodeList)
                                {
                                    string strImprovementSource = objXmlImprovement["improvementsource"]?.InnerText;
                                    switch (strImprovementSource)
                                    {
                                        // Do not load condition monitor improvements from older versions of Chummer
                                        case "ConditionMonitor":
                                            continue;
                                        // Load Edge use improvements from older versions of Chummer directly into Character's Edge Use property
                                        case "EdgeUse":
                                            decimal decOldEdgeUsed = 0;
                                            if (objXmlImprovement.TryGetDecFieldQuickly("aug", ref decOldEdgeUsed))
                                                EdgeUsed = (-decOldEdgeUsed).StandardRound();
                                            continue;
                                        case "EssenceLoss":
                                        case "EssenceLossChargen":
                                            // Do not load essence loss improvements if this character does not have any attributes affected by essence loss
                                            if (_decEssenceAtSpecialStart == decimal.MinValue)
                                                continue;
                                            break;
                                    }

                                    string strLoopSourceName = objXmlImprovement["sourcename"]?.InnerText;
                                    if ((blnRemoveImprovements || showWarnings)
                                        && !string.IsNullOrEmpty(strLoopSourceName)
                                        && strLoopSourceName.IsGuid()
                                        && objXmlImprovement["custom"]?.InnerText != bool.TrueString)
                                    {
                                        // Hacky way to make sure this character isn't loading in any orphaned improvements.
                                        // SourceName ID will pop up minimum twice in the save if the improvement's source is actually present:
                                        // once in the improvement and once in the parent that added it.
                                        int intFirstIdIndex =
                                            strCharacterInnerXml.IndexOf(strLoopSourceName,
                                                                         StringComparison.Ordinal);
                                        int intLastIdIndex =
                                            strCharacterInnerXml.LastIndexOf(strLoopSourceName,
                                                                             StringComparison.Ordinal);
                                        // Catch orphaned improvements that used to have the same source parent by making sure that at least one of
                                        // the IDs found is not an improvement's `<sourcename>` node's contents.
                                        // Spans are faster than substrings because they do not make allocations, so that is why they are used
                                        if (intFirstIdIndex >= 12
                                            && strCharacterInnerXml.AsSpan(intFirstIdIndex - 12, 12) ==
                                            "<sourcename>".AsSpan())
                                        {
                                            while (intLastIdIndex > intFirstIdIndex
                                                   && strCharacterInnerXml.AsSpan(intLastIdIndex - 12, 12) ==
                                                   "<sourcename>".AsSpan())
                                            {
                                                intLastIdIndex =
                                                    strCharacterInnerXml.LastIndexOf(strLoopSourceName,
                                                        intLastIdIndex,
                                                        StringComparison.Ordinal);
                                            }
                                        }

                                        if (intFirstIdIndex == intLastIdIndex)
                                        {
                                            //Utils.BreakIfDebug();
                                            if (blnRemoveImprovements
                                                || (Program.ShowMessageBox(
                                                        blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString(
                                                                "Message_OrphanedImprovements", token: token)
                                                            : await LanguageManager.GetStringAsync(
                                                                "Message_OrphanedImprovements", token: token).ConfigureAwait(false),
                                                        blnSync
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            ? LanguageManager.GetString(
                                                                "MessageTitle_OrphanedImprovements", token: token)
                                                            : await LanguageManager.GetStringAsync(
                                                                "MessageTitle_OrphanedImprovements", token: token).ConfigureAwait(false),
                                                        MessageBoxButtons.YesNo, MessageBoxIcon.Error) ==
                                                    DialogResult.Yes))
                                            {
                                                blnRemoveImprovements = true;
                                                continue;
                                            }

                                            return false;
                                        }
                                    }

                                    Improvement objImprovement = new Improvement(this);
                                    try
                                    {
                                        objImprovement.Load(objXmlImprovement);
                                        // This is initially set to false make sure no property changers are triggered
                                        objImprovement.SetupComplete = true;
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstImprovements.Add(objImprovement);
                                        else
                                            await _lstImprovements.AddAsync(objImprovement, token).ConfigureAwait(false);

                                        if (objImprovement.ImproveType ==
                                            Improvement.ImprovementType.SkillsoftAccess &&
                                            objImprovement.Value == 0)
                                        {
                                            if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                _lstInternalIdsNeedingReapplyImprovements.Add(objImprovement
                                                    .SourceName);
                                            else
                                                await _lstInternalIdsNeedingReapplyImprovements.AddAsync(objImprovement
                                                    .SourceName, token).ConfigureAwait(false);
                                        }
                                        // Cyberadept fix
                                        else if (LastSavedVersion <= new Version(5, 212, 78)
                                                 && objImprovement.ImproveSource ==
                                                 Improvement.ImprovementSource.Echo
                                                 && objImprovement.ImproveType ==
                                                 Improvement.ImprovementType.Attribute
                                                 && objImprovement.ImprovedName == "RESBase"
                                                 && objImprovement.Value > 0
                                                 && objImprovement.Value == objImprovement.Augmented)
                                        {
                                            // Cyberadept in these versions was an echo. It is no longer an echo, and so needs a more complicated reapplication
                                            if (Settings.SpecialKarmaCostBasedOnShownValue)
                                            {
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    _lstImprovements.Remove(objImprovement);
                                                else
                                                    await _lstImprovements.RemoveAsync(objImprovement, token).ConfigureAwait(false);
                                            }
                                            else
                                                lstCyberadeptSweepGrades.Add(objImprovement);
                                        }
                                    }
                                    catch (ArgumentException)
                                    {
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstInternalIdsNeedingReapplyImprovements.Add(
                                                objXmlImprovement["sourcename"]?.InnerText);
                                        else
                                            await _lstInternalIdsNeedingReapplyImprovements.AddAsync(
                                                objXmlImprovement["sourcename"]?.InnerText, token).ConfigureAwait(false);
                                    }
                                }

                                //Timekeeper.Finish("load_char_imp");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Label_Contacts", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("Label_Contacts", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_contacts", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_contacts", loadActivity, token).ConfigureAwait(false))
                            {
                                // Contacts.
                                foreach (XPathNavigator xmlContact in
                                         (blnSync
                                             // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                             ? xmlCharacterNavigator.SelectAndCacheExpression("contacts/contact")
                                             : await xmlCharacterNavigator.SelectAndCacheExpressionAsync(
                                                 "contacts/contact", token: token).ConfigureAwait(false)))
                                {
                                    Contact objContact = new Contact(this);
                                    objContact.Load(xmlContact);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstContacts.Add(objContact);
                                    else
                                        await _lstContacts.AddAsync(objContact, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_contacts");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("String_Qualities", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("String_Qualities", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_quality", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_quality", loadActivity, token).ConfigureAwait(false))
                            {
                                // Qualities

                                objXmlNodeList = objXmlCharacter.SelectNodes("qualities/quality");
                                bool blnHasOldQualities = false;
                                xmlRootQualitiesNode =
                                    (blnSync
                                        // ReSharper disable once MethodHasAsyncOverload
                                        ? LoadData("qualities.xml", token: token)
                                        : await LoadDataAsync("qualities.xml", token: token).ConfigureAwait(false))
                                    .SelectSingleNode("/chummer/qualities");
                                foreach (XmlNode objXmlQuality in objXmlNodeList)
                                {
                                    if (objXmlQuality["name"] != null)
                                    {
                                        if (!CorrectedUnleveledQuality(objXmlQuality, xmlRootQualitiesNode))
                                        {
                                            Quality objQuality = new Quality(this);
                                            objQuality.Load(objXmlQuality);
                                            // Corrects an issue arising from older versions of CorrectedUnleveledQuality()
                                            if (_lstQualities.Any(x => x.InternalId == objQuality.InternalId))
                                                objQuality.SetGUID(Guid.NewGuid());
                                            if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                _lstQualities.Add(objQuality);
                                            else
                                                await _lstQualities.AddAsync(objQuality, token).ConfigureAwait(false);
                                            if ((blnSync
                                                    // ReSharper disable once MethodHasAsyncOverload
                                                    ? objQuality.GetNodeXPath(token: token)
                                                    : await objQuality.GetNodeXPathAsync(token: token).ConfigureAwait(false))
                                                ?.SelectSingleNode("bonus/addgear/name")
                                                ?.Value ==
                                                "Living Persona")
                                                objLivingPersonaQuality = objQuality;
                                            // Legacy shim
                                            if (LastSavedVersion <= new Version(5, 195, 1)
                                                && (objQuality.Name == "The Artisan's Way"
                                                    || objQuality.Name == "The Artist's Way"
                                                    || objQuality.Name == "The Athlete's Way"
                                                    || objQuality.Name == "The Burnout's Way"
                                                    || objQuality.Name == "The Invisible Way"
                                                    || objQuality.Name == "The Magician's Way"
                                                    || objQuality.Name == "The Speaker's Way"
                                                    || objQuality.Name == "The Warrior's Way")
                                                && objQuality.Bonus?.HasChildNodes == false)
                                            {
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    ImprovementManager.RemoveImprovements(this,
                                                        Improvement.ImprovementSource.Quality,
                                                        objQuality.InternalId);
                                                else
                                                    await ImprovementManager.RemoveImprovementsAsync(this,
                                                        Improvement.ImprovementSource.Quality,
                                                        objQuality.InternalId, token).ConfigureAwait(false);
                                                XmlNode objNode = blnSync
                                                    // ReSharper disable once MethodHasAsyncOverload
                                                    ? objQuality.GetNode(token: token)
                                                    : await objQuality.GetNodeAsync(token: token).ConfigureAwait(false);
                                                if (objNode != null)
                                                {
                                                    objQuality.Bonus = objNode["bonus"];
                                                    if (objQuality.Bonus != null)
                                                    {
                                                        ImprovementManager.ForcedValue = objQuality.Extra;
                                                        if (blnSync)
                                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                            ImprovementManager.CreateImprovements(this,
                                                                Improvement.ImprovementSource.Quality,
                                                                objQuality.InternalId, objQuality.Bonus, 1,
                                                                objQuality.CurrentDisplayNameShort);
                                                        else
                                                            await ImprovementManager.CreateImprovementsAsync(this,
                                                                Improvement.ImprovementSource.Quality,
                                                                objQuality.InternalId, objQuality.Bonus, 1,
                                                                await objQuality.GetCurrentDisplayNameShortAsync(token), token: token).ConfigureAwait(false);
                                                        if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                                        {
                                                            objQuality.Extra = ImprovementManager.SelectedValue;
                                                        }
                                                    }

                                                    objQuality.FirstLevelBonus = objNode["firstlevelbonus"];
                                                    if (objQuality.FirstLevelBonus?.HasChildNodes == true)
                                                    {
                                                        bool blnDoFirstLevel = true;
                                                        foreach (Quality objCheckQuality in Qualities)
                                                        {
                                                            if (objCheckQuality != objQuality &&
                                                                objCheckQuality.SourceIDString ==
                                                                objQuality.SourceIDString &&
                                                                objCheckQuality.Extra == objQuality.Extra &&
                                                                objCheckQuality.SourceName == objQuality.SourceName)
                                                            {
                                                                blnDoFirstLevel = false;
                                                                break;
                                                            }
                                                        }

                                                        if (blnDoFirstLevel)
                                                        {
                                                            ImprovementManager.ForcedValue = objQuality.Extra;
                                                            if (blnSync)
                                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                                ImprovementManager.CreateImprovements(this,
                                                                    Improvement.ImprovementSource.Quality,
                                                                    objQuality.InternalId,
                                                                    objQuality.FirstLevelBonus, 1,
                                                                    objQuality.CurrentDisplayNameShort);
                                                            else
                                                                await ImprovementManager.CreateImprovementsAsync(this,
                                                                    Improvement.ImprovementSource.Quality,
                                                                    objQuality.InternalId,
                                                                    objQuality.FirstLevelBonus, 1,
                                                                    await objQuality.GetCurrentDisplayNameShortAsync(token), token: token).ConfigureAwait(false);
                                                            if (!string.IsNullOrEmpty(ImprovementManager
                                                                    .SelectedValue))
                                                            {
                                                                objQuality.Extra = ImprovementManager.SelectedValue;
                                                            }
                                                        }
                                                    }
                                                }
                                                else
                                                {
                                                    // Failed to re-apply the improvements immediately, so let's just add it for processing when the character is opened
                                                    if (blnSync)
                                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                        _lstInternalIdsNeedingReapplyImprovements.Add(objQuality.InternalId);
                                                    else
                                                        await _lstInternalIdsNeedingReapplyImprovements.AddAsync(objQuality.InternalId, token).ConfigureAwait(false);
                                                }

                                                objQuality.NaturalWeaponsNode = objNode["naturalweapons"];
                                                if (objQuality.NaturalWeaponsNode != null)
                                                {
                                                    ImprovementManager.ForcedValue = objQuality.Extra;
                                                    if (blnSync)
                                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                        ImprovementManager.CreateImprovements(this,
                                                            Improvement.ImprovementSource.Quality,
                                                            objQuality.InternalId, objQuality.NaturalWeaponsNode, 1,
                                                            objQuality.CurrentDisplayNameShort);
                                                    else
                                                        await ImprovementManager.CreateImprovementsAsync(this,
                                                            Improvement.ImprovementSource.Quality,
                                                            objQuality.InternalId, objQuality.NaturalWeaponsNode, 1,
                                                            await objQuality.GetCurrentDisplayNameShortAsync(token), token: token).ConfigureAwait(false);
                                                    if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                                    {
                                                        objQuality.Extra = ImprovementManager.SelectedValue;
                                                    }
                                                }
                                            }

                                            if (LastSavedVersion <= new Version(5, 200, 0)
                                                && objQuality.Name == "Made Man"
                                                && objQuality.Bonus["selectcontact"] != null)
                                            {
                                                string selectedContactUniqueId = (Improvements.FirstOrDefault(x =>
                                                        x.SourceName == objQuality.InternalId &&
                                                        x.ImproveType == Improvement.ImprovementType
                                                            .ContactForcedLoyalty))
                                                    ?.ImprovedName;
                                                if (string.IsNullOrWhiteSpace(selectedContactUniqueId))
                                                {
                                                    selectedContactUniqueId =
                                                        Contacts.FirstOrDefault(x => x.Name == objQuality.Extra)
                                                                ?.UniqueId;
                                                }

                                                if (string.IsNullOrWhiteSpace(selectedContactUniqueId))
                                                {
                                                    // Populate the Magician Traditions list.
                                                    using (new FetchSafelyFromPool<List<ListItem>>(
                                                               Utils.ListItemListPool,
                                                               out List<ListItem> lstContacts))
                                                    {
                                                        foreach (Contact objContact in Contacts)
                                                        {
                                                            if (objContact.IsGroup)
                                                                lstContacts.Add(new ListItem(objContact.Name,
                                                                    objContact.UniqueId));
                                                        }

                                                        if (lstContacts.Count > 1)
                                                        {
                                                            lstContacts.Sort(CompareListItems.CompareNames);
                                                        }

                                                        if (blnSync)
                                                        {
                                                            // ReSharper disable once MethodHasAsyncOverload
                                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                            using (ThreadSafeForm<SelectItem> frmPickItem = ThreadSafeForm<SelectItem>.Get(() => new SelectItem()))
                                                            {
                                                                frmPickItem.MyForm.SetDropdownItemsMode(lstContacts);
                                                                // ReSharper disable once MethodHasAsyncOverload
                                                                if (frmPickItem.ShowDialogSafe(this, token) != DialogResult.OK)
                                                                {
                                                                    return false;
                                                                }
                                                                selectedContactUniqueId = frmPickItem.MyForm.SelectedItem;
                                                            }
                                                        }
                                                        else
                                                        {
                                                            using (ThreadSafeForm<SelectItem> frmPickItem = await ThreadSafeForm<SelectItem>.GetAsync(() => new SelectItem(), token).ConfigureAwait(false))
                                                            {
                                                                frmPickItem.MyForm.SetDropdownItemsMode(lstContacts);
                                                                if (await frmPickItem.ShowDialogSafeAsync(this, token).ConfigureAwait(false) != DialogResult.OK)
                                                                {
                                                                    return false;
                                                                }
                                                                selectedContactUniqueId = frmPickItem.MyForm.SelectedItem;
                                                            }
                                                        }
                                                    }
                                                }

                                                objQuality.Bonus =
                                                    xmlRootQualitiesNode.SelectSingleNode(
                                                        "quality[name=\"Made Man\"]/bonus");
                                                objQuality.Extra = string.Empty;
                                                if (blnSync)
                                                {
                                                    // ReSharper disable MethodHasAsyncOverloadWithCancellation
                                                    ImprovementManager.RemoveImprovements(this,
                                                        Improvement.ImprovementSource.Quality,
                                                        objQuality.InternalId);
                                                    ImprovementManager.CreateImprovement(this, string.Empty,
                                                        Improvement.ImprovementSource.Quality, objQuality.InternalId,
                                                        Improvement.ImprovementType.MadeMan,
                                                        objQuality.CurrentDisplayNameShort);
                                                    ImprovementManager.CreateImprovement(this, selectedContactUniqueId,
                                                        Improvement.ImprovementSource.Quality, objQuality.InternalId,
                                                        Improvement.ImprovementType.AddContact,
                                                        objQuality.CurrentDisplayNameShort);
                                                    ImprovementManager.CreateImprovement(this, selectedContactUniqueId,
                                                        Improvement.ImprovementSource.Quality, objQuality.InternalId,
                                                        Improvement.ImprovementType.ContactForcedLoyalty,
                                                        objQuality.CurrentDisplayNameShort);
                                                    ImprovementManager.CreateImprovement(this, selectedContactUniqueId,
                                                        Improvement.ImprovementSource.Quality, objQuality.InternalId,
                                                        Improvement.ImprovementType.ContactForceGroup,
                                                        objQuality.CurrentDisplayNameShort);
                                                    ImprovementManager.CreateImprovement(this, selectedContactUniqueId,
                                                        Improvement.ImprovementSource.Quality, objQuality.InternalId,
                                                        Improvement.ImprovementType.ContactMakeFree,
                                                        objQuality.CurrentDisplayNameShort);
                                                    ImprovementManager.Commit(this);
                                                    // ReSharper restore MethodHasAsyncOverloadWithCancellation
                                                }
                                                else
                                                {
                                                    await ImprovementManager.RemoveImprovementsAsync(this,
                                                        Improvement.ImprovementSource.Quality,
                                                        objQuality.InternalId, token).ConfigureAwait(false);
                                                    await ImprovementManager.CreateImprovementAsync(this, string.Empty,
                                                        Improvement.ImprovementSource.Quality, objQuality.InternalId,
                                                        Improvement.ImprovementType.MadeMan,
                                                        objQuality.CurrentDisplayNameShort, token: token).ConfigureAwait(false);
                                                    await ImprovementManager.CreateImprovementAsync(
                                                        this, selectedContactUniqueId,
                                                        Improvement.ImprovementSource.Quality, objQuality.InternalId,
                                                        Improvement.ImprovementType.AddContact,
                                                        objQuality.CurrentDisplayNameShort, token: token).ConfigureAwait(false);
                                                    await ImprovementManager.CreateImprovementAsync(
                                                        this, selectedContactUniqueId,
                                                        Improvement.ImprovementSource.Quality, objQuality.InternalId,
                                                        Improvement.ImprovementType.ContactForcedLoyalty,
                                                        objQuality.CurrentDisplayNameShort, token: token).ConfigureAwait(false);
                                                    await ImprovementManager.CreateImprovementAsync(
                                                        this, selectedContactUniqueId,
                                                        Improvement.ImprovementSource.Quality, objQuality.InternalId,
                                                        Improvement.ImprovementType.ContactForceGroup,
                                                        objQuality.CurrentDisplayNameShort, token: token).ConfigureAwait(false);
                                                    await ImprovementManager.CreateImprovementAsync(
                                                        this, selectedContactUniqueId,
                                                        Improvement.ImprovementSource.Quality, objQuality.InternalId,
                                                        Improvement.ImprovementType.ContactMakeFree,
                                                        objQuality.CurrentDisplayNameShort, token: token).ConfigureAwait(false);
                                                    await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);
                                                }
                                            }

                                            if (LastSavedVersion <= new Version(5, 212, 43)
                                                && objQuality.Name == "Inspired"
                                                && objQuality.Source == "SASS"
                                                && objQuality.Bonus["selectexpertise"] == null)
                                            {
                                                // Old handling of SASS' Inspired quality was both hardcoded and wrong
                                                // Since SASS' Inspired requires the player to choose a specialization, we always need a prompt,
                                                // so add the quality to the list for processing when the character is opened.
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    _lstInternalIdsNeedingReapplyImprovements.Add(objQuality.InternalId);
                                                else
                                                    await _lstInternalIdsNeedingReapplyImprovements.AddAsync(objQuality.InternalId, token).ConfigureAwait(false);
                                            }

                                            if (LastSavedVersion <= new Version(5, 212, 56)
                                                && objQuality.Name == "Chain Breaker"
                                                && objQuality.Bonus == null)
                                            {
                                                // Chain Breaker bonus requires manual selection of two spirit types, so we need a prompt.
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    _lstInternalIdsNeedingReapplyImprovements.Add(objQuality.InternalId);
                                                else
                                                    await _lstInternalIdsNeedingReapplyImprovements.AddAsync(objQuality.InternalId, token).ConfigureAwait(false);
                                            }

                                            if (LastSavedVersion <= new Version(5, 212, 78)
                                                && objQuality.Name == "Resonant Stream: Cyberadept"
                                                && objQuality.Bonus == null)
                                            {
                                                objQuality.Bonus =
                                                    xmlRootQualitiesNode.SelectSingleNode(
                                                        "quality[name=\"Resonant Stream: Cyberadept\"]/bonus");
                                                if (blnSync)
                                                {
                                                    // ReSharper disable MethodHasAsyncOverloadWithCancellation
                                                    ImprovementManager.RemoveImprovements(this,
                                                        Improvement.ImprovementSource.Quality,
                                                        objQuality.InternalId);
                                                    ImprovementManager.CreateImprovement(this, string.Empty,
                                                        Improvement.ImprovementSource.Quality, objQuality.InternalId,
                                                        Improvement.ImprovementType.CyberadeptDaemon,
                                                        objQuality.CurrentDisplayNameShort);
                                                    ImprovementManager.Commit(this);
                                                    // ReSharper restore MethodHasAsyncOverloadWithCancellation
                                                }
                                                else
                                                {
                                                    await ImprovementManager.RemoveImprovementsAsync(this,
                                                        Improvement.ImprovementSource.Quality,
                                                        objQuality.InternalId, token: token).ConfigureAwait(false);
                                                    await ImprovementManager.CreateImprovementAsync(this, string.Empty,
                                                        Improvement.ImprovementSource.Quality, objQuality.InternalId,
                                                        Improvement.ImprovementType.CyberadeptDaemon,
                                                        objQuality.CurrentDisplayNameShort, token: token).ConfigureAwait(false);
                                                    await ImprovementManager.CommitAsync(this, token).ConfigureAwait(false);
                                                }
                                            }
                                        }
                                    }
                                    else
                                    {
                                        // If the Quality does not have a name tag, it is in the old format. Set the flag to show that old Qualities are in use.
                                        blnHasOldQualities = true;
                                    }
                                }

                                // If old Qualities are in use, they need to be converted before loading can continue.
                                if (blnHasOldQualities)
                                    ConvertOldQualities(objXmlNodeList);
                                //Timekeeper.Finish("load_char_quality");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Label_Attributes", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("Label_Attributes", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_attributes", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_attributes", loadActivity, token).ConfigureAwait(false))
                            {
                                AttributeSection.Load(objXmlCharacter, token);
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("String_Tradition", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("String_Tradition", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_misc2", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_misc2", loadActivity, token).ConfigureAwait(false))
                            {
                                // Attempt to load the split MAG CharacterAttribute information for Mystic Adepts.
                                if (_blnAdeptEnabled && _blnMagicianEnabled)
                                {
                                    xmlCharacterNavigator.TryGetInt32FieldQuickly("magsplitadept",
                                        ref _intMAGAdept);
                                    xmlCharacterNavigator.TryGetInt32FieldQuickly("magsplitmagician",
                                        ref _intMAGMagician);
                                }

                                // Attempt to load in the character's tradition (or equivalent for Technomancers)
                                string strTemp = string.Empty;
                                if (xmlCharacterNavigator.TryGetStringFieldQuickly("stream", ref strTemp) &&
                                    !string.IsNullOrEmpty(strTemp) && RESEnabled)
                                {
                                    // Legacy load a Technomancer tradition
                                    XmlNode xmlTraditionListDataNode =
                                        (blnSync
                                            // ReSharper disable once MethodHasAsyncOverload
                                            ? LoadData("streams.xml", token: token)
                                            : await LoadDataAsync("streams.xml", token: token).ConfigureAwait(false))
                                        .SelectSingleNode("/chummer/traditions");
                                    if (xmlTraditionListDataNode != null)
                                    {
                                        XmlNode xmlTraditionDataNode =
                                            xmlTraditionListDataNode.SelectSingleNode("tradition[name = " +
                                                strTemp.CleanXPath() + ']');
                                        if (xmlTraditionDataNode != null)
                                        {
                                            if (!_objTradition.Create(xmlTraditionDataNode, true))
                                                _objTradition.ResetTradition();
                                        }
                                        else
                                        {
                                            xmlTraditionDataNode =
                                                xmlTraditionListDataNode.SelectSingleNode(
                                                    "tradition[name = \"Default\"]");
                                            if (xmlTraditionDataNode != null)
                                            {
                                                if (!_objTradition.Create(xmlTraditionDataNode, true))
                                                    _objTradition.ResetTradition();
                                            }
                                            else
                                            {
                                                xmlTraditionDataNode =
                                                    xmlTraditionListDataNode.SelectSingleNode("tradition");
                                                if (xmlTraditionDataNode != null &&
                                                    !_objTradition.Create(xmlTraditionDataNode, true))
                                                    _objTradition.ResetTradition();
                                            }
                                        }
                                    }

                                    if (_objTradition.Type != TraditionType.None)
                                    {
                                        _objTradition.LegacyLoad(xmlCharacterNavigator);
                                    }
                                }
                                else
                                {
                                    XPathNavigator xpathTraditionNavigator =
                                        xmlCharacterNavigator.SelectSingleNode("tradition");
                                    // Regular tradition load
                                    if (xpathTraditionNavigator?.SelectSingleNode("guid") != null ||
                                        xpathTraditionNavigator?.SelectSingleNode("id") != null)
                                    {
                                        _objTradition.Load(objXmlCharacter.SelectSingleNode("tradition"));
                                    }
                                    // Not null but doesn't have children -> legacy load a magical tradition
                                    else if (xpathTraditionNavigator != null && MAGEnabled)
                                    {
                                        XmlNode xmlTraditionListDataNode =
                                            (blnSync
                                                // ReSharper disable once MethodHasAsyncOverload
                                                ? LoadData("traditions.xml", token: token)
                                                : await LoadDataAsync("traditions.xml", token: token).ConfigureAwait(false))
                                            .SelectSingleNode("/chummer/traditions");
                                        if (xmlTraditionListDataNode != null)
                                        {
                                            xmlCharacterNavigator.TryGetStringFieldQuickly("tradition",
                                                ref strTemp);
                                            XmlNode xmlTraditionDataNode =
                                                xmlTraditionListDataNode.SelectSingleNode(
                                                    "tradition[name = " + strTemp.CleanXPath() + ']');
                                            if (xmlTraditionDataNode != null)
                                            {
                                                if (!_objTradition.Create(xmlTraditionDataNode))
                                                    _objTradition.ResetTradition();
                                            }
                                            else
                                            {
                                                xmlTraditionDataNode =
                                                    xmlTraditionListDataNode.SelectSingleNode(
                                                        "tradition[id = " +
                                                        Tradition.CustomMagicalTraditionGuid.CleanXPath() + ']');
                                                if (xmlTraditionDataNode != null &&
                                                    !_objTradition.Create(xmlTraditionDataNode))
                                                {
                                                    _objTradition.ResetTradition();
                                                }
                                            }
                                        }

                                        if (_objTradition.Type != TraditionType.None)
                                        {
                                            _objTradition.LegacyLoad(xmlCharacterNavigator);
                                        }
                                    }
                                }

                                // Attempt to load Condition Monitor Progress.
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("physicalcmfilled",
                                                                              ref _intPhysicalCMFilled);
                                xmlCharacterNavigator.TryGetInt32FieldQuickly("stuncmfilled", ref _intStunCMFilled);

                                xmlCharacterNavigator.TryGetBoolFieldQuickly("psyche", ref _blnPsycheActive);
                                //Timekeeper.Finish("load_char_misc2");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_Skills", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("Tab_Skills", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_skills", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_skills", loadActivity, token).ConfigureAwait(false)) //slightly messy
                            {
                                _oldSkillsBackup = objXmlCharacter.SelectSingleNode("skills")?.Clone();
                                _oldSkillGroupBackup = objXmlCharacter.SelectSingleNode("skillgroups")?.Clone();

                                XmlNode objSkillNode = objXmlCharacter.SelectSingleNode("newskills");
                                if (objSkillNode != null)
                                {
                                    SkillsSection.Load(objSkillNode, false, loadActivity);
                                }
                                else
                                {
                                    SkillsSection.Load(objXmlCharacter, true, loadActivity);
                                }

                                //Timekeeper.Finish("load_char_skills");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("String_Locations", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("String_Locations", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_loc", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_loc", loadActivity, token).ConfigureAwait(false))
                            {
                                // Locations.
                                objXmlLocationList = objXmlCharacter.SelectNodes("gearlocations/gearlocation");
                                foreach (XmlNode objXmlLocation in objXmlLocationList)
                                {
                                    Location objLocation = new Location(this, _lstGearLocations);
                                    objLocation.Load(objXmlLocation);
                                }

                                objXmlLocationList = objXmlCharacter.SelectNodes("locations/location");
                                foreach (XmlNode objXmlLocation in objXmlLocationList)
                                {
                                    Location objLocation = new Location(this, _lstGearLocations);
                                    objLocation.Load(objXmlLocation);
                                }

                                objXmlLocationList = objXmlCharacter.SelectNodes("gearlocations/location");
                                foreach (XmlNode objXmlLocation in objXmlLocationList)
                                {
                                    Location objLocation = new Location(this, _lstGearLocations);
                                    objLocation.Load(objXmlLocation);
                                }

                                //Timekeeper.Finish("load_char_loc");
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_abundle", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_abundle", loadActivity, token).ConfigureAwait(false))
                            {
                                // Armor Bundles.
                                objXmlLocationList = objXmlCharacter.SelectNodes("armorbundles/armorbundle");
                                foreach (XmlNode objXmlLocation in objXmlLocationList)
                                {
                                    Location objLocation = new Location(this, _lstArmorLocations);
                                    objLocation.Load(objXmlLocation);
                                }

                                objXmlLocationList = objXmlCharacter.SelectNodes("armorlocations/armorlocation");
                                foreach (XmlNode objXmlLocation in objXmlLocationList)
                                {
                                    Location objLocation = new Location(this, _lstArmorLocations);
                                    objLocation.Load(objXmlLocation);
                                }

                                objXmlLocationList = objXmlCharacter.SelectNodes("armorlocations/location");
                                foreach (XmlNode objXmlLocation in objXmlLocationList)
                                {
                                    Location objLocation = new Location(this, _lstArmorLocations);
                                    objLocation.Load(objXmlLocation);
                                }

                                //Timekeeper.Finish("load_char_abundle");
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_vloc", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_vloc", loadActivity, token).ConfigureAwait(false))
                            {
                                // Vehicle Locations.
                                XmlNodeList objXmlVehicleLocationList =
                                    objXmlCharacter.SelectNodes("vehiclelocations/vehiclelocation");
                                foreach (XmlNode objXmlLocation in objXmlVehicleLocationList)
                                {
                                    Location objLocation = new Location(this, _lstVehicleLocations);
                                    objLocation.Load(objXmlLocation);
                                }

                                objXmlVehicleLocationList =
                                    objXmlCharacter.SelectNodes("vehiclelocations/location");
                                foreach (XmlNode objXmlLocation in objXmlVehicleLocationList)
                                {
                                    Location objLocation = new Location(this, _lstVehicleLocations);
                                    objLocation.Load(objXmlLocation);
                                }

                                //Timekeeper.Finish("load_char_vloc");
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_wloc", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_wloc", loadActivity, token).ConfigureAwait(false))
                            {
                                // Weapon Locations.
                                XmlNodeList objXmlWeaponLocationList =
                                    objXmlCharacter.SelectNodes("weaponlocations/weaponlocation");
                                foreach (XmlNode objXmlLocation in objXmlWeaponLocationList)
                                {
                                    Location objLocation = new Location(this, _lstWeaponLocations);
                                    objLocation.Load(objXmlLocation);
                                }

                                objXmlWeaponLocationList = objXmlCharacter.SelectNodes("weaponlocations/location");
                                foreach (XmlNode objXmlLocation in objXmlWeaponLocationList)
                                {
                                    Location objLocation = new Location(this, _lstWeaponLocations);
                                    objLocation.Load(objXmlLocation);
                                }

                                //Timekeeper.Finish("load_char_wloc");
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_sfoci", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_sfoci", loadActivity, token).ConfigureAwait(false))
                            {
                                // Stacked Foci.
                                objXmlNodeList = objXmlCharacter.SelectNodes("stackedfoci/stackedfocus");
                                foreach (XmlNode objXmlStack in objXmlNodeList)
                                {
                                    StackedFocus objStack = new StackedFocus(this);
                                    objStack.Load(objXmlStack);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstStackedFoci.Add(objStack);
                                    else
                                        await _lstStackedFoci.AddAsync(objStack, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_sfoci");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_Armor", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("Tab_Armor", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_armor", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_armor", loadActivity, token).ConfigureAwait(false))
                            {
                                // Armor.
                                objXmlNodeList = objXmlCharacter.SelectNodes("armors/armor");
                                foreach (XmlNode objXmlArmor in objXmlNodeList)
                                {
                                    Armor objArmor = new Armor(this);
                                    objArmor.Load(objXmlArmor);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstArmor.Add(objArmor);
                                    else
                                        await _lstArmor.AddAsync(objArmor, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_armor");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_Drugs", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("Tab_Drugs", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_drugs", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_drugs", loadActivity, token).ConfigureAwait(false))
                            {
                                // Drugs.
                                objXmlNodeList = objXmlDocument.SelectNodes("/character/drugs/drug");
                                foreach (XmlNode objXmlDrug in objXmlNodeList)
                                {
                                    Drug objDrug = new Drug(this);
                                    objDrug.Load(objXmlDrug);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstDrugs.Add(objDrug);
                                    else
                                        await _lstDrugs.AddAsync(objDrug, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_drugs");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_Cyberware", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("Tab_Cyberware", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_ware", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_ware", loadActivity, token).ConfigureAwait(false))
                            {
                                // Cyberware/Bioware.
                                objXmlNodeList = objXmlCharacter.SelectNodes("cyberwares/cyberware");
                                // Dictionary for instantly re-applying outdated improvements for 'ware with pair bonuses in legacy shim
                                Dictionary<Cyberware, int> dicPairableCyberwares =
                                    new Dictionary<Cyberware, int>(objXmlNodeList.Count);
                                foreach (XmlNode objXmlCyberware in objXmlNodeList)
                                {
                                    Cyberware objCyberware = new Cyberware(this);
                                    objCyberware.Load(objXmlCyberware);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstCyberware.Add(objCyberware);
                                    else
                                        await _lstCyberware.AddAsync(objCyberware, token).ConfigureAwait(false);
                                    // Legacy shim #1
                                    if (objCyberware.Name == "Myostatin Inhibitor" &&
                                        LastSavedVersion <= new Version(5, 195, 1) &&
                                        !Improvements.Any(x =>
                                                              x.SourceName == objCyberware.InternalId &&
                                                              x.ImproveType == Improvement.ImprovementType
                                                                  .AttributeKarmaCost))
                                    {
                                        XmlNode objNode = blnSync
                                            // ReSharper disable once MethodHasAsyncOverload
                                            ? objCyberware.GetNode(token: token)
                                            : await objCyberware.GetNodeAsync(token: token).ConfigureAwait(false);
                                        if (objNode != null)
                                        {
                                            if (blnSync)
                                            {
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                ImprovementManager.RemoveImprovements(this, objCyberware.SourceType,
                                                    objCyberware.InternalId);
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                ImprovementManager.RemoveImprovements(this, objCyberware.SourceType,
                                                    objCyberware.InternalId + "Pair");
                                            }
                                            else
                                            {
                                                await ImprovementManager.RemoveImprovementsAsync(this, objCyberware.SourceType,
                                                    objCyberware.InternalId, token: token).ConfigureAwait(false);
                                                await ImprovementManager.RemoveImprovementsAsync(this, objCyberware.SourceType,
                                                    objCyberware.InternalId + "Pair", token: token).ConfigureAwait(false);
                                            }
                                            objCyberware.Bonus = objNode["bonus"];
                                            objCyberware.WirelessBonus = objNode["wirelessbonus"];
                                            objCyberware.PairBonus = objNode["pairbonus"];
                                            if (!string.IsNullOrEmpty(objCyberware.Forced) &&
                                                objCyberware.Forced != "Right" &&
                                                objCyberware.Forced != "Left")
                                                ImprovementManager.ForcedValue = objCyberware.Forced;
                                            if (objCyberware.Bonus != null)
                                            {
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    ImprovementManager.CreateImprovements(this, objCyberware.SourceType,
                                                        objCyberware.InternalId, objCyberware.Bonus,
                                                        objCyberware.Rating,
                                                        objCyberware.CurrentDisplayNameShort);
                                                else
                                                    await ImprovementManager.CreateImprovementsAsync(
                                                        this, objCyberware.SourceType,
                                                        objCyberware.InternalId, objCyberware.Bonus,
                                                        await objCyberware.GetRatingAsync(token),
                                                        await objCyberware.GetCurrentDisplayNameShortAsync(token), token: token).ConfigureAwait(false);
                                                if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                                    objCyberware.Extra = ImprovementManager.SelectedValue;
                                            }

                                            if (objCyberware.WirelessOn && objCyberware.WirelessBonus != null)
                                            {
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    ImprovementManager.CreateImprovements(this, objCyberware.SourceType,
                                                        objCyberware.InternalId, objCyberware.WirelessBonus,
                                                        objCyberware.Rating,
                                                        objCyberware.CurrentDisplayNameShort);
                                                else
                                                    await ImprovementManager.CreateImprovementsAsync(
                                                        this, objCyberware.SourceType,
                                                        objCyberware.InternalId, objCyberware.WirelessBonus,
                                                        await objCyberware.GetRatingAsync(token),
                                                        await objCyberware.GetCurrentDisplayNameShortAsync(token), token: token).ConfigureAwait(false);
                                                if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue) &&
                                                    string.IsNullOrEmpty(objCyberware.Extra))
                                                    objCyberware.Extra = ImprovementManager.SelectedValue;
                                            }

                                            if (!objCyberware.IsModularCurrentlyEquipped)
                                            {
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    objCyberware.ChangeModularEquip(false);
                                                else
                                                    await objCyberware.ChangeModularEquipAsync(false, token: token);
                                            }
                                            else if (objCyberware.PairBonus != null)
                                            {
                                                Cyberware objMatchingCyberware =
                                                    dicPairableCyberwares.Keys.FirstOrDefault(
                                                        x =>
                                                            x.Name == objCyberware.Name &&
                                                            x.Extra == objCyberware.Extra);
                                                if (objMatchingCyberware != null)
                                                    ++dicPairableCyberwares[objMatchingCyberware];
                                                else
                                                    dicPairableCyberwares.Add(objCyberware, 1);
                                            }
                                        }
                                        else if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstInternalIdsNeedingReapplyImprovements.Add(objCyberware.InternalId);
                                        else
                                            await _lstInternalIdsNeedingReapplyImprovements.AddAsync(objCyberware.InternalId, token).ConfigureAwait(false);
                                    }
                                }

                                // Legacy Shim #2 (needed to be separate because we're dealing with PairBonuses here, and we don't know if something needs its PairBonus reapplied until all Cyberwares have been loaded)
                                if (LastSavedVersion <= new Version(5, 200, 0))
                                {
                                    foreach (Cyberware objCyberware in Cyberware)
                                    {
                                        if (objCyberware.PairBonus?.HasChildNodes == true &&
                                            !Cyberware.DeepAny(x => x.Children, x =>
                                            {
                                                if (!objCyberware.IncludePair.Contains(x.Name) ||
                                                    x.Extra != objCyberware.Extra ||
                                                    !x.IsModularCurrentlyEquipped)
                                                    return false;
                                                string strToMatch = x.InternalId + "Pair";
                                                return Improvements.Any(y => y.SourceName == strToMatch);
                                            }))
                                        {
                                            XmlNode objNode = blnSync
                                                // ReSharper disable once MethodHasAsyncOverload
                                                ? objCyberware.GetNode(token: token)
                                                : await objCyberware.GetNodeAsync(token: token).ConfigureAwait(false);
                                            if (objNode != null)
                                            {
                                                if (blnSync)
                                                {
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    ImprovementManager.RemoveImprovements(this, objCyberware.SourceType,
                                                        objCyberware.InternalId);
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    ImprovementManager.RemoveImprovements(this, objCyberware.SourceType,
                                                        objCyberware.InternalId + "Pair");
                                                }
                                                else
                                                {
                                                    await ImprovementManager.RemoveImprovementsAsync(this, objCyberware.SourceType,
                                                        objCyberware.InternalId, token: token).ConfigureAwait(false);
                                                    await ImprovementManager.RemoveImprovementsAsync(this, objCyberware.SourceType,
                                                        objCyberware.InternalId + "Pair", token: token).ConfigureAwait(false);
                                                }
                                                objCyberware.Bonus = objNode["bonus"];
                                                objCyberware.WirelessBonus = objNode["wirelessbonus"];
                                                objCyberware.PairBonus = objNode["pairbonus"];
                                                if (!string.IsNullOrEmpty(objCyberware.Forced) &&
                                                    objCyberware.Forced != "Right" &&
                                                    objCyberware.Forced != "Left")
                                                    ImprovementManager.ForcedValue = objCyberware.Forced;
                                                if (objCyberware.Bonus != null)
                                                {
                                                    if (blnSync)
                                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                        ImprovementManager.CreateImprovements(this,
                                                            objCyberware.SourceType,
                                                            objCyberware.InternalId, objCyberware.Bonus,
                                                            objCyberware.Rating,
                                                            objCyberware.CurrentDisplayNameShort);
                                                    else
                                                        await ImprovementManager.CreateImprovementsAsync(this,
                                                            objCyberware.SourceType,
                                                            objCyberware.InternalId, objCyberware.Bonus,
                                                            await objCyberware.GetRatingAsync(token),
                                                            await objCyberware.GetCurrentDisplayNameShortAsync(token), token: token).ConfigureAwait(false);
                                                    if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                                        objCyberware.Extra = ImprovementManager.SelectedValue;
                                                }

                                                if (objCyberware.WirelessOn && objCyberware.WirelessBonus != null)
                                                {
                                                    if (blnSync)
                                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                        ImprovementManager.CreateImprovements(this,
                                                            objCyberware.SourceType,
                                                            objCyberware.InternalId, objCyberware.WirelessBonus,
                                                            objCyberware.Rating,
                                                            objCyberware.CurrentDisplayNameShort);
                                                    else
                                                        await ImprovementManager.CreateImprovementsAsync(this,
                                                            objCyberware.SourceType,
                                                            objCyberware.InternalId, objCyberware.WirelessBonus,
                                                            await objCyberware.GetRatingAsync(token),
                                                            await objCyberware.GetCurrentDisplayNameShortAsync(token), token: token).ConfigureAwait(false);
                                                    if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue) &&
                                                        string.IsNullOrEmpty(objCyberware.Extra))
                                                        objCyberware.Extra = ImprovementManager.SelectedValue;
                                                }

                                                if (!objCyberware.IsModularCurrentlyEquipped)
                                                {
                                                    if (blnSync)
                                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                        objCyberware.ChangeModularEquip(false);
                                                    else
                                                        await objCyberware.ChangeModularEquipAsync(false, token: token);
                                                }
                                                else if (objCyberware.PairBonus != null)
                                                {
                                                    Cyberware objMatchingCyberware =
                                                        dicPairableCyberwares.Keys.FirstOrDefault(
                                                            x =>
                                                                x.Name == objCyberware.Name &&
                                                                x.Extra == objCyberware.Extra);
                                                    if (objMatchingCyberware != null)
                                                        ++dicPairableCyberwares[objMatchingCyberware];
                                                    else
                                                        dicPairableCyberwares.Add(objCyberware, 1);
                                                }
                                            }
                                            else if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                _lstInternalIdsNeedingReapplyImprovements.Add(objCyberware.InternalId);
                                            else
                                                await _lstInternalIdsNeedingReapplyImprovements.AddAsync(objCyberware.InternalId, token).ConfigureAwait(false);
                                        }
                                    }
                                }

                                // Separate Pass for PairBonuses
                                foreach (KeyValuePair<Cyberware, int> objItem in dicPairableCyberwares)
                                {
                                    Cyberware objCyberware = objItem.Key;
                                    int intCyberwaresCount = objItem.Value;
                                    List<Cyberware> lstPairableCyberwares = Cyberware.DeepWhere(x => x.Children,
                                        x => objCyberware.IncludePair.Contains(x.Name) &&
                                             x.Extra == objCyberware.Extra &&
                                             x.IsModularCurrentlyEquipped).ToList();
                                    // Need to use slightly different logic if this cyberware has a location (Left or Right) and only pairs with itself because Lefts can only be paired with Rights and Rights only with Lefts
                                    if (!string.IsNullOrEmpty(objCyberware.Location) &&
                                        objCyberware.IncludePair.All(x => x == objCyberware.Name))
                                    {
                                        int intMatchLocationCount = 0;
                                        int intNotMatchLocationCount = 0;
                                        foreach (Cyberware objPairableCyberware in lstPairableCyberwares)
                                        {
                                            if (objPairableCyberware.Location != objCyberware.Location)
                                                ++intNotMatchLocationCount;
                                            else
                                                ++intMatchLocationCount;
                                        }

                                        // Set the count to the total number of cyberwares in matching pairs, which would mean 2x the number of whichever location contains the fewest members (since every single one of theirs would have a pair)
                                        intCyberwaresCount =
                                            Math.Min(intNotMatchLocationCount, intMatchLocationCount) *
                                            2;
                                    }

                                    if (intCyberwaresCount > 0)
                                    {
                                        foreach (Cyberware objLoopCyberware in lstPairableCyberwares)
                                        {
                                            if ((intCyberwaresCount & 1) == 0)
                                            {
                                                if (!string.IsNullOrEmpty(objCyberware.Forced) &&
                                                    objCyberware.Forced != "Right" &&
                                                    objCyberware.Forced != "Left")
                                                    ImprovementManager.ForcedValue = objCyberware.Forced;
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    ImprovementManager.CreateImprovements(this,
                                                        objLoopCyberware.SourceType,
                                                        objLoopCyberware.InternalId + "Pair",
                                                        objLoopCyberware.PairBonus,
                                                        objLoopCyberware.Rating,
                                                        objLoopCyberware.CurrentDisplayNameShort);
                                                else
                                                    await ImprovementManager.CreateImprovementsAsync(this,
                                                        objLoopCyberware.SourceType,
                                                        objLoopCyberware.InternalId + "Pair",
                                                        objLoopCyberware.PairBonus,
                                                        await objLoopCyberware.GetRatingAsync(token),
                                                        await objLoopCyberware.GetCurrentDisplayNameShortAsync(token), token: token).ConfigureAwait(false);
                                                if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue) &&
                                                    string.IsNullOrEmpty(objCyberware.Extra))
                                                    objCyberware.Extra = ImprovementManager.SelectedValue;
                                            }

                                            --intCyberwaresCount;
                                            if (intCyberwaresCount <= 0)
                                                break;
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_ware");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Label_SelectedSpells", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("Label_SelectedSpells", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_spells", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_spells", loadActivity, token).ConfigureAwait(false))
                            {
                                // Spells.
                                objXmlNodeList = objXmlCharacter.SelectNodes("spells/spell");
                                foreach (XmlNode objXmlSpell in objXmlNodeList)
                                {
                                    Spell objSpell = new Spell(this);
                                    objSpell.Load(objXmlSpell);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstSpells.Add(objSpell);
                                    else
                                        await _lstSpells.AddAsync(objSpell, token).ConfigureAwait(false);
                                }
                                //Timekeeper.Finish("load_char_spells");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_Adept", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("Tab_Adept", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_powers", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_powers", loadActivity, token).ConfigureAwait(false))
                            {
                                // Powers.
                                objXmlNodeList = objXmlCharacter.SelectNodes("powers/power");
                                if (objXmlNodeList.Count > 0)
                                {
                                    using (new FetchSafelyFromPool<List<ListItem>>(
                                               Utils.ListItemListPool, out List<ListItem> lstPowerOrder))
                                    {
                                        bool blnDoEnhancedAccuracyRefresh =
                                            LastSavedVersion <= new Version(5, 198, 26);
                                        // Sort the Powers in alphabetical order.
                                        foreach (XmlNode xmlPower in objXmlNodeList)
                                        {
                                            string strGuid = xmlPower["guid"]?.InnerText;
                                            string strPowerName = xmlPower["name"]?.InnerText ?? string.Empty;
                                            if (blnDoEnhancedAccuracyRefresh
                                                && strPowerName == "Enhanced Accuracy (skill)")
                                            {
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    _lstInternalIdsNeedingReapplyImprovements.Add(strGuid);
                                                else
                                                    await _lstInternalIdsNeedingReapplyImprovements.AddAsync(strGuid, token).ConfigureAwait(false);
                                            }

                                            if (!string.IsNullOrEmpty(strGuid))
                                                lstPowerOrder.Add(new ListItem(strGuid,
                                                                               strPowerName
                                                                               + (xmlPower["extra"]?.InnerText
                                                                                   ?? string.Empty)));
                                            else
                                            {
                                                Power objPower = new Power(this);
                                                objPower.Load(xmlPower);
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    _lstPowers.Add(objPower);
                                                else
                                                    await _lstPowers.AddAsync(objPower, token).ConfigureAwait(false);
                                            }
                                        }

                                        lstPowerOrder.Sort(CompareListItems.CompareNames);

                                        foreach (ListItem objItem in lstPowerOrder)
                                        {
                                            XmlNode objNode =
                                                objXmlCharacter.SelectSingleNode(
                                                    "powers/power[guid = " + objItem.Value.ToString().CleanXPath()
                                                                           + ']');
                                            if (objNode != null)
                                            {
                                                Power objPower = new Power(this);
                                                objPower.Load(objNode);
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    _lstPowers.Add(objPower);
                                                else
                                                    await _lstPowers.AddAsync(objPower, token).ConfigureAwait(false);
                                            }
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_powers");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Label_Spirits", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("Label_Spirits", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_spirits", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_spirits", loadActivity, token).ConfigureAwait(false))
                            {
                                // Spirits/Sprites.
                                foreach (XPathNavigator xmlSpirit in (blnSync
                                             // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                             ? xmlCharacterNavigator.SelectAndCacheExpression("spirits/spirit")
                                             : await xmlCharacterNavigator.SelectAndCacheExpressionAsync(
                                                 "spirits/spirit", token: token).ConfigureAwait(false)))
                                {
                                    Spirit objSpirit = new Spirit(this);
                                    objSpirit.Load(xmlSpirit);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstSpirits.Add(objSpirit);
                                    else
                                        await _lstSpirits.AddAsync(objSpirit, token).ConfigureAwait(false);
                                }

                                if (!_lstSpirits.Any(s => s.Fettered) && Improvements.Any(imp =>
                                        imp.ImproveSource == Improvement.ImprovementSource.SpiritFettering))
                                {
                                    // If we don't have any Fettered spirits, make sure that we
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        ImprovementManager.RemoveImprovements(
                                            this, Improvement.ImprovementSource.SpiritFettering);
                                    else
                                        await ImprovementManager.RemoveImprovementsAsync(this,
                                            Improvement.ImprovementSource.SpiritFettering, token: token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_spirits");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Label_ComplexForms", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("Label_ComplexForms", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_complex", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_complex", loadActivity, token).ConfigureAwait(false))
                            {
                                // Complex Forms/Technomancer Programs.
                                objXmlNodeList = objXmlCharacter.SelectNodes("complexforms/complexform");
                                foreach (XmlNode objXmlComplexForm in objXmlNodeList)
                                {
                                    ComplexForm objComplexForm = new ComplexForm(this);
                                    objComplexForm.Load(objXmlComplexForm);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstComplexForms.Add(objComplexForm);
                                    else
                                        await _lstComplexForms.AddAsync(objComplexForm, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_complex");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_AdvancedPrograms", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("Tab_AdvancedPrograms", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_aiprogram", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_aiprogram", loadActivity, token).ConfigureAwait(false))
                            {
                                // Compex Forms/Technomancer Programs.
                                objXmlNodeList = objXmlCharacter.SelectNodes("aiprograms/aiprogram");
                                foreach (XmlNode objXmlProgram in objXmlNodeList)
                                {
                                    AIProgram objProgram = new AIProgram(this);
                                    objProgram.Load(objXmlProgram);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstAIPrograms.Add(objProgram);
                                    else
                                        await _lstAIPrograms.AddAsync(objProgram, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_aiprogram");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_MartialArts", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("Tab_MartialArts", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_martialarts", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_martialarts", loadActivity, token).ConfigureAwait(false))
                            {
                                // Martial Arts.
                                objXmlNodeList = objXmlCharacter.SelectNodes("martialarts/martialart");
                                foreach (XmlNode objXmlArt in objXmlNodeList)
                                {
                                    MartialArt objMartialArt = new MartialArt(this);
                                    objMartialArt.Load(objXmlArt);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstMartialArts.Add(objMartialArt);
                                    else
                                        await _lstMartialArts.AddAsync(objMartialArt, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_marts");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_Limits", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("Tab_Limits", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_mod", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_mod", loadActivity, token).ConfigureAwait(false))
                            {
                                // Limit Modifiers.
                                objXmlNodeList = objXmlCharacter.SelectNodes("limitmodifiers/limitmodifier");
                                foreach (XmlNode objXmlLimit in objXmlNodeList)
                                {
                                    LimitModifier obLimitModifier = new LimitModifier(this);
                                    obLimitModifier.Load(objXmlLimit);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstLimitModifiers.Add(obLimitModifier);
                                    else
                                        await _lstLimitModifiers.AddAsync(obLimitModifier, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_mod");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("String_SelectPACKSKit_Lifestyles", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("String_SelectPACKSKit_Lifestyles", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_lifestyle", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_lifestyle", loadActivity, token).ConfigureAwait(false))
                            {
                                // Lifestyles.
                                objXmlNodeList = objXmlCharacter.SelectNodes("lifestyles/lifestyle");
                                foreach (XmlNode objXmlLifestyle in objXmlNodeList)
                                {
                                    Lifestyle objLifestyle = new Lifestyle(this);
                                    objLifestyle.Load(objXmlLifestyle);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstLifestyles.Add(objLifestyle);
                                    else
                                        await _lstLifestyles.AddAsync(objLifestyle, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_lifestyle");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_Gear", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("Tab_Gear", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_gear", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_gear", loadActivity, token).ConfigureAwait(false))
                            {
                                // <gears>
                                objXmlNodeList = objXmlCharacter.SelectNodes("gears/gear");
                                foreach (XmlNode objXmlGear in objXmlNodeList)
                                {
                                    Gear objGear = new Gear(this);
                                    objGear.Load(objXmlGear);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstGear.Add(objGear);
                                    else
                                        await _lstGear.AddAsync(objGear, token).ConfigureAwait(false);
                                }

                                // If the character has a technomancer quality but no Living Persona commlink, its improvements get re-applied immediately
                                if (objLivingPersonaQuality != null && LastSavedVersion <= new Version(5, 195, 1))
                                {
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        ImprovementManager.RemoveImprovements(this,
                                                                              Improvement.ImprovementSource.Quality,
                                                                              objLivingPersonaQuality.InternalId);
                                    else
                                        await ImprovementManager.RemoveImprovementsAsync(this,
                                            Improvement.ImprovementSource.Quality,
                                            objLivingPersonaQuality.InternalId, token: token).ConfigureAwait(false);

                                    XmlNode objNode = blnSync
                                        // ReSharper disable once MethodHasAsyncOverload
                                        ? objLivingPersonaQuality.GetNode(token: token)
                                        : await objLivingPersonaQuality.GetNodeAsync(token: token).ConfigureAwait(false);
                                    if (objNode != null)
                                    {
                                        objLivingPersonaQuality.Bonus = objNode["bonus"];
                                        if (objLivingPersonaQuality.Bonus != null)
                                        {
                                            ImprovementManager.ForcedValue = objLivingPersonaQuality.Extra;
                                            if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                ImprovementManager.CreateImprovements(this,
                                                    Improvement.ImprovementSource.Quality,
                                                    objLivingPersonaQuality.InternalId,
                                                    objLivingPersonaQuality
                                                        .Bonus, 1,
                                                    objLivingPersonaQuality.CurrentDisplayNameShort);
                                            else
                                                await ImprovementManager.CreateImprovementsAsync(this,
                                                    Improvement.ImprovementSource.Quality,
                                                    objLivingPersonaQuality.InternalId,
                                                    objLivingPersonaQuality
                                                        .Bonus, 1,
                                                    await objLivingPersonaQuality.GetCurrentDisplayNameShortAsync(token), token: token).ConfigureAwait(false);
                                            if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                            {
                                                objLivingPersonaQuality.Extra = ImprovementManager.SelectedValue;
                                            }
                                        }

                                        objLivingPersonaQuality.FirstLevelBonus = objNode["firstlevelbonus"];
                                        if (objLivingPersonaQuality.FirstLevelBonus?.HasChildNodes == true)
                                        {
                                            bool blnDoFirstLevel = true;
                                            foreach (Quality objCheckQuality in Qualities)
                                            {
                                                if (objCheckQuality != objLivingPersonaQuality &&
                                                    objCheckQuality.SourceIDString ==
                                                    objLivingPersonaQuality.SourceIDString &&
                                                    objCheckQuality.Extra == objLivingPersonaQuality.Extra &&
                                                    objCheckQuality.SourceName ==
                                                    objLivingPersonaQuality.SourceName)
                                                {
                                                    blnDoFirstLevel = false;
                                                    break;
                                                }
                                            }

                                            if (blnDoFirstLevel)
                                            {
                                                ImprovementManager.ForcedValue = objLivingPersonaQuality.Extra;
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    ImprovementManager.CreateImprovements(this,
                                                        Improvement.ImprovementSource.Quality,
                                                        objLivingPersonaQuality.InternalId,
                                                        objLivingPersonaQuality
                                                            .FirstLevelBonus, 1,
                                                        objLivingPersonaQuality.CurrentDisplayNameShort);
                                                else
                                                    await ImprovementManager.CreateImprovementsAsync(this,
                                                        Improvement.ImprovementSource.Quality,
                                                        objLivingPersonaQuality.InternalId,
                                                        objLivingPersonaQuality
                                                            .FirstLevelBonus, 1,
                                                        await objLivingPersonaQuality.GetCurrentDisplayNameShortAsync(token), token: token).ConfigureAwait(false);
                                                if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                                {
                                                    objLivingPersonaQuality.Extra =
                                                        ImprovementManager.SelectedValue;
                                                }
                                            }
                                        }
                                    }
                                    else
                                    {
                                        // Failed to re-apply the improvements immediately, so let's just add it for processing when the character is opened
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstInternalIdsNeedingReapplyImprovements.Add(objLivingPersonaQuality.InternalId);
                                        else
                                            await _lstInternalIdsNeedingReapplyImprovements.AddAsync(objLivingPersonaQuality.InternalId, token).ConfigureAwait(false);
                                    }

                                    objLivingPersonaQuality.NaturalWeaponsNode = objNode["naturalweapons"];
                                    if (objLivingPersonaQuality.NaturalWeaponsNode != null)
                                    {
                                        ImprovementManager.ForcedValue = objLivingPersonaQuality.Extra;
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            ImprovementManager.CreateImprovements(this,
                                                Improvement.ImprovementSource.Quality,
                                                objLivingPersonaQuality.InternalId,
                                                objLivingPersonaQuality
                                                    .NaturalWeaponsNode, 1,
                                                objLivingPersonaQuality.CurrentDisplayNameShort);
                                        else
                                            await ImprovementManager.CreateImprovementsAsync(this,
                                                Improvement.ImprovementSource.Quality,
                                                objLivingPersonaQuality.InternalId,
                                                objLivingPersonaQuality
                                                    .NaturalWeaponsNode, 1,
                                                await objLivingPersonaQuality.GetCurrentDisplayNameShortAsync(token), token: token).ConfigureAwait(false);
                                        if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                        {
                                            objLivingPersonaQuality.Extra = ImprovementManager.SelectedValue;
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_gear");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Label_Vehicles", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("Label_Vehicles", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_car", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_car", loadActivity, token).ConfigureAwait(false))
                            {
                                // Vehicles.
                                objXmlNodeList = objXmlCharacter.SelectNodes("vehicles/vehicle");
                                foreach (XmlNode objXmlVehicle in objXmlNodeList)
                                {
                                    Vehicle objVehicle = new Vehicle(this);
                                    objVehicle.Load(objXmlVehicle);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstVehicles.Add(objVehicle);
                                    else
                                        await _lstVehicles.AddAsync(objVehicle, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_car");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_Weapons", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("Tab_Weapons", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_weapons", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_weapons", loadActivity, token).ConfigureAwait(false))
                            {
                                // Weapons.
                                objXmlNodeList = objXmlCharacter.SelectNodes("weapons/weapon");
                                foreach (XmlNode objXmlWeapon in objXmlNodeList)
                                {
                                    Weapon objWeapon = new Weapon(this);
                                    objWeapon.Load(objXmlWeapon);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstWeapons.Add(objWeapon);
                                    else
                                        await _lstWeapons.AddAsync(objWeapon, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_weapons");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("String_Metamagics", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("String_Metamagics", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_metamagics", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_metamagics", loadActivity, token).ConfigureAwait(false))
                            {
                                // Metamagics/Echoes.
                                objXmlNodeList = objXmlCharacter.SelectNodes("metamagics/metamagic");
                                foreach (XmlNode objXmlMetamagic in objXmlNodeList)
                                {
                                    Metamagic objMetamagic = new Metamagic(this);
                                    objMetamagic.Load(objXmlMetamagic);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstMetamagics.Add(objMetamagic);
                                    else
                                        await _lstMetamagics.AddAsync(objMetamagic, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_mmagic");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("String_Arts", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("String_Arts", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_arts", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_arts", loadActivity, token).ConfigureAwait(false))
                            {
                                // Arts
                                objXmlNodeList = objXmlCharacter.SelectNodes("arts/art");
                                foreach (XmlNode objXmlArt in objXmlNodeList)
                                {
                                    Art objArt = new Art(this);
                                    objArt.Load(objXmlArt);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstArts.Add(objArt);
                                    else
                                        await _lstArts.AddAsync(objArt, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_arts");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("String_Enhancements", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("String_Enhancements", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_enhancements", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_enhancements", loadActivity, token).ConfigureAwait(false))
                            {
                                // Enhancements
                                objXmlNodeList = objXmlCharacter.SelectNodes("enhancements/enhancement");
                                foreach (XmlNode objXmlEnhancement in objXmlNodeList)
                                {
                                    Enhancement objEnhancement = new Enhancement(this);
                                    objEnhancement.Load(objXmlEnhancement);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstEnhancements.Add(objEnhancement);
                                    else
                                        await _lstEnhancements.AddAsync(objEnhancement, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_ench");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_Critter", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("Tab_Critter", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_critterpowers", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_critterpowers", loadActivity, token).ConfigureAwait(false))
                            {
                                // Critter Powers.
                                objXmlNodeList = objXmlCharacter.SelectNodes("critterpowers/critterpower");
                                foreach (XmlNode objXmlPower in objXmlNodeList)
                                {
                                    CritterPower objPower = new CritterPower(this);
                                    objPower.Load(objXmlPower);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstCritterPowers.Add(objPower);
                                    else
                                        await _lstCritterPowers.AddAsync(objPower, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_cpow");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Label_SummaryFoci", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("Label_SummaryFoci", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_foci", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_foci", loadActivity, token).ConfigureAwait(false))
                            {
                                // Foci.
                                objXmlNodeList = objXmlCharacter.SelectNodes("foci/focus");
                                foreach (XmlNode objXmlFocus in objXmlNodeList)
                                {
                                    Focus objFocus = new Focus(this);
                                    objFocus.Load(objXmlFocus);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstFoci.Add(objFocus);
                                    else
                                        await _lstFoci.AddAsync(objFocus, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_foci");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Label_SummaryInitiation", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("Label_SummaryInitiation", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_init", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_init", loadActivity, token).ConfigureAwait(false))
                            {
                                // Initiation Grades.
                                objXmlNodeList = objXmlCharacter.SelectNodes("initiationgrades/initiationgrade");
                                foreach (XmlNode objXmlGrade in objXmlNodeList)
                                {
                                    InitiationGrade objGrade = new InitiationGrade(this);
                                    objGrade.Load(objXmlGrade);
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstInitiationGrades.Add(objGrade);
                                    else
                                        await _lstInitiationGrades.AddAsync(objGrade, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_init");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("String_Expenses", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("String_Expenses", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            // While expenses are to be saved in create mode due to starting nuyen and starting karma being logged as expense log entries,
                            // they shouldn't get loaded in create mode because they shouldn't be there.
                            if (Created)
                            {
                                using (_ = blnSync
                                           // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                           ? Timekeeper.StartSyncron("load_char_elog", loadActivity)
                                           : await Timekeeper.StartSyncronAsync("load_char_elog", loadActivity, token).ConfigureAwait(false))
                                {
                                    // Expense Log Entries.
                                    XmlNodeList objXmlExpenseList = objXmlCharacter.SelectNodes("expenses/expense");
                                    foreach (XmlNode objXmlExpense in objXmlExpenseList)
                                    {
                                        ExpenseLogEntry objExpenseLogEntry = new ExpenseLogEntry(this);
                                        objExpenseLogEntry.Load(objXmlExpense);
                                        await _lstExpenseLog.AddWithSortAsync(objExpenseLogEntry, token: token).ConfigureAwait(false);
                                    }

                                    //Timekeeper.Finish("load_char_elog");
                                }
                            }
#if DEBUG
                            else
                            {
                                // There shouldn't be any expenses for a character loaded in create mode. This code is to help narrow down issues should expenses somehow be created.
                                XmlNodeList objXmlExpenseList = objXmlCharacter.SelectNodes("expenses/expense");
                                if (objXmlExpenseList?.Count > 0)
                                {
                                    Utils.BreakIfDebug();
                                }
                            }
#endif
                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tip_Skill_Sustain", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("Tip_Skill_Sustain", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            // Need to load these after everything else so that we can properly link them up during loading
                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_sustainedobjects", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_sustainedobjects", loadActivity, token).ConfigureAwait(false))
                            {
                                objXmlNodeList = objXmlCharacter.SelectNodes("sustainedobjects");
                                foreach (XmlNode objXmlSustained in objXmlNodeList)
                                {
                                    SustainedObject objSustained = new SustainedObject(this);
                                    objSustained.Load(objXmlSustained);
                                    if (objSustained.InternalId !=
                                        Guid.Empty.ToString("D", GlobalSettings.InvariantCultureInfo))
                                    {
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstSustainedObjects.Add(objSustained);
                                        else
                                            await _lstSustainedObjects.AddAsync(objSustained, token).ConfigureAwait(false);
                                    }
                                }
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_Improvements", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("Tab_Improvements", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_igroup", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_igroup", loadActivity, token).ConfigureAwait(false))
                            {
                                // Improvement Groups.
                                XmlNodeList objXmlGroupList =
                                    objXmlCharacter.SelectNodes("improvementgroups/improvementgroup");
                                if (blnSync)
                                {
                                    foreach (XmlNode objXmlGroup in objXmlGroupList)
                                    {
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstImprovementGroups.Add(objXmlGroup.InnerText);
                                    }
                                }
                                else
                                {
                                    foreach (XmlNode objXmlGroup in objXmlGroupList)
                                    {
                                        await _lstImprovementGroups.AddAsync(objXmlGroup.InnerText, token).ConfigureAwait(false);
                                    }
                                }

                                //Timekeeper.Finish("load_char_igroup");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_Calendar", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("Tab_Calendar", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_calendar", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_calendar", loadActivity, token).ConfigureAwait(false))
                            {
                                // Calendar.
                                XmlNodeList objXmlWeekList = objXmlCharacter.SelectNodes("calendar/week");
                                foreach (XmlNode objXmlWeek in objXmlWeekList)
                                {
                                    CalendarWeek objWeek = new CalendarWeek();
                                    objWeek.Load(objXmlWeek);
                                    await _lstCalendar.AddWithSortAsync(objWeek, (x, y) => y.CompareTo(x), token: token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_calendar");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("String_LegacyFixes", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("String_LegacyFixes", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_unarmed", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_unarmed", loadActivity, token).ConfigureAwait(false))
                            {
                                // Look for the unarmed attack
                                bool blnFoundUnarmed = false;
                                foreach (Weapon objWeapon in _lstWeapons)
                                {
                                    if (objWeapon.Name == "Unarmed Attack")
                                    {
                                        blnFoundUnarmed = true;
                                        break;
                                    }
                                }

                                if (!blnFoundUnarmed)
                                {
                                    // Add the Unarmed Attack Weapon to the character.
                                    XmlDocument objXmlWeaponDoc = blnSync
                                        // ReSharper disable once MethodHasAsyncOverload
                                        ? LoadData("weapons.xml", token: token)
                                        : await LoadDataAsync("weapons.xml", token: token).ConfigureAwait(false);
                                    XmlNode objXmlWeapon =
                                        objXmlWeaponDoc.SelectSingleNode(
                                            "/chummer/weapons/weapon[name = \"Unarmed Attack\"]");
                                    if (objXmlWeapon != null)
                                    {
                                        Weapon objWeapon = new Weapon(this);
                                        objWeapon.Create(objXmlWeapon, _lstWeapons);
                                        objWeapon.IncludedInWeapon = true; // Unarmed attack can never be removed
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstWeapons.Add(objWeapon);
                                        else
                                            await _lstWeapons.AddAsync(objWeapon, token).ConfigureAwait(false);
                                    }
                                }

                                //Timekeeper.Finish("load_char_unarmed");
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_dwarffix", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_dwarffix", loadActivity, token).ConfigureAwait(false))
                            {
                                // converting from old dwarven resistance to new dwarven resistance
                                if (Metatype.Equals("dwarf", StringComparison.OrdinalIgnoreCase))
                                {
                                    Quality objOldQuality =
                                        Qualities.FirstOrDefault(x =>
                                                                     x.Name.Equals("Resistance to Pathogens and Toxins",
                                                                         StringComparison.Ordinal));
                                    if (objOldQuality != null)
                                    {
                                        objOldQuality.DeleteQuality();
                                        if (Qualities.All(x =>
                                                              !x.Name.Equals("Resistance to Pathogens/Toxins",
                                                                             StringComparison.Ordinal))
                                            && Qualities.All(x =>
                                                                 !x.Name.Equals(
                                                                     "Dwarf Resistance", StringComparison.Ordinal)))
                                        {
                                            XmlNode objXmlDwarfQuality =
                                                xmlRootQualitiesNode.SelectSingleNode(
                                                    "quality[name = \"Resistance to Pathogens/Toxins\"]") ??
                                                xmlRootQualitiesNode.SelectSingleNode(
                                                    "quality[name = \"Dwarf Resistance\"]");

                                            List<Weapon> lstWeapons = new List<Weapon>(1);
                                            Quality objQuality = new Quality(this);

                                            objQuality.Create(objXmlDwarfQuality, QualitySource.Metatype,
                                                              lstWeapons);

                                            if (blnSync)
                                            {
                                                foreach (Weapon objWeapon in lstWeapons)
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    Weapons.Add(objWeapon);
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                Qualities.Add(objQuality);
                                            }
                                            else
                                            {
                                                foreach (Weapon objWeapon in lstWeapons)
                                                    await Weapons.AddAsync(objWeapon, token).ConfigureAwait(false);
                                                await Qualities.AddAsync(objQuality, token).ConfigureAwait(false);
                                            }
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_dwarffix");
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_cyberadeptfix", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_cyberadeptfix", loadActivity, token).ConfigureAwait(false))
                            {
                                //Sweep through grades if we have any cyberadept improvements that need reassignment
                                if (lstCyberadeptSweepGrades.Count > 0)
                                {
                                    foreach (Improvement objCyberadeptImprovement in lstCyberadeptSweepGrades)
                                    {
                                        InitiationGrade objBestGradeMatch = null;
                                        foreach (InitiationGrade objInitiationGrade in InitiationGrades)
                                        {
                                            if (!objInitiationGrade.Technomancer
                                                || objInitiationGrade.Grade.DivAwayFromZero(2) >
                                                objCyberadeptImprovement.Value
                                                || Metamagics.Any(x => x.Grade == objInitiationGrade.Grade)
                                                || lstCyberadeptSweepGrades.All(x =>
                                                    x.ImproveSource != Improvement.ImprovementSource
                                                        .CyberadeptDaemon
                                                    || x.SourceName != objInitiationGrade.InternalId))
                                                continue;
                                            if (objBestGradeMatch == null ||
                                                objBestGradeMatch.Grade > objInitiationGrade.Grade)
                                                objBestGradeMatch = objInitiationGrade;
                                        }

                                        if (objBestGradeMatch != null)
                                        {
                                            objCyberadeptImprovement.ImproveSource =
                                                Improvement.ImprovementSource.CyberadeptDaemon;
                                            objCyberadeptImprovement.SourceName = objBestGradeMatch.InternalId;
                                        }
                                        else if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstImprovements.Remove(objCyberadeptImprovement);
                                        else
                                            await _lstImprovements.RemoveAsync(objCyberadeptImprovement, token).ConfigureAwait(false);
                                    }
                                }

                                //Timekeeper.Finish("load_char_cyberadeptfix");
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_mentorspiritfix", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_mentorspiritfix", loadActivity, token).ConfigureAwait(false))
                            {
                                Quality objMentorQuality = Qualities.FirstOrDefault(q => q.Name == "Mentor Spirit");
                                // This character doesn't have any improvements tied to a cached Mentor Spirit value, so re-apply the improvement that adds the Mentor spirit
                                if (objMentorQuality != null && !Improvements.Any(imp =>
                                        imp.ImproveType == Improvement.ImprovementType.MentorSpirit &&
                                        !string.IsNullOrEmpty(imp.ImprovedName)))
                                {
                                    // Selecting bonuses for a mentor spirit mid-load is confusing, so just show the error and let the player manually re-apply
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstInternalIdsNeedingReapplyImprovements.Add(objMentorQuality.InternalId);
                                    else
                                        await _lstInternalIdsNeedingReapplyImprovements.AddAsync(objMentorQuality.InternalId, token).ConfigureAwait(false);
                                }

                                //Timekeeper.Finish("load_char_mentorspiritfix");
                            }

                            if (frmLoadingForm != null)
                            {
                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    frmLoadingForm.PerformStep(LanguageManager.GetString("Tab_Options_Plugins", token: token));
                                else
                                    await frmLoadingForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("Tab_Options_Plugins", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                            }

                            //Plugins
                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_plugins", loadActivity)
                                       : await Timekeeper.StartSyncronAsync("load_char_plugins", loadActivity, token).ConfigureAwait(false))
                            {
                                foreach (IPlugin plugin in Program.PluginLoader.MyActivePlugins)
                                {
                                    foreach (XmlNode objXmlPlugin in objXmlCharacter.SelectNodes("plugins/" +
                                                 plugin.GetPluginAssembly().GetName().Name))
                                    {
                                        plugin.LoadFileElement(this, objXmlPlugin.InnerText);
                                    }
                                }

                                //Timekeeper.Finish("load_plugins");
                            }
                        }
                        finally
                        {
                            IsLoading = false;
                        }

                        if (frmLoadingForm != null)
                        {
                            if (blnSync)
                                // ReSharper disable once MethodHasAsyncOverload
                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                frmLoadingForm.PerformStep(LanguageManager.GetString("String_GeneratedImprovements", token: token));
                            else
                                await frmLoadingForm.PerformStepAsync(
                                    await LanguageManager.GetStringAsync("String_GeneratedImprovements", token: token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                        }

                        // Refresh certain improvements
                        using (_ = blnSync
                                   // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                   ? Timekeeper.StartSyncron("load_char_improvementrefreshers1", loadActivity)
                                   : await Timekeeper.StartSyncronAsync("load_char_improvementrefreshers1", loadActivity, token).ConfigureAwait(false))
                        {
                            // Process all events related to improvements
                            using (new FetchSafelyFromPool<
                                       Dictionary<INotifyMultiplePropertyChanged, HashSet<string>>>(
                                       Utils.DictionaryForMultiplePropertyChangedPool,
                                       out Dictionary<INotifyMultiplePropertyChanged, HashSet<string>>
                                           dicChangedProperties))
                            {
                                try
                                {
                                    foreach (Improvement objImprovement in Improvements)
                                    {
                                        if (!objImprovement.Enabled)
                                            continue;
                                        foreach ((INotifyMultiplePropertyChanged objItemToUpdate,
                                                  string strPropertyToUpdate) in objImprovement
                                                     .GetRelevantPropertyChangers())
                                        {
                                            if (!dicChangedProperties.TryGetValue(
                                                    objItemToUpdate, out HashSet<string> setChangedProperties))
                                            {
                                                setChangedProperties = Utils.StringHashSetPool.Get();
                                                dicChangedProperties.Add(objItemToUpdate, setChangedProperties);
                                            }

                                            setChangedProperties.Add(strPropertyToUpdate);
                                        }
                                    }

                                    foreach (KeyValuePair<INotifyMultiplePropertyChanged, HashSet<string>>
                                                 kvpToProcess in
                                             dicChangedProperties)
                                    {
                                        kvpToProcess.Key.OnMultiplePropertyChanged(kvpToProcess.Value.ToList());
                                    }
                                }
                                finally
                                {
                                    foreach (HashSet<string> setToReturn in dicChangedProperties.Values)
                                        Utils.StringHashSetPool.Return(setToReturn);
                                }
                            }

                            // Refresh Black Market Discounts
                            RefreshBlackMarketDiscounts();
                            // Refresh Dealer Connection discounts
                            RefreshDealerConnectionDiscounts();
                            // Refresh permanent attribute changes due to essence loss
                            if (blnSync)
                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                RefreshEssenceLossImprovements();
                            else
                                await RefreshEssenceLossImprovementsAsync(token).ConfigureAwait(false);
                            // Refresh dicepool modifiers due to filled condition monitor boxes
                            RefreshWoundPenalties();
                            // Refresh dicepool modifiers due to sustained spells
                            RefreshSustainingPenalties();
                            // Refresh encumbrance penalties
                            RefreshEncumbrance();
                            RefreshArmorEncumbrance();
                            // Curb Mystic Adept power points if the values that were loaded in would be illegal
                            if (MysticAdeptPowerPoints > 0)
                            {
                                int intMAGTotalValue = blnSync
                                    ? MAG.TotalValue
                                    : await (await GetAttributeAsync("MAG", token: token)).GetTotalValueAsync(token);
                                if (MysticAdeptPowerPoints > intMAGTotalValue)
                                    MysticAdeptPowerPoints = intMAGTotalValue;
                            }

                            if (!InitiationEnabled || !AddInitiationsAllowed)
                                ClearInitiations(token);
                            foreach (Func<bool> funcToCall in PostLoadMethods)
                                if (!funcToCall.Invoke())
                                    return false;
                            if (blnSync)
                            {
                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                PostLoadMethods.Clear();

                                foreach (Func<Task<bool>> funcToCall in PostLoadMethodsAsync)
                                {
                                    Task<bool> tskToCall = funcToCall.Invoke();
                                    if (tskToCall.Status == TaskStatus.Created)
                                        tskToCall.RunSynchronously();
                                    if (!tskToCall.GetAwaiter().GetResult())
                                        return false;
                                }

                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                PostLoadMethodsAsync.Clear();
                            }
                            else
                            {
                                await PostLoadMethods.ClearAsync(token).ConfigureAwait(false);

                                foreach (Func<Task<bool>> funcToCall in PostLoadMethodsAsync)
                                {
                                    if (!await funcToCall.Invoke().ConfigureAwait(false))
                                        return false;
                                }

                                await PostLoadMethodsAsync.ClearAsync(token).ConfigureAwait(false);
                            }
                            //Timekeeper.Finish("load_char_improvementrefreshers");
                        }

                        //// If the character had old Qualities that were converted, immediately save the file so they are in the new format.
                        //if (blnHasOldQualities)
                        //{
                        //    Timekeeper.Start("load_char_resav");  //Lets not silently save file on load?
                        //    Save();
                        //    Timekeeper.Finish("load_char_resav");
                        //}
                        loadActivity.SetSuccess(true);
                    }
                    catch (Exception e)
                    {
                        loadActivity.SetSuccess(false);
                        Log.Error(e);
                        throw;
                    }
                }

                return true;
            }
            finally
            {
                if (blnSync)
                    // ReSharper disable once MethodHasAsyncOverload
                    objLocker.Dispose();
                else
                    await objLockerAsync.DisposeAsync().ConfigureAwait(false);
            }
        }

        public Task<XmlDocument> GenerateExportXml(CultureInfo objCultureInfo, string strLanguage)
        {
            return CommonFunctions.GenerateCharactersExportXml(objCultureInfo, strLanguage, this);
        }

        public Task<XmlDocument> GenerateExportXml(CultureInfo objCultureInfo, string strLanguage, CancellationToken objToken)
        {
            return CommonFunctions.GenerateCharactersExportXml(objCultureInfo, strLanguage, objToken, this);
        }

        /// <summary>
        /// Print this character information to a XmlTextWriter. This creates only the character object itself, not any of the opening or closing XmlDocument items.
        /// This can be used to write multiple characters to a single XmlDocument.
        /// </summary>
        /// <param name="objWriter">XmlTextWriter to write to.</param>
        /// <param name="objCulture">Culture in which to print.</param>
        /// <param name="strLanguageToPrint">Language in which to print.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public Task PrintToXmlTextWriter(XmlWriter objWriter, CultureInfo objCulture = null,
                                         string strLanguageToPrint = "", CancellationToken token = default)
        {
            return objWriter != null
                ? PrintToXmlTextWriterCore(objWriter, objCulture, strLanguageToPrint, token)
                : Task.FromException(new ArgumentNullException(nameof(objWriter)));
        }

        /// <summary>
        /// Print this character information to a XmlTextWriter. This creates only the character object itself, not any of the opening or closing XmlDocument items.
        /// This can be used to write multiple characters to a single XmlDocument.
        /// </summary>
        /// <param name="objWriter">XmlTextWriter to write to.</param>
        /// <param name="objCulture">Culture in which to print.</param>
        /// <param name="strLanguageToPrint">Language in which to print.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        private async Task PrintToXmlTextWriterCore(XmlWriter objWriter, CultureInfo objCulture = null, string strLanguageToPrint = "", CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (objCulture == null)
                objCulture = GlobalSettings.CultureInfo;
            if (string.IsNullOrEmpty(strLanguageToPrint))
                strLanguageToPrint = GlobalSettings.Language;
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                // <character>
                XmlElementWriteHelper objCharacterElement = await objWriter.StartElementAsync("character", token: token);
                try
                {
                    // <settings />
                    await objWriter.WriteElementStringAsync("settings", await GetSettingsKeyAsync(token), token: token);
                    // <buildmethod />
                    await objWriter.WriteElementStringAsync("buildmethod", Settings.BuildMethod.ToString(), token: token);
                    // <imageformat />
                    await objWriter.WriteElementStringAsync("imageformat",
                                                            "jpeg", token: token); // Here for legacy/compatibility purposes, we always export as JPEG now
                    // <metatype />
                    await objWriter.WriteElementStringAsync("metatype", await DisplayMetatypeAsync(strLanguageToPrint, token), token: token);
                    // <metatype_english />
                    await objWriter.WriteElementStringAsync("metatype_english", Metatype, token: token);
                    // <metatype_guid />
                    await objWriter.WriteElementStringAsync("metatype_guid",
                                                            MetatypeGuid.ToString(
                                                                "D", GlobalSettings.InvariantCultureInfo), token: token);
                    // <metavariant />
                    await objWriter.WriteElementStringAsync("metavariant",
                                                            await DisplayMetavariantAsync(strLanguageToPrint, token), token: token);
                    // <metavariant_english />
                    await objWriter.WriteElementStringAsync("metavariant_english", Metavariant, token: token);
                    // <metavariant_guid />
                    await objWriter.WriteElementStringAsync("metavariant_guid",
                                                            MetavariantGuid.ToString(
                                                                "D", GlobalSettings.InvariantCultureInfo), token: token);
                    // <movement />
                    await objWriter.WriteElementStringAsync("movement", await FullMovementAsync(objCulture, strLanguageToPrint, token), token: token);
                    // <walk />
                    await objWriter.WriteElementStringAsync("walk", await FullMovementAsync(objCulture, strLanguageToPrint, token), token: token);
                    // <run />
                    await objWriter.WriteElementStringAsync("run", await FullMovementAsync(objCulture, strLanguageToPrint, token), token: token);
                    // <sprint />
                    await objWriter.WriteElementStringAsync("sprint", await FullMovementAsync(objCulture, strLanguageToPrint, token), token: token);
                    // <movementwalk />
                    await objWriter.WriteElementStringAsync("movementwalk",
                                                            await GetMovementAsync(objCulture, strLanguageToPrint, token), token: token);
                    // <movementswim />
                    await objWriter.WriteElementStringAsync("movementswim", await GetSwimAsync(objCulture, strLanguageToPrint, token), token: token);
                    // <movementfly />
                    await objWriter.WriteElementStringAsync("movementfly", await GetFlyAsync(objCulture, strLanguageToPrint, token), token: token);

                    // <prioritymetatype />
                    await objWriter.WriteElementStringAsync("prioritymetatype", MetatypePriority, token: token);
                    // <priorityattributes />
                    await objWriter.WriteElementStringAsync("priorityattributes", AttributesPriority, token: token);
                    // <priorityspecial />
                    await objWriter.WriteElementStringAsync("priorityspecial", SpecialPriority, token: token);
                    // <priorityskills />
                    await objWriter.WriteElementStringAsync("priorityskills", SkillsPriority, token: token);
                    // <priorityresources />
                    await objWriter.WriteElementStringAsync("priorityresources", ResourcesPriority, token: token);

                    // <priorityskills>
                    XmlElementWriteHelper objPrioritySkillsElement = await objWriter.StartElementAsync("priorityskills", token: token);
                    try
                    {
                        foreach (string strSkill in PriorityBonusSkillList)
                        {
                            await objWriter.WriteElementStringAsync("priorityskill", strSkill, token: token);
                        }
                    }
                    finally
                    {
                        // </priorityskills>
                        await objPrioritySkillsElement.DisposeAsync();
                    }

                    // <handedness />
                    if (await GetAmbidextrousAsync(token))
                    {
                        await objWriter.WriteElementStringAsync("primaryarm",
                                                                await LanguageManager.GetStringAsync(
                                                                    "String_Ambidextrous", strLanguageToPrint, token: token), token: token);
                    }
                    else if (PrimaryArm == "Left")
                    {
                        await objWriter.WriteElementStringAsync("primaryarm",
                                                                await LanguageManager.GetStringAsync(
                                                                    "String_Improvement_SideLeft", strLanguageToPrint, token: token), token: token);
                    }
                    else
                    {
                        await objWriter.WriteElementStringAsync("primaryarm",
                                                                await LanguageManager.GetStringAsync(
                                                                    "String_Improvement_SideRight",
                                                                    strLanguageToPrint, token: token), token: token);
                    }

                    // If the character does not have a name, call them Unnamed Character. This prevents a transformed document from
                    // having a self-terminated title tag which causes browser to not rendering anything.
                    // <name />
                    await objWriter.WriteElementStringAsync("name",
                                                            !string.IsNullOrEmpty(Name)
                                                                ? Name
                                                                : await LanguageManager.GetStringAsync(
                                                                    "String_UnnamedCharacter", strLanguageToPrint, token: token), token: token);

                    await PrintMugshots(objWriter, token);

                    // <sex />
                    await objWriter.WriteElementStringAsync("gender",
                                                            await TranslateExtraAsync(
                                                                await ReverseTranslateExtraAsync(
                                                                    Gender, GlobalSettings.Language, "contacts.xml", token: token),
                                                                strLanguageToPrint, "contacts.xml", token: token), token: token);
                    // <age />
                    await objWriter.WriteElementStringAsync("age",
                                                            await TranslateExtraAsync(
                                                                await ReverseTranslateExtraAsync(
                                                                    Age, GlobalSettings.Language, "contacts.xml", token: token),
                                                                strLanguageToPrint,
                                                                "contacts.xml", token: token), token: token);
                    // <eyes />
                    await objWriter.WriteElementStringAsync("eyes",
                                                            await TranslateExtraAsync(
                                                                await ReverseTranslateExtraAsync(Eyes, token: token),
                                                                strLanguageToPrint, token: token), token: token);
                    // <height />
                    await objWriter.WriteElementStringAsync("height",
                                                            await TranslateExtraAsync(
                                                                await ReverseTranslateExtraAsync(Height, token: token),
                                                                strLanguageToPrint, token: token), token: token);
                    // <weight />
                    await objWriter.WriteElementStringAsync("weight",
                                                            await TranslateExtraAsync(
                                                                await ReverseTranslateExtraAsync(Weight, token: token),
                                                                strLanguageToPrint, token: token), token: token);
                    // <skin />
                    await objWriter.WriteElementStringAsync("skin",
                                                            await TranslateExtraAsync(
                                                                await ReverseTranslateExtraAsync(Skin, token: token),
                                                                strLanguageToPrint, token: token), token: token);
                    // <hair />
                    await objWriter.WriteElementStringAsync("hair",
                                                            await TranslateExtraAsync(
                                                                await ReverseTranslateExtraAsync(Hair, token: token),
                                                                strLanguageToPrint, token: token), token: token);
                    // <description />
                    await objWriter.WriteElementStringAsync("description", await Description.RtfToHtmlAsync(token), token: token);
                    // <background />
                    await objWriter.WriteElementStringAsync("background", await Background.RtfToHtmlAsync(token), token: token);
                    // <concept />
                    await objWriter.WriteElementStringAsync("concept", await Concept.RtfToHtmlAsync(token), token: token);
                    // <notes />
                    await objWriter.WriteElementStringAsync("notes", await Notes.RtfToHtmlAsync(token), token: token);
                    // <alias />
                    await objWriter.WriteElementStringAsync("alias", Alias, token: token);
                    // <playername />
                    await objWriter.WriteElementStringAsync("playername", PlayerName, token: token);
                    // <gamenotes />
                    await objWriter.WriteElementStringAsync("gamenotes", await GameNotes.RtfToHtmlAsync(token), token: token);

                    // <limitphysical />
                    await objWriter.WriteElementStringAsync("limitphysical", LimitPhysical.ToString(objCulture), token: token);
                    // <limitmental />
                    await objWriter.WriteElementStringAsync("limitmental", LimitMental.ToString(objCulture), token: token);
                    // <limitsocial />
                    await objWriter.WriteElementStringAsync("limitsocial", LimitSocial.ToString(objCulture), token: token);
                    // <limitastral />
                    await objWriter.WriteElementStringAsync("limitastral", LimitAstral.ToString(objCulture), token: token);
                    // <contactpoints />
                    await objWriter.WriteElementStringAsync("contactpoints", ContactPoints.ToString(objCulture), token: token);
                    // <contactpointsused />
                    await objWriter.WriteElementStringAsync("contactpointsused",
                                                            ContactPointsUsed.ToString(objCulture), token: token);
                    // <cfplimit />
                    await objWriter.WriteElementStringAsync("cfplimit", CFPLimit.ToString(objCulture), token: token);
                    // <totalaiprogramlimit />
                    await objWriter.WriteElementStringAsync("ainormalprogramlimit",
                                                            AINormalProgramLimit.ToString(objCulture), token: token);
                    // <aiadvancedprogramlimit />
                    await objWriter.WriteElementStringAsync("aiadvancedprogramlimit",
                                                            AIAdvancedProgramLimit.ToString(objCulture), token: token);
                    // <spelllimit />
                    await objWriter.WriteElementStringAsync("spelllimit", FreeSpells.ToString(objCulture), token: token);
                    // <karma />
                    await objWriter.WriteElementStringAsync("karma", Karma.ToString(objCulture), token: token);
                    // <totalkarma />
                    await objWriter.WriteElementStringAsync("totalkarma", CareerKarma.ToString(objCulture), token: token);
                    // <special />
                    await objWriter.WriteElementStringAsync("special", Special.ToString(objCulture), token: token);
                    // <totalspecial />
                    await objWriter.WriteElementStringAsync("totalspecial", TotalSpecial.ToString(objCulture), token: token);
                    // <attributes />
                    await objWriter.WriteElementStringAsync("attributes", Attributes.ToString(objCulture), token: token);
                    // <totalattributes />
                    await objWriter.WriteElementStringAsync("totalattributes", TotalAttributes.ToString(objCulture), token: token);
                    // <edgeused />
                    await objWriter.WriteElementStringAsync("edgeused", EdgeUsed.ToString(objCulture), token: token);
                    // <edgeremaining />
                    await objWriter.WriteElementStringAsync("edgeremaining", EdgeRemaining.ToString(objCulture), token: token);
                    // <streetcred />
                    await objWriter.WriteElementStringAsync("streetcred", StreetCred.ToString(objCulture), token: token);
                    // <calculatedstreetcred />
                    await objWriter.WriteElementStringAsync("calculatedstreetcred",
                                                            CalculatedStreetCred.ToString(objCulture), token: token);
                    // <totalstreetcred />
                    await objWriter.WriteElementStringAsync("totalstreetcred", TotalStreetCred.ToString(objCulture), token: token);
                    // <burntstreetcred />
                    await objWriter.WriteElementStringAsync("burntstreetcred", BurntStreetCred.ToString(objCulture), token: token);
                    // <notoriety />
                    await objWriter.WriteElementStringAsync("notoriety", Notoriety.ToString(objCulture), token: token);
                    // <calculatednotoriety />
                    await objWriter.WriteElementStringAsync("calculatednotoriety",
                                                            CalculatedNotoriety.ToString(objCulture), token: token);
                    // <totalnotoriety />
                    await objWriter.WriteElementStringAsync("totalnotoriety", TotalNotoriety.ToString(objCulture), token: token);
                    // <publicawareness />
                    await objWriter.WriteElementStringAsync("publicawareness", PublicAwareness.ToString(objCulture), token: token);
                    // <calculatedpublicawareness />
                    await objWriter.WriteElementStringAsync("calculatedpublicawareness",
                                                            CalculatedPublicAwareness.ToString(objCulture), token: token);
                    // <totalpublicawareness />
                    await objWriter.WriteElementStringAsync("totalpublicawareness",
                                                            TotalPublicAwareness.ToString(objCulture), token: token);
                    // <astralreputation />
                    await objWriter.WriteElementStringAsync("astralreputation", AstralReputation.ToString(objCulture), token: token);
                    // <totalastralreputation />
                    await objWriter.WriteElementStringAsync("totalastralreputation",
                                                            TotalAstralReputation.ToString(objCulture), token: token);
                    // <wildreputation />
                    await objWriter.WriteElementStringAsync("wildreputation", WildReputation.ToString(objCulture), token: token);
                    // <totalwildreputation />
                    await objWriter.WriteElementStringAsync("totalwildreputation",
                                                            TotalWildReputation.ToString(objCulture), token: token);
                    // <created />
                    await objWriter.WriteElementStringAsync(
                        "created", Created.ToString(GlobalSettings.InvariantCultureInfo), token: token);
                    // <nuyen />
                    await objWriter.WriteElementStringAsync("nuyen", Nuyen.ToString(Settings.NuyenFormat, objCulture), token: token);
                    // <adept />
                    await objWriter.WriteElementStringAsync(
                        "adept", AdeptEnabled.ToString(GlobalSettings.InvariantCultureInfo), token: token);
                    // <magician />
                    await objWriter.WriteElementStringAsync(
                        "magician", MagicianEnabled.ToString(GlobalSettings.InvariantCultureInfo), token: token);
                    // <technomancer />
                    await objWriter.WriteElementStringAsync("technomancer",
                                                            TechnomancerEnabled.ToString(
                                                                GlobalSettings.InvariantCultureInfo), token: token);
                    // <ai />
                    await objWriter.WriteElementStringAsync("ai",
                                                            AdvancedProgramsEnabled.ToString(
                                                                GlobalSettings.InvariantCultureInfo), token: token);
                    // <cyberwaredisabled />
                    await objWriter.WriteElementStringAsync("cyberwaredisabled",
                                                            CyberwareDisabled.ToString(
                                                                GlobalSettings.InvariantCultureInfo), token: token);
                    // <critter />
                    await objWriter.WriteElementStringAsync(
                        "critter", CritterEnabled.ToString(GlobalSettings.InvariantCultureInfo), token: token);

                    await objWriter.WriteElementStringAsync(
                        "totaless", (await EssenceAsync(token: token)).ToString(Settings.EssenceFormat, objCulture), token: token);

                    // <tradition />
                    if (MagicTradition.Type != TraditionType.None)
                    {
                        await MagicTradition.Print(objWriter, objCulture, strLanguageToPrint);
                    }

                    // <attributes>
                    XmlElementWriteHelper objAttributesElement = await objWriter.StartElementAsync("attributes", token: token);
                    try
                    {
                        await AttributeSection.Print(objWriter, objCulture, strLanguageToPrint, token);
                    }
                    finally
                    {
                        // </attributes>
                        await objAttributesElement.DisposeAsync();
                    }

                    int intArmor = await GetTotalArmorRatingAsync(token);
                    int intFireArmor = await GetTotalFireArmorRatingAsync(token);
                    int intColdArmor = await GetTotalColdArmorRatingAsync(token);
                    int intElectricityArmor = await GetTotalElectricityArmorRatingAsync(token);
                    int intAcidArmor = await GetTotalAcidArmorRatingAsync(token);
                    int intFallingArmor = await GetTotalFallingArmorRatingAsync(token);
                    // <dodge />
                    await objWriter.WriteElementStringAsync("dodge", Dodge.ToString(objCulture), token: token);
                    // <armor />
                    await objWriter.WriteElementStringAsync("armor", intArmor.ToString(objCulture), token: token);
                    // <firearmor />
                    await objWriter.WriteElementStringAsync("firearmor", intFireArmor.ToString(objCulture), token: token);
                    // <coldarmor />
                    await objWriter.WriteElementStringAsync("coldarmor", intColdArmor.ToString(objCulture), token: token);
                    // <electricityarmor />
                    await objWriter.WriteElementStringAsync("electricityarmor", intElectricityArmor.ToString(objCulture), token: token);
                    // <acidarmor />
                    await objWriter.WriteElementStringAsync("acidarmor", intAcidArmor.ToString(objCulture), token: token);
                    // <fallingarmor />
                    await objWriter.WriteElementStringAsync("fallingarmor", intFallingArmor.ToString(objCulture), token: token);

                    int intDamageResistanceDice = (await ImprovementManager
                            .ValueOfAsync(this, Improvement.ImprovementType.DamageResistance, token: token))
                                                  .StandardRound();
                    int intBodTotalValue = await (await GetAttributeAsync("BOD", token: token)).GetTotalValueAsync(token);
                    // <armordicestun />
                    await objWriter.WriteElementStringAsync("armordicestun",
                                                            (intBodTotalValue + intDamageResistanceDice
                                                                              + intArmor).ToString(objCulture), token: token);
                    // <firearmordicestun />
                    await objWriter.WriteElementStringAsync("firearmordicestun",
                                                            (intBodTotalValue + intDamageResistanceDice
                                                                              + intFireArmor)
                                                            .ToString(objCulture), token: token);
                    // <coldarmordicestun />
                    await objWriter.WriteElementStringAsync("coldarmordicestun",
                                                            (intBodTotalValue + intDamageResistanceDice
                                                                              + intColdArmor)
                                                            .ToString(objCulture), token: token);
                    // <electricityarmordicestun />
                    await objWriter.WriteElementStringAsync("electricityarmordicestun",
                                                            (intBodTotalValue + intDamageResistanceDice
                                                                              + intElectricityArmor)
                                                            .ToString(objCulture), token: token);
                    // <acidarmordicestun />
                    await objWriter.WriteElementStringAsync("acidarmordicestun",
                                                            (intBodTotalValue + intDamageResistanceDice
                                                                              + intAcidArmor)
                                                            .ToString(objCulture), token: token);
                    // <fallingarmordicestun />
                    await objWriter.WriteElementStringAsync("fallingarmordicestun",
                                                            (intBodTotalValue + intDamageResistanceDice
                                                                              + intFallingArmor)
                                                            .ToString(objCulture), token: token);
                    // <armordicephysical />
                    await objWriter.WriteElementStringAsync("armordicephysical",
                                                            (intBodTotalValue + intDamageResistanceDice
                                                                              + intArmor).ToString(objCulture), token: token);
                    // <firearmordicephysical />
                    await objWriter.WriteElementStringAsync("firearmordicephysical",
                                                            (intBodTotalValue + intDamageResistanceDice
                                                                              + intFireArmor)
                                                            .ToString(objCulture), token: token);
                    // <coldarmordicephysical />
                    await objWriter.WriteElementStringAsync("coldarmordicephysical",
                                                            (intBodTotalValue + intDamageResistanceDice
                                                                              + intColdArmor)
                                                            .ToString(objCulture), token: token);
                    // <electricityarmordicephysical />
                    await objWriter.WriteElementStringAsync("electricityarmordicephysical",
                                                            (intBodTotalValue + intDamageResistanceDice
                                                                              + intElectricityArmor)
                                                            .ToString(objCulture), token: token);
                    // <acidarmordicephysical />
                    await objWriter.WriteElementStringAsync("acidarmordicephysical",
                                                            (intBodTotalValue + intDamageResistanceDice
                                                                              + intAcidArmor)
                                                            .ToString(objCulture), token: token);
                    // <fallingarmordicephysical />
                    await objWriter.WriteElementStringAsync("fallingarmordicephysical",
                                                            (intBodTotalValue + intDamageResistanceDice
                                                                              + intFallingArmor)
                                                            .ToString(objCulture), token: token);

                    bool blnIsAI = IsAI;
                    bool blnPhysicalTrackIsCore = blnIsAI && !(HomeNode is Vehicle);
                    // Condition Monitors.
                    // <physicalcm />
                    int intPhysicalCM = PhysicalCM;
                    await objWriter.WriteElementStringAsync("physicalcm", intPhysicalCM.ToString(objCulture), token: token);
                    await objWriter.WriteElementStringAsync("physicalcmiscorecm",
                                                            blnPhysicalTrackIsCore.ToString(
                                                                GlobalSettings.InvariantCultureInfo), token: token);
                    // <stuncm />
                    int intStunCM = StunCM;
                    await objWriter.WriteElementStringAsync("stuncm", intStunCM.ToString(objCulture), token: token);
                    await objWriter.WriteElementStringAsync("stuncmismatrixcm",
                                                            blnIsAI.ToString(GlobalSettings.InvariantCultureInfo), token: token);

                    // Condition Monitor Progress.
                    // <physicalcmfilled />
                    await objWriter.WriteElementStringAsync("physicalcmfilled", PhysicalCMFilled.ToString(objCulture), token: token);
                    // <stuncmfilled />
                    await objWriter.WriteElementStringAsync("stuncmfilled", StunCMFilled.ToString(objCulture), token: token);

                    // <cmthreshold>
                    await objWriter.WriteElementStringAsync("cmthreshold", CMThreshold.ToString(objCulture), token: token);
                    // <cmthresholdoffset>
                    await objWriter.WriteElementStringAsync("physicalcmthresholdoffset",
                                                            Math.Min(PhysicalCMThresholdOffset, intPhysicalCM)
                                                                .ToString(objCulture), token: token);
                    // <cmthresholdoffset>
                    await objWriter.WriteElementStringAsync("stuncmthresholdoffset",
                                                            Math.Min(StunCMThresholdOffset, intStunCM)
                                                                .ToString(objCulture), token: token);
                    // <cmoverflow>
                    await objWriter.WriteElementStringAsync("cmoverflow", CMOverflow.ToString(objCulture), token: token);

                    // <psyche>
                    await objWriter.WriteElementStringAsync(
                        "psyche", _blnPsycheActive.ToString(GlobalSettings.InvariantCultureInfo), token: token);

                    // Calculate Initiatives.
                    // Initiative.
                    await objWriter.WriteElementStringAsync("init", GetInitiative(objCulture, strLanguageToPrint), token: token);
                    await objWriter.WriteElementStringAsync("initdice", InitiativeDice.ToString(objCulture), token: token);
                    await objWriter.WriteElementStringAsync("initvalue", InitiativeValue.ToString(objCulture), token: token);
                    await objWriter.WriteElementStringAsync("initbonus",
                                                            Math.Max(
                                                                    await ImprovementManager.ValueOfAsync(
                                                                        this, Improvement.ImprovementType.Initiative, token: token),
                                                                    0)
                                                                .ToString(objCulture), token: token);

                    // Astral Initiative.
                    if (MAGEnabled)
                    {
                        await objWriter.WriteElementStringAsync("astralinit",
                                                                GetAstralInitiative(objCulture, strLanguageToPrint), token: token);
                        await objWriter.WriteElementStringAsync("astralinitdice",
                                                                AstralInitiativeDice.ToString(objCulture), token: token);
                        await objWriter.WriteElementStringAsync("astralinitvalue",
                                                                AstralInitiativeValue.ToString(objCulture), token: token);
                    }

                    // Matrix Initiative (AR).
                    await objWriter.WriteElementStringAsync("matrixarinit",
                                                            GetMatrixInitiative(objCulture, strLanguageToPrint), token: token);
                    await objWriter.WriteElementStringAsync("matrixarinitdice",
                                                            MatrixInitiativeDice.ToString(objCulture), token: token);
                    await objWriter.WriteElementStringAsync("matrixarinitvalue",
                                                            MatrixInitiativeValue.ToString(objCulture), token: token);

                    // Matrix Initiative (Cold).
                    await objWriter.WriteElementStringAsync("matrixcoldinit",
                                                            GetMatrixInitiativeCold(objCulture, strLanguageToPrint), token: token);
                    await objWriter.WriteElementStringAsync("matrixcoldinitdice",
                                                            MatrixInitiativeDice.ToString(objCulture), token: token);
                    await objWriter.WriteElementStringAsync("matrixcoldinitvalue",
                                                            MatrixInitiativeValue.ToString(objCulture), token: token);

                    // Matrix Initiative (Hot).
                    await objWriter.WriteElementStringAsync("matrixhotinit",
                                                            GetMatrixInitiativeHot(objCulture, strLanguageToPrint), token: token);
                    await objWriter.WriteElementStringAsync("matrixhotinitdice",
                                                            MatrixInitiativeDice.ToString(objCulture), token: token);
                    await objWriter.WriteElementStringAsync("matrixhotinitvalue",
                                                            MatrixInitiativeValue.ToString(objCulture), token: token);

                    // Rigger Initiative.
                    await objWriter.WriteElementStringAsync("riggerinit",
                                                            GetInitiative(objCulture, strLanguageToPrint), token: token);

                    // <magenabled />
                    await objWriter.WriteElementStringAsync("magenabled",
                                                            MAGEnabled.ToString(GlobalSettings.InvariantCultureInfo), token: token);
                    // <initiategrade />
                    await objWriter.WriteElementStringAsync("initiategrade", InitiateGrade.ToString(objCulture), token: token);
                    // <resenabled />
                    await objWriter.WriteElementStringAsync("resenabled",
                                                            RESEnabled.ToString(GlobalSettings.InvariantCultureInfo), token: token);
                    // <submersiongrade />
                    await objWriter.WriteElementStringAsync("submersiongrade", SubmersionGrade.ToString(objCulture), token: token);
                    // <depenabled />
                    await objWriter.WriteElementStringAsync("depenabled",
                                                            DEPEnabled.ToString(GlobalSettings.InvariantCultureInfo), token: token);
                    // <groupmember />
                    await objWriter.WriteElementStringAsync("groupmember",
                                                            GroupMember.ToString(GlobalSettings.InvariantCultureInfo), token: token);
                    // <groupname />
                    await objWriter.WriteElementStringAsync("groupname", GroupName, token: token);
                    // <groupnotes />
                    await objWriter.WriteElementStringAsync("groupnotes", GroupNotes, token: token);
                    // <surprise />
                    await objWriter.WriteElementStringAsync("surprise", Surprise.ToString(objCulture), token: token);
                    // <composure />
                    await objWriter.WriteElementStringAsync("composure", Composure.ToString(objCulture), token: token);
                    // <judgeintentions />
                    await objWriter.WriteElementStringAsync("judgeintentions", JudgeIntentions.ToString(objCulture), token: token);
                    // <judgeintentionsresist />
                    await objWriter.WriteElementStringAsync("judgeintentionsresist",
                                                            JudgeIntentionsResist.ToString(objCulture), token: token);
                    // <liftandcarry />
                    await objWriter.WriteElementStringAsync("liftandcarry", LiftAndCarry.ToString(objCulture), token: token);
                    // <memory />
                    await objWriter.WriteElementStringAsync("memory", Memory.ToString(objCulture), token: token);
                    // <liftweight />
                    await objWriter.WriteElementStringAsync("liftweight",
                                                            LiftLimit.ToString(Settings.WeightFormat, objCulture), token: token);
                    // <carryweight />
                    await objWriter.WriteElementStringAsync("carryweight",
                                                            CarryLimit.ToString(Settings.WeightFormat, objCulture), token: token);
                    // <totalcarriedweight />
                    await objWriter.WriteElementStringAsync("totalcarriedweight",
                                                            TotalCarriedWeight.ToString(
                                                                Settings.WeightFormat, objCulture), token: token);
                    // <fatigueresist />
                    await objWriter.WriteElementStringAsync("fatigueresist", FatigueResist.ToString(objCulture), token: token);
                    // <radiationresist />
                    await objWriter.WriteElementStringAsync("radiationresist", RadiationResist.ToString(objCulture), token: token);
                    // <sonicresist />
                    await objWriter.WriteElementStringAsync("sonicresist", SonicResist.ToString(objCulture), token: token);
                    // <toxincontacttesist />
                    await objWriter.WriteElementStringAsync("toxincontactresist",
                                                            ToxinContactResist(strLanguageToPrint, objCulture), token: token);
                    // <toxiningestionresist />
                    await objWriter.WriteElementStringAsync("toxiningestionresist",
                                                            ToxinIngestionResist(strLanguageToPrint, objCulture), token: token);
                    // <toxininhalationresist />
                    await objWriter.WriteElementStringAsync("toxininhalationresist",
                                                            ToxinInhalationResist(strLanguageToPrint, objCulture), token: token);
                    // <toxininjectionresist />
                    await objWriter.WriteElementStringAsync("toxininjectionresist",
                                                            ToxinInjectionResist(strLanguageToPrint, objCulture), token: token);
                    // <pathogencontactresist />
                    await objWriter.WriteElementStringAsync("pathogencontactresist",
                                                            PathogenContactResist(strLanguageToPrint, objCulture), token: token);
                    // <pathogeningestionresist />
                    await objWriter.WriteElementStringAsync("pathogeningestionresist",
                                                            PathogenIngestionResist(strLanguageToPrint, objCulture), token: token);
                    // <pathogeninhalationresist />
                    await objWriter.WriteElementStringAsync("pathogeninhalationresist",
                                                            PathogenInhalationResist(strLanguageToPrint, objCulture), token: token);
                    // <pathogeninjectionresist />
                    await objWriter.WriteElementStringAsync("pathogeninjectionresist",
                                                            PathogenInjectionResist(strLanguageToPrint, objCulture), token: token);
                    // <physiologicaladdictionresistfirsttime />
                    await objWriter.WriteElementStringAsync("physiologicaladdictionresistfirsttime",
                                                            PhysiologicalAddictionResistFirstTime.ToString(objCulture), token: token);
                    // <physiologicaladdictionresistalreadyaddicted />
                    await objWriter.WriteElementStringAsync("physiologicaladdictionresistalreadyaddicted",
                                                            PhysiologicalAddictionResistAlreadyAddicted.ToString(
                                                                objCulture), token: token);
                    // <psychologicaladdictionresistfirsttime />
                    await objWriter.WriteElementStringAsync("psychologicaladdictionresistfirsttime",
                                                            PsychologicalAddictionResistFirstTime.ToString(objCulture), token: token);
                    // <psychologicaladdictionresistalreadyaddicted />
                    await objWriter.WriteElementStringAsync("psychologicaladdictionresistalreadyaddicted",
                                                            PsychologicalAddictionResistAlreadyAddicted.ToString(
                                                                objCulture), token: token);
                    // <physicalcmnaturalrecovery />
                    await objWriter.WriteElementStringAsync("physicalcmnaturalrecovery",
                                                            PhysicalCMNaturalRecovery.ToString(objCulture), token: token);
                    // <stuncmnaturalrecovery />
                    await objWriter.WriteElementStringAsync("stuncmnaturalrecovery",
                                                            StunCMNaturalRecovery.ToString(objCulture), token: token);

                    // Spell Resistances
                    //Indirect Dodge
                    await objWriter.WriteElementStringAsync("indirectdefenseresist",
                                                            SpellDefenseIndirectDodge.ToString(objCulture), token: token);
                    //Direct Soak - Mana
                    await objWriter.WriteElementStringAsync("directmanaresist",
                                                            SpellDefenseDirectSoakMana.ToString(objCulture), token: token);
                    //Direct Soak - Physical
                    await objWriter.WriteElementStringAsync("directphysicalresist",
                                                            SpellDefenseDirectSoakPhysical.ToString(objCulture), token: token);
                    //Detection Spells
                    await objWriter.WriteElementStringAsync("detectionspellresist",
                                                            SpellDefenseDetection.ToString(objCulture), token: token);
                    //Decrease Attribute - BOD
                    await objWriter.WriteElementStringAsync("decreasebodresist",
                                                            SpellDefenseDecreaseBOD.ToString(objCulture), token: token);
                    //Decrease Attribute - AGI
                    await objWriter.WriteElementStringAsync("decreaseagiresist",
                                                            SpellDefenseDecreaseAGI.ToString(objCulture), token: token);
                    //Decrease Attribute - REA
                    await objWriter.WriteElementStringAsync("decreaserearesist",
                                                            SpellDefenseDecreaseREA.ToString(objCulture), token: token);
                    //Decrease Attribute - STR
                    await objWriter.WriteElementStringAsync("decreasestrresist",
                                                            SpellDefenseDecreaseSTR.ToString(objCulture), token: token);
                    //Decrease Attribute - CHA
                    await objWriter.WriteElementStringAsync("decreasecharesist",
                                                            SpellDefenseDecreaseCHA.ToString(objCulture), token: token);
                    //Decrease Attribute - INT
                    await objWriter.WriteElementStringAsync("decreaseintresist",
                                                            SpellDefenseDecreaseINT.ToString(objCulture), token: token);
                    //Decrease Attribute - LOG
                    await objWriter.WriteElementStringAsync("decreaselogresist",
                                                            SpellDefenseDecreaseLOG.ToString(objCulture), token: token);
                    //Decrease Attribute - WIL
                    await objWriter.WriteElementStringAsync("decreasewilresist",
                                                            SpellDefenseDecreaseWIL.ToString(objCulture), token: token);
                    //Illusion - Mana
                    await objWriter.WriteElementStringAsync("illusionmanaresist",
                                                            SpellDefenseIllusionMana.ToString(objCulture), token: token);
                    //Illusion - Physical
                    await objWriter.WriteElementStringAsync("illusionphysicalresist",
                                                            SpellDefenseIllusionPhysical.ToString(objCulture), token: token);
                    //Manipulation - Mental
                    await objWriter.WriteElementStringAsync("manipulationmentalresist",
                                                            SpellDefenseManipulationMental.ToString(objCulture), token: token);
                    //Manipulation - Physical
                    await objWriter.WriteElementStringAsync("manipulationphysicalresist",
                                                            SpellDefenseManipulationPhysical.ToString(objCulture), token: token);

                    // <skills>
                    XmlElementWriteHelper objSkillsElement = await objWriter.StartElementAsync("skills", token: token);
                    try
                    {
                        await SkillsSection.Print(objWriter, objCulture, strLanguageToPrint, token: token);
                    }
                    finally
                    {
                        // </skills>
                        await objSkillsElement.DisposeAsync();
                    }

                    // <contacts>
                    XmlElementWriteHelper objContactsElement = await objWriter.StartElementAsync("contacts", token: token);
                    try
                    {
                        foreach (Contact objContact in Contacts)
                        {
                            await objContact.Print(objWriter, objCulture, strLanguageToPrint, token);
                        }
                    }
                    finally
                    {
                        // </contacts>
                        await objContactsElement.DisposeAsync();
                    }

                    // <limitmodifiersphys>
                    XmlElementWriteHelper objLimitModifiersPhysElement = await objWriter.StartElementAsync("limitmodifiersphys", token: token);
                    try
                    {
                        await (await GetLimitModifiersAsync(token)).ForEachAsync(async objLimitModifier =>
                        {
                            if (objLimitModifier.Limit == "Physical")
                            {
                                await objLimitModifier.Print(objWriter, objCulture, strLanguageToPrint);
                            }
                        }, token);

                        // Populate Limit Modifiers from Improvements
                        foreach (Improvement objImprovement in await ImprovementManager.GetCachedImprovementListForValueOfAsync(this,
                                     Improvement.ImprovementType.LimitModifier, "Physical", token: token))
                        {
                            string strName = await GetObjectNameAsync(objImprovement, strLanguageToPrint, token);
                            if (strName == objImprovement.SourceName)
                                strName = objImprovement.UniqueName;
                            strName += await LanguageManager.GetStringAsync("String_Colon", strLanguageToPrint, token: token) +
                                       await LanguageManager.GetStringAsync("String_Space", strLanguageToPrint, token: token);
                            if (objImprovement.Value > 0)
                                strName += '+';
                            strName += objImprovement.Value.ToString(objCulture);

                            if (!string.IsNullOrEmpty(objImprovement.Condition))
                                strName += ',' + await LanguageManager.GetStringAsync("String_Space", strLanguageToPrint, token: token) +
                                           objImprovement.Condition;

                            // <limitmodifier>
                            XmlElementWriteHelper objLimitModifierElement = await objWriter.StartElementAsync("limitmodifier", token: token);
                            try
                            {
                                await objWriter.WriteElementStringAsync("name", strName, token: token);
                                if (GlobalSettings.PrintNotes)
                                    await objWriter.WriteElementStringAsync("notes", objImprovement.Notes, token: token);
                            }
                            finally
                            {
                                // </limitmodifier>
                                await objLimitModifierElement.DisposeAsync();
                            }
                        }
                    }
                    finally
                    {
                        // </limitmodifiersphys>
                        await objLimitModifiersPhysElement.DisposeAsync();
                    }

                    // <limitmodifiersment>
                    XmlElementWriteHelper objLimitModifiersMentElement = await objWriter.StartElementAsync("limitmodifiersment", token: token);
                    try
                    {
                        await (await GetLimitModifiersAsync(token)).ForEachAsync(async objLimitModifier =>
                        {
                            if (objLimitModifier.Limit == "Mental")
                            {
                                await objLimitModifier.Print(objWriter, objCulture, strLanguageToPrint);
                            }
                        }, token);

                        // Populate Limit Modifiers from Improvements
                        foreach (Improvement objImprovement in await ImprovementManager.GetCachedImprovementListForValueOfAsync(this,
                                     Improvement.ImprovementType.LimitModifier, "Mental", token: token))
                        {
                            string strName = await GetObjectNameAsync(objImprovement, strLanguageToPrint, token);
                            if (strName == objImprovement.SourceName)
                                strName = objImprovement.UniqueName;
                            strName += await LanguageManager.GetStringAsync("String_Colon", strLanguageToPrint, token: token) +
                                       await LanguageManager.GetStringAsync("String_Space", strLanguageToPrint, token: token);
                            if (objImprovement.Value > 0)
                                strName += '+';
                            strName += objImprovement.Value.ToString(objCulture);

                            if (!string.IsNullOrEmpty(objImprovement.Condition))
                                strName += ',' + await LanguageManager.GetStringAsync("String_Space", strLanguageToPrint, token: token) +
                                           objImprovement.Condition;

                            // <limitmodifier>
                            XmlElementWriteHelper objLimitModifierElement = await objWriter.StartElementAsync("limitmodifier", token: token);
                            try
                            {
                                await objWriter.WriteElementStringAsync("name", strName, token: token);
                                if (GlobalSettings.PrintNotes)
                                    await objWriter.WriteElementStringAsync("notes", objImprovement.Notes, token: token);
                            }
                            finally
                            {
                                // </limitmodifier>
                                await objLimitModifierElement.DisposeAsync();
                            }
                        }
                    }
                    finally
                    {
                        // </limitmodifiersment>
                        await objLimitModifiersMentElement.DisposeAsync();
                    }

                    // <limitmodifierssoc>
                    XmlElementWriteHelper objLimitModifiersSocElement = await objWriter.StartElementAsync("limitmodifierssoc", token: token);
                    try
                    {
                        await (await GetLimitModifiersAsync(token)).ForEachAsync(async objLimitModifier =>
                        {
                            if (objLimitModifier.Limit == "Social")
                            {
                                await objLimitModifier.Print(objWriter, objCulture, strLanguageToPrint);
                            }
                        }, token);

                        // Populate Limit Modifiers from Improvements
                        foreach (Improvement objImprovement in await ImprovementManager.GetCachedImprovementListForValueOfAsync(this,
                                     Improvement.ImprovementType.LimitModifier, "Social", token: token))
                        {
                            string strName = await GetObjectNameAsync(objImprovement, strLanguageToPrint, token);
                            if (strName == objImprovement.SourceName)
                                strName = objImprovement.UniqueName;
                            strName += await LanguageManager.GetStringAsync("String_Colon", strLanguageToPrint, token: token) +
                                       await LanguageManager.GetStringAsync("String_Space", strLanguageToPrint, token: token);
                            if (objImprovement.Value > 0)
                                strName += '+';
                            strName += objImprovement.Value.ToString(objCulture);

                            if (!string.IsNullOrEmpty(objImprovement.Condition))
                                strName += ',' + await LanguageManager.GetStringAsync("String_Space", strLanguageToPrint, token: token) +
                                           objImprovement.Condition;

                            // <limitmodifier>
                            XmlElementWriteHelper objLimitModifierElement = await objWriter.StartElementAsync("limitmodifier", token: token);
                            try
                            {
                                await objWriter.WriteElementStringAsync("name", strName, token: token);
                                if (GlobalSettings.PrintNotes)
                                    await objWriter.WriteElementStringAsync("notes", objImprovement.Notes, token: token);
                            }
                            finally
                            {
                                // </limitmodifier>
                                await objLimitModifierElement.DisposeAsync();
                            }
                        }
                    }
                    finally
                    {
                        // </limitmodifierssoc>
                        await objLimitModifiersSocElement.DisposeAsync();
                    }

                    // <mentorspirits>
                    XmlElementWriteHelper objMentorSpiritsElement = await objWriter.StartElementAsync("mentorspirits", token: token);
                    try
                    {
                        foreach (MentorSpirit objMentorSpirit in MentorSpirits)
                        {
                            await objMentorSpirit.Print(objWriter, strLanguageToPrint);
                        }
                    }
                    finally
                    {
                        // </mentorspirits>
                        await objMentorSpiritsElement.DisposeAsync();
                    }

                    // <spells>
                    XmlElementWriteHelper objSpellsElement = await objWriter.StartElementAsync("spells", token: token);
                    try
                    {
                        foreach (Spell objSpell in Spells)
                        {
                            await objSpell.Print(objWriter, objCulture, strLanguageToPrint);
                        }
                    }
                    finally
                    {
                        // </spells>
                        await objSpellsElement.DisposeAsync();
                    }

                    // <powers>
                    XmlElementWriteHelper objPowersElement = await objWriter.StartElementAsync("powers", token: token);
                    try
                    {
                        foreach (Power objPower in Powers)
                        {
                            await objPower.Print(objWriter, objCulture, strLanguageToPrint);
                        }
                    }
                    finally
                    {
                        // </powers>
                        await objPowersElement.DisposeAsync();
                    }

                    // <spirits>
                    XmlElementWriteHelper objSpiritsElement = await objWriter.StartElementAsync("spirits", token: token);
                    try
                    {
                        foreach (Spirit objSpirit in Spirits)
                        {
                            await objSpirit.Print(objWriter, objCulture, strLanguageToPrint, token);
                        }
                    }
                    finally
                    {
                        // </spirits>
                        await objSpiritsElement.DisposeAsync();
                    }

                    // <complexforms>
                    XmlElementWriteHelper objComplexFormsElement = await objWriter.StartElementAsync("complexforms", token: token);
                    try
                    {
                        foreach (ComplexForm objComplexForm in ComplexForms)
                        {
                            await objComplexForm.Print(objWriter, strLanguageToPrint);
                        }
                    }
                    finally
                    {
                        // </complexforms>
                        await objComplexFormsElement.DisposeAsync();
                    }

                    // <aiprograms>
                    XmlElementWriteHelper objAIProgramsElement = await objWriter.StartElementAsync("aiprograms", token: token);
                    try
                    {
                        foreach (AIProgram objProgram in AIPrograms)
                        {
                            await objProgram.Print(objWriter, strLanguageToPrint);
                        }
                    }
                    finally
                    {
                        // </aiprograms>
                        await objAIProgramsElement.DisposeAsync();
                    }

                    // <martialarts>
                    XmlElementWriteHelper objMartialArtsElement = await objWriter.StartElementAsync("martialarts", token: token);
                    try
                    {
                        foreach (MartialArt objMartialArt in MartialArts)
                        {
                            await objMartialArt.Print(objWriter, objCulture, strLanguageToPrint);
                        }
                    }
                    finally
                    {
                        // </martialarts>
                        await objMartialArtsElement.DisposeAsync();
                    }

                    // <armors>
                    XmlElementWriteHelper objArmorsElement = await objWriter.StartElementAsync("armors", token: token);
                    try
                    {
                        foreach (Armor objArmor in Armor)
                        {
                            await objArmor.Print(objWriter, objCulture, strLanguageToPrint);
                        }
                    }
                    finally
                    {
                        // </armors>
                        await objArmorsElement.DisposeAsync();
                    }

                    // <weapons>
                    XmlElementWriteHelper objWeaponsElement = await objWriter.StartElementAsync("weapons", token: token);
                    try
                    {
                        foreach (Weapon objWeapon in Weapons)
                        {
                            await objWeapon.Print(objWriter, objCulture, strLanguageToPrint);
                        }
                    }
                    finally
                    {
                        // </weapons>
                        await objWeaponsElement.DisposeAsync();
                    }

                    // <cyberwares>
                    XmlElementWriteHelper objCyberwaresElement = await objWriter.StartElementAsync("cyberwares", token: token);
                    try
                    {
                        foreach (Cyberware objCyberware in Cyberware)
                        {
                            await objCyberware.Print(objWriter, objCulture, strLanguageToPrint);
                        }
                    }
                    finally
                    {
                        // </cyberwares>
                        await objCyberwaresElement.DisposeAsync();
                    }

                    // <qualities>
                    XmlElementWriteHelper objQualitiesElement = await objWriter.StartElementAsync("qualities", token: token);
                    try
                    {
                        // Multiple instances of the same quality are combined into just one entry with a number next to it (e.g. 6 discrete entries of "Focused Concentration" become "Focused Concentration 6")
                        Dictionary<string, int> strQualitiesToPrint = new Dictionary<string, int>(Qualities.Count);
                        foreach (Quality objQuality in Qualities)
                        {
                            string strKey = objQuality.SourceIDString + '|' + objQuality.SourceName + '|'
                                            + objQuality.Extra;
                            if (strQualitiesToPrint.TryGetValue(strKey, out int intExistingRating))
                            {
                                strQualitiesToPrint[strKey] = intExistingRating + 1;
                            }
                            else
                            {
                                strQualitiesToPrint.Add(strKey, 1);
                            }
                        }

                        foreach (Quality objQuality in Qualities)
                        {
                            string strKey = objQuality.SourceIDString + '|' + objQuality.SourceName + '|'
                                            + objQuality.Extra;
                            if (strQualitiesToPrint.TryGetValue(strKey, out int intLoopRating))
                            {
                                await objQuality.Print(objWriter, intLoopRating, objCulture, strLanguageToPrint);
                                strQualitiesToPrint.Remove(strKey);
                            }
                        }
                    }
                    finally
                    {
                        // </qualities>
                        await objQualitiesElement.DisposeAsync();
                    }

                    // <lifestyles>
                    XmlElementWriteHelper objLifestylesElement = await objWriter.StartElementAsync("lifestyles", token: token);
                    try
                    {
                        foreach (Lifestyle objLifestyle in Lifestyles)
                        {
                            await objLifestyle.Print(objWriter, objCulture, strLanguageToPrint);
                        }
                    }
                    finally
                    {
                        // </lifestyles>
                        await objLifestylesElement.DisposeAsync();
                    }

                    // <gears>
                    XmlElementWriteHelper objGearsElement = await objWriter.StartElementAsync("gears", token: token);
                    try
                    {
                        foreach (Gear objGear in Gear)
                        {
                            await objGear.Print(objWriter, objCulture, strLanguageToPrint);
                        }
                    }
                    finally
                    {
                        // </gears>
                        await objGearsElement.DisposeAsync();
                    }

                    // <drugs>
                    XmlElementWriteHelper objDrugsElement = await objWriter.StartElementAsync("drugs", token: token);
                    try
                    {
                        foreach (Drug objDrug in Drugs)
                        {
                            await objDrug.Print(objWriter, objCulture, strLanguageToPrint);
                        }
                    }
                    finally
                    {
                        // </drugs>
                        await objDrugsElement.DisposeAsync();
                    }

                    // <vehicles>
                    XmlElementWriteHelper objVehiclesElement = await objWriter.StartElementAsync("vehicles", token: token);
                    try
                    {
                        foreach (Vehicle objVehicle in Vehicles)
                        {
                            await objVehicle.Print(objWriter, objCulture, strLanguageToPrint);
                        }
                    }
                    finally
                    {
                        // </vehicles>
                        await objVehiclesElement.DisposeAsync();
                    }

                    // <initiationgrade>
                    XmlElementWriteHelper objInitiationGradeElement = await objWriter.StartElementAsync("initiationgrade", token: token);
                    try
                    {
                        foreach (InitiationGrade objGrade in InitiationGrades)
                        {
                            await objGrade.Print(objWriter, objCulture);

                            //TODO: Probably better to integrate this into the main print method, but eh.
                            // <metamagics>
                            XmlElementWriteHelper objInitiationMetamagicsElement = await objWriter.StartElementAsync("metamagics", token: token);
                            try
                            {
                                foreach (Metamagic objMetamagic in Metamagics)
                                {
                                    if (objMetamagic.Grade == objGrade.Grade)
                                        await objMetamagic.Print(objWriter, objCulture, strLanguageToPrint);
                                }
                            }
                            finally
                            {
                                // </metamagics>
                                await objInitiationMetamagicsElement.DisposeAsync();
                            }

                            // <arts>
                            XmlElementWriteHelper objInitiationArtsElement = await objWriter.StartElementAsync("arts", token: token);
                            try
                            {
                                foreach (Art objArt in Arts)
                                {
                                    if (objArt.Grade == objGrade.Grade)
                                        await objArt.Print(objWriter, strLanguageToPrint);
                                }
                            }
                            finally
                            {
                                // </arts>
                                await objInitiationArtsElement.DisposeAsync();
                            }

                            // <enhancements>
                            XmlElementWriteHelper objInitiationEnhancementsElement = await objWriter.StartElementAsync("enhancements", token: token);
                            try
                            {
                                foreach (Enhancement objEnhancement in Enhancements)
                                {
                                    if (objEnhancement.Grade == objGrade.Grade)
                                        await objEnhancement.Print(objWriter, strLanguageToPrint);
                                }
                            }
                            finally
                            {
                                // </enhancements>
                                await objInitiationEnhancementsElement.DisposeAsync();
                            }
                        }
                    }
                    finally
                    {
                        // </initiationgrade>
                        await objInitiationGradeElement.DisposeAsync();
                    }

                    // <metamagics>
                    XmlElementWriteHelper objMetamagicsElement = await objWriter.StartElementAsync("metamagics", token: token);
                    try
                    {
                        foreach (Metamagic objMetamagic in Metamagics)
                        {
                            await objMetamagic.Print(objWriter, objCulture, strLanguageToPrint);
                        }
                    }
                    finally
                    {
                        // </metamagics>
                        await objMetamagicsElement.DisposeAsync();
                    }

                    // <arts>
                    XmlElementWriteHelper objArtsElement = await objWriter.StartElementAsync("arts", token: token);
                    try
                    {
                        foreach (Art objArt in Arts)
                        {
                            await objArt.Print(objWriter, strLanguageToPrint);
                        }
                    }
                    finally
                    {
                        // </arts>
                        await objArtsElement.DisposeAsync();
                    }

                    // <enhancements>
                    XmlElementWriteHelper objEnhancementsElement = await objWriter.StartElementAsync("enhancements", token: token);
                    try
                    {
                        foreach (Enhancement objEnhancement in Enhancements)
                        {
                            await objEnhancement.Print(objWriter, strLanguageToPrint);
                        }
                    }
                    finally
                    {
                        // </enhancements>
                        await objEnhancementsElement.DisposeAsync();
                    }

                    // <critterpowers>
                    XmlElementWriteHelper objCritterPowersElement = await objWriter.StartElementAsync("critterpowers", token: token);
                    try
                    {
                        foreach (CritterPower objPower in CritterPowers)
                        {
                            await objPower.Print(objWriter, strLanguageToPrint);
                        }
                    }
                    finally
                    {
                        // </critterpowers>
                        await objCritterPowersElement.DisposeAsync();
                    }

                    // <sustainedobjects>
                    XmlElementWriteHelper objSustainedObjectsElement = await objWriter.StartElementAsync("sustainedobjects", token: token);
                    try
                    {
                        foreach (SustainedObject objSustained in SustainedCollection)
                        {
                            await objSustained.Print(objWriter, objCulture, strLanguageToPrint);
                        }
                    }
                    finally
                    {
                        // </sustainedobjects>
                        await objSustainedObjectsElement.DisposeAsync();
                    }

                    // <otherarmors>
                    XmlElementWriteHelper objOtherArmorsElement = await objWriter.StartElementAsync("otherarmors", token: token);
                    try
                    {
                        foreach (Improvement objImprovement in await ImprovementManager.GetCachedImprovementListForValueOfAsync(this, Improvement.ImprovementType.Armor, token: token))
                        {
                            if (objImprovement.ImproveSource == Improvement.ImprovementSource.Armor
                                || objImprovement.ImproveSource == Improvement.ImprovementSource.ArmorMod)
                                continue;
                            // <otherarmor>
                            XmlElementWriteHelper objBaseElement = await objWriter.StartElementAsync("otherarmor", token: token);
                            try
                            {
                                await objWriter.WriteElementStringAsync("guid", objImprovement.InternalId, token: token);
                                await objWriter.WriteElementStringAsync("sourcename", objImprovement.SourceName, token: token);
                                await objWriter.WriteElementStringAsync("objectname", await GetObjectNameAsync(objImprovement, strLanguageToPrint, token), token: token);
                                await objWriter.WriteElementStringAsync("objectname_english", await GetObjectNameAsync(objImprovement, GlobalSettings.DefaultLanguage, token), token: token);
                                await objWriter.WriteElementStringAsync("armor", objImprovement.Value.ToString(GlobalSettings.InvariantCultureInfo), token: token);
                                await objWriter.WriteElementStringAsync("improvesource", objImprovement.ImproveSource.ToString(), token: token);
                                await objWriter.WriteElementStringAsync("enabled", objImprovement.Enabled.ToString(GlobalSettings.InvariantCultureInfo), token: token);
                                await objWriter.WriteElementStringAsync("customname", objImprovement.CustomName, token: token);
                                await objWriter.WriteElementStringAsync("customgroup", objImprovement.CustomGroup, token: token);
                                if (GlobalSettings.PrintNotes)
                                    await objWriter.WriteElementStringAsync("notes", objImprovement.Notes, token: token);
                            }
                            finally
                            {
                                // </otherarmor>
                                await objBaseElement.DisposeAsync();
                            }
                        }
                    }
                    finally
                    {
                        // </otherarmors>
                        await objOtherArmorsElement.DisposeAsync();
                    }

                    // <calendar>
                    XmlElementWriteHelper objCalendarElement = await objWriter.StartElementAsync("calendar", token: token);
                    try
                    {
                        foreach (CalendarWeek objWeek in Calendar)
                            await objWeek.Print(objWriter, objCulture, GlobalSettings.PrintNotes);
                    }
                    finally
                    {
                        // </calendar>
                        await objCalendarElement.DisposeAsync();
                    }

                    // Print the Expense Log Entries if the option is enabled.
                    if (GlobalSettings.PrintExpenses)
                    {
                        // <expenses>
                        XmlElementWriteHelper objExpensesElement = await objWriter.StartElementAsync("expenses", token: token);
                        try
                        {
                            foreach (ExpenseLogEntry objExpense in ExpenseEntries.Reverse())
                                await objExpense.Print(objWriter, objCulture, strLanguageToPrint);
                        }
                        finally
                        {
                            // </expenses>
                            await objExpensesElement.DisposeAsync();
                        }
                    }
                }
                finally
                {
                    // </character>
                    await objCharacterElement.DisposeAsync();
                }
            }
        }
        #endregion

        public bool IsDisposed { get; private set; }

        /// <summary>
        /// Remove stray event handlers and clear all info used by this character
        /// </summary>
        public void Dispose()
        {
            if (LockObject.IsDisposed)
                return;

            if (Program.OpenCharacters.Contains(this)
                || Program.OpenCharacters.Any(x => x.LinkedCharacters.Contains(this)))
                return; // Do not actually dispose any characters who are still in the open characters list or required by a character who is

            using (EnterReadLock.Enter(LockObject))
            {
                if (IsDisposed)
                    return;
                using (LockObject.EnterWriteLock()) // Wait for all pending locks to get freed before disposing
                {
                    IsDisposed = true;
                    ImprovementManager.ClearCachedValues(this);
                    _lstLinkedCharacters.Clear(); // Clear this list because it relates to Contacts and Spirits disposal
                    _lstLinkedCharacters.Dispose();
                    foreach (Image imgMugshot in _lstMugshots)
                        imgMugshot.Dispose();
                    _lstMugshots.Dispose();
                    foreach (Contact objContact in _lstContacts)
                        objContact.Dispose();
                    _lstContacts.Dispose();
                    foreach (Spirit objSpirit in _lstSpirits)
                        objSpirit.Dispose();
                    _lstSpirits.Dispose();
                    foreach (Armor objItem in _lstArmor)
                        objItem.Dispose();
                    _lstArmor.Dispose();
                    foreach (Weapon objItem in _lstWeapons)
                        objItem.Dispose();
                    _lstWeapons.Dispose();
                    foreach (Gear objItem in _lstGear)
                        objItem.Dispose();
                    _lstGear.Dispose();
                    foreach (Cyberware objItem in _lstCyberware)
                        objItem.Dispose();
                    _lstCyberware.Dispose();
                    foreach (Vehicle objItem in _lstVehicles)
                        objItem.Dispose();
                    _lstVehicles.Dispose();
                    foreach (Lifestyle objItem in _lstLifestyles)
                        objItem.Dispose();
                    _lstLifestyles.Dispose();
                    foreach (Spell objItem in _lstSpells)
                        objItem.Dispose();
                    _lstSpells.Dispose();
                    foreach (MartialArt objItem in _lstMartialArts)
                        objItem.Dispose();
                    _lstMartialArts.Dispose();
                    _lstComplexForms.Dispose();
                    _lstAIPrograms.Dispose();
                    _lstPowers.Dispose();
                    _lstCritterPowers.Dispose();
                    _lstFoci.Dispose();
                    foreach (StackedFocus objItem in _lstStackedFoci)
                        objItem.Dispose();
                    _lstStackedFoci.Dispose();
                    _lstMetamagics.Dispose();
                    _lstArts.Dispose();
                    _lstEnhancements.Dispose();
                    _lstImprovements.Dispose();
                    _lstInitiationGrades.Dispose();
                    _lstInternalIdsNeedingReapplyImprovements.Dispose();
                    _lstCalendar.Dispose();
                    foreach (Drug objItem in _lstDrugs)
                        objItem.Dispose();
                    _lstDrugs.Dispose();
                    _lstExpenseLog.Dispose();
                    foreach (Location objItem in _lstArmorLocations)
                        objItem.Dispose();
                    _lstArmorLocations.Dispose();
                    foreach (Location objItem in _lstGearLocations)
                        objItem.Dispose();
                    _lstGearLocations.Dispose();
                    foreach (Location objItem in _lstWeaponLocations)
                        objItem.Dispose();
                    _lstWeaponLocations.Dispose();
                    foreach (Location objItem in _lstVehicleLocations)
                        objItem.Dispose();
                    _lstVehicleLocations.Dispose();
                    _lstImprovementGroups.Dispose();
                    _lstPrioritySkills.Dispose();
                    _objSkillsSection.Dispose();
                    _objAttributeSection.Dispose();
                    _quePostLoadMethods.Dispose();
                    _quePostLoadMethodsAsync.Dispose();
                    _setDoOnSaveCompleted.Dispose();
                    _setDoOnSaveCompletedAsync.Dispose();
                    if (_stkPushText.IsValueCreated)
                        _stkPushText.Value.Dispose();
                    if (!SettingsManager.LoadedCharacterSettings.ContainsKey(_objSettings.DictionaryKey))
                        _objSettings.Dispose();
                    _objCachedEssenceLock.Dispose();
                }
            }

            LockObject.Dispose();
        }

        /// <summary>
        /// Remove stray event handlers and clear all info used by this character
        /// </summary>
        public async ValueTask DisposeAsync()
        {
            if (LockObject.IsDisposed)
                return;

            if (await Program.OpenCharacters.ContainsAsync(this)
                || await Program.OpenCharacters.AnyAsync(async x => await x.LinkedCharacters.ContainsAsync(this)))
                return; // Do not actually dispose any characters who are still in the open characters list or required by a character who is

            using (await EnterReadLock.EnterAsync(LockObject))
            {
                if (IsDisposed)
                    return;
                IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync();
                try
                {
                    IsDisposed = true;
                    await ImprovementManager.ClearCachedValuesAsync(this);
                    await _lstLinkedCharacters.ClearAsync(); // Clear this list because it relates to Contacts and Spirits disposal
                    await _lstLinkedCharacters.DisposeAsync();
                    foreach (Image imgMugshot in _lstMugshots)
                        imgMugshot.Dispose();
                    await _lstMugshots.DisposeAsync();
                    foreach (Contact objContact in _lstContacts)
                        objContact.Dispose();
                    await _lstContacts.DisposeAsync();
                    foreach (Spirit objSpirit in _lstSpirits)
                        objSpirit.Dispose();
                    await _lstSpirits.DisposeAsync();
                    foreach (Armor objItem in _lstArmor)
                        objItem.Dispose();
                    await _lstArmor.DisposeAsync();
                    foreach (Weapon objItem in _lstWeapons)
                        objItem.Dispose();
                    await _lstWeapons.DisposeAsync();
                    foreach (Gear objItem in _lstGear)
                        objItem.Dispose();
                    await _lstGear.DisposeAsync();
                    foreach (Cyberware objItem in _lstCyberware)
                        objItem.Dispose();
                    await _lstCyberware.DisposeAsync();
                    foreach (Vehicle objItem in _lstVehicles)
                        objItem.Dispose();
                    await _lstVehicles.DisposeAsync();
                    foreach (Lifestyle objItem in _lstLifestyles)
                        objItem.Dispose();
                    await _lstLifestyles.DisposeAsync();
                    foreach (Spell objItem in _lstSpells)
                        objItem.Dispose();
                    await _lstSpells.DisposeAsync();
                    foreach (MartialArt objItem in _lstMartialArts)
                        objItem.Dispose();
                    await _lstMartialArts.DisposeAsync();
                    await _lstComplexForms.DisposeAsync();
                    await _lstAIPrograms.DisposeAsync();
                    await _lstPowers.DisposeAsync();
                    await _lstCritterPowers.DisposeAsync();
                    await _lstFoci.DisposeAsync();
                    foreach (StackedFocus objItem in _lstStackedFoci)
                        objItem.Dispose();
                    await _lstStackedFoci.DisposeAsync();
                    await _lstMetamagics.DisposeAsync();
                    await _lstArts.DisposeAsync();
                    await _lstEnhancements.DisposeAsync();
                    await _lstImprovements.DisposeAsync();
                    await _lstInitiationGrades.DisposeAsync();
                    await _lstInternalIdsNeedingReapplyImprovements.DisposeAsync();
                    await _lstCalendar.DisposeAsync();
                    foreach (Drug objItem in _lstDrugs)
                        objItem.Dispose();
                    await _lstDrugs.DisposeAsync();
                    await _lstExpenseLog.DisposeAsync();
                    foreach (Location objItem in _lstArmorLocations)
                        objItem.Dispose();
                    await _lstArmorLocations.DisposeAsync();
                    foreach (Location objItem in _lstGearLocations)
                        objItem.Dispose();
                    await _lstGearLocations.DisposeAsync();
                    foreach (Location objItem in _lstWeaponLocations)
                        objItem.Dispose();
                    await _lstWeaponLocations.DisposeAsync();
                    foreach (Location objItem in _lstVehicleLocations)
                        objItem.Dispose();
                    await _lstVehicleLocations.DisposeAsync();
                    await _lstImprovementGroups.DisposeAsync();
                    await _lstPrioritySkills.DisposeAsync();
                    await _objSkillsSection.DisposeAsync();
                    await _objAttributeSection.DisposeAsync();
                    await _quePostLoadMethods.DisposeAsync();
                    await _quePostLoadMethodsAsync.DisposeAsync();
                    await _setDoOnSaveCompleted.DisposeAsync();
                    await _setDoOnSaveCompletedAsync.DisposeAsync();
                    if (_stkPushText.IsValueCreated)
                        await _stkPushText.Value.DisposeAsync();
                    if (!await (await SettingsManager.GetLoadedCharacterSettingsAsync()).ContainsKeyAsync(_objSettings.DictionaryKey))
                        await _objSettings.DisposeAsync();
                    await _objCachedEssenceLock.DisposeAsync();
                }
                finally
                {
                    await objLocker.DisposeAsync();
                }
            }

            await LockObject.DisposeAsync();
        }

        /// <summary>
        /// Reset all of the Character information and start from scratch.
        /// </summary>
        public void ResetCharacter(CancellationToken token = default)
        {
            using (LockObject.EnterWriteLock(token))
            {
                _intFreeSpells = 0;
                _intCFPLimit = 0;
                _intAINormalProgramLimit = 0;
                _intAIAdvancedProgramLimit = 0;
                _intCachedCareerKarma = int.MinValue;
                _intCachedContactPoints = int.MinValue;
                _decCachedBaseCarryLimit = decimal.MinValue;
                _decCachedBaseLiftLimit = decimal.MinValue;
                _decCachedTotalCarriedWeight = decimal.MinValue;
                _decCachedEncumbranceInterval = decimal.MinValue;
                _intCachedEnemyKarma = int.MinValue;
                _intCachedInitiationEnabled = int.MinValue;
                _intCachedMetagenicNegativeQualities = int.MinValue;
                _intCachedMetagenicPositiveQualities = int.MinValue;
                _intCachedNegativeQualities = int.MinValue;
                _intCachedNegativeQualityLimitKarma = int.MinValue;
                _intCachedPositiveQualityLimitKarma = int.MinValue;
                _intCachedPositiveQualities = int.MinValue;
                _intCachedRedlinerBonus = int.MinValue;
                _intCachedRestrictedGear = int.MinValue;
                _intCachedTotalAcidArmorRating = int.MinValue;
                _intCachedTotalArmorRating = int.MinValue;
                _intCachedTotalColdArmorRating = int.MinValue;
                _intCachedTotalElectricityArmorRating = int.MinValue;
                _intCachedTotalFallingArmorRating = int.MinValue;
                _intCachedTotalFireArmorRating = int.MinValue;
                _intCurrentCounterspellingDice = 0;
                _intCurrentLiftCarryHits = 0;
                _decCachedBiowareEssence = decimal.MinValue;
                _decCachedCyberwareEssence = decimal.MinValue;
                ResetCachedEssence(token);
                _decCachedEssenceHole = decimal.MinValue;
                _decCachedPowerPointsUsed = decimal.MinValue;
                _decCachedPrototypeTranshumanEssenceUsed = decimal.MinValue;
                _intContactPointsUsed = 0;
                _intKarma = 0;
                _intSpecial = 0;
                _intTotalSpecial = 0;
                _intAttributes = 0;
                _intTotalAttributes = 0;
                _intEdgeUsed = 0;
                _intBoundSpiritLimit = int.MinValue;
                _intRegisteredSpriteLimit = int.MinValue;

                // Reset Metatype Information.
                _strMetatype = string.Empty;
                _strMetavariant = string.Empty;
                _strMetatypeCategory = string.Empty;
                _intMetatypeBP = 0;
                _strMovement = string.Empty;

                // Reset Special Tab Flags.
                _blnAdeptEnabled = false;
                _blnMagicianEnabled = false;
                _blnTechnomancerEnabled = false;
                _blnAdvancedProgramsEnabled = false;
                _blnCyberwareDisabled = false;
                _blnInitiationDisabled = false;
                _blnCritterEnabled = false;

                // Reset Attributes.
                AttributeSection.Reset(token: token);
                _blnMAGEnabled = false;
                _blnRESEnabled = false;
                _blnDEPEnabled = false;
                _blnGroupMember = false;
                _strGroupName = string.Empty;
                _strGroupNotes = string.Empty;
                _intInitiateGrade = 0;
                _intSubmersionGrade = 0;

                _intMAGAdept = 0;
                _intMAGMagician = 0;

                _lstLinkedCharacters.Clear();
                _intMainMugshotIndex = -1;
                foreach (Image imgMugshot in _lstMugshots)
                    imgMugshot.Dispose();
                _lstMugshots.Clear();
                foreach (Contact objContact in _lstContacts)
                    objContact.Dispose();
                _lstContacts.Clear();
                foreach (Spirit objSpirit in _lstSpirits)
                    objSpirit.Dispose();
                _lstSpirits.Clear();
                foreach (Armor objItem in _lstArmor)
                    objItem.Dispose();
                foreach (Weapon objItem in _lstWeapons)
                    objItem.Dispose();
                foreach (Gear objItem in _lstGear)
                    objItem.Dispose();
                foreach (Cyberware objItem in _lstCyberware)
                    objItem.Dispose();
                foreach (Vehicle objItem in _lstVehicles)
                    objItem.Dispose();
                foreach (Lifestyle objItem in _lstLifestyles)
                    objItem.Dispose();
                foreach (Spell objItem in _lstSpells)
                    objItem.Dispose();
                foreach (MartialArt objItem in _lstMartialArts)
                    objItem.Dispose();
                foreach (StackedFocus objItem in _lstStackedFoci)
                    objItem.Dispose();
                // Reset all of the Lists.
                // This kills the GC
                ImprovementManager.ClearCachedValues(this);
                _lstImprovements.Clear();
                _lstSpells.Clear();
                _lstSustainedObjects.Clear();
                _lstFoci.Clear();
                _lstStackedFoci.Clear();
                _lstPowers.Clear();
                _lstComplexForms.Clear();
                _lstAIPrograms.Clear();
                _lstMartialArts.Clear();
                _lstLimitModifiers.Clear();
                _lstArmor.Clear();
                _lstCyberware.Clear();
                _lstMetamagics.Clear();
                _lstArts.Clear();
                _lstEnhancements.Clear();
                _lstWeapons.Clear();
                _lstLifestyles.Clear();
                _lstGear.Clear();
                _lstVehicles.Clear();
                _lstExpenseLog.Clear();
                _lstCritterPowers.Clear();
                _lstInitiationGrades.Clear();
                _lstQualities.Clear();
                _lstCalendar.Clear();
                _lstDrugs.Clear();

                SkillsSection.Reset();
                LoadAsDirty = false;
            }
        }

        /// <summary>
        /// Reset all of the Character information and start from scratch.
        /// </summary>
        public async ValueTask ResetCharacterAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token);
            try
            {
                _intFreeSpells = 0;
                _intCFPLimit = 0;
                _intAINormalProgramLimit = 0;
                _intAIAdvancedProgramLimit = 0;
                _intCachedCareerKarma = int.MinValue;
                _intCachedContactPoints = int.MinValue;
                _decCachedBaseCarryLimit = decimal.MinValue;
                _decCachedBaseLiftLimit = decimal.MinValue;
                _decCachedTotalCarriedWeight = decimal.MinValue;
                _decCachedEncumbranceInterval = decimal.MinValue;
                _intCachedEnemyKarma = int.MinValue;
                _intCachedInitiationEnabled = int.MinValue;
                _intCachedMetagenicNegativeQualities = int.MinValue;
                _intCachedMetagenicPositiveQualities = int.MinValue;
                _intCachedNegativeQualities = int.MinValue;
                _intCachedNegativeQualityLimitKarma = int.MinValue;
                _intCachedPositiveQualityLimitKarma = int.MinValue;
                _intCachedPositiveQualities = int.MinValue;
                _intCachedRedlinerBonus = int.MinValue;
                _intCachedRestrictedGear = int.MinValue;
                _intCachedTotalAcidArmorRating = int.MinValue;
                _intCachedTotalArmorRating = int.MinValue;
                _intCachedTotalColdArmorRating = int.MinValue;
                _intCachedTotalElectricityArmorRating = int.MinValue;
                _intCachedTotalFallingArmorRating = int.MinValue;
                _intCachedTotalFireArmorRating = int.MinValue;
                _intCurrentCounterspellingDice = 0;
                _intCurrentLiftCarryHits = 0;
                _decCachedBiowareEssence = decimal.MinValue;
                _decCachedCyberwareEssence = decimal.MinValue;
                await ResetCachedEssenceAsync(token);
                _decCachedEssenceHole = decimal.MinValue;
                _decCachedPowerPointsUsed = decimal.MinValue;
                _decCachedPrototypeTranshumanEssenceUsed = decimal.MinValue;
                _intContactPointsUsed = 0;
                _intKarma = 0;
                _intSpecial = 0;
                _intTotalSpecial = 0;
                _intAttributes = 0;
                _intTotalAttributes = 0;
                _intEdgeUsed = 0;
                _intBoundSpiritLimit = int.MinValue;
                _intRegisteredSpriteLimit = int.MinValue;

                // Reset Metatype Information.
                _strMetatype = string.Empty;
                _strMetavariant = string.Empty;
                _strMetatypeCategory = string.Empty;
                _intMetatypeBP = 0;
                _strMovement = string.Empty;

                // Reset Special Tab Flags.
                _blnAdeptEnabled = false;
                _blnMagicianEnabled = false;
                _blnTechnomancerEnabled = false;
                _blnAdvancedProgramsEnabled = false;
                _blnCyberwareDisabled = false;
                _blnInitiationDisabled = false;
                _blnCritterEnabled = false;

                // Reset Attributes.
                await AttributeSection.ResetAsync(token: token);
                _blnMAGEnabled = false;
                _blnRESEnabled = false;
                _blnDEPEnabled = false;
                _blnGroupMember = false;
                _strGroupName = string.Empty;
                _strGroupNotes = string.Empty;
                _intInitiateGrade = 0;
                _intSubmersionGrade = 0;

                _intMAGAdept = 0;
                _intMAGMagician = 0;

                await _lstLinkedCharacters.ClearAsync(token);
                _intMainMugshotIndex = -1;
                foreach (Image imgMugshot in _lstMugshots)
                    imgMugshot.Dispose();
                await _lstMugshots.ClearAsync(token);
                foreach (Contact objContact in _lstContacts)
                    objContact.Dispose();
                await _lstContacts.ClearAsync(token);
                foreach (Spirit objSpirit in _lstSpirits)
                    objSpirit.Dispose();
                await _lstSpirits.ClearAsync(token);
                foreach (Armor objItem in _lstArmor)
                    objItem.Dispose();
                foreach (Weapon objItem in _lstWeapons)
                    objItem.Dispose();
                foreach (Gear objItem in _lstGear)
                    objItem.Dispose();
                foreach (Cyberware objItem in _lstCyberware)
                    objItem.Dispose();
                foreach (Vehicle objItem in _lstVehicles)
                    objItem.Dispose();
                foreach (Lifestyle objItem in _lstLifestyles)
                    objItem.Dispose();
                foreach (Spell objItem in _lstSpells)
                    objItem.Dispose();
                foreach (MartialArt objItem in _lstMartialArts)
                    objItem.Dispose();
                foreach (StackedFocus objItem in _lstStackedFoci)
                    objItem.Dispose();
                // Reset all of the Lists.
                // This kills the GC
                await ImprovementManager.ClearCachedValuesAsync(this, token);
                await _lstImprovements.ClearAsync(token);
                await _lstSpells.ClearAsync(token);
                await _lstSustainedObjects.ClearAsync(token);
                await _lstFoci.ClearAsync(token);
                await _lstStackedFoci.ClearAsync(token);
                await _lstPowers.ClearAsync(token);
                await _lstComplexForms.ClearAsync(token);
                await _lstAIPrograms.ClearAsync(token);
                await _lstMartialArts.ClearAsync(token);
                await _lstLimitModifiers.ClearAsync(token);
                await _lstArmor.ClearAsync(token);
                await _lstCyberware.ClearAsync(token);
                await _lstMetamagics.ClearAsync(token);
                await _lstArts.ClearAsync(token);
                await _lstEnhancements.ClearAsync(token);
                await _lstWeapons.ClearAsync(token);
                await _lstLifestyles.ClearAsync(token);
                await _lstGear.ClearAsync(token);
                await _lstVehicles.ClearAsync(token);
                await _lstExpenseLog.ClearAsync(token);
                await _lstCritterPowers.ClearAsync(token);
                await _lstInitiationGrades.ClearAsync(token);
                await _lstQualities.ClearAsync(token);
                await _lstCalendar.ClearAsync(token);
                await _lstDrugs.ClearAsync(token);

                await SkillsSection.ResetAsync(token);
                LoadAsDirty = false;
            }
            finally
            {
                await objLocker.DisposeAsync();
            }
        }

        #endregion

        #region Helper Methods

        /// <summary>
        /// Retrieve the name of the Object that created an Improvement.
        /// </summary>
        /// <param name="objImprovement">Improvement to check.</param>
        /// <param name="strLanguage">Language in which to fetch name.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public string GetObjectName(Improvement objImprovement, string strLanguage = "", CancellationToken token = default)
        {
            if (objImprovement == null)
                return string.Empty;
            if (string.IsNullOrEmpty(strLanguage))
                strLanguage = GlobalSettings.Language;
            string strSpace = LanguageManager.GetString("String_Space", strLanguage, token: token);
            string strImprovedSourceName = objImprovement.SourceName.TrimEndOnce("Pair");
            bool blnWireless = false;

            if (strImprovedSourceName.EndsWith("Wireless", StringComparison.Ordinal))
            {
                blnWireless = true;
                strImprovedSourceName = strImprovedSourceName.TrimEndOnce("Wireless", true);
            }

            Improvement.ImprovementSource eSource = objImprovement.ImproveSource;
            using (EnterReadLock.Enter(LockObject, token))
            {
                switch (eSource)
                {
                    case Improvement.ImprovementSource.Bioware:
                    case Improvement.ImprovementSource.Cyberware:
                    {
                        Cyberware objCyberware = Cyberware.DeepFirstOrDefault(x => x.Children,
                                                                              x => x.InternalId == strImprovedSourceName
                                                                                  && x.SourceType == eSource);
                        if (objCyberware != null)
                        {
                            string strWareReturn = objCyberware.DisplayNameShort(strLanguage);
                            if (objCyberware.Parent != null)
                                strWareReturn += strSpace + '(' + objCyberware.Parent.DisplayNameShort(strLanguage)
                                                 + ')';
                            if (blnWireless)
                                strWareReturn += strSpace + LanguageManager.GetString("String_Wireless", strLanguage, token: token);
                            return strWareReturn;
                        }

                        foreach (Vehicle objVehicle in Vehicles)
                        {
                            foreach (VehicleMod objVehicleMod in objVehicle.Mods)
                            {
                                objCyberware = objVehicleMod.Cyberware.DeepFirstOrDefault(x => x.Children,
                                    x => x.InternalId == strImprovedSourceName);
                                if (objCyberware != null)
                                {
                                    string strWareReturn
                                        = objCyberware.DisplayNameShort(strLanguage) + strSpace + '('
                                          + objVehicle.DisplayNameShort(strLanguage) + ','
                                          + strSpace + objVehicleMod.DisplayNameShort(strLanguage);
                                    if (objCyberware.Parent != null)
                                        strWareReturn += ',' + strSpace
                                                             + objCyberware.Parent.DisplayNameShort(strLanguage);
                                    strWareReturn += ')';
                                    if (blnWireless)
                                        strWareReturn
                                            += strSpace + LanguageManager.GetString("String_Wireless", strLanguage, token: token);
                                    return strWareReturn;
                                }
                            }

                            foreach (WeaponMount objMount in objVehicle.WeaponMounts)
                            {
                                foreach (VehicleMod objVehicleMod in objMount.Mods)
                                {
                                    objCyberware = objVehicleMod.Cyberware.DeepFirstOrDefault(x => x.Children,
                                        x => x.InternalId == strImprovedSourceName);
                                    if (objCyberware != null)
                                    {
                                        string strWareReturn
                                            = objCyberware.DisplayNameShort(strLanguage) + strSpace + '('
                                              + objVehicle.DisplayNameShort(strLanguage) + ',' + strSpace
                                              + objMount.DisplayNameShort(strLanguage) + ','
                                              + strSpace + objVehicleMod.DisplayNameShort(strLanguage);
                                        if (objCyberware.Parent != null)
                                            strWareReturn += ',' + strSpace
                                                                 + objCyberware.Parent.DisplayNameShort(strLanguage);
                                        strWareReturn += ')';
                                        if (blnWireless)
                                            strWareReturn += strSpace
                                                             + LanguageManager.GetString(
                                                                 "String_Wireless", strLanguage, token: token);
                                        return strWareReturn;
                                    }
                                }
                            }
                        }

                        break;
                    }
                    case Improvement.ImprovementSource.Gear:
                    {
                        Gear objReturnGear =
                            Gear.DeepFirstOrDefault(x => x.Children, x => x.InternalId == strImprovedSourceName);
                        if (objReturnGear != null)
                        {
                            string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                            if (objReturnGear.Parent is Gear parent)
                                strGearReturn += strSpace + '(' + parent.DisplayNameShort(strLanguage) + ')';
                            if (blnWireless)
                                strGearReturn += strSpace + LanguageManager.GetString("String_Wireless", strLanguage, token: token);
                            return strGearReturn;
                        }

                        objReturnGear
                            = Weapons.FindWeaponGear(strImprovedSourceName, out WeaponAccessory objGearAccessory);

                        if (objReturnGear != null)
                        {
                            string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                            if (objReturnGear.Parent is Gear parent)
                                strGearReturn += strSpace + '(' + objGearAccessory.Parent.DisplayNameShort(strLanguage)
                                                 + ','
                                                 + strSpace
                                                 + objGearAccessory.DisplayNameShort(strLanguage) + ',' + strSpace
                                                 + parent.DisplayNameShort(strLanguage) + ')';
                            else
                                strGearReturn += strSpace + '(' + objGearAccessory.Parent.DisplayNameShort(strLanguage)
                                                 + ','
                                                 + strSpace + objGearAccessory.DisplayNameShort(strLanguage) + ')';
                            if (blnWireless)
                                strGearReturn
                                    += strSpace + LanguageManager.GetString("String_Wireless", strLanguage, token: token);
                            return strGearReturn;
                        }

                        objReturnGear
                            = Armor.FindArmorGear(strImprovedSourceName, out Armor objArmor, out ArmorMod objArmorMod);
                        if (objReturnGear != null)
                        {
                            string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                            if (objReturnGear.Parent is Gear objParent)
                            {
                                strGearReturn += strSpace + '(' + objArmor.DisplayNameShort(strLanguage) + ','
                                                 + strSpace
                                                 + objArmorMod.DisplayNameShort(strLanguage) + ',' + strSpace
                                                 + objParent.DisplayNameShort(strLanguage) + ')';
                            }
                            else if (objArmorMod != null)
                                strGearReturn += strSpace + '(' + objArmor.DisplayNameShort(strLanguage) + ','
                                                 + strSpace
                                                 + objArmorMod.DisplayNameShort(strLanguage) + ')';
                            else
                                strGearReturn += strSpace + '(' + objArmor.DisplayNameShort(strLanguage) + ')';

                            if (blnWireless)
                                strGearReturn += strSpace + LanguageManager.GetString("String_Wireless", strLanguage, token: token);
                            return strGearReturn;
                        }

                        objReturnGear
                            = Cyberware.FindCyberwareGear(strImprovedSourceName, out Cyberware objGearCyberware);

                        if (objReturnGear != null)
                        {
                            string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                            if (objReturnGear.Parent is Gear parent)
                                strGearReturn += strSpace + '(' + objGearCyberware.DisplayNameShort(strLanguage) + ','
                                                 + strSpace
                                                 + strSpace + parent.DisplayNameShort(strLanguage) + ')';
                            else
                                strGearReturn += strSpace + '(' + objGearCyberware.DisplayNameShort(strLanguage) + ')';
                            if (blnWireless)
                                strGearReturn += strSpace + LanguageManager.GetString("String_Wireless", strLanguage, token: token);
                            return strGearReturn;
                        }

                        foreach (Vehicle objVehicle in Vehicles)
                        {
                            objReturnGear = objVehicle.GearChildren.DeepFirstOrDefault(x => x.Children,
                                x => x.InternalId == strImprovedSourceName);
                            if (objReturnGear != null)
                            {
                                string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                                if (objReturnGear.Parent is Gear parent)
                                    strGearReturn += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ','
                                                     + strSpace
                                                     + strSpace + parent.DisplayNameShort(strLanguage) + ')';
                                else
                                    strGearReturn += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ')';
                                if (blnWireless)
                                    strGearReturn
                                        += strSpace + LanguageManager.GetString("String_Wireless", strLanguage, token: token);
                                return strGearReturn;
                            }

                            foreach (Weapon objWeapon in objVehicle.Weapons.DeepWhere(x => x.Children,
                                         x => x.WeaponAccessories.Any(y => y.GearChildren.Count > 0)))
                            {
                                foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                                {
                                    objReturnGear = objAccessory.GearChildren.DeepFirstOrDefault(x => x.Children,
                                        x => x.InternalId == strImprovedSourceName);
                                    if (objReturnGear != null)
                                    {
                                        string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                                        if (objReturnGear.Parent is Gear parent)
                                            strGearReturn
                                                += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ','
                                                   + strSpace
                                                   + objWeapon.DisplayNameShort(strLanguage) + ',' + strSpace
                                                   + objAccessory.DisplayNameShort(strLanguage) + ','
                                                   + strSpace + parent.DisplayNameShort(strLanguage) + ')';
                                        else
                                            strGearReturn
                                                += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ','
                                                   + strSpace
                                                   + objWeapon.DisplayNameShort(strLanguage) + ',' + strSpace
                                                   + objAccessory.DisplayNameShort(strLanguage) + ')';
                                        if (blnWireless)
                                            strGearReturn += strSpace
                                                             + LanguageManager.GetString(
                                                                 "String_Wireless", strLanguage, token: token);
                                        return strGearReturn;
                                    }
                                }
                            }

                            foreach (VehicleMod objVehicleMod in objVehicle.Mods)
                            {
                                foreach (Weapon objWeapon in objVehicleMod.Weapons.DeepWhere(x => x.Children,
                                             x => x.WeaponAccessories.Any(y => y.GearChildren.Count > 0)))
                                {
                                    foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                                    {
                                        objReturnGear = objAccessory.GearChildren.DeepFirstOrDefault(x => x.Children,
                                            x => x.InternalId == strImprovedSourceName);
                                        if (objReturnGear != null)
                                        {
                                            string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                                            if (objReturnGear.Parent is Gear parent)
                                                strGearReturn
                                                    += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ','
                                                       + strSpace + objVehicleMod.DisplayNameShort(strLanguage)
                                                       + ',' + strSpace + objWeapon.DisplayNameShort(strLanguage) + ','
                                                       + strSpace + objAccessory.DisplayNameShort(strLanguage)
                                                       + ',' + strSpace + parent.DisplayNameShort(strLanguage) + ')';
                                            else
                                                strGearReturn
                                                    += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ','
                                                       + strSpace + objVehicleMod.DisplayNameShort(strLanguage)
                                                       + ',' + strSpace + objWeapon.DisplayNameShort(strLanguage) + ','
                                                       + strSpace + objAccessory.DisplayNameShort(strLanguage) + ')';
                                            if (blnWireless)
                                                strGearReturn += strSpace
                                                                 + LanguageManager.GetString(
                                                                     "String_Wireless", strLanguage, token: token);
                                            return strGearReturn;
                                        }
                                    }
                                }

                                foreach (Cyberware objCyberware in objVehicleMod.Cyberware.DeepWhere(x => x.Children,
                                             x => x.GearChildren.Count > 0))
                                {
                                    objReturnGear = objCyberware.GearChildren.DeepFirstOrDefault(x => x.Children,
                                        x => x.InternalId == strImprovedSourceName);
                                    if (objReturnGear != null)
                                    {
                                        string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                                        if (objReturnGear.Parent is Gear parent)
                                            strGearReturn
                                                += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ','
                                                   + strSpace + objVehicleMod.DisplayNameShort(strLanguage)
                                                   + ',' + strSpace + objCyberware.DisplayNameShort(strLanguage) + ','
                                                   + strSpace + parent.DisplayNameShort(strLanguage) + ')';
                                        else
                                            strGearReturn
                                                += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ','
                                                   + strSpace + objVehicleMod.DisplayNameShort(strLanguage)
                                                   + ',' + strSpace + objCyberware.DisplayNameShort(strLanguage) + ')';
                                        if (blnWireless)
                                            strGearReturn += strSpace
                                                             + LanguageManager.GetString(
                                                                 "String_Wireless", strLanguage, token: token);
                                        return strGearReturn;
                                    }
                                }
                            }

                            foreach (WeaponMount objMount in objVehicle.WeaponMounts)
                            {
                                foreach (VehicleMod objVehicleMod in objMount.Mods)
                                {
                                    foreach (Weapon objWeapon in objVehicleMod.Weapons.DeepWhere(x => x.Children,
                                                 x => x.WeaponAccessories.Any(y => y.GearChildren.Count > 0)))
                                    {
                                        foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                                        {
                                            objReturnGear = objAccessory.GearChildren.DeepFirstOrDefault(
                                                x => x.Children,
                                                x => x.InternalId == strImprovedSourceName);
                                            if (objReturnGear != null)
                                            {
                                                string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                                                if (objReturnGear.Parent is Gear parent)
                                                    strGearReturn
                                                        += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage)
                                                           + ','
                                                           + strSpace + objMount.DisplayNameShort(strLanguage) + ','
                                                           + strSpace + objVehicleMod.DisplayNameShort(strLanguage)
                                                           + ',' + strSpace + objWeapon.DisplayNameShort(strLanguage)
                                                           + ','
                                                           + strSpace + objAccessory.DisplayNameShort(strLanguage)
                                                           + ',' + strSpace + parent.DisplayNameShort(strLanguage)
                                                           + ')';
                                                else
                                                    strGearReturn
                                                        += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage)
                                                           + ','
                                                           + strSpace + objMount.DisplayNameShort(strLanguage) + ','
                                                           + strSpace + objVehicleMod.DisplayNameShort(strLanguage)
                                                           + ',' + strSpace + objWeapon.DisplayNameShort(strLanguage)
                                                           + ','
                                                           + strSpace + objAccessory.DisplayNameShort(strLanguage)
                                                           + ')';
                                                if (blnWireless)
                                                    strGearReturn += strSpace
                                                                     + LanguageManager.GetString(
                                                                         "String_Wireless", strLanguage, token: token);
                                                return strGearReturn;
                                            }
                                        }
                                    }

                                    foreach (Cyberware objCyberware in objVehicleMod.Cyberware.DeepWhere(
                                                 x => x.Children,
                                                 x => x.GearChildren.Count > 0))
                                    {
                                        objReturnGear = objCyberware.GearChildren.DeepFirstOrDefault(x => x.Children,
                                            x => x.InternalId == strImprovedSourceName);
                                        if (objReturnGear != null)
                                        {
                                            string strGearReturn = objReturnGear.DisplayNameShort(strLanguage);
                                            if (objReturnGear.Parent is Gear parent)
                                                strGearReturn
                                                    += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ','
                                                       + strSpace + objMount.DisplayNameShort(strLanguage) + ','
                                                       + strSpace
                                                       + objVehicleMod.DisplayNameShort(strLanguage)
                                                       + ',' + strSpace + objCyberware.DisplayNameShort(strLanguage)
                                                       + ','
                                                       + strSpace + parent.DisplayNameShort(strLanguage) + ')';
                                            else
                                                strGearReturn
                                                    += strSpace + '(' + objVehicle.DisplayNameShort(strLanguage) + ','
                                                       + strSpace + objMount.DisplayNameShort(strLanguage) + ','
                                                       + strSpace
                                                       + objVehicleMod.DisplayNameShort(strLanguage)
                                                       + ',' + strSpace + objCyberware.DisplayNameShort(strLanguage)
                                                       + ')';
                                            if (blnWireless)
                                                strGearReturn += strSpace
                                                                 + LanguageManager.GetString(
                                                                     "String_Wireless", strLanguage, token: token);
                                            return strGearReturn;
                                        }
                                    }
                                }
                            }
                        }

                        break;
                    }
                    case Improvement.ImprovementSource.Spell:
                        foreach (Spell objSpell in Spells)
                        {
                            if (objSpell.InternalId == strImprovedSourceName)
                            {
                                return objSpell.DisplayNameShort(strLanguage);
                            }
                        }

                        break;
                    case Improvement.ImprovementSource.Power:
                        foreach (Power objPower in Powers)
                        {
                            if (objPower.InternalId == strImprovedSourceName)
                            {
                                return objPower.DisplayNameShort(strLanguage);
                            }
                        }

                        break;
                    case Improvement.ImprovementSource.CritterPower:
                        foreach (CritterPower objPower in CritterPowers)
                        {
                            if (objPower.InternalId == strImprovedSourceName)
                            {
                                return objPower.DisplayNameShort(strLanguage);
                            }
                        }

                        break;
                    case Improvement.ImprovementSource.Metamagic:
                        foreach (Metamagic objMetamagic in Metamagics)
                        {
                            if (objMetamagic.InternalId == strImprovedSourceName
                                && objMetamagic.SourceType == Improvement.ImprovementSource.Metamagic)
                            {
                                return objMetamagic.DisplayNameShort(strLanguage);
                            }
                        }

                        break;
                    case Improvement.ImprovementSource.Echo:
                        foreach (Metamagic objMetamagic in Metamagics)
                        {
                            if (objMetamagic.InternalId == strImprovedSourceName
                                && objMetamagic.SourceType == Improvement.ImprovementSource.Echo)
                            {
                                return objMetamagic.DisplayNameShort(strLanguage);
                            }
                        }

                        break;
                    case Improvement.ImprovementSource.Art:
                        foreach (Art objArt in Arts)
                        {
                            if (objArt.InternalId == strImprovedSourceName)
                            {
                                return objArt.DisplayNameShort(strLanguage);
                            }
                        }

                        break;
                    case Improvement.ImprovementSource.Enhancement:
                        foreach (Enhancement objEnhancement in Enhancements)
                        {
                            if (objEnhancement.InternalId == strImprovedSourceName)
                            {
                                return objEnhancement.DisplayNameShort(strLanguage);
                            }
                        }

                        break;
                    case Improvement.ImprovementSource.Armor:
                    {
                        foreach (Armor objArmor in Armor)
                        {
                            if (objArmor.InternalId == strImprovedSourceName)
                            {
                                string strReturnArmor = objArmor.DisplayNameShort(strLanguage);
                                if (blnWireless)
                                    strReturnArmor
                                        += strSpace + LanguageManager.GetString("String_Wireless", strLanguage, token: token);
                                return strReturnArmor;
                            }
                        }

                        break;
                    }
                    case Improvement.ImprovementSource.ArmorMod:
                    {
                        foreach (Armor objArmor in Armor)
                        {
                            foreach (ArmorMod objMod in objArmor.ArmorMods)
                            {
                                if (objMod.InternalId == strImprovedSourceName)
                                {
                                    string strReturnArmorMod = objMod.DisplayNameShort(strLanguage) + strSpace + '('
                                                               + objArmor.DisplayNameShort(strLanguage) + ')';
                                    if (blnWireless)
                                        strReturnArmorMod
                                            += strSpace + LanguageManager.GetString("String_Wireless", strLanguage, token: token);
                                    return strReturnArmorMod;
                                }
                            }
                        }

                        break;
                    }
                    case Improvement.ImprovementSource.ComplexForm:
                        foreach (ComplexForm objComplexForm in ComplexForms)
                        {
                            if (objComplexForm.InternalId == strImprovedSourceName)
                            {
                                return objComplexForm.DisplayNameShort(strLanguage);
                            }
                        }

                        break;
                    case Improvement.ImprovementSource.AIProgram:
                        foreach (AIProgram objProgram in AIPrograms)
                        {
                            if (objProgram.InternalId == strImprovedSourceName)
                            {
                                return objProgram.DisplayNameShort(strLanguage);
                            }
                        }

                        break;
                    case Improvement.ImprovementSource.Quality:
                        if (strImprovedSourceName.StartsWith("SEEKER", StringComparison.Ordinal))
                        {
                            if (strImprovedSourceName == "SEEKER_WIL")
                                return LoadDataXPath("qualities.xml", token: token)
                                       .SelectSingleNode(
                                           "/chummer/qualities/quality[name = \"Cyber-Singularity Seeker\"]/translate")
                                       ?.Value ?? "Cyber-Singularity Seeker";
                            return LoadDataXPath("qualities.xml", token: token)
                                   .SelectSingleNode("/chummer/qualities/quality[name = \"Redliner\"]/translate")
                                   ?.Value ?? "Redliner";
                        }

                        foreach (Quality objQuality in Qualities)
                        {
                            if (objQuality.InternalId == strImprovedSourceName)
                            {
                                return objQuality.DisplayNameShort(strLanguage);
                            }
                        }

                        break;
                    case Improvement.ImprovementSource.MartialArtTechnique:
                        foreach (MartialArtTechnique objTechnique in MartialArts.SelectMany(x => x.Techniques))
                        {
                            if (objTechnique.InternalId == strImprovedSourceName)
                            {
                                return objTechnique.DisplayName(strLanguage);
                            }
                        }

                        break;
                    case Improvement.ImprovementSource.MentorSpirit:
                        foreach (MentorSpirit objMentorSpirit in MentorSpirits)
                        {
                            if (objMentorSpirit.InternalId == strImprovedSourceName)
                            {
                                return objMentorSpirit.DisplayNameShort(strLanguage);
                            }
                        }

                        break;
                    case Improvement.ImprovementSource.Heritage:
                        return LanguageManager.GetString("String_Priority", strLanguage, token: token);
                    case Improvement.ImprovementSource.Initiation:
                        return LanguageManager.GetString("Tab_Initiation", strLanguage, token: token);
                    case Improvement.ImprovementSource.Submersion:
                        return LanguageManager.GetString("Tab_Submersion", strLanguage, token: token);
                    case Improvement.ImprovementSource.Encumbrance:
                        return LanguageManager.GetString("String_Encumbrance", strLanguage, token: token);
                    case Improvement.ImprovementSource.ArmorEncumbrance:
                        return LanguageManager.GetString("String_ArmorEncumbrance", strLanguage, token: token);
                    case Improvement.ImprovementSource.Tradition:
                        return LanguageManager.GetString("String_Tradition", strLanguage, token: token);
                    case Improvement.ImprovementSource.AstralReputation:
                        return LanguageManager.GetString("String_AstralReputation", strLanguage, token: token);
                    case Improvement.ImprovementSource.CyberadeptDaemon:
                        return LoadDataXPath("qualities.xml", strLanguage, token: token)
                               .SelectSingleNode(
                                   "/chummer/qualities/quality[name = \"Resonant Stream: Cyberadept\"]/translate")
                               ?.Value ?? "Resonant Stream: Cyberadept";
                    default:
                        if (objImprovement.ImproveType == Improvement.ImprovementType.ArmorEncumbrancePenalty)
                            return LanguageManager.GetString("String_ArmorEncumbrance", strLanguage, token: token);
                        // If this comes from a custom Improvement, use the name the player gave it instead of showing a GUID.
                        if (!string.IsNullOrEmpty(objImprovement.CustomName))
                            return objImprovement.CustomName;
                        string strReturn = strImprovedSourceName;
                        if (string.IsNullOrEmpty(strReturn) || strReturn.IsGuid())
                        {
                            string strTemp = LanguageManager.GetString("String_" + objImprovement.ImproveSource,
                                                                       strLanguage, false, token: token);
                            if (!string.IsNullOrEmpty(strTemp))
                                strReturn = strTemp;
                        }

                        return strReturn;
                }
            }

            return string.Empty;
        }

        /// <summary>
        /// Retrieve the name of the Object that created an Improvement.
        /// </summary>
        /// <param name="objImprovement">Improvement to check.</param>
        /// <param name="strLanguage">Language in which to fetch name.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public async Task<string> GetObjectNameAsync(Improvement objImprovement, string strLanguage = "", CancellationToken token = default)
        {
            if (objImprovement == null)
                return string.Empty;
            if (string.IsNullOrEmpty(strLanguage))
                strLanguage = GlobalSettings.Language;
            string strSpace = await LanguageManager.GetStringAsync("String_Space", strLanguage, token: token);
            string strImprovedSourceName = objImprovement.SourceName.TrimEndOnce("Pair");
            bool blnWireless = false;

            if (strImprovedSourceName.EndsWith("Wireless", StringComparison.Ordinal))
            {
                blnWireless = true;
                strImprovedSourceName = strImprovedSourceName.TrimEndOnce("Wireless", true);
            }

            Improvement.ImprovementSource eSource = objImprovement.ImproveSource;
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                switch (eSource)
                {
                    case Improvement.ImprovementSource.Bioware:
                    case Improvement.ImprovementSource.Cyberware:
                        {
                            Cyberware objCyberware = Cyberware.DeepFirstOrDefault(x => x.Children,
                                                                                  x => x.InternalId == strImprovedSourceName
                                                                                      && x.SourceType == eSource);
                            if (objCyberware != null)
                            {
                                string strWareReturn = await objCyberware.DisplayNameShortAsync(strLanguage, token);
                                if (objCyberware.Parent != null)
                                    strWareReturn += strSpace + '(' + await objCyberware.Parent.DisplayNameShortAsync(strLanguage, token)
                                                     + ')';
                                if (blnWireless)
                                    strWareReturn += strSpace + await LanguageManager.GetStringAsync("String_Wireless", strLanguage, token: token);
                                return strWareReturn;
                            }

                            foreach (Vehicle objVehicle in Vehicles)
                            {
                                foreach (VehicleMod objVehicleMod in objVehicle.Mods)
                                {
                                    objCyberware = objVehicleMod.Cyberware.DeepFirstOrDefault(x => x.Children,
                                        x => x.InternalId == strImprovedSourceName);
                                    if (objCyberware != null)
                                    {
                                        string strWareReturn
                                            = await objCyberware.DisplayNameShortAsync(strLanguage, token) + strSpace + '('
                                              + await objVehicle.DisplayNameShortAsync(strLanguage, token) + ','
                                              + strSpace + await objVehicleMod.DisplayNameShortAsync(strLanguage, token: token);
                                        if (objCyberware.Parent != null)
                                            strWareReturn += ',' + strSpace
                                                                 + await objCyberware.Parent.DisplayNameShortAsync(strLanguage, token);
                                        strWareReturn += ')';
                                        if (blnWireless)
                                            strWareReturn
                                                += strSpace + await LanguageManager.GetStringAsync("String_Wireless", strLanguage, token: token);
                                        return strWareReturn;
                                    }
                                }

                                foreach (WeaponMount objMount in objVehicle.WeaponMounts)
                                {
                                    foreach (VehicleMod objVehicleMod in objMount.Mods)
                                    {
                                        objCyberware = objVehicleMod.Cyberware.DeepFirstOrDefault(x => x.Children,
                                            x => x.InternalId == strImprovedSourceName);
                                        if (objCyberware != null)
                                        {
                                            string strWareReturn
                                                = await objCyberware.DisplayNameShortAsync(strLanguage, token) + strSpace + '('
                                                  + await objVehicle.DisplayNameShortAsync(strLanguage, token) + ',' + strSpace
                                                  + await objMount.DisplayNameShortAsync(strLanguage, token) + ','
                                                  + strSpace + await objVehicleMod.DisplayNameShortAsync(strLanguage, token);
                                            if (objCyberware.Parent != null)
                                                strWareReturn += ',' + strSpace
                                                                     + await objCyberware.Parent.DisplayNameShortAsync(strLanguage, token);
                                            strWareReturn += ')';
                                            if (blnWireless)
                                                strWareReturn += strSpace
                                                                 + await LanguageManager.GetStringAsync(
                                                                     "String_Wireless", strLanguage, token: token);
                                            return strWareReturn;
                                        }
                                    }
                                }
                            }

                            break;
                        }
                    case Improvement.ImprovementSource.Gear:
                        {
                            Gear objReturnGear =
                                Gear.DeepFirstOrDefault(x => x.Children, x => x.InternalId == strImprovedSourceName);
                            if (objReturnGear != null)
                            {
                                string strGearReturn = await objReturnGear.DisplayNameShortAsync(strLanguage, token: token);
                                if (objReturnGear.Parent is Gear parent)
                                    strGearReturn += strSpace + '(' + await parent.DisplayNameShortAsync(strLanguage, token: token) + ')';
                                if (blnWireless)
                                    strGearReturn += strSpace + await LanguageManager.GetStringAsync("String_Wireless", strLanguage, token: token);
                                return strGearReturn;
                            }

                            objReturnGear
                                = Weapons.FindWeaponGear(strImprovedSourceName, out WeaponAccessory objGearAccessory);

                            if (objReturnGear != null)
                            {
                                string strGearReturn = await objReturnGear.DisplayNameShortAsync(strLanguage, token: token);
                                if (objReturnGear.Parent is Gear parent)
                                    strGearReturn += strSpace + '(' + await objGearAccessory.Parent.DisplayNameShortAsync(strLanguage, token: token)
                                                     + ','
                                                     + strSpace
                                                     + await objGearAccessory.DisplayNameShortAsync(strLanguage, token: token) + ',' + strSpace
                                                     + await parent.DisplayNameShortAsync(strLanguage, token) + ')';
                                else
                                    strGearReturn += strSpace + '(' + await objGearAccessory.Parent.DisplayNameShortAsync(strLanguage, token: token)
                                                     + ','
                                                     + strSpace + await objGearAccessory.DisplayNameShortAsync(strLanguage, token: token) + ')';
                                if (blnWireless)
                                    strGearReturn
                                        += strSpace + await LanguageManager.GetStringAsync("String_Wireless", strLanguage, token: token);
                                return strGearReturn;
                            }

                            objReturnGear
                                = Armor.FindArmorGear(strImprovedSourceName, out Armor objArmor, out ArmorMod objArmorMod);
                            if (objReturnGear != null)
                            {
                                string strGearReturn = await objReturnGear.DisplayNameShortAsync(strLanguage, token);
                                if (objReturnGear.Parent is Gear objParent)
                                {
                                    strGearReturn += strSpace + '(' + await objArmor.DisplayNameShortAsync(strLanguage, token) + ','
                                                     + strSpace
                                                     + await objArmorMod.DisplayNameShortAsync(strLanguage, token) + ',' + strSpace
                                                     + await objParent.DisplayNameShortAsync(strLanguage, token) + ')';
                                }
                                else if (objArmorMod != null)
                                    strGearReturn += strSpace + '(' + await objArmor.DisplayNameShortAsync(strLanguage, token) + ','
                                                     + strSpace
                                                     + await objArmorMod.DisplayNameShortAsync(strLanguage, token) + ')';
                                else
                                    strGearReturn += strSpace + '(' + await objArmor.DisplayNameShortAsync(strLanguage, token) + ')';

                                if (blnWireless)
                                    strGearReturn += strSpace + await LanguageManager.GetStringAsync("String_Wireless", strLanguage, token: token);
                                return strGearReturn;
                            }

                            objReturnGear
                                = Cyberware.FindCyberwareGear(strImprovedSourceName, out Cyberware objGearCyberware);

                            if (objReturnGear != null)
                            {
                                string strGearReturn = await objReturnGear.DisplayNameShortAsync(strLanguage, token: token);
                                if (objReturnGear.Parent is Gear parent)
                                    strGearReturn += strSpace + '(' + await objGearCyberware.DisplayNameShortAsync(strLanguage, token: token) + ','
                                                     + strSpace
                                                     + strSpace + await parent.DisplayNameShortAsync(strLanguage, token: token) + ')';
                                else
                                    strGearReturn += strSpace + '(' + await objGearCyberware.DisplayNameShortAsync(strLanguage, token: token) + ')';
                                if (blnWireless)
                                    strGearReturn += strSpace + await LanguageManager.GetStringAsync("String_Wireless", strLanguage, token: token);
                                return strGearReturn;
                            }

                            foreach (Vehicle objVehicle in Vehicles)
                            {
                                objReturnGear = objVehicle.GearChildren.DeepFirstOrDefault(x => x.Children,
                                    x => x.InternalId == strImprovedSourceName);
                                if (objReturnGear != null)
                                {
                                    string strGearReturn = await objReturnGear.DisplayNameShortAsync(strLanguage, token: token);
                                    if (objReturnGear.Parent is Gear parent)
                                        strGearReturn += strSpace + '(' + await objVehicle.DisplayNameShortAsync(strLanguage, token: token) + ','
                                                         + strSpace
                                                         + strSpace + await parent.DisplayNameShortAsync(strLanguage, token: token) + ')';
                                    else
                                        strGearReturn += strSpace + '(' + await objVehicle.DisplayNameShortAsync(strLanguage, token: token) + ')';
                                    if (blnWireless)
                                        strGearReturn
                                            += strSpace + await LanguageManager.GetStringAsync("String_Wireless", strLanguage, token: token);
                                    return strGearReturn;
                                }

                                foreach (Weapon objWeapon in objVehicle.Weapons.DeepWhere(x => x.Children,
                                             x => x.WeaponAccessories.Any(y => y.GearChildren.Count > 0)))
                                {
                                    foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                                    {
                                        objReturnGear = objAccessory.GearChildren.DeepFirstOrDefault(x => x.Children,
                                            x => x.InternalId == strImprovedSourceName);
                                        if (objReturnGear != null)
                                        {
                                            string strGearReturn = await objReturnGear.DisplayNameShortAsync(strLanguage, token);
                                            if (objReturnGear.Parent is Gear parent)
                                                strGearReturn
                                                    += strSpace + '(' + await objVehicle.DisplayNameShortAsync(strLanguage, token) + ','
                                                       + strSpace
                                                       + await objWeapon.DisplayNameShortAsync(strLanguage, token) + ',' + strSpace
                                                       + await objAccessory.DisplayNameShortAsync(strLanguage, token) + ','
                                                       + strSpace + await parent.DisplayNameShortAsync(strLanguage, token) + ')';
                                            else
                                                strGearReturn
                                                    += strSpace + '(' + await objVehicle.DisplayNameShortAsync(strLanguage, token) + ','
                                                       + strSpace
                                                       + await objWeapon.DisplayNameShortAsync(strLanguage, token) + ',' + strSpace
                                                       + await objAccessory.DisplayNameShortAsync(strLanguage, token) + ')';
                                            if (blnWireless)
                                                strGearReturn += strSpace
                                                                 + await LanguageManager.GetStringAsync(
                                                                     "String_Wireless", strLanguage, token: token);
                                            return strGearReturn;
                                        }
                                    }
                                }

                                foreach (VehicleMod objVehicleMod in objVehicle.Mods)
                                {
                                    foreach (Weapon objWeapon in objVehicleMod.Weapons.DeepWhere(x => x.Children,
                                                 x => x.WeaponAccessories.Any(y => y.GearChildren.Count > 0)))
                                    {
                                        foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                                        {
                                            objReturnGear = objAccessory.GearChildren.DeepFirstOrDefault(x => x.Children,
                                                x => x.InternalId == strImprovedSourceName);
                                            if (objReturnGear != null)
                                            {
                                                string strGearReturn = await objReturnGear.DisplayNameShortAsync(strLanguage, token);
                                                if (objReturnGear.Parent is Gear parent)
                                                    strGearReturn
                                                        += strSpace + '(' + await objVehicle.DisplayNameShortAsync(strLanguage, token) + ','
                                                           + strSpace + await objVehicleMod.DisplayNameShortAsync(strLanguage, token)
                                                           + ',' + strSpace + await objWeapon.DisplayNameShortAsync(strLanguage, token) + ','
                                                           + strSpace + await objAccessory.DisplayNameShortAsync(strLanguage, token)
                                                           + ',' + strSpace + await parent.DisplayNameShortAsync(strLanguage, token) + ')';
                                                else
                                                    strGearReturn
                                                        += strSpace + '(' + await objVehicle.DisplayNameShortAsync(strLanguage, token) + ','
                                                           + strSpace + await objVehicleMod.DisplayNameShortAsync(strLanguage, token)
                                                           + ',' + strSpace + await objWeapon.DisplayNameShortAsync(strLanguage, token) + ','
                                                           + strSpace + await objAccessory.DisplayNameShortAsync(strLanguage, token) + ')';
                                                if (blnWireless)
                                                    strGearReturn += strSpace
                                                                     + await LanguageManager.GetStringAsync(
                                                                         "String_Wireless", strLanguage, token: token);
                                                return strGearReturn;
                                            }
                                        }
                                    }

                                    foreach (Cyberware objCyberware in objVehicleMod.Cyberware.DeepWhere(x => x.Children,
                                                 x => x.GearChildren.Count > 0))
                                    {
                                        objReturnGear = objCyberware.GearChildren.DeepFirstOrDefault(x => x.Children,
                                            x => x.InternalId == strImprovedSourceName);
                                        if (objReturnGear != null)
                                        {
                                            string strGearReturn = await objReturnGear.DisplayNameShortAsync(strLanguage, token);
                                            if (objReturnGear.Parent is Gear parent)
                                                strGearReturn
                                                    += strSpace + '(' + await objVehicle.DisplayNameShortAsync(strLanguage, token) + ','
                                                       + strSpace + await objVehicleMod.DisplayNameShortAsync(strLanguage, token)
                                                       + ',' + strSpace + await objCyberware.DisplayNameShortAsync(strLanguage, token) + ','
                                                       + strSpace + await parent.DisplayNameShortAsync(strLanguage, token) + ')';
                                            else
                                                strGearReturn
                                                    += strSpace + '(' + await objVehicle.DisplayNameShortAsync(strLanguage, token) + ','
                                                       + strSpace + await objVehicleMod.DisplayNameShortAsync(strLanguage, token)
                                                       + ',' + strSpace + await objCyberware.DisplayNameShortAsync(strLanguage, token) + ')';
                                            if (blnWireless)
                                                strGearReturn += strSpace
                                                                 + await LanguageManager.GetStringAsync(
                                                                     "String_Wireless", strLanguage, token: token);
                                            return strGearReturn;
                                        }
                                    }
                                }

                                foreach (WeaponMount objMount in objVehicle.WeaponMounts)
                                {
                                    foreach (VehicleMod objVehicleMod in objMount.Mods)
                                    {
                                        foreach (Weapon objWeapon in objVehicleMod.Weapons.DeepWhere(x => x.Children,
                                                     x => x.WeaponAccessories.Any(y => y.GearChildren.Count > 0)))
                                        {
                                            foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                                            {
                                                objReturnGear = objAccessory.GearChildren.DeepFirstOrDefault(
                                                    x => x.Children,
                                                    x => x.InternalId == strImprovedSourceName);
                                                if (objReturnGear != null)
                                                {
                                                    string strGearReturn = await objReturnGear.DisplayNameShortAsync(strLanguage, token);
                                                    if (objReturnGear.Parent is Gear parent)
                                                        strGearReturn
                                                            += strSpace + '(' + await objVehicle.DisplayNameShortAsync(strLanguage, token)
                                                               + ','
                                                               + strSpace + await objMount.DisplayNameShortAsync(strLanguage, token) + ','
                                                               + strSpace + await objVehicleMod.DisplayNameShortAsync(strLanguage, token)
                                                               + ',' + strSpace + await objWeapon.DisplayNameShortAsync(strLanguage, token)
                                                               + ','
                                                               + strSpace + await objAccessory.DisplayNameShortAsync(strLanguage, token)
                                                               + ',' + strSpace + await parent.DisplayNameShortAsync(strLanguage, token)
                                                               + ')';
                                                    else
                                                        strGearReturn
                                                            += strSpace + '(' + await objVehicle.DisplayNameShortAsync(strLanguage, token)
                                                               + ','
                                                               + strSpace + await objMount.DisplayNameShortAsync(strLanguage, token) + ','
                                                               + strSpace + await objVehicleMod.DisplayNameShortAsync(strLanguage, token)
                                                               + ',' + strSpace + await objWeapon.DisplayNameShortAsync(strLanguage, token)
                                                               + ','
                                                               + strSpace + await objAccessory.DisplayNameShortAsync(strLanguage, token)
                                                               + ')';
                                                    if (blnWireless)
                                                        strGearReturn += strSpace
                                                                         + await LanguageManager.GetStringAsync(
                                                                             "String_Wireless", strLanguage, token: token);
                                                    return strGearReturn;
                                                }
                                            }
                                        }

                                        foreach (Cyberware objCyberware in objVehicleMod.Cyberware.DeepWhere(
                                                     x => x.Children,
                                                     x => x.GearChildren.Count > 0))
                                        {
                                            objReturnGear = objCyberware.GearChildren.DeepFirstOrDefault(x => x.Children,
                                                x => x.InternalId == strImprovedSourceName);
                                            if (objReturnGear != null)
                                            {
                                                string strGearReturn = await objReturnGear.DisplayNameShortAsync(strLanguage, token);
                                                if (objReturnGear.Parent is Gear parent)
                                                    strGearReturn
                                                        += strSpace + '(' + await objVehicle.DisplayNameShortAsync(strLanguage, token) + ','
                                                           + strSpace + await objMount.DisplayNameShortAsync(strLanguage, token) + ','
                                                           + strSpace
                                                           + await objVehicleMod.DisplayNameShortAsync(strLanguage, token)
                                                           + ',' + strSpace + await objCyberware.DisplayNameShortAsync(strLanguage, token)
                                                           + ','
                                                           + strSpace + await parent.DisplayNameShortAsync(strLanguage, token) + ')';
                                                else
                                                    strGearReturn
                                                        += strSpace + '(' + await objVehicle.DisplayNameShortAsync(strLanguage, token) + ','
                                                           + strSpace + await objMount.DisplayNameShortAsync(strLanguage, token) + ','
                                                           + strSpace
                                                           + await objVehicleMod.DisplayNameShortAsync(strLanguage, token)
                                                           + ',' + strSpace + await objCyberware.DisplayNameShortAsync(strLanguage, token)
                                                           + ')';
                                                if (blnWireless)
                                                    strGearReturn += strSpace
                                                                     + await LanguageManager.GetStringAsync(
                                                                         "String_Wireless", strLanguage, token: token);
                                                return strGearReturn;
                                            }
                                        }
                                    }
                                }
                            }

                            break;
                        }
                    case Improvement.ImprovementSource.Spell:
                        foreach (Spell objSpell in Spells)
                        {
                            if (objSpell.InternalId == strImprovedSourceName)
                            {
                                return await objSpell.DisplayNameShortAsync(strLanguage, token);
                            }
                        }

                        break;
                    case Improvement.ImprovementSource.Power:
                        foreach (Power objPower in Powers)
                        {
                            if (objPower.InternalId == strImprovedSourceName)
                            {
                                return await objPower.DisplayNameShortAsync(strLanguage, token);
                            }
                        }

                        break;
                    case Improvement.ImprovementSource.CritterPower:
                        foreach (CritterPower objPower in CritterPowers)
                        {
                            if (objPower.InternalId == strImprovedSourceName)
                            {
                                return await objPower.DisplayNameShortAsync(strLanguage, token);
                            }
                        }

                        break;
                    case Improvement.ImprovementSource.Metamagic:
                        foreach (Metamagic objMetamagic in Metamagics)
                        {
                            if (objMetamagic.InternalId == strImprovedSourceName
                                && objMetamagic.SourceType == Improvement.ImprovementSource.Metamagic)
                            {
                                return await objMetamagic.DisplayNameShortAsync(strLanguage, token);
                            }
                        }

                        break;
                    case Improvement.ImprovementSource.Echo:
                        foreach (Metamagic objMetamagic in Metamagics)
                        {
                            if (objMetamagic.InternalId == strImprovedSourceName
                                && objMetamagic.SourceType == Improvement.ImprovementSource.Echo)
                            {
                                return await objMetamagic.DisplayNameShortAsync(strLanguage, token);
                            }
                        }

                        break;
                    case Improvement.ImprovementSource.Art:
                        foreach (Art objArt in Arts)
                        {
                            if (objArt.InternalId == strImprovedSourceName)
                            {
                                return await objArt.DisplayNameShortAsync(strLanguage, token);
                            }
                        }

                        break;
                    case Improvement.ImprovementSource.Enhancement:
                        foreach (Enhancement objEnhancement in Enhancements)
                        {
                            if (objEnhancement.InternalId == strImprovedSourceName)
                            {
                                return await objEnhancement.DisplayNameShortAsync(strLanguage, token);
                            }
                        }

                        break;
                    case Improvement.ImprovementSource.Armor:
                        {
                            foreach (Armor objArmor in Armor)
                            {
                                if (objArmor.InternalId == strImprovedSourceName)
                                {
                                    string strReturnArmor = await objArmor.DisplayNameShortAsync(strLanguage, token);
                                    if (blnWireless)
                                        strReturnArmor
                                            += strSpace + await LanguageManager.GetStringAsync("String_Wireless", strLanguage, token: token);
                                    return strReturnArmor;
                                }
                            }

                            break;
                        }
                    case Improvement.ImprovementSource.ArmorMod:
                        {
                            foreach (Armor objArmor in Armor)
                            {
                                foreach (ArmorMod objMod in objArmor.ArmorMods)
                                {
                                    if (objMod.InternalId == strImprovedSourceName)
                                    {
                                        string strReturnArmorMod = await objMod.DisplayNameShortAsync(strLanguage, token) + strSpace + '('
                                                                   + await objArmor.DisplayNameShortAsync(strLanguage, token) + ')';
                                        if (blnWireless)
                                            strReturnArmorMod
                                                += strSpace + await LanguageManager.GetStringAsync("String_Wireless", strLanguage, token: token);
                                        return strReturnArmorMod;
                                    }
                                }
                            }

                            break;
                        }
                    case Improvement.ImprovementSource.ComplexForm:
                        foreach (ComplexForm objComplexForm in ComplexForms)
                        {
                            if (objComplexForm.InternalId == strImprovedSourceName)
                            {
                                return await objComplexForm.DisplayNameShortAsync(strLanguage, token);
                            }
                        }

                        break;
                    case Improvement.ImprovementSource.AIProgram:
                        foreach (AIProgram objProgram in AIPrograms)
                        {
                            if (objProgram.InternalId == strImprovedSourceName)
                            {
                                return await objProgram.DisplayNameShortAsync(strLanguage, token);
                            }
                        }

                        break;
                    case Improvement.ImprovementSource.Quality:
                        if (strImprovedSourceName.StartsWith("SEEKER", StringComparison.Ordinal))
                        {
                            if (strImprovedSourceName == "SEEKER_WIL")
                                return (await LoadDataXPathAsync("qualities.xml", token: token))
                                       .SelectSingleNode(
                                           "/chummer/qualities/quality[name = \"Cyber-Singularity Seeker\"]/translate")
                                       ?.Value ?? "Cyber-Singularity Seeker";
                            return (await LoadDataXPathAsync("qualities.xml", token: token))
                                   .SelectSingleNode("/chummer/qualities/quality[name = \"Redliner\"]/translate")
                                   ?.Value ?? "Redliner";
                        }

                        foreach (Quality objQuality in Qualities)
                        {
                            if (objQuality.InternalId == strImprovedSourceName)
                            {
                                return await objQuality.DisplayNameShortAsync(strLanguage, token);
                            }
                        }

                        break;
                    case Improvement.ImprovementSource.MartialArtTechnique:
                        foreach (MartialArtTechnique objTechnique in MartialArts.SelectMany(x => x.Techniques))
                        {
                            if (objTechnique.InternalId == strImprovedSourceName)
                            {
                                return await objTechnique.DisplayNameAsync(strLanguage, token);
                            }
                        }

                        break;
                    case Improvement.ImprovementSource.MentorSpirit:
                        foreach (MentorSpirit objMentorSpirit in MentorSpirits)
                        {
                            if (objMentorSpirit.InternalId == strImprovedSourceName)
                            {
                                return await objMentorSpirit.DisplayNameShortAsync(strLanguage, token);
                            }
                        }

                        break;
                    case Improvement.ImprovementSource.Heritage:
                        return await LanguageManager.GetStringAsync("String_Priority", strLanguage, token: token);
                    case Improvement.ImprovementSource.Initiation:
                        return await LanguageManager.GetStringAsync("Tab_Initiation", strLanguage, token: token);
                    case Improvement.ImprovementSource.Submersion:
                        return await LanguageManager.GetStringAsync("Tab_Submersion", strLanguage, token: token);
                    case Improvement.ImprovementSource.Encumbrance:
                        return await LanguageManager.GetStringAsync("String_Encumbrance", strLanguage, token: token);
                    case Improvement.ImprovementSource.ArmorEncumbrance:
                        return await LanguageManager.GetStringAsync("String_ArmorEncumbrance", strLanguage, token: token);
                    case Improvement.ImprovementSource.Tradition:
                        return await LanguageManager.GetStringAsync("String_Tradition", strLanguage, token: token);
                    case Improvement.ImprovementSource.AstralReputation:
                        return await LanguageManager.GetStringAsync("String_AstralReputation", strLanguage, token: token);
                    case Improvement.ImprovementSource.CyberadeptDaemon:
                        return (await LoadDataXPathAsync("qualities.xml", strLanguage, token: token))
                               .SelectSingleNode(
                                   "/chummer/qualities/quality[name = \"Resonant Stream: Cyberadept\"]/translate")
                               ?.Value ?? "Resonant Stream: Cyberadept";
                    default:
                        if (objImprovement.ImproveType == Improvement.ImprovementType.ArmorEncumbrancePenalty)
                            return await LanguageManager.GetStringAsync("String_ArmorEncumbrance", strLanguage, token: token);
                        // If this comes from a custom Improvement, use the name the player gave it instead of showing a GUID.
                        if (!string.IsNullOrEmpty(objImprovement.CustomName))
                            return objImprovement.CustomName;
                        string strReturn = strImprovedSourceName;
                        if (string.IsNullOrEmpty(strReturn) || strReturn.IsGuid())
                        {
                            string strTemp = await LanguageManager.GetStringAsync("String_" + objImprovement.ImproveSource,
                                strLanguage, false, token: token);
                            if (!string.IsNullOrEmpty(strTemp))
                                strReturn = strTemp;
                        }

                        return strReturn;
                }
            }

            return string.Empty;
        }

        public void CleanUpOrphanedImprovements(CancellationToken token = default)
        {
            using (LockObject.EnterWriteLock(token))
            {
                int intNewImprovementCount = 0;
                int intOldImprovementCount = Improvements.Count;
                // Loop this until we remove every single orphaned improvement (necessary because orphaned improvements can add other improvements)
                while (intOldImprovementCount != intNewImprovementCount)
                {
                    intOldImprovementCount = Improvements.Count;
                    // Relying on (a lack of) GetObjectName is slower than ideal, but much easier to maintain
                    Improvements.RemoveAll(x => string.IsNullOrEmpty(GetObjectName(x, GlobalSettings.DefaultLanguage, token)));
                    intNewImprovementCount = Improvements.Count;
                }
            }
        }

        public async ValueTask CleanUpOrphanedImprovementsAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token);
            try
            {
                int intNewImprovementCount = 0;
                int intOldImprovementCount = await Improvements.GetCountAsync(token);
                // Loop this until we remove every single orphaned improvement (necessary because orphaned improvements can add other improvements)
                while (intOldImprovementCount != intNewImprovementCount)
                {
                    intOldImprovementCount = await Improvements.GetCountAsync(token);
                    // Relying on (a lack of) GetObjectName is slower than ideal, but much easier to maintain
                    await Improvements.RemoveAllAsync(
                        x => string.IsNullOrEmpty(GetObjectName(x, GlobalSettings.DefaultLanguage, token)), token);
                    intNewImprovementCount = await Improvements.GetCountAsync(token);
                }
            }
            finally
            {
                await objLocker.DisposeAsync();
            }
        }

        public void FormatImprovementModifiers(StringBuilder sbdToolTip, IEnumerable<Improvement.ImprovementType> improvements, string strSpace, int intModifiers, CancellationToken token = default)
        {
            if (sbdToolTip == null)
                return;
            sbdToolTip.Append(strSpace).Append('+').Append(strSpace).Append(LanguageManager.GetString("Tip_Modifiers", token: token));
            bool blnFirstModifier = true;
            using (EnterReadLock.Enter(LockObject, token))
            {
                foreach (Improvement.ImprovementType eType in improvements)
                {
                    foreach (Improvement objLoopImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                 this, eType, token: token))
                    {
                        if (blnFirstModifier)
                        {
                            blnFirstModifier = false;
                            sbdToolTip.Append(LanguageManager.GetString("String_Colon", token: token));
                        }
                        else
                            sbdToolTip.Append(',');

                        sbdToolTip.Append(strSpace).Append(GetObjectName(objLoopImprovement, token: token));
                    }
                }
            }

            sbdToolTip.Append(strSpace).Append('(').Append(intModifiers.ToString(GlobalSettings.CultureInfo)).Append(')');
        }

        /// <summary>
        /// Return an enumerable of CyberwareGrades from XML files.
        /// </summary>
        /// <param name="objSource">Source to load the Grades from, either Bioware or Cyberware.</param>
        /// <param name="blnIgnoreBannedGrades">Whether to ignore grades banned at chargen.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public IEnumerable<Grade> GetGrades(Improvement.ImprovementSource objSource, bool blnIgnoreBannedGrades = false, CancellationToken token = default)
        {
            using (EnterReadLock.Enter(LockObject, token))
            {
                string strXPath;
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdFilter))
                {
                    if (Settings != null)
                    {
                        sbdFilter.Append('(').Append(Settings.BookXPath()).Append(") and ");
                        if (!IgnoreRules && !Created && !blnIgnoreBannedGrades)
                        {
                            foreach (string strBannedGrade in Settings.BannedWareGrades)
                            {
                                sbdFilter.Append("not(contains(name, ").Append(strBannedGrade.CleanXPath())
                                         .Append(")) and ");
                            }
                        }
                    }

                    if (sbdFilter.Length != 0)
                    {
                        sbdFilter.Length -= 5;
                        strXPath = "/chummer/grades/grade[(" + sbdFilter + ")]";
                    }
                    else
                        strXPath = "/chummer/grades/grade";
                }

                using (XmlNodeList xmlGradeList = LoadData(Grade.GetDataFileNameFromImprovementSource(objSource), token: token)
                           .SelectNodes(strXPath))
                {
                    if (xmlGradeList?.Count > 0)
                    {
                        foreach (XmlNode objNode in xmlGradeList)
                        {
                            Grade objGrade = new Grade(this, objSource);
                            objGrade.Load(objNode);
                            yield return objGrade;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Return a list of CyberwareGrades from XML files.
        /// </summary>
        /// <param name="objSource">Source to load the Grades from, either Bioware or Cyberware.</param>
        /// <param name="blnIgnoreBannedGrades">Whether to ignore grades banned at chargen.</param>
        public List<Grade> GetGradesList(Improvement.ImprovementSource objSource, bool blnIgnoreBannedGrades = false)
        {
            return GetGrades(objSource, blnIgnoreBannedGrades).ToList();
        }

        /// <summary>
        /// Return a list of CyberwareGrades from XML files.
        /// </summary>
        /// <param name="objSource">Source to load the Grades from, either Bioware or Cyberware.</param>
        /// <param name="blnIgnoreBannedGrades">Whether to ignore grades banned at chargen.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public async Task<List<Grade>> GetGradesListAsync(Improvement.ImprovementSource objSource, bool blnIgnoreBannedGrades = false, CancellationToken token = default)
        {
            List<Grade> lstReturn;
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                string strXPath;
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdFilter))
                {
                    if (Settings != null)
                    {
                        sbdFilter.Append('(').Append(await (await GetSettingsAsync(token)).BookXPathAsync(token: token)).Append(") and ");
                        if (!IgnoreRules && !Created && !blnIgnoreBannedGrades)
                        {
                            foreach (string strBannedGrade in (await GetSettingsAsync(token)).BannedWareGrades)
                            {
                                sbdFilter.Append("not(contains(name, ").Append(strBannedGrade.CleanXPath())
                                         .Append(")) and ");
                            }
                        }
                    }

                    if (sbdFilter.Length != 0)
                    {
                        sbdFilter.Length -= 5;
                        strXPath = "/chummer/grades/grade[(" + sbdFilter + ")]";
                    }
                    else
                        strXPath = "/chummer/grades/grade";
                }

                using (XmlNodeList xmlGradeList = (await LoadDataAsync(Grade.GetDataFileNameFromImprovementSource(objSource), token: token))
                           .SelectNodes(strXPath))
                {
                    lstReturn = new List<Grade>(xmlGradeList?.Count ?? 0);
                    if (xmlGradeList?.Count > 0)
                    {
                        foreach (XmlNode objNode in xmlGradeList)
                        {
                            Grade objGrade = new Grade(this, objSource);
                            objGrade.Load(objNode);
                            lstReturn.Add(objGrade);
                        }
                    }
                }
            }

            return lstReturn;
        }

        /// <summary>
        /// Calculate the number of Free Spirit Power Points used.
        /// </summary>
        public async ValueTask<string> CalculateFreeSpiritPowerPointsAsync(CancellationToken token = default)
        {
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);

            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (await GetMetatypeAsync(token).ConfigureAwait(false) == "Free Spirit" && !await GetIsCritterAsync(token).ConfigureAwait(false))
                {
                    // PC Free Spirit.
                    decimal decPowerPoints = await (await GetCritterPowersAsync(token).ConfigureAwait(false))
                                                   .SumAsync(x => x.CountTowardsLimit, x => x.PowerPoints, token: token)
                                                   .ConfigureAwait(false);

                    int intPowerPoints = await (await GetAttributeAsync("EDG", token: token).ConfigureAwait(false))
                                               .GetTotalValueAsync(token).ConfigureAwait(false)
                                         + (await ImprovementManager
                                                  .ValueOfAsync(this, Improvement.ImprovementType.FreeSpiritPowerPoints,
                                                                token: token).ConfigureAwait(false)).StandardRound();

                    // If the house rule to base Power Points on the character's MAG value instead, use the character's MAG.
                    if (await (await GetSettingsAsync(token).ConfigureAwait(false)).GetFreeSpiritPowerPointsMAGAsync(token).ConfigureAwait(false))
                        intPowerPoints = await (await GetAttributeAsync("MAG", token: token).ConfigureAwait(false))
                                               .GetTotalValueAsync(token).ConfigureAwait(false)
                                         + (await ImprovementManager
                                                  .ValueOfAsync(this, Improvement.ImprovementType.FreeSpiritPowerPoints,
                                                                token: token).ConfigureAwait(false)).StandardRound();

                    return intPowerPoints.ToString(GlobalSettings.CultureInfo) + strSpace + '('
                           + (intPowerPoints - decPowerPoints).ToString(GlobalSettings.CultureInfo) + strSpace
                           + await LanguageManager.GetStringAsync("String_Remaining", token: token).ConfigureAwait(false) + ')';
                }
                else
                {
                    int intPowerPoints;

                    switch (await GetMetatypeAsync(token).ConfigureAwait(false))
                    {
                        case "Free Spirit":
                            // Critter Free Spirits have a number of Power Points equal to their EDG plus any Free Spirit Power Points Improvements.
                            intPowerPoints = await (await GetAttributeAsync("EDG", token: token).ConfigureAwait(false))
                                                   .GetTotalValueAsync(token).ConfigureAwait(false)
                                             + (await ImprovementManager
                                                      .ValueOfAsync(
                                                          this, Improvement.ImprovementType.FreeSpiritPowerPoints,
                                                          token: token).ConfigureAwait(false)).StandardRound();
                            break;
                        case "Ally Spirit":
                            // Ally Spirits get a number of Power Points equal to their MAG.
                            intPowerPoints = await (await GetAttributeAsync("MAG", token: token).ConfigureAwait(false))
                                                   .GetTotalValueAsync(token).ConfigureAwait(false);
                            break;
                        default:
                            // Spirits get 1 Power Point for every 3 full points of Force (MAG) they possess.
                            intPowerPoints = await (await GetAttributeAsync("MAG", token: token).ConfigureAwait(false))
                                                   .GetTotalValueAsync(token).ConfigureAwait(false) / 3;
                            break;
                    }

                    decimal decUsed = await (await GetCritterPowersAsync(token).ConfigureAwait(false))
                                            .SumAsync(x => x.Category != "Weakness" && x.CountTowardsLimit,
                                                      x => x.PowerPoints, token: token).ConfigureAwait(false);

                    return intPowerPoints.ToString(GlobalSettings.CultureInfo) + strSpace + '('
                           + (intPowerPoints - decUsed).ToString(GlobalSettings.CultureInfo) + strSpace
                           + await LanguageManager.GetStringAsync("String_Remaining", token: token) + ')';
                }
            }
        }

        /// <summary>
        /// Calculate the number of Free Sprite Power Points used.
        /// </summary>
        public async ValueTask<string> CalculateFreeSpritePowerPointsAsync(CancellationToken token = default)
        {
            // Free Sprite Power Points.
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                decimal decUsedPowerPoints = await (await GetCritterPowersAsync(token).ConfigureAwait(false))
                                                   .SumAsync(x => x.CountTowardsLimit, x => x.PowerPoints, token)
                                                   .ConfigureAwait(false);

                int intPowerPoints = await (await GetAttributeAsync("EDG", token: token).ConfigureAwait(false))
                                           .GetTotalValueAsync(token).ConfigureAwait(false)
                                     + (await ImprovementManager
                                              .ValueOfAsync(this, Improvement.ImprovementType.FreeSpiritPowerPoints,
                                                            token: token).ConfigureAwait(false)).StandardRound();

                string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);

                return intPowerPoints.ToString(GlobalSettings.CultureInfo) + strSpace + '('
                       + (intPowerPoints - decUsedPowerPoints).ToString(GlobalSettings.CultureInfo)
                       + strSpace + await LanguageManager.GetStringAsync("String_Remaining", token: token).ConfigureAwait(false) + ')';
            }
        }

        /// <summary>
        /// Construct a list of possible places to put a piece of modular cyberware. Names are display names of the given items, values are internalIDs of the given items.
        /// </summary>
        /// <param name="objModularCyberware">Cyberware for which to construct the list.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public IEnumerable<ListItem> ConstructModularCyberlimbList([NotNull] Cyberware objModularCyberware, CancellationToken token = default)
        {
            yield return new ListItem("None", LanguageManager.GetString("String_None", token: token));

            string strSpace = LanguageManager.GetString("String_Space", token: token);

            using (EnterReadLock.Enter(LockObject, token))
            {
                foreach (Cyberware objLoopCyberware in Cyberware.GetAllDescendants(x => x.Children))
                {
                    // Make sure this has an eligible mount location and it's not the selected piece modular cyberware
                    if (objLoopCyberware.HasModularMount == objModularCyberware.PlugsIntoModularMount
                        && (objLoopCyberware.Location == objModularCyberware.Location
                            || string.IsNullOrEmpty(objModularCyberware.Location))
                        && objLoopCyberware.Grade.Name == objModularCyberware.Grade.Name
                        && objLoopCyberware != objModularCyberware
                        // Make sure it's not the place where the mount is already occupied (either by us or something else)
                        && objLoopCyberware.Children.All(
                            x => x.PlugsIntoModularMount != objLoopCyberware.HasModularMount))
                    {
                        string strName = objLoopCyberware.Parent?.CurrentDisplayName
                                         ?? objLoopCyberware.CurrentDisplayName;
                        yield return new ListItem(objLoopCyberware.InternalId, strName);
                    }
                }

                foreach (Vehicle objLoopVehicle in Vehicles)
                {
                    foreach (VehicleMod objLoopVehicleMod in objLoopVehicle.Mods)
                    {
                        foreach (Cyberware objLoopCyberware in objLoopVehicleMod.Cyberware.GetAllDescendants(
                                     x => x.Children))
                        {
                            // Make sure this has an eligible mount location and it's not the selected piece modular cyberware
                            if (objLoopCyberware.HasModularMount == objModularCyberware.PlugsIntoModularMount
                                && objLoopCyberware.Location == objModularCyberware.Location
                                && objLoopCyberware.Grade.Name == objModularCyberware.Grade.Name
                                && objLoopCyberware != objModularCyberware
                                // Make sure it's not the place where the mount is already occupied (either by us or something else)
                                && objLoopCyberware.Children.All(
                                    x => x.PlugsIntoModularMount != objLoopCyberware.HasModularMount))
                            {
                                string strName = objLoopVehicle.CurrentDisplayName
                                                 + strSpace + (objLoopCyberware.Parent?.CurrentDisplayName
                                                               ?? objLoopVehicleMod.CurrentDisplayName);
                                yield return new ListItem(objLoopCyberware.InternalId, strName);
                            }
                        }
                    }

                    foreach (WeaponMount objLoopWeaponMount in objLoopVehicle.WeaponMounts)
                    {
                        foreach (VehicleMod objLoopVehicleMod in objLoopWeaponMount.Mods)
                        {
                            foreach (Cyberware objLoopCyberware in objLoopVehicleMod.Cyberware.GetAllDescendants(
                                         x => x.Children))
                            {
                                // Make sure this has an eligible mount location and it's not the selected piece modular cyberware
                                if (objLoopCyberware.HasModularMount == objModularCyberware.PlugsIntoModularMount
                                    && objLoopCyberware.Location == objModularCyberware.Location
                                    && objLoopCyberware.Grade.Name == objModularCyberware.Grade.Name
                                    && objLoopCyberware != objModularCyberware
                                    // Make sure it's not the place where the mount is already occupied (either by us or something else)
                                    && objLoopCyberware.Children.All(
                                        x => x.PlugsIntoModularMount != objLoopCyberware.HasModularMount))
                                {
                                    string strName = objLoopVehicle.CurrentDisplayName
                                                     + strSpace + (objLoopCyberware.Parent?.CurrentDisplayName
                                                                   ?? objLoopVehicleMod.CurrentDisplayName);
                                    yield return new ListItem(objLoopCyberware.InternalId, strName);
                                }
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Construct a list of possible places to put a piece of modular cyberware. Names are display names of the given items, values are internalIDs of the given items.
        /// </summary>
        /// <param name="objModularCyberware">Cyberware for which to construct the list.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public async Task<List<ListItem>> ConstructModularCyberlimbListAsync([NotNull] Cyberware objModularCyberware, CancellationToken token = default)
        {
            List<ListItem> lstReturn = new List<ListItem>
                {new ListItem("None", await LanguageManager.GetStringAsync("String_None", token: token))};

            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token);

            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                foreach (Cyberware objLoopCyberware in (await GetCyberwareAsync(token)).GetAllDescendants(x => x.Children))
                {
                    // Make sure this has an eligible mount location and it's not the selected piece modular cyberware
                    if (objLoopCyberware.HasModularMount == objModularCyberware.PlugsIntoModularMount
                        && (objLoopCyberware.Location == objModularCyberware.Location
                            || string.IsNullOrEmpty(objModularCyberware.Location))
                        && objLoopCyberware.Grade.Name == objModularCyberware.Grade.Name
                        && objLoopCyberware != objModularCyberware
                        // Make sure it's not the place where the mount is already occupied (either by us or something else)
                        && objLoopCyberware.Children.All(
                            x => x.PlugsIntoModularMount != objLoopCyberware.HasModularMount))
                    {
                        string strName = objLoopCyberware.Parent != null
                            ? await objLoopCyberware.Parent.GetCurrentDisplayNameAsync(token)
                            : await objLoopCyberware.GetCurrentDisplayNameAsync(token);
                        lstReturn.Add(new ListItem(objLoopCyberware.InternalId, strName));
                    }
                }

                foreach (Vehicle objLoopVehicle in await GetVehiclesAsync(token))
                {
                    foreach (VehicleMod objLoopVehicleMod in objLoopVehicle.Mods)
                    {
                        foreach (Cyberware objLoopCyberware in objLoopVehicleMod.Cyberware.GetAllDescendants(
                                     x => x.Children))
                        {
                            // Make sure this has an eligible mount location and it's not the selected piece modular cyberware
                            if (objLoopCyberware.HasModularMount == objModularCyberware.PlugsIntoModularMount
                                && objLoopCyberware.Location == objModularCyberware.Location
                                && objLoopCyberware.Grade.Name == objModularCyberware.Grade.Name
                                && objLoopCyberware != objModularCyberware
                                // Make sure it's not the place where the mount is already occupied (either by us or something else)
                                && objLoopCyberware.Children.All(
                                    x => x.PlugsIntoModularMount != objLoopCyberware.HasModularMount))
                            {
                                string strName = await objLoopVehicle.GetCurrentDisplayNameAsync(token)
                                                 + strSpace + (objLoopCyberware.Parent != null
                                                     ? await objLoopCyberware.Parent.GetCurrentDisplayNameAsync(token)
                                                     : await objLoopVehicleMod.GetCurrentDisplayNameAsync(token));
                                lstReturn.Add(new ListItem(objLoopCyberware.InternalId, strName));
                            }
                        }
                    }

                    foreach (WeaponMount objLoopWeaponMount in objLoopVehicle.WeaponMounts)
                    {
                        foreach (VehicleMod objLoopVehicleMod in objLoopWeaponMount.Mods)
                        {
                            foreach (Cyberware objLoopCyberware in objLoopVehicleMod.Cyberware.GetAllDescendants(
                                         x => x.Children))
                            {
                                // Make sure this has an eligible mount location and it's not the selected piece modular cyberware
                                if (objLoopCyberware.HasModularMount == objModularCyberware.PlugsIntoModularMount
                                    && objLoopCyberware.Location == objModularCyberware.Location
                                    && objLoopCyberware.Grade.Name == objModularCyberware.Grade.Name
                                    && objLoopCyberware != objModularCyberware
                                    // Make sure it's not the place where the mount is already occupied (either by us or something else)
                                    && objLoopCyberware.Children.All(
                                        x => x.PlugsIntoModularMount != objLoopCyberware.HasModularMount))
                                {
                                    string strName = await objLoopVehicle.GetCurrentDisplayNameAsync(token)
                                                     + strSpace + (objLoopCyberware.Parent != null
                                                         ? await objLoopCyberware.Parent.GetCurrentDisplayNameAsync(token)
                                                         : await objLoopVehicleMod.GetCurrentDisplayNameAsync(token));
                                    lstReturn.Add(new ListItem(objLoopCyberware.InternalId, strName));
                                }
                            }
                        }
                    }
                }
            }

            return lstReturn;
        }

        public async Task<bool> SwitchBuildMethods(CharacterBuildMethod eOldBuildMethod, CharacterBuildMethod eNewBuildMethod, string strOldSettingsKey, CancellationToken token = default)
        {
            DialogResult eResult;
            if (eNewBuildMethod.UsesPriorityTables())
            {
                using (ThreadSafeForm<SelectMetatypePriority> frmSelectMetatype = await ThreadSafeForm<SelectMetatypePriority>.GetAsync(() => new SelectMetatypePriority(this), token))
                {
                    eResult = await frmSelectMetatype.ShowDialogSafeAsync(this, token);
                }
            }
            else
            {
                using (ThreadSafeForm<SelectMetatypeKarma> frmSelectMetatype = await ThreadSafeForm<SelectMetatypeKarma>.GetAsync(() => new SelectMetatypeKarma(this), token))
                {
                    eResult = await frmSelectMetatype.ShowDialogSafeAsync(this, token);
                }
            }

            IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token);
            try
            {
                if (eResult != DialogResult.OK)
                {
                    await SetSettingsKeyAsync(strOldSettingsKey, token);
                    return false;
                }

                if (eOldBuildMethod == CharacterBuildMethod.LifeModule)
                {
                    ThreadSafeObservableCollection<Quality> lstQualities = await GetQualitiesAsync(token);
                    for (int i = await lstQualities.GetCountAsync(token) - 1; i >= 0; --i)
                    {
                        if (i >= await lstQualities.GetCountAsync(token))
                            continue;
                        Quality objQuality = await lstQualities.GetValueAtAsync(i, token);
                        if (objQuality.OriginSource == QualitySource.LifeModule)
                            objQuality.DeleteQuality();
                    }
                }
            }
            finally
            {
                await objLocker.DisposeAsync();
            }

            return true;
        }

        public async Task<Tuple<string, int>> CalculateKarmaValue(string strLanguage, CultureInfo objCulture, CancellationToken token = default)
        {
            string strColonCharacter = await LanguageManager.GetStringAsync("String_Colon", strLanguage, token: token).ConfigureAwait(false);
            string strSpace = await LanguageManager.GetStringAsync("String_Space", strLanguage, token: token).ConfigureAwait(false);
            string strKarmaString = await LanguageManager.GetStringAsync("String_Karma", strLanguage, token: token).ConfigureAwait(false);
            int intExtraKarmaToRemoveForPointBuyComparison = 0;
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                CharacterSettings objSettings = await GetSettingsAsync(token).ConfigureAwait(false);
                int intReturn = await objSettings.GetBuildKarmaAsync(token).ConfigureAwait(false);

                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdMessage))
                {
                    sbdMessage.AppendLine(await LanguageManager.GetStringAsync("Message_KarmaValue", strLanguage, token: token).ConfigureAwait(false)).AppendLine()
                              .Append(await LanguageManager.GetStringAsync("Label_Base", strLanguage, token: token).ConfigureAwait(false))
                              .Append(strColonCharacter).Append(strSpace)
                              .Append(intReturn.ToString(objCulture))
                              .Append(strSpace).Append(strKarmaString);

                    if (await GetEffectiveBuildMethodUsesPriorityTablesAsync(token).ConfigureAwait(false))
                    {
                        // Zeroed to -10 because that's Human's value at default settings
                        int intMetatypeQualitiesValue = -2 * objSettings.KarmaAttribute;
                        // Karma value of all qualities (we're ignoring metatype cost because Point Buy karma costs don't line up with other methods' values)
                        await (await GetQualitiesAsync(token).ConfigureAwait(false)).ForEachAsync(async objQuality =>
                        {
                            if (objQuality.OriginSource == QualitySource.Metatype
                                || objQuality.OriginSource == QualitySource.MetatypeRemovable)
                            {
                                XPathNavigator xmlQualityNode = await objQuality.GetNodeXPathAsync(token: token).ConfigureAwait(false);
                                if (xmlQualityNode == null)
                                    return;
                                int intLoopKarma = 0;
                                if (xmlQualityNode.TryGetInt32FieldQuickly("karma", ref intLoopKarma))
                                    intMetatypeQualitiesValue += intLoopKarma;
                            }
                        }, token).ConfigureAwait(false);

                        intReturn += intMetatypeQualitiesValue;

                        // Subtract extra karma cost of a metatype in priority
                        int intTemp = -await GetMetatypeBPAsync(token).ConfigureAwait(false);
                        int intAttributesValue = 0;
                        // Value from attribute points and raised attribute minimums
                        foreach (CharacterAttrib objLoopAttrib in AttributeSection.AttributeList.Concat(AttributeSection
                                     .SpecialAttributeList))
                        {
                            string strAttributeName = objLoopAttrib.Abbrev;
                            if (strAttributeName != "ESS" &&
                                (strAttributeName != "MAGAdept"
                                 || (await GetIsMysticAdeptAsync(token).ConfigureAwait(false) && await objSettings.GetMysAdeptSecondMAGAttributeAsync(token).ConfigureAwait(false)))
                                &&
                                await objLoopAttrib.GetMetatypeMaximumAsync(token).ConfigureAwait(false) > 0)
                            {
                                int intLoopAttribValue =
                                    Math.Max(objLoopAttrib.Base + await objLoopAttrib.GetFreeBaseAsync(token).ConfigureAwait(false) + await objLoopAttrib.GetRawMinimumAsync(token).ConfigureAwait(false),
                                             await objLoopAttrib.GetTotalMinimumAsync(token).ConfigureAwait(false)) + await objLoopAttrib.GetAttributeValueModifiersAsync(token).ConfigureAwait(false);
                                if (intLoopAttribValue > 1)
                                {
                                    intTemp += ((intLoopAttribValue + 1) * intLoopAttribValue / 2 - 1)
                                               * await objSettings.GetKarmaAttributeAsync(token).ConfigureAwait(false);
                                    if (strAttributeName != "MAG" && strAttributeName != "MAGAdept" &&
                                        strAttributeName != "RES" && strAttributeName != "DEP")
                                    {
                                        int intVanillaAttribValue =
                                            Math.Max(
                                                objLoopAttrib.Base + await objLoopAttrib.GetFreeBaseAsync(token).ConfigureAwait(false) + await objLoopAttrib.GetRawMinimumAsync(token).ConfigureAwait(false) -
                                                await objLoopAttrib.GetMetatypeMinimumAsync(token).ConfigureAwait(false) + 1,
                                                await objLoopAttrib.GetTotalMinimumAsync(token).ConfigureAwait(false) - await objLoopAttrib.GetMetatypeMinimumAsync(token).ConfigureAwait(false) + 1) +
                                            await objLoopAttrib.GetAttributeValueModifiersAsync(token).ConfigureAwait(false);
                                        intAttributesValue
                                            += ((intVanillaAttribValue + 1) * intVanillaAttribValue / 2 - 1) *
                                               await objSettings.GetKarmaAttributeAsync(token).ConfigureAwait(false);
                                    }
                                    else
                                        intAttributesValue += ((intLoopAttribValue + 1) * intLoopAttribValue / 2 - 1) *
                                                              await objSettings.GetKarmaAttributeAsync(token).ConfigureAwait(false);
                                }
                            }
                        }

                        // For point buy comparisons, we need to use the metatype's Point Buy cost for the comparison, not attributes + metatype qualities.
                        intExtraKarmaToRemoveForPointBuyComparison
                            += intTemp - intAttributesValue + intMetatypeQualitiesValue;

                        if (intTemp - intAttributesValue + intMetatypeQualitiesValue != 0)
                        {
                            sbdMessage.AppendLine()
                                      .Append(await LanguageManager.GetStringAsync("Label_SumtoTenHeritage", strLanguage, token: token).ConfigureAwait(false))
                                      .Append(strSpace)
                                      .Append((intTemp - intAttributesValue + intMetatypeQualitiesValue).ToString(
                                                  objCulture)).Append(strSpace).Append(strKarmaString);
                        }

                        if (intAttributesValue != 0)
                        {
                            sbdMessage.AppendLine()
                                      .Append(await LanguageManager.GetStringAsync("Label_SumtoTenAttributes", strLanguage, token: token).ConfigureAwait(false))
                                      .Append(strSpace).Append(intAttributesValue.ToString(objCulture))
                                      .Append(strSpace).Append(strKarmaString);
                        }

                        intReturn += intTemp;

                        // Karma needs to be added based on the character's metatype/metavariant Point Buy karma cost because that is what is used in Point Buy,
                        // not the metatype/metavariant attribute/quality costs.
                        intTemp = 0;
                        if ((await this.GetNodeXPathAsync(token: token).ConfigureAwait(false))?.TryGetInt32FieldQuickly("karma", ref intTemp) == true)
                            intExtraKarmaToRemoveForPointBuyComparison -= intTemp;

                        intTemp = 0;
                        // This is where "Talent" qualities like Adept and Technomancer get added in
                        await (await GetQualitiesAsync(token).ConfigureAwait(false)).ForEachAsync(async objQuality =>
                        {
                            if (objQuality.OriginSource == QualitySource.Heritage)
                            {
                                XPathNavigator xmlQualityNode = await objQuality.GetNodeXPathAsync(token: token).ConfigureAwait(false);
                                if (xmlQualityNode == null)
                                    return;
                                int intLoopKarma = 0;
                                if (xmlQualityNode.TryGetInt32FieldQuickly("karma", ref intLoopKarma))
                                    intTemp += intLoopKarma;
                            }
                        }, token).ConfigureAwait(false);

                        if (intTemp != 0)
                        {
                            sbdMessage.AppendLine().Append(await LanguageManager.GetStringAsync("String_Qualities", strLanguage, token: token).ConfigureAwait(false))
                                      .Append(strColonCharacter).Append(strSpace)
                                      .Append(intTemp.ToString(objCulture)).Append(strSpace)
                                      .Append(strKarmaString);
                            intReturn += intTemp;
                        }

                        // Value from free spells
                        intTemp = await GetFreeSpellsAsync(token).ConfigureAwait(false) * await SpellKarmaCostAsync("Spells", token).ConfigureAwait(false);
                        if (intTemp != 0)
                        {
                            sbdMessage.AppendLine().Append(await LanguageManager.GetStringAsync("String_FreeSpells", strLanguage, token: token).ConfigureAwait(false))
                                      .Append(strColonCharacter).Append(strSpace)
                                      .Append(intTemp.ToString(objCulture)).Append(strSpace)
                                      .Append(strKarmaString);
                            intReturn += intTemp;
                        }

                        // Value from free complex forms
                        intTemp = await GetCFPLimitAsync(token).ConfigureAwait(false) * await GetComplexFormKarmaCostAsync(token).ConfigureAwait(false);
                        if (intTemp != 0)
                        {
                            sbdMessage.AppendLine().Append(await LanguageManager.GetStringAsync("String_FreeCFs", strLanguage, token: token).ConfigureAwait(false))
                                      .Append(strColonCharacter).Append(strSpace)
                                      .Append(intTemp.ToString(objCulture)).Append(strSpace)
                                      .Append(strKarmaString);
                            intReturn += intTemp;
                        }

                        intTemp = 0;
                        // Value from skill points
                        foreach (Skill objLoopActiveSkill in SkillsSection.Skills)
                        {
                            if (!(objLoopActiveSkill.SkillGroupObject?.Base > 0))
                            {
                                int intLoopRating = await objLoopActiveSkill.GetBaseAsync(token).ConfigureAwait(false);
                                if (intLoopRating > 0)
                                {
                                    intTemp += await objSettings.GetKarmaNewActiveSkillAsync(token).ConfigureAwait(false);
                                    intTemp += ((intLoopRating + 1) * intLoopRating / 2 - 1)
                                               * await objSettings.GetKarmaImproveActiveSkillAsync(token).ConfigureAwait(false);
                                    if (await GetEffectiveBuildMethodIsLifeModuleAsync(token).ConfigureAwait(false))
                                        intTemp += await objLoopActiveSkill.Specializations.CountAsync(x => x.Free, token: token).ConfigureAwait(false) *
                                                   await objSettings.GetKarmaSpecializationAsync(token).ConfigureAwait(false);
                                    else if (!await objLoopActiveSkill.GetBuyWithKarmaAsync(token).ConfigureAwait(false))
                                        intTemp += objLoopActiveSkill.Specializations.Count
                                                   * await objSettings.GetKarmaSpecializationAsync(token).ConfigureAwait(false);
                                }
                            }
                        }

                        if (intTemp != 0)
                        {
                            sbdMessage.AppendLine().Append(await LanguageManager.GetStringAsync("String_SkillPoints", strLanguage, token: token).ConfigureAwait(false))
                                      .Append(strColonCharacter).Append(strSpace)
                                      .Append(intTemp.ToString(objCulture)).Append(strSpace)
                                      .Append(strKarmaString);
                            intReturn += intTemp;
                        }

                        intTemp = 0;
                        // Value from skill group points
                        foreach (int intLoopRating in SkillsSection.SkillGroups.Select(x => x.Base))
                        {
                            if (intLoopRating <= 0)
                                continue;
                            intTemp += await objSettings.GetKarmaNewSkillGroupAsync(token).ConfigureAwait(false);
                            intTemp += ((intLoopRating + 1) * intLoopRating / 2 - 1) * await objSettings.GetKarmaImproveSkillGroupAsync(token).ConfigureAwait(false);
                        }

                        if (intTemp != 0)
                        {
                            sbdMessage.AppendLine()
                                      .Append(await LanguageManager.GetStringAsync("String_SkillGroupPoints", strLanguage, token: token).ConfigureAwait(false))
                                      .Append(strColonCharacter).Append(strSpace)
                                      .Append(intTemp.ToString(objCulture)).Append(strSpace)
                                      .Append(strKarmaString);
                            intReturn += intTemp;
                        }

                        // Starting Nuyen karma value
                        decimal decBaseStartingNuyen
                            = await CalculateStartingNuyenFromKarmaAsync(Math.Min(await GetNuyenBPAsync(token).ConfigureAwait(false), await GetTotalNuyenMaximumBPAsync(token).ConfigureAwait(false)), await GetStartingNuyenAsync(token).ConfigureAwait(false), token).ConfigureAwait(false);
                        if (decBaseStartingNuyen != 0)
                        {
                            // Start off with the negative value of the karma we put into nuyen to make this calculation work properly for weird, nonlinear scaling
                            intTemp = -Math.Min(await GetNuyenBPAsync(token).ConfigureAwait(false), await GetTotalNuyenMaximumBPAsync(token).ConfigureAwait(false)).ToInt32();
                            // This looks horrible, but we cannot use binary search or calculate karma value directly because XPath expressions are so free-form
                            // The only option is to loop through every possible Karma value until we find the lowest one that gives more nuyen than Priority gives
                            for (int i = 0; i < int.MaxValue; ++i)
                            {
                                decimal decLoopNuyen = await CalculateStartingNuyenFromKarmaAsync(i, 0, token).ConfigureAwait(false);
                                // This looks quite wonky when what we're actually looking for is the exact value, but effectively rounds karma requirements up in cases where Nuyen doesn't divide cleanly
                                if (decLoopNuyen >= decBaseStartingNuyen)
                                {
                                    intTemp += i;
                                    break;
                                }
                            }

                            if (intTemp != 0)
                            {
                                sbdMessage.AppendLine()
                                          .Append(await LanguageManager.GetStringAsync("Checkbox_CreatePACKSKit_StartingNuyen",
                                                      strLanguage, token: token).ConfigureAwait(false)).Append(strColonCharacter)
                                          .Append(strSpace).Append(intTemp.ToString(objCulture))
                                          .Append(strSpace).Append(strKarmaString);
                                intReturn += intTemp;
                            }
                        }
                    }

                    int intContactPointsValue = await GetContactPointsAsync(token).ConfigureAwait(false) * await objSettings.GetKarmaContactAsync(token).ConfigureAwait(false);
                    if (intContactPointsValue != 0)
                    {
                        sbdMessage.AppendLine().Append(await LanguageManager.GetStringAsync("String_Contacts", strLanguage, token: token).ConfigureAwait(false))
                                  .Append(strColonCharacter).Append(strSpace)
                                  .Append(intContactPointsValue.ToString(objCulture)).Append(strSpace)
                                  .Append(strKarmaString);
                        intReturn += intContactPointsValue;
                        intExtraKarmaToRemoveForPointBuyComparison += intContactPointsValue;
                    }

                    int intKnowledgePointsValue = 0;
                    foreach (KnowledgeSkill objLoopKnowledgeSkill in SkillsSection.KnowledgeSkills)
                    {
                        int intLoopRating = await objLoopKnowledgeSkill.GetBaseAsync(token).ConfigureAwait(false);
                        if (intLoopRating > 0)
                        {
                            intKnowledgePointsValue += await objSettings.GetKarmaNewKnowledgeSkillAsync(token).ConfigureAwait(false);
                            intKnowledgePointsValue += ((intLoopRating + 1) * intLoopRating / 2 - 1) *
                                                       await objSettings.GetKarmaImproveKnowledgeSkillAsync(token).ConfigureAwait(false);
                            if (await GetEffectiveBuildMethodIsLifeModuleAsync(token).ConfigureAwait(false))
                                intKnowledgePointsValue += await objLoopKnowledgeSkill.Specializations.CountAsync(x => x.Free, token).ConfigureAwait(false) *
                                                           await objSettings.GetKarmaKnowledgeSpecializationAsync(token).ConfigureAwait(false);
                            else if (!await objLoopKnowledgeSkill.GetBuyWithKarmaAsync(token).ConfigureAwait(false))
                                intKnowledgePointsValue += objLoopKnowledgeSkill.Specializations.Count *
                                                           await objSettings.GetKarmaKnowledgeSpecializationAsync(token).ConfigureAwait(false);
                        }
                    }

                    if (intKnowledgePointsValue != 0)
                    {
                        sbdMessage.AppendLine().Append(await LanguageManager.GetStringAsync("Label_KnowledgeSkills", strLanguage, token: token).ConfigureAwait(false))
                                  .Append(strColonCharacter).Append(strSpace)
                                  .Append(intKnowledgePointsValue.ToString(objCulture)).Append(strSpace)
                                  .Append(strKarmaString);
                        intReturn += intKnowledgePointsValue;
                        intExtraKarmaToRemoveForPointBuyComparison += intKnowledgePointsValue;
                    }

                    sbdMessage.AppendLine().AppendLine().Append(await LanguageManager.GetStringAsync("String_Total", strLanguage, token: token).ConfigureAwait(false))
                              .Append(strColonCharacter).Append(strSpace)
                              .Append(intReturn.ToString(objCulture))
                              .Append(strSpace).AppendLine(strKarmaString).AppendLine()
                              .Append(await LanguageManager.GetStringAsync("String_TotalComparisonWithPointBuy", strLanguage, token: token).ConfigureAwait(false))
                              .Append(strColonCharacter).Append(strSpace)
                              .Append((intReturn - intExtraKarmaToRemoveForPointBuyComparison).ToString(
                                          objCulture)).Append(strSpace).Append(strKarmaString);

                    return new Tuple<string, int>(sbdMessage.ToString(), intReturn);
                }
            }
        }

        /// <summary>
        /// Creates a list of keywords for each category of an XML node. Used to preselect whether items of that category are discounted by the Black Market Pipeline quality.
        /// </summary>
        public IEnumerable<string> GenerateBlackMarketMappings(XPathNavigator xmlCategoryList, CancellationToken token = default)
        {
            if (xmlCategoryList == null)
                yield break;
            using (EnterReadLock.Enter(LockObject, token))
            {
                // Character has no Black Market discount qualities. Fail out early.
                if (!BlackMarketDiscount)
                    yield break;
                // if the passed list is still the root, assume we're looking for default categories. Special cases like vehicle modcategories are expected to be passed through by the parameter.
                if (xmlCategoryList.Name == "chummer")
                {
                    xmlCategoryList = xmlCategoryList.SelectSingleNodeAndCacheExpression("categories");
                    if (xmlCategoryList == null)
                        yield break;
                }

                // Get all the improved names of the Black Market Pipeline improvements. In most cases this should only be 1 item, but supports custom content.
                using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                out HashSet<string> setNames))
                {
                    foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                 this, Improvement.ImprovementType.BlackMarketDiscount, token: token))
                    {
                        setNames.Add(objImprovement.ImprovedName);
                    }

                    // For each category node, split the comma-separated blackmarket attribute (if present on the node), then add each category where any of those items matches a Black Market Pipeline improvement.
                    foreach (XPathNavigator xmlCategoryNode in xmlCategoryList.SelectAndCacheExpression("category"))
                    {
                        string strBlackMarketAttribute
                            = xmlCategoryNode.SelectSingleNodeAndCacheExpression("@blackmarket")?.Value;
                        if (!string.IsNullOrEmpty(strBlackMarketAttribute) &&
                            strBlackMarketAttribute.SplitNoAlloc(',', StringSplitOptions.RemoveEmptyEntries)
                                                   .Any(x => setNames.Contains(x)))
                        {
                            yield return xmlCategoryNode.Value;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Book code (using the translated version if applicable) using the character's data files.
        /// </summary>
        /// <param name="strAltCode">Book code to search for.</param>
        /// <param name="strLanguage">Language to load.</param>
        public string LanguageBookCodeFromAltCode(string strAltCode, string strLanguage = "")
        {
            return CommonFunctions.LanguageBookCodeFromAltCode(strAltCode, strLanguage, this);
        }

        /// <summary>
        /// Book code (using the translated version if applicable) using the character's data files.
        /// </summary>
        /// <param name="strAltCode">Book code to search for.</param>
        /// <param name="strLanguage">Language to load.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public ValueTask<string> LanguageBookCodeFromAltCodeAsync(string strAltCode, string strLanguage = "", CancellationToken token = default)
        {
            return CommonFunctions.LanguageBookCodeFromAltCodeAsync(strAltCode, strLanguage, this, token);
        }

        /// <summary>
        /// Book code (using the translated version if applicable) using the character's data files.
        /// </summary>
        /// <param name="strCode">Book code to search for.</param>
        /// <param name="strLanguage">Language to load.</param>
        public string LanguageBookShort(string strCode, string strLanguage = "")
        {
            return CommonFunctions.LanguageBookShort(strCode, strLanguage, this);
        }

        /// <summary>
        /// Book code (using the translated version if applicable) using the character's data files.
        /// </summary>
        /// <param name="strCode">Book code to search for.</param>
        /// <param name="strLanguage">Language to load.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public ValueTask<string> LanguageBookShortAsync(string strCode, string strLanguage = "", CancellationToken token = default)
        {
            return CommonFunctions.LanguageBookShortAsync(strCode, strLanguage, this, token);
        }

        /// <summary>
        /// Book name (using the translated version if applicable) using the character's data files.
        /// </summary>
        /// <param name="strCode">Book code to search for.</param>
        /// <param name="strLanguage">Language to load.</param>
        public string LanguageBookLong(string strCode, string strLanguage = "")
        {
            return CommonFunctions.LanguageBookLong(strCode, strLanguage, this);
        }

        /// <summary>
        /// Book name (using the translated version if applicable) using the character's data files.
        /// </summary>
        /// <param name="strCode">Book code to search for.</param>
        /// <param name="strLanguage">Language to load.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public ValueTask<string> LanguageBookLongAsync(string strCode, string strLanguage = "", CancellationToken token = default)
        {
            return CommonFunctions.LanguageBookLongAsync(strCode, strLanguage, this, token);
        }

        /// <summary>
        /// Attempt to translate any Extra text for an item using the character's data files.
        /// </summary>
        /// <param name="strExtra">Extra string to translate.</param>
        /// <param name="strIntoLanguage">Language into which the string should be translated</param>
        /// <param name="strPreferFile">Name of a file to prefer for extras before all others.</param>
        /// <param name="token">CancellationToken to use.</param>
        public string TranslateExtra(string strExtra, string strIntoLanguage = "", string strPreferFile = "", CancellationToken token = default)
        {
            return LanguageManager.TranslateExtra(strExtra, strIntoLanguage, this, strPreferFile, token);
        }

        /// <summary>
        /// Attempt to translate any Extra text for an item using the character's data files.
        /// </summary>
        /// <param name="strExtra">Extra string to translate.</param>
        /// <param name="strIntoLanguage">Language into which the string should be translated</param>
        /// <param name="strPreferFile">Name of a file to prefer for extras before all others.</param>
        /// <param name="token">CancellationToken to use.</param>
        public Task<string> TranslateExtraAsync(string strExtra, string strIntoLanguage = "", string strPreferFile = "", CancellationToken token = default)
        {
            return LanguageManager.TranslateExtraAsync(strExtra, strIntoLanguage, this, strPreferFile, token);
        }

        /// <summary>
        /// Attempt to translate any Extra text for an item from a foreign language to the default one using the character's data files.
        /// </summary>
        /// <param name="strExtra">Extra string to translate.</param>
        /// <param name="strFromLanguage">Language from which the string should be translated</param>
        /// <param name="strPreferFile">Name of a file to prefer for extras before all others.</param>
        /// <param name="token">CancellationToken to use.</param>
        public string ReverseTranslateExtra(string strExtra, string strFromLanguage = "", string strPreferFile = "", CancellationToken token = default)
        {
            return LanguageManager.ReverseTranslateExtra(strExtra, strFromLanguage, this, strPreferFile, token);
        }

        /// <summary>
        /// Attempt to translate any Extra text for an item from a foreign language to the default one using the character's data files.
        /// </summary>
        /// <param name="strExtra">Extra string to translate.</param>
        /// <param name="strFromLanguage">Language from which the string should be translated</param>
        /// <param name="strPreferFile">Name of a file to prefer for extras before all others.</param>
        /// <param name="token">CancellationToken to use.</param>
        public Task<string> ReverseTranslateExtraAsync(string strExtra, string strFromLanguage = "", string strPreferFile = "", CancellationToken token = default)
        {
            return LanguageManager.ReverseTranslateExtraAsync(strExtra, strFromLanguage, this, strPreferFile, token);
        }
        #endregion

        #region UI Methods

        #region Move TreeNodes

        /// <summary>
        /// Move a Gear TreeNode after Drag and Drop, changing its parent.
        /// </summary>
        /// <param name="objGearNode">Node of gear to move.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public void MoveGearParent(TreeNode objDestination, TreeNode objGearNode, CancellationToken token = default)
        {
            if (objGearNode == null || objDestination == null)
                return;
            // The item cannot be dropped onto itself or onto one of its children.
            for(TreeNode objCheckNode = objDestination;
                objCheckNode != null && objCheckNode.Level >= objDestination.Level;
                objCheckNode = objCheckNode.Parent)
                if(objCheckNode == objGearNode)
                    return;
            if(!(objGearNode.Tag is Gear objGear))
            {
                return;
            }

            // Gear cannot be moved to one if its children.
            bool blnAllowMove = true;
            if(objDestination.Level > 0)
            {
                TreeNode objFindNode = objDestination;
                do
                {
                    objFindNode = objFindNode.Parent;
                    if(objFindNode.Tag == objGear)
                    {
                        blnAllowMove = false;
                        break;
                    }
                } while(objFindNode.Level > 0);
            }

            if(!blnAllowMove)
                return;

            using (LockObject.EnterWriteLock(token))
            {
                // Remove the Gear from the character.
                if (objGear.Parent is IHasChildren<Gear> parent)
                    parent.Children.Remove(objGear);
                else
                    Gear.Remove(objGear);

                switch (objDestination.Tag)
                {
                    case Location objLocation:
                        // The Gear was moved to a location, so add it to the character instead.
                        objGear.Location = objLocation;
                        objLocation.Children.Add(objGear);
                        Gear.Add(objGear);
                        break;
                    case Gear objParent:
                        // Add the Gear as a child of the destination Node and clear its location.
                        objGear.Location = null;
                        objParent.Children.Add(objGear);
                        break;
                }
            }
        }

        /// <summary>
        /// Move a Gear TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodeToMove">Node of gear to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public void MoveGearNode(int intNewIndex, TreeNode objDestination, TreeNode nodeToMove, CancellationToken token = default)
        {
            if (objDestination == null || nodeToMove == null)
                return;
            if (!(nodeToMove.Tag is Gear objGear))
                return;
            TreeNode objNewParent = objDestination;
            while (objNewParent.Level > 0 && !(objNewParent.Tag is Location))
                objNewParent = objNewParent.Parent;

            using (LockObject.EnterWriteLock(token))
            {
                switch (objNewParent.Tag)
                {
                    case Location objLocation:
                        nodeToMove.Remove();
                        objGear.Location = objLocation;
                        objNewParent.Nodes.Insert(0, nodeToMove);
                        break;
                    case string _:
                        objGear.Location = null;
                        intNewIndex = Math.Min(intNewIndex, Gear.Count - 1);
                        Gear.Move(Gear.IndexOf(objGear), intNewIndex);
                        break;
                }
            }
        }

        /// <summary>
        /// Move a Gear Location TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodOldNode">Node of gear location to move.</param>
        public void MoveGearRoot(int intNewIndex, TreeNode objDestination, TreeNode nodOldNode)
        {
            if (nodOldNode == null)
                return;
            if(objDestination != null)
            {
                TreeNode objNewParent = objDestination;
                while(objNewParent.Level > 0)
                    objNewParent = objNewParent.Parent;
                intNewIndex = objNewParent.Index;
            }

            if(intNewIndex == 0)
                return;

            if(!(nodOldNode.Tag is Location objLocation))
                return;
            GearLocations.Move(GearLocations.IndexOf(objLocation), intNewIndex);
        }

        /// <summary>
        /// Move a Lifestyle TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodLifestyleNode">Node of lifestyle to move.</param>
        public void MoveLifestyleNode(int intNewIndex, TreeNode objDestination, TreeNode nodLifestyleNode)
        {
            if (nodLifestyleNode == null)
                return;
            if (objDestination != null)
            {
                TreeNode objNewParent = objDestination;
                while(objNewParent.Level > 0)
                    objNewParent = objNewParent.Parent;
                intNewIndex = objNewParent.Index;
            }

            if (intNewIndex == 0)
                return;

            if (!(nodLifestyleNode.Tag is Lifestyle objLifestyle))
                return;
            Lifestyles.Move(Lifestyles.IndexOf(objLifestyle), intNewIndex);
        }

        /// <summary>
        /// Move an Armor TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodeToMove">Node of armor to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public void MoveArmorNode(int intNewIndex, TreeNode objDestination, TreeNode nodeToMove, CancellationToken token = default)
        {
            if (objDestination == null)
                return;
            if (!(nodeToMove?.Tag is Armor objArmor))
                return;
            TreeNode objNewParent = objDestination;
            while (objNewParent.Level > 0 && !(objNewParent.Tag is Location))
                objNewParent = objNewParent.Parent;

            using (LockObject.EnterWriteLock(token))
            {
                switch (objNewParent.Tag)
                {
                    case Location objLocation:
                        nodeToMove.Remove();
                        objArmor.Location = objLocation;
                        objNewParent.Nodes.Insert(0, nodeToMove);
                        break;
                    case string _:
                        objArmor.Location = null;
                        intNewIndex = Math.Min(intNewIndex, Armor.Count - 1);
                        Armor.Move(Armor.IndexOf(objArmor), intNewIndex);
                        break;
                }
            }
        }

        /// <summary>
        /// Move an Armor Location TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodOldNode">Node of armor location to move.</param>
        public void MoveArmorRoot(int intNewIndex, TreeNode objDestination, TreeNode nodOldNode)
        {
            if (nodOldNode == null)
                return;
            if (objDestination != null)
            {
                TreeNode objNewParent = objDestination;
                while (objNewParent.Level > 0)
                    objNewParent = objNewParent.Parent;
                intNewIndex = objNewParent.Index;
            }

            if (intNewIndex == 0)
                return;

            if (!(nodOldNode.Tag is Location objLocation))
                return;
            ArmorLocations.Move(ArmorLocations.IndexOf(objLocation), intNewIndex);
        }

        /// <summary>
        /// Move a Weapon TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodeToMove">Node of weapon to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public void MoveWeaponNode(int intNewIndex, TreeNode objDestination, TreeNode nodeToMove, CancellationToken token = default)
        {
            if (objDestination == null)
                return;
            if (!(nodeToMove?.Tag is Weapon objWeapon))
                return;
            TreeNode objNewParent = objDestination;
            while (objNewParent.Level > 0 && !(objNewParent.Tag is Location))
                objNewParent = objNewParent.Parent;

            using (LockObject.EnterWriteLock(token))
            {
                switch (objNewParent.Tag)
                {
                    case Location objLocation:
                        nodeToMove.Remove();
                        objWeapon.Location = objLocation;
                        objNewParent.Nodes.Insert(0, nodeToMove);
                        break;
                    case string _:
                        objWeapon.Location = null;
                        intNewIndex = Math.Min(intNewIndex, Weapons.Count - 1);
                        Weapons.Move(Weapons.IndexOf(objWeapon), intNewIndex);
                        break;
                }
            }
        }

        /// <summary>
        /// Move a Weapon Location TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodOldNode">Node of weapon location to move.</param>
        public void MoveWeaponRoot(int intNewIndex, TreeNode objDestination, TreeNode nodOldNode)
        {
            if (nodOldNode == null)
                return;
            if (objDestination != null)
            {
                TreeNode objNewParent = objDestination;
                while (objNewParent.Level > 0)
                    objNewParent = objNewParent.Parent;
                intNewIndex = objNewParent.Index;
            }

            if (intNewIndex == 0)
                return;

            if (!(nodOldNode.Tag is Location objLocation))
                return;
            WeaponLocations.Move(WeaponLocations.IndexOf(objLocation), intNewIndex);
        }

        /// <summary>
        /// Move a Vehicle TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodeToMove">Node of vehicle to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public void MoveVehicleNode(int intNewIndex, TreeNode objDestination, TreeNode nodeToMove, CancellationToken token = default)
        {
            if (objDestination == null)
                return;
            if (!(nodeToMove?.Tag is Vehicle objVehicle))
                return;
            TreeNode objNewParent = objDestination;
            while (objNewParent.Level > 0 && !(objNewParent.Tag is Location))
                objNewParent = objNewParent.Parent;

            using (LockObject.EnterWriteLock(token))
            {
                switch (objNewParent.Tag)
                {
                    case Location objLocation:
                        nodeToMove.Remove();
                        objVehicle.Location = objLocation;
                        objNewParent.Nodes.Insert(0, nodeToMove);
                        break;
                    case string _:
                        objVehicle.Location = null;
                        intNewIndex = Math.Min(intNewIndex, Weapons.Count - 1);
                        Vehicles.Move(Vehicles.IndexOf(objVehicle), intNewIndex);
                        break;
                }
            }
        }

        /// <summary>
        /// Move a Vehicle Gear TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="nodDestination">Destination Node.</param>
        /// <param name="nodGearNode">Node of gear to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public void MoveVehicleGearParent(TreeNode nodDestination, TreeNode nodGearNode, CancellationToken token = default)
        {
            if (nodDestination == null || nodGearNode == null)
                return;
            // The item cannot be dropped onto itself or onto one of its children.
            for (TreeNode objCheckNode = nodDestination;
                objCheckNode != null && objCheckNode.Level >= nodDestination.Level;
                objCheckNode = objCheckNode.Parent)
                if (objCheckNode == nodGearNode)
                    return;
            if (!(nodGearNode.Tag is IHasInternalId nodeId))
                return;
            using (EnterReadLock.Enter(LockObject, token))
            {
                // Locate the currently selected piece of Gear.
                //TODO: Better interface for determining what the parent of a bit of gear is.
                Gear objGear = Vehicles.FindVehicleGear(nodeId.InternalId, out Vehicle objOldVehicle,
                                                        out WeaponAccessory objOldWeaponAccessory,
                                                        out Cyberware objOldCyberware);

                if (objGear == null)
                    return;

                using (LockObject.EnterWriteLock(token))
                {
                    if (nodDestination.Tag is Gear objDestinationGear)
                    {
                        // Remove the Gear from the Vehicle.
                        if (objGear.Parent is IHasChildren<Gear> parent)
                            parent.Children.Remove(objGear);
                        else if (objOldCyberware != null)
                            objOldCyberware.GearChildren.Remove(objGear);
                        else if (objOldWeaponAccessory != null)
                            objOldWeaponAccessory.GearChildren.Remove(objGear);
                        else
                            objOldVehicle.GearChildren.Remove(objGear);

                        // Add the Gear to its new parent.
                        objGear.Location = null;
                        objDestinationGear.Children.Add(objGear);
                    }
                    else
                    {
                        // Determine if this is a Location.
                        TreeNode nodVehicleNode = nodDestination;
                        Location objLocation = null;
                        while (nodVehicleNode.Level > 1)
                        {
                            if (objLocation is null && nodVehicleNode.Tag is Location loc)
                            {
                                objLocation = loc;
                            }

                            nodVehicleNode = nodVehicleNode.Parent;
                        }

                        // Determine if this is a Location in the destination Vehicle.
                        if (nodDestination.Tag is Vehicle objNewVehicle)
                        {
                            // Remove the Gear from the Vehicle.
                            if (objGear.Parent is IHasChildren<Gear> parent)
                                parent.Children.Remove(objGear);
                            else if (objOldCyberware != null)
                                objOldCyberware.GearChildren.Remove(objGear);
                            else if (objOldWeaponAccessory != null)
                                objOldWeaponAccessory.GearChildren.Remove(objGear);
                            else
                                objOldVehicle.GearChildren.Remove(objGear);

                            // Add the Gear to the Vehicle and set its Location.
                            objGear.Parent = objNewVehicle;
                            objNewVehicle.GearChildren.Add(objGear);
                            objLocation?.Children.Add(objGear);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Move an Improvement TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodOldNode">Node of improvement to move.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public void MoveImprovementNode(TreeNode objDestination, TreeNode nodOldNode, CancellationToken token = default)
        {
            if (objDestination == null)
                return;
            if (!(nodOldNode?.Tag is Improvement objImprovement))
                return;
            TreeNode objNewParent = objDestination;
            while (objNewParent.Level > 0)
                objNewParent = objNewParent.Parent;

            using (LockObject.EnterWriteLock(token))
            {
                objImprovement.CustomGroup = objNewParent.Tag.ToString() == "Node_SelectedImprovements"
                    ? string.Empty
                    : objNewParent.Text;
                Improvements[Improvements.IndexOf(objImprovement)] = objImprovement;
            }
        }

        /// <summary>
        /// Move an Improvement Group TreeNode after Drag and Drop.
        /// </summary>
        /// <param name="intNewIndex">Node's new index.</param>
        /// <param name="objDestination">Destination Node.</param>
        /// <param name="nodOldNode">Node of improvement group to move.</param>
        public void MoveImprovementRoot(int intNewIndex, TreeNode objDestination, TreeNode nodOldNode)
        {
            if (nodOldNode == null)
                return;
            if (objDestination != null)
            {
                TreeNode objNewParent = objDestination;
                while(objNewParent.Level > 0)
                    objNewParent = objNewParent.Parent;
                intNewIndex = objNewParent.Index;
            }

            if(intNewIndex == 0)
                return;

            string strLocation = nodOldNode.Tag.ToString();
            ImprovementGroups.Move(ImprovementGroups.IndexOf(strLocation), intNewIndex);
        }

        #endregion

        #region Tab clearing

        /// <summary>
        /// Clear all Spell tab elements from the character.
        /// </summary>
        public void ClearMagic(bool blnKeepAdeptEligible, CancellationToken token = default)
        {
            using (EnterReadLock.Enter(LockObject, token))
            {
                if (ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.FreeSpells, token: token)
                        .Count > 0
                    || ImprovementManager
                        .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.FreeSpellsATT, token: token).Count > 0
                    || ImprovementManager
                        .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.FreeSpellsSkill, token: token).Count >
                    0)
                {
                    // Run through all of the Spells and remove their Improvements.
                    using (LockObject.EnterWriteLock(token))
                    {
                        for (int i = Spells.Count - 1; i >= 0; --i)
                        {
                            if (i < Spells.Count)
                            {
                                Spell objToRemove = Spells[i];
                                if (objToRemove.Grade == 0)
                                {
                                    if (blnKeepAdeptEligible && objToRemove.Category == "Rituals" &&
                                        !objToRemove.Descriptors.Contains("Spell"))
                                        continue;
                                    // Remove the Improvements created by the Spell.
                                    ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Spell,
                                        objToRemove.InternalId);
                                    Spells.RemoveAt(i);
                                }
                            }
                        }
                    }
                }

                using (LockObject.EnterWriteLock(token))
                {
                    for (int i = Spirits.Count - 1; i >= 0; --i)
                    {
                        if (i < Spirits.Count)
                        {
                            Spirit objToRemove = Spirits[i];
                            if (objToRemove.EntityType == SpiritType.Spirit)
                            {
                                Spirits.RemoveAt(i);
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Clear all Adept tab elements from the character.
        /// </summary>
        public void ClearAdeptPowers(CancellationToken token = default)
        {
            using (LockObject.EnterWriteLock(token))
            {
                // Run through all powers and remove the ones not added by improvements or foci
                for (int i = Powers.Count - 1; i >= 0; --i)
                {
                    if (i < Powers.Count)
                    {
                        Power objToRemove = Powers[i];
                        if (objToRemove.FreeLevels == 0 && objToRemove.FreePoints == 0)
                        {
                            // Remove the Improvements created by the Power.
                            ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Power,
                                objToRemove.InternalId);
                            Powers.RemoveAt(i);
                        }
                        else
                            objToRemove.Rating = 0;
                    }
                }
            }
        }

        /// <summary>
        /// Clear all Technomancer tab elements from the character.
        /// </summary>
        public void ClearResonance(CancellationToken token = default)
        {
            using (LockObject.EnterWriteLock(token))
            {
                // Run through all of the Complex Forms and remove their Improvements.
                for (int i = ComplexForms.Count - 1; i >= 0; --i)
                {
                    if (i < ComplexForms.Count)
                    {
                        ComplexForm objToRemove = ComplexForms[i];
                        if (objToRemove.Grade == 0)
                        {
                            // Remove the Improvements created by the Spell.
                            ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.ComplexForm,
                                objToRemove.InternalId);
                            ComplexForms.RemoveAt(i);
                        }
                    }
                }

                for (int i = Spirits.Count - 1; i >= 0; --i)
                {
                    if (i < Spirits.Count)
                    {
                        Spirit objToRemove = Spirits[i];
                        if (objToRemove.EntityType == SpiritType.Sprite)
                        {
                            Spirits.RemoveAt(i);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Clear all Advanced Programs tab elements from the character.
        /// </summary>
        public void ClearAdvancedPrograms(CancellationToken token = default)
        {
            using (LockObject.EnterWriteLock(token))
            {
                // Run through all advanced programs and remove the ones not added by improvements
                for (int i = AIPrograms.Count - 1; i >= 0; --i)
                {
                    if (i < AIPrograms.Count)
                    {
                        AIProgram objToRemove = AIPrograms[i];
                        if (objToRemove.CanDelete)
                        {
                            // Remove the Improvements created by the Program.
                            ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.AIProgram,
                                objToRemove.InternalId);
                            AIPrograms.RemoveAt(i);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Clear all cyberware and bioware implanted on the character.
        /// </summary>
        public void ClearCyberwareTab(CancellationToken token = default)
        {
            using (EnterReadLock.Enter(LockObject, token))
            {
                string strDisabledSource = string.Empty;
                if (Created)
                {
                    Improvement objDisablingImprovement = ImprovementManager
                        .GetCachedImprovementListForValueOf(
                            this,
                            Improvement.ImprovementType.SpecialTab,
                            "Cyberware", token: token)
                        .Find(x => x.UniqueName == "disabletab");
                    if (objDisablingImprovement != null)
                    {
                        strDisabledSource = LanguageManager.GetString("String_Space", token: token) +
                                            '(' + GetObjectName(objDisablingImprovement, GlobalSettings.Language, token: token) +
                                            ')' +
                                            LanguageManager.GetString("String_Space", token: token);
                    }
                }

                using (LockObject.EnterWriteLock(token))
                {
                    foreach (Cyberware objCyberware in Cyberware
                                 .Where(x => x.SourceID != Backend.Equipment.Cyberware.EssenceHoleGUID
                                             && x.SourceID != Backend.Equipment.Cyberware
                                                 .EssenceAntiHoleGUID && x.IsModularCurrentlyEquipped)
                                 .ToList())
                    {
                        if (!string.IsNullOrEmpty(objCyberware.PlugsIntoModularMount))
                        {
                            if (objCyberware.CanRemoveThroughImprovements)
                            {
                                objCyberware.Parent?.Children.Remove(objCyberware);
                                Cyberware.Add(objCyberware);
                                objCyberware.ChangeModularEquip(false);
                            }
                        }
                        else if (objCyberware.CanRemoveThroughImprovements)
                        {
                            objCyberware.DeleteCyberware();
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(this);
                            string strEntry = LanguageManager.GetString(
                                objCyberware.SourceType == Improvement.ImprovementSource.Cyberware
                                    ? "String_ExpenseSoldCyberware"
                                    : "String_ExpenseSoldBioware", token: token);
                            objExpense.Create(0,
                                strEntry + strDisabledSource
                                         + objCyberware.CurrentDisplayNameShort,
                                ExpenseType.Nuyen, DateTime.Now);
                            ExpenseEntries.AddWithSort(objExpense);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Clear all Critter tab elements from the character.
        /// </summary>
        public void ClearCritterPowers(CancellationToken token = default)
        {
            using (LockObject.EnterWriteLock(token))
            {
                for (int i = CritterPowers.Count - 1; i >= 0; --i)
                {
                    if (i < CritterPowers.Count)
                    {
                        CritterPower objToRemove = CritterPowers[i];
                        if (objToRemove.Grade >= 0)
                        {
                            // Remove the Improvements created by the Metamagic.
                            ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.CritterPower,
                                objToRemove.InternalId);
                            CritterPowers.RemoveAt(i);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Clear all Initiation tab elements from the character that were not added by improvements.
        /// </summary>
        public void ClearInitiations(CancellationToken token = default)
        {
            using (LockObject.EnterWriteLock(token))
            {
                // Do not update grade numbers until after we're done processing everything
                _blnClearingInitiations = true;
                // We need to remove grades that can potentially add stuff that adds grades, so we cannot use foreach
                for (int i = InitiationGrades.Count - 1; i >= 0; --i)
                {
                    InitiationGrades[i].Remove(false, false);
                }
                // Now update our grade numbers
                _blnClearingInitiations = false;
                InitiateGrade = 0;
                SubmersionGrade = 0;
            }
        }

        #endregion

        #endregion

        #region Basic Properties

        private CharacterSettings _objSettings;

        /// <summary>
        /// Character Settings object.
        /// </summary>
        public CharacterSettings Settings
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _objSettings;
            }
            private set // Private to make sure this is always in sync with GameplayOption
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (ReferenceEquals(_objSettings, value))
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        CharacterSettings objOldSettings = _objSettings;
                        bool blnActuallyDifferentSettings = false;
                        if (_objSettings != null)
                        {
                            blnActuallyDifferentSettings = !_objSettings.HasIdenticalSettings(value);
                            _objSettings.PropertyChanged -= OptionsOnPropertyChanged;
                        }
                        else if (value != null)
                            blnActuallyDifferentSettings = true;
                        _objSettings = value;
                        if (_objSettings != null)
                            _objSettings.PropertyChanged += OptionsOnPropertyChanged;
                        if (!blnActuallyDifferentSettings || IsLoading)
                            return;
                        OnPropertyChanged();
                        if (_objSettings != null)
                        {
                            Utils.RunWithoutThreadLock(async () =>
                            {
                                foreach (string strProperty in _objSettings.GetDifferingPropertyNames(objOldSettings))
                                    await DoOptionsOnPropertyChanged(this, new PropertyChangedEventArgs(strProperty));
                            });
                        }
                        else
                        {
                            Utils.RunWithoutThreadLock(async () =>
                            {
                                foreach (string strProperty in objOldSettings.GetDifferingPropertyNames(_objSettings))
                                    await DoOptionsOnPropertyChanged(this, new PropertyChangedEventArgs(strProperty));
                            });
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Character Settings object.
        /// </summary>
        public async ValueTask<CharacterSettings> GetSettingsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _objSettings;
        }

        /// <summary>
        /// Character Settings object.
        /// </summary>
        private async ValueTask SetSettingsAsync(CharacterSettings value, CancellationToken token = default) // Private to make sure this is always in sync with GameplayOption
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                if (ReferenceEquals(_objSettings, value))
                    return;
                IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token);
                try
                {
                    CharacterSettings objOldSettings = _objSettings;
                    bool blnActuallyDifferentSettings = false;
                    if (_objSettings != null)
                    {
                        blnActuallyDifferentSettings = !await _objSettings.HasIdenticalSettingsAsync(value, token);
                        _objSettings.PropertyChanged -= OptionsOnPropertyChanged;
                    }
                    else if (value != null)
                        blnActuallyDifferentSettings = true;

                    _objSettings = value;
                    if (_objSettings != null)
                        _objSettings.PropertyChanged += OptionsOnPropertyChanged;
                    if (!blnActuallyDifferentSettings || IsLoading)
                        return;
                    OnPropertyChanged();
                    if (_objSettings != null)
                    {
                        foreach (string strProperty in _objSettings.GetDifferingPropertyNames(objOldSettings))
                            await DoOptionsOnPropertyChanged(this, new PropertyChangedEventArgs(strProperty));
                    }
                    else
                    {
                        foreach (string strProperty in objOldSettings.GetDifferingPropertyNames(_objSettings))
                            await DoOptionsOnPropertyChanged(this, new PropertyChangedEventArgs(strProperty));
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync();
                }
            }
        }

        /// <summary>
        /// Name of the file the Character is saved to.
        /// </summary>
        public string FileName
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strFileName;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strFileName == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _strFileName = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Last write time of the file to which this character is saved.
        /// </summary>
        public DateTime FileLastWriteTime
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _dateFileLastWriteTime > DateTime.MinValue ? _dateFileLastWriteTime : DateTime.UtcNow;
            }
        }

        /// <summary>
        /// Whether or not the character has been saved as Created and can no longer be modified using the Build system.
        /// </summary>
        [HubTag]
        public bool Created
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnCreated;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnCreated == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnCreated = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        public async ValueTask<bool> GetCreatedAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _blnCreated;
        }

        /// <summary>
        /// Character's name.
        /// </summary>
        [HubTag]
        public string Name
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strName;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strName == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _strName = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Character's portraits encoded using Base64.
        /// </summary>
        public ThreadSafeList<Image> Mugshots
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstMugshots;
            }
        }

        /// <summary>
        /// Character's main portrait encoded using Base64.
        /// </summary>
        public Image MainMugshot
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (MainMugshotIndex >= Mugshots.Count || MainMugshotIndex < 0)
                        return null;

                    return Mugshots[MainMugshotIndex];
                }
            }
            set
            {
                if(value == null)
                {
                    MainMugshotIndex = -1;
                    return;
                }

                using (EnterReadLock.Enter(LockObject))
                {
                    int intNewMainMugshotIndex = Mugshots.IndexOf(value);
                    if (intNewMainMugshotIndex != -1)
                    {
                        MainMugshotIndex = intNewMainMugshotIndex;
                    }
                    else
                    {
                        using (LockObject.EnterWriteLock())
                            Mugshots.Add(value);
                        MainMugshotIndex = Mugshots.Count - 1;
                    }
                }
            }
        }

        /// <summary>
        /// Index of Character's main portrait. -1 if set to none.
        /// </summary>
        public int MainMugshotIndex
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intMainMugshotIndex;
            }
            set
            {
                if (value < -1)
                    value = -1;
                else if (value >= 0)
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (value >= Mugshots.Count)
                            value = -1;
                    }
                }

                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intMainMugshotIndex == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _intMainMugshotIndex = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        public void SaveMugshots(XmlWriter objWriter, CancellationToken token = default)
        {
            SaveMugshotsCore(true, objWriter, token).ConfigureAwait(false).GetAwaiter().GetResult();
        }

        public Task SaveMugshotsAsync(XmlWriter objWriter, CancellationToken token = default)
        {
            return SaveMugshotsCore(false, objWriter, token);
        }

        public async Task SaveMugshotsCore(bool blnSync, XmlWriter objWriter, CancellationToken token = default)
        {
            if (objWriter == null)
                return;

            // ReSharper disable once MethodHasAsyncOverload
            using (blnSync ? EnterReadLock.Enter(LockObject, token) : await EnterReadLock.EnterAsync(LockObject, token))
            {
                if (blnSync)
                {
                    objWriter.WriteElementString("mainmugshotindex",
                                                 MainMugshotIndex.ToString(GlobalSettings.InvariantCultureInfo));
                    // <mugshot>
                    // ReSharper disable once MethodHasAsyncOverload
                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                    using (objWriter.StartElement("mugshots"))
                    {
                        foreach (Image imgMugshot in Mugshots)
                        {
                            // ReSharper disable once MethodHasAsyncOverload
                            objWriter.WriteElementString(
                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                "mugshot", GlobalSettings.ImageToBase64StringForStorage(imgMugshot));
                        }
                    }
                    // </mugshot>
                }
                else
                {
                    await objWriter.WriteElementStringAsync("mainmugshotindex",
                                                            MainMugshotIndex.ToString(
                                                                GlobalSettings.InvariantCultureInfo), token: token);
                    // <mugshots>
                    XmlElementWriteHelper objBaseElement = await objWriter.StartElementAsync("mugshots", token: token);
                    try
                    {
                        foreach (Image imgMugshot in Mugshots)
                        {
                            await objWriter.WriteElementStringAsync(
                                "mugshot", await GlobalSettings.ImageToBase64StringForStorageAsync(imgMugshot, token), token: token);
                        }
                    }
                    finally
                    {
                        // </mugshots>
                        await objBaseElement.DisposeAsync();
                    }
                }
            }
        }

        public void LoadMugshots(XPathNavigator xmlSavedNode)
        {
            // Mugshots
            using (LockObject.EnterWriteLock())
            {
                xmlSavedNode.TryGetInt32FieldQuickly("mainmugshotindex", ref _intMainMugshotIndex);
                XPathNodeIterator xmlMugshotsList = xmlSavedNode.SelectAndCacheExpression("mugshots/mugshot");
                List<string> lstMugshotsBase64 = new List<string>(xmlMugshotsList.Count);
                foreach (XPathNavigator objXmlMugshot in xmlMugshotsList)
                {
                    string strMugshot = objXmlMugshot.Value;
                    if (!string.IsNullOrWhiteSpace(strMugshot))
                    {
                        lstMugshotsBase64.Add(strMugshot);
                    }
                }

                if (lstMugshotsBase64.Count > 1)
                {
                    Image[] objMugshotImages = new Image[lstMugshotsBase64.Count];
                    Parallel.For(0, lstMugshotsBase64.Count,
                                 i => objMugshotImages[i] = lstMugshotsBase64[i].ToImage(PixelFormat.Format32bppPArgb));
                    _lstMugshots.AddRange(objMugshotImages);
                }
                else if (lstMugshotsBase64.Count == 1)
                {
                    _lstMugshots.Add(lstMugshotsBase64[0].ToImage(PixelFormat.Format32bppPArgb));
                }

                // Legacy Shimmer
                if (Mugshots.Count == 0)
                {
                    XPathNavigator objOldMugshotNode = xmlSavedNode.SelectSingleNode("mugshot");
                    string strMugshot = objOldMugshotNode?.Value;
                    if (!string.IsNullOrWhiteSpace(strMugshot))
                    {
                        _lstMugshots.Add(strMugshot.ToImage(PixelFormat.Format32bppPArgb));
                        _intMainMugshotIndex = 0;
                    }
                }
            }
        }

        public async ValueTask PrintMugshots(XmlWriter objWriter, CancellationToken token = default)
        {
            if (objWriter == null)
                return;
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                if (Mugshots.Count > 0)
                {
                    // Since IE is retarded and can't handle base64 images before IE9, the image needs to be dumped to a temporary directory and its information rewritten.
                    // If you give it an extension of jpg, gif, or png, it expects the file to be in that format and won't render the image unless it was originally that type.
                    // But if you give it the extension img, it will render whatever you give it (which doesn't make any damn sense, but that's IE for you).
                    string strMugshotsDirectoryPath = Path.Combine(Utils.GetStartupPath, "mugshots");
                    if (!Directory.Exists(strMugshotsDirectoryPath))
                    {
                        try
                        {
                            Directory.CreateDirectory(strMugshotsDirectoryPath);
                        }
                        catch (UnauthorizedAccessException)
                        {
                            Program.ShowMessageBox(
                                await LanguageManager.GetStringAsync("Message_Insufficient_Permissions_Warning", token: token));
                        }
                    }

                    Guid guiImage = Guid.NewGuid();
                    Image imgMainMugshot = MainMugshot;
                    if (imgMainMugshot != null)
                    {
                        string imgMugshotPath = Path.Combine(strMugshotsDirectoryPath,
                                                             guiImage.ToString("N", GlobalSettings.InvariantCultureInfo)
                                                             + ".jpg");
                        imgMainMugshot.Save(imgMugshotPath);
                        // <mainmugshotpath />
                        await objWriter.WriteElementStringAsync("mainmugshotpath",
                                                     "file://" + imgMugshotPath.Replace(
                                                         Path.DirectorySeparatorChar, '/'), token: token);
                        // <mainmugshotbase64 />
                        await objWriter.WriteElementStringAsync("mainmugshotbase64", await imgMainMugshot.ToBase64StringAsJpegAsync(token: token), token: token);
                    }

                    // <othermugshots>
                    await objWriter.WriteElementStringAsync("hasothermugshots",
                                                 (imgMainMugshot == null || Mugshots.Count > 1).ToString(
                                                     GlobalSettings.InvariantCultureInfo), token: token);

                    // <othermugshots>
                    XmlElementWriteHelper objOtherMugshotsElement = await objWriter.StartElementAsync("othermugshots", token: token);
                    try
                    {
                        for (int i = 0; i < Mugshots.Count; ++i)
                        {
                            if (i == MainMugshotIndex)
                                continue;
                            Image imgMugshot = Mugshots[i];

                            // <mugshot>
                            XmlElementWriteHelper objMugshotElement = await objWriter.StartElementAsync("mugshot", token: token);
                            try
                            {
                                await objWriter.WriteElementStringAsync(
                                    "stringbase64", await imgMugshot.ToBase64StringAsJpegAsync(token: token),
                                    token: token);

                                string imgMugshotPath = Path.Combine(strMugshotsDirectoryPath,
                                                                     guiImage.ToString("N", GlobalSettings.InvariantCultureInfo)
                                                                     +
                                                                     i.ToString(GlobalSettings.InvariantCultureInfo) + ".jpg");
                                imgMugshot.Save(imgMugshotPath);
                                await objWriter.WriteElementStringAsync("temppath",
                                                                        "file://" + imgMugshotPath.Replace(
                                                                            Path.DirectorySeparatorChar, '/'), token: token);
                            }
                            finally
                            {
                                // </mugshot>
                                await objMugshotElement.DisposeAsync();
                            }
                        }
                    }
                    finally
                    {
                        // </othermugshots>
                        await objOtherMugshotsElement.DisposeAsync();
                    }
                }
            }
        }

        /// <summary>
        /// Character's Gameplay Option.
        /// </summary>
        [HubTag]
        public string SettingsKey
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strSettingsKey;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strSettingsKey == value)
                        return;
                    if (!SettingsManager.LoadedCharacterSettings.TryGetValue(
                            value, out CharacterSettings objNewSettings))
                        throw new InvalidOperationException(nameof(SettingsKey));
                    using (LockObject.EnterWriteLock())
                    {
                        _strSettingsKey = value;
                        OnPropertyChanged();
                        Settings = objNewSettings;
                    }
                }
            }
        }

        /// <summary>
        /// Character's Gameplay Option.
        /// </summary>
        public async ValueTask<string> GetSettingsKeyAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _strSettingsKey;
        }

        public async Task SetSettingsKeyAsync(string value, CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                if (_strSettingsKey == value)
                    return;
                (bool blnSuccess, CharacterSettings objNewSettings)
                    = await SettingsManager.LoadedCharacterSettings.TryGetValueAsync(value, token);
                if (!blnSuccess)
                    throw new InvalidOperationException(nameof(SettingsKey));
                IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token);
                try
                {
                    _strSettingsKey = value;
                    OnPropertyChanged(nameof(SettingsKey));
                    await SetSettingsAsync(objNewSettings, token);
                }
                finally
                {
                    await objLocker.DisposeAsync();
                }
            }
        }

        /// <summary>
        /// Character's Metatype Priority.
        /// </summary>
        [HubTag]
        public string MetatypePriority
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strPriorityMetatype;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strPriorityMetatype == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _strPriorityMetatype = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Character's Attributes Priority.
        /// </summary>
        [HubTag]
        public string AttributesPriority
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strPriorityAttributes;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strPriorityAttributes == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _strPriorityAttributes = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Character's Special Priority.
        /// </summary>
        [HubTag]
        public string SpecialPriority
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strPrioritySpecial;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strPrioritySpecial == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _strPrioritySpecial = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Character's Skills Priority.
        /// </summary>
        [HubTag]
        public string SkillsPriority
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strPrioritySkills;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strPrioritySkills == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _strPrioritySkills = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Character's Resources Priority.
        /// </summary>
        [HubTag]
        public string ResourcesPriority
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strPriorityResources;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strPriorityResources == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _strPriorityResources = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Character's Resources Priority.
        /// </summary>
        [HubTag]
        public string TalentPriority
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strPriorityTalent;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strPriorityTalent == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _strPriorityTalent = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Character's list of priority bonus skills.
        /// </summary>
        public ThreadSafeList<string> PriorityBonusSkillList
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstPrioritySkills;
            }
        }

        /// <summary>
        /// Character's gender.
        /// </summary>
        public string Gender
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strGender;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strGender == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _strGender = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Character's gender.
        /// </summary>
        public async ValueTask<string> GetGenderAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _strGender;
        }

        private string _strCachedCharacterGrammaticGender = string.Empty;

        public string CharacterGrammaticGender
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (!string.IsNullOrEmpty(_strCachedCharacterGrammaticGender))
                        return _strCachedCharacterGrammaticGender;
                    switch (ReverseTranslateExtra(Gender).ToUpperInvariant())
                    {
                        case "M":
                        case "MALE":
                        case "MAN":
                        case "BOY":
                        case "LORD":
                        case "GENTLEMAN":
                        case "GUY":
                            return _strCachedCharacterGrammaticGender = "male";
                        case "F":
                        case "W":
                        case "FEMALE":
                        case "WOMAN":
                        case "GIRL":
                        case "LADY":
                        case "GAL":
                            return _strCachedCharacterGrammaticGender = "female";
                        default:
                            return _strCachedCharacterGrammaticGender = "neutral";
                    }
                }
            }
        }

        /// <summary>
        /// Character's age.
        /// </summary>
        public string Age
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strAge;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strAge == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _strAge = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Character's age.
        /// </summary>
        public async ValueTask<string> GetAgeAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _strAge;
        }

        /// <summary>
        /// Character's eyes.
        /// </summary>
        public string Eyes
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strEyes;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strEyes == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _strEyes = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Character's height.
        /// </summary>
        public string Height
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strHeight;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strHeight == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _strHeight = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Character's weight.
        /// </summary>
        public string Weight
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strWeight;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strWeight == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _strWeight = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Character's skin.
        /// </summary>
        public string Skin
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strSkin;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strSkin == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _strSkin = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Character's hair.
        /// </summary>
        public string Hair
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strHair;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strHair == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _strHair = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Character's description.
        /// </summary>
        public string Description
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strDescription;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strDescription == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        string strOldText = _strDescription.RtfToPlainText();
                        string strOldHtml = _strDescription.RtfToHtml();
                        string strNewText = value.RtfToPlainText();
                        string strNewHtml = value.RtfToHtml();
                        _strDescription = string.IsNullOrWhiteSpace(strNewText) ? string.Empty : value;
                        // There's something wonky with Rtf comparison, so do an HTML comparison to be sure that something was definitely changed
                        if ((!string.IsNullOrWhiteSpace(strOldText) || !string.IsNullOrWhiteSpace(strNewText))
                            && (!string.IsNullOrWhiteSpace(strOldHtml) || !string.IsNullOrWhiteSpace(strNewHtml))
                            && strOldHtml != strNewHtml)
                            OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Character's background.
        /// </summary>
        public string Background
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strBackground;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strBackground == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        string strOldText = _strBackground.RtfToPlainText();
                        string strOldHtml = _strBackground.RtfToHtml();
                        string strNewText = value.RtfToPlainText();
                        string strNewHtml = value.RtfToHtml();
                        _strBackground = string.IsNullOrWhiteSpace(strNewText) ? string.Empty : value;
                        // There's something wonky with Rtf comparison, so do an HTML comparison to be sure that something was definitely changed
                        if ((!string.IsNullOrWhiteSpace(strOldText) || !string.IsNullOrWhiteSpace(strNewText))
                            && (!string.IsNullOrWhiteSpace(strOldHtml) || !string.IsNullOrWhiteSpace(strNewHtml))
                            && strOldHtml != strNewHtml)
                            OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Character's concept.
        /// </summary>
        public string Concept
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strConcept;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strConcept == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        string strOldText = _strConcept.RtfToPlainText();
                        string strOldHtml = _strConcept.RtfToHtml();
                        string strNewText = value.RtfToPlainText();
                        string strNewHtml = value.RtfToHtml();
                        _strConcept = string.IsNullOrWhiteSpace(strNewText) ? string.Empty : value;
                        // There's something wonky with Rtf comparison, so do an HTML comparison to be sure that something was definitely changed
                        if ((!string.IsNullOrWhiteSpace(strOldText) || !string.IsNullOrWhiteSpace(strNewText))
                            && (!string.IsNullOrWhiteSpace(strOldHtml) || !string.IsNullOrWhiteSpace(strNewHtml))
                            && strOldHtml != strNewHtml)
                            OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Character notes.
        /// </summary>
        public string Notes
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strNotes;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strNotes == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        string strOldText = _strNotes.RtfToPlainText();
                        string strOldHtml = _strNotes.RtfToHtml();
                        string strNewText = value.RtfToPlainText();
                        string strNewHtml = value.RtfToHtml();
                        _strNotes = string.IsNullOrWhiteSpace(strNewText) ? string.Empty : value;
                        // There's something wonky with Rtf comparison, so do an HTML comparison to be sure that something was definitely changed
                        if ((!string.IsNullOrWhiteSpace(strOldText) || !string.IsNullOrWhiteSpace(strNewText))
                            && (!string.IsNullOrWhiteSpace(strOldHtml) || !string.IsNullOrWhiteSpace(strNewHtml))
                            && strOldHtml != strNewHtml)
                            OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// General gameplay notes.
        /// </summary>
        public string GameNotes
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strGameNotes;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strGameNotes == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        string strOldText = _strGameNotes.RtfToPlainText();
                        string strOldHtml = _strGameNotes.RtfToHtml();
                        string strNewText = value.RtfToPlainText();
                        string strNewHtml = value.RtfToHtml();
                        _strGameNotes = string.IsNullOrWhiteSpace(strNewText) ? string.Empty : value;
                        // There's something wonky with Rtf comparison, so do an HTML comparison to be sure that something was definitely changed
                        if ((!string.IsNullOrWhiteSpace(strOldText) || !string.IsNullOrWhiteSpace(strNewText))
                            && (!string.IsNullOrWhiteSpace(strOldHtml) || !string.IsNullOrWhiteSpace(strNewHtml))
                            && strOldHtml != strNewHtml)
                            OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// What is the Characters preferred hand
        /// </summary>
        public string PrimaryArm
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strPrimaryArm;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strPrimaryArm == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _strPrimaryArm = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Player name.
        /// </summary>
        [HubTag]
        public string PlayerName
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strPlayerName;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strPlayerName == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _strPlayerName = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Character's alias.
        /// </summary>
        [HubTag]
        public string Alias
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strAlias;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strAlias == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _strAlias = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Character's name to use when loading them in a new tab.
        /// </summary>
        public string CharacterName
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (!string.IsNullOrWhiteSpace(Alias))
                        return Alias;
                    return !string.IsNullOrWhiteSpace(Name)
                        ? Name
                        : LanguageManager.GetString("String_UnnamedCharacter");
                }
            }
        }

        /// <summary>
        /// Street Cred.
        /// </summary>
        [HubTag]
        public int StreetCred
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intStreetCred;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intStreetCred == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _intStreetCred = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Burnt Street Cred.
        /// </summary>
        public int BurntStreetCred
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intBurntStreetCred;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intBurntStreetCred == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _intBurntStreetCred = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Notoriety.
        /// </summary>
        [HubTag]
        public int Notoriety
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intNotoriety;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intNotoriety == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _intNotoriety = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Public Awareness.
        /// </summary>
        public int PublicAwareness
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intPublicAwareness;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intPublicAwareness == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _intPublicAwareness = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        private bool RefreshAstralReputationImprovements()
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (IsLoading) // Not all improvements are guaranteed to have been loaded in, so just skip the refresh until the end
                {
                    if (!PostLoadMethods.Contains(RefreshAstralReputationImprovements))
                        PostLoadMethods.Enqueue(RefreshAstralReputationImprovements);
                    return true;
                }

                using (LockObject.EnterWriteLock())
                {
                    int intCurrentTotalAstralReputation = TotalAstralReputation;
                    List<Improvement> lstCurrentAstralReputationImprovements = Improvements
                                                                               .Where(x => x.ImproveSource
                                                                                   == Improvement.ImprovementSource
                                                                                       .AstralReputation).ToList();
                    if (lstCurrentAstralReputationImprovements.All(x => x.Value == -intCurrentTotalAstralReputation))
                        return true;
                    ImprovementManager.RemoveImprovements(this, lstCurrentAstralReputationImprovements);
                    ImprovementManager.CreateImprovement(this, "Summoning",
                                                         Improvement.ImprovementSource.AstralReputation,
                                                         nameof(TotalAstralReputation).ToUpperInvariant(),
                                                         Improvement.ImprovementType.Skill,
                                                         Guid.NewGuid()
                                                             .ToString("D", GlobalSettings.InvariantCultureInfo),
                                                         -intCurrentTotalAstralReputation);
                    ImprovementManager.CreateImprovement(this, "Binding",
                                                         Improvement.ImprovementSource.AstralReputation,
                                                         nameof(TotalAstralReputation).ToUpperInvariant(),
                                                         Improvement.ImprovementType.Skill,
                                                         Guid.NewGuid()
                                                             .ToString("D", GlobalSettings.InvariantCultureInfo),
                                                         -intCurrentTotalAstralReputation);
                    ImprovementManager.CreateImprovement(this, "Banishing",
                                                         Improvement.ImprovementSource.AstralReputation,
                                                         nameof(TotalAstralReputation).ToUpperInvariant(),
                                                         Improvement.ImprovementType.Skill,
                                                         Guid.NewGuid()
                                                             .ToString("D", GlobalSettings.InvariantCultureInfo),
                                                         -intCurrentTotalAstralReputation);
                    if (intCurrentTotalAstralReputation >= 3)
                        ImprovementManager.CreateImprovement(this, "Chain Breaker",
                                                             Improvement.ImprovementSource.AstralReputation,
                                                             nameof(TotalAstralReputation).ToUpperInvariant(),
                                                             Improvement.ImprovementType.DisableQuality,
                                                             Guid.NewGuid()
                                                                 .ToString("D", GlobalSettings.InvariantCultureInfo),
                                                             -intCurrentTotalAstralReputation);
                    ImprovementManager.Commit(this);
                    return true;
                }
            }
        }

        /// <summary>
        /// Tooltip to use for Astral Reputation total.
        /// </summary>
        public string AstralReputationTooltip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdReturn))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdReturn.Append(AstralReputation.ToString(GlobalSettings.CultureInfo));

                        foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.AstralReputation))
                        {
                            sbdReturn.Append(strSpace).Append('+').Append(strSpace)
                                     .Append(GetObjectName(objImprovement))
                                     .Append(strSpace).Append('(')
                                     .Append(objImprovement.Value.ToString(GlobalSettings.CultureInfo)).Append(')');
                        }
                    }

                    return sbdReturn.ToString();
                }
            }
        }

        /// <summary>
        /// Astral Reputation (SG 207).
        /// </summary>
        public int TotalAstralReputation
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return Math.Max(
                        0,
                        AstralReputation + ImprovementManager
                                           .ValueOf(this, Improvement.ImprovementType.AstralReputation)
                                           .StandardRound());
            }
        }

        /// <summary>
        /// Points of Astral Reputation that have added or removed manually (latter usually by burning Wild Reputation).
        /// </summary>
        public int AstralReputation
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intBaseAstralReputation;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intBaseAstralReputation == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _intBaseAstralReputation = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Tooltip to use for Wild Reputation total.
        /// </summary>
        public string WildReputationTooltip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdReturn))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdReturn.Append(WildReputation.ToString(GlobalSettings.CultureInfo));

                        foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.AstralReputationWild))
                        {
                            sbdReturn.Append(strSpace).Append('+').Append(strSpace)
                                     .Append(GetObjectName(objImprovement))
                                     .Append(strSpace).Append('(')
                                     .Append(objImprovement.Value.ToString(GlobalSettings.CultureInfo)).Append(')');
                        }
                    }

                    return sbdReturn.ToString();
                }
            }
        }

        /// <summary>
        /// Total Reputation with Wild Spirits (FA 175).
        /// </summary>
        public int TotalWildReputation
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return Math.Max(0,
                                    WildReputation
                                    + ImprovementManager.ValueOf(this, Improvement.ImprovementType.AstralReputationWild)
                                                        .StandardRound());
            }
        }

        /// <summary>
        /// Points of Wild Reputation that have added or removed manually (latter usually by burning it to lower Astral Reputation).
        /// </summary>
        public int WildReputation
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intBaseWildReputation;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intBaseWildReputation == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _intBaseWildReputation = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Number of Physical Condition Monitor Boxes that are filled.
        /// </summary>
        public int PhysicalCMFilled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (HomeNode is Vehicle objVehicle)
                        return objVehicle.PhysicalCMFilled;

                    return _intPhysicalCMFilled;
                }
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (HomeNode is Vehicle objVehicle)
                    {
                        if (objVehicle.PhysicalCMFilled != value)
                        {
                            using (LockObject.EnterWriteLock())
                            {
                                objVehicle.PhysicalCMFilled = value;
                                OnPropertyChanged();
                            }
                        }
                    }
                    else if (_intPhysicalCMFilled != value)
                    {
                        using (LockObject.EnterWriteLock())
                        {
                            _intPhysicalCMFilled = value;
                            OnPropertyChanged();
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Number of Stun Condition Monitor Boxes that are filled.
        /// </summary>
        public int StunCMFilled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI && HomeNode != null)
                    {
                        // A.I. do not have a Stun Condition Monitor, but they do have a Matrix Condition Monitor if they are in their home node.
                        return HomeNode.MatrixCMFilled;
                    }

                    return _intStunCMFilled;
                }
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI && HomeNode != null)
                    {
                        // A.I. do not have a Stun Condition Monitor, but they do have a Matrix Condition Monitor if they are in their home node.
                        if (HomeNode.MatrixCMFilled != value)
                        {
                            using (LockObject.EnterWriteLock())
                            {
                                HomeNode.MatrixCMFilled = value;
                                OnPropertyChanged();
                            }
                        }
                    }
                    else if (_intStunCMFilled != value)
                    {
                        using (LockObject.EnterWriteLock())
                        {
                            _intStunCMFilled = value;
                            OnPropertyChanged();
                        }
                    }
                }
            }
        }

        public bool AddInitiationsAllowed
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return Created || IgnoreRules || Settings.AllowInitiationInCreateMode;
            }
        }

        /// <summary>
        /// Whether or not character creation rules should be ignored.
        /// </summary>
        [HubTag]
        public bool IgnoreRules
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnIgnoreRules;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnIgnoreRules == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnIgnoreRules = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Whether or not character creation rules should be ignored.
        /// </summary>
        public async ValueTask<bool> GetIgnoreRulesAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _blnIgnoreRules;
        }

        /// <summary>
        /// Contact Points.
        /// </summary>
        public int ContactPoints
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedContactPoints == int.MinValue)
                    {
                        string strExpression = Settings.ContactPointsExpression;
                        if (strExpression.IndexOfAny('{', '+', '-', '*', ',') != -1 || strExpression.Contains("div"))
                        {
                            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                          out StringBuilder sbdValue))
                            {
                                sbdValue.Append(strExpression);
                                AttributeSection.ProcessAttributesInXPath(sbdValue, strExpression);

                                // This is first converted to a decimal and rounded up since some items have a multiplier that is not a whole number, such as 2.5.
                                object objProcess
                                    = CommonFunctions.EvaluateInvariantXPath(
                                        sbdValue.ToString(), out bool blnIsSuccess);
                                _intCachedContactPoints = blnIsSuccess ? ((double) objProcess).StandardRound() : 0;
                            }
                        }
                        else
                            int.TryParse(strExpression, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                         out _intCachedContactPoints);
                    }

                    return _intCachedContactPoints;
                }
            }
        }

        public async ValueTask<int> GetContactPointsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                if (_intCachedContactPoints == int.MinValue)
                {
                    string strExpression = await (await GetSettingsAsync(token)).GetContactPointsExpressionAsync(token);
                    if (strExpression.IndexOfAny('{', '+', '-', '*', ',') != -1 || strExpression.Contains("div"))
                    {
                        using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                      out StringBuilder sbdValue))
                        {
                            sbdValue.Append(strExpression);
                            await (await GetAttributeSectionAsync(token)).ProcessAttributesInXPathAsync(sbdValue, strExpression, token: token);

                            // This is first converted to a decimal and rounded up since some items have a multiplier that is not a whole number, such as 2.5.
                            (bool blnIsSuccess, object objProcess)
                                = await CommonFunctions.EvaluateInvariantXPathAsync(sbdValue.ToString(), token);
                            _intCachedContactPoints = blnIsSuccess ? ((double)objProcess).StandardRound() : 0;
                        }
                    }
                    else
                        int.TryParse(strExpression, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                     out _intCachedContactPoints);
                }

                return _intCachedContactPoints;
            }
        }

        /// <summary>
        /// Number of free Contact Points the character has used.
        /// </summary>
        public int ContactPointsUsed
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intContactPointsUsed;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intContactPointsUsed == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _intContactPointsUsed = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        public async ValueTask SetContactPointsUsedAsync(int value, CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (_intContactPointsUsed == value)
                    return;
                IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    _intContactPointsUsed = value;
                    OnPropertyChanged();
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
        }

        /// <summary>
        /// Carry limit (in kg) with added Lift and Carry hits.
        /// </summary>
        public decimal CarryLimit
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return BaseCarryLimit + CurrentLiftCarryHits * 10m;
            }
        }

        /// <summary>
        /// Carry limit (in kg) without added Lift and Carry hits.
        /// </summary>
        public decimal BaseCarryLimit
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_decCachedBaseCarryLimit == decimal.MinValue)
                    {
                        string strExpression = Settings.CarryLimitExpression;
                        if (strExpression.IndexOfAny('{', '+', '-', '*', ',') != -1 || strExpression.Contains("div"))
                        {
                            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                          out StringBuilder sbdValue))
                            {
                                sbdValue.Append(strExpression);
                                AttributeSection.ProcessAttributesInXPath(sbdValue, strExpression);
                                // This is first converted to a decimal and rounded up since some items have a multiplier that is not a whole number, such as 2.5.
                                object objProcess
                                    = CommonFunctions.EvaluateInvariantXPath(
                                        sbdValue.ToString(), out bool blnIsSuccess);
                                _decCachedBaseCarryLimit = blnIsSuccess ? Convert.ToDecimal((double) objProcess) : 0;
                            }
                        }
                        else
                            decimal.TryParse(strExpression, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                             out _decCachedBaseCarryLimit);
                    }

                    return _decCachedBaseCarryLimit;
                }
            }
        }

        /// <summary>
        /// Lift limit (in kg) with added Lift and Carry hits.
        /// </summary>
        public decimal LiftLimit
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return BaseLiftLimit + CurrentLiftCarryHits * 10m;
            }
        }

        /// <summary>
        /// Lift limit (in kg) without added Lift and Carry hits.
        /// </summary>
        public decimal BaseLiftLimit
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_decCachedBaseLiftLimit == decimal.MinValue)
                    {
                        string strExpression = Settings.LiftLimitExpression;
                        if (strExpression.IndexOfAny('{', '+', '-', '*', ',') != -1 || strExpression.Contains("div"))
                        {
                            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                          out StringBuilder sbdValue))
                            {
                                sbdValue.Append(strExpression);
                                AttributeSection.ProcessAttributesInXPath(sbdValue, strExpression);
                                // This is first converted to a decimal and rounded up since some items have a multiplier that is not a whole number, such as 2.5.
                                object objProcess
                                    = CommonFunctions.EvaluateInvariantXPath(
                                        sbdValue.ToString(), out bool blnIsSuccess);
                                _decCachedBaseLiftLimit = blnIsSuccess ? Convert.ToDecimal((double) objProcess) : 0;
                            }
                        }
                        else
                            decimal.TryParse(strExpression, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                             out _decCachedBaseLiftLimit);
                    }

                    return _decCachedBaseLiftLimit;
                }
            }
        }

        /// <summary>
        /// Encumbrance interval (in kg).
        /// </summary>
        public decimal EncumbranceInterval
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_decCachedEncumbranceInterval == decimal.MinValue)
                    {
                        string strExpression = Settings.EncumbranceIntervalExpression;
                        if (strExpression.IndexOfAny('{', '+', '-', '*', ',') != -1 || strExpression.Contains("div"))
                        {
                            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                          out StringBuilder sbdValue))
                            {
                                sbdValue.Append(strExpression);
                                AttributeSection.ProcessAttributesInXPath(sbdValue, strExpression);
                                // This is first converted to a decimal and rounded up since some items have a multiplier that is not a whole number, such as 2.5.
                                object objProcess
                                    = CommonFunctions.EvaluateInvariantXPath(
                                        sbdValue.ToString(), out bool blnIsSuccess);
                                _decCachedEncumbranceInterval
                                    = blnIsSuccess ? Convert.ToDecimal((double) objProcess) : 0;
                            }
                        }
                        else
                            decimal.TryParse(strExpression, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                             out _decCachedEncumbranceInterval);

                        // Need this to make sure our division doesn't go haywire
                        if (_decCachedEncumbranceInterval <= 0)
                            _decCachedEncumbranceInterval = Convert.ToDecimal(double.Epsilon);
                    }

                    return _decCachedEncumbranceInterval;
                }
            }
        }

        /// <summary>
        /// CFP Limit.
        /// </summary>
        public int CFPLimit
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intCFPLimit;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCFPLimit == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _intCFPLimit = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// CFP Limit.
        /// </summary>
        public async ValueTask<int> GetCFPLimitAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _intCFPLimit;
        }

        /// <summary>
        /// Total AI Program Limit.
        /// </summary>
        public int AINormalProgramLimit
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intAINormalProgramLimit;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intAINormalProgramLimit == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _intAINormalProgramLimit = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Total AI Program Limit.
        /// </summary>
        public async ValueTask<int> GetAINormalProgramLimitAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _intAINormalProgramLimit;
        }

        /// <summary>
        /// AI Advanced Program Limit.
        /// </summary>
        public int AIAdvancedProgramLimit
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intAIAdvancedProgramLimit;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intAIAdvancedProgramLimit == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _intAIAdvancedProgramLimit = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// AI Advanced Program Limit.
        /// </summary>
        public async ValueTask<int> GetAIAdvancedProgramLimitAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _intAIAdvancedProgramLimit;
        }

        /// <summary>
        /// Spell Limit.
        /// </summary>
        public int FreeSpells
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intFreeSpells;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intFreeSpells == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _intFreeSpells = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Spell Limit.
        /// </summary>
        public async ValueTask<int> GetFreeSpellsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _intFreeSpells;
        }

        /// <summary>
        /// Karma.
        /// </summary>
        public int Karma
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intKarma;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intKarma == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _intKarma = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Karma.
        /// </summary>
        public async ValueTask<int> GetKarmaAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _intKarma;
        }
        /// <summary>
        /// Karma.
        /// </summary>
        public async ValueTask SetKarmaAsync(int value, CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                if (_intKarma == value)
                    return;
                IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token);
                try
                {
                    _intKarma = value;
                    OnPropertyChanged(nameof(Karma));
                }
                finally
                {
                    await objLocker.DisposeAsync();
                }
            }
        }

        public string DisplayKarma
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return Karma.ToString(GlobalSettings.CultureInfo);
            }
        }

        /// <summary>
        /// Special.
        /// </summary>
        public int Special
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intSpecial;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intSpecial == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _intSpecial = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// TotalSpecial.
        /// </summary>
        public int TotalSpecial
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intTotalSpecial;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intTotalSpecial == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _intTotalSpecial = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Attributes.
        /// </summary>
        public int Attributes
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intAttributes;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intAttributes == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _intAttributes = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// TotalAttributes.
        /// </summary>
        public int TotalAttributes
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intTotalAttributes;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intTotalAttributes == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _intTotalAttributes = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        private int _intCachedCareerKarma = int.MinValue;

        /// <summary>
        /// Total amount of Karma the character has earned over the career.
        /// </summary>
        [HubTag]
        public int CareerKarma
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedCareerKarma != int.MinValue)
                        return _intCachedCareerKarma;

                    int intKarma = 0;

                    foreach (ExpenseLogEntry objEntry in _lstExpenseLog)
                    {
                        // Since we're only interested in the amount they have earned, only count values that are greater than 0 and are not refunds.
                        if (objEntry.Type == ExpenseType.Karma && (objEntry.Amount > 0 || objEntry.ForceCareerVisible)
                                                               && !objEntry.Refund)
                            intKarma += objEntry.Amount.StandardRound();
                    }

                    return _intCachedCareerKarma = intKarma;
                }
            }
        }

        public string DisplayCareerKarma
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CareerKarma.ToString(GlobalSettings.CultureInfo);
            }
        }

        private decimal _decCachedCareerNuyen = decimal.MinValue;

        /// <summary>
        /// Total amount of Nuyen the character has earned over the career.
        /// </summary>
        public decimal CareerNuyen
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_decCachedCareerNuyen != decimal.MinValue)
                        return _decCachedCareerNuyen;

                    decimal decNuyen = 0;

                    foreach (ExpenseLogEntry objEntry in _lstExpenseLog)
                    {
                        // Since we're only interested in the amount they have earned, only count values that are greater than 0 and are not refunds.
                        if (objEntry.Type == ExpenseType.Nuyen && objEntry.Amount > 0 && !objEntry.Refund)
                            decNuyen += objEntry.Amount;
                    }

                    return _decCachedCareerNuyen = decNuyen;
                }
            }
        }

        public string DisplayCareerNuyen
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CareerNuyen.ToString(Settings.NuyenFormat, GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol");
            }
        }

        /// <summary>
        /// Special.
        /// </summary>
        public int EdgeUsed
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intEdgeUsed;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intEdgeUsed == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _intEdgeUsed = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        public int EdgeRemaining
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return EDG.TotalValue - EdgeUsed;
            }
        }

        public string EdgeRemainingString
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return EdgeRemaining.ToString(GlobalSettings.CultureInfo) + LanguageManager.GetString("String_Of")
                                                                              + EDG.TotalValue.ToString(
                                                                                  GlobalSettings.CultureInfo)
                                                                              + LanguageManager.GetString(
                                                                                  "String_Space")
                                                                              + LanguageManager.GetString(
                                                                                  "String_Remaining");
            }
        }

        /// <summary>
        /// Whether or not the character is a Critter.
        /// </summary>
        [HubTag]
        public bool IsCritter
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnIsCritter;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnIsCritter == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnIsCritter = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Whether or not the character is a Critter.
        /// </summary>
        public async ValueTask<bool> GetIsCritterAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _blnIsCritter;
        }

        /// <summary>
        /// Whether or not the character is a changeling.
        /// </summary>
        [HubTag]
        public bool IsChangeling
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return MetagenicLimit > 0;
            }
        }

        /// <summary>
        /// The highest number of free Metagenic qualities the character can have.
        /// </summary>
        public int MetagenicLimit => ImprovementManager.ValueOf(this, Improvement.ImprovementType.MetageneticLimit)
                                                       .StandardRound();

        /// <summary>
        /// The highest number of free Metagenic qualities the character can have.
        /// </summary>
        public int SpecialModificationLimit =>
            ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpecialModificationLimit)
                              .StandardRound();

        /// <summary>
        /// Whether or not the character is possessed by a Spirit.
        /// </summary>
        public bool Possessed
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnPossessed;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnPossessed == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnPossessed = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        public int SpellKarmaCost(string strCategory = "")
        {
            using (EnterReadLock.Enter(LockObject))
            {
                decimal decReturn = Settings.KarmaSpell;

                // Unconditional modifiers first (which can be cached)
                decReturn += ImprovementManager.ValueOf(this, Improvement.ImprovementType.NewSpellKarmaCost,
                                                        strImprovedName: strCategory);

                foreach (Improvement objLoopImprovement in Improvements)
                {
                    if (objLoopImprovement.ImproveType != Improvement.ImprovementType.NewSpellKarmaCost)
                        continue;
                    if (!objLoopImprovement.Enabled)
                        continue;
                    switch (objLoopImprovement.Condition)
                    {
                        case "career":
                            if (Created)
                                decReturn += objLoopImprovement.Value;
                            break;
                        case "create":
                            if (!Created)
                                decReturn += objLoopImprovement.Value;
                            break;
                        default:
                            continue;
                    }
                }

                // Unconditional modifiers first (which can be cached)
                decimal decMultiplier = 1.0m;
                foreach (Improvement objLoopImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                             this, Improvement.ImprovementType.NewSpellKarmaCostMultiplier, strCategory))
                {
                    decMultiplier *= objLoopImprovement.Value / 100.0m;
                }

                foreach (Improvement objLoopImprovement in Improvements)
                {
                    if (objLoopImprovement.ImproveType != Improvement.ImprovementType.NewSpellKarmaCostMultiplier)
                        continue;
                    if (!objLoopImprovement.Enabled)
                        continue;
                    switch (objLoopImprovement.Condition)
                    {
                        case "career":
                            if (Created)
                                decMultiplier *= objLoopImprovement.Value / 100.0m;
                            break;
                        case "create":
                            if (!Created)
                                decMultiplier *= objLoopImprovement.Value / 100.0m;
                            break;
                        default:
                            continue;
                    }
                }

                if (decMultiplier != 1.0m)
                    decReturn *= decMultiplier;

                return Math.Max(decReturn.StandardRound(), 0);
            }
        }

        public async ValueTask<int> SpellKarmaCostAsync(string strCategory = "", CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                decimal decReturn = await (await GetSettingsAsync(token).ConfigureAwait(false)).GetKarmaSpellAsync(token).ConfigureAwait(false);

                // Unconditional modifiers first (which can be cached)
                decReturn += await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.NewSpellKarmaCost,
                                                                   strImprovedName: strCategory, token: token).ConfigureAwait(false);

                bool blnCreated = await GetCreatedAsync(token).ConfigureAwait(false);
                await Improvements.ForEachAsync(objLoopImprovement =>
                {
                    if (objLoopImprovement.ImproveType != Improvement.ImprovementType.NewSpellKarmaCost)
                        return;
                    if (!objLoopImprovement.Enabled)
                        return;
                    switch (objLoopImprovement.Condition)
                    {
                        case "career":
                            if (blnCreated)
                                decReturn += objLoopImprovement.Value;
                            break;
                        case "create":
                            if (!blnCreated)
                                decReturn += objLoopImprovement.Value;
                            break;
                    }
                }, token).ConfigureAwait(false);

                // Unconditional modifiers first (which can be cached)
                decimal decMultiplier = 1.0m;
                foreach (Improvement objLoopImprovement in await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                             this, Improvement.ImprovementType.NewSpellKarmaCostMultiplier, strCategory, token: token))
                {
                    decMultiplier *= objLoopImprovement.Value / 100.0m;
                }

                await (await GetImprovementsAsync(token)).ForEachAsync(objLoopImprovement =>
                {
                    if (objLoopImprovement.ImproveType != Improvement.ImprovementType.NewSpellKarmaCostMultiplier)
                        return;
                    if (!objLoopImprovement.Enabled)
                        return;
                    switch (objLoopImprovement.Condition)
                    {
                        case "career":
                            if (blnCreated)
                                decMultiplier *= objLoopImprovement.Value / 100.0m;
                            break;
                        case "create":
                            if (!blnCreated)
                                decMultiplier *= objLoopImprovement.Value / 100.0m;
                            break;
                    }
                }, token).ConfigureAwait(false);

                if (decMultiplier != 1.0m)
                    decReturn *= decMultiplier;

                return Math.Max(decReturn.StandardRound(), 0);
            }
        }

        public int ComplexFormKarmaCost
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    decimal decReturn = Settings.KarmaNewComplexForm;

                    decimal decMultiplier = 1.0m;
                    foreach (Improvement objLoopImprovement in Improvements)
                    {
                        if ((string.IsNullOrEmpty(objLoopImprovement.Condition)
                             || (objLoopImprovement.Condition == "career") == Created
                             || (objLoopImprovement.Condition == "create") != Created) && objLoopImprovement.Enabled)
                        {
                            switch (objLoopImprovement.ImproveType)
                            {
                                case Improvement.ImprovementType.NewComplexFormKarmaCost:
                                    decReturn += objLoopImprovement.Value;
                                    break;
                                case Improvement.ImprovementType.NewComplexFormKarmaCostMultiplier:
                                    decMultiplier *= objLoopImprovement.Value / 100.0m;
                                    break;
                            }
                        }
                    }

                    if (decMultiplier != 1.0m)
                        decReturn *= decMultiplier;

                    return Math.Max(decReturn.StandardRound(), 0);
                }
            }
        }

        public async ValueTask<int> GetComplexFormKarmaCostAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                decimal decReturn = await (await GetSettingsAsync(token)).GetKarmaNewComplexFormAsync(token);

                decimal decMultiplier = 1.0m;
                await (await GetImprovementsAsync(token)).ForEachAsync(async objLoopImprovement =>
                {
                    if ((string.IsNullOrEmpty(objLoopImprovement.Condition)
                         || (objLoopImprovement.Condition == "career") == await GetCreatedAsync(token)
                         || (objLoopImprovement.Condition == "create") != await GetCreatedAsync(token))
                        && objLoopImprovement.Enabled)
                    {
                        switch (objLoopImprovement.ImproveType)
                        {
                            case Improvement.ImprovementType.NewComplexFormKarmaCost:
                                decReturn += objLoopImprovement.Value;
                                break;
                            case Improvement.ImprovementType.NewComplexFormKarmaCostMultiplier:
                                decMultiplier *= objLoopImprovement.Value / 100.0m;
                                break;
                        }
                    }
                }, token);

                if (decMultiplier != 1.0m)
                    decReturn *= decMultiplier;

                return Math.Max(decReturn.StandardRound(), 0);
            }
        }

        public int AIProgramKarmaCost
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    decimal decReturn = Settings.KarmaNewAIProgram;

                    decimal decMultiplier = 1.0m;
                    foreach (Improvement objLoopImprovement in Improvements)
                    {
                        if ((string.IsNullOrEmpty(objLoopImprovement.Condition)
                             || (objLoopImprovement.Condition == "career") == Created
                             || (objLoopImprovement.Condition == "create") != Created) && objLoopImprovement.Enabled)
                        {
                            switch (objLoopImprovement.ImproveType)
                            {
                                case Improvement.ImprovementType.NewAIProgramKarmaCost:
                                    decReturn += objLoopImprovement.Value;
                                    break;
                                case Improvement.ImprovementType.NewAIProgramKarmaCostMultiplier:
                                    decMultiplier *= objLoopImprovement.Value / 100.0m;
                                    break;
                            }
                        }
                    }

                    if (decMultiplier != 1.0m)
                        decReturn *= decMultiplier;

                    return Math.Max(decReturn.StandardRound(), 0);
                }
            }
        }

        public async ValueTask<int> GetAIProgramKarmaCostAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                decimal decReturn = await (await GetSettingsAsync(token)).GetKarmaNewAIProgramAsync(token);

                decimal decMultiplier = 1.0m;
                await (await GetImprovementsAsync(token)).ForEachAsync(async objLoopImprovement =>
                {
                    if ((!string.IsNullOrEmpty(objLoopImprovement.Condition)
                         && (objLoopImprovement.Condition == "career") != await GetCreatedAsync(token)
                         && (objLoopImprovement.Condition == "create") == await GetCreatedAsync(token))
                        || !objLoopImprovement.Enabled)
                        return;

                    switch (objLoopImprovement.ImproveType)
                    {
                        case Improvement.ImprovementType.NewAIProgramKarmaCost:
                            decReturn += objLoopImprovement.Value;
                            break;
                        case Improvement.ImprovementType.NewAIProgramKarmaCostMultiplier:
                            decMultiplier *= objLoopImprovement.Value / 100.0m;
                            break;
                    }
                }, token);

                if (decMultiplier != 1.0m)
                    decReturn *= decMultiplier;

                return Math.Max(decReturn.StandardRound(), 0);
            }
        }

        public int AIAdvancedProgramKarmaCost
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    decimal decReturn = Settings.KarmaNewAIAdvancedProgram;

                    decimal decMultiplier = 1.0m;
                    foreach (Improvement objLoopImprovement in Improvements)
                    {
                        if ((string.IsNullOrEmpty(objLoopImprovement.Condition)
                             || (objLoopImprovement.Condition == "career") == Created
                             || (objLoopImprovement.Condition == "create") != Created) && objLoopImprovement.Enabled)
                        {
                            switch (objLoopImprovement.ImproveType)
                            {
                                case Improvement.ImprovementType.NewAIAdvancedProgramKarmaCost:
                                    decReturn += objLoopImprovement.Value;
                                    break;
                                case Improvement.ImprovementType.NewAIAdvancedProgramKarmaCostMultiplier:
                                    decMultiplier *= objLoopImprovement.Value / 100.0m;
                                    break;
                            }
                        }
                    }

                    if (decMultiplier != 1.0m)
                        decReturn *= decMultiplier;

                    return Math.Max(decReturn.StandardRound(), 0);
                }
            }
        }

        public async ValueTask<int> GetAIAdvancedProgramKarmaCostAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                decimal decReturn = await (await GetSettingsAsync(token)).GetKarmaNewAIAdvancedProgramAsync(token);

                decimal decMultiplier = 1.0m;
                await (await GetImprovementsAsync(token)).ForEachAsync(async objLoopImprovement =>
                {
                    if ((!string.IsNullOrEmpty(objLoopImprovement.Condition)
                         && (objLoopImprovement.Condition == "career") != await GetCreatedAsync(token)
                         && (objLoopImprovement.Condition == "create") == await GetCreatedAsync(token))
                        || !objLoopImprovement.Enabled)
                        return;

                    switch (objLoopImprovement.ImproveType)
                    {
                        case Improvement.ImprovementType.NewAIAdvancedProgramKarmaCost:
                            decReturn += objLoopImprovement.Value;
                            break;
                        case Improvement.ImprovementType.NewAIAdvancedProgramKarmaCostMultiplier:
                            decMultiplier *= objLoopImprovement.Value / 100.0m;
                            break;
                    }
                }, token);

                if (decMultiplier != 1.0m)
                    decReturn *= decMultiplier;

                return Math.Max(decReturn.StandardRound(), 0);
            }
        }

        public bool Ambidextrous => ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Ambidextrous).Count > 0;

        public async ValueTask<bool> GetAmbidextrousAsync(CancellationToken token = default)
        {
            return (await ImprovementManager.GetCachedImprovementListForValueOfAsync(this, Improvement.ImprovementType.Ambidextrous, token: token)).Count > 0;
        }

        #endregion

        #region Attributes

        /// <summary>
        /// Get a CharacterAttribute by its name.
        /// </summary>
        /// <param name="strAttribute">CharacterAttribute name to retrieve.</param>
        /// <param name="blnExplicit">Whether to force looking for a specific attribute name.
        /// Mostly expected to be used for gutting Mystic Adept power points.</param>
        public CharacterAttrib GetAttribute(string strAttribute, bool blnExplicit = false)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (strAttribute == "MAGAdept" && !blnExplicit && (!IsMysticAdept || !Settings.MysAdeptSecondMAGAttribute))
                    strAttribute = "MAG";
                return AttributeSection.GetAttributeByName(strAttribute);
            }
        }

        /// <summary>
        /// Get a CharacterAttribute by its name.
        /// </summary>
        /// <param name="strAttribute">CharacterAttribute name to retrieve.</param>
        /// <param name="blnExplicit">Whether to force looking for a specific attribute name.
        /// Mostly expected to be used for gutting Mystic Adept power points.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public async ValueTask<CharacterAttrib> GetAttributeAsync(string strAttribute, bool blnExplicit = false, CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                if (strAttribute == "MAGAdept" && !blnExplicit && (!await GetIsMysticAdeptAsync(token) || !await Settings.GetMysAdeptSecondMAGAttributeAsync(token)))
                    strAttribute = "MAG";
                return await (await GetAttributeSectionAsync(token)).GetAttributeByNameAsync(strAttribute, token);
            }
        }

        /// <summary>
        /// Get all CharacterAttributes that have a particular abbreviation.
        /// </summary>
        /// <param name="strAttribute">CharacterAttribute name to retrieve.</param>
        /// <param name="blnExplicit">Whether to force looking for a specific attribute name.
        /// Mostly expected to be used for gutting Mystic Adept power points.</param>
        public IEnumerable<CharacterAttrib> GetAllAttributes(string strAttribute, bool blnExplicit = false)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (strAttribute == "MAGAdept" && (!IsMysticAdept || !Settings.MysAdeptSecondMAGAttribute)
                                               && !blnExplicit)
                    strAttribute = "MAG";
                foreach (CharacterAttrib objLoop in AttributeSection.AttributeList)
                {
                    if (objLoop.Abbrev == strAttribute)
                        yield return objLoop;
                }

                foreach (CharacterAttrib objLoop in AttributeSection.SpecialAttributeList)
                {
                    if (objLoop.Abbrev == strAttribute)
                        yield return objLoop;
                }
            }
        }

        /// <summary>
        /// Body (BOD) CharacterAttribute.
        /// </summary>
        public CharacterAttrib BOD
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AttributeSection.GetAttributeByName("BOD");
            }
        }

        /// <summary>
        /// Agility (AGI) CharacterAttribute.
        /// </summary>
        public CharacterAttrib AGI
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AttributeSection.GetAttributeByName("AGI");
            }
        }

        /// <summary>
        /// Reaction (REA) CharacterAttribute.
        /// </summary>
        public CharacterAttrib REA
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AttributeSection.GetAttributeByName("REA");
            }
        }

        /// <summary>
        /// Strength (STR) CharacterAttribute.
        /// </summary>
        public CharacterAttrib STR
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AttributeSection.GetAttributeByName("STR");
            }
        }

        /// <summary>
        /// Charisma (CHA) CharacterAttribute.
        /// </summary>
        public CharacterAttrib CHA
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AttributeSection.GetAttributeByName("CHA");
            }
        }

        /// <summary>
        /// Intuition (INT) CharacterAttribute.
        /// </summary>
        public CharacterAttrib INT
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AttributeSection.GetAttributeByName("INT");
            }
        }

        /// <summary>
        /// Logic (LOG) CharacterAttribute.
        /// </summary>
        public CharacterAttrib LOG
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AttributeSection.GetAttributeByName("LOG");
            }
        }

        /// <summary>
        /// Willpower (WIL) CharacterAttribute.
        /// </summary>
        public CharacterAttrib WIL
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AttributeSection.GetAttributeByName("WIL");
            }
        }

        /// <summary>
        /// Edge (EDG) CharacterAttribute.
        /// </summary>
        public CharacterAttrib EDG
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AttributeSection.GetAttributeByName("EDG");
            }
        }

        /// <summary>
        /// Magic (MAG) CharacterAttribute.
        /// </summary>
        public CharacterAttrib MAG
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AttributeSection.GetAttributeByName("MAG");
            }
        }

        /// <summary>
        /// Reflection of MAG (hide it, if it is not enabled!)
        /// </summary>
        [HubTag("Magic")]
        public CharacterAttrib ReflectionMAG
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return MAGEnabled ? MAG : null;
            }
        }

        /// <summary>
        /// Magic (MAG) CharacterAttribute for Adept powers of Mystic Adepts when the appropriate house rule is enabled.
        /// </summary>
        public CharacterAttrib MAGAdept
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Settings.MysAdeptSecondMAGAttribute && IsMysticAdept)
                        return AttributeSection.GetAttributeByName("MAGAdept");
                    return MAG;
                }
            }
        }

        /// <summary>
        /// Reflection of MAGAdept (hide it, if it is not enabled!)
        /// </summary>
        [HubTag("MagicAdept")]
        public CharacterAttrib ReflectionMAGAdept
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return MAGEnabled ? MAGAdept : null;
            }
        }

        /// <summary>
        /// Resonance (RES) CharacterAttribute.
        /// </summary>
        public CharacterAttrib RES
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AttributeSection.GetAttributeByName("RES");
            }
        }

        /// <summary>
        /// Reflection of RES (hide it, if it is not enabled!)
        /// </summary>
        [HubTag("Resonance")]
        public CharacterAttrib ReflectionRES
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return RESEnabled ? RES : null;
            }
        }

        /// <summary>
        /// Depth (DEP) Attribute.
        /// </summary>
        public CharacterAttrib DEP
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AttributeSection.GetAttributeByName("DEP");
            }
        }

        /// <summary>
        /// Reflection of DEP (hide it, if it is not enabled!)
        /// </summary>
        [HubTag("Depth")]
        public CharacterAttrib ReflectionDEP
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return DEPEnabled ? DEP : null;
            }
        }

        /// <summary>
        /// Essence (ESS) Attribute.
        /// </summary>
        public CharacterAttrib ESS => AttributeSection.GetAttributeByName("ESS");

        /// <summary>
        /// Is the MAG CharacterAttribute enabled?
        /// </summary>
        [HubTag]
        public bool MAGEnabled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnMAGEnabled;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnMAGEnabled == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnMAGEnabled = value;
                        if (IsLoading)
                        {
                            OnPropertyChanged();
                            return;
                        }

                        if (value)
                        {
                            // Career mode, so no extra calculations need to be done for EssenceAtSpecialStart
                            if (Created)
                            {
                                ResetCachedEssence();
                                EssenceAtSpecialStart = Essence(true);
                            }
                            // EssenceAtSpecialStart needs to be calculated by assuming that the character took the MAG-enabling quality with the highest essence penalty first, as that would be the most optimal
                            else
                            {
                                // If this character has any MAG-enabling bonuses that could be granted before all others (because they're priority and/or metatype-given),
                                // it has to be assumed those are taken first.
                                List<Improvement> lstAttributeImprovements = ImprovementManager
                                    .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Attribute,
                                                                        "MAG");
                                bool blnCountOnlyPriorityOrMetatypeGivenBonuses = lstAttributeImprovements.Any(
                                    x => x.ImproveSource
                                         == Improvement.ImprovementSource
                                                       .Metatype
                                         || x.ImproveSource
                                         == Improvement.ImprovementSource
                                                       .Metavariant
                                         || x.ImproveSource
                                         == Improvement.ImprovementSource
                                                       .Heritage);
                                if (!blnCountOnlyPriorityOrMetatypeGivenBonuses)
                                {
                                    List<string> lstMAGEnablingQualityIds = lstAttributeImprovements
                                                                            .Where(x => x.ImproveSource
                                                                                == Improvement.ImprovementSource
                                                                                    .Quality).Select(
                                                                                x => x.SourceName).ToList();
                                    // Can't use foreach because new items can get added to this list while it is looping
                                    for (int i = 0; i < lstMAGEnablingQualityIds.Count; ++i)
                                    {
                                        Quality objQuality
                                            = Qualities.FirstOrDefault(
                                                x => x.InternalId == lstMAGEnablingQualityIds[i]);
                                        if (objQuality != null)
                                        {
                                            if (objQuality.OriginSource == QualitySource.Metatype
                                                || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                                || objQuality.OriginSource == QualitySource.BuiltIn
                                                || objQuality.OriginSource == QualitySource.LifeModule
                                                || objQuality.OriginSource == QualitySource.Heritage)
                                            {
                                                blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                                break;
                                            }

                                            if (objQuality.OriginSource == QualitySource.Improvement)
                                            {
                                                List<Improvement> lstSpecificQualityImprovements = ImprovementManager
                                                    .GetCachedImprovementListForValueOf(
                                                        this, Improvement.ImprovementType.SpecificQuality,
                                                        objQuality.InternalId);
                                                if (lstSpecificQualityImprovements.Any(x =>
                                                        x.ImproveSource == Improvement.ImprovementSource.Metatype
                                                        || x.ImproveSource == Improvement.ImprovementSource
                                                            .Metavariant
                                                        || x.ImproveSource
                                                        == Improvement.ImprovementSource.Heritage))
                                                {
                                                    blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                                    break;
                                                }

                                                // Qualities that add other qualities get added to the list to be checked, too
                                                lstMAGEnablingQualityIds.AddRange(
                                                    lstSpecificQualityImprovements
                                                        .Where(
                                                            x => x.ImproveSource
                                                                 == Improvement.ImprovementSource.Quality)
                                                        .Select(x => x.SourceName));
                                            }
                                        }
                                    }
                                }

                                Dictionary<string, decimal> dicImprovementEssencePenalties =
                                    new Dictionary<string, decimal>(Improvements.Count);
                                foreach (Improvement objImprovement in Improvements)
                                {
                                    if (!objImprovement.Enabled)
                                        continue;
                                    bool blnCountImprovement = !blnCountOnlyPriorityOrMetatypeGivenBonuses
                                                               || objImprovement.ImproveSource
                                                               == Improvement.ImprovementSource.Metatype
                                                               || objImprovement.ImproveSource
                                                               == Improvement.ImprovementSource.Metavariant
                                                               || objImprovement.ImproveSource
                                                               == Improvement.ImprovementSource.Heritage;
                                    if (!blnCountImprovement && objImprovement.ImproveSource
                                        == Improvement.ImprovementSource.Quality)
                                    {
                                        Quality objQuality
                                            = Qualities.FirstOrDefault(x => x.InternalId == objImprovement.SourceName);
                                        while (objQuality != null)
                                        {
                                            if (objQuality.OriginSource == QualitySource.Metatype
                                                || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                                || objQuality.OriginSource == QualitySource.BuiltIn
                                                || objQuality.OriginSource == QualitySource.LifeModule
                                                || objQuality.OriginSource == QualitySource.Heritage)
                                            {
                                                blnCountImprovement = true;
                                                break;
                                            }

                                            if (objQuality.OriginSource == QualitySource.Improvement)
                                            {
                                                Improvement objParentImprovement = ImprovementManager
                                                    .GetCachedImprovementListForValueOf(
                                                        this,
                                                        Improvement.ImprovementType
                                                                   .SpecificQuality,
                                                        objQuality.InternalId)
                                                    .FirstOrDefault();
                                                if (objParentImprovement == null)
                                                    break;
                                                if (objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Metatype
                                                    || objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Metavariant
                                                    || objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Heritage)
                                                {
                                                    blnCountImprovement = true;
                                                    break;
                                                }

                                                if (objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Quality)
                                                {
                                                    // Qualities that add other qualities get added to the list to be checked, too
                                                    objQuality = Qualities.FirstOrDefault(
                                                        x => x.InternalId == objParentImprovement.SourceName);
                                                }
                                                else
                                                    break;
                                            }
                                            else
                                                break;
                                        }
                                    }

                                    if (blnCountImprovement)
                                    {
                                        decimal decLoopEssencePenalty = 0;
                                        switch (objImprovement.ImproveType)
                                        {
                                            case Improvement.ImprovementType.EssencePenalty:
                                                decLoopEssencePenalty += objImprovement.Value;
                                                break;
                                            case Improvement.ImprovementType.EssencePenaltyT100:
                                            case Improvement.ImprovementType.EssencePenaltyMAGOnlyT100:
                                                decLoopEssencePenalty += objImprovement.Value / 100.0m;
                                                break;
                                        }

                                        if (decLoopEssencePenalty != 0)
                                        {
                                            if (dicImprovementEssencePenalties.TryGetValue(
                                                    objImprovement.SourceName, out decimal decExistingPenalty))
                                                dicImprovementEssencePenalties[objImprovement.SourceName]
                                                    = decExistingPenalty + decLoopEssencePenalty;
                                            else
                                                dicImprovementEssencePenalties.Add(objImprovement.SourceName,
                                                    decLoopEssencePenalty);
                                        }
                                    }
                                }

                                if (dicImprovementEssencePenalties.Count > 0)
                                    EssenceAtSpecialStart =
                                        ESS.MetatypeMaximum + dicImprovementEssencePenalties.Values.Min();
                                else
                                    EssenceAtSpecialStart = ESS.MetatypeMaximum;
                            }
                        }
                        else
                        {
                            if (!RESEnabled)
                            {
                                ClearInitiations();
                                MagicTradition.ResetTradition();
                            }
                            else
                            {
                                XmlNode xmlTraditionListDataNode
                                    = LoadData("streams.xml").SelectSingleNode("/chummer/traditions");
                                if (xmlTraditionListDataNode != null)
                                {
                                    XmlNode xmlTraditionDataNode
                                        = xmlTraditionListDataNode.SelectSingleNode("tradition[name = \"Default\"]");
                                    if (xmlTraditionDataNode != null)
                                    {
                                        if (!MagicTradition.Create(xmlTraditionDataNode, true))
                                            MagicTradition.ResetTradition();
                                    }
                                    else
                                        MagicTradition.ResetTradition();
                                }
                                else
                                    MagicTradition.ResetTradition();
                            }

                            if (!Created && !RESEnabled && !DEPEnabled)
                                EssenceAtSpecialStart = decimal.MinValue;
                        }

                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Is the MAG CharacterAttribute enabled?
        /// </summary>
        public async ValueTask<bool> GetMAGEnabledAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _blnMAGEnabled;
        }

        /// <summary>
        /// Maximum force of spirits summonable/bindable by the character. Limited to MAG at creation.
        /// </summary>
        public int MaxSpiritForce
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    int intReturn = Settings.SpiritForceBasedOnTotalMAG ? MAG.TotalValue : MAG.Value;
                    if (intReturn <= 0)
                        return 0;
                    if (Created)
                        intReturn *= 2;
                    return intReturn;
                }
            }
        }

        public int BoundSpiritLimit
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intBoundSpiritLimit == int.MinValue)
                    {
                        string strExpression = Settings.BoundSpiritExpression;
                        if (strExpression.IndexOfAny('{', '+', '-', '*', ',') != -1 || strExpression.Contains("div"))
                        {
                            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                          out StringBuilder sbdValue))
                            {
                                sbdValue.Append(strExpression);
                                AttributeSection.ProcessAttributesInXPath(sbdValue, strExpression);

                                // This is first converted to a decimal and rounded up since some items have a multiplier that is not a whole number, such as 2.5.
                                object objProcess
                                    = CommonFunctions.EvaluateInvariantXPath(
                                        sbdValue.ToString(), out bool blnIsSuccess);
                                _intBoundSpiritLimit = blnIsSuccess ? ((double) objProcess).StandardRound() : 0;
                            }
                        }
                        else
                            int.TryParse(strExpression, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                         out _intBoundSpiritLimit);
                    }

                    return _intBoundSpiritLimit;
                }
            }
        }

        /// <summary>
        /// Maximum level of sprites compilable/registrable by the character. Limited to RES at creation.
        /// </summary>
        public int MaxSpriteLevel
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    int intReturn = RES.TotalValue;
                    if (intReturn <= 0)
                        return 0;
                    if (Created)
                        intReturn *= 2;
                    return intReturn;
                }
            }
        }

        public int RegisteredSpriteLimit
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intRegisteredSpriteLimit == int.MinValue)
                    {
                        string strExpression = Settings.RegisteredSpriteExpression;
                        if (strExpression.IndexOfAny('{', '+', '-', '*', ',') != -1 || strExpression.Contains("div"))
                        {
                            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                          out StringBuilder sbdValue))
                            {
                                sbdValue.Append(strExpression);
                                AttributeSection.ProcessAttributesInXPath(sbdValue, strExpression);

                                // This is first converted to a decimal and rounded up since some items have a multiplier that is not a whole number, such as 2.5.
                                object objProcess
                                    = CommonFunctions.EvaluateInvariantXPath(
                                        sbdValue.ToString(), out bool blnIsSuccess);
                                _intRegisteredSpriteLimit = blnIsSuccess ? ((double) objProcess).StandardRound() : 0;
                            }
                        }
                        else
                            int.TryParse(strExpression, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                         out _intRegisteredSpriteLimit);
                    }

                    return _intRegisteredSpriteLimit;
                }
            }
        }

        /// <summary>
        /// Amount of Power Points for Mystic Adepts.
        /// </summary>
        public int MysticAdeptPowerPoints
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intMAGAdept;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    int intNewValue = Math.Min(value, MAG.TotalValue);
                    if (_intMAGAdept == intNewValue)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _intMAGAdept = intNewValue;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Amount of Power Points for Mystic Adepts.
        /// </summary>
        public async ValueTask<int> GetMysticAdeptPowerPointsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _intMAGAdept;
        }

        /// <summary>
        /// Total Amount of Power Points this character has.
        /// </summary>
        public decimal PowerPointsTotal
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    decimal decMAG = UseMysticAdeptPPs ? MysticAdeptPowerPoints : MAGAdept.TotalValue;

                    // Add any Power Point Improvements to MAG.
                    decMAG += ImprovementManager.ValueOf(this, Improvement.ImprovementType.AdeptPowerPoints);

                    return Math.Max(decMAG, 0);
                }
            }
        }

        /// <summary>
        /// Total Amount of Power Points this character has.
        /// </summary>
        public async ValueTask<decimal> GetPowerPointsTotalAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                decimal decMAG = await GetUseMysticAdeptPPsAsync(token)
                    ? await GetMysticAdeptPowerPointsAsync(token)
                    : await (await GetAttributeAsync("MAGAdept", token: token)).GetTotalValueAsync(token);

                // Add any Power Point Improvements to MAG.
                decMAG += await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.AdeptPowerPoints, token: token);

                return Math.Max(decMAG, 0);
            }
        }

        private decimal _decCachedPowerPointsUsed = decimal.MinValue;

        public decimal PowerPointsUsed
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_decCachedPowerPointsUsed != decimal.MinValue)
                        return _decCachedPowerPointsUsed;
                    return _decCachedPowerPointsUsed = Powers.Sum(objPower => objPower.PowerPoints);
                }
            }
        }

        public async ValueTask<decimal> GetPowerPointsUsedAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                if (_decCachedPowerPointsUsed != decimal.MinValue)
                    return _decCachedPowerPointsUsed;
                return _decCachedPowerPointsUsed = await (await GetPowersAsync(token)).SumAsync(objPower => objPower.GetPowerPointsAsync(token).AsTask(), token);
            }
        }

        public string DisplayPowerPointsRemaining
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                    return PowerPointsTotal.ToString(GlobalSettings.CultureInfo) + strSpace + '(' +
                           (PowerPointsTotal - PowerPointsUsed).ToString(GlobalSettings.CultureInfo) + strSpace +
                           LanguageManager.GetString("String_Remaining") + ')';
            }
        }

        public bool AnyPowerAdeptWayDiscountEnabled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return Powers.Any(objPower => objPower.AdeptWayDiscountEnabled);
            }
        }

        /// <summary>
        /// Magician's Tradition.
        /// </summary>
        [HubTag("Tradition", "", "MagicTradition", false)]
        public Tradition MagicTradition
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _objTradition;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_objTradition == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _objTradition = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Initiate Grade.
        /// </summary>
        [HubTag]
        public int InitiateGrade
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intInitiateGrade;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intInitiateGrade == value)
                        return;
                    bool blnFirstInitiation = _intInitiateGrade == 0;
                    using (LockObject.EnterWriteLock())
                    {
                        _intInitiateGrade = value;
                        // Remove any existing Initiation Improvements.
                        if (value == 0)
                        {
                            ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Initiation);
                            // Update any Metamagic Improvements the character might have.
                            foreach (Metamagic objMetamagic in Metamagics.Where(
                                         x => x.SourceType == Improvement.ImprovementSource.Metamagic
                                              && x.Bonus?.InnerXml.Contains("Rating") == true))
                            {
                                ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Metamagic,
                                                                      objMetamagic.InternalId);
                            }
                        }
                        else if (blnFirstInitiation)
                        {
                            // Create the new Improvement.
                            ImprovementManager.CreateImprovement(this, "MAG", Improvement.ImprovementSource.Initiation,
                                                                 string.Empty, Improvement.ImprovementType.Attribute,
                                                                 string.Empty, 0, value, 0, 1);
                            ImprovementManager.CreateImprovement(this, "MAGAdept",
                                                                 Improvement.ImprovementSource.Initiation,
                                                                 string.Empty, Improvement.ImprovementType.Attribute,
                                                                 string.Empty, 0, value, 0, 1);
                            ImprovementManager.Commit(this);
                            // Update any Metamagic Improvements the character might have.
                            foreach (Metamagic objMetamagic in Metamagics.Where(
                                         x => x.SourceType == Improvement.ImprovementSource.Metamagic
                                              && x.Bonus?.InnerXml.Contains("Rating") == true))
                            {
                                ImprovementManager.CreateImprovements(this, Improvement.ImprovementSource.Metamagic,
                                                                      objMetamagic.InternalId, objMetamagic.Bonus,
                                                                      value,
                                                                      objMetamagic.DisplayNameShort(
                                                                          GlobalSettings.Language));
                            }
                        }
                        else
                        {
                            if (Improvements.All(x => x.ImproveSource != Improvement.ImprovementSource.Initiation))
                            {
                                // Create the new Improvement.
                                ImprovementManager.CreateImprovement(this, "MAG",
                                                                     Improvement.ImprovementSource.Initiation,
                                                                     string.Empty,
                                                                     Improvement.ImprovementType.Attribute,
                                                                     string.Empty, 0, value, 0, 1);
                                ImprovementManager.CreateImprovement(this, "MAGAdept",
                                                                     Improvement.ImprovementSource.Initiation,
                                                                     string.Empty,
                                                                     Improvement.ImprovementType.Attribute,
                                                                     string.Empty, 0, value, 0, 1);
                                ImprovementManager.Commit(this);
                            }
                            else
                            {
                                // ReSharper disable once ForCanBeConvertedToForeach
                                for (int i = 0; i < Improvements.Count; ++i)
                                {
                                    Improvement objImprovement = Improvements[i];
                                    if (objImprovement.ImproveSource == Improvement.ImprovementSource.Initiation)
                                        objImprovement.Rating = value;
                                }
                            }

                            // Update any Metamagic Improvements the character might have.
                            foreach (Metamagic objMetamagic in Metamagics.Where(
                                         x => x.SourceType == Improvement.ImprovementSource.Metamagic
                                              && x.Bonus?.InnerXml.Contains("Rating") == true))
                            {
                                string strMetamagicId = objMetamagic.InternalId;
                                // If the Bonus contains "Rating", refresh ratings of existing Improvements.
                                if (Improvements.All(x =>
                                                         x.ImproveSource != Improvement.ImprovementSource.Metamagic ||
                                                         x.SourceName != strMetamagicId))
                                {
                                    ImprovementManager.CreateImprovements(this, Improvement.ImprovementSource.Metamagic,
                                                                          strMetamagicId, objMetamagic.Bonus, value,
                                                                          objMetamagic.DisplayNameShort(
                                                                              GlobalSettings.Language));
                                }
                                else
                                {
                                    // ReSharper disable once ForCanBeConvertedToForeach
                                    for (int i = 0; i < Improvements.Count; ++i)
                                    {
                                        Improvement objImprovement = Improvements[i];
                                        if (objImprovement.SourceName == strMetamagicId &&
                                            objImprovement.ImproveSource == Improvement.ImprovementSource.Metamagic)
                                            objImprovement.Rating = value;
                                    }
                                }
                            }
                        }

                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Is the RES CharacterAttribute enabled?
        /// </summary>
        [HubTag]
        public bool RESEnabled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnRESEnabled;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnRESEnabled == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnRESEnabled = value;
                        if (IsLoading)
                        {
                            OnPropertyChanged();
                            return;
                        }

                        if (value)
                        {
                            // Career mode, so no extra calculations need to be done for EssenceAtSpecialStart
                            if (Created)
                            {
                                ResetCachedEssence();
                                EssenceAtSpecialStart = Essence();
                            }
                            // EssenceAtSpecialStart needs to be calculated by assuming that the character took the RES-enabling quality with the highest essence penalty first, as that would be the most optimal
                            else
                            {
                                // If this character has any RES-enabling bonuses that could be granted before all others (because they're priority and/or metatype-given),
                                // it has to be assumed those are taken first.
                                List<Improvement> lstAttributeImprovements = ImprovementManager
                                    .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Attribute,
                                                                        "RES");
                                bool blnCountOnlyPriorityOrMetatypeGivenBonuses = lstAttributeImprovements.Any(
                                    x => x.ImproveSource
                                         == Improvement.ImprovementSource
                                                       .Metatype
                                         || x.ImproveSource
                                         == Improvement.ImprovementSource
                                                       .Metavariant
                                         || x.ImproveSource
                                         == Improvement.ImprovementSource
                                                       .Heritage);
                                if (!blnCountOnlyPriorityOrMetatypeGivenBonuses)
                                {
                                    List<string> lstRESEnablingQualityIds = lstAttributeImprovements
                                                                            .Where(x => x.ImproveSource
                                                                                == Improvement.ImprovementSource
                                                                                    .Quality).Select(
                                                                                x => x.SourceName).ToList();
                                    // Can't use foreach because new items can get added to this list while it is looping
                                    for (int i = 0; i < lstRESEnablingQualityIds.Count; ++i)
                                    {
                                        Quality objQuality
                                            = Qualities.FirstOrDefault(
                                                x => x.InternalId == lstRESEnablingQualityIds[i]);
                                        if (objQuality != null)
                                        {
                                            if (objQuality.OriginSource == QualitySource.Metatype
                                                || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                                || objQuality.OriginSource == QualitySource.BuiltIn
                                                || objQuality.OriginSource == QualitySource.LifeModule
                                                || objQuality.OriginSource == QualitySource.Heritage)
                                            {
                                                blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                                break;
                                            }

                                            if (objQuality.OriginSource == QualitySource.Improvement)
                                            {
                                                List<Improvement> lstSpecificQualityImprovements = ImprovementManager
                                                    .GetCachedImprovementListForValueOf(
                                                        this, Improvement.ImprovementType.SpecificQuality,
                                                        objQuality.InternalId);
                                                if (lstSpecificQualityImprovements.Any(x =>
                                                        x.ImproveSource == Improvement.ImprovementSource.Metatype
                                                        || x.ImproveSource == Improvement.ImprovementSource
                                                            .Metavariant
                                                        || x.ImproveSource
                                                        == Improvement.ImprovementSource.Heritage))
                                                {
                                                    blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                                    break;
                                                }

                                                // Qualities that add other qualities get added to the list to be checked, too
                                                lstRESEnablingQualityIds.AddRange(
                                                    lstSpecificQualityImprovements
                                                        .Where(
                                                            x => x.ImproveSource
                                                                 == Improvement.ImprovementSource.Quality)
                                                        .Select(x => x.SourceName));
                                            }
                                        }
                                    }
                                }

                                Dictionary<string, decimal> dicImprovementEssencePenalties =
                                    new Dictionary<string, decimal>(Improvements.Count);
                                foreach (Improvement objImprovement in Improvements)
                                {
                                    if (!objImprovement.Enabled)
                                        continue;
                                    bool blnCountImprovement = !blnCountOnlyPriorityOrMetatypeGivenBonuses
                                                               || objImprovement.ImproveSource
                                                               == Improvement.ImprovementSource.Metatype
                                                               || objImprovement.ImproveSource
                                                               == Improvement.ImprovementSource.Metavariant
                                                               || objImprovement.ImproveSource
                                                               == Improvement.ImprovementSource.Heritage;
                                    if (!blnCountImprovement
                                        && objImprovement.ImproveSource == Improvement.ImprovementSource.Quality)
                                    {
                                        Quality objQuality
                                            = Qualities.FirstOrDefault(x => x.InternalId == objImprovement.SourceName);
                                        while (objQuality != null)
                                        {
                                            if (objQuality.OriginSource == QualitySource.Metatype
                                                || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                                || objQuality.OriginSource == QualitySource.BuiltIn
                                                || objQuality.OriginSource == QualitySource.LifeModule
                                                || objQuality.OriginSource == QualitySource.Heritage)
                                            {
                                                blnCountImprovement = true;
                                                break;
                                            }

                                            if (objQuality.OriginSource == QualitySource.Improvement)
                                            {
                                                Improvement objParentImprovement = ImprovementManager
                                                    .GetCachedImprovementListForValueOf(
                                                        this,
                                                        Improvement.ImprovementType
                                                                   .SpecificQuality,
                                                        objQuality.InternalId)
                                                    .FirstOrDefault();
                                                if (objParentImprovement == null)
                                                    break;
                                                if (objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Metatype
                                                    || objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Metavariant
                                                    || objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Heritage)
                                                {
                                                    blnCountImprovement = true;
                                                    break;
                                                }

                                                if (objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Quality)
                                                {
                                                    // Qualities that add other qualities get added to the list to be checked, too
                                                    objQuality = Qualities.FirstOrDefault(
                                                        x => x.InternalId == objParentImprovement.SourceName);
                                                }
                                                else
                                                    break;
                                            }
                                            else
                                                break;
                                        }
                                    }

                                    if (blnCountImprovement)
                                    {
                                        decimal decLoopEssencePenalty = 0;
                                        switch (objImprovement.ImproveType)
                                        {
                                            case Improvement.ImprovementType.EssencePenalty:
                                                decLoopEssencePenalty += objImprovement.Value;
                                                break;
                                            case Improvement.ImprovementType.EssencePenaltyT100:
                                                decLoopEssencePenalty += objImprovement.Value / 100.0m;
                                                break;
                                        }

                                        if (decLoopEssencePenalty != 0)
                                        {
                                            if (dicImprovementEssencePenalties.TryGetValue(
                                                    objImprovement.SourceName, out decimal decExistingPenalty))
                                                dicImprovementEssencePenalties[objImprovement.SourceName]
                                                    = decExistingPenalty + decLoopEssencePenalty;
                                            else
                                                dicImprovementEssencePenalties.Add(objImprovement.SourceName,
                                                    decLoopEssencePenalty);
                                        }
                                    }
                                }

                                if (dicImprovementEssencePenalties.Count > 0)
                                    EssenceAtSpecialStart =
                                        ESS.MetatypeMaximum + dicImprovementEssencePenalties.Values.Min();
                                else
                                    EssenceAtSpecialStart = ESS.MetatypeMaximum;
                            }

                            XmlNode xmlTraditionListDataNode
                                = LoadData("streams.xml").SelectSingleNode("/chummer/traditions");
                            if (xmlTraditionListDataNode != null)
                            {
                                XmlNode xmlTraditionDataNode
                                    = xmlTraditionListDataNode.SelectSingleNode("tradition[name = \"Default\"]");
                                if (xmlTraditionDataNode != null)
                                {
                                    if (!MagicTradition.Create(xmlTraditionDataNode, true))
                                        MagicTradition.ResetTradition();
                                }
                                else
                                {
                                    xmlTraditionDataNode = xmlTraditionListDataNode.SelectSingleNode("tradition");
                                    if (xmlTraditionDataNode != null
                                        && !MagicTradition.Create(xmlTraditionDataNode, true))
                                    {
                                        MagicTradition.ResetTradition();
                                    }
                                }
                            }
                        }
                        else
                        {
                            if (!MAGEnabled)
                            {
                                ClearInitiations();
                                MagicTradition.ResetTradition();
                            }
                            else
                            {
                                XmlNode xmlTraditionListDataNode
                                    = LoadData("traditions.xml").SelectSingleNode("/chummer/traditions");
                                if (xmlTraditionListDataNode != null)
                                {
                                    XmlNode xmlTraditionDataNode
                                        = xmlTraditionListDataNode.SelectSingleNode(
                                            "tradition[id = " + Tradition.CustomMagicalTraditionGuid.CleanXPath()
                                                              + ']');
                                    if (xmlTraditionDataNode != null)
                                    {
                                        if (!MagicTradition.Create(xmlTraditionDataNode))
                                            MagicTradition.ResetTradition();
                                    }
                                    else
                                        MagicTradition.ResetTradition();
                                }
                                else
                                    MagicTradition.ResetTradition();
                            }

                            if (!Created && !DEPEnabled && !MAGEnabled)
                                EssenceAtSpecialStart = decimal.MinValue;
                        }

                        ImprovementManager.ClearCachedValue(this, Improvement.ImprovementType.MatrixInitiativeDice);
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Is the RES CharacterAttribute enabled?
        /// </summary>
        public async ValueTask<bool> GetRESEnabledAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _blnRESEnabled;
        }

        /// <summary>
        /// Is the DEP CharacterAttribute enabled?
        /// </summary>
        [HubTag]
        public bool DEPEnabled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnDEPEnabled;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnDEPEnabled == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnDEPEnabled = value;
                        if (IsLoading)
                        {
                            OnPropertyChanged();
                            return;
                        }

                        if (value)
                        {
                            // Career mode, so no extra calculations need to be done for EssenceAtSpecialStart
                            if (Created)
                            {
                                ResetCachedEssence();
                                EssenceAtSpecialStart = Essence();
                            }
                            // EssenceAtSpecialStart needs to be calculated by assuming that the character took the DEP-enabling quality with the highest essence penalty first, as that would be the most optimal
                            else
                            {
                                // If this character has any DEP-enabling bonuses that could be granted before all others (because they're priority and/or metatype-given),
                                // it has to be assumed those are taken first.
                                List<Improvement> lstAttributeImprovements = ImprovementManager
                                    .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Attribute,
                                                                        "DEP");
                                bool blnCountOnlyPriorityOrMetatypeGivenBonuses = lstAttributeImprovements.Any(
                                    x => x.ImproveSource
                                         == Improvement.ImprovementSource
                                                       .Metatype
                                         || x.ImproveSource
                                         == Improvement.ImprovementSource
                                                       .Metavariant
                                         || x.ImproveSource
                                         == Improvement.ImprovementSource
                                                       .Heritage);
                                if (!blnCountOnlyPriorityOrMetatypeGivenBonuses)
                                {
                                    List<string> lstDEPEnablingQualityIds = lstAttributeImprovements
                                                                            .Where(x => x.ImproveSource
                                                                                == Improvement.ImprovementSource
                                                                                    .Quality).Select(
                                                                                x => x.SourceName).ToList();
                                    // Can't use foreach because new items can get added to this list while it is looping
                                    for (int i = 0; i < lstDEPEnablingQualityIds.Count; ++i)
                                    {
                                        Quality objQuality
                                            = Qualities.FirstOrDefault(
                                                x => x.InternalId == lstDEPEnablingQualityIds[i]);
                                        if (objQuality != null)
                                        {
                                            if (objQuality.OriginSource == QualitySource.Metatype
                                                || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                                || objQuality.OriginSource == QualitySource.BuiltIn
                                                || objQuality.OriginSource == QualitySource.LifeModule
                                                || objQuality.OriginSource == QualitySource.Heritage)
                                            {
                                                blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                                break;
                                            }

                                            if (objQuality.OriginSource == QualitySource.Improvement)
                                            {
                                                List<Improvement> lstSpecificQualityImprovements = ImprovementManager
                                                    .GetCachedImprovementListForValueOf(
                                                        this, Improvement.ImprovementType.SpecificQuality,
                                                        objQuality.InternalId);
                                                if (lstSpecificQualityImprovements.Any(x =>
                                                        x.ImproveSource == Improvement.ImprovementSource.Metatype
                                                        || x.ImproveSource == Improvement.ImprovementSource
                                                            .Metavariant
                                                        || x.ImproveSource
                                                        == Improvement.ImprovementSource.Heritage))
                                                {
                                                    blnCountOnlyPriorityOrMetatypeGivenBonuses = true;
                                                    break;
                                                }

                                                // Qualities that add other qualities get added to the list to be checked, too
                                                lstDEPEnablingQualityIds.AddRange(
                                                    lstSpecificQualityImprovements
                                                        .Where(
                                                            x => x.ImproveSource
                                                                 == Improvement.ImprovementSource.Quality)
                                                        .Select(x => x.SourceName));
                                            }
                                        }
                                    }
                                }

                                Dictionary<string, decimal> dicImprovementEssencePenalties =
                                    new Dictionary<string, decimal>(Improvements.Count);
                                foreach (Improvement objImprovement in Improvements)
                                {
                                    if (!objImprovement.Enabled)
                                        continue;
                                    bool blnCountImprovement = !blnCountOnlyPriorityOrMetatypeGivenBonuses
                                                               || objImprovement.ImproveSource
                                                               == Improvement.ImprovementSource.Metatype
                                                               || objImprovement.ImproveSource
                                                               == Improvement.ImprovementSource.Metavariant
                                                               || objImprovement.ImproveSource
                                                               == Improvement.ImprovementSource.Heritage;
                                    if (!blnCountImprovement
                                        && objImprovement.ImproveSource == Improvement.ImprovementSource.Quality)
                                    {
                                        Quality objQuality
                                            = Qualities.FirstOrDefault(x => x.InternalId == objImprovement.SourceName);
                                        while (objQuality != null)
                                        {
                                            if (objQuality.OriginSource == QualitySource.Metatype
                                                || objQuality.OriginSource == QualitySource.MetatypeRemovable
                                                || objQuality.OriginSource == QualitySource.BuiltIn
                                                || objQuality.OriginSource == QualitySource.LifeModule
                                                || objQuality.OriginSource == QualitySource.Heritage)
                                            {
                                                blnCountImprovement = true;
                                                break;
                                            }

                                            if (objQuality.OriginSource == QualitySource.Improvement)
                                            {
                                                Improvement objParentImprovement = ImprovementManager
                                                    .GetCachedImprovementListForValueOf(
                                                        this,
                                                        Improvement.ImprovementType
                                                                   .SpecificQuality,
                                                        objQuality.InternalId)
                                                    .FirstOrDefault();
                                                if (objParentImprovement == null)
                                                    break;
                                                if (objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Metatype
                                                    || objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Metavariant
                                                    || objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Heritage)
                                                {
                                                    blnCountImprovement = true;
                                                    break;
                                                }

                                                if (objParentImprovement.ImproveSource
                                                    == Improvement.ImprovementSource.Quality)
                                                {
                                                    // Qualities that add other qualities get added to the list to be checked, too
                                                    objQuality = Qualities.FirstOrDefault(
                                                        x => x.InternalId == objParentImprovement.SourceName);
                                                }
                                                else
                                                    break;
                                            }
                                            else
                                                break;
                                        }
                                    }

                                    if (blnCountImprovement)
                                    {
                                        decimal decLoopEssencePenalty = 0;
                                        switch (objImprovement.ImproveType)
                                        {
                                            case Improvement.ImprovementType.EssencePenalty:
                                                decLoopEssencePenalty += objImprovement.Value;
                                                break;
                                            case Improvement.ImprovementType.EssencePenaltyT100:
                                                decLoopEssencePenalty += objImprovement.Value / 100.0m;
                                                break;
                                        }

                                        if (decLoopEssencePenalty != 0)
                                        {
                                            if (dicImprovementEssencePenalties.TryGetValue(
                                                    objImprovement.SourceName, out decimal decExistingPenalty))
                                                dicImprovementEssencePenalties[objImprovement.SourceName]
                                                    = decExistingPenalty + decLoopEssencePenalty;
                                            else
                                                dicImprovementEssencePenalties.Add(objImprovement.SourceName,
                                                    decLoopEssencePenalty);
                                        }
                                    }
                                }

                                if (dicImprovementEssencePenalties.Count > 0)
                                    EssenceAtSpecialStart =
                                        ESS.MetatypeMaximum + dicImprovementEssencePenalties.Values.Min();
                                else
                                    EssenceAtSpecialStart = ESS.MetatypeMaximum;
                            }
                        }
                        else if (!Created && !RESEnabled && !MAGEnabled)
                            EssenceAtSpecialStart = decimal.MinValue;

                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Is the DEP CharacterAttribute enabled?
        /// </summary>
        public async ValueTask<bool> GetDEPEnabledAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _blnDEPEnabled;
        }

        [HubTag]
        public bool IsAI
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return DEPEnabled && BOD.MetatypeMaximum == 0;
            }
        }

        /// <summary>
        /// Submersion Grade.
        /// </summary>
        [HubTag]
        public int SubmersionGrade
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intSubmersionGrade;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intSubmersionGrade == value)
                        return;
                    bool blnFirstSubmersion = _intSubmersionGrade == 0;
                    using (LockObject.EnterWriteLock())
                    {
                        _intSubmersionGrade = value;
                        // Remove any existing Submersion Improvements.
                        if (value == 0)
                        {
                            ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Submersion);
                            // Update any Echo Improvements the character might have.
                            foreach (Metamagic objMetamagic in Metamagics.Where(
                                         x => x.SourceType == Improvement.ImprovementSource.Echo
                                              && x.Bonus?.InnerXml.Contains("Rating") == true))
                            {
                                ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Echo,
                                                                      objMetamagic.InternalId);
                            }
                        }
                        else if (blnFirstSubmersion)
                        {
                            // Create the new Improvement.
                            ImprovementManager.CreateImprovement(this, "RES", Improvement.ImprovementSource.Submersion,
                                                                 string.Empty, Improvement.ImprovementType.Attribute,
                                                                 string.Empty, 0, value, 0, 1);
                            ImprovementManager.Commit(this);
                            // Update any Echo Improvements the character might have.
                            foreach (Metamagic objMetamagic in Metamagics.Where(
                                         x => x.SourceType == Improvement.ImprovementSource.Echo
                                              && x.Bonus?.InnerXml.Contains("Rating") == true))
                            {
                                ImprovementManager.CreateImprovements(this, Improvement.ImprovementSource.Echo,
                                                                      objMetamagic.InternalId, objMetamagic.Bonus,
                                                                      value,
                                                                      objMetamagic.DisplayNameShort(
                                                                          GlobalSettings.Language));
                            }
                        }
                        else
                        {
                            if (Improvements.All(x => x.ImproveSource != Improvement.ImprovementSource.Submersion))
                            {
                                // Create the new Improvement.
                                ImprovementManager.CreateImprovement(this, "RES",
                                                                     Improvement.ImprovementSource.Submersion,
                                                                     string.Empty,
                                                                     Improvement.ImprovementType.Attribute,
                                                                     string.Empty, 0, value, 0, 1);
                                ImprovementManager.Commit(this);
                            }
                            else
                            {
                                // ReSharper disable once ForCanBeConvertedToForeach
                                for (int i = 0; i < Improvements.Count; ++i)
                                {
                                    Improvement objImprovement = Improvements[i];
                                    if (objImprovement.ImproveSource == Improvement.ImprovementSource.Submersion)
                                        objImprovement.Rating = value;
                                }
                            }

                            // Update any Echo Improvements the character might have.
                            foreach (Metamagic objMetamagic in Metamagics.Where(
                                         x => x.SourceType == Improvement.ImprovementSource.Echo
                                              && x.Bonus?.InnerXml.Contains("Rating") == true))
                            {
                                string strMetamagicId = objMetamagic.InternalId;
                                // If the Bonus contains "Rating", refresh ratings of existing Improvements.
                                if (Improvements.All(x =>
                                                         x.ImproveSource != Improvement.ImprovementSource.Echo ||
                                                         x.SourceName != strMetamagicId))
                                {
                                    ImprovementManager.CreateImprovements(this, Improvement.ImprovementSource.Echo,
                                                                          strMetamagicId, objMetamagic.Bonus, value,
                                                                          objMetamagic.DisplayNameShort(
                                                                              GlobalSettings.Language));
                                }
                                else
                                {
                                    // ReSharper disable once ForCanBeConvertedToForeach
                                    for (int i = 0; i < Improvements.Count; ++i)
                                    {
                                        Improvement objImprovement = Improvements[i];
                                        if (objImprovement.SourceName == strMetamagicId &&
                                            objImprovement.ImproveSource == Improvement.ImprovementSource.Echo)
                                            objImprovement.Rating = value;
                                    }
                                }
                            }
                        }

                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Whether or not the character is a member of a Group or Network.
        /// </summary>
        public bool GroupMember
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnGroupMember;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnGroupMember == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnGroupMember = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Whether or not the character is a member of a Group or Network.
        /// </summary>
        public async ValueTask<bool> GetGroupMemberAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _blnGroupMember;
        }

        /// <summary>
        /// The name of the Group the Initiate has joined.
        /// </summary>
        [HubTag]
        public string GroupName
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strGroupName;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strGroupName == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _strGroupName = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Notes for the Group the Initiate has joined.
        /// </summary>
        public string GroupNotes
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strGroupNotes;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strGroupNotes == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _strGroupNotes = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Essence the character had when the first gained access to MAG/RES.
        /// </summary>
        public decimal EssenceAtSpecialStart
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _decEssenceAtSpecialStart;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_decEssenceAtSpecialStart == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _decEssenceAtSpecialStart = value;
                        RefreshEssenceLossImprovements();
                    }
                }
            }
        }

        private decimal _decCachedEssence = decimal.MinValue;
        private readonly AsyncFriendlyReaderWriterLock _objCachedEssenceLock = new AsyncFriendlyReaderWriterLock();

        public void ResetCachedEssence(CancellationToken token = default)
        {
            using (LockObject.EnterWriteLock(token))
            using (_objCachedEssenceLock.EnterWriteLock(token))
                _decCachedEssence = decimal.MinValue;
        }

        public async ValueTask ResetCachedEssenceAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token);
            try
            {
                IAsyncDisposable objLocker2 = await _objCachedEssenceLock.EnterWriteLockAsync(token);
                try
                {
                    _decCachedEssence = decimal.MinValue;
                }
                finally
                {
                    await objLocker2.DisposeAsync();
                }
            }
            finally
            {
                await objLocker.DisposeAsync();
            }
        }

        /// <summary>
        /// Character's Essence.
        /// </summary>
        /// <param name="blnForMAGPenalty">Whether fetched Essence is to be used to calculate the penalty MAG should receive from lost Essence (true) or not (false).</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public decimal Essence(bool blnForMAGPenalty = false, CancellationToken token = default)
        {
            if (blnForMAGPenalty)
                return EssenceForMagPenalty(token);
            using (EnterReadLock.Enter(LockObject, token))
            {
                using (EnterReadLock.Enter(_objCachedEssenceLock, token))
                {
                    if (_decCachedEssence != decimal.MinValue)
                        return _decCachedEssence;
                    using (_objCachedEssenceLock.EnterWriteLock(token))
                    {
                        // Another check in case this was already cached in between requesting the lock and obtaining the lock
                        if (_decCachedEssence != decimal.MinValue)
                            return _decCachedEssence;
                        // If the character has a fixed Essence Improvement, permanently fix their Essence at its value.
                        if (ImprovementManager
                            .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.CyborgEssence, token: token).Count
                            > 0)
                        {
                            return _decCachedEssence = 0.1m;
                        }

                        decimal decESS = ESS.MetatypeMaximum;
                        decESS += ImprovementManager.ValueOf(this, Improvement.ImprovementType.EssencePenalty, token: token);
                        decESS += ImprovementManager.ValueOf(this, Improvement.ImprovementType.EssencePenaltyT100, token: token)
                                  / 100.0m;

                        // Run through all of the pieces of Cyberware and include their Essence cost.
                        decESS -= Cyberware.Sum(objCyberware => objCyberware.CalculatedESS);

                        //1781 Essence is not printing
                        //ESS.Base = Convert.ToInt32(decESS); -- Disabled because this messes up Character Validity, and it really shouldn't be what "Base" of an attribute is supposed to be (it's supposed to be extra levels gained)

                        return _decCachedEssence = decESS;
                    }
                }
            }
        }

        /// <summary>
        /// Character's Essence.
        /// </summary>
        /// <param name="blnForMAGPenalty">Whether fetched Essence is to be used to calculate the penalty MAG should receive from lost Essence (true) or not (false).</param>
        /// <param name="token">CancellationToken to listen to.</param>
        public async ValueTask<decimal> EssenceAsync(bool blnForMAGPenalty = false, CancellationToken token = default)
        {
            if (blnForMAGPenalty)
                return await EssenceForMagPenaltyAsync(token: token);
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                using (await EnterReadLock.EnterAsync(_objCachedEssenceLock, token))
                {
                    if (_decCachedEssence != decimal.MinValue)
                        return _decCachedEssence;
                    IAsyncDisposable objLocker = await _objCachedEssenceLock.EnterWriteLockAsync(token);
                    try
                    {
                        // Another check in case this was already cached in between requesting the lock and obtaining the lock
                        if (_decCachedEssence != decimal.MinValue)
                            return _decCachedEssence;
                        // If the character has a fixed Essence Improvement, permanently fix their Essence at its value.
                        if ((await ImprovementManager
                                .GetCachedImprovementListForValueOfAsync(this, Improvement.ImprovementType.CyborgEssence, token: token)).Count
                            > 0)
                        {
                            return _decCachedEssence = 0.1m;
                        }

                        decimal decESS = await ESS.GetMetatypeMaximumAsync(token);
                        decESS += await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.EssencePenalty, token: token);
                        decESS += await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.EssencePenaltyT100, token: token)
                                  / 100.0m;

                        // Run through all of the pieces of Cyberware and include their Essence cost.
                        decESS -= await Cyberware.SumAsync(objCyberware => objCyberware.CalculatedESSAsync, token: token);

                        //1781 Essence is not printing
                        //ESS.Base = Convert.ToInt32(decESS); -- Disabled because this messes up Character Validity, and it really shouldn't be what "Base" of an attribute is supposed to be (it's supposed to be extra levels gained)

                        return _decCachedEssence = decESS;
                    }
                    finally
                    {
                        await objLocker.DisposeAsync();
                    }
                }
            }
        }

        private decimal _decCachedCyberwareEssence = decimal.MinValue;

        /// <summary>
        /// Character's Essence to be used to calculate the penalty MAG should receive from lost Essence.
        /// </summary>
        public decimal EssenceForMagPenalty(CancellationToken token = default)
        {
            using (EnterReadLock.Enter(LockObject, token))
            {
                // If the character has a fixed Essence Improvement, permanently fix their Essence at its value.
                if (ImprovementManager
                    .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.CyborgEssence, token: token).Count
                    > 0)
                {
                    return 0.1m;
                }

                decimal decESS = ESS.MetatypeMaximum;
                decESS += ImprovementManager.ValueOf(this, Improvement.ImprovementType.EssencePenalty, token: token);
                decESS += ImprovementManager.ValueOf(this, Improvement.ImprovementType.EssencePenaltyT100, token: token)
                          / 100.0m;
                decESS += ImprovementManager.ValueOf(
                              this, Improvement.ImprovementType.EssencePenaltyMAGOnlyT100, token: token)
                          / 100.0m;

                // Run through all of the pieces of Cyberware and include their Essence cost.
                decESS -= Cyberware.Sum(objCyberware => objCyberware.CalculatedESS);

                //1781 Essence is not printing
                //ESS.Base = Convert.ToInt32(decESS); -- Disabled because this messes up Character Validity, and it really shouldn't be what "Base" of an attribute is supposed to be (it's supposed to be extra levels gained)

                return decESS;
            }
        }

        /// <summary>
        /// Character's Essence to be used to calculate the penalty MAG should receive from lost Essence.
        /// </summary>
        public async ValueTask<decimal> EssenceForMagPenaltyAsync(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                // If the character has a fixed Essence Improvement, permanently fix their Essence at its value.
                if ((await ImprovementManager
                        .GetCachedImprovementListForValueOfAsync(this, Improvement.ImprovementType.CyborgEssence, token: token)).Count
                    > 0)
                {
                    return 0.1m;
                }

                decimal decESS = await ESS.GetMetatypeMaximumAsync(token);
                decESS += await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.EssencePenalty, token: token);
                decESS += await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.EssencePenaltyT100, token: token)
                          / 100.0m;
                decESS += await ImprovementManager.ValueOfAsync(
                              this, Improvement.ImprovementType.EssencePenaltyMAGOnlyT100, token: token)
                          / 100.0m;

                // Run through all of the pieces of Cyberware and include their Essence cost.
                decESS -= await Cyberware.SumAsync(objCyberware => objCyberware.CalculatedESS, token: token);

                //1781 Essence is not printing
                //ESS.Base = Convert.ToInt32(decESS); -- Disabled because this messes up Character Validity, and it really shouldn't be what "Base" of an attribute is supposed to be (it's supposed to be extra levels gained)

                return decESS;
            }
        }

        /// <summary>
        /// Essence consumed by Cyberware.
        /// </summary>
        public decimal CyberwareEssence
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_decCachedCyberwareEssence != decimal.MinValue)
                        return _decCachedCyberwareEssence;
                    // Run through all of the pieces of Cyberware and include their Essence cost. Cyberware and Bioware costs are calculated separately.
                    return _decCachedCyberwareEssence = Cyberware
                        .Sum(objCyberware =>
                                 objCyberware.SourceType
                                 == Improvement.ImprovementSource.Cyberware
                                 && !objCyberware.SourceID.Equals(
                                     Backend.Equipment.Cyberware.EssenceHoleGUID)
                                 && !objCyberware.SourceID.Equals(
                                     Backend.Equipment.Cyberware.EssenceAntiHoleGUID),
                             objCyberware => objCyberware.CalculatedESS);
                }
            }
        }

        private decimal _decCachedBiowareEssence = decimal.MinValue;

        /// <summary>
        /// Essence consumed by Bioware.
        /// </summary>
        public decimal BiowareEssence
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_decCachedBiowareEssence != decimal.MinValue)
                        return _decCachedBiowareEssence;
                    // Run through all of the pieces of Cyberware and include their Essence cost. Cyberware and Bioware costs are calculated separately.
                    return _decCachedBiowareEssence = Cyberware
                        .Sum(objCyberware =>
                                 objCyberware.SourceType
                                 == Improvement.ImprovementSource.Bioware
                                 && !objCyberware.SourceID.Equals(
                                     Backend.Equipment.Cyberware.EssenceHoleGUID)
                                 && !objCyberware.SourceID.Equals(
                                     Backend.Equipment.Cyberware.EssenceAntiHoleGUID),
                             objCyberware => objCyberware.CalculatedESS);
                }
            }
        }

        private decimal _decCachedEssenceHole = decimal.MinValue;

        /// <summary>
        /// Essence consumed by Essence Holes.
        /// </summary>
        public decimal EssenceHole
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_decCachedEssenceHole != decimal.MinValue)
                        return _decCachedEssenceHole;
                    // Find the total Essence Cost of all Essence Hole objects.
                    return _decCachedEssenceHole = Cyberware
                        .Sum(objCyberware =>
                                 objCyberware.SourceID.Equals(
                                     Backend.Equipment.Cyberware.EssenceHoleGUID)
                                 || objCyberware.SourceID.Equals(
                                     Backend.Equipment.Cyberware.EssenceAntiHoleGUID),
                             objCyberware => objCyberware.CalculatedESS);
                }
            }
        }

        public void IncreaseEssenceHole(decimal decEssence, bool blnOverflowIntoHole = true)
        {
            IncreaseEssenceHole((decEssence * 100).StandardRound(), blnOverflowIntoHole);
        }

        public void IncreaseEssenceHole(int intCentiessence, bool blnOverflowIntoHole = true)
        {
            using (LockObject.EnterWriteLock())
            {
                Cyberware objAntiHole
                    = Cyberware.FirstOrDefault(x => x.SourceID == Backend.Equipment.Cyberware.EssenceAntiHoleGUID);
                if (objAntiHole != null)
                {
                    if (objAntiHole.Rating > intCentiessence)
                    {
                        objAntiHole.Rating -= intCentiessence;
                        return;
                    }

                    intCentiessence -= objAntiHole.Rating;
                    objAntiHole.DeleteCyberware();
                }

                if (blnOverflowIntoHole)
                {
                    Cyberware objHole
                        = Cyberware.FirstOrDefault(x => x.SourceID == Backend.Equipment.Cyberware.EssenceHoleGUID);
                    if (objHole == null)
                    {
                        XmlNode xmlEssHole = LoadData("cyberware.xml")
                            .SelectSingleNode("/chummer/cyberwares/cyberware[id = " + Backend.Equipment.Cyberware
                                                  .EssenceHoleGUID.ToString("D", GlobalSettings.InvariantCultureInfo)
                                                  .CleanXPath() + ']');
                        objHole = new Cyberware(this);
                        List<Weapon> lstWeapons = new List<Weapon>(1);
                        List<Vehicle> lstVehicles = new List<Vehicle>(1);
                        objHole.Create(
                            xmlEssHole,
                            GetGrades(Improvement.ImprovementSource.Cyberware, true)
                                .FirstOrDefault(x => x.Name == "None"), Improvement.ImprovementSource.Cyberware,
                            intCentiessence, lstWeapons,
                            lstVehicles);

                        Cyberware.Add(objHole);

                        foreach (Weapon objWeapon in lstWeapons)
                        {
                            Weapons.Add(objWeapon);
                        }

                        foreach (Vehicle objVehicle in lstVehicles)
                        {
                            Vehicles.Add(objVehicle);
                        }
                    }
                    else
                    {
                        objHole.Rating += intCentiessence;
                    }

                    if (objHole.Rating == 0 && Cyberware.Contains(objHole))
                        Cyberware.Remove(objHole);
                }

                if (objAntiHole?.Rating == 0 && Cyberware.Contains(objAntiHole))
                    Cyberware.Remove(objAntiHole);
            }
        }

        public void DecreaseEssenceHole(decimal decEssence, bool blnOverflowIntoHole = true)
        {
            DecreaseEssenceHole((decEssence * 100).StandardRound(), blnOverflowIntoHole);
        }

        /// <summary>
        /// Decrease or create an Essence Hole, if required.
        /// </summary>
        /// <param name="intCentiessence">Hundredths of Essence to push into a new Essence Hole or Antihole.</param>
        /// <param name="blnOverflowIntoAntiHole">Should we increase or create an Essence Antihole to handle any overflow. Remember, Essence Holes are consumed first.</param>
        public void DecreaseEssenceHole(int intCentiessence, bool blnOverflowIntoAntiHole = true)
        {
            using (LockObject.EnterWriteLock())
            {
                Cyberware objHole
                    = Cyberware.FirstOrDefault(x => x.SourceID == Backend.Equipment.Cyberware.EssenceHoleGUID);

                if (objHole != null)
                {
                    if (objHole.Rating > intCentiessence)
                    {
                        objHole.Rating -= intCentiessence;
                        return;
                    }

                    intCentiessence -= objHole.Rating;
                    objHole.DeleteCyberware();
                }

                if (blnOverflowIntoAntiHole && intCentiessence != 0)
                {
                    Cyberware objAntiHole
                        = Cyberware.FirstOrDefault(x => x.SourceID == Backend.Equipment.Cyberware.EssenceAntiHoleGUID);
                    if (objAntiHole == null)
                    {
                        XmlNode xmlEssAntiHole = LoadData("cyberware.xml")
                            .SelectSingleNode("/chummer/cyberwares/cyberware[id = " + Backend.Equipment.Cyberware
                                                  .EssenceAntiHoleGUID
                                                  .ToString("D", GlobalSettings.InvariantCultureInfo).CleanXPath()
                                              + ']');
                        objAntiHole = new Cyberware(this);
                        List<Weapon> lstWeapons = new List<Weapon>(1);
                        List<Vehicle> lstVehicles = new List<Vehicle>(1);
                        objAntiHole.Create(xmlEssAntiHole,
                                           GetGrades(Improvement.ImprovementSource.Cyberware, true)
                                               .FirstOrDefault(x => x.Name == "None"),
                                           Improvement.ImprovementSource.Cyberware, intCentiessence, lstWeapons,
                                           lstVehicles);

                        Cyberware.Add(objAntiHole);

                        foreach (Weapon objWeapon in lstWeapons)
                        {
                            Weapons.Add(objWeapon);
                        }

                        foreach (Vehicle objVehicle in lstVehicles)
                        {
                            Vehicles.Add(objVehicle);
                        }
                    }
                    else
                    {
                        objAntiHole.Rating += intCentiessence;
                    }

                    if (objAntiHole.Rating == 0 && Cyberware.Contains(objAntiHole))
                        Cyberware.Remove(objAntiHole);
                }

                if (objHole?.Rating == 0 && Cyberware.Contains(objHole))
                    Cyberware.Remove(objHole);
            }
        }

        private decimal _decCachedPrototypeTranshumanEssenceUsed = decimal.MinValue;

        /// <summary>
        /// Essence consumed by Prototype Transhuman 'ware
        /// </summary>
        public decimal PrototypeTranshumanEssenceUsed
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_decCachedPrototypeTranshumanEssenceUsed != decimal.MinValue)
                        return _decCachedPrototypeTranshumanEssenceUsed;
                    // Find the total Essence Cost of all Prototype Transhuman 'ware.
                    if (!IsPrototypeTranshuman)
                        return _decCachedPrototypeTranshumanEssenceUsed = 0.0m;
                    return _decCachedPrototypeTranshumanEssenceUsed = Cyberware
                        .Sum(objCyberware => objCyberware.PrototypeTranshuman,
                             objCyberware => objCyberware.CalculatedESSPrototypeInvariant);
                }
            }
        }

        public string DisplayEssence
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return EssenceDecimal.ToString(Settings.EssenceFormat, GlobalSettings.CultureInfo);
            }
        }

        /// <summary>
        /// This is only here for Reflection
        /// </summary>
        [HubTag("Essence")]
        public decimal EssenceDecimal => Essence();

        public string DisplayCyberwareEssence
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CyberwareEssence.ToString(Settings.EssenceFormat, GlobalSettings.CultureInfo);
            }
        }

        public string DisplayBiowareEssence
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return BiowareEssence.ToString(Settings.EssenceFormat, GlobalSettings.CultureInfo);
            }
        }

        public string DisplayEssenceHole
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return EssenceHole.ToString(Settings.EssenceFormat, GlobalSettings.CultureInfo);
            }
        }

        public string DisplayPrototypeTranshumanEssenceUsed
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                    return PrototypeTranshumanEssenceUsed.ToString(Settings.EssenceFormat, GlobalSettings.CultureInfo)
                           + strSpace + '/' + strSpace +
                           PrototypeTranshuman.ToString(Settings.EssenceFormat, GlobalSettings.CultureInfo);
            }
        }

        #region Initiative

        #region Physical

        /// <summary>
        /// Physical Initiative.
        /// </summary>
        public string Initiative
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return GetInitiative(GlobalSettings.CultureInfo, GlobalSettings.Language);
            }
        }

        public string GetInitiative(CultureInfo objCulture, string strLanguage)
        {
            using (EnterReadLock.Enter(LockObject))
                return string.Format(objCulture, LanguageManager.GetString("String_Initiative", strLanguage),
                                     InitiativeValue.ToString(objCulture),
                                     InitiativeDice.ToString(objCulture));
        }

        public string InitiativeToolTip
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    int intINTAttributeModifiers = INT.AttributeModifiers;
                    int intREAAttributeModifiers = REA.AttributeModifiers;
                    string strSpace = LanguageManager.GetString("String_Space");

                    string strInit = REA.DisplayAbbrev + strSpace + '(' + REA.Value.ToString(GlobalSettings.CultureInfo)
                                     + ')'
                                     + strSpace + '+' + strSpace + INT.DisplayAbbrev + strSpace + '('
                                     + INT.Value.ToString(GlobalSettings.CultureInfo) + ')';
                    if (ImprovementManager.ValueOf(this, Improvement.ImprovementType.Initiative) != 0
                        || intINTAttributeModifiers != 0 || intREAAttributeModifiers != 0 || WoundModifier != 0)
                    {
                        strInit += strSpace + '+' + strSpace + LanguageManager.GetString("Tip_Modifiers") + strSpace
                                   + '('
                                   + (ImprovementManager.ValueOf(this, Improvement.ImprovementType.Initiative)
                                      + intINTAttributeModifiers + intREAAttributeModifiers + WoundModifier)
                                   .ToString(GlobalSettings.CultureInfo) + ')';
                    }

                    return string.Format(GlobalSettings.CultureInfo, LanguageManager.GetString("String_Initiative"),
                                         strInit, InitiativeDice.ToString(GlobalSettings.CultureInfo));
                }
            }
        }

        /// <summary>
        /// Initiative Dice.
        /// </summary>
        [HubTag]
        public int InitiativeDice
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    int intExtraIP = _intInitiativeDice
                                     + ImprovementManager.ValueOf(this, Improvement.ImprovementType.InitiativeDice)
                                                         .StandardRound()
                                     + ImprovementManager.ValueOf(this, Improvement.ImprovementType.InitiativeDiceAdd)
                                                         .StandardRound();

                    return Math.Min(intExtraIP, Settings.MaxInitiativeDice);
                }
            }
        }

        [HubTag]
        public int InitiativeValue
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if ((INT == null) || (REA == null))
                    {
                        Utils.BreakIfDebug();
                        return 0;
                    }

                    int intINI = INT.TotalValue + REA.TotalValue + WoundModifier;
                    intINI += ImprovementManager.ValueOf(this, Improvement.ImprovementType.Initiative).StandardRound();
                    if (intINI < 0)
                        intINI = 0;
                    return intINI;
                }
            }
        }

        #endregion

        #region Astral

        /// <summary>
        /// Astral Initiative.
        /// </summary>
        public string AstralInitiative
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return GetAstralInitiative(GlobalSettings.CultureInfo, GlobalSettings.Language);
            }
        }

        public string GetAstralInitiative(CultureInfo objCulture, string strLanguageToPrint)
        {
            using (EnterReadLock.Enter(LockObject))
                return string.Format(objCulture, LanguageManager.GetString("String_Initiative", strLanguageToPrint),
                                     AstralInitiativeValue.ToString(objCulture),
                                     AstralInitiativeDice.ToString(objCulture));
        }

        public string AstralInitiativeToolTip
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (!MAGEnabled)
                        return string.Empty;
                    int intINTAttributeModifiers = INT.AttributeModifiers;
                    string strSpace = LanguageManager.GetString("String_Space");
                    string strInit = INT.DisplayAbbrev + strSpace + '(' + INT.Value.ToString(GlobalSettings.CultureInfo)
                                     + ')' + strSpace + '' + strSpace + 2.ToString(GlobalSettings.CultureInfo);
                    if (intINTAttributeModifiers != 0 || WoundModifier != 0)
                        strInit += LanguageManager.GetString("Tip_Modifiers") + strSpace + '('
                                   + (intINTAttributeModifiers + WoundModifier).ToString(GlobalSettings.CultureInfo)
                                   + ')';
                    return string.Format(GlobalSettings.CultureInfo, LanguageManager.GetString("String_Initiative"),
                                         strInit, AstralInitiativeDice.ToString(GlobalSettings.CultureInfo));
                }
            }
        }

        /// <summary>
        /// Astral Initiative Value.
        /// </summary>
        public int AstralInitiativeValue
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return (INT.TotalValue * 2) + WoundModifier;
            }
        }

        /// <summary>
        /// Astral Initiative Dice.
        /// </summary>
        public int AstralInitiativeDice
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    int intReturn = Settings.MinAstralInitiativeDice;
                    return Math.Min(intReturn, Settings.MaxAstralInitiativeDice);
                }
            }
        }

        #endregion

        #region Matrix

        #region AR

        /// <summary>
        /// Formatted AR Matrix Initiative.
        /// </summary>
        public string MatrixInitiative
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return GetMatrixInitiative(GlobalSettings.CultureInfo, GlobalSettings.Language);
            }
        }

        public string GetMatrixInitiative(CultureInfo objCulture, string strLanguageToPrint)
        {
            using (EnterReadLock.Enter(LockObject))
                return string.Format(objCulture, LanguageManager.GetString("String_Initiative", strLanguageToPrint),
                                     MatrixInitiativeValue, MatrixInitiativeDice);
        }

        public string MatrixInitiativeToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                {
                    int intINTAttributeModifiers = INT.AttributeModifiers;

                    string strInit;
                    if (IsAI)
                    {
                        strInit = INT.DisplayAbbrev + strSpace + '(' + INT.Value.ToString(GlobalSettings.CultureInfo)
                                  + ')';

                        if (HomeNode != null)
                        {
                            int intHomeNodeDP = HomeNode.GetTotalMatrixAttribute("Data Processing");
                            if (HomeNode is Vehicle objHomeNodeVehicle)
                            {
                                int intHomeNodePilot = objHomeNodeVehicle.Pilot;
                                if (intHomeNodePilot > intHomeNodeDP)
                                    intHomeNodeDP = intHomeNodePilot;
                            }

                            strInit += strSpace + '+' + strSpace + LanguageManager.GetString("String_DataProcessing") +
                                       strSpace + '(' + intHomeNodeDP.ToString(GlobalSettings.CultureInfo) + ')';
                        }

                        if (intINTAttributeModifiers != 0 || WoundModifier != 0)
                        {
                            strInit += strSpace + '+' + strSpace + LanguageManager.GetString("Tip_Modifiers") + strSpace
                                       +
                                       '(' +
                                       (intINTAttributeModifiers + WoundModifier).ToString(GlobalSettings.CultureInfo)
                                       + ')';
                        }
                    }
                    else
                    {
                        int intREAAttributeModifiers = REA.AttributeModifiers;

                        strInit = REA.DisplayAbbrev + strSpace + '(' + REA.Value.ToString(GlobalSettings.CultureInfo)
                                  + ')' +
                                  strSpace + '+' + strSpace + INT.DisplayAbbrev + strSpace + '(' +
                                  INT.Value.ToString(GlobalSettings.CultureInfo) + ')';
                        if (ImprovementManager.ValueOf(this, Improvement.ImprovementType.Initiative) != 0
                            || intINTAttributeModifiers != 0 || intREAAttributeModifiers != 0 || WoundModifier != 0)
                        {
                            strInit += strSpace + '+' + strSpace + LanguageManager.GetString("Tip_Modifiers") + strSpace
                                       +
                                       '(' + (ImprovementManager.ValueOf(this, Improvement.ImprovementType.Initiative) +
                                              intINTAttributeModifiers + intREAAttributeModifiers + WoundModifier)
                                       .ToString(GlobalSettings.CultureInfo) + ')';
                        }
                    }

                    return string.Format(GlobalSettings.CultureInfo, LanguageManager.GetString("String_Initiative"),
                                         strInit, MatrixInitiativeDice);
                }
            }
        }

        /// <summary>
        /// AR Matrix Initiative Value.
        /// </summary>
        public int MatrixInitiativeValue
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        int intINI = (INT.TotalValue) + WoundModifier;
                        if (HomeNode != null)
                        {
                            int intHomeNodeDP = HomeNode.GetTotalMatrixAttribute("Data Processing");
                            if (HomeNode is Vehicle objHomeNodeVehicle)
                            {
                                int intHomeNodePilot = objHomeNodeVehicle.Pilot;
                                if (intHomeNodePilot > intHomeNodeDP)
                                    intHomeNodeDP = intHomeNodePilot;
                            }

                            intINI += intHomeNodeDP;
                        }

                        return intINI;
                    }

                    return InitiativeValue;
                }
            }
        }

        /// <summary>
        /// AR Matrix Initiative Dice.
        /// </summary>
        public int MatrixInitiativeDice
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    int intReturn;
                    // A.I.s always have 4 Matrix Initiative Dice.
                    if (IsAI)
                        intReturn = Settings.MinHotSimInitiativeDice + ImprovementManager
                                                                       .ValueOf(
                                                                           this,
                                                                           Improvement.ImprovementType
                                                                               .MatrixInitiativeDice).StandardRound();
                    else
                        intReturn = InitiativeDice;

                    // Add in any additional Matrix Initiative Pass bonuses.
                    intReturn += ImprovementManager.ValueOf(this, Improvement.ImprovementType.MatrixInitiativeDiceAdd)
                                                   .StandardRound();

                    return Math.Min(intReturn, Settings.MaxInitiativeDice);
                }
            }
        }

        #endregion

        #region Cold Sim

        /// <summary>
        /// Matrix Initiative via VR with Cold Sim.
        /// </summary>
        public string MatrixInitiativeCold
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return GetMatrixInitiativeCold(GlobalSettings.CultureInfo, GlobalSettings.Language);
            }
        }

        public string GetMatrixInitiativeCold(CultureInfo objCulture, string strLanguageToPrint)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (IsAI)
                {
                    return GetMatrixInitiative(objCulture, strLanguageToPrint);
                }

                return string.Format(
                    objCulture,
                    LanguageManager.GetString(ActiveCommlink == null ? "String_MatrixInitiative" : "String_Initiative",
                                              strLanguageToPrint),
                    MatrixInitiativeColdValue, MatrixInitiativeColdDice);
            }
        }

        public string MatrixInitiativeColdToolTip
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        return MatrixInitiativeToolTip;
                    }

                    int intINTAttributeModifiers = INT.AttributeModifiers;

                    string strSpace = LanguageManager.GetString("String_Space");

                    string strInit = INT.DisplayAbbrev + strSpace + '(' + INT.Value.ToString(GlobalSettings.CultureInfo)
                                     + ')';
                    if (ActiveCommlink != null)
                    {
                        strInit += strSpace + '+' + strSpace + LanguageManager.GetString("String_DataProcessing") +
                                   strSpace + '(' + ActiveCommlink.GetTotalMatrixAttribute("Data Processing")
                                                                  .ToString(GlobalSettings.CultureInfo) + ')';
                    }

                    if (ImprovementManager.ValueOf(this, Improvement.ImprovementType.MatrixInitiative) != 0
                        || intINTAttributeModifiers != 0 || WoundModifier != 0)
                    {
                        strInit += strSpace + '+' + strSpace + LanguageManager.GetString("Tip_Modifiers") + strSpace
                                   + '(' +
                                   (ImprovementManager.ValueOf(this, Improvement.ImprovementType.MatrixInitiative) +
                                    intINTAttributeModifiers + WoundModifier).ToString(GlobalSettings.CultureInfo)
                                   + ')';
                    }

                    return string.Format(GlobalSettings.CultureInfo,
                                         LanguageManager.GetString(
                                             ActiveCommlink == null
                                                 ? "String_MatrixInitiativeLong"
                                                 : "String_Initiative"),
                                         strInit, MatrixInitiativeColdDice);
                }
            }
        }

        /// <summary>
        /// Cold Sim Matrix Initiative Value.
        /// </summary>
        public int MatrixInitiativeColdValue
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        return MatrixInitiativeValue;
                    }

                    int intCommlinkDP = ActiveCommlink?.GetTotalMatrixAttribute("Data Processing") ?? 0;
                    return INT.TotalValue + intCommlinkDP + WoundModifier +
                           ImprovementManager.ValueOf(this, Improvement.ImprovementType.MatrixInitiative)
                                             .StandardRound();
                }
            }
        }

        /// <summary>
        /// Cold Sim Matrix Initiative Dice.
        /// </summary>
        public int MatrixInitiativeColdDice
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        return MatrixInitiativeDice;
                    }

                    return Math.Min(
                        Settings.MinColdSimInitiativeDice + ImprovementManager
                                                            .ValueOf(
                                                                this, Improvement.ImprovementType.MatrixInitiativeDice)
                                                            .StandardRound(),
                        Settings.MaxColdSimInitiativeDice);
                }
            }
        }

        #endregion

        #region Hot Sim

        /// <summary>
        /// Matrix Initiative via VR with Hot Sim.
        /// </summary>
        public string MatrixInitiativeHot
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return GetMatrixInitiativeHot(GlobalSettings.CultureInfo, GlobalSettings.Language);
            }
        }

        public string GetMatrixInitiativeHot(CultureInfo objCulture, string strLanguageToPrint)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (IsAI)
                {
                    return GetMatrixInitiative(objCulture, strLanguageToPrint);
                }

                return string.Format(
                    objCulture,
                    LanguageManager.GetString(ActiveCommlink == null ? "String_MatrixInitiative" : "String_Initiative",
                                              strLanguageToPrint),
                    MatrixInitiativeHotValue, MatrixInitiativeHotDice);
            }
        }

        public string MatrixInitiativeHotToolTip
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        return MatrixInitiativeToolTip;
                    }

                    int intINTAttributeModifiers = INT.AttributeModifiers;

                    string strSpace = LanguageManager.GetString("String_Space");

                    string strInit = INT.DisplayAbbrev + strSpace + '(' + INT.Value.ToString(GlobalSettings.CultureInfo)
                                     + ')';
                    if (ActiveCommlink != null)
                    {
                        strInit += strSpace + '+' + strSpace + LanguageManager.GetString("String_DataProcessing") +
                                   strSpace + '(' + ActiveCommlink.GetTotalMatrixAttribute("Data Processing")
                                                                  .ToString(GlobalSettings.CultureInfo) + ')';
                    }

                    if (ImprovementManager.ValueOf(this, Improvement.ImprovementType.MatrixInitiative) != 0
                        || intINTAttributeModifiers != 0 || WoundModifier != 0)
                    {
                        strInit += strSpace + '+' + strSpace + LanguageManager.GetString("Tip_Modifiers") + strSpace
                                   + '(' +
                                   (ImprovementManager.ValueOf(this, Improvement.ImprovementType.MatrixInitiative) +
                                    intINTAttributeModifiers + WoundModifier).ToString(GlobalSettings.CultureInfo)
                                   + ')';
                    }

                    return string.Format(GlobalSettings.CultureInfo,
                                         LanguageManager.GetString(
                                             ActiveCommlink == null
                                                 ? "String_MatrixInitiativeLong"
                                                 : "String_Initiative"),
                                         strInit, MatrixInitiativeHotDice);
                }
            }
        }

        /// <summary>
        /// Hot Sim Matrix Initiative Value.
        /// </summary>
        public int MatrixInitiativeHotValue
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        return MatrixInitiativeValue;
                    }

                    int intCommlinkDP = ActiveCommlink?.GetTotalMatrixAttribute("Data Processing") ?? 0;
                    return INT.TotalValue + intCommlinkDP + WoundModifier +
                           ImprovementManager.ValueOf(this, Improvement.ImprovementType.MatrixInitiative)
                                             .StandardRound();
                }
            }
        }

        /// <summary>
        /// Hot Sim Matrix Initiative Dice.
        /// </summary>
        public int MatrixInitiativeHotDice
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        return MatrixInitiativeDice;
                    }

                    return Math.Min(
                        Settings.MinHotSimInitiativeDice + ImprovementManager
                                                           .ValueOf(
                                                               this, Improvement.ImprovementType.MatrixInitiativeDice)
                                                           .StandardRound(),
                        Settings.MaxHotSimInitiativeDice);
                }
            }
        }

        #endregion

        #region XPath Processing
        /// <summary>
        /// Replaces substring in the form of {Skill} with the total dicepool of the skill.
        /// </summary>
        /// <param name="strInput">Stringbuilder object that contains the input.</param>
        /// <param name="dicValueOverrides">Alternative dictionary to use for value lookup instead of SkillsSection.GetActiveSkill.</param>
        public string ProcessMatrixAttributesInXPath(string strInput, IReadOnlyDictionary<string, int> dicValueOverrides = null)
        {
            if (string.IsNullOrEmpty(strInput))
                return strInput;
            string strReturn = strInput;
            using (EnterReadLock.Enter(LockObject))
            {
                foreach (string strAttributeName in MatrixAttributes.MatrixAttributeStrings)
                {
                    strReturn = strReturn
                        .CheapReplace('{' + strAttributeName + '}', () =>
                                          dicValueOverrides?.ContainsKey(strAttributeName) == true
                                              ? dicValueOverrides[strAttributeName].ToString()
                                              : ActiveCommlink?.GetTotalMatrixAttribute(strAttributeName).ToString());
                }
            }

            return strReturn;
        }

        /// <summary>
        /// Replaces stringbuilder content in the form of {MatrixAttribute} with the total pool of the Matrix Attribute of the Active Commlink, if any.
        /// </summary>
        /// <param name="sbdInput">Stringbuilder object that contains the input.</param>
        /// <param name="dicValueOverrides">Alternative dictionary to use for value lookup instead of SkillsSection.GetActiveSkill.</param>
        public void ProcessMatrixAttributesInXPath(StringBuilder sbdInput, IReadOnlyDictionary<string, int> dicValueOverrides = null)
        {
            if (sbdInput == null || sbdInput.Length <= 0)
                return;
            using (EnterReadLock.Enter(LockObject))
            {
                foreach (string strAttributeName in MatrixAttributes.MatrixAttributeStrings)
                {
                    sbdInput.CheapReplace('{' + strAttributeName + '}', () =>
                                              dicValueOverrides?.ContainsKey(strAttributeName) == true
                                                  ? dicValueOverrides[strAttributeName].ToString()
                                                  : ActiveCommlink?.GetTotalMatrixAttribute(strAttributeName)
                                                                  .ToString());
                }
            }
        }
        #endregion
        #endregion

        #endregion

        /// <summary>
        /// Character's total Spell Resistance from qualities and metatype properties.
        /// </summary>
        public int SpellResistance => ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance).StandardRound();

        #endregion

        #region Special CharacterAttribute Tests

        /// <summary>
        /// Composure (WIL + CHA).
        /// </summary>
        public int Composure
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return WIL.TotalValue + CHA.TotalValue +
                           ImprovementManager.ValueOf(this, Improvement.ImprovementType.Composure).StandardRound()
                           + WoundModifier
                           + SustainingPenalty;
            }
        }

        public string ComposureToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(CHA.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(CHA.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(LanguageManager.GetString("Tip_Skill_Wounds"))
                                  .Append(strSpace).Append('(')
                                  .Append(WoundModifier.ToString(GlobalSettings.CultureInfo))
                                  .Append(')').Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Tip_Skill_Sustain")).Append(strSpace).Append('(')
                                  .Append(SustainingPenalty.ToString(GlobalSettings.CultureInfo)).Append(')');
                        foreach (Improvement objLoopImprovement in
                                 ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.Composure))
                        {
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                      .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        /// <summary>
        /// Judge Intentions (INT + CHA).
        /// </summary>
        public int JudgeIntentions
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return INT.TotalValue + CHA.TotalValue +
                           (ImprovementManager.ValueOf(this, Improvement.ImprovementType.JudgeIntentions)
                            + ImprovementManager.ValueOf(this, Improvement.ImprovementType.JudgeIntentionsOffense))
                           .StandardRound()
                           + SustainingPenalty
                           + WoundModifier;
            }
        }

        public string JudgeIntentionsToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(CHA.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(CHA.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(INT.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(INT.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(LanguageManager.GetString("Tip_Skill_Wounds"))
                                  .Append(strSpace).Append('(')
                                  .Append(WoundModifier.ToString(GlobalSettings.CultureInfo))
                                  .Append(')').Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Tip_Skill_Sustain")).Append(strSpace).Append('(')
                                  .Append(SustainingPenalty.ToString(GlobalSettings.CultureInfo)).Append(')');
                        foreach (Improvement objLoopImprovement in
                                 ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.JudgeIntentions))
                        {
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                      .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');
                        }

                        foreach (Improvement objLoopImprovement in
                                 ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.JudgeIntentionsOffense))
                        {
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                      .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        /// <summary>
        /// Judge Intentions Resist (CHA + WIL).
        /// </summary>
        public int JudgeIntentionsResist
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CHA.TotalValue + WIL.TotalValue +
                           (ImprovementManager.ValueOf(this, Improvement.ImprovementType.JudgeIntentions)
                            + ImprovementManager.ValueOf(this, Improvement.ImprovementType.JudgeIntentionsDefense))
                           .StandardRound();
            }
        }

        public string JudgeIntentionsResistToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(CHA.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(CHA.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');
                        foreach (Improvement objLoopImprovement in
                                 ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.JudgeIntentions))
                        {
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                      .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');
                        }

                        foreach (Improvement objLoopImprovement in
                                 ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.JudgeIntentionsDefense))
                        {
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                      .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        /// <summary>
        /// Lifting and Carrying (STR + BOD).
        /// </summary>
        public int LiftAndCarry
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return STR.TotalValue + BOD.TotalValue +
                           ImprovementManager.ValueOf(this, Improvement.ImprovementType.LiftAndCarry).StandardRound()
                           + WoundModifier
                           + SustainingPenalty;
            }
        }

        public string LiftAndCarryToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(BOD.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(BOD.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(STR.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(STR.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(LanguageManager.GetString("Tip_Skill_Wounds"))
                                  .Append(strSpace).Append('(')
                                  .Append(WoundModifier.ToString(GlobalSettings.CultureInfo))
                                  .Append(')').Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Tip_Skill_Sustain")).Append(strSpace).Append('(')
                                  .Append(SustainingPenalty.ToString(GlobalSettings.CultureInfo)).Append(')');
                        foreach (Improvement objLoopImprovement in
                                 ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.LiftAndCarry))
                        {
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                      .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public string LiftAndCarryLimits
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return string.Format(GlobalSettings.CultureInfo,
                                         LanguageManager.GetString("Label_OtherLiftAndCarryLimitsFormat"),
                                         LiftLimit.ToString(
                                             Settings.WeightFormat, GlobalSettings.CultureInfo),
                                         CarryLimit.ToString(
                                             Settings.WeightFormat, GlobalSettings.CultureInfo));
            }
        }

        /// <summary>
        /// Memory (LOG + WIL).
        /// </summary>
        public int Memory
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return LOG.TotalValue + WIL.TotalValue +
                           ImprovementManager.ValueOf(this, Improvement.ImprovementType.Memory).StandardRound()
                           + WoundModifier
                           + SustainingPenalty;
            }
        }

        public string MemoryToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(LOG.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(LOG.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(LanguageManager.GetString("Tip_Skill_Wounds"))
                                  .Append(strSpace).Append('(')
                                  .Append(WoundModifier.ToString(GlobalSettings.CultureInfo))
                                  .Append(')').Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Tip_Skill_Sustain")).Append(strSpace).Append('(')
                                  .Append(SustainingPenalty.ToString(GlobalSettings.CultureInfo)).Append(')');
                        foreach (Improvement objLoopImprovement in
                                 ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.Memory))
                        {
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                      .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        /// <summary>
        /// Resist test to Fatigue damage (BOD + WIL).
        /// </summary>
        public int FatigueResist
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return BOD.TotalValue + WIL.TotalValue +
                           ImprovementManager.ValueOf(this, Improvement.ImprovementType.FatigueResist).StandardRound();
            }
        }

        /// <summary>
        /// Resist test to Radiation damage (BOD + WIL).
        /// </summary>
        public int RadiationResist
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return BOD.TotalValue + WIL.TotalValue +
                           ImprovementManager.ValueOf(this, Improvement.ImprovementType.RadiationResist)
                                             .StandardRound();
            }
        }

        /// <summary>
        /// Resist test to Sonic Attacks damage (WIL).
        /// </summary>
        public int SonicResist
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return WIL.TotalValue + ImprovementManager.ValueOf(this, Improvement.ImprovementType.SonicResist)
                                                              .StandardRound();
            }
        }

        /// <summary>
        /// Resist test to Contact-vector Toxins (BOD + WIL).
        /// </summary>
        public string ToxinContactResist(string strLanguage, CultureInfo objCulture)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (IsAI || ImprovementManager
                            .GetCachedImprovementListForValueOf(
                                this, Improvement.ImprovementType.ToxinContactImmune).Count > 0)
                    return LanguageManager.GetString("String_Immune", strLanguage);
                return (BOD.TotalValue + WIL.TotalValue +
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.ToxinContactResist)
                                          .StandardRound())
                    .ToString(objCulture);
            }
        }

        /// <summary>
        /// Resist test to Ingestion-vector Toxins (BOD + WIL).
        /// </summary>
        public string ToxinIngestionResist(string strLanguage, CultureInfo objCulture)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (IsAI || ImprovementManager
                            .GetCachedImprovementListForValueOf(
                                this, Improvement.ImprovementType.ToxinIngestionImmune).Count > 0)
                    return LanguageManager.GetString("String_Immune", strLanguage);
                return (BOD.TotalValue + WIL.TotalValue +
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.ToxinIngestionResist)
                                          .StandardRound())
                    .ToString(objCulture);
            }
        }

        /// <summary>
        /// Resist test to Inhalation-vector Toxins (BOD + WIL).
        /// </summary>
        public string ToxinInhalationResist(string strLanguage, CultureInfo objCulture)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (IsAI || ImprovementManager
                            .GetCachedImprovementListForValueOf(
                                this, Improvement.ImprovementType.ToxinInhalationImmune).Count > 0)
                    return LanguageManager.GetString("String_Immune", strLanguage);
                return (BOD.TotalValue + WIL.TotalValue +
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.ToxinInhalationResist)
                                          .StandardRound())
                    .ToString(objCulture);
            }
        }

        /// <summary>
        /// Resist test to Injection-vector Toxins (BOD + WIL).
        /// </summary>
        public string ToxinInjectionResist(string strLanguage, CultureInfo objCulture)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (IsAI || ImprovementManager
                            .GetCachedImprovementListForValueOf(
                                this, Improvement.ImprovementType.ToxinInjectionImmune).Count > 0)
                    return LanguageManager.GetString("String_Immune", strLanguage);
                return (BOD.TotalValue + WIL.TotalValue +
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.ToxinInjectionResist)
                                          .StandardRound())
                    .ToString(objCulture);
            }
        }

        /// <summary>
        /// Resist test to Contact-vector Pathogens (BOD + WIL).
        /// </summary>
        public string PathogenContactResist(string strLanguage, CultureInfo objCulture)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (IsAI || ImprovementManager
                            .GetCachedImprovementListForValueOf(
                                this, Improvement.ImprovementType.PathogenContactImmune).Count > 0)
                    return LanguageManager.GetString("String_Immune", strLanguage);
                return (BOD.TotalValue + WIL.TotalValue +
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.PathogenContactResist)
                                          .StandardRound())
                    .ToString(objCulture);
            }
        }

        /// <summary>
        /// Resist test to Ingestion-vector Pathogens (BOD + WIL).
        /// </summary>
        public string PathogenIngestionResist(string strLanguage, CultureInfo objCulture)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (IsAI || ImprovementManager
                            .GetCachedImprovementListForValueOf(
                                this, Improvement.ImprovementType.PathogenIngestionImmune).Count > 0)
                    return LanguageManager.GetString("String_Immune", strLanguage);
                return (BOD.TotalValue + WIL.TotalValue +
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.PathogenIngestionResist)
                                          .StandardRound())
                    .ToString(objCulture);
            }
        }

        /// <summary>
        /// Resist test to Inhalation-vector Pathogens (BOD + WIL).
        /// </summary>
        public string PathogenInhalationResist(string strLanguage, CultureInfo objCulture)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (IsAI || ImprovementManager
                            .GetCachedImprovementListForValueOf(
                                this, Improvement.ImprovementType.PathogenInhalationImmune).Count > 0)
                    return LanguageManager.GetString("String_Immune", strLanguage);
                return (BOD.TotalValue + WIL.TotalValue +
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.PathogenInhalationResist)
                                          .StandardRound())
                    .ToString(objCulture);
            }
        }

        /// <summary>
        /// Resist test to Injection-vector Pathogens (BOD + WIL).
        /// </summary>
        public string PathogenInjectionResist(string strLanguage, CultureInfo objCulture)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (IsAI || ImprovementManager
                            .GetCachedImprovementListForValueOf(
                                this, Improvement.ImprovementType.PathogenInjectionImmune).Count > 0)
                    return LanguageManager.GetString("String_Immune", strLanguage);
                return (BOD.TotalValue + WIL.TotalValue +
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.PathogenInjectionResist)
                                          .StandardRound())
                    .ToString(objCulture);
            }
        }

        /// <summary>
        /// Resist test to Physiological Addiction (BOD + WIL) if you are not addicted yet.
        /// </summary>
        public int PhysiologicalAddictionResistFirstTime
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return BOD.TotalValue + WIL.TotalValue + ImprovementManager.ValueOf(this,
                                                                                   Improvement.ImprovementType
                                                                                       .PhysiologicalAddictionFirstTime)
                                                                               .StandardRound();
            }
        }

        /// <summary>
        /// Resist test to Psychological Addiction (LOG + WIL) if you are not addicted yet.
        /// </summary>
        public int PsychologicalAddictionResistFirstTime
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return LOG.TotalValue + WIL.TotalValue + ImprovementManager.ValueOf(this,
                                                                                   Improvement.ImprovementType
                                                                                       .PsychologicalAddictionFirstTime)
                                                                               .StandardRound();
            }
        }

        /// <summary>
        /// Resist test to Physiological Addiction (BOD + WIL) if you are already addicted.
        /// </summary>
        public int PhysiologicalAddictionResistAlreadyAddicted
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return BOD.TotalValue + WIL.TotalValue + ImprovementManager.ValueOf(this,
                                                                                   Improvement.ImprovementType
                                                                                       .PhysiologicalAddictionAlreadyAddicted)
                                                                               .StandardRound();
            }
        }

        /// <summary>
        /// Resist test to Psychological Addiction (LOG + WIL) if you are already addicted.
        /// </summary>
        public int PsychologicalAddictionResistAlreadyAddicted
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return LOG.TotalValue + WIL.TotalValue + ImprovementManager.ValueOf(this,
                                                                                   Improvement.ImprovementType
                                                                                       .PsychologicalAddictionAlreadyAddicted)
                                                                               .StandardRound();
            }
        }

        /// <summary>
        /// Dicepool for natural recovery from Stun CM box damage (BOD + WIL).
        /// </summary>
        public int StunCMNaturalRecovery
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    // Matrix damage for A.I.s is not naturally repaired
                    if (IsAI)
                        return 0;
                    int intReturn = BOD.TotalValue + WIL.TotalValue +
                                    ImprovementManager.ValueOf(this, Improvement.ImprovementType.StunCMRecovery)
                                                      .StandardRound();
                    if (ImprovementManager
                        .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.AddESStoStunCMRecovery)
                        .Count
                        > 0)
                        intReturn += Essence().ToInt32();
                    return intReturn;
                }
            }
        }

        /// <summary>
        /// Dicepool for natural recovery from Physical CM box damage (2 x BOD).
        /// </summary>
        public int PhysicalCMNaturalRecovery
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        if (HomeNode is Vehicle)
                            return 0;

                        // A.I.s can restore Core damage via Software + Depth [Data Processing] (1 day) Extended Test
                        int intAIReturn =
                            (SkillsSection.GetActiveSkill("Software")?.PoolOtherAttribute("DEP") ??
                             DEP.TotalValue - 1) +
                            ImprovementManager.ValueOf(this, Improvement.ImprovementType.PhysicalCMRecovery)
                                              .StandardRound();
                        if (ImprovementManager
                            .GetCachedImprovementListForValueOf(
                                this, Improvement.ImprovementType.AddESStoPhysicalCMRecovery).Count
                            > 0)
                            intAIReturn += Essence().ToInt32();
                        return intAIReturn;
                    }

                    int intReturn = 2 * BOD.TotalValue +
                                    ImprovementManager.ValueOf(this, Improvement.ImprovementType.PhysicalCMRecovery)
                                                      .StandardRound();
                    if (ImprovementManager
                        .GetCachedImprovementListForValueOf(
                            this, Improvement.ImprovementType.AddESStoPhysicalCMRecovery).Count
                        > 0)
                        intReturn += Essence().ToInt32();
                    return intReturn;
                }
            }
        }

        #endregion

        #region Reputation

        /// <summary>
        /// Amount of Street Cred the character has earned through standard means.
        /// </summary>
        public int CalculatedStreetCred
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    // Street Cred = Career Karma / 10, rounded down
                    int intReturn = CareerKarma /
                                    (10 + ImprovementManager.ValueOf(this,
                                                                     Improvement.ImprovementType.StreetCredMultiplier)
                                                            .StandardRound());

                    // Deduct burnt Street Cred.
                    intReturn -= BurntStreetCred;

                    return intReturn;
                }
            }
        }

        /// <summary>
        /// Character's total amount of Street Cred (earned + GM awarded).
        /// </summary>
        public int TotalStreetCred
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return Math.Max(
                        CalculatedStreetCred + StreetCred +
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.StreetCred).StandardRound(), 0);
            }
        }

        public string CareerDisplayStreetCred
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    int intTotalStreetCred = TotalStreetCred;
                    int intCalculatedStreetCred = intTotalStreetCred - StreetCred;
                    return (intCalculatedStreetCred >= 0
                               ? " + " + intCalculatedStreetCred.ToString(GlobalSettings.CultureInfo)
                               : " - " + (-intCalculatedStreetCred).ToString(GlobalSettings.CultureInfo)) + " = " +
                           intTotalStreetCred.ToString(GlobalSettings.CultureInfo);
                }
            }
        }

        public bool CanBurnStreetCred
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return Created && TotalStreetCred >= 2;
            }
        }

        /// <summary>
        /// Street Cred Tooltip.
        /// </summary>
        public string StreetCredTooltip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdReturn))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdReturn.Append(StreetCred.ToString(GlobalSettings.CultureInfo));

                        foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.StreetCred))
                        {
                            sbdReturn.Append(strSpace).Append('+').Append(strSpace)
                                     .Append(GetObjectName(objImprovement))
                                     .Append(strSpace).Append('(')
                                     .Append(objImprovement.Value.ToString(GlobalSettings.CultureInfo)).Append(')');
                        }

                        sbdReturn.Append(strSpace).Append('+').Append(strSpace).Append('[')
                                 .Append(LanguageManager.GetString("String_CareerKarma")).Append(strSpace).Append('')
                                 .Append(strSpace)
                                 .Append((10 + ImprovementManager.ValueOf(
                                             this, Improvement.ImprovementType.StreetCredMultiplier))
                                         .ToString(GlobalSettings.CultureInfo)).Append(']').Append(strSpace).Append('(')
                                 .Append(
                                     (CareerKarma
                                      / (10 + ImprovementManager.ValueOf(
                                          this, Improvement.ImprovementType.StreetCredMultiplier)))
                                     .ToString(GlobalSettings.CultureInfo)).Append(')');

                        if (BurntStreetCred != 0)
                            sbdReturn.Append(strSpace).Append('-').Append(strSpace)
                                     .Append(LanguageManager.GetString("String_BurntStreetCred")).Append(strSpace)
                                     .Append('(')
                                     .Append(BurntStreetCred.ToString(GlobalSettings.CultureInfo)).Append(')');
                    }

                    return sbdReturn.ToString();
                }
            }
        }

        /// <summary>
        /// Amount of Notoriety the character has earned through standard means.
        /// </summary>
        public int CalculatedNotoriety
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    // Notoriety is simply the total value of Notoriety Improvements + the number of Enemies they have.
                    int intReturn = ImprovementManager.ValueOf(this, Improvement.ImprovementType.Notoriety)
                                                      .StandardRound() -
                                    (BurntStreetCred / 2); // + Contacts.Count(x => x.EntityType == ContactType.Enemy);

                    return intReturn;
                }
            }
        }

        /// <summary>
        /// Character's total amount of Notoriety (earned + GM awarded - burnt Street Cred).
        /// </summary>
        public int TotalNotoriety
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CalculatedNotoriety + Notoriety;
            }
        }

        public string CareerDisplayNotoriety
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                {
                    int intCalculatedNotoriety = CalculatedNotoriety;
                    return (intCalculatedNotoriety >= 0
                               ? strSpace + '+' + strSpace +
                                 intCalculatedNotoriety.ToString(GlobalSettings.CultureInfo)
                               : strSpace + '-' + strSpace +
                                 (-intCalculatedNotoriety).ToString(GlobalSettings.CultureInfo)) + strSpace + '=' +
                           strSpace + TotalNotoriety.ToString(GlobalSettings.CultureInfo);
                }
            }
        }

        /// <summary>
        /// Tooltip to use for Notoriety total.
        /// </summary>
        public string NotorietyTooltip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdReturn))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdReturn.Append(Notoriety.ToString(GlobalSettings.CultureInfo));

                        foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.Notoriety))
                        {
                            sbdReturn.Append(strSpace).Append('+').Append(strSpace)
                                     .Append(GetObjectName(objImprovement))
                                     .Append(strSpace).Append('(')
                                     .Append(objImprovement.Value.ToString(GlobalSettings.CultureInfo)).Append(')');
                        }

                        if (BurntStreetCred > 0)
                            sbdReturn.Append(strSpace).Append('-').Append(strSpace)
                                     .Append(LanguageManager.GetString("String_BurntStreetCred")).Append(
                                         strSpace).Append('(')
                                     .Append((BurntStreetCred / 2).ToString(GlobalSettings.CultureInfo)).Append(')');
                    }

                    return sbdReturn.ToString();
                }
            }
        }

        /// <summary>
        /// Amount of Public Awareness the character has earned through standard means.
        /// </summary>
        public int CalculatedPublicAwareness
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    int intReturn = ImprovementManager.ValueOf(this, Improvement.ImprovementType.PublicAwareness)
                                                      .StandardRound();
                    if (Settings.UseCalculatedPublicAwareness)
                    {
                        // Public Awareness is calculated as (Street Cred + Notoriety) / 3, rounded down.
                        intReturn += (TotalStreetCred + TotalNotoriety) / 3;
                    }

                    return intReturn;
                }
            }
        }

        /// <summary>
        /// Character's total amount of Public Awareness (earned + GM awarded).
        /// </summary>
        public int TotalPublicAwareness
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    int intReturn = PublicAwareness + CalculatedPublicAwareness;
                    if (Erased && intReturn >= 1)
                        return 1;
                    return intReturn;
                }
            }
        }

        public string CareerDisplayPublicAwareness
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                {
                    int intTotalPublicAwareness = TotalPublicAwareness;
                    int intCalculatedPublicAwareness = intTotalPublicAwareness - PublicAwareness;
                    return (intCalculatedPublicAwareness >= 0
                               ? strSpace + '+' + strSpace +
                                 intCalculatedPublicAwareness.ToString(GlobalSettings.CultureInfo)
                               : strSpace + '-' + strSpace +
                                 (-intCalculatedPublicAwareness).ToString(GlobalSettings.CultureInfo)) + strSpace +
                           '=' + strSpace + intTotalPublicAwareness.ToString(GlobalSettings.CultureInfo);
                }
            }
        }

        /// <summary>
        /// Public Awareness Tooltip.
        /// </summary>
        public string PublicAwarenessTooltip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdReturn))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdReturn.Append(PublicAwareness.ToString(GlobalSettings.CultureInfo));

                        foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.PublicAwareness))
                        {
                            sbdReturn.Append(strSpace).Append('+').Append(strSpace)
                                     .Append(GetObjectName(objImprovement))
                                     .Append(strSpace).Append('(')
                                     .Append(objImprovement.Value.ToString(GlobalSettings.CultureInfo)).Append(')');
                        }

                        if (Settings.UseCalculatedPublicAwareness)
                        {
                            sbdReturn.Append(strSpace).Append('+').Append(strSpace).Append('[')
                                     .Append(LanguageManager.GetString("String_StreetCred")).Append(strSpace)
                                     .Append('+')
                                     .Append(strSpace).Append(LanguageManager.GetString("String_Notoriety")).Append(']')
                                     .Append(strSpace).Append('').Append(strSpace)
                                     .Append(3.ToString(GlobalSettings.CultureInfo)).Append(strSpace).Append('(')
                                     .Append(((TotalStreetCred + TotalNotoriety) / 3).ToString(
                                                 GlobalSettings.CultureInfo))
                                     .Append(')');
                        }

                        if (Erased)
                        {
                            int intTotalPublicAwareness = PublicAwareness + CalculatedPublicAwareness;
                            if (intTotalPublicAwareness > 1)
                            {
                                string strErasedString = Qualities.FirstOrDefault(x => x.Name == "Erased")
                                                                  ?.CurrentDisplayNameShort;
                                if (string.IsNullOrEmpty(strErasedString))
                                {
                                    XPathNavigator xmlErasedQuality = LoadDataXPath("qualities.xml")
                                        .SelectSingleNode("chummer/qualities/quality[name = \"Erased\"]");
                                    if (xmlErasedQuality != null)
                                    {
                                        strErasedString
                                            = xmlErasedQuality.SelectSingleNodeAndCacheExpression("translate")?.Value
                                              ?? "Erased";
                                    }
                                }

                                sbdReturn.Append(strSpace).Append('-').Append(strSpace).Append(strErasedString)
                                         .Append(strSpace)
                                         .Append('(')
                                         .Append((intTotalPublicAwareness - 1).ToString(GlobalSettings.CultureInfo))
                                         .Append(')');
                            }
                        }
                    }

                    return sbdReturn.ToString();
                }
            }
        }

        #endregion

        #region List Properties

        /// <summary>
        /// Improvements.
        /// </summary>
        public ThreadSafeObservableCollection<Improvement> Improvements
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstImprovements;
            }
        }

        /// <summary>
        /// Improvements.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<Improvement>> GetImprovementsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _lstImprovements;
        }

        /// <summary>
        /// Mentor spirits.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<MentorSpirit> MentorSpirits
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstMentorSpirits;
            }
        }

        /// <summary>
        /// Contacts and Enemies.
        /// </summary>
        public ThreadSafeObservableCollection<Contact> Contacts
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstContacts;
            }
        }

        public async ValueTask<ThreadSafeObservableCollection<Contact>> GetContactsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _lstContacts;
        }

        /// <summary>
        /// Spirits and Sprites.
        /// </summary>
        public ThreadSafeObservableCollection<Spirit> Spirits
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstSpirits;
            }
        }

        /// <summary>
        /// Spirits and Sprites.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<Spirit>> GetSpiritsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _lstSpirits;
        }

        /// <summary>
        /// Magician Spells.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<Spell> Spells
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstSpells;
            }
        }

        /// <summary>
        /// Magician Spells.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<Spell>> GetSpellsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _lstSpells;
        }

        /// <summary>
        /// Sustained Spells
        /// </summary>
        public ThreadSafeObservableCollection<SustainedObject> SustainedCollection
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstSustainedObjects;
            }
        }

        /// <summary>
        /// Sustained Spells.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<SustainedObject>> GetSustainedCollectionAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _lstSustainedObjects;
        }

        /// <summary>
        /// Foci.
        /// </summary>
        public ThreadSafeList<Focus> Foci
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstFoci;
            }
        }

        /// <summary>
        /// Foci.
        /// </summary>
        public async ValueTask<ThreadSafeList<Focus>> GetFociAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _lstFoci;
        }

        /// <summary>
        /// Stacked Foci.
        /// </summary>
        public ThreadSafeList<StackedFocus> StackedFoci
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstStackedFoci;
            }
        }

        /// <summary>
        /// Stacked Foci.
        /// </summary>
        public async ValueTask<ThreadSafeList<StackedFocus>> GetStackedFociAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _lstStackedFoci;
        }

        /// <summary>
        /// Adept Powers.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeBindingList<Power> Powers
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstPowers;
            }
        }

        /// <summary>
        /// Adept Powers.
        /// </summary>
        public async ValueTask<ThreadSafeBindingList<Power>> GetPowersAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _lstPowers;
        }

        /// <summary>
        /// Technomancer Complex Forms.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<ComplexForm> ComplexForms
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstComplexForms;
            }
        }

        /// <summary>
        /// Technomancer Complex Forms.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<ComplexForm>> GetComplexFormsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _lstComplexForms;
        }

        /// <summary>
        /// AI Programs and Advanced Programs
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<AIProgram> AIPrograms
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstAIPrograms;
            }
        }

        /// <summary>
        /// AI Programs and Advanced Programs
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<AIProgram>> GetAIProgramsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _lstAIPrograms;
        }

        /// <summary>
        /// Martial Arts.
        /// </summary>
        public ThreadSafeObservableCollection<MartialArt> MartialArts
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstMartialArts;
            }
        }

        /// <summary>
        /// Martial Arts.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<MartialArt>> GetMartialArtsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _lstMartialArts;
        }

        /// <summary>
        /// Limit Modifiers.
        /// </summary>
        public ThreadSafeObservableCollection<LimitModifier> LimitModifiers
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstLimitModifiers;
            }
        }

        /// <summary>
        /// Limit Modifiers.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<LimitModifier>> GetLimitModifiersAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _lstLimitModifiers;
        }

        /// <summary>
        /// Armor.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<Armor> Armor
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstArmor;
            }
        }

        /// <summary>
        /// Armor.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<Armor>> GetArmorAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _lstArmor;
        }

        /// <summary>
        /// Cyberware and Bioware.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<Cyberware> Cyberware
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstCyberware;
            }
        }

        /// <summary>
        /// Cyberware and Bioware.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<Cyberware>> GetCyberwareAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _lstCyberware;
        }

        /// <summary>
        /// Weapons.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<Weapon> Weapons
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstWeapons;
            }
        }

        /// <summary>
        /// Weapons.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<Weapon>> GetWeaponsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _lstWeapons;
        }

        /// <summary>
        /// Lifestyles.
        /// </summary>
        public ThreadSafeObservableCollection<Lifestyle> Lifestyles
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstLifestyles;
            }
        }

        /// <summary>
        /// Lifestyles.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<Lifestyle>> GetLifestylesAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _lstLifestyles;
        }

        /// <summary>
        /// Gear.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<Gear> Gear
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstGear;
            }
        }

        /// <summary>
        /// Gear.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<Gear>> GetGearAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _lstGear;
        }

        /// <summary>
        /// Vehicles.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<Vehicle> Vehicles
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstVehicles;
            }
        }

        /// <summary>
        /// Vehicles.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<Vehicle>> GetVehiclesAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _lstVehicles;
        }

        /// <summary>
        /// Metamagics and Echoes.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<Metamagic> Metamagics
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstMetamagics;
            }
        }

        /// <summary>
        /// Metamagics and Echoes.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<Metamagic>> GetMetamagicsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _lstMetamagics;
        }

        /// <summary>
        /// Enhancements.
        /// </summary>
        public ThreadSafeObservableCollection<Enhancement> Enhancements
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstEnhancements;
            }
        }

        /// <summary>
        /// Enhancements.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<Enhancement>> GetEnhancementsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _lstEnhancements;
        }

        /// <summary>
        /// Arts.
        /// </summary>
        public ThreadSafeObservableCollection<Art> Arts
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstArts;
            }
        }

        /// <summary>
        /// Arts.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<Art>> GetArtsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _lstArts;
        }

        /// <summary>
        /// Critter Powers.
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<CritterPower> CritterPowers
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstCritterPowers;
            }
        }

        /// <summary>
        /// Critter Powers.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<CritterPower>> GetCritterPowersAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _lstCritterPowers;
        }

        /// <summary>
        /// Initiation and Submersion Grades.
        /// </summary>
        public ThreadSafeObservableCollection<InitiationGrade> InitiationGrades
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstInitiationGrades;
            }
        }

        /// <summary>
        /// Initiation and Submersion Grades.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<InitiationGrade>> GetInitiationGradesAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _lstInitiationGrades;
        }

        /// <summary>
        /// Expenses (Karma and Nuyen).
        /// </summary>
        public ThreadSafeObservableCollection<ExpenseLogEntry> ExpenseEntries
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstExpenseLog;
            }
        }

        /// <summary>
        /// Qualities (Positive and Negative).
        /// </summary>
        [HubTag(true)]
        public ThreadSafeObservableCollection<Quality> Qualities
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstQualities;
            }
        }

        /// <summary>
        /// Qualities (Positive and Negative).
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<Quality>> GetQualitiesAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _lstQualities;
        }

        /*
        /// <summary>
        /// Life modules
        /// </summary>
        public List<LifeModule> LifeModules
        {
            get { return _lstLifeModules; }
        }
        */

        /// <summary>
        /// Locations.
        /// </summary>
        public ThreadSafeObservableCollection<Location> GearLocations
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstGearLocations;
            }
        }

        /// <summary>
        /// Armor Bundles.
        /// </summary>
        public ThreadSafeObservableCollection<Location> ArmorLocations
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstArmorLocations;
            }
        }

        /// <summary>
        /// Vehicle Locations.
        /// </summary>
        public ThreadSafeObservableCollection<Location> VehicleLocations
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstVehicleLocations;
            }
        }

        /// <summary>
        /// Weapon Locations.
        /// </summary>
        public ThreadSafeObservableCollection<Location> WeaponLocations
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstWeaponLocations;
            }
        }

        /// <summary>
        /// Improvement Groups.
        /// </summary>
        public ThreadSafeObservableCollection<string> ImprovementGroups
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstImprovementGroups;
            }
        }

        /// <summary>
        /// Calendar.
        /// </summary>
        public ThreadSafeBindingList<CalendarWeek> Calendar
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstCalendar;
            }
        }

        /// <summary>
        /// List of internal IDs that need their improvements re-applied.
        /// </summary>
        public ThreadSafeList<string> InternalIdsNeedingReapplyImprovements
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstInternalIdsNeedingReapplyImprovements;
            }
        }

        #endregion

        #region Armor Properties

        public int GetArmorRating(Improvement.ImprovementType eDamageType = Improvement.ImprovementType.Armor)
        {
            return GetArmorRatingWithImprovement(eDamageType, out int _, out List<Improvement> _);
        }

        public int GetArmorRatingWithImprovement(Improvement.ImprovementType eDamageType, out int intFromEquippedArmorImprovements, out List<Improvement> lstUsedImprovements)
        {
            intFromEquippedArmorImprovements = 0;
            if (eDamageType == Improvement.ImprovementType.None)
            {
                lstUsedImprovements = new List<Improvement>();
                return 0;
            }

            using (EnterReadLock.Enter(LockObject))
            {
                List<Armor> lstArmorsToConsider = Armor.Where(objArmor => objArmor.Equipped).ToList();
                decimal decBaseArmorImprovement
                    = ImprovementManager.ValueOf(this, eDamageType, out lstUsedImprovements);
                if (eDamageType != Improvement.ImprovementType.Armor)
                {
                    decBaseArmorImprovement += ImprovementManager.ValueOf(
                        this, Improvement.ImprovementType.Armor, out List<Improvement> lstUsedImprovementsExtra);
                    lstUsedImprovements.AddRange(lstUsedImprovementsExtra);
                }

                if (lstArmorsToConsider.Count == 0)
                    return decBaseArmorImprovement.StandardRound();
                decimal decGeneralArmorImprovementValue = decBaseArmorImprovement;
                Dictionary<Armor, decimal> dicArmorImprovementValues
                    = lstArmorsToConsider.ToDictionary(x => x, y => decBaseArmorImprovement);
                foreach (Improvement objImprovement in lstUsedImprovements)
                {
                    if (objImprovement.ImproveSource != Improvement.ImprovementSource.Armor &&
                        objImprovement.ImproveSource != Improvement.ImprovementSource.ArmorMod)
                        continue;
                    Armor objSourceArmor =
                        lstArmorsToConsider.Find(x => x.InternalId == objImprovement.SourceName)
                        ?? lstArmorsToConsider.FindArmorMod(objImprovement.SourceName)?.Parent;
                    if (objSourceArmor == null)
                        continue;
                    decGeneralArmorImprovementValue -= objImprovement.Value;
                    foreach (Armor objArmor in lstArmorsToConsider)
                    {
                        if (objArmor != objSourceArmor)
                            dicArmorImprovementValues[objArmor] -= objImprovement.Value;
                    }
                }

                Armor objHighestArmor = null;
                int intHighest = 0;
                int intHighestNoCustomStack = 0;
                // Run through the list of Armor currently worn and retrieve the highest total Armor rating.
                // This is used for Custom-Fit armour's stacking.
                foreach (Armor objArmor in lstArmorsToConsider)
                {
                    if (objArmor.ArmorValue.StartsWith('+')
                        || objArmor.ArmorValue.StartsWith('-'))
                        continue;
                    int intCustomStackBonus = 0;
                    string strArmorName = objArmor.Name;
                    foreach (Armor objInnerArmor in lstArmorsToConsider)
                    {
                        if (objInnerArmor == objArmor)
                            continue;
                        if (!objInnerArmor.ArmorOverrideValue.StartsWith('+')
                            && !objInnerArmor.ArmorOverrideValue.StartsWith('-'))
                            continue;
                        if (objInnerArmor.ArmorMods.Any(objMod => objMod.Name == "Custom Fit (Stack)"
                                                                  && objMod.Extra == strArmorName
                                                                  && objMod.Equipped))
                            intCustomStackBonus += objInnerArmor.TotalOverrideArmor;
                    }

                    int intArmorValue = objArmor.TotalArmor + dicArmorImprovementValues[objArmor].StandardRound();
                    if (intArmorValue + intCustomStackBonus > intHighest)
                    {
                        intHighest = intArmorValue + intCustomStackBonus;
                        intFromEquippedArmorImprovements
                            = (dicArmorImprovementValues[objArmor] - decGeneralArmorImprovementValue).StandardRound();
                        intHighestNoCustomStack = intArmorValue;
                        objHighestArmor = objArmor;
                    }
                }

                int intArmor = objHighestArmor != null
                    ? intHighestNoCustomStack
                    : decGeneralArmorImprovementValue.StandardRound();

                // Run through the list of Armor currently worn again and look at armors that start with '+' since they stack with the highest Armor.
                int intStacking = 0;
                foreach (Armor objArmor in lstArmorsToConsider)
                {
                    if (!objArmor.ArmorValue.StartsWith('+')
                        && !objArmor.ArmorValue.StartsWith('-')
                        && !objArmor.ArmorOverrideValue.StartsWith('+')
                        && !objArmor.ArmorOverrideValue.StartsWith('-')
                        || objArmor == objHighestArmor)
                        continue;
                    bool blnDoAdd = true;
                    bool blnCustomFit = false;
                    if (objHighestArmor != null)
                    {
                        foreach (ArmorMod objMod in objArmor.ArmorMods)
                        {
                            if (objMod.Name == "Custom Fit (Stack)")
                            {
                                blnDoAdd = objMod.Extra == objHighestArmor.Name && objMod.Equipped;
                                blnCustomFit = true;
                                break;
                            }
                        }
                    }

                    if (blnDoAdd)
                    {
                        if (!blnCustomFit
                            && (objArmor.ArmorValue.StartsWith('+') || objArmor.ArmorValue.StartsWith('-')))
                            intStacking += objArmor.TotalArmor;
                        else
                            intStacking += objArmor.TotalOverrideArmor;
                    }
                }

                return intArmor + intStacking;
            }
        }

        public async ValueTask<int> GetArmorRatingAsync(Improvement.ImprovementType eDamageType = Improvement.ImprovementType.Armor, CancellationToken token = default)
        {
            return (await GetArmorRatingWithImprovementAsync(eDamageType, token)).Item1;
        }

        public async ValueTask<Tuple<int, int, List<Improvement>>> GetArmorRatingWithImprovementAsync(Improvement.ImprovementType eDamageType, CancellationToken token = default)
        {
            if (eDamageType == Improvement.ImprovementType.None)
            {
                return new Tuple<int, int, List<Improvement>>(0, 0, new List<Improvement>());
            }

            int intFromEquippedArmorImprovements = 0;
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                List<Armor> lstArmorsToConsider = await (await GetArmorAsync(token)).ToListAsync(objArmor => objArmor.Equipped, token: token);
                (decimal decBaseArmorImprovement, List<Improvement> lstUsedImprovements)
                    = await ImprovementManager.ValueOfTupleAsync(this, eDamageType, token: token);
                if (eDamageType != Improvement.ImprovementType.Armor)
                {
                    (decimal decExtra, List<Improvement> lstUsedImprovementsExtra)
                        = await ImprovementManager.ValueOfTupleAsync(this, Improvement.ImprovementType.Armor, token: token);
                    decBaseArmorImprovement += decExtra;
                    lstUsedImprovements.AddRange(lstUsedImprovementsExtra);
                }

                if (lstArmorsToConsider.Count == 0)
                    return new Tuple<int, int, List<Improvement>>(decBaseArmorImprovement.StandardRound(), intFromEquippedArmorImprovements, lstUsedImprovements);
                decimal decGeneralArmorImprovementValue = decBaseArmorImprovement;
                Dictionary<Armor, decimal> dicArmorImprovementValues
                    = lstArmorsToConsider.ToDictionary(x => x, y => decBaseArmorImprovement);
                foreach (Improvement objImprovement in lstUsedImprovements)
                {
                    if (objImprovement.ImproveSource != Improvement.ImprovementSource.Armor &&
                        objImprovement.ImproveSource != Improvement.ImprovementSource.ArmorMod)
                        continue;
                    Armor objSourceArmor =
                        lstArmorsToConsider.Find(x => x.InternalId == objImprovement.SourceName)
                        ?? lstArmorsToConsider.FindArmorMod(objImprovement.SourceName)?.Parent;
                    if (objSourceArmor == null)
                        continue;
                    decGeneralArmorImprovementValue -= objImprovement.Value;
                    foreach (Armor objArmor in lstArmorsToConsider)
                    {
                        if (objArmor != objSourceArmor)
                            dicArmorImprovementValues[objArmor] -= objImprovement.Value;
                    }
                }

                Armor objHighestArmor = null;
                int intHighest = 0;
                int intHighestNoCustomStack = 0;
                // Run through the list of Armor currently worn and retrieve the highest total Armor rating.
                // This is used for Custom-Fit armour's stacking.
                foreach (Armor objArmor in lstArmorsToConsider)
                {
                    if (objArmor.ArmorValue.StartsWith('+')
                        || objArmor.ArmorValue.StartsWith('-'))
                        continue;
                    int intCustomStackBonus = 0;
                    string strArmorName = objArmor.Name;
                    foreach (Armor objInnerArmor in lstArmorsToConsider)
                    {
                        if (objInnerArmor == objArmor)
                            continue;
                        if (!objInnerArmor.ArmorOverrideValue.StartsWith('+')
                            && !objInnerArmor.ArmorOverrideValue.StartsWith('-'))
                            continue;
                        if (objInnerArmor.ArmorMods.Any(objMod => objMod.Name == "Custom Fit (Stack)"
                                                                  && objMod.Extra == strArmorName
                                                                  && objMod.Equipped))
                            intCustomStackBonus += objInnerArmor.TotalOverrideArmor;
                    }

                    int intArmorValue = objArmor.TotalArmor + dicArmorImprovementValues[objArmor].StandardRound();
                    if (intArmorValue + intCustomStackBonus > intHighest)
                    {
                        intHighest = intArmorValue + intCustomStackBonus;
                        intFromEquippedArmorImprovements
                            = (dicArmorImprovementValues[objArmor] - decGeneralArmorImprovementValue).StandardRound();
                        intHighestNoCustomStack = intArmorValue;
                        objHighestArmor = objArmor;
                    }
                }

                int intArmor = objHighestArmor != null
                    ? intHighestNoCustomStack
                    : decGeneralArmorImprovementValue.StandardRound();

                // Run through the list of Armor currently worn again and look at armors that start with '+' since they stack with the highest Armor.
                int intStacking = 0;
                foreach (Armor objArmor in lstArmorsToConsider)
                {
                    if (!objArmor.ArmorValue.StartsWith('+')
                        && !objArmor.ArmorValue.StartsWith('-')
                        && !objArmor.ArmorOverrideValue.StartsWith('+')
                        && !objArmor.ArmorOverrideValue.StartsWith('-')
                        || objArmor == objHighestArmor)
                        continue;
                    bool blnDoAdd = true;
                    bool blnCustomFit = false;
                    if (objHighestArmor != null)
                    {
                        foreach (ArmorMod objMod in objArmor.ArmorMods)
                        {
                            if (objMod.Name == "Custom Fit (Stack)")
                            {
                                blnDoAdd = objMod.Extra == objHighestArmor.Name && objMod.Equipped;
                                blnCustomFit = true;
                                break;
                            }
                        }
                    }

                    if (blnDoAdd)
                    {
                        if (!blnCustomFit
                            && (objArmor.ArmorValue.StartsWith('+') || objArmor.ArmorValue.StartsWith('-')))
                            intStacking += objArmor.TotalArmor;
                        else
                            intStacking += objArmor.TotalOverrideArmor;
                    }
                }

                return new Tuple<int, int, List<Improvement>>(intArmor + intStacking, intFromEquippedArmorImprovements, lstUsedImprovements);
            }
        }

        public int DamageResistancePool
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    int intBody = 0;
                    if (IsAI)
                    {
                        if (HomeNode is Vehicle objVehicle)
                            intBody = objVehicle.TotalBody;
                    }
                    else
                        intBody = BOD.TotalValue;

                    return intBody +
                           TotalArmorRating +
                           ImprovementManager.ValueOf(this, Improvement.ImprovementType.DamageResistance)
                                             .StandardRound();
                }
            }
        }

        public string DamageResistancePoolToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                {
                    int intBody;
                    string strBodyAbbrev;
                    if (IsAI)
                    {
                        intBody = HomeNode is Vehicle objVehicle ? objVehicle.TotalBody : 0;
                        strBodyAbbrev = LanguageManager.GetString("String_VehicleBody");
                    }
                    else
                    {
                        intBody = BOD.TotalValue;
                        strBodyAbbrev = BOD.DisplayAbbrev;
                    }

                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append(strBodyAbbrev).Append(strSpace).Append('(')
                                  .Append(intBody.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                                  .Append('+').Append(strSpace).Append(LanguageManager.GetString("Tip_Armor"))
                                  .Append(strSpace).Append('(')
                                  .Append(TotalArmorRating.ToString(GlobalSettings.CultureInfo)).Append(')');

                        foreach (Improvement objLoopImprovement in
                                 ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.DamageResistance))
                        {
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                      .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        public int CurrentCounterspellingDice
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intCurrentCounterspellingDice;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCurrentCounterspellingDice == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _intCurrentCounterspellingDice = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        public int CurrentLiftCarryHits
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intCurrentLiftCarryHits;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCurrentLiftCarryHits == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _intCurrentLiftCarryHits = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        #region Dodge
        public int Dodge
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return REA.TotalValue + INT.TotalValue + TotalBonusDodgeRating + WoundModifier + SustainingPenalty;
            }
        }

        public string DisplayDodge
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return Dodge.ToString(GlobalSettings.CultureInfo);
            }
        }

        public string DodgeToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(REA.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(REA.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(INT.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(INT.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(LanguageManager.GetString("Tip_Skill_Wounds"))
                                  .Append(strSpace).Append('(')
                                  .Append(WoundModifier.ToString(GlobalSettings.CultureInfo))
                                  .Append(')').Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Tip_Skill_Sustain")).Append(strSpace).Append('(')
                                  .Append(SustainingPenalty.ToString(GlobalSettings.CultureInfo)).Append(')');

                        int intModifiers = TotalBonusDodgeRating;

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                Improvement.ImprovementType.Dodge.Yield(),
                                strSpace,
                                intModifiers);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }
        #endregion
        #region Spell Defense
        #region Indirect Dodge
        public int SpellDefenseIndirectDodge
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return Dodge;
            }
        }

        public string DisplaySpellDefenseIndirectDodge
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseIndirectDodge.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseIndirectDodge.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseIndirectDodge + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseIndirectDodgeToolTip
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    string strToolTip = DodgeToolTip;

                    if (CurrentCounterspellingDice != 0)
                    {
                        string strSpace = LanguageManager.GetString("String_Space");
                        strToolTip += strSpace + '+' + strSpace + LanguageManager.GetString("Label_CounterspellingDice")
                                      +
                                      strSpace + '(' + CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo)
                                      + ')';
                    }

                    return strToolTip;
                }
            }
        }
        #endregion
        #region Indirect Soak
        public int SpellDefenseIndirectSoak
        {
            get
            {
                int intAttributes = 0;
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        if (HomeNode is Vehicle objVehicle)
                            intAttributes = objVehicle.TotalBody;
                    }
                    else
                        intAttributes = BOD.TotalValue;

                    return intAttributes +
                           GetArmorRating(Improvement.ImprovementType.SpellResistance) +
                           ImprovementManager.ValueOf(this, Improvement.ImprovementType.DamageResistance)
                                             .StandardRound();
                }
            }
        }

        public string DisplaySpellDefenseIndirectSoak
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseIndirectSoak.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseIndirectSoak.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseIndirectSoak + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseIndirectSoakToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                {
                    int intBody;
                    string strBodyAbbrev;
                    if (IsAI)
                    {
                        intBody = HomeNode is Vehicle objVehicle ? objVehicle.TotalBody : 0;
                        strBodyAbbrev = LanguageManager.GetString("String_VehicleBody");
                    }
                    else
                    {
                        intBody = BOD.TotalValue;
                        strBodyAbbrev = BOD.DisplayAbbrev;
                    }

                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append(strBodyAbbrev).Append(strSpace).Append('(')
                                  .Append(intBody.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Tip_Armor"))
                                  .Append(strSpace).Append('(')
                                  .Append(TotalArmorRating.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');

                        if (CurrentCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                      .Append('(')
                                      .Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DamageResistance)).StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                Improvement.ImprovementType.DamageResistance.Yield(),
                                strSpace,
                                intModifiers);
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }
        #endregion
        #region Direct Soak Mana
        public int SpellDefenseDirectSoakMana
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return WIL.TotalValue
                           + (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                              + ImprovementManager.ValueOf(this, Improvement.ImprovementType.DirectManaSpellResist))
                           .StandardRound();
            }
        }

        public string DisplaySpellDefenseDirectSoakMana
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseDirectSoakMana.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseDirectSoakMana.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseDirectSoakMana + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseDirectSoakManaToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                        if (CurrentCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                      .Append('(')
                                      .Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DirectManaSpellResist)).StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                Improvement.ImprovementType.SpellResistance.Yield(),
                                strSpace,
                                intModifiers);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }
        #endregion
        #region Direct Soak Physical
        public int SpellDefenseDirectSoakPhysical
        {
            get
            {
                int intAttributes = 0;
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        if (HomeNode is Vehicle objVehicle)
                            intAttributes = objVehicle.TotalBody;
                    }
                    else
                        intAttributes = BOD.TotalValue;

                    return intAttributes +
                           (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance) +
                            ImprovementManager.ValueOf(this, Improvement.ImprovementType.DirectPhysicalSpellResist))
                           .StandardRound();
                }
            }
        }

        public string DisplaySpellDefenseDirectSoakPhysical
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseDirectSoakPhysical.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseDirectSoakPhysical.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseDirectSoakPhysical + CurrentCounterspellingDice).ToString(
                              GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseDirectSoakPhysicalToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                {
                    int intBody;
                    string strBodyAbbrev;
                    if (IsAI)
                    {
                        intBody = HomeNode is Vehicle objVehicle ? objVehicle.TotalBody : 0;
                        strBodyAbbrev = LanguageManager.GetString("String_VehicleBody");
                    }
                    else
                    {
                        intBody = BOD.TotalValue;
                        strBodyAbbrev = BOD.DisplayAbbrev;
                    }

                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append(strBodyAbbrev).Append(strSpace).Append('(')
                                  .Append(intBody.ToString(GlobalSettings.CultureInfo)).Append(')');

                        if (CurrentCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                      .Append('(')
                                      .Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DirectPhysicalSpellResist))
                            .StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                new[]
                                {
                                    Improvement.ImprovementType.SpellResistance,
                                    Improvement.ImprovementType.DirectPhysicalSpellResist
                                },
                                strSpace,
                                intModifiers);
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }
        #endregion
        #region Detection
        public int SpellDefenseDetection
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return LOG.TotalValue + WIL.TotalValue + SpellResistance +
                           ImprovementManager.ValueOf(this, Improvement.ImprovementType.DetectionSpellResist)
                                             .StandardRound();
            }
        }

        public string DisplaySpellDefenseDetection
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseDetection.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseDetection.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseDetection + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseDetectionToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(LOG.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(LOG.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                        if (CurrentCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                      .Append('(')
                                      .Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DetectionSpellResist)).StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                new[]
                                {
                                    Improvement.ImprovementType.SpellResistance,
                                    Improvement.ImprovementType.DetectionSpellResist
                                },
                                strSpace,
                                intModifiers);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }
        #endregion
        #region Decrease Attributes
        public int SpellDefenseDecreaseBOD
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return BOD.TotalValue + WIL.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.DecreaseBODResist))
                                          .StandardRound();
            }
        }

        public string DisplaySpellDefenseDecreaseBOD
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseDecreaseBOD.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseDecreaseBOD.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseDecreaseBOD + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseDecreaseBODToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(BOD.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(BOD.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                        if (CurrentCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                      .Append('(')
                                      .Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DecreaseBODResist)).StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                new[]
                                {
                                    Improvement.ImprovementType.SpellResistance,
                                    Improvement.ImprovementType.DecreaseBODResist
                                },
                                strSpace,
                                intModifiers);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public int SpellDefenseDecreaseAGI
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AGI.TotalValue + WIL.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.DecreaseAGIResist))
                                          .StandardRound();
            }
        }

        public string DisplaySpellDefenseDecreaseAGI
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseDecreaseAGI.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseDecreaseAGI.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseDecreaseAGI + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseDecreaseAGIToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(AGI.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(AGI.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                        if (CurrentCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                      .Append('(')
                                      .Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DecreaseAGIResist)).StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                new[]
                                {
                                    Improvement.ImprovementType.SpellResistance,
                                    Improvement.ImprovementType.DecreaseAGIResist
                                },
                                strSpace,
                                intModifiers);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public int SpellDefenseDecreaseREA
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return REA.TotalValue + WIL.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.DecreaseREAResist))
                                          .StandardRound();
            }
        }

        public string DisplaySpellDefenseDecreaseREA
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseDecreaseREA.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseDecreaseREA.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseDecreaseREA + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseDecreaseREAToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(REA.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(REA.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                        if (CurrentCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                      .Append('(')
                                      .Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DecreaseREAResist)).StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                new[]
                                {
                                    Improvement.ImprovementType.SpellResistance,
                                    Improvement.ImprovementType.DecreaseREAResist
                                },
                                strSpace,
                                intModifiers);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public int SpellDefenseDecreaseSTR
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return STR.TotalValue + WIL.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.DecreaseSTRResist))
                                          .StandardRound();
            }
        }

        public string DisplaySpellDefenseDecreaseSTR
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseDecreaseSTR.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseDecreaseSTR.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseDecreaseSTR + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseDecreaseSTRToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(STR.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(STR.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                        if (CurrentCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                      .Append('(')
                                      .Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DecreaseSTRResist)).StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                Improvement.ImprovementType.SpellResistance.Yield(),
                                strSpace,
                                intModifiers);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public int SpellDefenseDecreaseCHA
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CHA.TotalValue + WIL.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.DecreaseCHAResist))
                                          .StandardRound();
            }
        }

        public string DisplaySpellDefenseDecreaseCHA
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseDecreaseCHA.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseDecreaseCHA.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseDecreaseCHA + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseDecreaseCHAToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(CHA.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(CHA.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                        if (CurrentCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                      .Append('(')
                                      .Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DecreaseCHAResist)).StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                new[]
                                {
                                    Improvement.ImprovementType.SpellResistance,
                                    Improvement.ImprovementType.DecreaseCHAResist
                                },
                                strSpace,
                                intModifiers);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public int SpellDefenseDecreaseINT
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return INT.TotalValue + WIL.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.DecreaseINTResist))
                                          .StandardRound();
            }
        }

        public string DisplaySpellDefenseDecreaseINT
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseDecreaseINT.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseDecreaseINT.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseDecreaseINT + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseDecreaseINTToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(INT.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(INT.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                        if (CurrentCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                      .Append('(')
                                      .Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DecreaseINTResist)).StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                new[]
                                {
                                    Improvement.ImprovementType.SpellResistance,
                                    Improvement.ImprovementType.DecreaseINTResist
                                },
                                strSpace,
                                intModifiers);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public int SpellDefenseDecreaseLOG
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return LOG.TotalValue + WIL.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.DecreaseLOGResist))
                                          .StandardRound();
            }
        }

        public string DisplaySpellDefenseDecreaseLOG
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseDecreaseLOG.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseDecreaseLOG.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseDecreaseLOG + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseDecreaseLOGToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(LOG.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(LOG.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                        if (CurrentCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                      .Append('(')
                                      .Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DecreaseLOGResist)).StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                new[]
                                {
                                    Improvement.ImprovementType.SpellResistance,
                                    Improvement.ImprovementType.DecreaseLOGResist
                                },
                                strSpace,
                                intModifiers);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public int SpellDefenseDecreaseWIL
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return WIL.TotalValue + WIL.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.DecreaseWILResist))
                                          .StandardRound();
            }
        }

        public string DisplaySpellDefenseDecreaseWIL
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseDecreaseWIL.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseDecreaseWIL.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseDecreaseWIL + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseDecreaseWILToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                        if (CurrentCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                      .Append('(')
                                      .Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                               + ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.DecreaseWILResist)).StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                new[]
                                {
                                    Improvement.ImprovementType.SpellResistance,
                                    Improvement.ImprovementType.DecreaseWILResist
                                },
                                strSpace,
                                intModifiers);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }
        #endregion
        #endregion

        public int Surprise
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return REA.TotalValue + INT.TotalValue
                                          + ImprovementManager.ValueOf(this, Improvement.ImprovementType.Surprise)
                                                              .StandardRound()
                                          + WoundModifier
                                          + SustainingPenalty;
            }
        }

        public string SurpriseToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        sbdToolTip.Append(REA.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(REA.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(INT.DisplayAbbrev).Append(strSpace).Append('(')
                                  .Append(INT.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')')
                                  .Append(strSpace)
                                  .Append('+').Append(strSpace).Append(LanguageManager.GetString("Tip_Skill_Wounds"))
                                  .Append(strSpace).Append('(')
                                  .Append(WoundModifier.ToString(GlobalSettings.CultureInfo))
                                  .Append(')').Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Tip_Skill_Sustain")).Append(strSpace).Append('(')
                                  .Append(SustainingPenalty.ToString(GlobalSettings.CultureInfo)).Append(')');

                        int intModifiers = ImprovementManager.ValueOf(this, Improvement.ImprovementType.Surprise)
                                                             .StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                Improvement.ImprovementType.Surprise.Yield(),
                                strSpace,
                                intModifiers);
                        }
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        private int _intCachedTotalArmorRating = int.MinValue;
        private int _intCachedTotalFireArmorRating = int.MinValue;
        private int _intCachedTotalColdArmorRating = int.MinValue;
        private int _intCachedTotalElectricityArmorRating = int.MinValue;
        private int _intCachedTotalAcidArmorRating = int.MinValue;
        private int _intCachedTotalFallingArmorRating = int.MinValue;

        /// <summary>
        /// The Character's total Armor Rating.
        /// </summary>
        [HubTag]
        public int TotalArmorRating
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedTotalArmorRating == int.MinValue)
                        _intCachedTotalArmorRating = GetArmorRating();
                    return _intCachedTotalArmorRating;
                }
            }
        }

        /// <summary>
        /// The Character's total Armor Rating.
        /// </summary>
        public async ValueTask<int> GetTotalArmorRatingAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                if (_intCachedTotalArmorRating == int.MinValue)
                    _intCachedTotalArmorRating = await GetArmorRatingAsync(token: token);
                return _intCachedTotalArmorRating;
            }
        }

        public string TotalArmorRatingToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                {
                    int intArmor
                        = GetArmorRatingWithImprovement(Improvement.ImprovementType.Armor,
                                                        out int intFromHighestArmorImprovements,
                                                        out List<Improvement> lstUsedImprovements)
                          - ImprovementManager.ValueOf(this, Improvement.ImprovementType.Armor).StandardRound()
                          + intFromHighestArmorImprovements;

                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append(LanguageManager.GetString("Tip_Armor")).Append(strSpace).Append('(')
                                  .Append(intArmor.ToString(GlobalSettings.CultureInfo)).Append(')');
                        foreach (Improvement objLoopImprovement in lstUsedImprovements)
                        {
                            if (objLoopImprovement.ImproveSource != Improvement.ImprovementSource.Armor
                                && objLoopImprovement.ImproveSource != Improvement.ImprovementSource.ArmorMod)
                            {
                                sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                          .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                          .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                          .Append(')');
                            }
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against Fire attacks.
        /// </summary>
        public int TotalFireArmorRating
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedTotalFireArmorRating == int.MinValue)
                        _intCachedTotalFireArmorRating = GetArmorRating(Improvement.ImprovementType.FireArmor);
                    return _intCachedTotalFireArmorRating;
                }
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against Fire attacks.
        /// </summary>
        public async ValueTask<int> GetTotalFireArmorRatingAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                if (_intCachedTotalFireArmorRating == int.MinValue)
                    _intCachedTotalFireArmorRating = await GetArmorRatingAsync(Improvement.ImprovementType.FireArmor, token: token);
                return _intCachedTotalFireArmorRating;
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against Cold attacks.
        /// </summary>
        public int TotalColdArmorRating
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedTotalColdArmorRating == int.MinValue)
                        _intCachedTotalColdArmorRating = GetArmorRating(Improvement.ImprovementType.ColdArmor);
                    return _intCachedTotalColdArmorRating;
                }
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against Cold attacks.
        /// </summary>
        public async ValueTask<int> GetTotalColdArmorRatingAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                if (_intCachedTotalColdArmorRating == int.MinValue)
                    _intCachedTotalColdArmorRating = await GetArmorRatingAsync(Improvement.ImprovementType.ColdArmor, token: token);
                return _intCachedTotalColdArmorRating;
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against Electricity attacks.
        /// </summary>
        public int TotalElectricityArmorRating
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedTotalElectricityArmorRating == int.MinValue)
                        _intCachedTotalElectricityArmorRating
                            = GetArmorRating(Improvement.ImprovementType.ElectricityArmor);
                    return _intCachedTotalElectricityArmorRating;
                }
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against Electricity attacks.
        /// </summary>
        public async ValueTask<int> GetTotalElectricityArmorRatingAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                if (_intCachedTotalElectricityArmorRating == int.MinValue)
                    _intCachedTotalElectricityArmorRating = await GetArmorRatingAsync(Improvement.ImprovementType.ElectricityArmor, token: token);
                return _intCachedTotalElectricityArmorRating;
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against Acid attacks.
        /// </summary>
        public int TotalAcidArmorRating
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedTotalAcidArmorRating == int.MinValue)
                        _intCachedTotalAcidArmorRating = GetArmorRating(Improvement.ImprovementType.AcidArmor);
                    return _intCachedTotalAcidArmorRating;
                }
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against Acid attacks.
        /// </summary>
        public async ValueTask<int> GetTotalAcidArmorRatingAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                if (_intCachedTotalAcidArmorRating == int.MinValue)
                    _intCachedTotalAcidArmorRating = await GetArmorRatingAsync(Improvement.ImprovementType.AcidArmor, token: token);
                return _intCachedTotalAcidArmorRating;
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against falling damage (AP -4 not factored in).
        /// </summary>
        public int TotalFallingArmorRating
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedTotalFallingArmorRating == int.MinValue)
                        _intCachedTotalFallingArmorRating = GetArmorRating(Improvement.ImprovementType.FallingArmor);
                    return _intCachedTotalFallingArmorRating;
                }
            }
        }

        /// <summary>
        /// The Character's total Armor Rating against falling damage (AP -4 not factored in).
        /// </summary>
        public async ValueTask<int> GetTotalFallingArmorRatingAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                if (_intCachedTotalFallingArmorRating == int.MinValue)
                    _intCachedTotalFallingArmorRating = await GetArmorRatingAsync(Improvement.ImprovementType.FallingArmor, token: token);
                return _intCachedTotalFallingArmorRating;
            }
        }

        /// <summary>
        /// The Character's total bonus to Dodge Rating (to add on top of REA + INT).
        /// </summary>
        public int TotalBonusDodgeRating => ImprovementManager.ValueOf(this, Improvement.ImprovementType.Dodge).StandardRound();

        /// <summary>
        /// Encumbrance modifier for carrying more stuff than carry limit
        /// </summary>
        public int Encumbrance
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    decimal decCarryLimit = CarryLimit;

                    decimal decCarriedWeight = TotalCarriedWeight;

                    return decCarriedWeight > decCarryLimit
                        ? -((decCarriedWeight - decCarryLimit) / EncumbranceInterval).StandardRound()
                        : 0;
                }
            }
        }

        /// <summary>
        /// Total amount of stuff the character is currently carrying on their person (via Equipped)
        /// </summary>
        public decimal TotalCarriedWeight
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_decCachedTotalCarriedWeight == decimal.MinValue)
                    {
                        _decCachedTotalCarriedWeight = Armor.Sum(x => x.Equipped, x => x.TotalWeight)
                                                       + Weapons.Sum(x => x.Equipped, x => x.TotalWeight)
                                                       + Gear.Sum(x => x.Equipped, x => x.TotalWeight)
                                                       + Cyberware.Sum(x => x.IsModularCurrentlyEquipped, x => x.TotalWeight);
                    }

                    return _decCachedTotalCarriedWeight;
                }
            }
        }

        /// <summary>
        /// String used to show the current carried weight status in the toolstrip of character forms
        /// </summary>
        public string DisplayTotalCarriedWeight
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                    return TotalCarriedWeight.ToString(Settings.WeightFormat, GlobalSettings.CultureInfo) + strSpace
                        + "kg"
                        + strSpace + '/' + strSpace
                        + CarryLimit.ToString(Settings.WeightFormat, GlobalSettings.CultureInfo) + strSpace + "kg";
            }
        }

        /// <summary>
        /// Armor Encumbrance modifier from Armor.
        /// </summary>
        public int ArmorEncumbrance
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (Settings.NoArmorEncumbrance)
                        return 0;
                    List<Armor> lstArmorsToConsider = Armor.Where(objArmor => objArmor.Equipped).ToList();
                    if (lstArmorsToConsider.Count == 0 || lstArmorsToConsider.All(objArmor => !objArmor.Encumbrance))
                        return 0;
                    Armor objHighestArmor = null;
                    int intHighest = 0;
                    // Run through the list of Armor currently worn and retrieve the highest total Armor rating.
                    // This is used for Custom-Fit armour's stacking.
                    foreach (Armor objArmor in lstArmorsToConsider)
                    {
                        if (objArmor.ArmorValue.StartsWith('+')
                            || objArmor.ArmorValue.StartsWith('-'))
                            continue;
                        int intLoopTotal = objArmor.TotalArmor;
                        string strArmorName = objArmor.Name;
                        foreach (Armor objInnerArmor in lstArmorsToConsider)
                        {
                            if (objInnerArmor == objArmor)
                                continue;
                            if (!objInnerArmor.ArmorOverrideValue.StartsWith('+')
                                && !objInnerArmor.ArmorOverrideValue.StartsWith('-'))
                                continue;
                            if (objInnerArmor.ArmorMods.Any(objMod => objMod.Name == "Custom Fit (Stack)"
                                                                      && objMod.Extra == strArmorName
                                                                      && objMod.Equipped))
                                intLoopTotal += objInnerArmor.TotalOverrideArmor;
                        }

                        if (intLoopTotal > intHighest)
                        {
                            intHighest = intLoopTotal;
                            objHighestArmor = objArmor;
                        }
                    }

                    int intTotalA = 0;

                    foreach (Armor objArmor in lstArmorsToConsider)
                    {
                        if (!objArmor.Encumbrance
                            || (!objArmor.ArmorValue.StartsWith('+')
                                && !objArmor.ArmorValue.StartsWith('-')
                                && !objArmor.ArmorOverrideValue.StartsWith('+')
                                && !objArmor.ArmorOverrideValue.StartsWith('-'))
                            || objArmor == objHighestArmor)
                            continue;
                        bool blnDoAdd = true;
                        bool blnCustomFit = false;
                        if (objHighestArmor != null)
                        {
                            foreach (ArmorMod objMod in objArmor.ArmorMods)
                            {
                                if (objMod.Name == "Custom Fit (Stack)")
                                {
                                    blnDoAdd = objMod.Extra == objHighestArmor.Name && objMod.Equipped;
                                    blnCustomFit = true;
                                    break;
                                }
                            }
                        }

                        if (blnDoAdd)
                        {
                            if (!blnCustomFit && (objArmor.ArmorValue.StartsWith('+')
                                                  || objArmor.ArmorValue.StartsWith('-')))
                                intTotalA += objArmor.TotalArmor;
                            else
                                intTotalA += objArmor.TotalOverrideArmor;
                        }
                    }

                    // calculate armor encumbrance
                    int intSTRTotalValue = STR.TotalValue;
                    if (intTotalA > intSTRTotalValue + 1)
                        return (intSTRTotalValue - intTotalA) / 2; // a negative number is expected
                    return 0;
                }
            }
        }

        #endregion

        #region Spell Defense
        public int SpellDefenseIllusionMana
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return LOG.TotalValue + WIL.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.ManaIllusionResist))
                                          .StandardRound();
            }
        }

        public string DisplaySpellDefenseIllusionMana
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseIllusionMana.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseIllusionMana.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseIllusionMana + CurrentCounterspellingDice).ToString(GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseIllusionManaToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(LOG.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(LOG.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                    if (CurrentCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                  .Append('(').Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');

                    int intModifiers = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                        + ImprovementManager.ValueOf(
                                            this, Improvement.ImprovementType.ManaIllusionResist))
                        .StandardRound();

                    if (intModifiers != 0)
                    {
                        FormatImprovementModifiers(
                            sbdToolTip,
                            new []
                            {
                                Improvement.ImprovementType.SpellResistance,
                                Improvement.ImprovementType.ManaIllusionResist
                            },
                            strSpace,
                            intModifiers);
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public int SpellDefenseIllusionPhysical
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return LOG.TotalValue + INT.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.PhysicalIllusionResist))
                                          .StandardRound();
            }
        }

        public string DisplaySpellDefenseIllusionPhysical
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseIllusionPhysical.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseIllusionPhysical.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseIllusionPhysical + CurrentCounterspellingDice).ToString(
                              GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseIllusionPhysicalToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(LOG.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(LOG.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(INT.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(INT.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                    if (CurrentCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                  .Append('(').Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');

                    int intModifiers = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                        + ImprovementManager.ValueOf(
                                            this, Improvement.ImprovementType.PhysicalIllusionResist)).StandardRound();

                    if (intModifiers != 0)
                    {
                        FormatImprovementModifiers(
                            sbdToolTip,
                            new []
                            {
                                Improvement.ImprovementType.SpellResistance,
                                Improvement.ImprovementType.PhysicalIllusionResist
                            },
                            strSpace,
                            intModifiers);
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public int SpellDefenseManipulationMental
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return LOG.TotalValue + WIL.TotalValue
                                          + (ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.SpellResistance)
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.MentalManipulationResist))
                                          .StandardRound();
            }
        }

        public string DisplaySpellDefenseManipulationMental
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseManipulationMental.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseManipulationMental.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseManipulationMental + CurrentCounterspellingDice).ToString(
                              GlobalSettings.CultureInfo)
                          + ')';
            }
        }

        public string SpellDefenseManipulationMentalToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdToolTip))
                {
                    sbdToolTip.Append(LOG.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(LOG.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                              .Append('+').Append(strSpace).Append(WIL.DisplayAbbrev).Append(strSpace).Append('(')
                              .Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(')');

                    if (CurrentCounterspellingDice != 0)
                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                  .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                  .Append('(').Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                  .Append(')');

                    int intModifiers = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance)
                                        + ImprovementManager.ValueOf(
                                            this, Improvement.ImprovementType.MentalManipulationResist))
                        .StandardRound();

                    if (intModifiers != 0)
                    {
                        FormatImprovementModifiers(
                            sbdToolTip,
                            new []
                            {
                                Improvement.ImprovementType.SpellResistance,
                                Improvement.ImprovementType.MentalManipulationResist
                            },
                            strSpace,
                            intModifiers);
                    }

                    return sbdToolTip.ToString();
                }
            }
        }

        public int SpellDefenseManipulationPhysical
        {
            get
            {
                int intAttributes = 0;
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        if (HomeNode is Vehicle objVehicle)
                            intAttributes = objVehicle.TotalBody * 2;
                    }
                    else
                        intAttributes = BOD.TotalValue + STR.TotalValue;

                    return intAttributes +
                           (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance) +
                            ImprovementManager.ValueOf(this, Improvement.ImprovementType.PhysicalManipulationResist))
                           .StandardRound();
                }
            }
        }

        public string DisplaySpellDefenseManipulationPhysical
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return CurrentCounterspellingDice == 0
                        ? SpellDefenseManipulationPhysical.ToString(GlobalSettings.CultureInfo)
                        : SpellDefenseManipulationPhysical.ToString(GlobalSettings.CultureInfo) +
                          LanguageManager.GetString("String_Space") + '(' +
                          (SpellDefenseManipulationPhysical + CurrentCounterspellingDice).ToString(
                              GlobalSettings.CultureInfo) + ')';
            }
        }

        public string SpellDefenseManipulationPhysicalToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                {
                    int intBody;
                    int intStrength;
                    string strBodyAbbrev;
                    string strStrengthAbbrev;
                    if (IsAI)
                    {
                        intBody = intStrength = (HomeNode is Vehicle objVehicle ? objVehicle.TotalBody : 0);
                        strBodyAbbrev = strStrengthAbbrev = LanguageManager.GetString("String_VehicleBody");
                    }
                    else
                    {
                        intBody = BOD.TotalValue;
                        intStrength = STR.TotalValue;
                        strBodyAbbrev = BOD.DisplayAbbrev;
                        strStrengthAbbrev = STR.DisplayAbbrev;
                    }

                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append(strBodyAbbrev).Append(strSpace).Append('(')
                                  .Append(intBody.ToString(GlobalSettings.CultureInfo)).Append(')').Append(strSpace)
                                  .Append('+').Append(strSpace).Append(strStrengthAbbrev).Append(strSpace).Append('(')
                                  .Append(intStrength.ToString(GlobalSettings.CultureInfo)).Append(')');

                        if (CurrentCounterspellingDice != 0)
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(LanguageManager.GetString("Label_CounterspellingDice")).Append(strSpace)
                                      .Append('(')
                                      .Append(CurrentCounterspellingDice.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');

                        int intModifiers
                            = (ImprovementManager.ValueOf(this, Improvement.ImprovementType.SpellResistance) +
                               ImprovementManager.ValueOf(
                                   this, Improvement.ImprovementType.PhysicalManipulationResist))
                            .StandardRound();

                        if (intModifiers != 0)
                        {
                            FormatImprovementModifiers(
                                sbdToolTip,
                                new[]
                                {
                                    Improvement.ImprovementType.SpellResistance,
                                    Improvement.ImprovementType.PhysicalManipulationResist
                                },
                                strSpace,
                                intModifiers);
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }
        #endregion

        /// <summary>
        /// Custom Drugs created by the character.
        /// </summary>
        public ThreadSafeObservableCollection<Drug> Drugs
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstDrugs;
            }
        }

        /// <summary>
        /// Custom Drugs created by the character.
        /// </summary>
        public async ValueTask<ThreadSafeObservableCollection<Drug>> GetDrugsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _lstDrugs;
        }

        #region Condition Monitors

        /// <summary>
        /// Number of Physical Condition Monitor boxes.
        /// </summary>
        public int PhysicalCM
        {
            get
            {
                int intCMPhysical = 8;
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        if (HomeNode is Vehicle objVehicle)
                        {
                            return objVehicle.PhysicalCM;
                        }

                        if (DEP != null)
                            // A.I.s use Core Condition Monitors instead of Physical Condition Monitors if they are not in a vehicle or drone.
                            intCMPhysical += (DEP.TotalValue + 1) / 2;
                    }
                    else
                    {
                        if (BOD != null)
                            intCMPhysical += (BOD.TotalValue + 1) / 2;
                    }

                    // Include Improvements in the Condition Monitor values.
                    intCMPhysical += ImprovementManager.ValueOf(this, Improvement.ImprovementType.PhysicalCM)
                                                       .StandardRound();
                }

                return intCMPhysical;
            }
        }

        public string PhysicalCMLabelText
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return IsAI
                        ? LanguageManager.GetString(HomeNode is Vehicle ? "Label_OtherPhysicalCM" : "Label_OtherCoreCM")
                        : LanguageManager.GetString("Label_OtherPhysicalCM");
            }
        }

        public string PhysicalCMToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                string strModifiers = LanguageManager.GetString("Tip_Modifiers");
                string strCM;
                using (EnterReadLock.Enter(LockObject))
                {
                    int intBonus;
                    if (IsAI)
                    {
                        if (HomeNode is Vehicle objVehicleHomeNode)
                        {
                            strCM = objVehicleHomeNode.BasePhysicalBoxes.ToString(GlobalSettings.CultureInfo) + strSpace
                                +
                                '+' + strSpace + '(' + BOD.DisplayAbbrev + '' + 2.ToString(GlobalSettings.CultureInfo)
                                +
                                ')' + strSpace + '(' +
                                ((objVehicleHomeNode.TotalBody + 1) / 2).ToString(GlobalSettings.CultureInfo) + ')';

                            intBonus = objVehicleHomeNode.Mods.Sum(objMod => objMod.ConditionMonitor);
                            if (intBonus != 0)
                                strCM += strSpace + '+' + strSpace + strModifiers + strSpace + '('
                                         + intBonus.ToString(GlobalSettings.CultureInfo) + ')';
                        }
                        else
                        {
                            strCM = 8.ToString(GlobalSettings.CultureInfo) + strSpace + '+' + strSpace + '(' +
                                    DEP.DisplayAbbrev + '' + 2.ToString(GlobalSettings.CultureInfo) + ')' + strSpace
                                    + '(' +
                                    ((DEP.TotalValue + 1) / 2).ToString(GlobalSettings.CultureInfo) + ')';

                            intBonus = ImprovementManager.ValueOf(this, Improvement.ImprovementType.PhysicalCM)
                                                         .StandardRound();
                            if (intBonus != 0)
                                strCM += strSpace + '+' + strSpace + strModifiers + strSpace + '('
                                         + intBonus.ToString(GlobalSettings.CultureInfo) + ')';
                        }
                    }
                    else
                    {
                        strCM = 8.ToString(GlobalSettings.CultureInfo) + strSpace + '+' + strSpace + '(' +
                                BOD.DisplayAbbrev + '' + 2.ToString(GlobalSettings.CultureInfo) + ')' + strSpace + '('
                                +
                                ((BOD.TotalValue + 1) / 2).ToString(GlobalSettings.CultureInfo) + ')';

                        intBonus = ImprovementManager.ValueOf(this, Improvement.ImprovementType.PhysicalCM)
                                                     .StandardRound();
                        if (intBonus != 0)
                            strCM += strSpace + '+' + strSpace + strModifiers + strSpace + '('
                                     + intBonus.ToString(GlobalSettings.CultureInfo) + ')';
                    }
                }

                return strCM;
            }
        }

        /// <summary>
        /// Number of Stun Condition Monitor boxes.
        /// </summary>
        public int StunCM
        {
            get
            {
                int intCMStun = 0;
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        // A.I. do not have a Stun Condition Monitor, but they do have a Matrix Condition Monitor if they are in their home node.
                        if (HomeNode != null)
                        {
                            intCMStun = HomeNode.MatrixCM;
                        }
                    }
                    else
                    {
                        intCMStun = 8 + (WIL.TotalValue + 1) / 2;
                        // Include Improvements in the Condition Monitor values.
                        intCMStun += ImprovementManager.ValueOf(this, Improvement.ImprovementType.StunCM)
                                                       .StandardRound();
                    }
                }

                return intCMStun;
            }
        }

        public bool StunCMVisible
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return !IsAI || HomeNode != null;
            }
        }

        public string StunCMLabelText
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        return HomeNode == null ? string.Empty : LanguageManager.GetString("Label_OtherMatrixCM");
                    }

                    return LanguageManager.GetString("Label_OtherStunCM");
                }
            }
        }

        public string StunCMToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                string strModifiers = LanguageManager.GetString("Tip_Modifiers");
                string strCM;
                using (EnterReadLock.Enter(LockObject))
                {
                    int intBonus;
                    if (IsAI)
                    {
                        if (HomeNode == null)
                            return string.Empty;
                        strCM = 8.ToString(GlobalSettings.CultureInfo) + strSpace + '+' + strSpace + '(' +
                                LanguageManager.GetString("String_DeviceRating") + '' +
                                2.ToString(GlobalSettings.CultureInfo) + ')' + strSpace + '(' +
                                ((HomeNode.GetTotalMatrixAttribute("Device Rating") + 1) / 2).ToString(GlobalSettings
                                    .CultureInfo) + ')';

                        intBonus = HomeNode.TotalBonusMatrixBoxes;
                        if (intBonus != 0)
                            strCM += strSpace + '+' + strSpace + strModifiers + strSpace + '(' +
                                     intBonus.ToString(GlobalSettings.CultureInfo) + ')';
                    }
                    else
                    {
                        strCM = 8.ToString(GlobalSettings.CultureInfo) + strSpace + '+' + strSpace + '(' +
                                WIL.DisplayAbbrev + '' + 2.ToString(GlobalSettings.CultureInfo) + ')' + strSpace + '('
                                +
                                ((WIL.TotalValue + 1) / 2).ToString(GlobalSettings.CultureInfo) + ')';

                        intBonus = ImprovementManager.ValueOf(this, Improvement.ImprovementType.StunCM).StandardRound();
                        if (intBonus != 0)
                            strCM += strSpace + '+' + strSpace + strModifiers + strSpace + '(' +
                                     intBonus.ToString(GlobalSettings.CultureInfo) + ')';
                    }
                }

                return strCM;
            }
        }

        /// <summary>
        /// Number of Condition Monitor boxes are needed to reach a Condition Monitor Threshold.
        /// </summary>
        public int CMThreshold
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    int intCMThreshold = 3 + ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMThreshold)
                                                               .StandardRound();
                    return intCMThreshold;
                }
            }
        }

        /// <summary>
        /// Returns PhysicalCMThresholdOffset and StunCMThresholdOffset as a pair.
        /// </summary>
        public Tuple<int, int> CMThresholdOffsets
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return new Tuple<int, int>(PhysicalCMThresholdOffset, StunCMThresholdOffset);
            }
        }

        /// <summary>
        /// Number of additional boxes appear before the first Physical Condition Monitor penalty.
        /// </summary>
        public int PhysicalCMThresholdOffset
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (ImprovementManager
                        .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.IgnoreCMPenaltyPhysical)
                        .Count
                        > 0)
                        return int.MaxValue;
                    if (IsAI || ImprovementManager
                                .GetCachedImprovementListForValueOf(
                                    this, Improvement.ImprovementType.IgnoreCMPenaltyStun)
                                .Count > 0)
                        return (ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMThresholdOffset) +
                                ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMSharedThresholdOffset))
                            .StandardRound();

                    decimal decCMThresholdOffset =
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMThresholdOffset);
                    // We're subtracting CM Threshold from the amount of CM boxes filled because you only need to ignore wounds up to your first wound threshold, not all wounds
                    decimal decCMSharedThresholdOffset = decCMThresholdOffset +
                                                         ImprovementManager.ValueOf(this,
                                                             Improvement.ImprovementType.CMSharedThresholdOffset) -
                                                         Math.Max(StunCMFilled - CMThreshold - decCMThresholdOffset, 0);
                    return Math.Max(decCMThresholdOffset, decCMSharedThresholdOffset).StandardRound();
                }
            }
        }

        /// <summary>
        /// Number of additional boxes appear before the first Stun Condition Monitor penalty.
        /// </summary>
        public int StunCMThresholdOffset
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    // A.I.s don't get wound penalties from Matrix damage
                    if (IsAI)
                        return int.MaxValue;
                    if (ImprovementManager
                        .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.IgnoreCMPenaltyStun)
                        .Count > 0)
                        return int.MaxValue;
                    if (ImprovementManager
                        .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.IgnoreCMPenaltyPhysical)
                        .Count
                        > 0)
                        return (ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMThresholdOffset) +
                                ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMSharedThresholdOffset))
                            .StandardRound();

                    decimal decCMThresholdOffset =
                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMThresholdOffset);
                    // We're subtracting CM Threshold from the amount of CM boxes filled because you only need to ignore wounds up to your first wound threshold, not all wounds
                    decimal decCMSharedThresholdOffset = decCMThresholdOffset +
                                                         ImprovementManager.ValueOf(this,
                                                             Improvement.ImprovementType.CMSharedThresholdOffset) -
                                                         Math.Max(PhysicalCMFilled - CMThreshold - decCMThresholdOffset,
                                                                  0);
                    return Math.Max(decCMThresholdOffset, decCMSharedThresholdOffset).StandardRound();
                }
            }
        }

        /// <summary>
        /// Number of Overflow Condition Monitor boxes.
        /// </summary>
        public int CMOverflow
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    int intCMOverflow = 0;
                    // A.I. do not have an Overflow Condition Monitor.
                    if (!IsAI)
                    {
                        // Characters get a number of overflow boxes equal to their BOD (plus any Improvements). One more boxes is added to mark the character as dead.
                        intCMOverflow = BOD.TotalValue +
                                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.CMOverflow)
                                                          .StandardRound() + 1;
                    }

                    return intCMOverflow;
                }
            }
        }

        #endregion

        #region Build Properties

        /// <summary>
        /// Method being used to build the character.
        /// </summary>
        public CharacterBuildMethod EffectiveBuildMethod
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return IsCritter ? CharacterBuildMethod.Karma : Settings.BuildMethod;
            }
        }

        public bool EffectiveBuildMethodUsesPriorityTables
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return EffectiveBuildMethod.UsesPriorityTables();
            }
        }

        public async ValueTask<bool> GetEffectiveBuildMethodUsesPriorityTablesAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return EffectiveBuildMethod.UsesPriorityTables();
        }

        public bool EffectiveBuildMethodIsLifeModule
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return EffectiveBuildMethod == CharacterBuildMethod.LifeModule;
            }
        }
        public async ValueTask<bool> GetEffectiveBuildMethodIsLifeModuleAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return EffectiveBuildMethod == CharacterBuildMethod.LifeModule;
        }

        public bool EnableAutomaticStoryButton
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return EffectiveBuildMethodIsLifeModule && Settings.AutomaticBackstory;
            }
        }

        /// <summary>
        /// Amount of Nuyen the character has.
        /// </summary>
        public decimal Nuyen
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _decNuyen;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_decNuyen == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _decNuyen = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Amount of Nuyen the character has.
        /// </summary>
        public async ValueTask<decimal> GetNuyenAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _decNuyen;
        }

        /// <summary>
        /// Amount of Nuyen the character has.
        /// </summary>
        public async ValueTask SetNuyenAsync(decimal value, CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (_decNuyen == value)
                    return;
                IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    _decNuyen = value;
                    OnPropertyChanged(nameof(Nuyen));
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
        }

        public decimal StolenNuyen
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _decStolenNuyen;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_decStolenNuyen == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _decStolenNuyen = value;
                        OnPropertyChanged();
                    }
                }
            }
        }
        
        public async ValueTask<decimal> GetStolenNuyenAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _decStolenNuyen;
        }

        public async ValueTask SetStolenNuyenAsync(decimal value, CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (_decNuyen == value)
                    return;
                IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    _decStolenNuyen = value;
                    OnPropertyChanged(nameof(StolenNuyen));
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
        }

        public string DisplayNuyen
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return Nuyen.ToString(Settings.NuyenFormat, GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol");
            }
        }

        public string DisplayStolenNuyen
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return StolenNuyen.ToString(Settings.NuyenFormat, GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol");
            }
        }

        /// <summary>
        /// Amount of Nuyen the character started with via the priority system.
        /// </summary>
        public decimal StartingNuyen
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _decStartingNuyen;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_decStartingNuyen == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _decStartingNuyen = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        public async ValueTask<decimal> GetStartingNuyenAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _decStartingNuyen;
        }

        private decimal _decCachedTotalStartingNuyen = decimal.MinValue;

        public decimal TotalStartingNuyen
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_decCachedTotalStartingNuyen == decimal.MinValue)
                    {
                        decimal decFromKarma
                            = CalculateStartingNuyenFromKarma(Math.Min(NuyenBP, TotalNuyenMaximumBP), StartingNuyen);
                        _decCachedTotalStartingNuyen = decFromKarma +
                                                       ImprovementManager.ValueOf(
                                                           this, Improvement.ImprovementType.Nuyen) -
                                                       ImprovementManager.ValueOf(
                                                           this, Improvement.ImprovementType.Nuyen
                                                           , strImprovedName: "Stolen");
                    }

                    return _decCachedTotalStartingNuyen;
                }
            }
        }

        public async ValueTask<decimal> GetTotalStartingNuyenAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (_decCachedTotalStartingNuyen == decimal.MinValue)
                {
                    decimal decFromKarma
                        = await CalculateStartingNuyenFromKarmaAsync(
                            Math.Min(await GetNuyenBPAsync(token), await GetTotalNuyenMaximumBPAsync(token)),
                            await GetStartingNuyenAsync(token), token);
                    _decCachedTotalStartingNuyen = decFromKarma +
                                                   await ImprovementManager.ValueOfAsync(
                                                       this, Improvement.ImprovementType.Nuyen, token: token).ConfigureAwait(false) -
                                                   await ImprovementManager.ValueOfAsync(
                                                       this, Improvement.ImprovementType.Nuyen
                                                       , strImprovedName: "Stolen", token: token).ConfigureAwait(false);
                }

                return _decCachedTotalStartingNuyen;
            }
        }

        private decimal CalculateStartingNuyenFromKarma(decimal decKarma, decimal decStartingNuyen)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                decimal decFromKarma = 0.0m;
                string strExpression = Settings.ChargenKarmaToNuyenExpression
                                               .Replace("{Karma}",
                                                        decKarma.ToString(GlobalSettings.InvariantCultureInfo))
                                               .Replace("{PriorityNuyen}",
                                                        decStartingNuyen.ToString(GlobalSettings.InvariantCultureInfo));
                if (strExpression.IndexOfAny('{', '+', '-', '*', ',') != -1 || strExpression.Contains("div"))
                {
                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdValue))
                    {
                        sbdValue.Append(strExpression);
                        AttributeSection.ProcessAttributesInXPath(sbdValue, strExpression);

                        // This is first converted to a decimal and rounded up since some items have a multiplier that is not a whole number, such as 2.5.
                        object objProcess =
                            CommonFunctions.EvaluateInvariantXPath(sbdValue.ToString(), out bool blnIsSuccess);
                        if (blnIsSuccess)
                            decFromKarma = Convert.ToDecimal((double) objProcess);
                    }
                }
                else
                    decimal.TryParse(strExpression, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                     out decFromKarma);

                return decFromKarma;
            }
        }

        private async ValueTask<decimal> CalculateStartingNuyenFromKarmaAsync(decimal decKarma, decimal decStartingNuyen, CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                decimal decFromKarma = 0.0m;
                string strExpression = (await (await GetSettingsAsync(token)).GetChargenKarmaToNuyenExpressionAsync(token))
                                       .Replace("{Karma}",
                                                decKarma.ToString(GlobalSettings.InvariantCultureInfo))
                                       .Replace("{PriorityNuyen}",
                                                decStartingNuyen.ToString(GlobalSettings.InvariantCultureInfo));
                if (strExpression.IndexOfAny('{', '+', '-', '*', ',') != -1 || strExpression.Contains("div"))
                {
                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdValue))
                    {
                        sbdValue.Append(strExpression);
                        await (await GetAttributeSectionAsync(token)).ProcessAttributesInXPathAsync(sbdValue, strExpression, token: token);

                        // This is first converted to a decimal and rounded up since some items have a multiplier that is not a whole number, such as 2.5.
                        (bool blnIsSuccess, object objProcess)
                            = await CommonFunctions.EvaluateInvariantXPathAsync(sbdValue.ToString(), token);
                        if (blnIsSuccess)
                            decFromKarma = Convert.ToDecimal((double)objProcess);
                    }
                }
                else
                    decimal.TryParse(strExpression, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                     out decFromKarma);

                return decFromKarma;
            }
        }

        public string DisplayTotalStartingNuyen
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return '=' + LanguageManager.GetString("String_Space") +
                           TotalStartingNuyen.ToString(Settings.NuyenFormat, GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol");
            }
        }

        /// <summary>
        /// Number of Build Points put into Nuyen.
        /// </summary>
        public decimal NuyenBP
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _decNuyenBP;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    decimal decNewValue = Math.Max(Math.Min(value, TotalNuyenMaximumBP), 0);
                    if (_decNuyenBP == decNewValue)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _decNuyenBP = decNewValue;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Number of Build Points put into Nuyen.
        /// </summary>
        public async ValueTask<decimal> GetNuyenBPAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
                return _decNuyenBP;
        }

        public decimal TotalNuyenMaximumBP
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    const decimal decMaxValue = int.MaxValue;
                    // If UnrestrictedNuyen is enabled, return the maximum possible value
                    if (IgnoreRules || Settings.UnrestrictedNuyen)
                    {
                        return decMaxValue;
                    }

                    return Math.Max(Math.Min(decMaxValue,
                                             Settings.NuyenMaximumBP
                                             + ImprovementManager.ValueOf(
                                                 this, Improvement.ImprovementType.NuyenMaxBP)), 0);
                }
            }
        }

        /// <summary>
        /// Number of Build Points put into Nuyen.
        /// </summary>
        public async ValueTask<decimal> GetTotalNuyenMaximumBPAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                const decimal decMaxValue = int.MaxValue;
                // If UnrestrictedNuyen is enabled, return the maximum possible value
                if (await GetIgnoreRulesAsync(token).ConfigureAwait(false))
                {
                    return decMaxValue;
                }

                CharacterSettings objSettings = await GetSettingsAsync(token).ConfigureAwait(false);
                if (await objSettings.GetUnrestrictedNuyenAsync(token).ConfigureAwait(false))
                {
                    return decMaxValue;
                }

                return Math.Max(Math.Min(decMaxValue,
                                         await objSettings.GetNuyenMaximumBPAsync(token).ConfigureAwait(false)
                                         + await ImprovementManager.ValueOfAsync(
                                             this, Improvement.ImprovementType.NuyenMaxBP, token: token).ConfigureAwait(false)), 0);
            }
        }

        /// <summary>
        /// The calculated Astral Limit.
        /// </summary>
        public int LimitAstral
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return Math.Max(LimitMental, LimitSocial);
            }
        }

        public string LimitAstralToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                    return string.Concat(LanguageManager.GetString("Label_Options_Maximum"),
                                         strSpace, "(", LanguageManager.GetString("String_LimitMentalShort"),
                                         strSpace, "[", LimitMental.ToString(GlobalSettings.CultureInfo), "],",
                                         strSpace, LanguageManager.GetString("String_LimitSocialShort"),
                                         strSpace, "[", LimitSocial.ToString(GlobalSettings.CultureInfo), "])");
            }
        }

        /// <summary>
        /// The calculated Physical Limit.
        /// </summary>
        public int LimitPhysical
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        Vehicle objHomeNodeVehicle = HomeNode as Vehicle;
                        return objHomeNodeVehicle?.Handling ?? 0;
                    }

                    int intLimit = (STR.TotalValue * 2 + BOD.TotalValue + REA.TotalValue + 2) / 3;
                    return intLimit + ImprovementManager.ValueOf(this, Improvement.ImprovementType.PhysicalLimit)
                                                        .StandardRound();
                }
            }
        }

        public string LimitPhysicalToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                {
                    if (IsAI)
                    {
                        Vehicle objHomeNodeVehicle = HomeNode as Vehicle;
                        return string.Concat(LanguageManager.GetString("String_Handling"),
                                             strSpace, "[",
                                             (objHomeNodeVehicle?.Handling ?? 0).ToString(GlobalSettings.CultureInfo),
                                             "]");
                    }

                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append('(').Append(STR.DisplayAbbrev).Append(strSpace).Append('[')
                                  .Append(STR.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(']')
                                  .Append(strSpace)
                                  .Append('').Append(strSpace).Append(2.ToString(GlobalSettings.CultureInfo))
                                  .Append(strSpace).Append('+').Append(strSpace).Append(BOD.DisplayAbbrev)
                                  .Append(strSpace)
                                  .Append('[').Append(BOD.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(']')
                                  .Append(strSpace).Append('+').Append(strSpace).Append(REA.DisplayAbbrev)
                                  .Append(strSpace)
                                  .Append('[').Append(REA.TotalValue.ToString(GlobalSettings.CultureInfo)).Append("])")
                                  .Append(strSpace).Append('/').Append(strSpace)
                                  .Append(3.ToString(GlobalSettings.CultureInfo));
                        foreach (Improvement objLoopImprovement in
                                 ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.PhysicalLimit))
                        {
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                      .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        /// <summary>
        /// The calculated Mental Limit.
        /// </summary>
        public int LimitMental
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    int intLimit = (LOG.TotalValue * 2 + INT.TotalValue + WIL.TotalValue + 2) / 3;
                    if (IsAI && HomeNode != null)
                    {
                        if (HomeNode is Vehicle objHomeNodeVehicle)
                        {
                            int intHomeNodeSensor = objHomeNodeVehicle.CalculatedSensor;
                            if (intHomeNodeSensor > intLimit)
                            {
                                intLimit = intHomeNodeSensor;
                            }
                        }

                        int intHomeNodeDP = HomeNode.GetTotalMatrixAttribute("Data Processing");
                        if (intHomeNodeDP > intLimit)
                        {
                            intLimit = intHomeNodeDP;
                        }
                    }

                    return intLimit + ImprovementManager.ValueOf(this, Improvement.ImprovementType.MentalLimit)
                                                        .StandardRound();
                }
            }
        }

        public string LimitMentalToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                {
                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append('(').Append(LOG.DisplayAbbrev).Append(strSpace).Append('[')
                                  .Append(LOG.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(']')
                                  .Append(strSpace)
                                  .Append('').Append(strSpace).Append(2.ToString(GlobalSettings.CultureInfo))
                                  .Append(strSpace).Append('+').Append(strSpace).Append(INT.DisplayAbbrev)
                                  .Append(strSpace)
                                  .Append('[').Append(INT.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(']')
                                  .Append(strSpace).Append('+').Append(strSpace).Append(WIL.DisplayAbbrev)
                                  .Append(strSpace)
                                  .Append('[').Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append("])")
                                  .Append(strSpace).Append('/').Append(strSpace)
                                  .Append(3.ToString(GlobalSettings.CultureInfo));

                        if (IsAI && HomeNode != null)
                        {
                            int intLimit = (LOG.TotalValue * 2 + INT.TotalValue + WIL.TotalValue + 2) / 3;
                            if (HomeNode is Vehicle objHomeNodeVehicle)
                            {
                                int intHomeNodeSensor = objHomeNodeVehicle.CalculatedSensor;
                                if (intHomeNodeSensor > intLimit)
                                {
                                    intLimit = intHomeNodeSensor;
                                    sbdToolTip.Clear();
                                    sbdToolTip.Append(LanguageManager.GetString("String_Sensor")).Append(strSpace)
                                              .Append('[').Append(intLimit.ToString(GlobalSettings.CultureInfo))
                                              .Append(']');
                                }
                            }

                            int intHomeNodeDP = HomeNode.GetTotalMatrixAttribute("Data Processing");
                            if (intHomeNodeDP > intLimit)
                            {
                                intLimit = intHomeNodeDP;
                                sbdToolTip.Clear();
                                sbdToolTip.Append(LanguageManager.GetString("String_DataProcessing")).Append(strSpace)
                                          .Append('[').Append(intLimit.ToString(GlobalSettings.CultureInfo))
                                          .Append(']');
                            }
                        }

                        foreach (Improvement objLoopImprovement in
                                 ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.MentalLimit))
                        {
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                      .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        /// <summary>
        /// The calculated Social Limit.
        /// </summary>
        public int LimitSocial
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    int intLimit;
                    if (IsAI && HomeNode != null)
                    {
                        int intHomeNodeDP = HomeNode.GetTotalMatrixAttribute("Data Processing");

                        if (HomeNode is Vehicle objHomeNodeVehicle)
                        {
                            int intHomeNodePilot = objHomeNodeVehicle.Pilot;
                            if (intHomeNodePilot > intHomeNodeDP)
                                intHomeNodeDP = intHomeNodePilot;
                        }

                        intLimit = (CHA.TotalValue + intHomeNodeDP + WIL.TotalValue + Essence().StandardRound() + 2)
                                   / 3;
                    }
                    else
                    {
                        intLimit = (CHA.TotalValue * 2 + WIL.TotalValue + Essence().StandardRound() + 2) / 3;
                    }

                    return intLimit + ImprovementManager.ValueOf(this, Improvement.ImprovementType.SocialLimit)
                                                        .StandardRound();
                }
            }
        }

        public string LimitSocialToolTip
        {
            get
            {
                string strSpace = LanguageManager.GetString("String_Space");
                using (EnterReadLock.Enter(LockObject))
                {
                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdToolTip))
                    {
                        sbdToolTip.Append('(').Append(CHA.DisplayAbbrev).Append(strSpace).Append('[')
                                  .Append(CHA.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(']');
                        if (IsAI && HomeNode != null)
                        {
                            int intHomeNodeDP = HomeNode.GetTotalMatrixAttribute("Data Processing");
                            string strDPString = LanguageManager.GetString("String_DataProcessing");
                            if (HomeNode is Vehicle objHomeNodeVehicle)
                            {
                                int intHomeNodePilot = objHomeNodeVehicle.Pilot;
                                if (intHomeNodePilot > intHomeNodeDP)
                                {
                                    intHomeNodeDP = intHomeNodePilot;
                                    strDPString = LanguageManager.GetString("String_Pilot");
                                }
                            }

                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace).Append(strDPString)
                                      .Append(strSpace)
                                      .Append('[').Append(intHomeNodeDP.ToString(GlobalSettings.CultureInfo))
                                      .Append(']');
                        }
                        else
                        {
                            sbdToolTip.Append(strSpace).Append('').Append(strSpace)
                                      .Append(2.ToString(GlobalSettings.CultureInfo));
                        }

                        sbdToolTip.Append(strSpace).Append('+').Append(strSpace).Append(WIL.DisplayAbbrev)
                                  .Append(strSpace)
                                  .Append('[').Append(WIL.TotalValue.ToString(GlobalSettings.CultureInfo)).Append(']')
                                  .Append(strSpace).Append('+').Append(strSpace).Append(ESS.DisplayAbbrev)
                                  .Append(strSpace)
                                  .Append('[').Append(DisplayEssence).Append("])").Append(strSpace).Append('/')
                                  .Append(strSpace)
                                  .Append(3.ToString(GlobalSettings.CultureInfo));

                        foreach (Improvement objLoopImprovement in
                                 ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.SocialLimit))
                        {
                            sbdToolTip.Append(strSpace).Append('+').Append(strSpace)
                                      .Append(GetObjectName(objLoopImprovement)).Append(strSpace).Append('(')
                                      .Append(objLoopImprovement.Value.ToString(GlobalSettings.CultureInfo))
                                      .Append(')');
                        }

                        return sbdToolTip.ToString();
                    }
                }
            }
        }

        public bool HasMentorSpirit
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return MentorSpirits.Count > 0;
            }
        }

        public string FirstMentorSpiritDisplayName
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return MentorSpirits.Count > 0
                        ? MentorSpirits[0].CurrentDisplayNameShort
                        : string.Empty;
            }
        }

        public string FirstMentorSpiritDisplayInformation
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (MentorSpirits.Count == 0)
                        return string.Empty;

                    MentorSpirit objMentorSpirit = MentorSpirits[0];
                    string strSpace = LanguageManager.GetString("String_Space");
                    return (LanguageManager.GetString("Label_SelectMentorSpirit_Advantage") + strSpace
                        + objMentorSpirit.DisplayAdvantage(GlobalSettings.Language)
                        + Environment.NewLine + Environment.NewLine
                        + LanguageManager.GetString("Label_SelectMetamagic_Disadvantage") + strSpace
                        + objMentorSpirit.DisplayDisadvantage(GlobalSettings.Language)).WordWrap();
                }
            }
        }

        #endregion

        #region Metatype/Metavariant Information

        /// <summary>
        /// Character's Metatype.
        /// </summary>
        public string Metatype
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strMetatype;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strMetatype == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _strMetatype = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Character's Metatype.
        /// </summary>
        public async ValueTask<string> GetMetatypeAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _strMetatype;
        }

        public Guid MetatypeGuid
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _guiMetatype;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_guiMetatype == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _guiMetatype = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// The name of the metatype as it should appear on printouts (translated name only).
        /// </summary>
        public string DisplayMetatype(string strLanguage)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (strLanguage.Equals(GlobalSettings.DefaultLanguage, StringComparison.OrdinalIgnoreCase))
                    return Metatype;

                return GetNodeXPath(true, strLanguage)?.SelectSingleNodeAndCacheExpression("translate")?.Value
                       ?? Metatype;
            }
        }

        /// <summary>
        /// The name of the metatype as it should appear on printouts (translated name only).
        /// </summary>
        public async ValueTask<string> DisplayMetatypeAsync(string strLanguage, CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                if (strLanguage.Equals(GlobalSettings.DefaultLanguage, StringComparison.OrdinalIgnoreCase))
                    return Metatype;

                XPathNavigator objNode = await GetNodeXPathAsync(true, strLanguage, token);
                return objNode != null
                    ? (await objNode.SelectSingleNodeAndCacheExpressionAsync("translate", token: token))
                    ?.Value ?? Metatype
                    : Metatype;
            }
        }

        /// <summary>
        /// Character's Metavariant.
        /// </summary>
        public string Metavariant
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strMetavariant;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strMetavariant == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _strMetavariant = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Character's Metavariant.
        /// </summary>
        public async ValueTask<string> GetMetavariantAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _strMetavariant;
        }

        public Guid MetavariantGuid
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _guiMetavariant;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_guiMetavariant == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _guiMetavariant = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        public async ValueTask<Guid> GetMetavariantGuidAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _guiMetavariant;
        }

        /// <summary>
        /// The name of the metatype as it should appear on printouts (translated name only).
        /// </summary>
        public string DisplayMetavariant(string strLanguage)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (strLanguage.Equals(GlobalSettings.DefaultLanguage, StringComparison.OrdinalIgnoreCase))
                    return Metavariant;

                return GetNodeXPath(false, strLanguage)?.SelectSingleNodeAndCacheExpression("translate")?.Value
                       ?? Metavariant;
            }
        }

        /// <summary>
        /// The name of the metatype as it should appear on printouts (translated name only).
        /// </summary>
        public async ValueTask<string> DisplayMetavariantAsync(string strLanguage, CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                if (strLanguage.Equals(GlobalSettings.DefaultLanguage, StringComparison.OrdinalIgnoreCase))
                    return Metavariant;

                XPathNavigator objNode = await GetNodeXPathAsync(false, strLanguage, token);
                return objNode != null
                    ? (await objNode.SelectSingleNodeAndCacheExpressionAsync("translate", token: token))
                             ?.Value ?? Metavariant
                    : Metavariant;
            }
        }

        public string FormattedMetatype => FormattedMetatypeMethod(GlobalSettings.Language);

        /// <summary>
        /// The metatype, including metavariant if any, in an appropriate language.
        /// </summary>
        /// <param name="strLanguage">Language to be used. Defaults to GlobalSettings.Language</param>
        public string FormattedMetatypeMethod(string strLanguage = "")
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (string.IsNullOrEmpty(strLanguage))
                    strLanguage = GlobalSettings.Language;
                string strMetatype = DisplayMetatype(strLanguage);

                if (MetavariantGuid != Guid.Empty)
                {
                    strMetatype += LanguageManager.GetString("String_Space") + '(' + DisplayMetavariant(strLanguage)
                                   + ')';
                }

                return strMetatype;
            }
        }

        /// <summary>
        /// The metatype, including metavariant if any, in an appropriate language.
        /// </summary>
        /// <param name="strLanguage">Language to be used. Defaults to GlobalSettings.Language</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public async ValueTask<string> FormattedMetatypeMethodAsync(string strLanguage = "", CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                if (string.IsNullOrEmpty(strLanguage))
                    strLanguage = GlobalSettings.Language;
                string strMetatype = await DisplayMetatypeAsync(strLanguage, token);

                if (MetavariantGuid != Guid.Empty)
                {
                    strMetatype += await LanguageManager.GetStringAsync("String_Space", token: token) + '('
                        + await DisplayMetavariantAsync(strLanguage, token) + ')';
                }

                return strMetatype;
            }
        }

        /// <summary>
        /// Metatype Category.
        /// </summary>
        public string MetatypeCategory
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strMetatypeCategory;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strMetatypeCategory == value)
                        return;
                    bool blnDoCyberzombieRefresh = _strMetatypeCategory == "Cyberzombie" || value == "Cyberzombie";
                    using (LockObject.EnterWriteLock())
                    {
                        _strMetatypeCategory = value;
                        OnPropertyChanged();
                        if (blnDoCyberzombieRefresh)
                            RefreshEssenceLossImprovements();
                    }
                }
            }
        }

        /// <summary>
        /// Metatype Category.
        /// </summary>
        public async ValueTask<string> GetMetatypeCategoryAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _strMetatypeCategory;
        }

        public int LimbCount(string strLimbSlot = "")
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (string.IsNullOrEmpty(strLimbSlot))
                {
                    return Settings.LimbCount + ImprovementManager.ValueOf(this, Improvement.ImprovementType.AddLimb)
                                                                  .StandardRound();
                }

                int intReturn =
                    1 + ImprovementManager.ValueOf(this, Improvement.ImprovementType.AddLimb, false, strLimbSlot)
                                          .StandardRound();
                if (strLimbSlot == "arm" || strLimbSlot == "leg")
                    ++intReturn;
                return intReturn;
            }
        }

        public async ValueTask<int> LimbCountAsync(string strLimbSlot = "", CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                if (string.IsNullOrEmpty(strLimbSlot))
                {
                    return Settings.LimbCount + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.AddLimb, token: token))
                                                                  .StandardRound();
                }

                int intReturn =
                    1 + (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.AddLimb, false, strLimbSlot, token: token))
                                          .StandardRound();
                if (strLimbSlot == "arm" || strLimbSlot == "leg")
                    ++intReturn;
                return intReturn;
            }
        }

        public string DisplayMovement
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return GetMovement(GlobalSettings.CultureInfo, GlobalSettings.Language);
            }
        }

        /// <summary>
        /// Character's Movement rate (Culture-dependent).
        /// </summary>
        public string GetMovement(CultureInfo objCulture, string strLanguage)
        {
            using (EnterReadLock.Enter(LockObject))
                // Don't attempt to do anything if the character's Movement is "Special" (typically for A.I.s).
                return Movement == "Special"
                    ? LanguageManager.GetString("String_ModeSpecial", strLanguage)
                    : CalculatedMovement("Ground", true, objCulture, strLanguage);
        }

        /// <summary>
        /// Character's Movement rate (Culture-dependent).
        /// </summary>
        public async ValueTask<string> GetMovementAsync(CultureInfo objCulture, string strLanguage, CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                // Don't attempt to do anything if the character's Movement is "Special" (typically for A.I.s).
                return await GetMovementAsync(token) == "Special"
                    ? await LanguageManager.GetStringAsync("String_ModeSpecial", strLanguage, token: token)
                    : await CalculatedMovementAsync("Ground", true, objCulture, strLanguage, token);
        }

        /// <summary>
        /// Character's Movement rate data string.
        /// </summary>
        public string Movement
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (string.IsNullOrWhiteSpace(_strMovement))
                    {
                        _strMovement = this.GetNodeXPath()?.SelectSingleNodeAndCacheExpression("movement")?.Value
                                       ?? GetNodeXPath(true)?.SelectSingleNodeAndCacheExpression("movement")?.Value
                                       ?? string.Empty;
                    }

                    return _strMovement;
                }
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strMovement == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _strMovement = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Character's Movement rate data string.
        /// </summary>
        public async ValueTask<string> GetMovementAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                if (string.IsNullOrWhiteSpace(_strMovement))
                {
                    XPathNavigator xmlDataNode = await this.GetNodeXPathAsync(token: token);
                    if (xmlDataNode != null)
                        _strMovement
                            = (await xmlDataNode.SelectSingleNodeAndCacheExpressionAsync("movement", token: token))?.Value
                              ?? string.Empty;
                    if (xmlDataNode == null || string.IsNullOrEmpty(_strMovement))
                    {
                        xmlDataNode = await GetNodeXPathAsync(true, token: token);
                        if (xmlDataNode != null)
                            _strMovement
                                = (await xmlDataNode.SelectSingleNodeAndCacheExpressionAsync("movement", token: token))?.Value
                                  ?? string.Empty;
                        else
                            _strMovement = string.Empty;
                    }
                }

                return _strMovement;
            }
        }

        /// <summary>
        /// Character's Run rate data string.
        /// </summary>
        public string RunString
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (string.IsNullOrWhiteSpace(_strRun))
                    {
                        _strRun = this.GetNodeXPath()?.SelectSingleNodeAndCacheExpression("run")?.Value
                                  ?? GetNodeXPath(true)?.SelectSingleNodeAndCacheExpression("run")?.Value
                                  ?? string.Empty;
                    }

                    return _strRun;
                }
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strRun == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _strRun = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Character's Run rate data string.
        /// </summary>
        public async ValueTask<string> GetRunStringAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                if (string.IsNullOrWhiteSpace(_strRun))
                {
                    XPathNavigator xmlDataNode = await this.GetNodeXPathAsync(token: token);
                    if (xmlDataNode != null)
                        _strRun
                            = (await xmlDataNode.SelectSingleNodeAndCacheExpressionAsync("run", token: token))?.Value
                              ?? string.Empty;
                    if (xmlDataNode == null || string.IsNullOrEmpty(_strRun))
                    {
                        xmlDataNode = await GetNodeXPathAsync(true, token: token);
                        if (xmlDataNode != null)
                            _strRun
                                = (await xmlDataNode.SelectSingleNodeAndCacheExpressionAsync("run", token: token))?.Value
                                  ?? string.Empty;
                        else
                            _strRun = string.Empty;
                    }
                }

                return _strRun;
            }
        }

        /// <summary>
        /// Character's Alternate Run rate data string.
        /// </summary>
        public string RunAltString
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (string.IsNullOrWhiteSpace(_strRunAlt))
                    {
                        _strRunAlt = this.GetNodeXPath()?.SelectSingleNodeAndCacheExpression("run")
                                         ?.GetAttribute("alt", string.Empty)
                                     ?? GetNodeXPath(true)?.SelectSingleNodeAndCacheExpression("run")
                                                          ?.GetAttribute("alt", string.Empty)
                                     ?? string.Empty;
                    }

                    return _strRunAlt;
                }
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strRunAlt == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _strRunAlt = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Character's Alternate Run rate data string.
        /// </summary>
        public async ValueTask<string> GetRunAltStringAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                if (string.IsNullOrWhiteSpace(_strRunAlt))
                {
                    XPathNavigator xmlDataNode = await this.GetNodeXPathAsync(token: token);
                    if (xmlDataNode != null)
                        _strRunAlt
                            = (await xmlDataNode.SelectSingleNodeAndCacheExpressionAsync("run", token: token))?.GetAttribute("alt", string.Empty)
                              ?? string.Empty;
                    if (xmlDataNode == null || string.IsNullOrEmpty(_strRunAlt))
                    {
                        xmlDataNode = await GetNodeXPathAsync(true, token: token);
                        if (xmlDataNode != null)
                            _strRunAlt
                                = (await xmlDataNode.SelectSingleNodeAndCacheExpressionAsync("run", token: token))?.GetAttribute("alt", string.Empty)
                                  ?? string.Empty;
                        else
                            _strRunAlt = string.Empty;
                    }
                }

                return _strRunAlt;
            }
        }

        /// <summary>
        /// Character's Walk rate data string.
        /// </summary>
        public string WalkString
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (string.IsNullOrWhiteSpace(_strWalk))
                    {
                        _strWalk = this.GetNodeXPath()?.SelectSingleNodeAndCacheExpression("walk")?.Value
                                   ?? GetNodeXPath(true)?.SelectSingleNodeAndCacheExpression("walk")?.Value
                                   ?? string.Empty;
                    }

                    return _strWalk;
                }
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strWalk == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _strWalk = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Character's Walk rate data string.
        /// </summary>
        public async ValueTask<string> GetWalkStringAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                if (string.IsNullOrWhiteSpace(_strWalk))
                {
                    XPathNavigator xmlDataNode = await this.GetNodeXPathAsync(token: token);
                    if (xmlDataNode != null)
                        _strWalk
                            = (await xmlDataNode.SelectSingleNodeAndCacheExpressionAsync("walk", token: token))?.Value
                              ?? string.Empty;
                    if (xmlDataNode == null || string.IsNullOrEmpty(_strWalk))
                    {
                        xmlDataNode = await GetNodeXPathAsync(true, token: token);
                        if (xmlDataNode != null)
                            _strWalk
                                = (await xmlDataNode.SelectSingleNodeAndCacheExpressionAsync("walk", token: token))?.Value
                                  ?? string.Empty;
                        else
                            _strWalk = string.Empty;
                    }
                }

                return _strWalk;
            }
        }

        /// <summary>
        /// Character's Alternate Walk rate data string.
        /// </summary>
        public string WalkAltString
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (string.IsNullOrWhiteSpace(_strWalkAlt))
                    {
                        _strWalkAlt = this.GetNodeXPath()?.SelectSingleNodeAndCacheExpression("walk")
                                          ?.GetAttribute("alt", string.Empty)
                                      ?? GetNodeXPath(true)?.SelectSingleNodeAndCacheExpression("walk")
                                                           ?.GetAttribute("alt", string.Empty)
                                      ?? string.Empty;
                    }

                    return _strWalkAlt;
                }
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strWalkAlt == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _strWalkAlt = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Character's Alternate Walk rate data string.
        /// </summary>
        public async ValueTask<string> GetWalkAltStringAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                if (string.IsNullOrWhiteSpace(_strWalkAlt))
                {
                    XPathNavigator xmlDataNode = await this.GetNodeXPathAsync(token: token);
                    if (xmlDataNode != null)
                        _strWalkAlt
                            = (await xmlDataNode.SelectSingleNodeAndCacheExpressionAsync("walk", token: token))?.GetAttribute("alt", string.Empty)
                              ?? string.Empty;
                    if (xmlDataNode == null || string.IsNullOrEmpty(_strWalkAlt))
                    {
                        xmlDataNode = await GetNodeXPathAsync(true, token: token);
                        if (xmlDataNode != null)
                            _strWalkAlt
                                = (await xmlDataNode.SelectSingleNodeAndCacheExpressionAsync("walk", token: token))?.GetAttribute("alt", string.Empty)
                                  ?? string.Empty;
                        else
                            _strWalkAlt = string.Empty;
                    }
                }

                return _strWalkAlt;
            }
        }

        /// <summary>
        /// Character's Sprint rate data string.
        /// </summary>
        public string SprintString
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (string.IsNullOrWhiteSpace(_strSprint))
                    {
                        _strSprint = this.GetNodeXPath()?.SelectSingleNodeAndCacheExpression("sprint")?.Value
                                     ?? GetNodeXPath(true)?.SelectSingleNodeAndCacheExpression("sprint")?.Value
                                     ?? string.Empty;
                    }

                    return _strSprint;
                }
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strSprint == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _strSprint = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Character's Spring rate data string.
        /// </summary>
        public async ValueTask<string> GetSprintStringAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                if (string.IsNullOrWhiteSpace(_strSprint))
                {
                    XPathNavigator xmlDataNode = await this.GetNodeXPathAsync(token: token);
                    if (xmlDataNode != null)
                        _strSprint
                            = (await xmlDataNode.SelectSingleNodeAndCacheExpressionAsync("sprint", token: token))?.Value
                              ?? string.Empty;
                    if (xmlDataNode == null || string.IsNullOrEmpty(_strSprint))
                    {
                        xmlDataNode = await GetNodeXPathAsync(true, token: token);
                        if (xmlDataNode != null)
                            _strSprint
                                = (await xmlDataNode.SelectSingleNodeAndCacheExpressionAsync("sprint", token: token))?.Value
                                  ?? string.Empty;
                        else
                            _strSprint = string.Empty;
                    }
                }

                return _strSprint;
            }
        }

        /// <summary>
        /// Character's Alternate Sprint rate data string.
        /// </summary>
        public string SprintAltString
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (string.IsNullOrWhiteSpace(_strSprintAlt))
                    {
                        _strSprintAlt = this.GetNodeXPath()?.SelectSingleNodeAndCacheExpression("sprint")
                                            ?.GetAttribute("alt", string.Empty)
                                        ?? GetNodeXPath(true)?.SelectSingleNodeAndCacheExpression("sprint")
                                                             ?.GetAttribute("alt", string.Empty)
                                        ?? string.Empty;
                    }

                    return _strSprintAlt;
                }
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strSprintAlt == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _strSprintAlt = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Character's Alternate Sprint rate data string.
        /// </summary>
        public async ValueTask<string> GetSprintAltStringAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                if (string.IsNullOrWhiteSpace(_strSprintAlt))
                {
                    XPathNavigator xmlDataNode = await this.GetNodeXPathAsync(token: token);
                    if (xmlDataNode != null)
                        _strSprintAlt
                            = (await xmlDataNode.SelectSingleNodeAndCacheExpressionAsync("sprint", token: token))?.GetAttribute("alt", string.Empty)
                              ?? string.Empty;
                    if (xmlDataNode == null || string.IsNullOrEmpty(_strSprintAlt))
                    {
                        xmlDataNode = await GetNodeXPathAsync(true, token: token);
                        if (xmlDataNode != null)
                            _strSprintAlt
                                = (await xmlDataNode.SelectSingleNodeAndCacheExpressionAsync("sprint", token: token))?.GetAttribute("alt", string.Empty)
                                  ?? string.Empty;
                        else
                            _strSprintAlt = string.Empty;
                    }
                }

                return _strSprintAlt;
            }
        }

        public string CurrentWalkingRateString
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AttributeSection.AttributeCategory == CharacterAttrib.AttributeCategory.Standard
                        ? WalkString
                        : WalkAltString;
            }
        }

        public string CurrentRunningRateString
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AttributeSection.AttributeCategory == CharacterAttrib.AttributeCategory.Standard
                        ? RunString
                        : RunAltString;
            }
        }

        public string CurrentSprintingRateString
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AttributeSection.AttributeCategory == CharacterAttrib.AttributeCategory.Standard
                        ? SprintString
                        : SprintAltString;
            }
        }

        public async ValueTask<string> GetCurrentWalkingRateStringAsync(CancellationToken token = default)
        {
            {
                using (await EnterReadLock.EnterAsync(LockObject, token))
                    return await (await (await GetAttributeSectionAsync(token)).GetAttributeCategoryAsync(token)
                                  == CharacterAttrib.AttributeCategory.Standard
                        ? GetWalkStringAsync(token)
                        : GetWalkAltStringAsync(token));
            }
        }

        public async ValueTask<string> GetCurrentRunningRateStringAsync(CancellationToken token = default)
        {
            {
                using (await EnterReadLock.EnterAsync(LockObject, token))
                    return await (await (await GetAttributeSectionAsync(token)).GetAttributeCategoryAsync(token)
                                  == CharacterAttrib.AttributeCategory.Standard
                        ? GetRunStringAsync(token)
                        : GetRunAltStringAsync(token));
            }
        }

        public async ValueTask<string> GetCurrentSprintingRateStringAsync(CancellationToken token = default)
        {
            {
                using (await EnterReadLock.EnterAsync(LockObject, token))
                    return await (await (await GetAttributeSectionAsync(token)).GetAttributeCategoryAsync(token)
                                  == CharacterAttrib.AttributeCategory.Standard
                        ? GetSprintStringAsync(token)
                        : GetSprintAltStringAsync(token));
            }
        }

        /// <summary>
        /// Character's running Movement rate.
        /// <param name="strType">Takes one of three parameters: Ground, 2 for Swim, 3 for Fly. Returns 0 if the requested type isn't found.</param>
        /// </summary>
        public decimal WalkingRate(string strType = "Ground")
        {
            using (EnterReadLock.Enter(LockObject))
            {
                decimal decTmp = decimal.MinValue;
                foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                             this, Improvement.ImprovementType.WalkSpeed, strType))
                    decTmp = Math.Max(decTmp, objImprovement.Value);

                if (decTmp != decimal.MinValue)
                    return decTmp;

                int intIndexToGet = 0;
                switch (strType)
                {
                    case "Fly":
                        intIndexToGet = 2;
                        break;
                    case "Swim":
                        intIndexToGet = 1;
                        break;
                }

                string strReturn = CurrentWalkingRateString.SplitNoAlloc('/', StringSplitOptions.RemoveEmptyEntries)
                                                           .ElementAtOrDefault(intIndexToGet);
                if (strReturn != null)
                    decimal.TryParse(strReturn, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                     out decTmp);
                return decTmp;
            }
        }

        /// <summary>
        /// Character's running Movement rate.
        /// <param name="strType">Takes one of three parameters: Ground, 2 for Swim, 3 for Fly. Returns 0 if the requested type isn't found.</param>
        /// </summary>
        public async ValueTask<decimal> WalkingRateAsync(string strType = "Ground", CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                decimal decTmp = decimal.MinValue;
                foreach (Improvement objImprovement in await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                             this, Improvement.ImprovementType.WalkSpeed, strType, token: token))
                    decTmp = Math.Max(decTmp, objImprovement.Value);

                if (decTmp != decimal.MinValue)
                    return decTmp;

                int intIndexToGet = 0;
                switch (strType)
                {
                    case "Fly":
                        intIndexToGet = 2;
                        break;
                    case "Swim":
                        intIndexToGet = 1;
                        break;
                }

                string strReturn = (await GetCurrentWalkingRateStringAsync(token))
                                   .SplitNoAlloc('/', StringSplitOptions.RemoveEmptyEntries)
                                   .ElementAtOrDefault(intIndexToGet);
                if (strReturn != null)
                    decimal.TryParse(strReturn, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                     out decTmp);
                return decTmp;
            }
        }

        /// <summary>
        /// Character's running Movement rate.
        /// <param name="strType">Takes one of three parameters: Ground, 2 for Swim, 3 for Fly. Returns 0 if the requested type isn't found.</param>
        /// </summary>
        public decimal RunningRate(string strType = "Ground")
        {
            using (EnterReadLock.Enter(LockObject))
            {
                decimal decTmp = decimal.MinValue;
                foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                             this, Improvement.ImprovementType.RunSpeed, strType))
                    decTmp = Math.Max(decTmp, objImprovement.Value);

                if (decTmp != decimal.MinValue)
                    return decTmp;

                int intIndexToGet = 0;
                switch (strType)
                {
                    case "Fly":
                        intIndexToGet = 2;
                        break;
                    case "Swim":
                        intIndexToGet = 1;
                        break;
                }

                string strReturn = CurrentRunningRateString.SplitNoAlloc('/', StringSplitOptions.RemoveEmptyEntries)
                                                           .ElementAtOrDefault(intIndexToGet);
                if (strReturn != null)
                    decimal.TryParse(strReturn, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                     out decTmp);
                return decTmp;
            }
        }

        /// <summary>
        /// Character's running Movement rate.
        /// <param name="strType">Takes one of three parameters: Ground, 2 for Swim, 3 for Fly. Returns 0 if the requested type isn't found.</param>
        /// </summary>
        public async ValueTask<decimal> RunningRateAsync(string strType = "Ground", CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                decimal decTmp = decimal.MinValue;
                foreach (Improvement objImprovement in await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                             this, Improvement.ImprovementType.RunSpeed, strType, token: token))
                    decTmp = Math.Max(decTmp, objImprovement.Value);

                if (decTmp != decimal.MinValue)
                    return decTmp;

                int intIndexToGet = 0;
                switch (strType)
                {
                    case "Fly":
                        intIndexToGet = 2;
                        break;
                    case "Swim":
                        intIndexToGet = 1;
                        break;
                }

                string strReturn = (await GetCurrentRunningRateStringAsync(token))
                                   .SplitNoAlloc('/', StringSplitOptions.RemoveEmptyEntries)
                                   .ElementAtOrDefault(intIndexToGet);
                if (strReturn != null)
                    decimal.TryParse(strReturn, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                     out decTmp);
                return decTmp;
            }
        }

        /// <summary>
        /// Character's sprinting Movement rate (meters per hit).
        /// <param name="strType">Takes one of three parameters: Ground, 2 for Swim, 3 for Fly. Returns 0 if the requested type isn't found.</param>
        /// </summary>
        public decimal SprintingRate(string strType = "Ground")
        {
            using (EnterReadLock.Enter(LockObject))
            {
                decimal decTmp = decimal.MinValue;
                foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                             this, Improvement.ImprovementType.SprintSpeed, strType))
                    decTmp = Math.Max(decTmp, objImprovement.Value / 100.0m);

                if (decTmp != decimal.MinValue)
                    return decTmp;

                int intIndexToGet = 0;
                switch (strType)
                {
                    case "Fly":
                        intIndexToGet = 2;
                        break;
                    case "Swim":
                        intIndexToGet = 1;
                        break;
                }

                string strReturn = CurrentSprintingRateString.SplitNoAlloc('/', StringSplitOptions.RemoveEmptyEntries)
                                                             .ElementAtOrDefault(intIndexToGet);
                if (strReturn != null)
                    decimal.TryParse(strReturn, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                     out decTmp);
                return decTmp;
            }
        }

        /// <summary>
        /// Character's sprinting Movement rate (meters per hit).
        /// <param name="strType">Takes one of three parameters: Ground, 2 for Swim, 3 for Fly. Returns 0 if the requested type isn't found.</param>
        /// </summary>
        public async ValueTask<decimal> SprintingRateAsync(string strType = "Ground", CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                decimal decTmp = decimal.MinValue;
                foreach (Improvement objImprovement in await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                             this, Improvement.ImprovementType.SprintSpeed, strType, token: token))
                    decTmp = Math.Max(decTmp, objImprovement.Value / 100.0m);

                if (decTmp != decimal.MinValue)
                    return decTmp;

                int intIndexToGet = 0;
                switch (strType)
                {
                    case "Fly":
                        intIndexToGet = 2;
                        break;
                    case "Swim":
                        intIndexToGet = 1;
                        break;
                }

                string strReturn = (await GetCurrentSprintingRateStringAsync(token))
                                   .SplitNoAlloc('/', StringSplitOptions.RemoveEmptyEntries)
                                   .ElementAtOrDefault(intIndexToGet);
                if (strReturn != null)
                    decimal.TryParse(strReturn, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                     out decTmp);
                return decTmp;
            }
        }

        public string CalculatedMovement(string strMovementType, bool blnUseCyberlegs = false,
            CultureInfo objCulture = null, string strLanguage = "")
        {
            using (EnterReadLock.Enter(LockObject))
            {
                decimal decSprint = SprintingRate(strMovementType) +
                                    ImprovementManager.ValueOf(this, Improvement.ImprovementType.SprintBonus, false,
                                                               strMovementType) / 100.0m;
                decimal decRun = RunningRate(strMovementType) + ImprovementManager.ValueOf(this,
                    Improvement.ImprovementType.RunMultiplier, false, strMovementType);
                decimal decWalk = WalkingRate(strMovementType) + ImprovementManager.ValueOf(this,
                    Improvement.ImprovementType.WalkMultiplier, false, strMovementType);
                // Everything else after this just multiplies values, so zeroes can be checked for here
                if (decWalk == 0 && decRun == 0 && decSprint == 0)
                {
                    return "0";
                }

                decSprint *= 1.0m + ImprovementManager.ValueOf(this, Improvement.ImprovementType.SprintBonusPercent,
                                                               false,
                                                               strMovementType) / 100.0m;
                decRun *= 1.0m + ImprovementManager.ValueOf(this, Improvement.ImprovementType.RunMultiplierPercent,
                                                            false,
                                                            strMovementType) / 100.0m;
                decWalk *= 1.0m + ImprovementManager.ValueOf(this, Improvement.ImprovementType.WalkMultiplierPercent,
                                                             false,
                                                             strMovementType) / 100.0m;

                int intAGI = AGI.CalculatedTotalValue(false);
                int intSTR = STR.CalculatedTotalValue(false);
                if (Settings.CyberlegMovement && blnUseCyberlegs)
                {
                    int intTempAGI = int.MaxValue;
                    int intTempSTR = int.MaxValue;
                    int intLegs = 0;
                    foreach (Cyberware objCyber in Cyberware.Where(objCyber => objCyber.LimbSlot == "leg"))
                    {
                        intLegs += objCyber.LimbSlotCount;
                        intTempAGI = Math.Min(intTempAGI, objCyber.GetAttributeTotalValue("AGI"));
                        intTempSTR = Math.Min(intTempSTR, objCyber.GetAttributeTotalValue("STR"));
                    }

                    if (intTempAGI != int.MaxValue && intTempSTR != int.MaxValue && intLegs >= 2)
                    {
                        intAGI = intTempAGI;
                        intSTR = intTempSTR;
                    }
                }

                if (strMovementType == "Swim")
                {
                    decWalk *= (intAGI + intSTR) * 0.5m;
                    decRun *= (intAGI + intSTR) * 0.5m;
                }
                else
                {
                    decWalk *= intAGI;
                    decRun *= intAGI;
                }

                if (objCulture == null)
                    objCulture = GlobalSettings.CultureInfo;
                string strReturn = string.Empty;
                if (decWalk != 0)
                {
                    if (decRun != 0)
                        strReturn = decWalk.ToString("#,0.##", objCulture) + '/'
                                                                           + decRun.ToString("#,0.##", objCulture);
                    else
                        strReturn = decWalk.ToString("#,0.##", objCulture);
                }
                else if (decRun != 0 || decSprint != 0)
                    strReturn = decRun.ToString("#,0.##", objCulture);

                if (decSprint != 0)
                {
                    if (!string.IsNullOrEmpty(strReturn))
                        strReturn += ';' + LanguageManager.GetString("String_Space", strLanguage);
                    strReturn += decSprint.ToString("#,0.##", objCulture)
                                 + LanguageManager.GetString("String_MetersPerHit", strLanguage);
                }

                return strReturn;
            }
        }

        public async ValueTask<string> CalculatedMovementAsync(string strMovementType, bool blnUseCyberlegs = false,
            CultureInfo objCulture = null, string strLanguage = "", CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                decimal decSprint = await SprintingRateAsync(strMovementType, token)
                                    + await ImprovementManager.ValueOfAsync(
                                        this, Improvement.ImprovementType.SprintBonus, false, strMovementType,
                                        token: token) / 100.0m;
                decimal decRun = await RunningRateAsync(strMovementType, token)
                                 + await ImprovementManager.ValueOfAsync(
                                     this, Improvement.ImprovementType.RunMultiplier, false, strMovementType,
                                     token: token);
                decimal decWalk = await WalkingRateAsync(strMovementType, token)
                                  + await ImprovementManager.ValueOfAsync(
                                      this, Improvement.ImprovementType.WalkMultiplier, false, strMovementType,
                                      token: token);
                // Everything else after this just multiplies values, so zeroes can be checked for here
                if (decWalk == 0 && decRun == 0 && decSprint == 0)
                {
                    return "0";
                }

                decSprint *= 1.0m + await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.SprintBonusPercent,
                                                                          false,
                                                                          strMovementType, token: token) / 100.0m;
                decRun *= 1.0m + await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.RunMultiplierPercent,
                                                                       false,
                                                                       strMovementType, token: token) / 100.0m;
                decWalk *= 1.0m + await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.WalkMultiplierPercent,
                                                                        false,
                                                                        strMovementType, token: token) / 100.0m;

                int intAGI = await AGI.CalculatedTotalValueAsync(false, token);
                int intSTR = await STR.CalculatedTotalValueAsync(false, token);
                if (blnUseCyberlegs && await (await GetSettingsAsync(token)).GetCyberlegMovementAsync(token))
                {
                    int intTempAGI = int.MaxValue;
                    int intTempSTR = int.MaxValue;
                    int intLegs = 0;
                    await Cyberware.ForEachAsync(async objCyber =>
                    {
                        if (objCyber.LimbSlot != "leg")
                            return;
                        intLegs += objCyber.LimbSlotCount;
                        intTempAGI = Math.Min(intTempAGI, await objCyber.GetAttributeTotalValueAsync("AGI", token));
                        intTempSTR = Math.Min(intTempSTR, await objCyber.GetAttributeTotalValueAsync("STR", token));
                    }, token);

                    if (intTempAGI != int.MaxValue && intTempSTR != int.MaxValue && intLegs >= 2)
                    {
                        intAGI = intTempAGI;
                        intSTR = intTempSTR;
                    }
                }

                if (strMovementType == "Swim")
                {
                    decWalk *= (intAGI + intSTR) * 0.5m;
                    decRun *= (intAGI + intSTR) * 0.5m;
                }
                else
                {
                    decWalk *= intAGI;
                    decRun *= intAGI;
                }

                if (objCulture == null)
                    objCulture = GlobalSettings.CultureInfo;
                string strReturn = string.Empty;
                if (decWalk != 0)
                {
                    if (decRun != 0)
                        strReturn = decWalk.ToString("#,0.##", objCulture) + '/'
                                                                           + decRun.ToString("#,0.##", objCulture);
                    else
                        strReturn = decWalk.ToString("#,0.##", objCulture);
                }
                else if (decRun != 0 || decSprint != 0)
                    strReturn = decRun.ToString("#,0.##", objCulture);

                if (decSprint != 0)
                {
                    if (!string.IsNullOrEmpty(strReturn))
                        strReturn += ';' + await LanguageManager.GetStringAsync("String_Space", strLanguage, token: token);
                    strReturn += decSprint.ToString("#,0.##", objCulture)
                                 + await LanguageManager.GetStringAsync("String_MetersPerHit", strLanguage, token: token);
                }

                return strReturn;
            }
        }

        public string DisplaySwim
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return GetSwim(GlobalSettings.CultureInfo, GlobalSettings.Language);
            }
        }

        /// <summary>
        /// Character's Swim rate.
        /// </summary>
        public string GetSwim(CultureInfo objCulture, string strLanguage)
        {
            using (EnterReadLock.Enter(LockObject))
                // Don't attempt to do anything if the character's Movement is "Special" (typically for A.I.s).
                return Movement == "Special"
                    ? LanguageManager.GetString("String_ModeSpecial", strLanguage)
                    : CalculatedMovement("Swim", false, objCulture, strLanguage);
        }

        /// <summary>
        /// Character's Swim rate.
        /// </summary>
        public async ValueTask<string> GetSwimAsync(CultureInfo objCulture, string strLanguage, CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                // Don't attempt to do anything if the character's Movement is "Special" (typically for A.I.s).
                return await GetMovementAsync(token) == "Special"
                    ? await LanguageManager.GetStringAsync("String_ModeSpecial", strLanguage, token: token)
                    : await CalculatedMovementAsync("Swim", false, objCulture, strLanguage, token);
        }

        public string DisplayFly
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return GetFly(GlobalSettings.CultureInfo, GlobalSettings.Language);
            }
        }

        /// <summary>
        /// Character's Fly rate.
        /// </summary>
        public string GetFly(CultureInfo objCulture, string strLanguage)
        {
            using (EnterReadLock.Enter(LockObject))
                // Don't attempt to do anything if the character's Movement is "Special" (typically for A.I.s).
                return Movement == "Special"
                    ? LanguageManager.GetString("String_ModeSpecial", strLanguage)
                    : CalculatedMovement("Fly", false, objCulture, strLanguage);
        }

        /// <summary>
        /// Character's Fly rate.
        /// </summary>
        public async ValueTask<string> GetFlyAsync(CultureInfo objCulture, string strLanguage, CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                // Don't attempt to do anything if the character's Movement is "Special" (typically for A.I.s).
                return await GetMovementAsync(token) == "Special"
                    ? await LanguageManager.GetStringAsync("String_ModeSpecial", strLanguage, token: token)
                    : await CalculatedMovementAsync("Fly", false, objCulture, strLanguage, token);
        }

        /// <summary>
        /// Full Movement (Movement, Swim, and Fly) for printouts.
        /// </summary>
        private string FullMovement(CultureInfo objCulture, string strLanguage)
        {
            string strSpace = LanguageManager.GetString("String_Space");
            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdReturn))
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    string strGroundMovement = GetMovement(objCulture, strLanguage);
                    string strSwimMovement = GetSwim(objCulture, strLanguage);
                    string strFlyMovement = GetFly(objCulture, strLanguage);
                    if (!string.IsNullOrEmpty(strGroundMovement) && strGroundMovement != "0")
                        sbdReturn.Append(strGroundMovement).Append(',').Append(strSpace);
                    if (!string.IsNullOrEmpty(strSwimMovement) && strSwimMovement != "0")
                        sbdReturn.Append(LanguageManager.GetString("Label_OtherSwim", strLanguage)).Append(strSpace)
                                 .Append(strSwimMovement).Append(',').Append(strSpace);
                    if (!string.IsNullOrEmpty(strFlyMovement) && strFlyMovement != "0")
                        sbdReturn.Append(LanguageManager.GetString("Label_OtherFly", strLanguage)).Append(strSpace)
                                 .Append(strFlyMovement).Append(',').Append(strSpace);
                }

                // Remove the trailing ", ".
                if (sbdReturn.Length > 0)
                    sbdReturn.Length -= 2;

                return sbdReturn.ToString();
            }
        }

        /// <summary>
        /// Full Movement (Movement, Swim, and Fly) for printouts.
        /// </summary>
        private async ValueTask<string> FullMovementAsync(CultureInfo objCulture, string strLanguage, CancellationToken token = default)
        {
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token);
            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdReturn))
            {
                using (await EnterReadLock.EnterAsync(LockObject, token))
                {
                    string strGroundMovement = await GetMovementAsync(objCulture, strLanguage, token);
                    string strSwimMovement = await GetSwimAsync(objCulture, strLanguage, token);
                    string strFlyMovement = await GetFlyAsync(objCulture, strLanguage, token);
                    if (!string.IsNullOrEmpty(strGroundMovement) && strGroundMovement != "0")
                        sbdReturn.Append(strGroundMovement).Append(',').Append(strSpace);
                    if (!string.IsNullOrEmpty(strSwimMovement) && strSwimMovement != "0")
                        sbdReturn.Append(await LanguageManager.GetStringAsync("Label_OtherSwim", strLanguage, token: token)).Append(strSpace)
                                 .Append(strSwimMovement).Append(',').Append(strSpace);
                    if (!string.IsNullOrEmpty(strFlyMovement) && strFlyMovement != "0")
                        sbdReturn.Append(await LanguageManager.GetStringAsync("Label_OtherFly", strLanguage, token: token)).Append(strSpace)
                                 .Append(strFlyMovement).Append(',').Append(strSpace);
                }

                // Remove the trailing ", ".
                if (sbdReturn.Length > 0)
                    sbdReturn.Length -= 2;

                return sbdReturn.ToString();
            }
        }

        /// <summary>
        /// BP cost of character's Metatype.
        /// </summary>
        public int MetatypeBP
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intMetatypeBP;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intMetatypeBP == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _intMetatypeBP = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        public async ValueTask<int> GetMetatypeBPAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _intMetatypeBP;
        }

        /// <summary>
        /// MetatypeBP as a string, including Karma string and multiplied by options as relevant.
        /// TODO: Belongs in a viewmodel for frmCreate rather than the main character class?
        /// </summary>
        public string DisplayMetatypeBP
        {
            get
            {
                string s = string.Empty;
                using (EnterReadLock.Enter(LockObject))
                {
                    switch (EffectiveBuildMethod)
                    {
                        case CharacterBuildMethod.Karma:
                        case CharacterBuildMethod.LifeModule:
                            s = (MetatypeBP * Settings.MetatypeCostsKarmaMultiplier).ToString(
                                GlobalSettings.CultureInfo);
                            break;
                        case CharacterBuildMethod.Priority:
                        case CharacterBuildMethod.SumtoTen:
                            s = (MetatypeBP).ToString(GlobalSettings.CultureInfo);
                            break;
                    }
                }

                s += LanguageManager.GetString("String_Space") + LanguageManager.GetString("String_Karma");
                return s;
            }
        }

        /// <summary>
        /// Whether or not the character is a non-Free Sprite.
        /// </summary>
        public bool IsSprite
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return MetatypeCategory.EndsWith("Sprites", StringComparison.Ordinal) && !IsFreeSprite;
            }
        }

        /// <summary>
        /// Whether or not the character is a Free Sprite.
        /// </summary>
        public bool IsFreeSprite
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return MetatypeCategory == "Free Sprite";
            }
        }

        /// <summary>
        /// Whether or not the character is a Free Sprite.
        /// </summary>
        public async ValueTask<bool> GetIsFreeSpriteAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return MetatypeCategory == "Free Sprite";
        }

        #endregion

        #region Special Functions and Enabled Check Properties

        /// <summary>
        /// Whether or not Adept options are enabled.
        /// </summary>
        public bool AdeptEnabled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnAdeptEnabled;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnAdeptEnabled == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnAdeptEnabled = value;
                        if (!value)
                        {
                            ClearAdeptPowers();
                        }

                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Whether or not Adept options are enabled.
        /// </summary>
        public async ValueTask<bool> GetAdeptEnabledAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _blnAdeptEnabled;
        }

        /// <summary>
        /// Whether or not Magician options are enabled.
        /// </summary>
        public bool MagicianEnabled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnMagicianEnabled;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnMagicianEnabled == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnMagicianEnabled = value;
                        if (!value)
                        {
                            ClearMagic(AdeptEnabled);
                        }

                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Whether or not Magician options are enabled.
        /// </summary>
        public async ValueTask<bool> GetMagicianEnabledAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _blnMagicianEnabled;
        }

        /// <summary>
        /// Whether or not Technomancer options are enabled.
        /// </summary>
        public bool TechnomancerEnabled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnTechnomancerEnabled;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnTechnomancerEnabled == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnTechnomancerEnabled = value;
                        if (!value)
                        {
                            ClearResonance();
                        }

                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Whether or not Technomancer options are enabled.
        /// </summary>
        public async ValueTask<bool> GetTechnomancerEnabledAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _blnTechnomancerEnabled;
        }

        /// <summary>
        /// Whether or not the Drug Psyche is active
        /// </summary>
        public bool PsycheActive
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnPsycheActive;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnPsycheActive == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnPsycheActive = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Whether or not Advanced Program options are enabled.
        /// </summary>
        public bool AdvancedProgramsEnabled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnAdvancedProgramsEnabled;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnAdvancedProgramsEnabled == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnAdvancedProgramsEnabled = value;
                        if (!value)
                        {
                            ClearAdvancedPrograms();
                        }

                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Whether or not Cyberware options are disabled.
        /// </summary>
        public bool CyberwareDisabled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnCyberwareDisabled;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnCyberwareDisabled == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnCyberwareDisabled = value;
                        if (value)
                            ClearCyberwareTab();

                        OnPropertyChanged();
                    }
                }
            }
        }

        public bool AddCyberwareEnabled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return !CyberwareDisabled && !IsAI
                                              && ImprovementManager
                                                 .GetCachedImprovementListForValueOf(
                                                     this, Improvement.ImprovementType.DisableCyberware)
                                                 .Count == 0;
            }
        }

        public bool AddBiowareEnabled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return !CyberwareDisabled && !IsAI
                                              && ImprovementManager
                                                 .GetCachedImprovementListForValueOf(
                                                     this, Improvement.ImprovementType.DisableBioware)
                                                 .Count == 0;
            }
        }

        private int _intCachedInitiationEnabled = int.MinValue;

        /// <summary>
        /// Whether or not the Initiation tab should be shown (override for BP mode).
        /// </summary>
        public bool InitiationEnabled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedInitiationEnabled < 0)
                    {
                        _intCachedInitiationEnabled = !InitiationForceDisabled && (MAGEnabled || RESEnabled) ? 1 : 0;
                    }

                    return _intCachedInitiationEnabled > 0;
                }
            }
        }

        public bool InitiationForceDisabled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnInitiationDisabled;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnInitiationDisabled == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnInitiationDisabled = value;
                        if (value)
                        {
                            ClearInitiations();
                        }

                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Whether or not Critter options are enabled.
        /// </summary>
        public bool CritterEnabled
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnCritterEnabled;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnCritterEnabled == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnCritterEnabled = value;
                        if (!value)
                        {
                            ClearCritterPowers();
                        }

                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Whether or not Black Market Discount is enabled.
        /// </summary>
        public bool DealerConnectionDiscount => ImprovementManager
                                                .GetCachedImprovementListForValueOf(
                                                    this, Improvement.ImprovementType.DealerConnection).Count > 0;

        public void RefreshDealerConnectionDiscounts()
        {
            using (EnterReadLock.Enter(LockObject))
            {
                // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
                if (IsLoading)
                    return;

                if (Created)
                    return; // Don't need to refresh properties in Career mode because costs are calculated immediately upon purchasing stuff

                if (DealerConnectionDiscount)
                    return;

                using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                out HashSet<string> setDealerConnectionMaps))
                {
                    foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                 this, Improvement.ImprovementType.DealerConnection))
                    {
                        setDealerConnectionMaps.Add(objImprovement.UniqueName);
                    }

                    using (LockObject.EnterWriteLock())
                    {
                        foreach (Vehicle objVehicle in Vehicles)
                        {
                            objVehicle.DealerConnectionDiscount = objVehicle.DealerConnectionDiscount
                                                                  && Vehicle.DoesDealerConnectionApply(
                                                                      setDealerConnectionMaps, objVehicle.Category);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Whether or not Black Market Discount is enabled.
        /// </summary>
        public bool BlackMarketDiscount => ImprovementManager
                                           .GetCachedImprovementListForValueOf(
                                               this, Improvement.ImprovementType.BlackMarketDiscount).Count
                                           > 0;

        public void RefreshBlackMarketDiscounts()
        {
            using (EnterReadLock.Enter(LockObject))
            {
                // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
                if (IsLoading)
                    return;

                if (Created)
                    return; // Don't need to refresh properties in Career mode because costs are calculated immediately upon purchasing stuff

                if (BlackMarketDiscount)
                {
                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                    out HashSet<string> setArmorBlackMarketMaps))
                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                    out HashSet<string> setArmorModBlackMarketMaps))
                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                    out HashSet<string> setBiowareBlackMarketMaps))
                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                    out HashSet<string> setCyberwareBlackMarketMaps))
                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                    out HashSet<string> setGearBlackMarketMaps))
                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                    out HashSet<string> setVehicleBlackMarketMaps))
                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                    out HashSet<string> setVehicleModBlackMarketMaps))
                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                    out HashSet<string> setWeaponMountBlackMarketMaps))
                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                    out HashSet<string> setWeaponBlackMarketMaps))
                    {
                        setArmorBlackMarketMaps.AddRange(GenerateBlackMarketMappings(LoadDataXPath("armor.xml")
                                                             .SelectSingleNodeAndCacheExpression("/chummer")));
                        setArmorModBlackMarketMaps.AddRange(GenerateBlackMarketMappings(LoadDataXPath("armor.xml")
                                                                .SelectSingleNodeAndCacheExpression(
                                                                    "/chummer/modcategories")));
                        setBiowareBlackMarketMaps.AddRange(GenerateBlackMarketMappings(LoadDataXPath("bioware.xml")
                                                               .SelectSingleNodeAndCacheExpression("/chummer")));
                        setCyberwareBlackMarketMaps.AddRange(GenerateBlackMarketMappings(LoadDataXPath("cyberware.xml")
                                                                 .SelectSingleNodeAndCacheExpression("/chummer")));
                        setGearBlackMarketMaps.AddRange(GenerateBlackMarketMappings(LoadDataXPath("gear.xml")
                                                            .SelectSingleNodeAndCacheExpression("/chummer")));
                        setVehicleBlackMarketMaps.AddRange(GenerateBlackMarketMappings(LoadDataXPath("vehicles.xml")
                                                               .SelectSingleNodeAndCacheExpression("/chummer")));
                        setVehicleModBlackMarketMaps.AddRange(GenerateBlackMarketMappings(LoadDataXPath("vehicles.xml")
                                                                  .SelectSingleNodeAndCacheExpression(
                                                                      "/chummer/modcategories")));
                        setWeaponMountBlackMarketMaps.AddRange(GenerateBlackMarketMappings(LoadDataXPath("vehicles.xml")
                                                                   .SelectSingleNodeAndCacheExpression(
                                                                       "/chummer/weaponmountcategories")));
                        setWeaponBlackMarketMaps.AddRange(GenerateBlackMarketMappings(LoadDataXPath("weapons.xml")
                                                              .SelectSingleNodeAndCacheExpression("/chummer")));

                        using (LockObject.EnterWriteLock())
                        {
                            foreach (Armor objArmor in Armor)
                            {
                                objArmor.DiscountCost
                                    = objArmor.DiscountCost && setArmorBlackMarketMaps.Contains(objArmor.Category);
                                foreach (ArmorMod objMod in objArmor.ArmorMods)
                                {
                                    objMod.DiscountCost = objMod.DiscountCost
                                                          && setArmorModBlackMarketMaps.Contains(objMod.Category);
                                    foreach (Gear objGear in objMod.GearChildren.GetAllDescendants(x => x.Children))
                                        objGear.DiscountCost = objGear.DiscountCost
                                                               && setGearBlackMarketMaps.Contains(objGear.Category);
                                }

                                foreach (Gear objGear in objArmor.GearChildren.GetAllDescendants(x => x.Children))
                                    objGear.DiscountCost
                                        = objGear.DiscountCost && setGearBlackMarketMaps.Contains(objGear.Category);
                            }

                            foreach (Cyberware objCyberware in Cyberware.GetAllDescendants(x => x.Children))
                            {
                                if (objCyberware.DiscountCost)
                                {
                                    objCyberware.DiscountCost
                                        = (objCyberware.SourceType == Improvement.ImprovementSource.Bioware
                                            ? setBiowareBlackMarketMaps
                                            : setCyberwareBlackMarketMaps).Contains(objCyberware.Category);
                                }

                                foreach (Gear objGear in objCyberware.GearChildren.GetAllDescendants(x => x.Children))
                                    objGear.DiscountCost
                                        = objGear.DiscountCost && setGearBlackMarketMaps.Contains(objGear.Category);
                            }

                            foreach (Gear objGear in Gear.GetAllDescendants(x => x.Children))
                                objGear.DiscountCost
                                    = objGear.DiscountCost && setGearBlackMarketMaps.Contains(objGear.Category);

                            foreach (Vehicle objVehicle in Vehicles)
                            {
                                objVehicle.DiscountCost = objVehicle.DiscountCost
                                                          && setVehicleBlackMarketMaps.Contains(objVehicle.Category);
                                foreach (Gear objGear in objVehicle.GearChildren.GetAllDescendants(x => x.Children))
                                    objGear.DiscountCost
                                        = objGear.DiscountCost && setGearBlackMarketMaps.Contains(objGear.Category);
                                foreach (VehicleMod objMod in objVehicle.Mods)
                                {
                                    objMod.DiscountCost = objMod.DiscountCost
                                                          && setVehicleModBlackMarketMaps.Contains(objMod.Category);
                                    foreach (Cyberware objCyberware in objMod.Cyberware.GetAllDescendants(
                                                 x => x.Children))
                                    {
                                        if (objCyberware.DiscountCost)
                                        {
                                            objCyberware.DiscountCost
                                                = (objCyberware.SourceType == Improvement.ImprovementSource.Bioware
                                                    ? setBiowareBlackMarketMaps
                                                    : setCyberwareBlackMarketMaps).Contains(objCyberware.Category);
                                        }

                                        foreach (Gear objGear in objCyberware.GearChildren.GetAllDescendants(
                                                     x => x.Children))
                                            objGear.DiscountCost = objGear.DiscountCost
                                                                   && setGearBlackMarketMaps.Contains(objGear.Category);
                                    }
                                }

                                foreach (Weapon objWeapon in objVehicle.Weapons.GetAllDescendants(x => x.Children))
                                {
                                    objWeapon.DiscountCost = objWeapon.DiscountCost
                                                             && setWeaponBlackMarketMaps.Contains(objWeapon.Category);
                                    foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                                    {
                                        objAccessory.DiscountCost = objAccessory.DiscountCost
                                                                    && setWeaponBlackMarketMaps
                                                                        .Contains(objWeapon.Category);
                                        foreach (Gear objGear in objAccessory.GearChildren.GetAllDescendants(
                                                     x => x.Children))
                                            objGear.DiscountCost = objGear.DiscountCost
                                                                   && setGearBlackMarketMaps.Contains(objGear.Category);
                                    }
                                }

                                foreach (WeaponMount objMount in objVehicle.WeaponMounts)
                                {
                                    objMount.DiscountCost = objMount.DiscountCost
                                                            && setWeaponMountBlackMarketMaps
                                                                .Contains(objMount.Category);
                                    foreach (VehicleMod objMod in objMount.Mods)
                                    {
                                        objMod.DiscountCost = objMod.DiscountCost
                                                              && setVehicleModBlackMarketMaps.Contains(objMod.Category);
                                        foreach (Cyberware objCyberware in objMod.Cyberware.GetAllDescendants(
                                                     x => x.Children))
                                        {
                                            if (objCyberware.DiscountCost)
                                            {
                                                objCyberware.DiscountCost
                                                    = (objCyberware.SourceType == Improvement.ImprovementSource.Bioware
                                                        ? setBiowareBlackMarketMaps
                                                        : setCyberwareBlackMarketMaps).Contains(objCyberware.Category);
                                            }

                                            foreach (Gear objGear in objCyberware.GearChildren.GetAllDescendants(
                                                         x => x.Children))
                                                objGear.DiscountCost = objGear.DiscountCost
                                                                       && setGearBlackMarketMaps.Contains(
                                                                           objGear.Category);
                                        }
                                    }

                                    foreach (Weapon objWeapon in objMount.Weapons.GetAllDescendants(x => x.Children))
                                    {
                                        objWeapon.DiscountCost = objWeapon.DiscountCost
                                                                 && setWeaponBlackMarketMaps.Contains(
                                                                     objWeapon.Category);
                                        foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                                        {
                                            objAccessory.DiscountCost = objAccessory.DiscountCost
                                                                        && setWeaponBlackMarketMaps
                                                                            .Contains(objWeapon.Category);
                                            foreach (Gear objGear in objAccessory.GearChildren.GetAllDescendants(
                                                         x => x.Children))
                                                objGear.DiscountCost = objGear.DiscountCost
                                                                       && setGearBlackMarketMaps.Contains(
                                                                           objGear.Category);
                                        }
                                    }
                                }
                            }

                            foreach (Weapon objWeapon in Weapons.GetAllDescendants(x => x.Children))
                            {
                                objWeapon.DiscountCost = objWeapon.DiscountCost
                                                         && setWeaponBlackMarketMaps.Contains(objWeapon.Category);
                                foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                                {
                                    objAccessory.DiscountCost = objAccessory.DiscountCost
                                                                && setWeaponBlackMarketMaps
                                                                    .Contains(objWeapon.Category);
                                    foreach (Gear objGear in objAccessory.GearChildren.GetAllDescendants(
                                                 x => x.Children))
                                        objGear.DiscountCost = objGear.DiscountCost
                                                               && setGearBlackMarketMaps.Contains(objGear.Category);
                                }
                            }
                        }
                    }
                }
                else
                {
                    using (LockObject.EnterWriteLock())
                    {
                        // Forcefully disable all Black Market Discounts that don't apply.
                        foreach (Armor objArmor in Armor)
                        {
                            objArmor.DiscountCost = false;
                            foreach (ArmorMod objMod in objArmor.ArmorMods)
                            {
                                objMod.DiscountCost = false;
                                foreach (Gear objGear in objMod.GearChildren.GetAllDescendants(x => x.Children))
                                    objGear.DiscountCost = false;
                            }

                            foreach (Gear objGear in objArmor.GearChildren.GetAllDescendants(x => x.Children))
                                objGear.DiscountCost = false;
                        }

                        foreach (Cyberware objCyberware in Cyberware.GetAllDescendants(x => x.Children))
                        {
                            objCyberware.DiscountCost = false;
                            foreach (Gear objGear in objCyberware.GearChildren.GetAllDescendants(x => x.Children))
                                objGear.DiscountCost = false;
                        }

                        foreach (Gear objGear in Gear.GetAllDescendants(x => x.Children))
                            objGear.DiscountCost = false;

                        foreach (Vehicle objVehicle in Vehicles)
                        {
                            objVehicle.DiscountCost = false;
                            foreach (Gear objGear in objVehicle.GearChildren.GetAllDescendants(x => x.Children))
                                objGear.DiscountCost = false;
                            foreach (VehicleMod objMod in objVehicle.Mods)
                            {
                                objMod.DiscountCost = false;
                                foreach (Cyberware objCyberware in objMod.Cyberware.GetAllDescendants(x => x.Children))
                                {
                                    objCyberware.DiscountCost = false;
                                    foreach (Gear objGear in objCyberware.GearChildren.GetAllDescendants(
                                                 x => x.Children))
                                        objGear.DiscountCost = false;
                                }
                            }

                            foreach (Weapon objWeapon in objVehicle.Weapons.GetAllDescendants(x => x.Children))
                            {
                                objWeapon.DiscountCost = false;
                                foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                                {
                                    objAccessory.DiscountCost = false;
                                    foreach (Gear objGear in objAccessory.GearChildren.GetAllDescendants(
                                                 x => x.Children))
                                        objGear.DiscountCost = false;
                                }
                            }

                            foreach (WeaponMount objMount in objVehicle.WeaponMounts)
                            {
                                objMount.DiscountCost = false;
                                foreach (VehicleMod objMod in objMount.Mods)
                                {
                                    objMod.DiscountCost = false;
                                    foreach (Cyberware objCyberware in objMod.Cyberware.GetAllDescendants(
                                                 x => x.Children))
                                    {
                                        objCyberware.DiscountCost = false;
                                        foreach (Gear objGear in objCyberware.GearChildren.GetAllDescendants(
                                                     x => x.Children))
                                            objGear.DiscountCost = false;
                                    }
                                }

                                foreach (Weapon objWeapon in objMount.Weapons.GetAllDescendants(x => x.Children))
                                {
                                    objWeapon.DiscountCost = false;
                                    foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                                    {
                                        objAccessory.DiscountCost = false;
                                        foreach (Gear objGear in objAccessory.GearChildren.GetAllDescendants(
                                                     x => x.Children))
                                            objGear.DiscountCost = false;
                                    }
                                }
                            }
                        }

                        foreach (Weapon objWeapon in Weapons.GetAllDescendants(x => x.Children))
                        {
                            objWeapon.DiscountCost = false;
                            foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                            {
                                objAccessory.DiscountCost = false;
                                foreach (Gear objGear in objAccessory.GearChildren.GetAllDescendants(x => x.Children))
                                    objGear.DiscountCost = false;
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Whether or not this character can quicken spells.
        /// </summary>
        public bool QuickeningEnabled =>
            ImprovementManager
                .GetCachedImprovementListForValueOf(
                    this, Improvement.ImprovementType.QuickeningMetamagic).Count > 0;

        /// <summary>
        /// Whether or not user is getting free bioware from Prototype Transhuman.
        /// </summary>
        public decimal PrototypeTranshuman
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _decPrototypeTranshuman;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_decPrototypeTranshuman == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _decPrototypeTranshuman = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        public bool IsPrototypeTranshuman => PrototypeTranshuman > 0;

        /// <summary>
        /// Whether or not Friends in High Places is enabled.
        /// </summary>
        public bool FriendsInHighPlaces => ImprovementManager
                                           .GetCachedImprovementListForValueOf(
                                               this, Improvement.ImprovementType.FriendsInHighPlaces).Count > 0;

        public async ValueTask<bool> GetFriendsInHighPlacesAsync(CancellationToken token = default)
        {
            return (await ImprovementManager
                .GetCachedImprovementListForValueOfAsync(
                    this, Improvement.ImprovementType.FriendsInHighPlaces, token: token)).Count > 0;
        }

        /// <summary>
        /// Whether or not ExCon is enabled.
        /// </summary>
        public bool ExCon => ImprovementManager
                             .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.ExCon).Count > 0;

        private int _intCachedTrustFund = int.MinValue;

        /// <summary>
        /// Value of the Trust Fund quality.
        /// </summary>
        public int TrustFund
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedTrustFund != int.MinValue)
                        return _intCachedTrustFund;

                    List<Improvement> lstTrustFundImprovements = ImprovementManager
                        .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.TrustFund);
                    return _intCachedTrustFund = lstTrustFundImprovements.Count > 0
                        ? lstTrustFundImprovements.Max(x => x.Value).StandardRound()
                        : 0;
                }
            }
        }

        private int _intCachedRestrictedGear = int.MinValue;

        /// <summary>
        /// The maximum availability for Restricted Gear if this character has it. If they do not, this is 0.
        /// </summary>
        public int RestrictedGear
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedRestrictedGear < 0)
                    {
                        foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.RestrictedGear))
                        {
                            _intCachedRestrictedGear
                                = Math.Max(_intCachedRestrictedGear, objImprovement.Value.StandardRound());
                        }
                    }

                    return _intCachedRestrictedGear;
                }
            }
        }

        /// <summary>
        /// The maximum availability for Restricted Gear if this character has it. If they do not, this is 0.
        /// </summary>
        public async ValueTask<int> GetRestrictedGearAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                if (_intCachedRestrictedGear < 0)
                {
                    foreach (Improvement objImprovement in await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                 this, Improvement.ImprovementType.RestrictedGear, token: token))
                    {
                        _intCachedRestrictedGear
                            = Math.Max(_intCachedRestrictedGear, objImprovement.Value.StandardRound());
                    }
                }

                return _intCachedRestrictedGear;
            }
        }

        /// <summary>
        /// Whether or not Overclocker is enabled.
        /// </summary>
        public bool Overclocker => ImprovementManager
                                   .GetCachedImprovementListForValueOf(
                                       this, Improvement.ImprovementType.Overclocker).Count > 0;

        /// <summary>
        /// Whether or not MadeMan is enabled.
        /// </summary>
        public bool MadeMan => ImprovementManager
                               .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.MadeMan).Count > 0;

        /// <summary>
        /// Whether or not Fame is enabled.
        /// </summary>
        public bool Fame => ImprovementManager
                            .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Fame).Count
                            > 0;

        /// <summary>
        /// Whether or not Erased is enabled.
        /// </summary>
        public bool Erased => ImprovementManager
                              .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Erased).Count
                              > 0;

        /// <summary>
        /// Whether or not the character is allowed to Fetter sprites. See Kill Code 91 (Sprite Pet)
        /// </summary>
        public bool AllowSpriteFettering => ImprovementManager
                                            .GetCachedImprovementListForValueOf(
                                                this, Improvement.ImprovementType.AllowSpriteFettering).Count
                                            > 0;

        /// <summary>
        /// Extended Availability Test information for an item based on the character's Negotiate Skill.
        /// </summary>
        /// <param name="decCost">Item's cost.</param>
        /// <param name="strAvail">Item's Availability.</param>
        public string AvailTest(decimal decCost, string strAvail)
        {
            if (string.IsNullOrEmpty(strAvail))
                return LanguageManager.GetString("String_None");
            bool blnShowTest = false;
            string strTestSuffix = LanguageManager.GetString("String_AvailRestricted");
            if(strAvail.EndsWith(strTestSuffix, StringComparison.Ordinal))
            {
                blnShowTest = true;
                strAvail = strAvail.TrimEndOnce(strTestSuffix, true);
            }
            else
            {
                strTestSuffix = LanguageManager.GetString("String_AvailForbidden");
                if(strAvail.EndsWith(strTestSuffix, StringComparison.Ordinal))
                {
                    blnShowTest = true;
                    strAvail = strAvail.TrimEndOnce(strTestSuffix, true);
                }
            }

            if(int.TryParse(strAvail, out int intAvail) && (intAvail != 0 || blnShowTest))
            {
                return GetAvailTestString(decCost, intAvail);
            }

            return LanguageManager.GetString("String_None");
        }

        /// <summary>
        /// Extended Availability Test information for an item based on the character's Negotiate Skill.
        /// </summary>
        /// <param name="decCost">Item's cost.</param>
        /// <param name="objAvailability">Item's Availability.</param>
        public string AvailTest(decimal decCost, AvailabilityValue objAvailability)
        {
            if(objAvailability.Value != 0 || objAvailability.Suffix == 'R' || objAvailability.Suffix == 'F')
            {
                return GetAvailTestString(decCost, objAvailability.Value);
            }

            return LanguageManager.GetString("String_None");
        }

        /// <summary>
        /// Extended Availability Test information for an item based on the character's Negotiate Skill.
        /// </summary>
        /// <param name="decCost">Item's cost.</param>
        /// <param name="strAvail">Item's Availability.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public async Task<string> AvailTestAsync(decimal decCost, string strAvail, CancellationToken token = default)
        {
            if (string.IsNullOrEmpty(strAvail))
                return await LanguageManager.GetStringAsync("String_None", token: token);
            bool blnShowTest = false;
            string strTestSuffix = await LanguageManager.GetStringAsync("String_AvailRestricted", token: token);
            if (strAvail.EndsWith(strTestSuffix, StringComparison.Ordinal))
            {
                blnShowTest = true;
                strAvail = strAvail.TrimEndOnce(strTestSuffix, true);
            }
            else
            {
                strTestSuffix = await LanguageManager.GetStringAsync("String_AvailForbidden", token: token);
                if (strAvail.EndsWith(strTestSuffix, StringComparison.Ordinal))
                {
                    blnShowTest = true;
                    strAvail = strAvail.TrimEndOnce(strTestSuffix, true);
                }
            }

            if (int.TryParse(strAvail, out int intAvail) && (intAvail != 0 || blnShowTest))
            {
                return await GetAvailTestStringAsync(decCost, intAvail, token);
            }

            return await LanguageManager.GetStringAsync("String_None", token: token);
        }

        /// <summary>
        /// Extended Availability Test information for an item based on the character's Negotiate Skill.
        /// </summary>
        /// <param name="decCost">Item's cost.</param>
        /// <param name="objAvailability">Item's Availability.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        public Task<string> AvailTestAsync(decimal decCost, AvailabilityValue objAvailability, CancellationToken token = default)
        {
            if (objAvailability.Value != 0 || objAvailability.Suffix == 'R' || objAvailability.Suffix == 'F')
            {
                return GetAvailTestStringAsync(decCost, objAvailability.Value, token);
            }

            return LanguageManager.GetStringAsync("String_None", token: token);
        }

        private string GetAvailTestString(decimal decCost, int intAvailValue)
        {
            string strSpace = LanguageManager.GetString("String_Space");
            using (EnterReadLock.Enter(LockObject))
            {
                // Find the character's Negotiation total.
                int intPool = SkillsSection.GetActiveSkill("Negotiation")?.Pool ?? 0;
                if (_dicAvailabilityMap == null || GlobalSettings.LiveCustomData)
                {
                    using (LockObject.EnterWriteLock())
                    {
                        if (_dicAvailabilityMap == null || GlobalSettings.LiveCustomData)
                        {
                            SortedDictionary<decimal, Tuple<string, string>> dicAvailabilityMap
                                = Interlocked.Exchange(ref _dicAvailabilityMap, null)
                                  ?? new SortedDictionary<decimal, Tuple<string, string>>();
                            dicAvailabilityMap.Clear();
                            foreach (XPathNavigator objNode in LoadDataXPath("options.xml")
                                         .SelectAndCacheExpression("/chummer/availmap/avail"))
                            {
                                decimal decValue = 0;
                                if (objNode.TryGetDecFieldQuickly("value", ref decValue)
                                    && !dicAvailabilityMap.ContainsKey(decValue))
                                {
                                    dicAvailabilityMap.Add(
                                        decValue,
                                        new Tuple<string, string>(
                                            objNode.SelectSingleNodeAndCacheExpression("duration").Value,
                                            objNode.SelectSingleNodeAndCacheExpression("interval")
                                                   .Value));
                                }
                            }
                            Interlocked.CompareExchange(ref _dicAvailabilityMap, dicAvailabilityMap, null);
                        }
                    }
                }

                KeyValuePair<decimal, Tuple<string, string>>
                    item = _dicAvailabilityMap.FirstOrDefault(
                        x => decCost
                             < x.Key); //Assumes that the keys are sorted lowest to highest. Maybe not safe for custom content?
                // Determine the interval based on the item's price.
                string strInterval = item.Value.Item1 + strSpace + LanguageManager.GetString(item.Value.Item2);

                return intPool.ToString(GlobalSettings.CultureInfo) + strSpace + '('
                       + intAvailValue.ToString(GlobalSettings.CultureInfo) + ',' + strSpace + strInterval + ')';
            }
        }

        private async Task<string> GetAvailTestStringAsync(decimal decCost, int intAvailValue, CancellationToken token = default)
        {
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token);
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                // Find the character's Negotiation total.
                Skill objSkill = await (await GetSkillsSectionAsync(token)).GetActiveSkillAsync("Negotiation", token);
                int intPool = objSkill != null ? await objSkill.GetPoolAsync(token) : 0;
                if (_dicAvailabilityMap == null || GlobalSettings.LiveCustomData)
                {
                    IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token);
                    try
                    {
                        if (_dicAvailabilityMap == null || GlobalSettings.LiveCustomData)
                        {
                            SortedDictionary<decimal, Tuple<string, string>> dicAvailabilityMap
                                = Interlocked.Exchange(ref _dicAvailabilityMap, null)
                                  ?? new SortedDictionary<decimal, Tuple<string, string>>();
                            dicAvailabilityMap.Clear();
                            foreach (XPathNavigator objNode in await (await LoadDataXPathAsync(
                                             "options.xml", token: token))
                                         .SelectAndCacheExpressionAsync("/chummer/availmap/avail", token))
                            {
                                decimal decValue = 0;
                                if (objNode.TryGetDecFieldQuickly("value", ref decValue)
                                    && !dicAvailabilityMap.ContainsKey(decValue))
                                {
                                    dicAvailabilityMap.Add(
                                        decValue,
                                        new Tuple<string, string>(
                                            (await objNode.SelectSingleNodeAndCacheExpressionAsync("duration", token))
                                            .Value,
                                            (await objNode.SelectSingleNodeAndCacheExpressionAsync("interval", token))
                                            .Value));
                                }
                            }

                            Interlocked.CompareExchange(ref _dicAvailabilityMap, dicAvailabilityMap, null);
                        }
                    }
                    finally
                    {
                        await objLocker.DisposeAsync();
                    }
                }

                KeyValuePair<decimal, Tuple<string, string>>
                    item = _dicAvailabilityMap.FirstOrDefault(
                        x => decCost
                             < x.Key); //Assumes that the keys are sorted lowest to highest. Maybe not safe for custom content?
                // Determine the interval based on the item's price.
                string strInterval = item.Value.Item1 + strSpace + await LanguageManager.GetStringAsync(item.Value.Item2, token: token);

                return intPool.ToString(GlobalSettings.CultureInfo) + strSpace + '('
                       + intAvailValue.ToString(GlobalSettings.CultureInfo) + ',' + strSpace + strInterval + ')';
            }
        }

        /// <summary>
        /// Whether or not Adapsin is enabled.
        /// </summary>
        public bool AdapsinEnabled =>
            ImprovementManager.GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Adapsin)
                              .Count > 0;

        /// <summary>
        /// Whether or not Burnout's Way is enabled.
        /// </summary>
        public bool BurnoutEnabled =>
            ImprovementManager
                .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.BurnoutsWay)
                .Count > 0;

        #endregion

        #region Application Properties

        private readonly LockingHashSet<Character> _lstLinkedCharacters = new LockingHashSet<Character>();

        /// <summary>
        /// Characters referenced by some member of this character (usually a contact).
        /// </summary>
        public LockingHashSet<Character> LinkedCharacters
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _lstLinkedCharacters;
            }
        }

        #endregion

        #region Old Quality Conversion Code

        /// <summary>
        /// Convert Qualities that are still saved in the old format.
        /// </summary>
        private void ConvertOldQualities(XmlNodeList objXmlQualityList)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                XmlNode xmlRootQualitiesNode = LoadData("qualities.xml").SelectSingleNode("/chummer/qualities");

                if (xmlRootQualitiesNode != null)
                {
                    // Convert the old Qualities.
                    foreach (XmlNode objXmlQuality in objXmlQualityList)
                    {
                        if (objXmlQuality["name"] == null)
                        {
                            XmlNode objXmlQualityNode =
                                xmlRootQualitiesNode.SelectSingleNode(
                                    "quality[name = " + GetQualityName(objXmlQuality.InnerText).CleanXPath() + ']');

                            if (objXmlQualityNode != null)
                            {
                                string strForceValue = string.Empty;
                                // Re-create the bonuses for the Quality.
                                if (objXmlQualityNode.InnerXml.Contains("<bonus>"))
                                {
                                    // Look for the existing Improvement.
                                    foreach (Improvement objImprovement in Improvements)
                                    {
                                        if (objImprovement.ImproveSource == Improvement.ImprovementSource.Quality &&
                                            objImprovement.SourceName == objXmlQuality.InnerText
                                            && objImprovement.Enabled)
                                        {
                                            strForceValue = objImprovement.ImprovedName;
                                            using (LockObject.EnterWriteLock())
                                                Improvements.Remove(objImprovement);
                                            break;
                                        }
                                    }
                                }

                                using (LockObject.EnterWriteLock())
                                {
                                    // Convert the item to the new Quality class.
                                    Quality objQuality = new Quality(this);
                                    objQuality.Create(objXmlQualityNode, QualitySource.Selected, _lstWeapons,
                                                      strForceValue);
                                    Qualities.Add(objQuality);
                                }
                            }
                        }
                    }

                    // Take care of the Metatype information.
                    string strXPath = "/chummer/metatypes/metatype[name = " + Metatype.CleanXPath() + ']';
                    XmlNode objXmlMetatype = LoadData("metatypes.xml").SelectSingleNode(strXPath) ??
                                             LoadData("critters.xml").SelectSingleNode(strXPath);

                    if (objXmlMetatype != null)
                    {
                        // Positive Qualities.
                        using (XmlNodeList xmlMetatypeQualityList =
                               objXmlMetatype.SelectNodes("qualities/positive/quality"))
                        {
                            if (xmlMetatypeQualityList != null)
                            {
                                foreach (XmlNode objXmlMetatypeQuality in xmlMetatypeQualityList)
                                {
                                    bool blnFound = false;
                                    // See if the Quality already exists in the character.
                                    foreach (Quality objCharacterQuality in _lstQualities)
                                    {
                                        if (objCharacterQuality.Name == objXmlMetatypeQuality.InnerText)
                                        {
                                            blnFound = true;
                                            break;
                                        }
                                    }

                                    // If the Quality was not found, create it.
                                    if (!blnFound)
                                    {
                                        string strForceValue =
                                            objXmlMetatypeQuality.Attributes?["select"]?.InnerText ?? string.Empty;
                                        XmlNode objXmlQuality =
                                            xmlRootQualitiesNode.SelectSingleNode(
                                                "quality[name = " + objXmlMetatypeQuality.InnerText.CleanXPath() + ']');
                                        using (LockObject.EnterWriteLock())
                                        {
                                            Quality objQuality = new Quality(this);
                                            objQuality.Create(objXmlQuality, QualitySource.Metatype, _lstWeapons,
                                                              strForceValue);
                                            Qualities.Add(objQuality);
                                        }
                                    }
                                }
                            }
                        }

                        // Negative Qualities.
                        using (XmlNodeList xmlMetatypeQualityList =
                               objXmlMetatype.SelectNodes("qualities/negative/quality"))
                        {
                            if (xmlMetatypeQualityList != null)
                            {
                                foreach (XmlNode objXmlMetatypeQuality in xmlMetatypeQualityList)
                                {
                                    bool blnFound = false;
                                    // See if the Quality already exists in the character.
                                    foreach (Quality objCharacterQuality in _lstQualities)
                                    {
                                        if (objCharacterQuality.Name == objXmlMetatypeQuality.InnerText)
                                        {
                                            blnFound = true;
                                            break;
                                        }
                                    }

                                    // If the Quality was not found, create it.
                                    if (!blnFound)
                                    {
                                        string strForceValue =
                                            objXmlMetatypeQuality.Attributes?["select"]?.InnerText ?? string.Empty;
                                        XmlNode objXmlQuality =
                                            xmlRootQualitiesNode.SelectSingleNode(
                                                "quality[name = " + objXmlMetatypeQuality.InnerText.CleanXPath() + ']');
                                        using (LockObject.EnterWriteLock())
                                        {
                                            Quality objQuality = new Quality(this);
                                            objQuality.Create(objXmlQuality, QualitySource.Metatype, _lstWeapons,
                                                              strForceValue);
                                            Qualities.Add(objQuality);
                                        }
                                    }
                                }
                            }
                        }

                        // Do it all over again for Metavariants.
                        if (!string.IsNullOrEmpty(_strMetavariant))
                        {
                            objXmlMetatype =
                                objXmlMetatype.SelectSingleNode(
                                    "metavariants/metavariant[name = " + Metavariant.CleanXPath() + ']');

                            if (objXmlMetatype != null)
                            {
                                // Positive Qualities.
                                using (XmlNodeList xmlMetatypeQualityList =
                                       objXmlMetatype.SelectNodes("qualities/positive/quality"))
                                {
                                    if (xmlMetatypeQualityList != null)
                                    {
                                        foreach (XmlNode objXmlMetatypeQuality in xmlMetatypeQualityList)
                                        {
                                            bool blnFound = false;
                                            // See if the Quality already exists in the character.
                                            foreach (Quality objCharacterQuality in _lstQualities)
                                            {
                                                if (objCharacterQuality.Name == objXmlMetatypeQuality.InnerText)
                                                {
                                                    blnFound = true;
                                                    break;
                                                }
                                            }

                                            // If the Quality was not found, create it.
                                            if (!blnFound)
                                            {
                                                string strForceValue =
                                                    objXmlMetatypeQuality.Attributes?["select"]?.InnerText
                                                    ?? string.Empty;
                                                XmlNode objXmlQuality =
                                                    xmlRootQualitiesNode.SelectSingleNode(
                                                        "quality[name = " + objXmlMetatypeQuality.InnerText.CleanXPath()
                                                                          + ']');
                                                using (LockObject.EnterWriteLock())
                                                {
                                                    Quality objQuality = new Quality(this);
                                                    objQuality.Create(objXmlQuality, QualitySource.Metatype,
                                                                      _lstWeapons,
                                                                      strForceValue);
                                                    Qualities.Add(objQuality);
                                                }
                                            }
                                        }
                                    }
                                }

                                // Negative Qualities.
                                using (XmlNodeList xmlMetatypeQualityList =
                                       objXmlMetatype.SelectNodes("qualities/negative/quality"))
                                {
                                    if (xmlMetatypeQualityList != null)
                                    {
                                        foreach (XmlNode objXmlMetatypeQuality in xmlMetatypeQualityList)
                                        {
                                            bool blnFound = false;
                                            // See if the Quality already exists in the character.
                                            foreach (Quality objCharacterQuality in _lstQualities)
                                            {
                                                if (objCharacterQuality.Name == objXmlMetatypeQuality.InnerText)
                                                {
                                                    blnFound = true;
                                                    break;
                                                }
                                            }

                                            // If the Quality was not found, create it.
                                            if (!blnFound)
                                            {
                                                string strForceValue =
                                                    objXmlMetatypeQuality.Attributes?["select"]?.InnerText
                                                    ?? string.Empty;
                                                XmlNode objXmlQuality =
                                                    xmlRootQualitiesNode.SelectSingleNode(
                                                        "quality[name = " + objXmlMetatypeQuality.InnerText.CleanXPath()
                                                                          + ']');
                                                using (LockObject.EnterWriteLock())
                                                {
                                                    Quality objQuality = new Quality(this);
                                                    objQuality.Create(objXmlQuality, QualitySource.Metatype,
                                                                      _lstWeapons,
                                                                      strForceValue);
                                                    Qualities.Add(objQuality);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Get the name of a Quality by parsing out its BP cost.
        /// </summary>
        /// <param name="strQuality">String to parse.</param>
        private static string GetQualityName(string strQuality)
        {
            int intPos = strQuality.IndexOf('[');
            if(intPos != -1)
                strQuality = strQuality.Substring(0, intPos - 1);
            return strQuality;
        }

        /// <summary>
        /// Check for older instances of certain qualities that were manually numbered to be replaced with multiple instances of the first level quality (so that it works with the level system)
        /// Returns true if it's a corrected quality, false otherwise
        /// </summary>
        private bool CorrectedUnleveledQuality(XmlNode xmlOldQuality, XmlNode xmlRootQualitiesNode)
        {
            XmlNode xmlNewQuality = null;
            int intRanks = 0;
            switch(xmlOldQuality["name"]?.InnerText)
            {
                case "Focused Concentration (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Focused Concentration\"]");
                        intRanks = 1;
                        break;
                    }
                case "Focused Concentration (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Focused Concentration\"]");
                        intRanks = 2;
                        break;
                    }
                case "Focused Concentration (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Focused Concentration\"]");
                        intRanks = 3;
                        break;
                    }
                case "Focused Concentration (Rating 4)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Focused Concentration\"]");
                        intRanks = 4;
                        break;
                    }
                case "Focused Concentration (Rating 5)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Focused Concentration\"]");
                        intRanks = 5;
                        break;
                    }
                case "Focused Concentration (Rating 6)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Focused Concentration\"]");
                        intRanks = 6;
                        break;
                    }
                case "High Pain Tolerance (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"High Pain Tolerance\"]");
                        intRanks = 1;
                        break;
                    }
                case "High Pain Tolerance (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"High Pain Tolerance\"]");
                        intRanks = 2;
                        break;
                    }
                case "High Pain Tolerance (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"High Pain Tolerance\"]");
                        intRanks = 3;
                        break;
                    }
                case "Magic Resistance (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Magic Resistance\"]");
                        intRanks = 1;
                        break;
                    }
                case "Magic Resistance (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Magic Resistance\"]");
                        intRanks = 2;
                        break;
                    }
                case "Magic Resistance (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Magic Resistance\"]");
                        intRanks = 3;
                        break;
                    }
                case "Magic Resistance (Rating 4)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Magic Resistance\"]");
                        intRanks = 4;
                        break;
                    }
                case "Will to Live (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Will to Live\"]");
                        intRanks = 1;
                        break;
                    }
                case "Will to Live (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Will to Live\"]");
                        intRanks = 2;
                        break;
                    }
                case "Will to Live (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Will to Live\"]");
                        intRanks = 3;
                        break;
                    }
                case "Gremlins (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Gremlins\"]");
                        intRanks = 1;
                        break;
                    }
                case "Gremlins (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Gremlins\"]");
                        intRanks = 2;
                        break;
                    }
                case "Gremlins (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Gremlins\"]");
                        intRanks = 3;
                        break;
                    }
                case "Gremlins (Rating 4)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Gremlins\"]");
                        intRanks = 4;
                        break;
                    }
                case "Aged (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Aged\"]");
                        intRanks = 1;
                        break;
                    }
                case "Aged (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Aged\"]");
                        intRanks = 2;
                        break;
                    }
                case "Aged (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Aged\"]");
                        intRanks = 3;
                        break;
                    }
                case "Illness (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Illness\"]");
                        intRanks = 1;
                        break;
                    }
                case "Illness (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Illness\"]");
                        intRanks = 2;
                        break;
                    }
                case "Illness (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Illness\"]");
                        intRanks = 3;
                        break;
                    }
                case "Perceptive I":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Perceptive\"]");
                        intRanks = 1;
                        break;
                    }
                case "Perceptive II":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Perceptive\"]");
                        intRanks = 2;
                        break;
                    }
                case "Spike Resistance I":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Spike Resistance\"]");
                        intRanks = 1;
                        break;
                    }
                case "Spike Resistance II":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Spike Resistance\"]");
                        intRanks = 2;
                        break;
                    }
                case "Spike Resistance III":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Spike Resistance\"]");
                        intRanks = 3;
                        break;
                    }
                case "Tough as Nails Physical I":
                    {
                        xmlNewQuality =
                            xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Tough as Nails (Physical)\"]");
                        intRanks = 1;
                        break;
                    }
                case "Tough as Nails Physical II":
                    {
                        xmlNewQuality =
                            xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Tough as Nails (Physical)\"]");
                        intRanks = 2;
                        break;
                    }
                case "Tough as Nails Physical III":
                    {
                        xmlNewQuality =
                            xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Tough as Nails (Physical)\"]");
                        intRanks = 3;
                        break;
                    }
                case "Tough as Nails Stun I":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Tough as Nails (Stun)\"]");
                        intRanks = 1;
                        break;
                    }
                case "Tough as Nails Stun II":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Tough as Nails (Stun)\"]");
                        intRanks = 2;
                        break;
                    }
                case "Tough as Nails Stun III":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Tough as Nails (Stun)\"]");
                        intRanks = 3;
                        break;
                    }
                case "Dimmer Bulb I":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Dimmer Bulb\"]");
                        intRanks = 1;
                        break;
                    }
                case "Dimmer Bulb II":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Dimmer Bulb\"]");
                        intRanks = 2;
                        break;
                    }
                case "Dimmer Bulb III":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Dimmer Bulb\"]");
                        intRanks = 3;
                        break;
                    }
                case "In Debt I":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 1;
                        break;
                    }
                case "In Debt II":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 2;
                        break;
                    }
                case "In Debt III":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 3;
                        break;
                    }
                case "In Debt IV":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 4;
                        break;
                    }
                case "In Debt V":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 5;
                        break;
                    }
                case "In Debt VI":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 6;
                        break;
                    }
                case "In Debt VII":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 7;
                        break;
                    }
                case "In Debt VIII":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 8;
                        break;
                    }
                case "In Debt IX":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 9;
                        break;
                    }
                case "In Debt X":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 10;
                        break;
                    }
                case "In Debt XI":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 11;
                        break;
                    }
                case "In Debt XII":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 12;
                        break;
                    }
                case "In Debt XIII":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 13;
                        break;
                    }
                case "In Debt XIV":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 14;
                        break;
                    }
                case "In Debt XV":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"In Debt\"]");
                        intRanks = 15;
                        break;
                    }
                case "Infirm I":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Infirm\"]");
                        intRanks = 1;
                        break;
                    }
                case "Infirm II":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Infirm\"]");
                        intRanks = 2;
                        break;
                    }
                case "Infirm III":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Infirm\"]");
                        intRanks = 3;
                        break;
                    }
                case "Infirm IV":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Infirm\"]");
                        intRanks = 4;
                        break;
                    }
                case "Infirm V":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Infirm\"]");
                        intRanks = 5;
                        break;
                    }
                case "Shiva Arms (1 Pair)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Shiva Arms (Pair)\"]");
                        intRanks = 1;
                        break;
                    }
                case "Shiva Arms (2 Pair)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Shiva Arms (Pair)\"]");
                        intRanks = 2;
                        break;
                    }
                case "Arcane Arrester I":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Arcane Arrester\"]");
                        intRanks = 1;
                        break;
                    }
                case "Arcane Arrester II":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Arcane Arrester\"]");
                        intRanks = 2;
                        break;
                    }
                case "Pilot Origins (Rating 1)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Pilot Origins\"]");
                        intRanks = 1;
                        break;
                    }
                case "Pilot Origins (Rating 2)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Pilot Origins\"]");
                        intRanks = 2;
                        break;
                    }
                case "Pilot Origins (Rating 3)":
                    {
                        xmlNewQuality = xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Pilot Origins\"]");
                        intRanks = 3;
                        break;
                    }
                case "Social Appearance Anxiety (Rating 1)":
                    {
                        xmlNewQuality =
                            xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Social Appearance Anxiety\"]");
                        intRanks = 1;
                        break;
                    }
                case "Social Appearance Anxiety (Rating 2)":
                    {
                        xmlNewQuality =
                            xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Social Appearance Anxiety\"]");
                        intRanks = 2;
                        break;
                    }
                case "Social Appearance Anxiety (Rating 3)":
                    {
                        xmlNewQuality =
                            xmlRootQualitiesNode.SelectSingleNode("quality[name = \"Social Appearance Anxiety\"]");
                        intRanks = 3;
                        break;
                    }
            }

            if(intRanks > 0)
            {
                using (LockObject.EnterWriteLock())
                {
                    for (int i = 0; i < intRanks; ++i)
                    {
                        Quality objQuality = new Quality(this);
                        if (i == 0 && xmlOldQuality.TryGetField("guid", Guid.TryParse, out Guid guidOld))
                        {
                            ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Quality,
                                                                  guidOld.ToString());
                            objQuality.SetGUID(guidOld);
                        }

                        QualitySource objQualitySource =
                            Quality.ConvertToQualitySource(xmlOldQuality["qualitysource"]?.InnerText);
                        objQuality.Create(xmlNewQuality, objQualitySource, _lstWeapons,
                                          xmlOldQuality["extra"]?.InnerText);
                        if (xmlOldQuality["bp"] != null
                            && int.TryParse(xmlOldQuality["bp"].InnerText, out int intOldBP))
                            objQuality.BP = intOldBP / intRanks;

                        Qualities.Add(objQuality);
                    }
                }

                return true;
            }

            return false;
        }

        #endregion

        #region Temporary Properties : Dashboard

        // This region is for properties that are applicable to the Dashboard
        /// <summary>
        /// The Current Initiative roll result including base Initiative
        /// <note>Dashboard</note>
        /// </summary>
        public int InitRoll { get; set; }

        /// <summary>
        /// The Initiative Passes that the player has
        /// <note>Dashboard</note>
        /// </summary>
        public int InitPasses
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intInitPasses == int.MinValue)
                        _intInitPasses = InitiativeDice;
                    return _intInitPasses;
                }
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intInitPasses == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _intInitPasses = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        private int _intInitPasses = int.MinValue;

        /// <summary>
        /// True iff the character is currently delaying an action
        /// <note>Dashboard</note>
        /// </summary>
        public bool Delayed { get; set; }

        /// <summary>
        /// The current name and initiative of the character
        /// </summary>
        public string DisplayInit
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return Name + " : " + InitRoll.ToString(GlobalSettings.CultureInfo);
            }
        }

        /// <summary>
        /// The initial Initiative of the character
        /// <note>Dashboard</note>
        /// </summary>
        public int InitialInit { get; set; }

        #endregion

        #region Temporary Properties

        /// <summary>
        /// Takes a semicolon-separated list of book codes and returns a formatted string with displaynames.
        /// </summary>
        /// <param name="strInput"></param>
        /// <param name="strLanguage">Language to fetch</param>
        public string TranslatedBookList(string strInput, string strLanguage = "")
        {
            if (string.IsNullOrEmpty(strInput))
                return string.Empty;
            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdReturn))
            {
                // Load the Sourcebook information.
                XPathNavigator objXmlDocument = LoadDataXPath("books.xml", strLanguage);

                foreach (string strBook in strInput.TrimEndOnce(';')
                                                   .SplitNoAlloc(';', StringSplitOptions.RemoveEmptyEntries))
                {
                    XPathNavigator objXmlBook
                        = objXmlDocument.SelectSingleNode("/chummer/books/book[code = " + strBook.CleanXPath() + ']');
                    if (objXmlBook != null)
                    {
                        string strToAppend = objXmlBook.SelectSingleNodeAndCacheExpression("translate")?.Value;
                        if (!string.IsNullOrEmpty(strToAppend))
                            sbdReturn.AppendLine(strToAppend);
                        else
                        {
                            strToAppend = objXmlBook.SelectSingleNode("name")?.Value;
                            if (!string.IsNullOrEmpty(strToAppend))
                                sbdReturn.AppendLine(strToAppend);
                            else
                            {
                                strToAppend = objXmlBook.SelectSingleNode("altcode")?.Value ?? strBook;
                                sbdReturn.Append(LanguageManager.GetString("String_Unknown", strLanguage))
                                         .Append(LanguageManager.GetString("String_Space", strLanguage)).Append('(')
                                         .Append(strToAppend).AppendLine(')');
                            }
                        }
                    }
                    else
                    {
                        sbdReturn.Append(LanguageManager.GetString("String_Unknown", strLanguage))
                                 .Append(LanguageManager.GetString("String_Space", strLanguage)).AppendLine(strBook);
                    }
                }

                return sbdReturn.ToString();
            }
        }

        #endregion

        //Can't be at improvementmanager due reasons
        private readonly Lazy<ThreadSafeStack<string>> _stkPushText = new Lazy<ThreadSafeStack<string>>();

        /// <summary>
        /// Push a value that will be used instead of dialog instead in next <selecttext />
        /// </summary>
        public ThreadSafeStack<string> PushText
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _stkPushText.Value;
            }
        }

        private IHasMatrixAttributes _objActiveCommlink;

        /// <summary>
        /// The Active Commlink of the character. Returns null if character has no active commlink.
        /// </summary>
        public IHasMatrixAttributes ActiveCommlink
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _objActiveCommlink;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_objActiveCommlink == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _objActiveCommlink = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        private IHasMatrixAttributes _objHomeNode;

        /// <summary>
        /// Home Node. Returns null if home node is not set to any item.
        /// </summary>
        public IHasMatrixAttributes HomeNode
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _objHomeNode;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_objHomeNode == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _objHomeNode = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        [HubTag]
        public SkillsSection SkillsSection
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _objSkillsSection;
            }
        }

        public async ValueTask<SkillsSection> GetSkillsSectionAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return _objSkillsSection;
        }

        public int RedlinerBonus
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedRedlinerBonus == int.MinValue)
                        RefreshRedlinerImprovements();
                    return _intCachedRedlinerBonus;
                }
            }
        }

        private bool RefreshRedlinerImprovements()
        {
            using (LockObject.EnterWriteLock())
            {
                if (IsLoading) // If we are in the middle of loading, just queue a single refresh to happen at the end of the process
                {
                    if (!PostLoadMethods.Contains(RefreshRedlinerImprovements))
                        PostLoadMethods.Enqueue(RefreshRedlinerImprovements);
                    return true;
                }

                //Get attributes affected by redliner/cyber singularity seeker
                List<Improvement> lstSeekerImprovements = ImprovementManager
                    .GetCachedImprovementListForValueOf(this, Improvement.ImprovementType.Attribute)
                    .Where(objLoopImprovement => objLoopImprovement.SourceName.Contains("SEEKER")).ToList();
                lstSeekerImprovements.AddRange(ImprovementManager
                    .GetCachedImprovementListForValueOf(
                        this, Improvement.ImprovementType.PhysicalCM)
                    .Where(objLoopImprovement =>
                        objLoopImprovement.SourceName.Contains("SEEKER")));
                List<string> lstSeekerAttributes = ImprovementManager
                    .GetCachedImprovementListForValueOf(
                        this, Improvement.ImprovementType.Seeker)
                    .ConvertAll(objImprovement => objImprovement.ImprovedName);

                //if neither contains anything, it is safe to exit
                if (lstSeekerImprovements.Count == 0 && lstSeekerAttributes.Count == 0)
                {
                    _intCachedRedlinerBonus = 0;
                    return true;
                }

                //Calculate bonus from cyberlimbs
                int intCount = Cyberware.Sum(objCyberware => objCyberware.GetCyberlimbCount(Settings.RedlinerExcludes));

                intCount = Math.Min(intCount / 2, 2);
                _intCachedRedlinerBonus = lstSeekerAttributes.Any(x => x == "STR" || x == "AGI")
                    ? intCount
                    : 0;

                for (int i = lstSeekerAttributes.Count - 1; i >= 0; --i)
                {
                    string strSeekerAttribute = "SEEKER_" + lstSeekerAttributes[i];
                    int intCountToTarget = strSeekerAttribute == "SEEKER_BOX" ? intCount * -3 : intCount;
                    Improvement objImprovement
                        = lstSeekerImprovements.Find(x => x.SourceName == strSeekerAttribute
                                                          && x.Value == intCountToTarget);
                    if (objImprovement != null)
                    {
                        lstSeekerAttributes.RemoveAt(i);
                        lstSeekerImprovements.Remove(objImprovement);
                    }
                }

                //Improvement manager defines the functions needed to manipulate improvements
                //When the locals (someday) gets moved to this class, this can be removed and use
                //the local
                if (lstSeekerImprovements.Count != 0 || lstSeekerAttributes.Count != 0)
                {
                    // Remove which qualities have been removed or which values have changed
                    ImprovementManager.RemoveImprovements(this, lstSeekerImprovements);

                    // Add new improvements or old improvements with new values
                    foreach (string strAttribute in lstSeekerAttributes)
                    {
                        if (strAttribute == "BOX")
                        {
                            ImprovementManager.CreateImprovement(this, strAttribute,
                                Improvement.ImprovementSource.Quality,
                                "SEEKER_BOX", Improvement.ImprovementType.PhysicalCM,
                                Guid.NewGuid().ToString("D", GlobalSettings.InvariantCultureInfo),
                                intCount * -3);
                        }
                        else
                        {
                            ImprovementManager.CreateImprovement(this, strAttribute,
                                Improvement.ImprovementSource.Quality,
                                "SEEKER_" + strAttribute, Improvement.ImprovementType.Attribute,
                                Guid.NewGuid().ToString("D", GlobalSettings.InvariantCultureInfo), intCount, 1, 0, 0,
                                intCount);
                        }
                    }

                    ImprovementManager.Commit(this);
                }

                return true;
            }
        }

        public void RefreshEssenceLossImprovements()
        {
            using (LockObject.EnterWriteLock())
            {
                // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
                if (IsLoading)
                    return;

                // Only worry about essence loss attribute modifiers if this character actually has any attributes that would be affected by essence loss
                // (which means EssenceAtSpecialStart is not set to decimal.MinValue)
                if (EssenceAtSpecialStart != decimal.MinValue)
                {
                    decimal decESS = Essence();
                    decimal decESSMag = Essence(true);
                    if (!Settings.DontRoundEssenceInternally)
                    {
                        int intESSDecimals = Settings.EssenceDecimals;
                        decESS = decimal.Round(decESS, intESSDecimals, MidpointRounding.AwayFromZero);
                        decESSMag = decimal.Round(decESSMag, intESSDecimals, MidpointRounding.AwayFromZero);
                    }

                    // Reduce a character's MAG and RES from Essence Loss.
                    decimal decMetatypeMaximumESS = ESS.MetatypeMaximum;
                    int intMagMaxReduction = (decMetatypeMaximumESS - decESSMag).StandardRound();
                    int intMaxReduction = (decMetatypeMaximumESS - decESS).StandardRound();
                    // Character has the option set where essence loss just acts as an augmented malus, so just replace old essence loss improvements with new ones that apply an augmented malus
                    // equal to the amount by which the attribute's maximum would normally be reduced.
                    if (Settings.SpecialKarmaCostBasedOnShownValue)
                    {
                        Improvement.ImprovementSource eEssenceLossSource = Created
                            ? Improvement.ImprovementSource.EssenceLoss
                            : Improvement.ImprovementSource.EssenceLossChargen;
                        ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.EssenceLoss);
                        ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.EssenceLossChargen);
                        // With this house rule, Cyberadept Daemon just negates a penalty from Essence based on Grade instead of restoring Resonance, so delete all old improvements
                        ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.CyberadeptDaemon);
                        if (intMaxReduction != 0)
                        {
                            int intRESReduction = intMaxReduction;
                            if (TechnomancerEnabled && SubmersionGrade > 0 && ImprovementManager
                                    .GetCachedImprovementListForValueOf(this,
                                        Improvement.ImprovementType.CyberadeptDaemon)
                                    .Count > 0)
                            {
                                decimal decNonCyberwareEssence = BiowareEssence + EssenceHole;
                                int intMaxCyberadeptDaemonBonus = Math.Ceiling(decNonCyberwareEssence) ==
                                                                  Math.Floor(decNonCyberwareEssence)
                                    ? (int)Math.Ceiling(CyberwareEssence)
                                    : (int)Math.Floor(CyberwareEssence);
                                int intCyberadeptDaemonBonus = 0;
                                for (int i = 1; i <= SubmersionGrade; ++i)
                                {
                                    intCyberadeptDaemonBonus += i.DivAwayFromZero(2);
                                }

                                intRESReduction -= Math.Min(intCyberadeptDaemonBonus, intMaxCyberadeptDaemonBonus);
                                if (intRESReduction < 0)
                                    intRESReduction = 0;
                            }

                            if (intRESReduction != 0)
                                ImprovementManager.CreateImprovement(this, "RES", eEssenceLossSource, string.Empty,
                                    Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, 0, -intRESReduction);
                            ImprovementManager.CreateImprovement(this, "DEP", eEssenceLossSource, string.Empty,
                                Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, 0, -intMaxReduction);
                        }

                        if (intMagMaxReduction != 0)
                        {
                            ImprovementManager.CreateImprovement(this, "MAG", eEssenceLossSource, string.Empty,
                                Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, 0, -intMagMaxReduction);
                            ImprovementManager.CreateImprovement(this, "MAGAdept", eEssenceLossSource, string.Empty,
                                Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, 0, -intMagMaxReduction);
                            // If this is a Mystic Adept using special Mystic Adept PP rules (i.e. no second MAG attribute), Mystic Adepts lose PPs even if they have fewer PPs than their MAG
                            if (UseMysticAdeptPPs)
                                ImprovementManager.CreateImprovement(this, string.Empty, eEssenceLossSource,
                                    string.Empty,
                                    Improvement.ImprovementType.AdeptPowerPoints, string.Empty, -intMagMaxReduction);
                        }

                        if (intMaxReduction != 0 || intMagMaxReduction != 0)
                            ImprovementManager.Commit(this);
                    }
                    // RAW Career mode: complicated. Similar to RAW Create mode, but with the extra possibility of burning current karma levels and/or PPs instead of pure minima reduction,
                    // plus the need to account for cases where a character will burn "past" 0 (i.e. to a current value that should be negative), but then upgrade to 1 afterwards.
                    else if (Created)
                    {
                        // "Base" minimum reduction. This is the amount by which the character's special attribute minima would be reduced across career and create modes if there wasn't any funny business
                        int intMinReduction = (EssenceAtSpecialStart - decESS).StandardRound();
                        int intMagMinReduction = (EssenceAtSpecialStart - decESSMag).StandardRound();

                        // This extra code is needed for legacy shims, to convert proper attribute values for characters who would end up having a higher level than their total attribute maxima
                        // They are extra amounts by which the relevant attributes' karma levels should be burned
                        int intExtraRESBurn = Math.Max(0,
                            Math.Max(RES.Base + RES.FreeBase + RES.RawMinimum + RES.AttributeValueModifiers,
                                RES.TotalMinimum) + RES.Karma - RES.TotalMaximum);
                        int intExtraDEPBurn = Math.Max(0,
                            Math.Max(DEP.Base + DEP.FreeBase + DEP.RawMinimum + DEP.AttributeValueModifiers,
                                DEP.TotalMinimum) + DEP.Karma - DEP.TotalMaximum);
                        int intExtraMAGBurn = Math.Max(0,
                            Math.Max(MAG.Base + MAG.FreeBase + MAG.RawMinimum + MAG.AttributeValueModifiers,
                                MAG.TotalMinimum) + MAG.Karma - MAG.TotalMaximum);
                        int intExtraMAGAdeptBurn = Math.Max(0,
                            Math.Max(
                                MAGAdept.Base + MAGAdept.FreeBase + MAGAdept.RawMinimum +
                                MAGAdept.AttributeValueModifiers,
                                MAGAdept.TotalMinimum) + MAGAdept.Karma - MAGAdept.TotalMaximum);
                        // Old values for minimum reduction from essence loss in career mode. These are used to determine if any karma needs to get burned.
                        int intOldRESCareerMinimumReduction = 0;
                        int intOldDEPCareerMinimumReduction = 0;
                        int intOldMAGCareerMinimumReduction = 0;
                        int intOldMAGAdeptCareerMinimumReduction = 0;
                        foreach (Improvement objImprovement in ImprovementManager.GetCachedImprovementListForValueOf(
                                     this, Improvement.ImprovementType.Attribute))
                        {
                            if (objImprovement.ImproveSource == Improvement.ImprovementSource.EssenceLoss)
                            {
                                // Values get subtracted because negative modifier = positive reduction, positive modifier = negative reduction
                                // Augmented values also get factored in in case the character is switching off the option to treat essence loss as an augmented malus
                                switch (objImprovement.ImprovedName)
                                {
                                    case "RES":
                                        intOldRESCareerMinimumReduction -=
                                            objImprovement.Minimum + objImprovement.Augmented.StandardRound();
                                        break;
                                    case "DEP":
                                        intOldDEPCareerMinimumReduction -=
                                            objImprovement.Minimum + objImprovement.Augmented.StandardRound();
                                        break;
                                    case "MAG":
                                        intOldMAGCareerMinimumReduction -=
                                            objImprovement.Minimum + objImprovement.Augmented.StandardRound();
                                        break;
                                    case "MAGAdept":
                                        intOldMAGAdeptCareerMinimumReduction -=
                                            objImprovement.Minimum + objImprovement.Augmented.StandardRound();
                                        break;
                                }
                            }
                        }

                        // Remove any Improvements from MAG, RES, and DEP from Essence Loss that were added in career.
                        ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.EssenceLoss);

                        // Career Minimum and Maximum reduction relies on whether there's any extra reduction since chargen.
                        // This is the step where create mode attribute loss regarding attribute maximum loss gets factored out.
                        int intRESMaximumReduction = intMaxReduction + RES.TotalMaximum - RES.MaximumNoEssenceLoss();
                        int intDEPMaximumReduction = intMaxReduction + DEP.TotalMaximum - DEP.MaximumNoEssenceLoss();
                        int intMAGMaximumReduction = intMagMaxReduction + MAG.TotalMaximum - MAG.MaximumNoEssenceLoss();
                        int intMAGAdeptMaximumReduction =
                            intMagMaxReduction + MAGAdept.TotalMaximum - MAGAdept.MaximumNoEssenceLoss();

                        // Create the Essence Loss (or gain, in case of essence restoration and increasing maxima) Improvements.
                        if (intMaxReduction > 0
                            || intMinReduction > 0
                            || intRESMaximumReduction != 0
                            || intDEPMaximumReduction != 0)
                        {
                            // This is the step where create mode attribute loss regarding attribute minimum loss gets factored out.
                            int intRESMinimumReduction;
                            int intDEPMinimumReduction;
                            // If only maxima would be reduced, use the attribute's current total value instead of its current maximum, as this makes sure minima will only get reduced if the maximum reduction would eat into the current value
                            if (Settings.ESSLossReducesMaximumOnly)
                            {
                                intRESMinimumReduction = Math.Max(0,
                                    intMinReduction + RES.TotalValue - RES.MaximumNoEssenceLoss(true));
                                intDEPMinimumReduction = Math.Max(0,
                                    intMinReduction + DEP.TotalValue - DEP.MaximumNoEssenceLoss(true));
                            }
                            else
                            {
                                intRESMinimumReduction =
                                    intMinReduction + RES.TotalMaximum - RES.MaximumNoEssenceLoss(true);
                                intDEPMinimumReduction =
                                    intMinReduction + DEP.TotalMaximum - DEP.MaximumNoEssenceLoss(true);
                            }

                            // If the new RES reduction is greater than the old one...
                            int intRESMinimumReductionDelta = intRESMinimumReduction - intOldRESCareerMinimumReduction;
                            if (intRESMinimumReductionDelta > 0)
                            {
                                // ... and adding minimum reducing-improvements wouldn't do anything, start burning karma.
                                if (intRESMinimumReduction >
                                    RES.Base + RES.FreeBase + RES.RawMinimum + RES.AttributeValueModifiers)
                                {
                                    // intRESMinimumReduction is not actually reduced so that karma doesn't get burned away each time this function is called.
                                    // Besides, this only fires if intRESMinimumReduction is already at a level where increasing it any more wouldn't have any effect on the character.
                                    intExtraRESBurn += Math.Min(RES.Karma, intRESMinimumReductionDelta);
                                    RES.Karma -= intExtraRESBurn;
                                }
                            }
                            // If the new RES reduction is less than our old one, the character doesn't actually get any new values back
                            else
                            {
                                intRESMinimumReduction = intOldRESCareerMinimumReduction;
                            }

                            // If the new DEP reduction is greater than the old one...
                            int intDEPMinimumReductionDelta = intDEPMinimumReduction - intOldDEPCareerMinimumReduction;
                            if (intDEPMinimumReductionDelta > 0)
                            {
                                // ... and adding minimum reducing-improvements wouldn't do anything, start burning karma.
                                if (intDEPMinimumReduction >
                                    DEP.Base + DEP.FreeBase + DEP.RawMinimum + DEP.AttributeValueModifiers)
                                {
                                    // intDEPMinimumReduction is not actually reduced so that karma doesn't get burned away each time this function is called.
                                    // Besides, this only fires if intDEPMinimumReduction is already at a level where increasing it any more wouldn't have any effect on the character.
                                    intExtraDEPBurn += Math.Min(DEP.Karma, intDEPMinimumReductionDelta);
                                    DEP.Karma -= intExtraDEPBurn;
                                }
                            }
                            // If the new DEP reduction is less than our old one, the character doesn't actually get any new values back
                            else
                            {
                                intDEPMinimumReduction = intOldDEPCareerMinimumReduction;
                            }

                            // Create Improvements
                            if (intRESMinimumReduction != 0 || intRESMaximumReduction != 0)
                                ImprovementManager.CreateImprovement(this, "RES",
                                    Improvement.ImprovementSource.EssenceLoss,
                                    string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1,
                                    -intRESMinimumReduction, -intRESMaximumReduction);
                            if (intDEPMinimumReduction != 0 || intDEPMaximumReduction != 0)
                                ImprovementManager.CreateImprovement(this, "DEP",
                                    Improvement.ImprovementSource.EssenceLoss,
                                    string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1,
                                    -intDEPMinimumReduction, -intDEPMaximumReduction);
                            if (intRESMinimumReduction != 0 || intRESMaximumReduction != 0 ||
                                intDEPMinimumReduction != 0 || intDEPMaximumReduction != 0)
                                ImprovementManager.Commit(this);
                        }

                        if (intMagMaxReduction > 0
                            || intMagMinReduction > 0
                            || intMAGMaximumReduction != 0
                            || intMAGAdeptMaximumReduction != 0)
                        {
                            // This is the step where create mode attribute loss regarding attribute minimum loss gets factored out.
                            int intMAGMinimumReduction;
                            int intMAGAdeptMinimumReduction;
                            // If only maxima would be reduced, use the attribute's current total value instead of its current maximum, as this makes sure minima will only get reduced if the maximum reduction would eat into the current value
                            if (Settings.ESSLossReducesMaximumOnly)
                            {
                                intMAGMinimumReduction = Math.Max(0,
                                    intMagMinReduction + MAG.TotalValue - MAG.MaximumNoEssenceLoss(true));
                                intMAGAdeptMinimumReduction = Math.Max(0,
                                    intMagMinReduction + MAGAdept.TotalValue - MAGAdept.MaximumNoEssenceLoss(true));
                            }
                            else
                            {
                                intMAGMinimumReduction =
                                    intMagMinReduction + MAG.TotalMaximum - MAG.MaximumNoEssenceLoss(true);
                                intMAGAdeptMinimumReduction =
                                    intMagMinReduction + MAGAdept.TotalMaximum - MAGAdept.MaximumNoEssenceLoss(true);
                            }

                            // If the new MAG reduction is greater than the old one...
                            int intMAGMinimumReductionDelta = intMAGMinimumReduction - intOldMAGCareerMinimumReduction;
                            if (intMAGMinimumReductionDelta > 0)
                            {
                                // ... and adding minimum reducing-improvements wouldn't do anything, start burning karma.
                                if (intMAGMinimumReduction >
                                    MAG.Base + MAG.FreeBase + MAG.RawMinimum + MAG.AttributeValueModifiers)
                                {
                                    // intMAGMinimumReduction is not actually reduced so that karma doesn't get burned away each time this function is called.
                                    // Besides, this only fires if intMAGMinimumReduction is already at a level where increasing it any more wouldn't have any effect on the character.
                                    intExtraMAGBurn += Math.Min(MAG.Karma, intMAGMinimumReductionDelta);
                                    MAG.Karma -= intExtraMAGBurn;
                                }

                                // Mystic Adept PPs may need to be burned away based on the change of our MAG attribute
                                if (UseMysticAdeptPPs)
                                {
                                    // First burn away PPs gained during chargen...
                                    int intChargenPPBurn =
                                        Math.Min(MysticAdeptPowerPoints, intMAGMinimumReductionDelta);
                                    MysticAdeptPowerPoints -= intChargenPPBurn;
                                    // ... now burn away PPs gained from initiations.
                                    decimal decPPBurn = Math.Min(intMAGMinimumReductionDelta - intChargenPPBurn,
                                        ImprovementManager.ValueOf(this, Improvement.ImprovementType.AdeptPowerPoints));
                                    // Source needs to be EssenceLossChargen so that it doesn't get wiped in career mode.
                                    if (decPPBurn != 0)
                                    {
                                        ImprovementManager.CreateImprovement(this, string.Empty,
                                            Improvement.ImprovementSource.EssenceLossChargen, string.Empty,
                                            Improvement.ImprovementType.AdeptPowerPoints, string.Empty, -decPPBurn);
                                        ImprovementManager.Commit(this);
                                    }
                                }
                            }
                            // If the new MAG reduction is less than our old one, the character doesn't actually get any new values back
                            else
                            {
                                intMAGMinimumReduction = intOldMAGCareerMinimumReduction;
                            }

                            // Make sure we only attempt to burn MAGAdept karma levels if it's actually a separate attribute from MAG
                            if (MAGAdept != MAG)
                            {
                                // If the new MAGAdept reduction is greater than the old one...
                                int intMAGAdeptMinimumReductionDelta =
                                    intMAGAdeptMinimumReduction - intOldMAGAdeptCareerMinimumReduction;
                                if (intMAGAdeptMinimumReductionDelta > 0)
                                {
                                    // ... and adding minimum reducing-improvements wouldn't do anything, start burning karma.
                                    if (intMAGAdeptMinimumReduction > MAGAdept.Base + MAGAdept.FreeBase +
                                        MAGAdept.RawMinimum + MAGAdept.AttributeValueModifiers)
                                    {
                                        // intMAGAdeptMinimumReduction is not actually reduced so that karma doesn't get burned away each time this function is called.
                                        // Besides, this only fires if intMAGAdeptMinimumReduction is already at a level where increasing it any more wouldn't have any effect on the character.
                                        intExtraMAGAdeptBurn += Math.Min(MAGAdept.Karma,
                                            intMAGAdeptMinimumReductionDelta);
                                        MAGAdept.Karma -= intExtraMAGAdeptBurn;
                                    }
                                }
                                // If the new MAGAdept reduction is less than our old one, the character doesn't actually get any new values back
                                else
                                {
                                    intMAGAdeptMinimumReduction = intOldMAGAdeptCareerMinimumReduction;
                                }
                            }
                            // Otherwise make sure that if the new MAGAdept reduction is less than our old one, the character doesn't actually get any new values back
                            else if (intMAGAdeptMinimumReduction < intOldMAGAdeptCareerMinimumReduction)
                            {
                                intMAGAdeptMinimumReduction = intOldMAGAdeptCareerMinimumReduction;
                            }

                            // Create Improvements
                            if (intMAGMinimumReduction != 0 || intMAGMaximumReduction != 0)
                                ImprovementManager.CreateImprovement(this, "MAG",
                                    Improvement.ImprovementSource.EssenceLoss,
                                    string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1,
                                    -intMAGMinimumReduction, -intMAGMaximumReduction);
                            if (intMAGAdeptMinimumReduction != 0 || intMAGAdeptMaximumReduction != 0)
                                ImprovementManager.CreateImprovement(this, "MAGAdept",
                                    Improvement.ImprovementSource.EssenceLoss, string.Empty,
                                    Improvement.ImprovementType.Attribute, string.Empty, 0, 1,
                                    -intMAGAdeptMinimumReduction,
                                    -intMAGAdeptMaximumReduction);
                            if (intMAGMinimumReduction != 0 || intMAGMaximumReduction != 0 ||
                                intMAGAdeptMinimumReduction != 0 || intMAGAdeptMaximumReduction != 0)
                                ImprovementManager.Commit(this);
                        }
                    }
                    // RAW Create mode: Reduce maxima based on max ESS - current ESS, reduce minima based on their essence from the most optimal way in which they could have gotten access to special attributes
                    else
                    {
                        int intMinReduction = (EssenceAtSpecialStart - decESS).StandardRound();
                        int intMagMinReduction = (EssenceAtSpecialStart - decESSMag).StandardRound();
                        int intRESMinimumReduction = intMinReduction;
                        int intDEPMinimumReduction = intMinReduction;
                        int intMAGMinimumReduction = intMagMinReduction;
                        int intMAGAdeptMinimumReduction = intMagMinReduction;
                        if (Settings.ESSLossReducesMaximumOnly)
                        {
                            intRESMinimumReduction = Math.Max(0, intMinReduction + RES.TotalValue - RES.TotalMaximum);
                            intDEPMinimumReduction = Math.Max(0, intMinReduction + DEP.TotalValue - DEP.TotalMaximum);
                            intMAGMinimumReduction =
                                Math.Max(0, intMagMinReduction + MAG.TotalValue - MAG.TotalMaximum);
                            intMAGAdeptMinimumReduction = Math.Max(0,
                                intMagMinReduction + MAGAdept.TotalValue - MAGAdept.TotalMaximum);
                        }

                        ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.EssenceLoss);
                        ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.EssenceLossChargen);
                        if (intMaxReduction != 0 || intRESMinimumReduction != 0 || intDEPMinimumReduction != 0)
                        {
                            ImprovementManager.CreateImprovement(this, "RES",
                                Improvement.ImprovementSource.EssenceLossChargen, string.Empty,
                                Improvement.ImprovementType.Attribute, string.Empty, 0, 1, -intRESMinimumReduction,
                                -intMaxReduction);
                            ImprovementManager.CreateImprovement(this, "DEP",
                                Improvement.ImprovementSource.EssenceLossChargen, string.Empty,
                                Improvement.ImprovementType.Attribute, string.Empty, 0, 1, -intDEPMinimumReduction,
                                -intMaxReduction);
                        }

                        if (intMagMaxReduction != 0 || intMAGMinimumReduction != 0 || intMAGAdeptMinimumReduction != 0)
                        {
                            ImprovementManager.CreateImprovement(this, "MAG",
                                Improvement.ImprovementSource.EssenceLossChargen, string.Empty,
                                Improvement.ImprovementType.Attribute, string.Empty, 0, 1, -intMAGMinimumReduction,
                                -intMagMaxReduction);
                            ImprovementManager.CreateImprovement(this, "MAGAdept",
                                Improvement.ImprovementSource.EssenceLossChargen, string.Empty,
                                Improvement.ImprovementType.Attribute, string.Empty, 0, 1, -intMAGAdeptMinimumReduction,
                                -intMagMaxReduction);
                        }
                    }

                    ImprovementManager.Commit(this);

                    // If the character is in Career mode, it is possible for them to be forced to burn out.
                    if (Created)
                    {
                        // If the CharacterAttribute reaches 0, the character has burned out.
                        if (MAGEnabled)
                        {
                            if (Settings.SpecialKarmaCostBasedOnShownValue)
                            {
                                if (Settings.MysAdeptSecondMAGAttribute && IsMysticAdept)
                                {
                                    if (intMagMaxReduction >= MAG.TotalMaximum)
                                    {
                                        MAG.Base = MAGAdept.Base;
                                        MAG.Karma = MAGAdept.Karma;
                                        MAG.AssignLimits(MAGAdept.RawMetatypeMinimum, MAGAdept.RawMetatypeMaximum,
                                            MAGAdept.RawMetatypeAugmentedMaximum);
                                        MAGAdept.Base = 0;
                                        MAGAdept.Karma = 0;
                                        MAGAdept.AssignLimits(0, 0, 0);

                                        MagicianEnabled = false;
                                    }

                                    if (intMagMaxReduction >= MAGAdept.TotalMaximum)
                                    {
                                        MAGAdept.Base = 0;
                                        MAGAdept.Karma = 0;
                                        MAGAdept.AssignLimits(0, 0, 0);

                                        AdeptEnabled = false;
                                    }

                                    if (!MagicianEnabled && !AdeptEnabled)
                                        MAGEnabled = false;
                                }
                                else if (intMagMaxReduction >= MAG.TotalMaximum)
                                {
                                    MAG.Base = 0;
                                    MAG.Karma = 0;
                                    MAG.AssignLimits(0, 0, 0);

                                    MagicianEnabled = false;
                                    AdeptEnabled = false;
                                    MAGEnabled = false;
                                }
                            }
                            else if (Settings.MysAdeptSecondMAGAttribute && IsMysticAdept)
                            {
                                if (MAG.TotalMaximum < 1)
                                {
                                    MAG.Base = MAGAdept.Base;
                                    MAG.Karma = MAGAdept.Karma;
                                    MAG.AssignLimits(MAGAdept.RawMetatypeMinimum, MAGAdept.RawMetatypeMaximum,
                                        MAGAdept.RawMetatypeAugmentedMaximum);
                                    MAGAdept.Base = 0;
                                    MAGAdept.Karma = 0;
                                    MAGAdept.AssignLimits(0, 0, 0);

                                    MagicianEnabled = false;
                                }

                                if (MAGAdept.TotalMaximum < 1)
                                {
                                    MAGAdept.Base = 0;
                                    MAGAdept.Karma = 0;
                                    MAGAdept.AssignLimits(0, 0, 0);

                                    AdeptEnabled = false;
                                }

                                if (!MagicianEnabled && !AdeptEnabled)
                                    MAGEnabled = false;
                            }
                            else if (MAG.TotalMaximum < 1)
                            {
                                MAG.Base = 0;
                                MAG.Karma = 0;
                                MAG.AssignLimits(0, 0, 0);

                                MagicianEnabled = false;
                                AdeptEnabled = false;
                                MAGEnabled = false;
                            }
                        }

                        if (RESEnabled
                            && (Settings.SpecialKarmaCostBasedOnShownValue
                                && intMaxReduction >= RES.TotalMaximum
                                || !Settings.SpecialKarmaCostBasedOnShownValue
                                && RES.TotalMaximum < 1))
                        {
                            RES.Base = 0;
                            RES.Karma = 0;
                            RES.AssignLimits(0, 0, 0);

                            RESEnabled = false;
                            TechnomancerEnabled = false;
                        }
                    }
                }
                // Otherwise any essence loss improvements that might have been left need to be deleted (e.g. character is in create mode and had access to special attributes, but that access was removed)
                else
                {
                    ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.EssenceLossChargen);
                    ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.EssenceLoss);
                    ImprovementManager.Commit(this);
                }

                // If the character is Cyberzombie, adjust their Attributes based on their Essence.
                if (MetatypeCategory == "Cyberzombie")
                {
                    int intESSModifier = (-Essence()).StandardRound();
                    ImprovementManager.RemoveImprovements(this,
                        Improvements.Where(x =>
                            x.ImproveSource == Improvement.ImprovementSource.Cyberzombie &&
                            x.ImproveType == Improvement.ImprovementType.Attribute).ToList());
                    if (intESSModifier != 0)
                    {
                        ImprovementManager.CreateImprovement(this, "BOD", Improvement.ImprovementSource.Cyberzombie,
                            string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, intESSModifier);
                        ImprovementManager.CreateImprovement(this, "AGI", Improvement.ImprovementSource.Cyberzombie,
                            string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, intESSModifier);
                        ImprovementManager.CreateImprovement(this, "REA", Improvement.ImprovementSource.Cyberzombie,
                            string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, intESSModifier);
                        ImprovementManager.CreateImprovement(this, "STR", Improvement.ImprovementSource.Cyberzombie,
                            string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, intESSModifier);
                        ImprovementManager.CreateImprovement(this, "CHA", Improvement.ImprovementSource.Cyberzombie,
                            string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, intESSModifier);
                        ImprovementManager.CreateImprovement(this, "INT", Improvement.ImprovementSource.Cyberzombie,
                            string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, intESSModifier);
                        ImprovementManager.CreateImprovement(this, "LOG", Improvement.ImprovementSource.Cyberzombie,
                            string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, intESSModifier);
                        ImprovementManager.CreateImprovement(this, "WIL", Improvement.ImprovementSource.Cyberzombie,
                            string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, intESSModifier);
                        ImprovementManager.Commit(this);
                    }
                }
            }
        }

        public async ValueTask RefreshEssenceLossImprovementsAsync(CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await LockObject.EnterWriteLockAsync(token);
            try
            {
                // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
                if (IsLoading)
                    return;

                // Only worry about essence loss attribute modifiers if this character actually has any attributes that would be affected by essence loss
                // (which means EssenceAtSpecialStart is not set to decimal.MinValue)
                if (EssenceAtSpecialStart != decimal.MinValue)
                {
                    decimal decESS = await EssenceAsync(token: token);
                    decimal decESSMag = await EssenceAsync(true, token);
                    if (!Settings.DontRoundEssenceInternally)
                    {
                        int intESSDecimals = Settings.EssenceDecimals;
                        decESS = decimal.Round(decESS, intESSDecimals, MidpointRounding.AwayFromZero);
                        decESSMag = decimal.Round(decESSMag, intESSDecimals, MidpointRounding.AwayFromZero);
                    }

                    // Reduce a character's MAG and RES from Essence Loss.
                    decimal decMetatypeMaximumESS = await ESS.GetMetatypeMaximumAsync(token);
                    int intMagMaxReduction = (decMetatypeMaximumESS - decESSMag).StandardRound();
                    int intMaxReduction = (decMetatypeMaximumESS - decESS).StandardRound();
                    // Character has the option set where essence loss just acts as an augmented malus, so just replace old essence loss improvements with new ones that apply an augmented malus
                    // equal to the amount by which the attribute's maximum would normally be reduced.
                    if (Settings.SpecialKarmaCostBasedOnShownValue)
                    {
                        Improvement.ImprovementSource eEssenceLossSource = Created
                            ? Improvement.ImprovementSource.EssenceLoss
                            : Improvement.ImprovementSource.EssenceLossChargen;
                        await ImprovementManager.RemoveImprovementsAsync(
                            this, Improvement.ImprovementSource.EssenceLoss, token: token);
                        await ImprovementManager.RemoveImprovementsAsync(
                            this, Improvement.ImprovementSource.EssenceLossChargen, token: token);
                        // With this house rule, Cyberadept Daemon just negates a penalty from Essence based on Grade instead of restoring Resonance, so delete all old improvements
                        await ImprovementManager.RemoveImprovementsAsync(
                            this, Improvement.ImprovementSource.CyberadeptDaemon, token: token);
                        if (intMaxReduction != 0)
                        {
                            int intRESReduction = intMaxReduction;
                            if (TechnomancerEnabled && SubmersionGrade > 0 && (await ImprovementManager
                                    .GetCachedImprovementListForValueOfAsync(this,
                                                                             Improvement.ImprovementType
                                                                                 .CyberadeptDaemon, token: token))
                                .Count > 0)
                            {
                                decimal decNonCyberwareEssence = BiowareEssence + EssenceHole;
                                int intMaxCyberadeptDaemonBonus = Math.Ceiling(decNonCyberwareEssence) ==
                                                                  Math.Floor(decNonCyberwareEssence)
                                    ? (int) Math.Ceiling(CyberwareEssence)
                                    : (int) Math.Floor(CyberwareEssence);
                                int intCyberadeptDaemonBonus = 0;
                                for (int i = 1; i <= SubmersionGrade; ++i)
                                {
                                    intCyberadeptDaemonBonus += i.DivAwayFromZero(2);
                                }

                                intRESReduction -= Math.Min(intCyberadeptDaemonBonus, intMaxCyberadeptDaemonBonus);
                                if (intRESReduction < 0)
                                    intRESReduction = 0;
                            }

                            if (intRESReduction != 0)
                                await ImprovementManager.CreateImprovementAsync(
                                    this, "RES", eEssenceLossSource, string.Empty,
                                    Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, 0, -intRESReduction, token: token);
                            await ImprovementManager.CreateImprovementAsync(
                                this, "DEP", eEssenceLossSource, string.Empty,
                                Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, 0, -intMaxReduction, token: token);
                        }

                        if (intMagMaxReduction != 0)
                        {
                            await ImprovementManager.CreateImprovementAsync(
                                this, "MAG", eEssenceLossSource, string.Empty,
                                Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, 0, -intMagMaxReduction, token: token);
                            await ImprovementManager.CreateImprovementAsync(
                                this, "MAGAdept", eEssenceLossSource, string.Empty,
                                Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, 0, -intMagMaxReduction, token: token);
                            // If this is a Mystic Adept using special Mystic Adept PP rules (i.e. no second MAG attribute), Mystic Adepts lose PPs even if they have fewer PPs than their MAG
                            if (UseMysticAdeptPPs)
                                await ImprovementManager.CreateImprovementAsync(this, string.Empty, eEssenceLossSource,
                                    string.Empty,
                                    Improvement.ImprovementType.AdeptPowerPoints, string.Empty, -intMagMaxReduction, token: token);
                        }

                        if (intMaxReduction != 0 || intMagMaxReduction != 0)
                            await ImprovementManager.CommitAsync(this, token);
                    }
                    // RAW Career mode: complicated. Similar to RAW Create mode, but with the extra possibility of burning current karma levels and/or PPs instead of pure minima reduction,
                    // plus the need to account for cases where a character will burn "past" 0 (i.e. to a current value that should be negative), but then upgrade to 1 afterwards.
                    else if (Created)
                    {
                        // "Base" minimum reduction. This is the amount by which the character's special attribute minima would be reduced across career and create modes if there wasn't any funny business
                        int intMinReduction = (EssenceAtSpecialStart - decESS).StandardRound();
                        int intMagMinReduction = (EssenceAtSpecialStart - decESSMag).StandardRound();

                        // This extra code is needed for legacy shims, to convert proper attribute values for characters who would end up having a higher level than their total attribute maxima
                        // They are extra amounts by which the relevant attributes' karma levels should be burned
                        int intExtraRESBurn = Math.Max(0,
                                                       Math.Max(
                                                           RES.Base + await RES.GetFreeBaseAsync(token) + await RES.GetRawMinimumAsync(token)
                                                           + await RES.GetAttributeValueModifiersAsync(token),
                                                           await RES.GetTotalMinimumAsync(token)) + RES.Karma - await RES.GetTotalMaximumAsync(token));
                        int intExtraDEPBurn = Math.Max(0,
                                                       Math.Max(
                                                           DEP.Base + await DEP.GetFreeBaseAsync(token) + await DEP.GetRawMinimumAsync(token)
                                                           + await DEP.GetAttributeValueModifiersAsync(token),
                                                           await DEP.GetTotalMinimumAsync(token)) + DEP.Karma - await DEP.GetTotalMaximumAsync(token));
                        int intExtraMAGBurn = Math.Max(0,
                                                       Math.Max(
                                                           MAG.Base + await MAG.GetFreeBaseAsync(token) + await MAG.GetRawMinimumAsync(token)
                                                           + await MAG.GetAttributeValueModifiersAsync(token),
                                                           await MAG.GetTotalMinimumAsync(token)) + MAG.Karma - await MAG.GetTotalMaximumAsync(token));
                        int intExtraMAGAdeptBurn = MAG == MAGAdept
                            ? intExtraMAGBurn
                            : Math.Max(0,
                                       Math.Max(
                                           MAGAdept.Base + await MAGAdept.GetFreeBaseAsync(token)
                                                         + await MAGAdept.GetRawMinimumAsync(token)
                                                         +
                                                         await MAGAdept.GetAttributeValueModifiersAsync(token),
                                           await MAGAdept.GetTotalMinimumAsync(token)) + MAGAdept.Karma
                                       - await MAGAdept.GetTotalMaximumAsync(token));
                        // Old values for minimum reduction from essence loss in career mode. These are used to determine if any karma needs to get burned.
                        int intOldRESCareerMinimumReduction = 0;
                        int intOldDEPCareerMinimumReduction = 0;
                        int intOldMAGCareerMinimumReduction = 0;
                        int intOldMAGAdeptCareerMinimumReduction = 0;
                        foreach (Improvement objImprovement in await ImprovementManager
                                     .GetCachedImprovementListForValueOfAsync(
                                         this, Improvement.ImprovementType.Attribute, token: token))
                        {
                            if (objImprovement.ImproveSource == Improvement.ImprovementSource.EssenceLoss)
                            {
                                // Values get subtracted because negative modifier = positive reduction, positive modifier = negative reduction
                                // Augmented values also get factored in in case the character is switching off the option to treat essence loss as an augmented malus
                                switch (objImprovement.ImprovedName)
                                {
                                    case "RES":
                                        intOldRESCareerMinimumReduction -=
                                            objImprovement.Minimum + objImprovement.Augmented.StandardRound();
                                        break;
                                    case "DEP":
                                        intOldDEPCareerMinimumReduction -=
                                            objImprovement.Minimum + objImprovement.Augmented.StandardRound();
                                        break;
                                    case "MAG":
                                        intOldMAGCareerMinimumReduction -=
                                            objImprovement.Minimum + objImprovement.Augmented.StandardRound();
                                        break;
                                    case "MAGAdept":
                                        intOldMAGAdeptCareerMinimumReduction -=
                                            objImprovement.Minimum + objImprovement.Augmented.StandardRound();
                                        break;
                                }
                            }
                        }

                        // Remove any Improvements from MAG, RES, and DEP from Essence Loss that were added in career.
                        await ImprovementManager.RemoveImprovementsAsync(
                            this, Improvement.ImprovementSource.EssenceLoss, token: token);

                        // Career Minimum and Maximum reduction relies on whether there's any extra reduction since chargen.
                        // This is the step where create mode attribute loss regarding attribute maximum loss gets factored out.
                        int intRESMaximumReduction
                            = intMaxReduction + await RES.GetTotalMaximumAsync(token) - await RES.MaximumNoEssenceLossAsync(token: token);
                        int intDEPMaximumReduction
                            = intMaxReduction + await DEP.GetTotalMaximumAsync(token) - await DEP.MaximumNoEssenceLossAsync(token: token);
                        int intMAGMaximumReduction = intMagMaxReduction + await MAG.GetTotalMaximumAsync(token)
                                                     - await MAG.MaximumNoEssenceLossAsync(token: token);
                        int intMAGAdeptMaximumReduction =
                            intMagMaxReduction + await MAGAdept.GetTotalMaximumAsync(token: token) - await MAGAdept.MaximumNoEssenceLossAsync(token: token);

                        // Create the Essence Loss (or gain, in case of essence restoration and increasing maxima) Improvements.
                        if (intMaxReduction > 0
                            || intMinReduction > 0
                            || intRESMaximumReduction != 0
                            || intDEPMaximumReduction != 0)
                        {
                            // This is the step where create mode attribute loss regarding attribute minimum loss gets factored out.
                            int intRESMinimumReduction;
                            int intDEPMinimumReduction;
                            // If only maxima would be reduced, use the attribute's current total value instead of its current maximum, as this makes sure minima will only get reduced if the maximum reduction would eat into the current value
                            if (Settings.ESSLossReducesMaximumOnly)
                            {
                                intRESMinimumReduction = Math.Max(0,
                                                                  intMinReduction + await RES.GetTotalValueAsync(token)
                                                                  - await RES.MaximumNoEssenceLossAsync(true, token));
                                intDEPMinimumReduction = Math.Max(0,
                                                                  intMinReduction + await DEP.GetTotalValueAsync(token)
                                                                  - await DEP.MaximumNoEssenceLossAsync(true, token));
                            }
                            else
                            {
                                intRESMinimumReduction =
                                    intMinReduction + await RES.GetTotalMaximumAsync(token) - await RES.MaximumNoEssenceLossAsync(true, token);
                                intDEPMinimumReduction =
                                    intMinReduction + await DEP.GetTotalMaximumAsync(token) - await DEP.MaximumNoEssenceLossAsync(true, token);
                            }

                            // If the new RES reduction is greater than the old one...
                            int intRESMinimumReductionDelta = intRESMinimumReduction - intOldRESCareerMinimumReduction;
                            if (intRESMinimumReductionDelta > 0)
                            {
                                // ... and adding minimum reducing-improvements wouldn't do anything, start burning karma.
                                if (intRESMinimumReduction >
                                    RES.Base + await RES.GetFreeBaseAsync(token) + await RES.GetRawMinimumAsync(token) + await RES.GetAttributeValueModifiersAsync(token))
                                {
                                    // intRESMinimumReduction is not actually reduced so that karma doesn't get burned away each time this function is called.
                                    // Besides, this only fires if intRESMinimumReduction is already at a level where increasing it any more wouldn't have any effect on the character.
                                    intExtraRESBurn += Math.Min(RES.Karma, intRESMinimumReductionDelta);
                                    RES.Karma -= intExtraRESBurn;
                                }
                            }
                            // If the new RES reduction is less than our old one, the character doesn't actually get any new values back
                            else
                            {
                                intRESMinimumReduction = intOldRESCareerMinimumReduction;
                            }

                            // If the new DEP reduction is greater than the old one...
                            int intDEPMinimumReductionDelta = intDEPMinimumReduction - intOldDEPCareerMinimumReduction;
                            if (intDEPMinimumReductionDelta > 0)
                            {
                                // ... and adding minimum reducing-improvements wouldn't do anything, start burning karma.
                                if (intDEPMinimumReduction >
                                    DEP.Base + await DEP.GetFreeBaseAsync(token) + await DEP.GetRawMinimumAsync(token) + await DEP.GetAttributeValueModifiersAsync(token))
                                {
                                    // intDEPMinimumReduction is not actually reduced so that karma doesn't get burned away each time this function is called.
                                    // Besides, this only fires if intDEPMinimumReduction is already at a level where increasing it any more wouldn't have any effect on the character.
                                    intExtraDEPBurn += Math.Min(DEP.Karma, intDEPMinimumReductionDelta);
                                    DEP.Karma -= intExtraDEPBurn;
                                }
                            }
                            // If the new DEP reduction is less than our old one, the character doesn't actually get any new values back
                            else
                            {
                                intDEPMinimumReduction = intOldDEPCareerMinimumReduction;
                            }

                            // Create Improvements
                            if (intRESMinimumReduction != 0 || intRESMaximumReduction != 0)
                                await ImprovementManager.CreateImprovementAsync(this, "RES",
                                    Improvement.ImprovementSource.EssenceLoss,
                                    string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1,
                                    -intRESMinimumReduction, -intRESMaximumReduction, token: token);
                            if (intDEPMinimumReduction != 0 || intDEPMaximumReduction != 0)
                                await ImprovementManager.CreateImprovementAsync(this, "DEP",
                                    Improvement.ImprovementSource.EssenceLoss,
                                    string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1,
                                    -intDEPMinimumReduction, -intDEPMaximumReduction, token: token);
                            if (intRESMinimumReduction != 0 || intRESMaximumReduction != 0 ||
                                intDEPMinimumReduction != 0 || intDEPMaximumReduction != 0)
                                await ImprovementManager.CommitAsync(this, token);
                        }

                        if (intMagMaxReduction > 0
                            || intMagMinReduction > 0
                            || intMAGMaximumReduction != 0
                            || intMAGAdeptMaximumReduction != 0)
                        {
                            // This is the step where create mode attribute loss regarding attribute minimum loss gets factored out.
                            int intMAGMinimumReduction;
                            int intMAGAdeptMinimumReduction;
                            // If only maxima would be reduced, use the attribute's current total value instead of its current maximum, as this makes sure minima will only get reduced if the maximum reduction would eat into the current value
                            if (Settings.ESSLossReducesMaximumOnly)
                            {
                                intMAGMinimumReduction = Math.Max(0,
                                                                  intMagMinReduction + await MAG.GetTotalValueAsync(token)
                                                                  - await MAG.MaximumNoEssenceLossAsync(true, token));
                                intMAGAdeptMinimumReduction = Math.Max(0,
                                                                       intMagMinReduction + await MAGAdept.GetTotalValueAsync(token)
                                                                       - await MAGAdept
                                                                           .MaximumNoEssenceLossAsync(true, token));
                            }
                            else
                            {
                                intMAGMinimumReduction =
                                    intMagMinReduction + await MAG.GetTotalMaximumAsync(token) - await MAG.MaximumNoEssenceLossAsync(true, token);
                                intMAGAdeptMinimumReduction =
                                    intMagMinReduction + await MAGAdept.GetTotalMaximumAsync(token)
                                    - await MAGAdept.MaximumNoEssenceLossAsync(true, token);
                            }

                            // If the new MAG reduction is greater than the old one...
                            int intMAGMinimumReductionDelta = intMAGMinimumReduction - intOldMAGCareerMinimumReduction;
                            if (intMAGMinimumReductionDelta > 0)
                            {
                                // ... and adding minimum reducing-improvements wouldn't do anything, start burning karma.
                                if (intMAGMinimumReduction >
                                    MAG.Base + await MAG.GetFreeBaseAsync(token) + await MAG.GetRawMinimumAsync(token) + await MAG.GetAttributeValueModifiersAsync(token))
                                {
                                    // intMAGMinimumReduction is not actually reduced so that karma doesn't get burned away each time this function is called.
                                    // Besides, this only fires if intMAGMinimumReduction is already at a level where increasing it any more wouldn't have any effect on the character.
                                    intExtraMAGBurn += Math.Min(MAG.Karma, intMAGMinimumReductionDelta);
                                    MAG.Karma -= intExtraMAGBurn;
                                }

                                // Mystic Adept PPs may need to be burned away based on the change of our MAG attribute
                                if (UseMysticAdeptPPs)
                                {
                                    // First burn away PPs gained during chargen...
                                    int intChargenPPBurn =
                                        Math.Min(MysticAdeptPowerPoints, intMAGMinimumReductionDelta);
                                    MysticAdeptPowerPoints -= intChargenPPBurn;
                                    // ... now burn away PPs gained from initiations.
                                    decimal decPPBurn = Math.Min(intMAGMinimumReductionDelta - intChargenPPBurn,
                                                                 await ImprovementManager.ValueOfAsync(
                                                                     this,
                                                                     Improvement.ImprovementType.AdeptPowerPoints, token: token));
                                    // Source needs to be EssenceLossChargen so that it doesn't get wiped in career mode.
                                    if (decPPBurn != 0)
                                    {
                                        await ImprovementManager.CreateImprovementAsync(this, string.Empty,
                                            Improvement.ImprovementSource.EssenceLossChargen, string.Empty,
                                            Improvement.ImprovementType.AdeptPowerPoints, string.Empty, -decPPBurn, token: token);
                                        await ImprovementManager.CommitAsync(this, token);
                                    }
                                }
                            }
                            // If the new MAG reduction is less than our old one, the character doesn't actually get any new values back
                            else
                            {
                                intMAGMinimumReduction = intOldMAGCareerMinimumReduction;
                            }

                            // Make sure we only attempt to burn MAGAdept karma levels if it's actually a separate attribute from MAG
                            if (MAGAdept != MAG)
                            {
                                // If the new MAGAdept reduction is greater than the old one...
                                int intMAGAdeptMinimumReductionDelta =
                                    intMAGAdeptMinimumReduction - intOldMAGAdeptCareerMinimumReduction;
                                if (intMAGAdeptMinimumReductionDelta > 0)
                                {
                                    // ... and adding minimum reducing-improvements wouldn't do anything, start burning karma.
                                    if (intMAGAdeptMinimumReduction > MAGAdept.Base + await MAGAdept.GetFreeBaseAsync(token) +
                                        await MAGAdept.GetRawMinimumAsync(token) + await MAGAdept.GetAttributeValueModifiersAsync(token))
                                    {
                                        // intMAGAdeptMinimumReduction is not actually reduced so that karma doesn't get burned away each time this function is called.
                                        // Besides, this only fires if intMAGAdeptMinimumReduction is already at a level where increasing it any more wouldn't have any effect on the character.
                                        intExtraMAGAdeptBurn += Math.Min(MAGAdept.Karma,
                                                                         intMAGAdeptMinimumReductionDelta);
                                        MAGAdept.Karma -= intExtraMAGAdeptBurn;
                                    }
                                }
                                // If the new MAGAdept reduction is less than our old one, the character doesn't actually get any new values back
                                else
                                {
                                    intMAGAdeptMinimumReduction = intOldMAGAdeptCareerMinimumReduction;
                                }
                            }
                            // Otherwise make sure that if the new MAGAdept reduction is less than our old one, the character doesn't actually get any new values back
                            else if (intMAGAdeptMinimumReduction < intOldMAGAdeptCareerMinimumReduction)
                            {
                                intMAGAdeptMinimumReduction = intOldMAGAdeptCareerMinimumReduction;
                            }

                            // Create Improvements
                            if (intMAGMinimumReduction != 0 || intMAGMaximumReduction != 0)
                                await ImprovementManager.CreateImprovementAsync(this, "MAG",
                                    Improvement.ImprovementSource.EssenceLoss,
                                    string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1,
                                    -intMAGMinimumReduction, -intMAGMaximumReduction, token: token);
                            if (intMAGAdeptMinimumReduction != 0 || intMAGAdeptMaximumReduction != 0)
                                await ImprovementManager.CreateImprovementAsync(this, "MAGAdept",
                                    Improvement.ImprovementSource.EssenceLoss, string.Empty,
                                    Improvement.ImprovementType.Attribute, string.Empty, 0, 1,
                                    -intMAGAdeptMinimumReduction,
                                    -intMAGAdeptMaximumReduction, token: token);
                            if (intMAGMinimumReduction != 0 || intMAGMaximumReduction != 0 ||
                                intMAGAdeptMinimumReduction != 0 || intMAGAdeptMaximumReduction != 0)
                                await ImprovementManager.CommitAsync(this, token);
                        }
                    }
                    // RAW Create mode: Reduce maxima based on max ESS - current ESS, reduce minima based on their essence from the most optimal way in which they could have gotten access to special attributes
                    else
                    {
                        int intMinReduction = (EssenceAtSpecialStart - decESS).StandardRound();
                        int intMagMinReduction = (EssenceAtSpecialStart - decESSMag).StandardRound();
                        int intRESMinimumReduction = intMinReduction;
                        int intDEPMinimumReduction = intMinReduction;
                        int intMAGMinimumReduction = intMagMinReduction;
                        int intMAGAdeptMinimumReduction = intMagMinReduction;
                        if (Settings.ESSLossReducesMaximumOnly)
                        {
                            intRESMinimumReduction = Math.Max(0, intMinReduction + await RES.GetTotalValueAsync(token) - await RES.GetTotalMaximumAsync(token));
                            intDEPMinimumReduction = Math.Max(0, intMinReduction + await DEP.GetTotalValueAsync(token) - await DEP.GetTotalMaximumAsync(token));
                            intMAGMinimumReduction =
                                Math.Max(0, intMagMinReduction + await MAG.GetTotalValueAsync(token) - await MAG.GetTotalMaximumAsync(token));
                            intMAGAdeptMinimumReduction = Math.Max(0,
                                                                   intMagMinReduction + await MAGAdept.GetTotalValueAsync(token)
                                                                   - await MAGAdept.GetTotalMaximumAsync(token));
                        }

                        await ImprovementManager.RemoveImprovementsAsync(
                            this, Improvement.ImprovementSource.EssenceLoss, token: token);
                        await ImprovementManager.RemoveImprovementsAsync(
                            this, Improvement.ImprovementSource.EssenceLossChargen, token: token);
                        if (intMaxReduction != 0 || intRESMinimumReduction != 0 || intDEPMinimumReduction != 0)
                        {
                            await ImprovementManager.CreateImprovementAsync(this, "RES",
                                                                            Improvement.ImprovementSource
                                                                                .EssenceLossChargen, string.Empty,
                                                                            Improvement.ImprovementType.Attribute,
                                                                            string.Empty, 0, 1, -intRESMinimumReduction,
                                                                            -intMaxReduction, token: token);
                            await ImprovementManager.CreateImprovementAsync(this, "DEP",
                                                                            Improvement.ImprovementSource
                                                                                .EssenceLossChargen, string.Empty,
                                                                            Improvement.ImprovementType.Attribute,
                                                                            string.Empty, 0, 1, -intDEPMinimumReduction,
                                                                            -intMaxReduction, token: token);
                        }

                        if (intMagMaxReduction != 0 || intMAGMinimumReduction != 0 || intMAGAdeptMinimumReduction != 0)
                        {
                            await ImprovementManager.CreateImprovementAsync(this, "MAG",
                                                                            Improvement.ImprovementSource
                                                                                .EssenceLossChargen, string.Empty,
                                                                            Improvement.ImprovementType.Attribute,
                                                                            string.Empty, 0, 1, -intMAGMinimumReduction,
                                                                            -intMagMaxReduction, token: token);
                            await ImprovementManager.CreateImprovementAsync(this, "MAGAdept",
                                                                            Improvement.ImprovementSource
                                                                                .EssenceLossChargen, string.Empty,
                                                                            Improvement.ImprovementType.Attribute,
                                                                            string.Empty, 0, 1,
                                                                            -intMAGAdeptMinimumReduction,
                                                                            -intMagMaxReduction, token: token);
                        }
                    }

                    await ImprovementManager.CommitAsync(this, token);

                    // If the character is in Career mode, it is possible for them to be forced to burn out.
                    if (await GetCreatedAsync(token))
                    {
                        // If the CharacterAttribute reaches 0, the character has burned out.
                        if (await GetMAGEnabledAsync(token))
                        {
                            if (Settings.SpecialKarmaCostBasedOnShownValue)
                            {
                                if (Settings.MysAdeptSecondMAGAttribute && IsMysticAdept)
                                {
                                    if (intMagMaxReduction >= await MAG.GetTotalMaximumAsync(token))
                                    {
                                        MAG.Base = MAGAdept.Base;
                                        MAG.Karma = MAGAdept.Karma;
                                        MAG.AssignLimits(MAGAdept.RawMetatypeMinimum, MAGAdept.RawMetatypeMaximum,
                                                         MAGAdept.RawMetatypeAugmentedMaximum);
                                        MAGAdept.Base = 0;
                                        MAGAdept.Karma = 0;
                                        MAGAdept.AssignLimits(0, 0, 0);

                                        MagicianEnabled = false;
                                    }

                                    if (intMagMaxReduction >= await MAGAdept.GetTotalMaximumAsync(token))
                                    {
                                        MAGAdept.Base = 0;
                                        MAGAdept.Karma = 0;
                                        MAGAdept.AssignLimits(0, 0, 0);

                                        AdeptEnabled = false;
                                    }

                                    if (!MagicianEnabled && !AdeptEnabled)
                                        MAGEnabled = false;
                                }
                                else if (intMagMaxReduction >= await MAG.GetTotalMaximumAsync(token))
                                {
                                    MAG.Base = 0;
                                    MAG.Karma = 0;
                                    MAG.AssignLimits(0, 0, 0);

                                    MagicianEnabled = false;
                                    AdeptEnabled = false;
                                    MAGEnabled = false;
                                }
                            }
                            else if (Settings.MysAdeptSecondMAGAttribute && IsMysticAdept)
                            {
                                if (await MAG.GetTotalMaximumAsync(token) < 1)
                                {
                                    MAG.Base = MAGAdept.Base;
                                    MAG.Karma = MAGAdept.Karma;
                                    MAG.AssignLimits(MAGAdept.RawMetatypeMinimum, MAGAdept.RawMetatypeMaximum,
                                                     MAGAdept.RawMetatypeAugmentedMaximum);
                                    MAGAdept.Base = 0;
                                    MAGAdept.Karma = 0;
                                    MAGAdept.AssignLimits(0, 0, 0);

                                    MagicianEnabled = false;
                                }

                                if (await MAGAdept.GetTotalMaximumAsync(token) < 1)
                                {
                                    MAGAdept.Base = 0;
                                    MAGAdept.Karma = 0;
                                    MAGAdept.AssignLimits(0, 0, 0);

                                    AdeptEnabled = false;
                                }

                                if (!MagicianEnabled && !AdeptEnabled)
                                    MAGEnabled = false;
                            }
                            else if (await MAG.GetTotalMaximumAsync(token) < 1)
                            {
                                MAG.Base = 0;
                                MAG.Karma = 0;
                                MAG.AssignLimits(0, 0, 0);

                                MagicianEnabled = false;
                                AdeptEnabled = false;
                                MAGEnabled = false;
                            }
                        }

                        if (RESEnabled)
                        {
                            int intResTotalMaximum = await RES.GetTotalMaximumAsync(token);
                            if (Settings.SpecialKarmaCostBasedOnShownValue
                                && intMaxReduction >= intResTotalMaximum
                                || !Settings.SpecialKarmaCostBasedOnShownValue
                                && intResTotalMaximum < 1)
                            {
                                RES.Base = 0;
                                RES.Karma = 0;
                                RES.AssignLimits(0, 0, 0);

                                RESEnabled = false;
                                TechnomancerEnabled = false;
                            }
                        }
                    }
                }
                // Otherwise any essence loss improvements that might have been left need to be deleted (e.g. character is in create mode and had access to special attributes, but that access was removed)
                else
                {
                    await ImprovementManager.RemoveImprovementsAsync(
                        this, Improvement.ImprovementSource.EssenceLossChargen, token: token);
                    await ImprovementManager.RemoveImprovementsAsync(this, Improvement.ImprovementSource.EssenceLoss, token: token);
                    await ImprovementManager.CommitAsync(this, token);
                }

                // If the character is Cyberzombie, adjust their Attributes based on their Essence.
                if (MetatypeCategory == "Cyberzombie")
                {
                    int intESSModifier = (-await EssenceAsync(token: token)).StandardRound();
                    await ImprovementManager.RemoveImprovementsAsync(
                        this,
                        await (await GetImprovementsAsync(token)).ToListAsync(
                            x => x.ImproveSource == Improvement.ImprovementSource.Cyberzombie
                                 && x.ImproveType == Improvement.ImprovementType.Attribute, token), token: token);
                    if (intESSModifier != 0)
                    {
                        await ImprovementManager.CreateImprovementAsync(
                            this, "BOD", Improvement.ImprovementSource.Cyberzombie,
                            string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, intESSModifier, token: token);
                        await ImprovementManager.CreateImprovementAsync(
                            this, "AGI", Improvement.ImprovementSource.Cyberzombie,
                            string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, intESSModifier, token: token);
                        await ImprovementManager.CreateImprovementAsync(
                            this, "REA", Improvement.ImprovementSource.Cyberzombie,
                            string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, intESSModifier, token: token);
                        await ImprovementManager.CreateImprovementAsync(
                            this, "STR", Improvement.ImprovementSource.Cyberzombie,
                            string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, intESSModifier, token: token);
                        await ImprovementManager.CreateImprovementAsync(
                            this, "CHA", Improvement.ImprovementSource.Cyberzombie,
                            string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, intESSModifier, token: token);
                        await ImprovementManager.CreateImprovementAsync(
                            this, "INT", Improvement.ImprovementSource.Cyberzombie,
                            string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, intESSModifier, token: token);
                        await ImprovementManager.CreateImprovementAsync(
                            this, "LOG", Improvement.ImprovementSource.Cyberzombie,
                            string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, intESSModifier, token: token);
                        await ImprovementManager.CreateImprovementAsync(
                            this, "WIL", Improvement.ImprovementSource.Cyberzombie,
                            string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, intESSModifier, token: token);
                        await ImprovementManager.CommitAsync(this, token);
                    }
                }
            }
            finally
            {
                await objLocker.DisposeAsync();
            }
        }

        private void ProcessSettingsExpressionsForDependentProperties(ICollection<string> lstPropertyChangedHolder,
                                                                      string strExpressionToFind)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                if (!Created)
                {
                    if (Settings.ContactPointsExpression.Contains(strExpressionToFind))
                        lstPropertyChangedHolder.Add(nameof(ContactPoints));
                    if (Settings.ChargenKarmaToNuyenExpression.Contains(strExpressionToFind))
                        lstPropertyChangedHolder.Add(nameof(TotalStartingNuyen));
                }

                if (Settings.CarryLimitExpression.Contains(strExpressionToFind))
                    lstPropertyChangedHolder.Add(nameof(BaseCarryLimit));
                if (Settings.LiftLimitExpression.Contains(strExpressionToFind))
                    lstPropertyChangedHolder.Add(nameof(BaseLiftLimit));
                if (Settings.BoundSpiritExpression.Contains(strExpressionToFind))
                    lstPropertyChangedHolder.Add(nameof(BoundSpiritLimit));
                if (Settings.RegisteredSpriteExpression.Contains(strExpressionToFind))
                    lstPropertyChangedHolder.Add(nameof(RegisteredSpriteLimit));
                if (Settings.EncumbranceIntervalExpression.Contains(strExpressionToFind))
                    lstPropertyChangedHolder.Add(nameof(EncumbranceInterval));
            }
        }

        public void RefreshBODDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(16)
                    {
                        nameof(LimitPhysical),
                        nameof(DamageResistancePool),
                        nameof(LiftAndCarry),
                        nameof(FatigueResist),
                        nameof(RadiationResist),
                        nameof(PhysiologicalAddictionResistFirstTime),
                        nameof(PhysiologicalAddictionResistAlreadyAddicted),
                        nameof(StunCMNaturalRecovery),
                        nameof(PhysicalCMNaturalRecovery),
                        nameof(PhysicalCM),
                        nameof(CMOverflow),
                        nameof(SpellDefenseIndirectSoak),
                        nameof(SpellDefenseDirectSoakPhysical),
                        nameof(SpellDefenseDecreaseBOD),
                        nameof(SpellDefenseManipulationPhysical)
                    };
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{BOD}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{BOD}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{BODUnaug}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{BODUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
                case nameof(CharacterAttrib.MetatypeMaximum):
                {
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (DEPEnabled)
                            OnPropertyChanged(nameof(IsAI));
                    }

                    break;
                }
            }
        }

        public void RefreshAGIDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(2)
                    {
                        nameof(SpellDefenseDecreaseAGI),
                        nameof(CalculatedMovement)
                    };
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{AGI}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{AGI}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{AGIUnaug}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{AGIUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
            }
        }

        public void RefreshREADependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(6)
                    {
                        nameof(LimitPhysical),
                        nameof(InitiativeValue),
                        nameof(Dodge),
                        nameof(SpellDefenseDecreaseREA),
                        nameof(Surprise)
                    };
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{REA}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{REA}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{REAUnaug}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{REAUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
            }
        }

        public void RefreshSTRDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(5)
                    {
                        nameof(LimitPhysical),
                        nameof(LiftAndCarry),
                        nameof(SpellDefenseDecreaseSTR),
                        nameof(SpellDefenseManipulationPhysical),
                        nameof(CalculatedMovement),
                        nameof(ArmorEncumbrance)
                    };
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{STR}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{STR}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{STRUnaug}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{STRUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
            }
        }

        public void RefreshCHADependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(6)
                    {
                        nameof(LimitSocial),
                        nameof(Composure),
                        nameof(JudgeIntentions),
                        nameof(JudgeIntentionsResist),
                        nameof(SpellDefenseDecreaseCHA)
                    };
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{CHA}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{CHA}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{CHAUnaug}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{CHAUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
            }
        }

        public void RefreshINTDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(12)
                    {
                        nameof(LimitMental),
                        nameof(JudgeIntentions),
                        nameof(InitiativeValue),
                        nameof(AstralInitiativeValue),
                        nameof(MatrixInitiativeValue),
                        nameof(MatrixInitiativeColdValue),
                        nameof(MatrixInitiativeHotValue),
                        nameof(Dodge),
                        nameof(SpellDefenseDecreaseINT),
                        nameof(SpellDefenseIllusionPhysical),
                        nameof(Surprise)
                    };
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{INT}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{INT}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{INTUnaug}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{INTUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
            }
        }

        public void RefreshLOGDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(10)
                    {
                        nameof(LimitMental),
                        nameof(Memory),
                        nameof(PsychologicalAddictionResistFirstTime),
                        nameof(PsychologicalAddictionResistAlreadyAddicted),
                        nameof(SpellDefenseDetection),
                        nameof(SpellDefenseDecreaseLOG),
                        nameof(SpellDefenseIllusionMana),
                        nameof(SpellDefenseIllusionPhysical),
                        nameof(SpellDefenseManipulationMental)
                    };
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{LOG}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{LOG}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{LOGUnaug}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{LOGUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
            }
        }

        public void RefreshWILDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(27)
                    {
                        nameof(LimitSocial),
                        nameof(LimitMental),
                        nameof(Composure),
                        nameof(Memory),
                        nameof(JudgeIntentionsResist),
                        nameof(FatigueResist),
                        nameof(SonicResist),
                        nameof(RadiationResist),
                        nameof(PhysiologicalAddictionResistFirstTime),
                        nameof(PhysiologicalAddictionResistAlreadyAddicted),
                        nameof(PsychologicalAddictionResistFirstTime),
                        nameof(PsychologicalAddictionResistAlreadyAddicted),
                        nameof(StunCMNaturalRecovery),
                        nameof(StunCM),
                        nameof(SpellDefenseDirectSoakMana),
                        nameof(SpellDefenseDetection),
                        nameof(SpellDefenseDecreaseBOD),
                        nameof(SpellDefenseDecreaseAGI),
                        nameof(SpellDefenseDecreaseREA),
                        nameof(SpellDefenseDecreaseSTR),
                        nameof(SpellDefenseDecreaseCHA),
                        nameof(SpellDefenseDecreaseINT),
                        nameof(SpellDefenseDecreaseLOG),
                        nameof(SpellDefenseDecreaseWIL),
                        nameof(SpellDefenseIllusionMana),
                        nameof(SpellDefenseManipulationMental)
                    };
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{WIL}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{WIL}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{WILUnaug}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{WILUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
            }
        }

        public void RefreshEDGDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(3);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (EdgeUsed > EDG.TotalValue)
                            EdgeUsed = EDG.TotalValue;
                        else
                            lstProperties.Add(nameof(EdgeRemaining));
                    }
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{EDG}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{EDG}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{EDGUnaug}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{EDGUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
            }
        }

        public void RefreshMAGDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(5);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!IsLoading && MysticAdeptPowerPoints > 0)
                        {
                            int intMAGTotalValue = MAG.TotalValue;
                            if (MysticAdeptPowerPoints > intMAGTotalValue)
                                MysticAdeptPowerPoints = intMAGTotalValue;
                        }

                        if (Settings.SpiritForceBasedOnTotalMAG)
                            lstProperties.Add(nameof(MaxSpiritForce));
                        if (MysAdeptAllowPPCareer)
                            lstProperties.Add(nameof(CanAffordCareerPP));
                        if (!UseMysticAdeptPPs && MAG == MAGAdept)
                            lstProperties.Add(nameof(PowerPointsTotal));
                        if (AnyPowerAdeptWayDiscountEnabled)
                            lstProperties.Add(nameof(AllowAdeptWayPowerDiscount));
                    }
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{MAG}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{MAG}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{MAGUnaug}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{MAGUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
            }
        }

        public void RefreshMAGAdeptDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            if(MAG == MAGAdept)
                return;

            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(2);
                    if (!UseMysticAdeptPPs)
                        lstProperties.Add(nameof(MaxSpiritForce));
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{MAGAdept}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{MAGAdept}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{MAGAdeptUnaug}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{MAGAdeptUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
            }
        }

        public void RefreshRESDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(2)
                    {
                        nameof(MaxSpriteLevel)
                    };
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{RES}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{RES}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{RESUnaug}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{RESUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
            }
        }

        public void RefreshDEPDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                case nameof(CharacterAttrib.TotalValue):
                {
                    if (IsAI)
                        EDG.OnPropertyChanged(nameof(CharacterAttrib.MetatypeMaximum));
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{DEP}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{DEP}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{DEPUnaug}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{DEPUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
            }
        }

        public void RefreshESSDependentProperties(object sender, PropertyChangedEventArgs e)
        {
            switch (e?.PropertyName)
            {
                // Only ESS.MetatypeMaximum is used for the Essence method/property when it comes to attributes
                case nameof(CharacterAttrib.MetatypeMaximum):
                    this.OnMultiplePropertyChanged(nameof(PrototypeTranshumanEssenceUsed), nameof(BiowareEssence), nameof(CyberwareEssence), nameof(EssenceHole));
                    break;
                case nameof(CharacterAttrib.TotalValue):
                {
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{ESS}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{ESS}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
                case nameof(CharacterAttrib.Value):
                {
                    List<string> lstProperties = new List<string>(4);
                    ProcessSettingsExpressionsForDependentProperties(lstProperties, "{ESSUnaug}");
                    OnMultiplePropertyChanged(lstProperties);
                    using (EnterReadLock.Enter(LockObject))
                    {
                        if (!Created && Settings.KnowledgePointsExpression.Contains("{ESSUnaug}"))
                            SkillsSection.OnPropertyChanged(nameof(SkillsSection.KnowledgeSkillPoints));
                    }

                    break;
                }
            }
        }

        public void RefreshEncumbrance()
        {
            using (LockObject.EnterWriteLock())
            {
                // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
                if (IsLoading)
                    return;
                // Remove any Improvements from Armor Encumbrance.
                ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.Encumbrance);
                if (!Settings.DoEncumbrancePenaltyPhysicalLimit
                    && !Settings.DoEncumbrancePenaltyMovementSpeed
                    && !Settings.DoEncumbrancePenaltyAgility
                    && !Settings.DoEncumbrancePenaltyReaction)
                    return;
                // Create the Encumbrance Improvements.
                int intEncumbrance = Encumbrance;
                if (intEncumbrance == 0)
                    return;
                if (Settings.DoEncumbrancePenaltyPhysicalLimit)
                    ImprovementManager.CreateImprovement(this, "Physical", Improvement.ImprovementSource.Encumbrance,
                        string.Empty, Improvement.ImprovementType.PhysicalLimit,
                        "precedence-1",
                        intEncumbrance * Settings.EncumbrancePenaltyPhysicalLimit);
                if (Settings.DoEncumbrancePenaltyMovementSpeed)
                {
                    ImprovementManager.CreateImprovement(this, "Ground", Improvement.ImprovementSource.Encumbrance,
                        string.Empty, Improvement.ImprovementType.SprintBonusPercent,
                        "precedence-1",
                        intEncumbrance * Settings.EncumbrancePenaltyMovementSpeed);
                    ImprovementManager.CreateImprovement(this, "Fly", Improvement.ImprovementSource.Encumbrance,
                        string.Empty, Improvement.ImprovementType.SprintBonusPercent,
                        "precedence-1",
                        intEncumbrance * Settings.EncumbrancePenaltyMovementSpeed);
                    ImprovementManager.CreateImprovement(this, "Swim", Improvement.ImprovementSource.Encumbrance,
                        string.Empty, Improvement.ImprovementType.SprintBonusPercent,
                        "precedence-1",
                        intEncumbrance * Settings.EncumbrancePenaltyMovementSpeed);
                    ImprovementManager.CreateImprovement(this, "Ground", Improvement.ImprovementSource.Encumbrance,
                        string.Empty, Improvement.ImprovementType.RunMultiplierPercent,
                        "precedence-1",
                        intEncumbrance * Settings.EncumbrancePenaltyMovementSpeed);
                    ImprovementManager.CreateImprovement(this, "Fly", Improvement.ImprovementSource.Encumbrance,
                        string.Empty, Improvement.ImprovementType.RunMultiplierPercent,
                        "precedence-1",
                        intEncumbrance * Settings.EncumbrancePenaltyMovementSpeed);
                    ImprovementManager.CreateImprovement(this, "Swim", Improvement.ImprovementSource.Encumbrance,
                        string.Empty, Improvement.ImprovementType.RunMultiplierPercent,
                        "precedence-1",
                        intEncumbrance * Settings.EncumbrancePenaltyMovementSpeed);
                    ImprovementManager.CreateImprovement(this, "Ground", Improvement.ImprovementSource.Encumbrance,
                        string.Empty, Improvement.ImprovementType.WalkMultiplierPercent,
                        "precedence-1",
                        intEncumbrance * Settings.EncumbrancePenaltyMovementSpeed);
                    ImprovementManager.CreateImprovement(this, "Fly", Improvement.ImprovementSource.Encumbrance,
                        string.Empty, Improvement.ImprovementType.WalkMultiplierPercent,
                        "precedence-1",
                        intEncumbrance * Settings.EncumbrancePenaltyMovementSpeed);
                    ImprovementManager.CreateImprovement(this, "Swim", Improvement.ImprovementSource.Encumbrance,
                        string.Empty, Improvement.ImprovementType.WalkMultiplierPercent,
                        "precedence-1",
                        intEncumbrance * Settings.EncumbrancePenaltyMovementSpeed);
                }

                if (Settings.DoEncumbrancePenaltyAgility)
                    ImprovementManager.CreateImprovement(this, "AGI", Improvement.ImprovementSource.Encumbrance,
                        string.Empty, Improvement.ImprovementType.Attribute, "precedence-1", 0, 1, 0, 0,
                        intEncumbrance * Settings.EncumbrancePenaltyAgility);
                if (Settings.DoEncumbrancePenaltyReaction)
                    ImprovementManager.CreateImprovement(this, "REA", Improvement.ImprovementSource.Encumbrance,
                        string.Empty, Improvement.ImprovementType.Attribute, "precedence-1", 0, 1, 0, 0,
                        intEncumbrance * Settings.EncumbrancePenaltyReaction);
                ImprovementManager.Commit(this);
            }
        }

        public void RefreshArmorEncumbrance()
        {
            using (LockObject.EnterWriteLock())
            {
                // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
                if (IsLoading)
                    return;
                // Remove any Improvements from Armor Encumbrance.
                ImprovementManager.RemoveImprovements(this, Improvement.ImprovementSource.ArmorEncumbrance);
                // Create the Armor Encumbrance Improvements.
                int intEncumbrance = ArmorEncumbrance;
                if (intEncumbrance != 0)
                {
                    ImprovementManager.CreateImprovement(this, "AGI", Improvement.ImprovementSource.ArmorEncumbrance,
                        string.Empty, Improvement.ImprovementType.Attribute, "precedence-1", 0, 1, 0, 0,
                        intEncumbrance);
                    ImprovementManager.CreateImprovement(this, "REA", Improvement.ImprovementSource.ArmorEncumbrance,
                        string.Empty, Improvement.ImprovementType.Attribute, "precedence-1", 0, 1, 0, 0,
                        intEncumbrance);
                    ImprovementManager.Commit(this);
                }
            }
        }

        public void RefreshWoundPenalties()
        {
            using (LockObject.EnterWriteLock())
            {
                // Don't hammer away with this method while this character is loading. Instead, it will be run once after everything has been loaded in.
                if (IsLoading)
                    return;
                int intPhysicalCMFilled = Math.Min(PhysicalCMFilled, PhysicalCM);
                int intStunCMFilled = Math.Min(StunCMFilled, StunCM);
                int intCMThreshold = CMThreshold;
                int intStunCMPenalty = ImprovementManager
                    .GetCachedImprovementListForValueOf(
                        this, Improvement.ImprovementType.IgnoreCMPenaltyStun)
                    .Count > 0
                    ? 0
                    : Math.Min(0, StunCMThresholdOffset - intStunCMFilled) / intCMThreshold;
                int intPhysicalCMPenalty = ImprovementManager
                    .GetCachedImprovementListForValueOf(
                        this, Improvement.ImprovementType.IgnoreCMPenaltyPhysical)
                    .Count > 0
                    ? 0
                    : Math.Min(0, PhysicalCMThresholdOffset - intPhysicalCMFilled) / intCMThreshold;
                _intWoundModifier = intPhysicalCMPenalty + intStunCMPenalty;
                if (Settings.DoEncumbrancePenaltyWoundModifier && Encumbrance != 0)
                    _intWoundModifier += Encumbrance * Settings.EncumbrancePenaltyWoundModifier;
            }
        }

        private int _intWoundModifier;

        /// <summary>
        /// Recalculates the Dicepoolmodifier for sustaining spells or complex forms
        /// </summary>
        public bool RefreshSustainingPenalties()
        {
            using (LockObject.EnterWriteLock())
            {
                if (IsLoading) // If we are in the middle of loading, just queue a single refresh to happen at the end of the process
                {
                    if (!PostLoadMethods.Contains(RefreshSustainingPenalties))
                        PostLoadMethods.Enqueue(RefreshSustainingPenalties);
                    return true;
                }

                int intDicePenaltySustainedSpell = Settings.DicePenaltySustaining;

                //The sustaining of Critterpowers doesn't cause any penalties that's why they aren't counted there is no way to change them to self sustained anyway, but just to be sure
                List<SustainedObject> lstSustainedSpells =
                    SustainedCollection.Where(x => x.HasSustainingPenalty).ToList();
                // Handling of bonuses that let characters sustain some objects for free requires special handling in order to best match the bonus ensemble to the sustained spells ensemble
                if (ImprovementManager.ValueOf(this, Improvement.ImprovementType.PenaltyFreeSustain,
                        out List<Improvement> lstUsedImprovements) != 0)
                {
                    // Set up a dictionary where the key is the maximum force/level of the bonus and the value is the number of objects that can be sustained
                    SortedDictionary<decimal, int> dicPenaltyFreeSustains = new SortedDictionary<decimal, int>();
                    foreach (Improvement objImprovement in lstUsedImprovements)
                    {
                        decimal decForce = objImprovement.Value;
                        if (dicPenaltyFreeSustains.TryGetValue(decForce, out int intExistingRating))
                            dicPenaltyFreeSustains[decForce] = intExistingRating + objImprovement.Rating;
                        else
                            dicPenaltyFreeSustains.Add(decForce, objImprovement.Rating);
                    }

                    // List of supported objects, sorted in descending order of Force
                    List<SustainedObject> lstSupportedObjects = new List<SustainedObject>(lstSustainedSpells.Count);
                    // Go from lowest maximum force/level bonus to highest (that's why we use SortedDictionary) and match each one to the highest possible objects for it.
                    foreach (KeyValuePair<decimal, int> kvpLoop in dicPenaltyFreeSustains)
                    {
                        int intSupportedForce = kvpLoop.Key.StandardRound();
                        int intNumSupportsPossible = kvpLoop.Value;
                        lstSupportedObjects.Clear();
                        foreach (SustainedObject objLoopObject in lstSustainedSpells)
                        {
                            int intLoopForce = objLoopObject.Force;
                            if (intLoopForce > intSupportedForce)
                                continue;
                            if (intLoopForce == intSupportedForce)
                            {
                                if (lstSupportedObjects.Count + 1 > intNumSupportsPossible)
                                    // Remove the last element because we know it's the lowest
                                    lstSupportedObjects.RemoveAt(lstSupportedObjects.Count - 1);
                                // Safe to insert object at the top because we cannot get objects with more Force in the list
                                lstSupportedObjects.Insert(0, objLoopObject);
                                if (lstSupportedObjects.Count == intNumSupportsPossible &&
                                    lstSupportedObjects[lstSupportedObjects.Count - 1].Force == intSupportedForce)
                                    // The entire list at this point is saturated with objects with the maximum allowable force, so quit out early
                                    break;
                            }
                            else
                            {
                                if (lstSupportedObjects.Count + 1 > intNumSupportsPossible)
                                {
                                    // Check against the last element because we know it'll be the lowest, only replace item if loop has a higher force than this one
                                    if (intLoopForce <= lstSupportedObjects[lstSupportedObjects.Count - 1].Force)
                                        continue;
                                    lstSupportedObjects.RemoveAt(lstSupportedObjects.Count - 1);
                                }

                                lstSupportedObjects.AddWithSort(objLoopObject, (x, y) => y.Force.CompareTo(x.Force));
                            }
                        }

                        // Remove all sustained objects that supported as penalty-free
                        lstSustainedSpells.RemoveAll(x => lstSupportedObjects.Contains(x));
                        // If we have no more sustained objects in need of penalty removal, exit out early
                        if (lstSustainedSpells.Count == 0)
                            break;
                    }
                }

                int intModifierPerSpell = PsycheActive ? -1 : -intDicePenaltySustainedSpell;

                SustainingPenalty = lstSustainedSpells.Count * intModifierPerSpell;
            }
            return true;
        }

        private int _intSustainingPenalty;
        /// <summary>
        /// Dicepool modifier the character has from wounds. Should be a non-positive number because wound modifiers are always penalties if they are not 0.
        /// </summary>
        public int WoundModifier
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intWoundModifier;
            }
        }

        /// <summary>
        /// Dicepool modifie the character has from sustaining spells. Should be negative
        /// </summary>
        public int SustainingPenalty
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _intSustainingPenalty;
            }
            private set //Private set instead of read only, to allow inclusion of OnPropertyChanged
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (value == _intSustainingPenalty)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _intSustainingPenalty = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        private bool _blnLoadAsDirty;

        /// <summary>
        /// Whether to immediately mark a character file as dirty when it is loaded in. Used if we're changing a character's settings on load.
        /// </summary>
        public bool LoadAsDirty
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _blnLoadAsDirty;
            }
            private set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_blnLoadAsDirty == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _blnLoadAsDirty = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        public Version LastSavedVersion
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _verSavedVersion;
            }
        }

        /// <summary>
        /// Is the character a mystic adept (MagicianEnabled && AdeptEnabled)? Used for databinding properties.
        /// </summary>
        public bool IsMysticAdept
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return AdeptEnabled && MagicianEnabled;
            }
        }

        /// <summary>
        /// Is the character a mystic adept (MagicianEnabled && AdeptEnabled)? Used for databinding properties.
        /// </summary>
        public async ValueTask<bool> GetIsMysticAdeptAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return await GetAdeptEnabledAsync(token) && await GetMagicianEnabledAsync(token);
        }

        /// <summary>
        /// Whether this character is using special Mystic Adept PP rules (true) or calculate PPs from Mystic Adept's Adept MAG (false)
        /// </summary>
        public bool UseMysticAdeptPPs
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return IsMysticAdept && !Settings.MysAdeptSecondMAGAttribute;
            }
        }

        /// <summary>
        /// Whether this character is using special Mystic Adept PP rules (true) or calculate PPs from Mystic Adept's Adept MAG (false)
        /// </summary>
        public async ValueTask<bool> GetUseMysticAdeptPPsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
                return await GetIsMysticAdeptAsync(token) && !await (await GetSettingsAsync(token)).GetMysAdeptSecondMAGAttributeAsync(token);
        }

        /// <summary>
        /// Whether this character is a Mystic Adept uses PPs and can purchase PPs in career mode
        /// </summary>
        public bool MysAdeptAllowPPCareer
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return UseMysticAdeptPPs && Settings.MysAdeptAllowPpCareer;
            }
        }

        /// <summary>
        /// Could this character buy Power Points in career mode if the optional/house rule is enabled
        /// </summary>
        public bool CanAffordCareerPP
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    return MysAdeptAllowPPCareer
                           && Karma >= Settings.KarmaMysticAdeptPowerPoint
                           && MAG.TotalValue > MysticAdeptPowerPoints;
                }
            }
        }

        /// <summary>
        /// Whether the character is allowed to gain free spells that are limited to the Touch range.
        /// </summary>
        public Tuple<bool, bool> AllowFreeSpells()
        {
            using (EnterReadLock.Enter(LockObject))
            {
                //Free Spells (typically from Dedicated Spellslinger or custom Improvements) are only handled manually
                //in Career Mode. Create mode manages itself.
                int intFreeGenericSpells = ImprovementManager.ValueOf(this, Improvement.ImprovementType.FreeSpells)
                    .StandardRound();
                int intFreeTouchOnlySpells = 0;
                foreach (Improvement imp in ImprovementManager.GetCachedImprovementListForValueOf(this,
                             Improvement.ImprovementType.FreeSpellsATT))
                {
                    int intAttValue = GetAttribute(imp.ImprovedName).TotalValue;
                    if (imp.UniqueName.Contains("half"))
                        intAttValue = (intAttValue + 1) / 2;
                    if (imp.UniqueName.Contains("touchonly"))
                        intFreeTouchOnlySpells += intAttValue;
                    else
                        intFreeGenericSpells += intAttValue;
                }

                foreach (Improvement imp in ImprovementManager.GetCachedImprovementListForValueOf(this,
                             Improvement.ImprovementType.FreeSpellsSkill))
                {
                    Skill skill = SkillsSection.GetActiveSkill(imp.ImprovedName);
                    int intSkillValue = SkillsSection.GetActiveSkill(imp.ImprovedName).TotalBaseRating;
                    if (imp.UniqueName.Contains("half"))
                        intSkillValue = (intSkillValue + 1) / 2;
                    if (imp.UniqueName.Contains("touchonly"))
                        intFreeTouchOnlySpells += intSkillValue;
                    else
                        intFreeGenericSpells += intSkillValue;
                    //TODO: I don't like this being hardcoded, even though I know full well CGL are never going to reuse this
                    intFreeGenericSpells += skill.Specializations.Count(spec =>
                        Spells.Any(spell => spell.Category == spec.Name && !spell.FreeBonus));
                }

                int intTotalFreeNonTouchSpellsCount = Spells.Count(spell =>
                    spell.FreeBonus && (spell.Range != "T" && spell.Range != "T (A)"));
                int intTotalFreeTouchOnlySpellsCount = Spells.Count(spell =>
                    spell.FreeBonus && (spell.Range == "T" || spell.Range == "T (A)"));
                return new Tuple<bool, bool>(intFreeTouchOnlySpells > intTotalFreeTouchOnlySpellsCount,
                    intFreeGenericSpells > intTotalFreeNonTouchSpellsCount +
                    Math.Max(intTotalFreeTouchOnlySpellsCount - intFreeTouchOnlySpells, 0));
            }
        }

        /// <summary>
        /// Whether the character is allowed to gain free spells that are limited to the Touch range.
        /// </summary>
        public async ValueTask<Tuple<bool, bool>> AllowFreeSpellsAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                //Free Spells (typically from Dedicated Spellslinger or custom Improvements) are only handled manually
                //in Career Mode. Create mode manages itself.
                int intFreeGenericSpells = (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.FreeSpells, token: token))
                    .StandardRound();
                int intFreeTouchOnlySpells = 0;
                foreach (Improvement imp in await ImprovementManager.GetCachedImprovementListForValueOfAsync(this,
                             Improvement.ImprovementType.FreeSpellsATT, token: token))
                {
                    int intAttValue = await (await GetAttributeAsync(imp.ImprovedName, token: token)).GetTotalValueAsync(token);
                    if (imp.UniqueName.Contains("half"))
                        intAttValue = (intAttValue + 1) / 2;
                    if (imp.UniqueName.Contains("touchonly"))
                        intFreeTouchOnlySpells += intAttValue;
                    else
                        intFreeGenericSpells += intAttValue;
                }

                ThreadSafeObservableCollection<Spell> lstSpells = await GetSpellsAsync(token);
                SkillsSection objSkillsSection = await GetSkillsSectionAsync(token);
                foreach (Improvement imp in await ImprovementManager.GetCachedImprovementListForValueOfAsync(this,
                             Improvement.ImprovementType.FreeSpellsSkill, token: token))
                {
                    Skill skill = await objSkillsSection.GetActiveSkillAsync(imp.ImprovedName, token);
                    int intSkillValue = (await objSkillsSection.GetActiveSkillAsync(imp.ImprovedName, token)).TotalBaseRating;
                    if (imp.UniqueName.Contains("half"))
                        intSkillValue = (intSkillValue + 1) / 2;
                    if (imp.UniqueName.Contains("touchonly"))
                        intFreeTouchOnlySpells += intSkillValue;
                    else
                        intFreeGenericSpells += intSkillValue;
                    //TODO: I don't like this being hardcoded, even though I know full well CGL are never going to reuse this
                    intFreeGenericSpells += await skill.Specializations.CountAsync(spec =>
                        lstSpells.AnyAsync(spell => spell.Category == spec.Name && !spell.FreeBonus, token: token), token);
                }

                int intTotalFreeNonTouchSpellsCount = await lstSpells.CountAsync(spell =>
                    spell.FreeBonus && (spell.Range != "T" && spell.Range != "T (A)"), token: token);
                int intTotalFreeTouchOnlySpellsCount = await lstSpells.CountAsync(spell =>
                    spell.FreeBonus && (spell.Range == "T" || spell.Range == "T (A)"), token: token);
                return new Tuple<bool, bool>(intFreeTouchOnlySpells > intTotalFreeTouchOnlySpellsCount,
                    intFreeGenericSpells > intTotalFreeNonTouchSpellsCount +
                    Math.Max(intTotalFreeTouchOnlySpellsCount - intFreeTouchOnlySpells, 0));
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;

        // Kept separate for events that are meant to work off of changes to whatever settings the character even if they change
        public event PropertyChangedEventHandler SettingsPropertyChanged;

        #region Static

        //A tree of dependencies. Once some of the properties are changed,
        //anything they depend on, also needs to raise OnChanged
        //This tree keeps track of dependencies
        private static readonly PropertyDependencyGraph<Character> s_CharacterDependencyGraph =
            new PropertyDependencyGraph<Character>(
                    new DependencyGraphNode<string, Character>(nameof(CharacterName),
                        new DependencyGraphNode<string, Character>(nameof(Alias)),
                        new DependencyGraphNode<string, Character>(nameof(Name), x => string.IsNullOrWhiteSpace(x.Alias),
                            new DependencyGraphNode<string, Character>(nameof(Alias))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayPowerPointsRemaining),
                        new DependencyGraphNode<string, Character>(nameof(PowerPointsTotal),
                            new DependencyGraphNode<string, Character>(nameof(UseMysticAdeptPPs),
                                new DependencyGraphNode<string, Character>(nameof(IsMysticAdept),
                                    new DependencyGraphNode<string, Character>(nameof(AdeptEnabled)),
                                    new DependencyGraphNode<string, Character>(nameof(MagicianEnabled))
                                )
                            ),
                            new DependencyGraphNode<string, Character>(nameof(MysticAdeptPowerPoints), x => x.UseMysticAdeptPPs,
                                new DependencyGraphNode<string, Character>(nameof(UseMysticAdeptPPs))
                            )
                        ),
                        new DependencyGraphNode<string, Character>(nameof(PowerPointsUsed))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(CanAffordCareerPP),
                        new DependencyGraphNode<string, Character>(nameof(MysAdeptAllowPPCareer),
                            new DependencyGraphNode<string, Character>(nameof(UseMysticAdeptPPs))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(MysticAdeptPowerPoints)),
                        new DependencyGraphNode<string, Character>(nameof(Karma))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(AddInitiationsAllowed),
                        new DependencyGraphNode<string, Character>(nameof(IgnoreRules)),
                        new DependencyGraphNode<string, Character>(nameof(Created))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(InitiationEnabled),
                        new DependencyGraphNode<string, Character>(nameof(MAGEnabled)),
                        new DependencyGraphNode<string, Character>(nameof(RESEnabled)),
                        new DependencyGraphNode<string, Character>(nameof(InitiationForceDisabled))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(InitiativeToolTip),
                        new DependencyGraphNode<string, Character>(nameof(Initiative),
                            new DependencyGraphNode<string, Character>(nameof(InitiativeDice)),
                            new DependencyGraphNode<string, Character>(nameof(InitiativeValue),
                                new DependencyGraphNode<string, Character>(nameof(WoundModifier))
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(AstralInitiativeToolTip),
                        new DependencyGraphNode<string, Character>(nameof(AstralInitiative),
                            new DependencyGraphNode<string, Character>(nameof(AstralInitiativeDice)),
                            new DependencyGraphNode<string, Character>(nameof(AstralInitiativeValue),
                                new DependencyGraphNode<string, Character>(nameof(WoundModifier))
                            )
                        ),
                        new DependencyGraphNode<string, Character>(nameof(MAGEnabled))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeToolTip),
                        new DependencyGraphNode<string, Character>(nameof(MatrixInitiative),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeDice),
                                new DependencyGraphNode<string, Character>(nameof(IsAI)),
                                new DependencyGraphNode<string, Character>(nameof(InitiativeDice), x => !x.IsAI,
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                )
                            ),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeValue),
                                new DependencyGraphNode<string, Character>(nameof(IsAI)),
                                new DependencyGraphNode<string, Character>(nameof(HomeNode), x => x.IsAI,
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                ),
                                new DependencyGraphNode<string, Character>(nameof(WoundModifier), x => x.IsAI,
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                ),
                                new DependencyGraphNode<string, Character>(nameof(InitiativeValue), x => !x.IsAI,
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                )
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeColdToolTip),
                        new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeCold),
                            new DependencyGraphNode<string, Character>(nameof(IsAI)),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiative), x => x.IsAI,
                                new DependencyGraphNode<string, Character>(nameof(IsAI))
                            ),
                            new DependencyGraphNode<string, Character>(nameof(ActiveCommlink), x => !x.IsAI,
                                new DependencyGraphNode<string, Character>(nameof(IsAI))
                            ),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeColdDice),
                                new DependencyGraphNode<string, Character>(nameof(IsAI)),
                                new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeDice), x => x.IsAI,
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                )
                            ),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeColdValue),
                                new DependencyGraphNode<string, Character>(nameof(ActiveCommlink), x => !x.IsAI,
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                ),
                                new DependencyGraphNode<string, Character>(nameof(IsAI)),
                                new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeValue), x => x.IsAI,
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                ),
                                new DependencyGraphNode<string, Character>(nameof(WoundModifier), x => !x.IsAI,
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                )
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeHotToolTip),
                        new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeHot),
                            new DependencyGraphNode<string, Character>(nameof(IsAI)),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiative), x => x.IsAI,
                                new DependencyGraphNode<string, Character>(nameof(IsAI))
                            ),
                            new DependencyGraphNode<string, Character>(nameof(ActiveCommlink), x => !x.IsAI,
                                new DependencyGraphNode<string, Character>(nameof(IsAI))
                            ),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeHotDice),
                                new DependencyGraphNode<string, Character>(nameof(IsAI)),
                                new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeDice), x => x.IsAI,
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                )
                            ),
                            new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeHotValue),
                                new DependencyGraphNode<string, Character>(nameof(ActiveCommlink), x => !x.IsAI,
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                ),
                                new DependencyGraphNode<string, Character>(nameof(IsAI)),
                                new DependencyGraphNode<string, Character>(nameof(MatrixInitiativeValue), x => x.IsAI,
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                ),
                                new DependencyGraphNode<string, Character>(nameof(WoundModifier), x => !x.IsAI,
                                    new DependencyGraphNode<string, Character>(nameof(IsAI))
                                )
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(IsSprite),
                        new DependencyGraphNode<string, Character>(nameof(IsFreeSprite),
                            new DependencyGraphNode<string, Character>(nameof(MetatypeCategory))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayMetatypeBP),
                        new DependencyGraphNode<string, Character>(nameof(MetatypeBP))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(PhysicalCMLabelText),
                        new DependencyGraphNode<string, Character>(nameof(IsAI)),
                        new DependencyGraphNode<string, Character>(nameof(HomeNode))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(PhysicalCMToolTip),
                        new DependencyGraphNode<string, Character>(nameof(PhysicalCM))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(StunCMToolTip),
                        new DependencyGraphNode<string, Character>(nameof(StunCM))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(StunCMVisible),
                        new DependencyGraphNode<string, Character>(nameof(IsAI)),
                        new DependencyGraphNode<string, Character>(nameof(HomeNode))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(StunCMLabelText),
                        new DependencyGraphNode<string, Character>(nameof(IsAI)),
                        new DependencyGraphNode<string, Character>(nameof(HomeNode))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SustainingPenalty),
                        new DependencyGraphNode<string, Character>(nameof(PsycheActive))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(WoundModifier),
                        new DependencyGraphNode<string, Character>(nameof(PhysicalCMFilled),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(PhysicalCM),
                            new DependencyGraphNode<string, Character>(nameof(IsAI)),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(StunCMFilled),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(StunCM),
                            new DependencyGraphNode<string, Character>(nameof(IsAI)),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(CMThreshold)),
                        new DependencyGraphNode<string, Character>(nameof(PhysicalCMThresholdOffset),
                            new DependencyGraphNode<string, Character>(nameof(StunCMFilled)),
                            new DependencyGraphNode<string, Character>(nameof(CMThreshold)),
                            new DependencyGraphNode<string, Character>(nameof(IsAI))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(StunCMThresholdOffset),
                            new DependencyGraphNode<string, Character>(nameof(PhysicalCMFilled)),
                            new DependencyGraphNode<string, Character>(nameof(CMThreshold)),
                            new DependencyGraphNode<string, Character>(nameof(IsAI))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(Encumbrance), x => x.Settings.DoEncumbrancePenaltyWoundModifier)
                    ),
                    new DependencyGraphNode<string, Character>(nameof(CMThresholdOffsets),
                        new DependencyGraphNode<string, Character>(nameof(PhysicalCMThresholdOffset)),
                        new DependencyGraphNode<string, Character>(nameof(StunCMThresholdOffset))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(EffectiveBuildMethodUsesPriorityTables),
                        new DependencyGraphNode<string, Character>(nameof(EffectiveBuildMethod),
                            new DependencyGraphNode<string, Character>(nameof(IsCritter))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(EnableAutomaticStoryButton),
                        new DependencyGraphNode<string, Character>(nameof(EffectiveBuildMethodIsLifeModule),
                            new DependencyGraphNode<string, Character>(nameof(EffectiveBuildMethod))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DamageResistancePoolToolTip),
                        new DependencyGraphNode<string, Character>(nameof(DamageResistancePool),
                            new DependencyGraphNode<string, Character>(nameof(TotalArmorRating)),
                            new DependencyGraphNode<string, Character>(nameof(IsAI)),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode), x => x.IsAI,
                                new DependencyGraphNode<string, Character>(nameof(IsAI))
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(IsAI),
                        new DependencyGraphNode<string, Character>(nameof(DEPEnabled))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseIndirectDodgeToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIndirectDodge),
                            new DependencyGraphNode<string, Character>(nameof(TotalBonusDodgeRating))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DodgeToolTip),
                        new DependencyGraphNode<string, Character>(nameof(Dodge),
                            new DependencyGraphNode<string, Character>(nameof(TotalBonusDodgeRating),
                            new DependencyGraphNode<string, Character>(nameof(WoundModifier)),
                            new DependencyGraphNode<string, Character>(nameof(SustainingPenalty))
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseIndirectDodge),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIndirectDodge))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseIndirectSoakToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIndirectSoak),
                            new DependencyGraphNode<string, Character>(nameof(TotalArmorRating)),
                            new DependencyGraphNode<string, Character>(nameof(IsAI)),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode), x => x.IsAI,
                                new DependencyGraphNode<string, Character>(nameof(IsAI))
                            ),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseIndirectSoak),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIndirectSoak))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDirectSoakManaToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDirectSoakMana),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDirectSoakMana),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDirectSoakMana))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDirectSoakPhysicalToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDirectSoakPhysical),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDirectSoakPhysical),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDirectSoakPhysical))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDetectionToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDetection),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDetection),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDetection))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseBODToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseBOD),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseBOD),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseBOD))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseAGIToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseAGI),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseAGI),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseAGI))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseREAToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseREA),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseREA),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseREA))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseSTRToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseSTR),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseSTR),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseSTR))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseCHAToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseCHA),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseCHA),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseCHA))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseINTToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseINT),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseINT),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseINT))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseLOGToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseLOG),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseLOG),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseLOG))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseWILToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseWIL),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseDecreaseWIL),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseDecreaseWIL))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseIllusionManaToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIllusionMana),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseIllusionMana),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIllusionMana))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseIllusionPhysicalToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIllusionPhysical),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseIllusionPhysical),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseIllusionPhysical))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseManipulationMentalToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseManipulationMental),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseManipulationMental),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseManipulationMental))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SpellDefenseManipulationPhysicalToolTip),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseManipulationPhysical),
                            new DependencyGraphNode<string, Character>(nameof(SpellResistance)),
                            new DependencyGraphNode<string, Character>(nameof(IsAI)),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode), x => x.IsAI,
                                new DependencyGraphNode<string, Character>(nameof(IsAI))
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySpellDefenseManipulationPhysical),
                        new DependencyGraphNode<string, Character>(nameof(CurrentCounterspellingDice)),
                        new DependencyGraphNode<string, Character>(nameof(SpellDefenseManipulationPhysical))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(TotalArmorRatingToolTip),
                        new DependencyGraphNode<string, Character>(nameof(TotalArmorRating),
                            new DependencyGraphNode<string, Character>(nameof(GetArmorRating),
                                new DependencyGraphNode<string, Character>(nameof(GetArmorRatingWithImprovement))
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(TotalFireArmorRating),
                        new DependencyGraphNode<string, Character>(nameof(GetArmorRating))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(TotalColdArmorRating),
                        new DependencyGraphNode<string, Character>(nameof(GetArmorRating))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(TotalElectricityArmorRating),
                        new DependencyGraphNode<string, Character>(nameof(GetArmorRating))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(TotalAcidArmorRating),
                        new DependencyGraphNode<string, Character>(nameof(GetArmorRating))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(TotalFallingArmorRating),
                        new DependencyGraphNode<string, Character>(nameof(GetArmorRating))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayEssence),
                        new DependencyGraphNode<string, Character>(nameof(Essence),
                            new DependencyGraphNode<string, Character>(nameof(CyberwareEssence)),
                            new DependencyGraphNode<string, Character>(nameof(BiowareEssence)),
                            new DependencyGraphNode<string, Character>(nameof(PrototypeTranshumanEssenceUsed)),
                            new DependencyGraphNode<string, Character>(nameof(EssenceHole))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(ComposureToolTip),
                        new DependencyGraphNode<string, Character>(nameof(Composure),
                            new DependencyGraphNode<string, Character>(nameof(SustainingPenalty)),
                            new DependencyGraphNode<string, Character>(nameof(WoundModifier))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(SurpriseToolTip),
                        new DependencyGraphNode<string, Character>(nameof(Surprise),
                            new DependencyGraphNode<string, Character>(nameof(WoundModifier)),
                            new DependencyGraphNode<string, Character>(nameof(SustainingPenalty))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(JudgeIntentionsToolTip),
                        new DependencyGraphNode<string, Character>(nameof(JudgeIntentions),
                            new DependencyGraphNode<string, Character>(nameof(WoundModifier)),
                            new DependencyGraphNode<string, Character>(nameof(SustainingPenalty))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(JudgeIntentionsResistToolTip),
                        new DependencyGraphNode<string, Character>(nameof(JudgeIntentionsResist))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(LiftAndCarryToolTip),
                        new DependencyGraphNode<string, Character>(nameof(LiftAndCarry),
                            new DependencyGraphNode<string, Character>(nameof(WoundModifier)),
                            new DependencyGraphNode<string, Character>(nameof(SustainingPenalty))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(MemoryToolTip),
                        new DependencyGraphNode<string, Character>(nameof(Memory),
                            new DependencyGraphNode<string, Character>(nameof(WoundModifier)),
                            new DependencyGraphNode<string, Character>(nameof(SustainingPenalty))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(LiftAndCarryLimits),
                        new DependencyGraphNode<string, Character>(nameof(LiftLimit),
                            new DependencyGraphNode<string, Character>(nameof(BaseLiftLimit)),
                            new DependencyGraphNode<string, Character>(nameof(CurrentLiftCarryHits))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(CarryLimit),
                            new DependencyGraphNode<string, Character>(nameof(BaseCarryLimit)),
                            new DependencyGraphNode<string, Character>(nameof(CurrentLiftCarryHits))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(Encumbrance),
                        new DependencyGraphNode<string, Character>(nameof(CarryLimit)),
                        new DependencyGraphNode<string, Character>(nameof(TotalCarriedWeight)),
                        new DependencyGraphNode<string, Character>(nameof(EncumbranceInterval))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayTotalCarriedWeight),
                        new DependencyGraphNode<string, Character>(nameof(CarryLimit)),
                        new DependencyGraphNode<string, Character>(nameof(TotalCarriedWeight))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayCyberwareEssence),
                        new DependencyGraphNode<string, Character>(nameof(CyberwareEssence))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayBiowareEssence),
                        new DependencyGraphNode<string, Character>(nameof(BiowareEssence))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayEssenceHole),
                        new DependencyGraphNode<string, Character>(nameof(EssenceHole))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayPrototypeTranshumanEssenceUsed),
                        new DependencyGraphNode<string, Character>(nameof(PrototypeTranshumanEssenceUsed)),
                        new DependencyGraphNode<string, Character>(nameof(PrototypeTranshuman))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(IsPrototypeTranshuman),
                        new DependencyGraphNode<string, Character>(nameof(PrototypeTranshuman))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayNuyen),
                        new DependencyGraphNode<string, Character>(nameof(Nuyen))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayStolenNuyen),
                        new DependencyGraphNode<string, Character>(nameof(StolenNuyen))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayKarma),
                        new DependencyGraphNode<string, Character>(nameof(Karma))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayTotalStartingNuyen),
                        new DependencyGraphNode<string, Character>(nameof(TotalStartingNuyen),
                            new DependencyGraphNode<string, Character>(nameof(StartingNuyen)),
                            new DependencyGraphNode<string, Character>(nameof(NuyenBP)),
                            new DependencyGraphNode<string, Character>(nameof(TotalNuyenMaximumBP),
                                new DependencyGraphNode<string, Character>(nameof(StolenNuyen)),
                                new DependencyGraphNode<string, Character>(nameof(IgnoreRules))
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayCareerNuyen),
                        new DependencyGraphNode<string, Character>(nameof(CareerNuyen))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayCareerKarma),
                        new DependencyGraphNode<string, Character>(nameof(CareerKarma))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(StreetCredTooltip),
                        new DependencyGraphNode<string, Character>(nameof(TotalStreetCred),
                            new DependencyGraphNode<string, Character>(nameof(StreetCred)),
                            new DependencyGraphNode<string, Character>(nameof(CalculatedStreetCred),
                                new DependencyGraphNode<string, Character>(nameof(CareerKarma)),
                                new DependencyGraphNode<string, Character>(nameof(BurntStreetCred))
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(CanBurnStreetCred),
                        new DependencyGraphNode<string, Character>(nameof(TotalStreetCred))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(NotorietyTooltip),
                        new DependencyGraphNode<string, Character>(nameof(TotalNotoriety),
                            new DependencyGraphNode<string, Character>(nameof(Notoriety)),
                            new DependencyGraphNode<string, Character>(nameof(CalculatedNotoriety)),
                            new DependencyGraphNode<string, Character>(nameof(BurntStreetCred))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(PublicAwarenessTooltip),
                        new DependencyGraphNode<string, Character>(nameof(TotalPublicAwareness),
                            new DependencyGraphNode<string, Character>(nameof(Erased)),
                            new DependencyGraphNode<string, Character>(nameof(CalculatedPublicAwareness),
                                new DependencyGraphNode<string, Character>(nameof(PublicAwareness)),
                                new DependencyGraphNode<string, Character>(nameof(TotalStreetCred),
                                    x => x.Settings.UseCalculatedPublicAwareness),
                                new DependencyGraphNode<string, Character>(nameof(TotalNotoriety),
                                    x => x.Settings.UseCalculatedPublicAwareness)
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(CareerDisplayStreetCred),
                        new DependencyGraphNode<string, Character>(nameof(TotalStreetCred))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(CareerDisplayNotoriety),
                        new DependencyGraphNode<string, Character>(nameof(TotalNotoriety))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(CareerDisplayPublicAwareness),
                        new DependencyGraphNode<string, Character>(nameof(TotalPublicAwareness))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(AddBiowareEnabled),
                        new DependencyGraphNode<string, Character>(nameof(CyberwareDisabled)),
                        new DependencyGraphNode<string, Character>(nameof(IsAI))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(AddCyberwareEnabled),
                        new DependencyGraphNode<string, Character>(nameof(CyberwareDisabled)),
                        new DependencyGraphNode<string, Character>(nameof(IsAI))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(HasMentorSpirit),
                        new DependencyGraphNode<string, Character>(nameof(MentorSpirits))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(CharacterGrammaticGender),
                        new DependencyGraphNode<string, Character>(nameof(Gender))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(FirstMentorSpiritDisplayName),
                        new DependencyGraphNode<string, Character>(nameof(MentorSpirits))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(FirstMentorSpiritDisplayInformation),
                        new DependencyGraphNode<string, Character>(nameof(MentorSpirits))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(LimitPhysicalToolTip),
                        new DependencyGraphNode<string, Character>(nameof(LimitPhysical),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(LimitMentalToolTip),
                        new DependencyGraphNode<string, Character>(nameof(LimitMental),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(LimitSocialToolTip),
                        new DependencyGraphNode<string, Character>(nameof(LimitSocial),
                            new DependencyGraphNode<string, Character>(nameof(HomeNode))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(LimitAstralToolTip),
                        new DependencyGraphNode<string, Character>(nameof(LimitAstral),
                            new DependencyGraphNode<string, Character>(nameof(LimitMental)),
                            new DependencyGraphNode<string, Character>(nameof(LimitSocial))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayMovement),
                        new DependencyGraphNode<string, Character>(nameof(GetMovement),
                            new DependencyGraphNode<string, Character>(nameof(Movement)),
                            new DependencyGraphNode<string, Character>(nameof(CalculatedMovement),
                                new DependencyGraphNode<string, Character>(nameof(WalkingRate),
                                    new DependencyGraphNode<string, Character>(nameof(CurrentWalkingRateString),
                                        new DependencyGraphNode<string, Character>(nameof(WalkString),
                                            x => x.AttributeSection.AttributeCategory ==
                                                 CharacterAttrib.AttributeCategory.Standard),
                                        new DependencyGraphNode<string, Character>(nameof(WalkAltString),
                                            x => x.AttributeSection.AttributeCategory !=
                                                 CharacterAttrib.AttributeCategory.Standard)
                                    )
                                ),
                                new DependencyGraphNode<string, Character>(nameof(RunningRate),
                                    new DependencyGraphNode<string, Character>(nameof(CurrentRunningRateString),
                                        new DependencyGraphNode<string, Character>(nameof(RunString),
                                            x => x.AttributeSection.AttributeCategory ==
                                                 CharacterAttrib.AttributeCategory.Standard),
                                        new DependencyGraphNode<string, Character>(nameof(RunAltString),
                                            x => x.AttributeSection.AttributeCategory !=
                                                 CharacterAttrib.AttributeCategory.Standard)
                                    )
                                ),
                                new DependencyGraphNode<string, Character>(nameof(SprintingRate),
                                    new DependencyGraphNode<string, Character>(nameof(CurrentSprintingRateString),
                                        new DependencyGraphNode<string, Character>(nameof(SprintString),
                                            x => x.AttributeSection.AttributeCategory ==
                                                 CharacterAttrib.AttributeCategory.Standard),
                                        new DependencyGraphNode<string, Character>(nameof(SprintAltString),
                                            x => x.AttributeSection.AttributeCategory !=
                                                 CharacterAttrib.AttributeCategory.Standard)
                                    )
                                )
                            )
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplaySwim),
                        new DependencyGraphNode<string, Character>(nameof(GetSwim),
                            new DependencyGraphNode<string, Character>(nameof(Movement)),
                            new DependencyGraphNode<string, Character>(nameof(CalculatedMovement))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayFly),
                        new DependencyGraphNode<string, Character>(nameof(GetFly),
                            new DependencyGraphNode<string, Character>(nameof(Movement)),
                            new DependencyGraphNode<string, Character>(nameof(CalculatedMovement))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayNegativeQualityKarma),
                        new DependencyGraphNode<string, Character>(nameof(NegativeQualityKarma),
                            new DependencyGraphNode<string, Character>(nameof(EnemyKarma)),
                            new DependencyGraphNode<string, Character>(nameof(Contacts)),
                            new DependencyGraphNode<string, Character>(nameof(Qualities))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(NegativeQualityLimitKarma),
                            new DependencyGraphNode<string, Character>(nameof(EnemyKarma)),
                            new DependencyGraphNode<string, Character>(nameof(Contacts)),
                            new DependencyGraphNode<string, Character>(nameof(Qualities))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayPositiveQualityKarma),
                        new DependencyGraphNode<string, Character>(nameof(PositiveQualityLimitKarma),
                            new DependencyGraphNode<string, Character>(nameof(Contacts)),
                            new DependencyGraphNode<string, Character>(nameof(Qualities))
                        ),
                        new DependencyGraphNode<string, Character>(nameof(PositiveQualityKarma),
                            new DependencyGraphNode<string, Character>(nameof(Contacts)),
                            new DependencyGraphNode<string, Character>(nameof(Qualities))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(DisplayMetagenicQualityKarma),
                        new DependencyGraphNode<string, Character>(nameof(MetagenicPositiveQualityKarma),
                        new DependencyGraphNode<string, Character>(nameof(MetagenicNegativeQualityKarma),
                            new DependencyGraphNode<string, Character>(nameof(IsChangeling)),
                            new DependencyGraphNode<string, Character>(nameof(Qualities))
                        ))
                    ),
                    new DependencyGraphNode<string, Character>(nameof(AstralReputationTooltip),
                        new DependencyGraphNode<string, Character>(nameof(TotalAstralReputation),
                            new DependencyGraphNode<string, Character>(nameof(AstralReputation))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(WildReputationTooltip),
                        new DependencyGraphNode<string, Character>(nameof(TotalWildReputation),
                            new DependencyGraphNode<string, Character>(nameof(WildReputation))
                        )
                    ),
                    new DependencyGraphNode<string, Character>(nameof(EdgeRemainingString),
                        new DependencyGraphNode<string, Character>(nameof(EdgeRemaining),
                            new DependencyGraphNode<string, Character>(nameof(EdgeUsed))
                        )
                    )
                );
        #endregion

        [NotifyPropertyChangedInvocator]
        public void OnPropertyChanged([CallerMemberName] string strPropertyName = null)
        {
            this.OnMultiplePropertyChanged(strPropertyName);
        }

        public void OnMultiplePropertyChanged(IReadOnlyCollection<string> lstPropertyNames)
        {
            using (EnterReadLock.Enter(LockObject))
            {
                HashSet<string> setNamesOfChangedProperties = null;
                try
                {
                    foreach (string strPropertyName in lstPropertyNames)
                    {
                        if (setNamesOfChangedProperties == null)
                            setNamesOfChangedProperties
                                = s_CharacterDependencyGraph.GetWithAllDependents(this, strPropertyName, true);
                        else
                        {
                            foreach (string strLoopChangedProperty in s_CharacterDependencyGraph
                                         .GetWithAllDependentsEnumerable(
                                             this, strPropertyName))
                                setNamesOfChangedProperties.Add(strLoopChangedProperty);
                        }
                    }

                    if (setNamesOfChangedProperties == null || setNamesOfChangedProperties.Count == 0)
                        return;

                    using (LockObject.EnterWriteLock())
                    {
                        if (setNamesOfChangedProperties.Contains(nameof(CharacterGrammaticGender)))
                        {
                            _strCachedCharacterGrammaticGender = string.Empty;
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(TotalStartingNuyen)))
                        {
                            _decCachedTotalStartingNuyen = decimal.MinValue;
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(ContactPoints)))
                        {
                            _intCachedContactPoints = int.MinValue;
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(BaseCarryLimit)))
                        {
                            _decCachedBaseCarryLimit = decimal.MinValue;
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(BaseLiftLimit)))
                        {
                            _decCachedBaseLiftLimit = decimal.MinValue;
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(EncumbranceInterval)))
                        {
                            _decCachedEncumbranceInterval = decimal.MinValue;
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(TotalArmorRating)))
                        {
                            _intCachedTotalArmorRating = int.MinValue;
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(TotalFireArmorRating)))
                        {
                            _intCachedTotalFireArmorRating = int.MinValue;
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(TotalColdArmorRating)))
                        {
                            _intCachedTotalColdArmorRating = int.MinValue;
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(TotalElectricityArmorRating)))
                        {
                            _intCachedTotalElectricityArmorRating = int.MinValue;
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(TotalAcidArmorRating)))
                        {
                            _intCachedTotalAcidArmorRating = int.MinValue;
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(TotalFallingArmorRating)))
                        {
                            _intCachedTotalFallingArmorRating = int.MinValue;
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(TrustFund)))
                        {
                            _intCachedTrustFund = int.MinValue;
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(RestrictedGear)))
                        {
                            _intCachedRestrictedGear = int.MinValue;
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(TotalCarriedWeight)))
                        {
                            _decCachedTotalCarriedWeight = decimal.MinValue;
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(DealerConnectionDiscount)))
                        {
                            RefreshDealerConnectionDiscounts();
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(BlackMarketDiscount)))
                        {
                            RefreshBlackMarketDiscounts();
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(PowerPointsUsed)))
                        {
                            _decCachedPowerPointsUsed = decimal.MinValue;
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(CyberwareEssence)))
                        {
                            _decCachedCyberwareEssence = decimal.MinValue;
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(BiowareEssence)))
                        {
                            _decCachedPrototypeTranshumanEssenceUsed = decimal.MinValue;
                            _decCachedBiowareEssence = decimal.MinValue;
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(EssenceHole)))
                        {
                            _decCachedEssenceHole = decimal.MinValue;
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(PrototypeTranshumanEssenceUsed)))
                        {
                            _decCachedBiowareEssence = decimal.MinValue;
                            _decCachedPrototypeTranshumanEssenceUsed = decimal.MinValue;
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(CareerNuyen)))
                        {
                            _decCachedCareerNuyen = decimal.MinValue;
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(CareerKarma)))
                        {
                            _intCachedCareerKarma = int.MinValue;
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(BoundSpiritLimit)))
                        {
                            _intBoundSpiritLimit = int.MinValue;
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(RegisteredSpriteLimit)))
                        {
                            _intRegisteredSpriteLimit = int.MinValue;
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(InitiationEnabled)))
                        {
                            _intCachedInitiationEnabled = int.MinValue;
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(RedlinerBonus)))
                        {
                            _intCachedRedlinerBonus = int.MinValue;
                            RefreshRedlinerImprovements();
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(Essence)))
                        {
                            ResetCachedEssence();
                            RefreshEssenceLossImprovements();
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(ArmorEncumbrance)))
                        {
                            RefreshArmorEncumbrance();
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(WoundModifier)))
                        {
                            RefreshWoundPenalties();
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(SustainingPenalty)))
                        {
                            RefreshSustainingPenalties();
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(EnemyKarma)))
                        {
                            _intCachedEnemyKarma = int.MinValue;
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(Qualities)))
                        {
                            _intCachedNegativeQualities = int.MinValue;
                            _intCachedNegativeQualityLimitKarma = int.MinValue;
                            _intCachedPositiveQualityLimitKarma = int.MinValue;
                            _intCachedPositiveQualities = int.MinValue;
                            _intCachedMetagenicNegativeQualities = int.MinValue;
                            _intCachedMetagenicPositiveQualities = int.MinValue;
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(MetagenicLimit)))
                        {
                            _intCachedMetagenicNegativeQualities = int.MinValue;
                            _intCachedMetagenicPositiveQualities = int.MinValue;
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(TotalAstralReputation)))
                            RefreshAstralReputationImprovements();
                    }

                    Utils.RunOnMainThread(() =>
                    {
                        if (PropertyChanged != null)
                        {
                            foreach (string strPropertyToChange in setNamesOfChangedProperties)
                            {
                                PropertyChanged.Invoke(this, new PropertyChangedEventArgs(strPropertyToChange));
                            }
                        }
                    });

                    if (!Created)
                    {
                        // If in create mode, update the Force for Spirits and Sprites (equal to Magician MAG Rating or RES Rating).
                        if (setNamesOfChangedProperties.Contains(nameof(MaxSpriteLevel)))
                        {
                            using (LockObject.EnterWriteLock())
                            {
                                foreach (Spirit objSpirit in Spirits)
                                {
                                    if (objSpirit.EntityType != SpiritType.Spirit)
                                        objSpirit.Force = MaxSpriteLevel;
                                }
                            }
                        }

                        if (setNamesOfChangedProperties.Contains(nameof(MaxSpiritForce)))
                        {
                            using (LockObject.EnterWriteLock())
                            {
                                foreach (Spirit objSpirit in Spirits)
                                {
                                    if (objSpirit.EntityType == SpiritType.Spirit)
                                        objSpirit.Force = MaxSpiritForce;
                                }
                            }
                        }
                    }
                }
                finally
                {
                    if (setNamesOfChangedProperties != null)
                        Utils.StringHashSetPool.Return(setNamesOfChangedProperties);
                }
            }

            if (Program.MainForm == null || IsLoading)
                return;
            foreach(Character objLoopOpenCharacter in Program.OpenCharacters)
            {
                if(objLoopOpenCharacter != this && objLoopOpenCharacter.LinkedCharacters.Contains(this))
                {
                    foreach(Spirit objSpirit in objLoopOpenCharacter.Spirits)
                    {
                        if(objSpirit.LinkedCharacter == this)
                        {
                            objSpirit.OnPropertyChanged(nameof(Spirit.LinkedCharacter));
                        }
                    }

                    foreach(Contact objContact in objLoopOpenCharacter.Contacts)
                    {
                        if(objContact.LinkedCharacter == this)
                        {
                            objContact.OnPropertyChanged(nameof(Contact.LinkedCharacter));
                        }
                    }
                }
            }
        }

        #region Hero Lab Importing
        public static readonly ReadOnlyCollection<string> HeroLabPluginNodeNames = Array.AsReadOnly(new[]
            {"modifications", "accessories", "ammunition", "programs", "othergear"});

        /// <summary>
        /// Load the Character from an XML file.
        /// </summary>
        public bool LoadFromHeroLabFile(string strPorFile, string strCharacterId, string strSettingsKey = "")
        {
            return LoadFromHeroLabFileCoreAsync(true, strPorFile, strCharacterId, strSettingsKey).ConfigureAwait(false).GetAwaiter().GetResult();
        }

        /// <summary>
        /// Load the Character from an XML file.
        /// </summary>
        public Task<bool> LoadFromHeroLabFileAsync(string strPorFile, string strCharacterId, string strSettingsKey = "")
        {
            return LoadFromHeroLabFileCoreAsync(false, strPorFile, strCharacterId, strSettingsKey);
        }

        /// <summary>
        /// Load the Character from an XML file.
        /// </summary>
        public async Task<bool> LoadFromHeroLabFileCoreAsync(bool blnSync, string strPorFile, string strCharacterId, string strSettingsKey = "", CancellationToken token = default)
        {
            if(!File.Exists(strPorFile))
                return false;

            IDisposable objLocker = null;
            IAsyncDisposable objLockerAsync = null;
            if (blnSync)
                // ReSharper disable once MethodHasAsyncOverload
                objLocker = LockObject.EnterWriteLock();
            else
                objLockerAsync = await LockObject.EnterWriteLockAsync(token);
            try
            {
                Dictionary<string, Bitmap> dicImages = new Dictionary<string, Bitmap>(1);
                XPathNavigator xmlStatBlockDocument = null;
                XPathNavigator xmlLeadsDocument = null;
                List<string> lstTextStatBlockLines = null;
                using (CustomActivity op_load = blnSync
                           // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                           ? Timekeeper.StartSyncron("LoadFromHeroLabFile", null,
                                                     CustomActivity.OperationType
                                                                   .DependencyOperation, strPorFile)
                           : await Timekeeper.StartSyncronAsync("LoadFromHeroLabFile", null,
                                                     CustomActivity.OperationType
                                                                   .DependencyOperation, strPorFile, token: token))
                {
                    try
                    {
                        op_load.MyDependencyTelemetry.Type = "loadHeroLab";
                        op_load.MyDependencyTelemetry.Target = strPorFile;

                        try
                        {
                            string strLeadsName = string.Empty;
                            using (ZipArchive zipArchive = ZipFile.Open(strPorFile, ZipArchiveMode.Read,
                                                                        Encoding.GetEncoding(850)))
                            {
                                foreach (ZipArchiveEntry entry in zipArchive.Entries)
                                {
                                    string strEntryFullName = entry.FullName;
                                    string strKey = Path.GetFileName(strEntryFullName);
                                    if ((xmlStatBlockDocument == null && strEntryFullName.StartsWith(
                                            "statblocks_xml",
                                            StringComparison.OrdinalIgnoreCase)) ||
                                        (string.IsNullOrEmpty(strLeadsName) &&
                                         strEntryFullName.EndsWith("portfolio.xml",
                                                                   StringComparison.OrdinalIgnoreCase)) ||
                                        lstTextStatBlockLines == null && strEntryFullName.StartsWith(
                                            "statblocks_txt",
                                            StringComparison.OrdinalIgnoreCase))
                                    {
                                        if (strEntryFullName.EndsWith(".xml", StringComparison.OrdinalIgnoreCase))
                                        {
                                            try
                                            {
                                                using (StreamReader objStreamReader =
                                                       new StreamReader(entry.Open(), true))
                                                {
                                                    using (XmlReader objReader = XmlReader.Create(objStreamReader,
                                                               GlobalSettings.SafeXmlReaderSettings))
                                                    {
                                                        XPathDocument xmlSourceDoc = new XPathDocument(objReader);
                                                        XPathNavigator objDummy = xmlSourceDoc.CreateNavigator();
                                                        if (strEntryFullName.StartsWith("statblocks_xml",
                                                                StringComparison.Ordinal))
                                                        {
                                                            if (objDummy.SelectSingleNode(
                                                                    "/document/public/character[@name = " +
                                                                    strCharacterId.CleanXPath() + ']') != null)
                                                                xmlStatBlockDocument = objDummy;
                                                        }
                                                        else
                                                        {
                                                            strLeadsName = objDummy.SelectSingleNode(
                                                                "/document/portfolio/hero[@heroname = " +
                                                                strCharacterId.CleanXPath() + "]/@leadfile")?.Value;
                                                        }
                                                    }
                                                }
                                            }
                                            // If we run into any problems loading the character xml files, fail out early.
                                            catch (IOException e)
                                            {
                                                Log.Info(e);
                                                Utils.BreakIfDebug();
                                            }
                                            catch (XmlException e)
                                            {
                                                Log.Info(e);
                                                Utils.BreakIfDebug();
                                            }
                                        }
                                        else if (strEntryFullName.EndsWith(".txt",
                                                                           StringComparison.OrdinalIgnoreCase)
                                                 && !strKey.Contains('.'))
                                        {
                                            lstTextStatBlockLines = new List<string>(30);

                                            using (StreamReader objReader = File.OpenText(strEntryFullName))
                                            {
                                                string strLine;
                                                while ((strLine = blnSync
                                                           // ReSharper disable once MethodHasAsyncOverload
                                                           ? objReader.ReadLine()
                                                           : await objReader.ReadLineAsync()) != null)
                                                {
                                                    // Trim away the newlines and empty spaces at the beginning and end of lines
                                                    strLine = strLine.Trim('\n', '\r', ' ').Trim();

                                                    lstTextStatBlockLines.Add(strLine);
                                                }
                                            }
                                        }
                                    }
                                    else if (strEntryFullName.StartsWith("images", StringComparison.Ordinal) &&
                                             strEntryFullName.Contains('.'))
                                    {
                                        using (Bitmap bmpMugshot = new Bitmap(entry.Open(), true))
                                        {
                                            Bitmap bmpNewMugshot =
                                                bmpMugshot.PixelFormat == PixelFormat.Format32bppPArgb
                                                    ? bmpMugshot
                                                        .Clone() as Bitmap // Clone makes sure file handle is closed
                                                    : bmpMugshot.ConvertPixelFormat(PixelFormat.Format32bppPArgb);
                                            if (dicImages.TryGetValue(strKey, out Bitmap bmpExistingMugshot))
                                            {
                                                bmpExistingMugshot.Dispose();
                                                dicImages[strKey] = bmpNewMugshot;
                                            }
                                            else
                                                dicImages.Add(strKey, bmpNewMugshot);
                                        }
                                    }
                                }

                                if (!string.IsNullOrEmpty(strLeadsName))
                                {
                                    // Need a second sweep for the Leads file
                                    foreach (ZipArchiveEntry entry in zipArchive.Entries)
                                    {
                                        string strEntryFullName = entry.FullName;
                                        if (strEntryFullName.EndsWith(strLeadsName,
                                                                      StringComparison.OrdinalIgnoreCase))
                                        {
                                            try
                                            {
                                                using (StreamReader objStreamReader =
                                                       new StreamReader(entry.Open(), true))
                                                {
                                                    using (XmlReader objReader = XmlReader.Create(objStreamReader,
                                                               GlobalSettings.SafeXmlReaderSettings))
                                                    {
                                                        XPathDocument xmlSourceDoc = new XPathDocument(objReader);
                                                        xmlLeadsDocument = xmlSourceDoc.CreateNavigator();
                                                    }
                                                }
                                            }
                                            // If we run into any problems loading the character xml files, fail out early.
                                            catch (IOException)
                                            {
                                                continue;
                                            }
                                            catch (XmlException)
                                            {
                                                continue;
                                            }

                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        catch (IOException ex)
                        {
                            if (op_load != null)
                            {
                                op_load.SetSuccess(false);
                                op_load.AddBaggage(ex.GetType().Name, ex.Message);
                                Log.Error(ex);
                            }

                            Program.ShowMessageBox(
                                string.Format(GlobalSettings.CultureInfo,
                                              blnSync
                                                  // ReSharper disable once MethodHasAsyncOverload
                                                  ? LanguageManager.GetString("Message_FailedLoad")
                                                  : await LanguageManager.GetStringAsync("Message_FailedLoad", token: token),
                                              ex.Message),
                                blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? LanguageManager.GetString("MessageTitle_FailedLoad")
                                    : await LanguageManager.GetStringAsync("MessageTitle_FailedLoad", token: token),
                                MessageBoxButtons.OK, MessageBoxIcon.Error);
                            return false;
                        }
                        catch (NotSupportedException ex)
                        {
                            if (op_load != null)
                            {
                                op_load.SetSuccess(false);
                                op_load.AddBaggage(ex.GetType().Name, ex.Message);
                                Log.Error(ex);
                            }

                            Program.ShowMessageBox(
                                string.Format(GlobalSettings.CultureInfo,
                                              blnSync
                                                  // ReSharper disable once MethodHasAsyncOverload
                                                  ? LanguageManager.GetString("Message_FailedLoad")
                                                  : await LanguageManager.GetStringAsync("Message_FailedLoad", token: token),
                                              ex.Message),
                                blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? LanguageManager.GetString("MessageTitle_FailedLoad")
                                    : await LanguageManager.GetStringAsync("MessageTitle_FailedLoad", token: token),
                                MessageBoxButtons.OK, MessageBoxIcon.Error);
                            return false;
                        }
                        catch (UnauthorizedAccessException ex)
                        {
                            if (op_load != null)
                            {
                                op_load.SetSuccess(false);
                                op_load.AddBaggage(ex.GetType().Name, ex.Message);
                                Log.Error(ex);
                            }

                            Program.ShowMessageBox(
                                string.Format(GlobalSettings.CultureInfo,
                                              blnSync
                                                  // ReSharper disable once MethodHasAsyncOverload
                                                  ? LanguageManager.GetString("Message_FailedLoad")
                                                  : await LanguageManager.GetStringAsync("Message_FailedLoad", token: token),
                                              ex.Message),
                                blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? LanguageManager.GetString("MessageTitle_FailedLoad")
                                    : await LanguageManager.GetStringAsync("MessageTitle_FailedLoad", token: token),
                                MessageBoxButtons.OK, MessageBoxIcon.Error);
                            return false;
                        }

                        if (xmlLeadsDocument == null || xmlStatBlockDocument == null)
                        {
                            return false;
                        }

                        IsLoading = true;
                        try
                        {
                            XPathNavigator xmlStatBlockBaseNode;
                            XPathNavigator xmlLeadsBaseNode;

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_misc", op_load)
                                       : await Timekeeper.StartSyncronAsync("load_char_misc", op_load, token: token))
                            {
                                _dateFileLastWriteTime = File.GetLastWriteTimeUtc(strPorFile);

                                xmlStatBlockBaseNode =
                                    xmlStatBlockDocument.SelectSingleNode("/document/public/character[@name = " +
                                                                          strCharacterId.CleanXPath() + ']');
                                xmlLeadsBaseNode =
                                    xmlLeadsDocument.SelectSingleNode("/document/hero[@heroname = " +
                                                                      strCharacterId.CleanXPath() +
                                                                      "]");

                                _blnCreated =
                                    (xmlStatBlockBaseNode.SelectSingleNode("karma/@total")?.Value ?? "0") !=
                                    "0";
                                if (!_blnCreated)
                                {
                                    XPathNodeIterator xmlJournalEntries = blnSync
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        ? xmlStatBlockBaseNode.SelectAndCacheExpression("journals/journal")
                                        : await xmlStatBlockBaseNode.SelectAndCacheExpressionAsync("journals/journal", token);
                                    if (xmlJournalEntries.Count > 1)
                                    {
                                        _blnCreated = true;
                                    }
                                    else if (xmlJournalEntries.Count == 1 &&
                                             xmlJournalEntries.Current.SelectSingleNode("@name")?.Value != "Title")
                                    {
                                        _blnCreated = true;
                                    }
                                }

                                if (blnSync)
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ResetCharacter(token);
                                else
                                    await ResetCharacterAsync(token);

                                // Get the name of the settings file in use if possible.
                                if (!string.IsNullOrEmpty(strSettingsKey))
                                {
                                    if (blnSync
                                            ? !SettingsManager.LoadedCharacterSettings.ContainsKey(strSettingsKey)
                                            : !await (await SettingsManager.GetLoadedCharacterSettingsAsync(token)).ContainsKeyAsync(strSettingsKey, token))
                                        return false;

                                    if (blnSync)
                                        SettingsKey = strSettingsKey;
                                    else
                                        await SetSettingsKeyAsync(strSettingsKey, token);
                                }

                                // Metatype information.
                                string strRaceString = xmlStatBlockBaseNode.SelectSingleNode("race/@name")?.Value;
                                if (!string.IsNullOrEmpty(strRaceString))
                                {
                                    if (strRaceString == "Metasapient")
                                        strRaceString = "A.I.";
                                    foreach (XPathNavigator xmlMetatype in (blnSync
                                                 // ReSharper disable once MethodHasAsyncOverload
                                                 ? LoadDataXPath("metatypes.xml")
                                                     // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                     .SelectAndCacheExpression("/chummer/metatypes/metatype")
                                                 : await (await LoadDataXPathAsync("metatypes.xml", token: token))
                                                     .SelectAndCacheExpressionAsync("/chummer/metatypes/metatype", token: token)))
                                    {
                                        string strMetatypeName = xmlMetatype.SelectSingleNode("name").Value;
                                        if (strMetatypeName == strRaceString)
                                        {
                                            _strMetatype = strMetatypeName;
                                            _strMetatypeCategory = xmlMetatype.SelectSingleNode("category").Value;
                                            _strMetavariant = "None";

                                            XPathNavigator objRunNode = xmlMetatype.SelectSingleNode("run");
                                            XPathNavigator objWalkNode = xmlMetatype.SelectSingleNode("walk");
                                            XPathNavigator objSprintNode = xmlMetatype.SelectSingleNode("sprint");

                                            _strMovement = xmlMetatype.SelectSingleNode("movement")?.Value ??
                                                           string.Empty;
                                            _strRun = objRunNode?.Value ?? string.Empty;
                                            _strWalk = objWalkNode?.Value ?? string.Empty;
                                            _strSprint = objSprintNode?.Value ?? string.Empty;

                                            objRunNode = objRunNode?.SelectSingleNode("@alt");
                                            objWalkNode = objWalkNode?.SelectSingleNode("@alt");
                                            objSprintNode = objSprintNode?.SelectSingleNode("@alt");
                                            _strRunAlt = objRunNode?.Value ?? string.Empty;
                                            _strWalkAlt = objWalkNode?.Value ?? string.Empty;
                                            _strSprintAlt = objSprintNode?.Value ?? string.Empty;
                                            break;
                                        }

                                        foreach (XPathNavigator xmlMetavariant in xmlMetatype.Select(
                                                     "metavariants/metavariant"))
                                        {
                                            string strMetavariantName =
                                                xmlMetavariant.SelectSingleNode("name").Value;
                                            if (strMetavariantName == strRaceString)
                                            {
                                                _strMetatype = strMetatypeName;
                                                _strMetatypeCategory =
                                                    xmlMetatype.SelectSingleNode("category").Value;
                                                _strMetavariant = strMetavariantName;

                                                XPathNavigator objRunNode =
                                                    xmlMetavariant?.SelectSingleNode("run") ??
                                                    xmlMetatype?.SelectSingleNode("run");
                                                XPathNavigator objWalkNode =
                                                    xmlMetavariant?.SelectSingleNode("walk") ??
                                                    xmlMetatype?.SelectSingleNode("walk");
                                                XPathNavigator objSprintNode =
                                                    xmlMetavariant?.SelectSingleNode("sprint") ??
                                                    xmlMetatype?.SelectSingleNode("sprint");

                                                _strMovement =
                                                    xmlMetavariant?.SelectSingleNode("movement")?.Value ??
                                                    xmlMetatype?.SelectSingleNode("movement")?.Value ??
                                                    string.Empty;
                                                _strRun = objRunNode?.Value ?? string.Empty;
                                                _strWalk = objWalkNode?.Value ?? string.Empty;
                                                _strSprint = objSprintNode?.Value ?? string.Empty;

                                                objRunNode = objRunNode?.SelectSingleNode("@alt");
                                                objWalkNode = objWalkNode?.SelectSingleNode("@alt");
                                                objSprintNode = objSprintNode?.SelectSingleNode("@alt");
                                                _strRunAlt = objRunNode?.Value ?? string.Empty;
                                                _strWalkAlt = objWalkNode?.Value ?? string.Empty;
                                                _strSprintAlt = objSprintNode?.Value ?? string.Empty;
                                                break;
                                            }
                                        }
                                    }
                                }

                                // General character information.
                                int intAsIndex = strCharacterId.IndexOf(" as ", StringComparison.Ordinal);
                                if (intAsIndex != -1)
                                {
                                    _strName = strCharacterId.Substring(0, intAsIndex);
                                    _strAlias = strCharacterId.Substring(intAsIndex).TrimStart(" as ").Trim('\'');
                                }
                                else
                                {
                                    _strAlias = strCharacterId;
                                }

                                XPathNavigator xmlPersonalNode = xmlStatBlockBaseNode.SelectSingleNode("personal");
                                if (xmlPersonalNode != null)
                                {
                                    _strBackground = xmlPersonalNode.SelectSingleNode("description")?.Value;
                                    _strHeight = xmlPersonalNode.SelectSingleNode("charheight/@text")?.Value;
                                    _strWeight = xmlPersonalNode.SelectSingleNode("charweight/@text")?.Value;
                                    if (xmlPersonalNode.HasAttributes)
                                    {
                                        _strGender = xmlPersonalNode.SelectSingleNode("@gender")?.Value;
                                        _strAge = xmlPersonalNode.SelectSingleNode("@age")?.Value;
                                        _strHair = xmlPersonalNode.SelectSingleNode("@hair")?.Value;
                                        _strEyes = xmlPersonalNode.SelectSingleNode("@eyes")?.Value;
                                        _strSkin = xmlPersonalNode.SelectSingleNode("@skin")?.Value;
                                    }
                                }

                                _strPlayerName = xmlStatBlockBaseNode.SelectSingleNode("@playername")?.Value;

                                foreach (XPathNavigator xmlImageFileNameNode in xmlStatBlockBaseNode.Select(
                                             "images/image/@filename"))
                                {
                                    if (dicImages.TryGetValue(xmlImageFileNameNode.Value, out Bitmap objOutput))
                                    {
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstMugshots.Add(objOutput);
                                        else
                                            await _lstMugshots.AddAsync(objOutput, token);
                                    }
                                }

                                if (_lstMugshots.Count > 0)
                                    _intMainMugshotIndex = 0;

                                if (string.IsNullOrEmpty(strSettingsKey))
                                {
                                    string strSettingsSummary =
                                        xmlStatBlockBaseNode.SelectSingleNode("settings/@summary")?.Value;
                                    if (!string.IsNullOrEmpty(strSettingsSummary))
                                    {
                                        int intCharCreationSystemsIndex =
                                            strSettingsSummary.IndexOf("Character Creation Systems:",
                                                                       StringComparison.OrdinalIgnoreCase);
                                        if (intCharCreationSystemsIndex != -1)
                                        {
                                            int intSemicolonIndex
                                                = strSettingsSummary.IndexOf(';', intCharCreationSystemsIndex);
                                            if (intCharCreationSystemsIndex + 28 <= intSemicolonIndex)
                                            {
                                                string strHeroLabSettingsName = strSettingsSummary.Substring(
                                                        intCharCreationSystemsIndex + 28,
                                                        strSettingsSummary.IndexOf(';', intCharCreationSystemsIndex)
                                                        - 28 - intCharCreationSystemsIndex)
                                                    .Trim();
                                                if (strHeroLabSettingsName == "Established Runners")
                                                    strHeroLabSettingsName = "Standard";

                                                if (strHeroLabSettingsName == "Standard")
                                                {
                                                    bool blnDoFullHouse = false;
                                                    int intSourcebooksIndex
                                                        = strSettingsSummary.IndexOf(
                                                            "Core Rulebooks:", StringComparison.OrdinalIgnoreCase);
                                                    if (intSourcebooksIndex != -1)
                                                    {
                                                        intSemicolonIndex
                                                            = strSettingsSummary.IndexOf(';', intSourcebooksIndex);
                                                        if (intSourcebooksIndex + 16 < intSemicolonIndex)
                                                        {
                                                            blnDoFullHouse
                                                                = true; // We probably have multiple books enabled, so use Full House instead
                                                        }
                                                    }

                                                    bool blnIsKarmaBased = xmlStatBlockBaseNode
                                                                           .SelectSingleNode("creation/bp/@total")
                                                                           ?.ValueAsInt > 100;
                                                    if (blnDoFullHouse)
                                                    {
                                                        strHeroLabSettingsName = blnIsKarmaBased
                                                            ? "Full House (Point Buy)"
                                                            : "Full House";
                                                    }
                                                    else if (blnIsKarmaBased)
                                                        strHeroLabSettingsName = "Point Buy";
                                                }

                                                CharacterSettings objHeroLabSettings =
                                                    SettingsManager.LoadedCharacterSettings.Values.FirstOrDefault(
                                                        x => x.Name == strHeroLabSettingsName);
                                                if (objHeroLabSettings != null)
                                                {
                                                    strSettingsKey = objHeroLabSettings.DictionaryKey;
                                                    if (blnSync)
                                                        SettingsKey = strSettingsKey;
                                                    else
                                                        await SetSettingsKeyAsync(strSettingsKey, token: token);
                                                }
                                            }
                                        }
                                    }
                                }

                                if (string.IsNullOrEmpty(strSettingsKey))
                                {
                                    if (Program.ShowMessageBox(
                                            string.Format(GlobalSettings.CultureInfo,
                                                          blnSync
                                                              // ReSharper disable once MethodHasAsyncOverload
                                                              ? LanguageManager.GetString(
                                                                  "Message_MissingGameplayOption")
                                                              : await LanguageManager
                                                                  .GetStringAsync(
                                                                      "Message_MissingGameplayOption", token: token),
                                                          blnSync ? SettingsKey : await GetSettingsKeyAsync(token)),
                                            blnSync
                                                // ReSharper disable once MethodHasAsyncOverload
                                                ? LanguageManager.GetString(
                                                    "Message_MissingGameplayOption_Title")
                                                : await LanguageManager.GetStringAsync(
                                                    "Message_MissingGameplayOption_Title", token: token),
                                            MessageBoxButtons.OKCancel, MessageBoxIcon.Error)
                                        == DialogResult.OK)
                                    {
                                        if (blnSync)
                                        {
                                            // ReSharper disable MethodHasAsyncOverload
                                            // ReSharper disable MethodHasAsyncOverloadWithCancellation
                                            using (ThreadSafeForm<SelectBuildMethod> frmPickBP
                                                   = ThreadSafeForm<SelectBuildMethod>.Get(
                                                       () => new SelectBuildMethod(this, true)))
                                            {
                                                if (frmPickBP.ShowDialogSafe(this) != DialogResult.OK)
                                                    return false;
                                            }
                                            // ReSharper restore MethodHasAsyncOverloadWithCancellation
                                            // ReSharper restore MethodHasAsyncOverload
                                        }
                                        else
                                        {
                                            using (ThreadSafeForm<SelectBuildMethod> frmPickBP =
                                                   await ThreadSafeForm<SelectBuildMethod>.GetAsync(
                                                       () => new SelectBuildMethod(this, true), token))
                                            {
                                                if (await frmPickBP.ShowDialogSafeAsync(this, token) != DialogResult.OK)
                                                    return false;
                                            }
                                        }
                                    }
                                    else
                                        return false;
                                }

                                if (EffectiveBuildMethodUsesPriorityTables)
                                {
                                    if (strRaceString == "A.I.")
                                        _strPriorityTalent = "AI";
                                    XPathNavigator xmlPriorityTalentPick =
                                        xmlLeadsBaseNode.SelectSingleNode(
                                            "container/pick[starts-with(@thing, \"qu\") and @source = \"heritage\"]");
                                    if (xmlPriorityTalentPick != null)
                                    {
                                        switch (xmlPriorityTalentPick.SelectSingleNode("@thing")?.Value)
                                        {
                                            case "quAware":
                                                _strPriorityTalent = "Aware";
                                                break;
                                            case "quEnchanter":
                                                _strPriorityTalent = "Enchanter";
                                                break;
                                            case "quExplorer":
                                                _strPriorityTalent = "Explorer";
                                                break;
                                            case "quApprentice":
                                                _strPriorityTalent = "Apprentice";
                                                break;
                                            case "quAspectedMagician":
                                                _strPriorityTalent = "Aspected Magician";
                                                break;
                                            case "quAdept":
                                                _strPriorityTalent = "Adept";
                                                break;
                                            case "quMagician":
                                                _strPriorityTalent = "Magician";
                                                break;
                                            case "quMysticAdept":
                                                _strPriorityTalent = "Mystic Adept";
                                                break;
                                            case "quTechnoma":
                                                _strPriorityTalent = "Technomancer";
                                                break;
                                        }

                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstPrioritySkills.Clear();
                                        else
                                            await _lstPrioritySkills.ClearAsync(token);
                                        foreach (XPathNavigator xmlField in (blnSync
                                                     // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                     ? xmlPriorityTalentPick.SelectAndCacheExpression("field")
                                                     : await xmlPriorityTalentPick.SelectAndCacheExpressionAsync(
                                                         "field", token)))
                                        {
                                            string strInnerText = xmlField.Value;
                                            if (!string.IsNullOrEmpty(strInnerText))
                                            {
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    _lstPrioritySkills.Add(strInnerText);
                                                else
                                                    await _lstPrioritySkills.AddAsync(strInnerText, token);
                                            }
                                        }
                                    }

                                    if (blnSync)
                                    {
                                        // ReSharper disable MethodHasAsyncOverload
                                        // ReSharper disable MethodHasAsyncOverloadWithCancellation
                                        using (ThreadSafeForm<SelectMetatypePriority> frmSelectMetatype =
                                               ThreadSafeForm<SelectMetatypePriority>.Get(
                                                   () => new SelectMetatypePriority(this)))
                                        {
                                            if (frmSelectMetatype.ShowDialogSafe(this) != DialogResult.OK)
                                                return false;
                                        }
                                        // ReSharper restore MethodHasAsyncOverloadWithCancellation
                                        // ReSharper restore MethodHasAsyncOverload
                                    }
                                    else
                                    {
                                        using (ThreadSafeForm<SelectMetatypePriority> frmSelectMetatype =
                                               await ThreadSafeForm<SelectMetatypePriority>.GetAsync(
                                                   () => new SelectMetatypePriority(this), token))
                                        {
                                            if (await frmSelectMetatype.ShowDialogSafeAsync(this, token) != DialogResult.OK)
                                                return false;
                                        }
                                    }
                                }
                                else
                                {
                                    if (blnSync)
                                    {
                                        // ReSharper disable MethodHasAsyncOverload
                                        // ReSharper disable MethodHasAsyncOverloadWithCancellation
                                        using (ThreadSafeForm<SelectMetatypeKarma> frmSelectMetatype =
                                               ThreadSafeForm<SelectMetatypeKarma>.Get(
                                                   () => new SelectMetatypeKarma(this)))
                                        {
                                            if (frmSelectMetatype.ShowDialogSafe(this) != DialogResult.OK)
                                                return false;
                                        }
                                        // ReSharper restore MethodHasAsyncOverloadWithCancellation
                                        // ReSharper restore MethodHasAsyncOverload
                                    }
                                    else
                                    {
                                        using (ThreadSafeForm<SelectMetatypeKarma> frmSelectMetatype =
                                               await ThreadSafeForm<SelectMetatypeKarma>.GetAsync(
                                                   () => new SelectMetatypeKarma(this), token))
                                        {
                                            if (await frmSelectMetatype.ShowDialogSafeAsync(this, token: token) != DialogResult.OK)
                                                return false;
                                        }
                                    }
                                }

                                XPathNavigator xmlKarmaNode = xmlStatBlockBaseNode.SelectSingleNode("karma");
                                if (xmlKarmaNode != null)
                                {
                                    int.TryParse(xmlKarmaNode.SelectSingleNode("@left")?.Value, NumberStyles.Any,
                                                 GlobalSettings.InvariantCultureInfo, out _intKarma);
                                    int.TryParse(xmlKarmaNode.SelectSingleNode("@total")?.Value, NumberStyles.Any,
                                                 GlobalSettings.InvariantCultureInfo, out _intTotalKarma);
                                }

                                XPathNavigator xmlReputationsNode =
                                    xmlStatBlockBaseNode.SelectSingleNode("reputations");
                                if (xmlReputationsNode != null)
                                {
                                    int.TryParse(
                                        xmlReputationsNode
                                            .SelectSingleNode("reputation[@name = \"Street Cred\"]/@value")
                                            .Value,
                                        NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                        out _intStreetCred);
                                    int.TryParse(
                                        xmlReputationsNode
                                            .SelectSingleNode("reputation[@name = \"Notoriety\"]/@value")
                                            .Value,
                                        NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                        out _intNotoriety);
                                    int.TryParse(
                                        xmlReputationsNode
                                            .SelectSingleNode("reputation[@name = \"Public Awareness\"]/@value")
                                            .Value, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                        out _intPublicAwareness);
                                }

                                if (Created)
                                {
                                    decimal.TryParse(xmlStatBlockBaseNode.SelectSingleNode("cash/@total")?.Value,
                                                     NumberStyles.Any,
                                                     GlobalSettings.InvariantCultureInfo, out _decNuyen);
                                }

                                /* TODO: Initiation, Submersion Grades
                                objXmlCharacter.TryGetInt32FieldQuickly("initiategrade", ref _intInitiateGrade);
                                objXmlCharacter.TryGetInt32FieldQuickly("submersiongrade", ref _intSubmersionGrade);
                                */
                                //Timekeeper.Finish("load_char_misc");
                            }

                            List<Weapon> lstWeapons = new List<Weapon>(1);
                            List<Vehicle> lstVehicles = new List<Vehicle>(1);

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_quality", op_load)
                                       : await Timekeeper.StartSyncronAsync("load_char_quality", op_load, token: token))
                            {
                                string[] astrLevelLabels =
                                {
                                    " (0)",
                                    " (1)",
                                    " (2)",
                                    " (3)",
                                    " (4)",
                                    " (5)",
                                    " (6)",
                                    " (7)",
                                    " (8)",
                                    " (9)",
                                    " (10)",
                                    " (11)",
                                    " (12)",
                                    " (13)",
                                    " (14)",
                                    " (15)"
                                };
                                // Qualities
                                XmlDocument xmlQualitiesDocument = blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? LoadData("qualities.xml")
                                    : await LoadDataAsync("qualities.xml", token: token);
                                foreach (XPathNavigator xmlQualityToImport in xmlStatBlockBaseNode.Select(
                                             "qualities/positive/quality[traitcost/@bp != \"0\"]"))
                                {
                                    string strQualityName = xmlQualityToImport.SelectSingleNode("@name")?.Value;
                                    if (!string.IsNullOrEmpty(strQualityName))
                                    {
                                        int intDicepoolLabelIndex =
                                            strQualityName.LastIndexOf("dicepool", StringComparison.Ordinal);
                                        if (intDicepoolLabelIndex != -1)
                                        {
                                            int intCullIndex =
                                                strQualityName.LastIndexOf('(', intDicepoolLabelIndex);
                                            if (intCullIndex != -1)
                                                strQualityName = strQualityName.Substring(0, intCullIndex).Trim();
                                        }

                                        int intQuantity = 1;
                                        for (int i = 0; i < astrLevelLabels.Length; ++i)
                                        {
                                            string strLoopString = astrLevelLabels[i];
                                            if (strQualityName.EndsWith(strLoopString, StringComparison.Ordinal))
                                            {
                                                strQualityName = strQualityName.TrimEndOnce(strLoopString, true);
                                                intQuantity = i;
                                                break;
                                            }
                                        }

                                        string strForcedValue = string.Empty;
                                        XmlNode xmlQualityDataNode =
                                            xmlQualitiesDocument.SelectSingleNode(
                                                "/chummer/qualities/quality[name = " + strQualityName.CleanXPath() +
                                                "]");
                                        if (xmlQualityDataNode == null)
                                        {
                                            string[] astrOriginalNameSplit =
                                                strQualityName.Split(':', StringSplitOptions.RemoveEmptyEntries);
                                            if (astrOriginalNameSplit.Length > 1)
                                            {
                                                string strName = astrOriginalNameSplit[0].Trim();
                                                xmlQualityDataNode =
                                                    xmlQualitiesDocument.SelectSingleNode(
                                                        "/chummer/qualities/quality[name = " +
                                                        strName.CleanXPath() +
                                                        "]");
                                                if (xmlQualityDataNode != null)
                                                    strForcedValue = astrOriginalNameSplit[1].Trim();
                                            }
                                        }

                                        if (xmlQualityDataNode == null)
                                        {
                                            string[] astrOriginalNameSplit =
                                                strQualityName.Split(',', StringSplitOptions.RemoveEmptyEntries);
                                            if (astrOriginalNameSplit.Length > 1)
                                            {
                                                string strName = astrOriginalNameSplit[0].Trim();
                                                xmlQualityDataNode =
                                                    xmlQualitiesDocument.SelectSingleNode(
                                                        "/chummer/qualities/quality[name = " +
                                                        strName.CleanXPath() +
                                                        "]");
                                                if (xmlQualityDataNode != null)
                                                    strForcedValue = astrOriginalNameSplit[1].Trim();
                                            }
                                        }

                                        if (xmlQualityDataNode != null)
                                        {
                                            for (int i = 0; i < intQuantity; ++i)
                                            {
                                                Quality objQuality = new Quality(this);
                                                objQuality.Create(xmlQualityDataNode, QualitySource.Selected,
                                                                  lstWeapons,
                                                                  strForcedValue);
                                                objQuality.Notes =
                                                    xmlQualityToImport.SelectSingleNode("description")?.Value ??
                                                    string.Empty;
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    _lstQualities.Add(objQuality);
                                                else
                                                    await _lstQualities.AddAsync(objQuality, token);
                                            }
                                        }
                                    }
                                }

                                foreach (XPathNavigator xmlQualityToImport in xmlStatBlockBaseNode.Select(
                                             "qualities/negative/quality[traitcost/@bp != \"0\"]"))
                                {
                                    string strQualityName = xmlQualityToImport.SelectSingleNode("@name")?.Value;
                                    if (!string.IsNullOrEmpty(strQualityName))
                                    {
                                        int intDicepoolLabelIndex =
                                            strQualityName.LastIndexOf("dicepool", StringComparison.Ordinal);
                                        if (intDicepoolLabelIndex != -1)
                                        {
                                            int intCullIndex =
                                                strQualityName.LastIndexOf('(', intDicepoolLabelIndex);
                                            if (intCullIndex != -1)
                                                strQualityName = strQualityName.Substring(0, intCullIndex).Trim();
                                        }

                                        switch (strQualityName)
                                        {
                                            case "Reduced (hearing)":
                                                strQualityName = "Reduced Sense (Hearing)";
                                                break;
                                            case "Reduced (smell)":
                                                strQualityName = "Reduced Sense (Smell)";
                                                break;
                                            case "Reduced (taste)":
                                                strQualityName = "Reduced Sense (Taste)";
                                                break;
                                            case "Reduced (touch)":
                                                strQualityName = "Reduced Sense (Touch)";
                                                break;
                                            case "Reduced (sight)":
                                                strQualityName = "Reduced Sense (Sight)";
                                                break;
                                        }

                                        int intQuantity = 1;
                                        for (int i = 0; i < astrLevelLabels.Length; ++i)
                                        {
                                            string strLoopString = astrLevelLabels[i];
                                            if (strQualityName.EndsWith(strLoopString, StringComparison.Ordinal))
                                            {
                                                strQualityName = strQualityName.TrimEndOnce(strLoopString, true);
                                                intQuantity = i;
                                                break;
                                            }
                                        }

                                        string strForcedValue = string.Empty;
                                        XmlNode xmlQualityDataNode =
                                            xmlQualitiesDocument.SelectSingleNode(
                                                "/chummer/qualities/quality[name = " + strQualityName.CleanXPath() +
                                                "]");
                                        if (xmlQualityDataNode == null)
                                        {
                                            string[] astrOriginalNameSplit =
                                                strQualityName.Split(':', StringSplitOptions.RemoveEmptyEntries);
                                            if (astrOriginalNameSplit.Length > 1)
                                            {
                                                string strName = astrOriginalNameSplit[0].Trim();
                                                xmlQualityDataNode =
                                                    xmlQualitiesDocument.SelectSingleNode(
                                                        "/chummer/qualities/quality[name = " +
                                                        strName.CleanXPath() +
                                                        "]");
                                                if (xmlQualityDataNode != null)
                                                    strForcedValue = astrOriginalNameSplit[1].Trim();
                                            }
                                        }

                                        if (xmlQualityDataNode == null)
                                        {
                                            string[] astrOriginalNameSplit =
                                                strQualityName.Split(',', StringSplitOptions.RemoveEmptyEntries);
                                            if (astrOriginalNameSplit.Length > 1)
                                            {
                                                string strName = astrOriginalNameSplit[0].Trim();
                                                xmlQualityDataNode =
                                                    xmlQualitiesDocument.SelectSingleNode(
                                                        "/chummer/qualities/quality[name = " +
                                                        strName.CleanXPath() +
                                                        "]");
                                                if (xmlQualityDataNode != null)
                                                    strForcedValue = astrOriginalNameSplit[1].Trim();
                                            }
                                        }

                                        if (xmlQualityDataNode != null)
                                        {
                                            for (int i = 0; i < intQuantity; ++i)
                                            {
                                                Quality objQuality = new Quality(this);
                                                objQuality.Create(xmlQualityDataNode, QualitySource.Selected,
                                                                  lstWeapons,
                                                                  strForcedValue);
                                                objQuality.Notes =
                                                    xmlQualityToImport.SelectSingleNode("description")?.Value ??
                                                    string.Empty;
                                                if (blnSync)
                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                    _lstQualities.Add(objQuality);
                                                else
                                                    await _lstQualities.AddAsync(objQuality, token: token);
                                            }
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_quality");
                            }

                            AttributeSection.LoadFromHeroLab(xmlStatBlockBaseNode, op_load, token);
                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_misc2", op_load)
                                       : await Timekeeper.StartSyncronAsync("load_char_misc2", op_load, token: token))
                            {
                                /* TODO: Find some way to get Mystic Adept PPs from Hero Lab files
                                // Attempt to load the split MAG CharacterAttribute information for Mystic Adepts.
                                if (_blnAdeptEnabled && _blnMagicianEnabled)
                                {
                                    xmlCharacterNavigator.TryGetInt32FieldQuickly("magsplitadept", ref _intMAGAdept);
                                    xmlCharacterNavigator.TryGetInt32FieldQuickly("magsplitmagician", ref _intMAGMagician);
                                }
                                */

                                // Attempt to load in the character's tradition
                                if (xmlStatBlockBaseNode.SelectSingleNode("magic/tradition") != null)
                                {
                                    _objTradition.LoadFromHeroLab(
                                        xmlStatBlockBaseNode.SelectSingleNode("magic/tradition"));
                                }

                                // Attempt to load Condition Monitor Progress.
                                XPathNavigator xmlPhysicalCMFilledNode =
                                    xmlLeadsBaseNode.SelectSingleNode(
                                        "usagepool[@id = \"DmgNet\" and @pickindex=\"5\"]/@quantity");
                                if (xmlPhysicalCMFilledNode != null)
                                    int.TryParse(xmlPhysicalCMFilledNode.Value, NumberStyles.Any,
                                                 GlobalSettings.InvariantCultureInfo, out _intPhysicalCMFilled);
                                XPathNavigator xmlStunCMFilledNode =
                                    xmlLeadsBaseNode.SelectSingleNode(
                                        "usagepool[@id = \"DmgNet\" and @pickindex=\"6\"]/@quantity");
                                if (xmlStunCMFilledNode != null)
                                    int.TryParse(xmlStunCMFilledNode.Value, NumberStyles.Any,
                                                 GlobalSettings.InvariantCultureInfo, out _intStunCMFilled);
                                //Timekeeper.Finish("load_char_misc2");
                            }

                            using (CustomActivity op_load_char_skills = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_skills", op_load)
                                       : await Timekeeper.StartSyncronAsync("load_char_skills", op_load, token: token)) //slightly messy
                            {
                                SkillsSection.LoadFromHeroLab(xmlStatBlockBaseNode.SelectSingleNode("skills"),
                                                              op_load_char_skills);

                                //Timekeeper.Finish("load_char_skills");
                            }

                            /* TODO: Add support for locations from HeroLab
                            Timekeeper.Start("load_char_loc");
        
                            // Locations.
                            XmlNodeList objXmlLocationList = objXmlCharacter.SelectNodes("gearlocations/gearlocation");
                            foreach (XmlNode objXmlLocation in objXmlLocationList)
                            {
                                Location objLocation = new Location(this, _lstGearLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }
        
                            objXmlLocationList = objXmlCharacter.SelectNodes("locations/location");
                            foreach (XmlNode objXmlLocation in objXmlLocationList)
                            {
                                Location objLocation = new Location(this, _lstGearLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }
        
                            objXmlLocationList = objXmlCharacter.SelectNodes("gearlocations/location");
                            foreach (XmlNode objXmlLocation in objXmlLocationList)
                            {
                                Location objLocation = new Location(this, _lstGearLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }
        
                            Timekeeper.Finish("load_char_loc");
                            Timekeeper.Start("load_char_abundle");
        
                            // Armor Bundles.
                            objXmlLocationList = objXmlCharacter.SelectNodes("armorbundles/armorbundle");
                            foreach (XmlNode objXmlLocation in objXmlLocationList)
                            {
                                Location objLocation = new Location(this, _lstArmorLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }
        
                            objXmlLocationList = objXmlCharacter.SelectNodes("armorlocations/armorlocation");
                            foreach (XmlNode objXmlLocation in objXmlLocationList)
                            {
                                Location objLocation = new Location(this, _lstArmorLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }
        
                            objXmlLocationList = objXmlCharacter.SelectNodes("armorlocations/location");
                            foreach (XmlNode objXmlLocation in objXmlLocationList)
                            {
                                Location objLocation = new Location(this, _lstArmorLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }
        
                            Timekeeper.Finish("load_char_abundle");
                            Timekeeper.Start("load_char_vloc");
        
                            // Vehicle Locations.
                            XmlNodeList objXmlVehicleLocationList = objXmlCharacter.SelectNodes("vehiclelocations/vehiclelocation");
                            foreach (XmlNode objXmlLocation in objXmlVehicleLocationList)
                            {
                                Location objLocation = new Location(this, _lstVehicleLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }
        
                            objXmlVehicleLocationList = objXmlCharacter.SelectNodes("vehiclelocations/location");
                            foreach (XmlNode objXmlLocation in objXmlVehicleLocationList)
                            {
                                Location objLocation = new Location(this, _lstVehicleLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }
        
                            Timekeeper.Finish("load_char_vloc");
                            Timekeeper.Start("load_char_wloc");
        
                            // Weapon Locations.
                            XmlNodeList objXmlWeaponLocationList = objXmlCharacter.SelectNodes("weaponlocations/weaponlocation");
                            foreach (XmlNode objXmlLocation in objXmlWeaponLocationList)
                            {
                                Location objLocation = new Location(this, _lstWeaponLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }
        
                            objXmlWeaponLocationList = objXmlCharacter.SelectNodes("weaponlocations/location");
                            foreach (XmlNode objXmlLocation in objXmlWeaponLocationList)
                            {
                                Location objLocation = new Location(this, _lstWeaponLocations, string.Empty, false);
                                objLocation.Load(objXmlLocation);
                            }
        
                            Timekeeper.Finish("load_char_wloc");
                            */
                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_contacts", op_load)
                                       : await Timekeeper.StartSyncronAsync("load_char_contacts", op_load, token: token))
                            {
                                // Contacts.
                                foreach (XPathNavigator xmlContactToImport in xmlStatBlockBaseNode.Select(
                                             "contacts/contact[@useradded != \"no\"]"))
                                {
                                    Contact objContact = new Contact(this)
                                    {
                                        EntityType = ContactType.Contact,
                                        Name = xmlContactToImport.SelectSingleNode("@name")?.Value ?? string.Empty,
                                        Role = xmlContactToImport.SelectSingleNode("@type")?.Value ?? string.Empty,
                                        Connection =
                                            xmlContactToImport.SelectSingleNode("@connection")?.ValueAsInt ?? 1,
                                        Loyalty = xmlContactToImport.SelectSingleNode("@loyalty")?.ValueAsInt ?? 1
                                    };
                                    string strDescription =
                                        xmlContactToImport.SelectSingleNode("description")?.Value;
                                    using (new FetchSafelyFromPool<StringBuilder>(
                                               Utils.StringBuilderPool, out StringBuilder sbdNotes))
                                    {
                                        foreach (string strLine in strDescription.SplitNoAlloc('\n',
                                                     StringSplitOptions.RemoveEmptyEntries))
                                        {
                                            string[] astrLineColonSplit =
                                                strLine.Split(':', StringSplitOptions.RemoveEmptyEntries);
                                            switch (astrLineColonSplit[0])
                                            {
                                                case "Metatype":
                                                    objContact.Metatype = astrLineColonSplit[1].Trim();
                                                    break;
                                                case "Gender":
                                                    objContact.Gender = astrLineColonSplit[1].Trim();
                                                    break;
                                                case "Age":
                                                    objContact.Age = astrLineColonSplit[1].Trim();
                                                    break;
                                                case "Preferred Payment Method":
                                                    objContact.PreferredPayment = astrLineColonSplit[1].Trim();
                                                    break;
                                                case "Hobbies/Vice":
                                                    objContact.HobbiesVice = astrLineColonSplit[1].Trim();
                                                    break;
                                                case "Personal Life":
                                                    objContact.PersonalLife = astrLineColonSplit[1].Trim();
                                                    break;
                                                case "Type":
                                                    objContact.Type = astrLineColonSplit[1].Trim();
                                                    break;
                                                default:
                                                    sbdNotes.AppendLine(strLine);
                                                    break;
                                            }
                                        }

                                        if (sbdNotes.Length > 0)
                                            sbdNotes.Length -= Environment.NewLine.Length;
                                        objContact.Notes = sbdNotes.ToString();
                                    }

                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstContacts.Add(objContact);
                                    else
                                        await _lstContacts.AddAsync(objContact, token);
                                }

                                //Timekeeper.Finish("load_char_contacts");
                            }

                            XmlDocument xmlGearDocument;
                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_armor", op_load)
                                       : await Timekeeper.StartSyncronAsync("load_char_armor", op_load, token: token))
                            {
                                // Armor.
                                xmlGearDocument = blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? LoadData("gear.xml")
                                    : await LoadDataAsync("gear.xml", token: token);
                                XmlDocument xmlArmorDocument = blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? LoadData("armor.xml")
                                    : await LoadDataAsync("armor.xml", token: token);
                                foreach (XPathNavigator xmlArmorToImport in xmlStatBlockBaseNode.Select(
                                             "gear/armor/item[@useradded != \"no\"]"))
                                {
                                    string strArmorName = xmlArmorToImport.SelectSingleNode("@name")?.Value;
                                    if (!string.IsNullOrEmpty(strArmorName))
                                    {
                                        XmlNode xmlArmorData =
                                            xmlArmorDocument.SelectSingleNode(
                                                "chummer/armors/armor[name = " + strArmorName.CleanXPath() + ']');
                                        if (xmlArmorData == null)
                                        {
                                            string[] astrOriginalNameSplit =
                                                strArmorName.Split(':', StringSplitOptions.RemoveEmptyEntries);
                                            if (astrOriginalNameSplit.Length > 1)
                                            {
                                                string strName = astrOriginalNameSplit[0].Trim();
                                                xmlArmorData =
                                                    xmlArmorDocument.SelectSingleNode(
                                                        "/chummer/armors/armor[name = " + strName.CleanXPath() +
                                                        ']');
                                            }

                                            if (xmlArmorData == null)
                                            {
                                                astrOriginalNameSplit = strArmorName.Split(',',
                                                    StringSplitOptions.RemoveEmptyEntries);
                                                if (astrOriginalNameSplit.Length > 1)
                                                {
                                                    string strName = astrOriginalNameSplit[0].Trim();
                                                    xmlArmorData =
                                                        xmlArmorDocument.SelectSingleNode(
                                                            "/chummer/armors/armor[name = " +
                                                            strName.CleanXPath() + ']');
                                                }
                                            }
                                        }

                                        if (xmlArmorData != null)
                                        {
                                            Armor objArmor = new Armor(this);
                                            objArmor.Create(xmlArmorData,
                                                            xmlArmorToImport.SelectSingleNode("@rating")?.ValueAsInt
                                                            ?? 0,
                                                            lstWeapons);
                                            objArmor.Notes = xmlArmorToImport.SelectSingleNode("description")
                                                                             ?.Value;
                                            if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                _lstArmor.Add(objArmor);
                                            else
                                                await _lstArmor.AddAsync(objArmor, token);

                                            foreach (string strName in HeroLabPluginNodeNames)
                                            {
                                                foreach (XPathNavigator xmlArmorModToImport in xmlArmorToImport
                                                             .Select(
                                                                 strName + "/item[@useradded != \"no\"]"))
                                                {
                                                    string strArmorModName =
                                                        xmlArmorModToImport.SelectSingleNode("@name")?.Value;
                                                    if (!string.IsNullOrEmpty(strArmorModName))
                                                    {
                                                        XmlNode xmlArmorModData =
                                                            xmlArmorDocument.SelectSingleNode(
                                                                "chummer/mods/mod[name = " +
                                                                strArmorModName.CleanXPath() +
                                                                "]");
                                                        if (xmlArmorModData != null)
                                                        {
                                                            ArmorMod objArmorMod = new ArmorMod(this);
                                                            objArmorMod.Create(xmlArmorModData,
                                                                               xmlArmorModToImport
                                                                                   .SelectSingleNode("@rating")
                                                                                   ?.ValueAsInt ?? 0, lstWeapons);
                                                            objArmorMod.Notes = xmlArmorModToImport
                                                                .SelectSingleNode("description")?.Value;
                                                            objArmorMod.Parent = objArmor;
                                                            if (blnSync)
                                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                                objArmor.ArmorMods.Add(objArmorMod);
                                                            else
                                                                await objArmor.ArmorMods.AddAsync(objArmorMod, token);

                                                            foreach (string strPluginNodeName in
                                                                     HeroLabPluginNodeNames)
                                                            {
                                                                foreach (XPathNavigator xmlPluginToAdd in
                                                                         xmlArmorModToImport
                                                                             .Select(strPluginNodeName +
                                                                                 "/item[@useradded != \"no\"]"))
                                                                {
                                                                    Gear objPlugin = new Gear(this);
                                                                    if (objPlugin.ImportHeroLabGear(xmlPluginToAdd,
                                                                            xmlArmorModData,
                                                                            lstWeapons))
                                                                    {
                                                                        if (blnSync)
                                                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                                            objArmorMod.GearChildren.Add(objPlugin);
                                                                        else
                                                                            await objArmorMod.GearChildren.AddAsync(objPlugin, token);
                                                                    }
                                                                    else
                                                                        objPlugin.Dispose();
                                                                }

                                                                foreach (XPathNavigator xmlPluginToAdd in
                                                                         xmlArmorModToImport
                                                                             .Select(strPluginNodeName +
                                                                                 "/item[@useradded = \"no\"]"))
                                                                {
                                                                    string strGearName = xmlPluginToAdd
                                                                        .SelectSingleNode("@name")?.Value;
                                                                    if (!string.IsNullOrEmpty(strGearName))
                                                                    {
                                                                        Gear objPlugin =
                                                                            objArmorMod.GearChildren.FirstOrDefault(
                                                                                x =>
                                                                                    x.IncludedInParent &&
                                                                                    (x.Name.Contains(strGearName) ||
                                                                                        strGearName.Contains(
                                                                                            x.Name)));
                                                                        if (objPlugin != null)
                                                                        {
                                                                            objPlugin.Quantity =
                                                                                xmlPluginToAdd
                                                                                    .SelectSingleNode("@quantity")
                                                                                    ?.ValueAsInt ?? 1;
                                                                            objPlugin.Notes = xmlPluginToAdd
                                                                                .SelectSingleNode("description")
                                                                                ?.Value;
                                                                            objPlugin.ProcessHeroLabGearPlugins(
                                                                                xmlPluginToAdd, lstWeapons);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        else
                                                        {
                                                            Gear objPlugin = new Gear(this);
                                                            if (objPlugin.ImportHeroLabGear(xmlArmorModToImport,
                                                                    xmlArmorData,
                                                                    lstWeapons))
                                                            {
                                                                if (blnSync)
                                                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                                    objArmor.GearChildren.Add(objPlugin);
                                                                else
                                                                    await objArmor.GearChildren.AddAsync(objPlugin, token);
                                                            }
                                                            else
                                                                objPlugin.Dispose();
                                                        }
                                                    }
                                                }

                                                foreach (XPathNavigator xmlArmorModToImport in xmlArmorToImport
                                                             .Select(
                                                                 strName + "/item[@useradded = \"no\"]"))
                                                {
                                                    string strArmorModName =
                                                        xmlArmorModToImport.SelectSingleNode("@name")?.Value;
                                                    if (!string.IsNullOrEmpty(strArmorModName))
                                                    {
                                                        ArmorMod objArmorMod = objArmor.ArmorMods.FirstOrDefault(
                                                            x =>
                                                                x.IncludedInArmor &&
                                                                (x.Name.Contains(strArmorModName) ||
                                                                 strArmorModName.Contains(x.Name)));
                                                        if (objArmorMod != null)
                                                        {
                                                            objArmorMod.Notes = xmlArmorModToImport
                                                                .SelectSingleNode("description")?.Value;
                                                            foreach (string strPluginNodeName in
                                                                     HeroLabPluginNodeNames)
                                                            {
                                                                foreach (XPathNavigator xmlPluginToAdd in
                                                                         xmlArmorModToImport
                                                                             .Select(strPluginNodeName +
                                                                                 "/item[@useradded != \"no\"]"))
                                                                {
                                                                    Gear objPlugin = new Gear(this);
                                                                    if (objPlugin.ImportHeroLabGear(xmlPluginToAdd,
                                                                            blnSync
                                                                                // ReSharper disable once MethodHasAsyncOverload
                                                                                ? objArmorMod.GetNode()
                                                                                : await objArmorMod.GetNodeAsync(token),
                                                                            lstWeapons))
                                                                    {
                                                                        if (blnSync)
                                                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                                            objArmorMod.GearChildren.Add(objPlugin);
                                                                        else
                                                                            await objArmorMod.GearChildren.AddAsync(objPlugin, token);
                                                                    }
                                                                    else
                                                                        objPlugin.Dispose();
                                                                }

                                                                foreach (XPathNavigator xmlPluginToAdd in
                                                                         xmlArmorModToImport
                                                                             .Select(strPluginNodeName +
                                                                                 "/item[@useradded = \"no\"]"))
                                                                {
                                                                    string strGearName = xmlPluginToAdd
                                                                        .SelectSingleNode("@name")?.Value;
                                                                    if (!string.IsNullOrEmpty(strGearName))
                                                                    {
                                                                        Gear objPlugin =
                                                                            objArmorMod.GearChildren.FirstOrDefault(
                                                                                x =>
                                                                                    x.IncludedInParent &&
                                                                                    (x.Name.Contains(strGearName) ||
                                                                                        strGearName.Contains(
                                                                                            x.Name)));
                                                                        if (objPlugin != null)
                                                                        {
                                                                            objPlugin.Quantity =
                                                                                xmlPluginToAdd
                                                                                    .SelectSingleNode("@quantity")
                                                                                    ?.ValueAsInt ?? 1;
                                                                            objPlugin.Notes = xmlPluginToAdd
                                                                                .SelectSingleNode("description")
                                                                                ?.Value;
                                                                            objPlugin.ProcessHeroLabGearPlugins(
                                                                                xmlPluginToAdd, lstWeapons);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        else
                                                        {
                                                            Gear objPlugin = objArmor.GearChildren.FirstOrDefault(
                                                                x =>
                                                                    x.IncludedInParent &&
                                                                    (x.Name.Contains(strArmorModName) ||
                                                                     strArmorModName.Contains(x.Name)));
                                                            if (objPlugin != null)
                                                            {
                                                                objPlugin.Quantity = xmlArmorModToImport
                                                                    .SelectSingleNode("@quantity")?.ValueAsInt ?? 1;
                                                                objPlugin.Notes = xmlArmorModToImport
                                                                    .SelectSingleNode("description")?.Value;
                                                                objPlugin.ProcessHeroLabGearPlugins(
                                                                    xmlArmorModToImport,
                                                                    lstWeapons);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_armor");
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_weapons", op_load)
                                       : await Timekeeper.StartSyncronAsync("load_char_weapons", op_load, token: token))
                            {
                                // Weapons.
                                foreach (XPathNavigator xmlWeaponToImport in xmlStatBlockBaseNode.Select(
                                             "gear/weapons/item[@useradded != \"no\"]"))
                                {
                                    Weapon objWeapon = new Weapon(this);
                                    if (objWeapon.ImportHeroLabWeapon(xmlWeaponToImport, lstWeapons))
                                    {
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstWeapons.Add(objWeapon);
                                        else
                                            await _lstWeapons.AddAsync(objWeapon, token);
                                    }
                                    else
                                        objWeapon.Dispose();
                                }

                                foreach (XPathNavigator xmlPluginToAdd in xmlStatBlockBaseNode.Select(
                                             "gear/weapons/item[@useradded = \"no\"]"))
                                {
                                    string strName = xmlPluginToAdd.SelectSingleNode("@name")?.Value;
                                    if (!string.IsNullOrEmpty(strName))
                                    {
                                        Weapon objWeapon = _lstWeapons.FirstOrDefault(x =>
                                            !string.IsNullOrEmpty(x.ParentID) &&
                                            (x.Name.Contains(strName) || strName.Contains(x.Name)));
                                        if (objWeapon != null)
                                        {
                                            objWeapon.Notes = xmlPluginToAdd.SelectSingleNode("description")?.Value;
                                            objWeapon.ProcessHeroLabWeaponPlugins(xmlPluginToAdd, lstWeapons);
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_weapons");
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_ware", op_load)
                                       : await Timekeeper.StartSyncronAsync("load_char_ware", op_load, token: token))
                            {
                                // Cyberware/Bioware.
                                foreach (XPathNavigator xmlCyberwareToImport in xmlStatBlockBaseNode.Select(
                                             "gear/augmentations/cyberware/item[@useradded != \"no\"]"))
                                {
                                    Cyberware objCyberware = new Cyberware(this);
                                    if (objCyberware.ImportHeroLabCyberware(xmlCyberwareToImport, null, lstWeapons,
                                                                            lstVehicles))
                                    {
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstCyberware.Add(objCyberware);
                                        else
                                            await _lstCyberware.AddAsync(objCyberware, token);
                                    }
                                    else
                                        objCyberware.Dispose();
                                }

                                foreach (XPathNavigator xmlPluginToAdd in xmlStatBlockBaseNode.Select(
                                             "gear/augmentations/cyberware/item[@useradded = \"no\"]"))
                                {
                                    string strName = xmlPluginToAdd.SelectSingleNode("@name")?.Value;
                                    if (!string.IsNullOrEmpty(strName))
                                    {
                                        Cyberware objPlugin = _lstCyberware.FirstOrDefault(x =>
                                            !string.IsNullOrEmpty(x.ParentID) &&
                                            (x.Name.Contains(strName) || strName.Contains(x.Name)));
                                        if (objPlugin != null)
                                        {
                                            objPlugin.Notes = xmlPluginToAdd.SelectSingleNode("description")?.Value;
                                            objPlugin.ProcessHeroLabCyberwarePlugins(xmlPluginToAdd,
                                                objPlugin.Grade,
                                                lstWeapons,
                                                lstVehicles);
                                        }
                                    }
                                }

                                foreach (XPathNavigator xmlCyberwareToImport in xmlStatBlockBaseNode.Select(
                                             "gear/augmentations/bioware/item[@useradded != \"no\"]"))
                                {
                                    Cyberware objCyberware = new Cyberware(this);
                                    if (objCyberware.ImportHeroLabCyberware(xmlCyberwareToImport, null, lstWeapons,
                                                                            lstVehicles))
                                    {
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstCyberware.Add(objCyberware);
                                        else
                                            await _lstCyberware.AddAsync(objCyberware, token);
                                    }
                                    else
                                        objCyberware.Dispose();
                                }

                                foreach (XPathNavigator xmlPluginToAdd in xmlStatBlockBaseNode.Select(
                                             "gear/augmentations/bioware/item[@useradded = \"no\"]"))
                                {
                                    string strName = xmlPluginToAdd.SelectSingleNode("@name")?.Value;
                                    if (!string.IsNullOrEmpty(strName))
                                    {
                                        Cyberware objPlugin = _lstCyberware.FirstOrDefault(x =>
                                            !string.IsNullOrEmpty(x.ParentID) &&
                                            (x.Name.Contains(strName) || strName.Contains(x.Name)));
                                        if (objPlugin != null)
                                        {
                                            objPlugin.Notes = xmlPluginToAdd.SelectSingleNode("description")?.Value;
                                            objPlugin.ProcessHeroLabCyberwarePlugins(xmlPluginToAdd,
                                                objPlugin.Grade,
                                                lstWeapons,
                                                lstVehicles);
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_ware");
                            }

                            XPathNodeIterator xmlNodeList;
                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_spells", op_load)
                                       : await Timekeeper.StartSyncronAsync("load_char_spells", op_load, token: token))
                            {
                                // Spells.
                                xmlNodeList = blnSync
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    ? xmlStatBlockBaseNode.SelectAndCacheExpression("magic/spells/spell")
                                    : await xmlStatBlockBaseNode.SelectAndCacheExpressionAsync("magic/spells/spell", token);
                                XmlDocument xmlSpellDocument = blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? LoadData("spells.xml")
                                    : await LoadDataAsync("spells.xml", token: token);
                                foreach (XPathNavigator xmlHeroLabSpell in xmlNodeList)
                                {
                                    string strSpellName = xmlHeroLabSpell.SelectSingleNode("@name")?.Value;
                                    if (!string.IsNullOrEmpty(strSpellName))
                                    {
                                        bool blnIsLimited =
                                            strSpellName.EndsWith(" (limited)", StringComparison.Ordinal);
                                        if (blnIsLimited)
                                            strSpellName = strSpellName.TrimEndOnce(" (limited)");
                                        string strForcedValue = string.Empty;
                                        switch (strSpellName)
                                        {
                                            case "Increase Body":
                                                strForcedValue = "BOD";
                                                strSpellName = "Increase [Attribute]";
                                                break;
                                            case "Increase Agility":
                                                strForcedValue = "AGI";
                                                strSpellName = "Increase [Attribute]";
                                                break;
                                            case "Increase Reaction":
                                                strForcedValue = "REA";
                                                strSpellName = "Increase [Attribute]";
                                                break;
                                            case "Increase Strength":
                                                strForcedValue = "STR";
                                                strSpellName = "Increase [Attribute]";
                                                break;
                                            case "Increase Charisma":
                                                strForcedValue = "CHA";
                                                strSpellName = "Increase [Attribute]";
                                                break;
                                            case "Increase Intuition":
                                                strForcedValue = "INT";
                                                strSpellName = "Increase [Attribute]";
                                                break;
                                            case "Increase Logic":
                                                strForcedValue = "LOG";
                                                strSpellName = "Increase [Attribute]";
                                                break;
                                            case "Increase Willpower":
                                                strForcedValue = "WIL";
                                                strSpellName = "Increase [Attribute]";
                                                break;
                                            case "Decrease Body":
                                                strForcedValue = "BOD";
                                                strSpellName = "Decrease [Attribute]";
                                                break;
                                            case "Decrease Agility":
                                                strForcedValue = "AGI";
                                                strSpellName = "Decrease [Attribute]";
                                                break;
                                            case "Decrease Reaction":
                                                strForcedValue = "REA";
                                                strSpellName = "Decrease [Attribute]";
                                                break;
                                            case "Decrease Strength":
                                                strForcedValue = "STR";
                                                strSpellName = "Decrease [Attribute]";
                                                break;
                                            case "Decrease Charisma":
                                                strForcedValue = "CHA";
                                                strSpellName = "Decrease [Attribute]";
                                                break;
                                            case "Decrease Intuition":
                                                strForcedValue = "INT";
                                                strSpellName = "Decrease [Attribute]";
                                                break;
                                            case "Decrease Logic":
                                                strForcedValue = "LOG";
                                                strSpellName = "Decrease [Attribute]";
                                                break;
                                            case "Decrease Willpower":
                                                strForcedValue = "WIL";
                                                strSpellName = "Decrease [Attribute]";
                                                break;
                                        }

                                        if (strSpellName.StartsWith("Detect ", StringComparison.Ordinal) &&
                                            strSpellName != "Detect Life" &&
                                            strSpellName != "Detect Life, Extended" &&
                                            strSpellName != "Detect Magic" &&
                                            strSpellName != "Detect Magic, Extended" &&
                                            strSpellName != "Detect Enemies" &&
                                            strSpellName != "Detect Enemies, Extended" &&
                                            strSpellName != "Detect Individual" &&
                                            strSpellName != "Detect Life, Extended")
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Clean ")
                                                                         .TrimEndOnce(", Extended");
                                            if (xmlHeroLabSpell.SelectSingleNode("@type")?.Value == "Physical")
                                                strSpellName = "Detect [Object]";
                                            else if (strSpellName.EndsWith(", Extended", StringComparison.Ordinal))
                                                strSpellName = "Detect [Life Form], Extended";
                                            else
                                                strSpellName = "Detect [Life Form]";
                                        }
                                        else if (strSpellName.StartsWith("Corrode ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Corrode ");
                                            strSpellName = "Corrode [Object]";
                                        }
                                        else if (strSpellName.StartsWith("Melt ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Melt ");
                                            strSpellName = "Melt [Object]";
                                        }
                                        else if (strSpellName.StartsWith("Sludge ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Sludge ");
                                            strSpellName = "Sludge [Object]";
                                        }
                                        else if (strSpellName.StartsWith("Disrupt ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Disrupt ");
                                            strSpellName = "Disrupt [Object]";
                                        }
                                        else if (strSpellName.StartsWith("Destroy ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Destroy ");
                                            strSpellName = xmlHeroLabSpell.SelectSingleNode("@type")?.Value ==
                                                           "Physical"
                                                ? "Destroy [Vehicle]"
                                                : "Destroy [Free Spirit]";
                                        }
                                        else if (strSpellName.StartsWith("Insecticide ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Insecticide ");
                                            strSpellName = "Insecticide [Insect Spirit]";
                                        }
                                        else if (strSpellName.StartsWith("One Less ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("One Less ");
                                            strSpellName = "One Less [Metatype/Species]";
                                        }
                                        else if (strSpellName.StartsWith("Slay ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Slay ");
                                            strSpellName = "Slay [Metatype/Species]";
                                        }
                                        else if (strSpellName.StartsWith("Slaughter ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Slaughter ");
                                            strSpellName = "Slaughter [Metatype/Species]";
                                        }
                                        else if (strSpellName.StartsWith("Ram ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Ram ");
                                            strSpellName = "Ram [Object]";
                                        }
                                        else if (strSpellName.StartsWith("Wreck ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Wreck ");
                                            strSpellName = "Wreck [Object]";
                                        }
                                        else if (strSpellName.StartsWith("Demolish ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Demolish ");
                                            strSpellName = "Demolish [Object]";
                                        }
                                        else if (strSpellName.EndsWith(" Cryptesthesia", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimEndOnce(" Cryptesthesia");
                                            strSpellName = "[Sense] Cryptesthesia";
                                        }
                                        else if (strSpellName.EndsWith(" Removal", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Mass ")
                                                                         .TrimEndOnce(" Removal");
                                            strSpellName =
                                                strSpellName.StartsWith("Mass ", StringComparison.Ordinal)
                                                    ? "Mass [Sense] Removal"
                                                    : "[Sense] Removal";
                                        }
                                        else if (strSpellName.StartsWith("Alleviate ", StringComparison.Ordinal) &&
                                                 strSpellName != "Alleviate Addiction")
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Alleviate ");
                                            strSpellName = "Alleviate [Allergy]";
                                        }
                                        else if (strSpellName.StartsWith("Clean ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Clean ");
                                            strSpellName = "Clean [Element]";
                                        }
                                        else if (strSpellName.EndsWith(" Grenade", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimEndOnce(" Grenade");
                                            strSpellName = "[Element] Grenade";
                                        }
                                        else if (strSpellName.EndsWith(" Aura", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimEndOnce(" Aura");
                                            strSpellName = "[Element] Aura";
                                        }
                                        else if (strSpellName != "Napalm Wall" &&
                                                 strSpellName.EndsWith(" Wall", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimEndOnce(" Wall");
                                            strSpellName = "[Element] Wall";
                                        }
                                        else if (strSpellName.StartsWith("Shape ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Shape ");
                                            strSpellName = "Shape [Material]";
                                        }
                                        else if (strSpellName.EndsWith(" Form", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimEndOnce(" Form");
                                            strSpellName = "[Critter] Form";
                                        }
                                        else if (strSpellName.StartsWith("Calling ", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimStartOnce("Calling ");
                                            strSpellName = "Calling [Spirit Type]";
                                        }
                                        else if (strSpellName != "Symbolic Link" &&
                                                 strSpellName.EndsWith(" Link", StringComparison.Ordinal))
                                        {
                                            strForcedValue = strSpellName.TrimEndOnce(" Link");
                                            strSpellName = "[Sense] Link";
                                        }

                                        string strSpellCategory =
                                            xmlHeroLabSpell.SelectSingleNode("@category")?.Value;
                                        XmlNode xmlSpellData = xmlSpellDocument.SelectSingleNode(
                                            "chummer/spells/spell[category = " + strSpellCategory.CleanXPath() +
                                            " and name = " + strSpellName.CleanXPath() + ']');
                                        if (xmlSpellData == null)
                                        {
                                            string[] astrOriginalNameSplit =
                                                strSpellName.Split(':', StringSplitOptions.RemoveEmptyEntries);
                                            if (astrOriginalNameSplit.Length > 1)
                                            {
                                                string strName = astrOriginalNameSplit[0].Trim();
                                                xmlSpellData = xmlSpellDocument.SelectSingleNode(
                                                    "/chummer/spells/spell[category = " +
                                                    strSpellCategory.CleanXPath() +
                                                    " and name = " + strName.CleanXPath() + ']');
                                            }

                                            if (xmlSpellData == null)
                                            {
                                                astrOriginalNameSplit = strSpellName.Split(',',
                                                    StringSplitOptions.RemoveEmptyEntries);
                                                if (astrOriginalNameSplit.Length > 1)
                                                {
                                                    string strName = astrOriginalNameSplit[0].Trim();
                                                    xmlSpellData = xmlSpellDocument.SelectSingleNode(
                                                        "/chummer/spells/spell[category = " +
                                                        strSpellCategory.CleanXPath() + " and name = " +
                                                        strName.CleanXPath() + ']');
                                                }
                                            }
                                        }

                                        if (xmlSpellData != null)
                                        {
                                            Spell objSpell = new Spell(this);
                                            objSpell.Create(xmlSpellData, strForcedValue, blnIsLimited);
                                            objSpell.Notes = xmlHeroLabSpell.SelectSingleNode("description")?.Value;
                                            if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                _lstSpells.Add(objSpell);
                                            else
                                                await _lstSpells.AddAsync(objSpell, token);
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_spells");
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_powers", op_load)
                                       : await Timekeeper.StartSyncronAsync("load_char_powers", op_load, token: token))
                            {
                                // Powers.
                                xmlNodeList = blnSync
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    ? xmlStatBlockBaseNode.SelectAndCacheExpression("magic/adeptpowers/adeptpower")
                                    : await xmlStatBlockBaseNode.SelectAndCacheExpressionAsync("magic/adeptpowers/adeptpower", token);
                                XmlDocument xmlPowersDocument = blnSync
                                    // ReSharper disable once MethodHasAsyncOverload
                                    ? LoadData("powers.xml")
                                    : await LoadDataAsync("powers.xml", token: token);
                                foreach (XPathNavigator xmlHeroLabPower in xmlNodeList)
                                {
                                    string strPowerName = xmlHeroLabPower.SelectSingleNode("@name")?.Value;
                                    if (!string.IsNullOrEmpty(strPowerName))
                                    {
                                        int intRating = 1;
                                        string strForcedValue = string.Empty;
                                        XmlNode xmlPowerData =
                                            xmlPowersDocument.SelectSingleNode(
                                                "chummer/powers/power[contains(name, " + strPowerName.CleanXPath() +
                                                ")]");
                                        if (xmlPowerData == null)
                                        {
                                            string[] astrOriginalNameSplit =
                                                strPowerName.Split(':', StringSplitOptions.RemoveEmptyEntries);
                                            if (astrOriginalNameSplit.Length > 1)
                                            {
                                                string strName = astrOriginalNameSplit[0].Trim();
                                                xmlPowerData =
                                                    xmlPowersDocument.SelectSingleNode(
                                                        "/chummer/powers/power[contains(name, " +
                                                        strName.CleanXPath() +
                                                        ")]");

                                                strForcedValue = astrOriginalNameSplit[1].Trim();
                                                int intForcedValueParenthesesStart = strForcedValue.IndexOf('(');
                                                if (intForcedValueParenthesesStart != -1)
                                                    strForcedValue =
                                                        strForcedValue.Substring(0, intForcedValueParenthesesStart);
                                            }

                                            if (xmlPowerData == null)
                                            {
                                                astrOriginalNameSplit = strPowerName.Split('(',
                                                    StringSplitOptions.RemoveEmptyEntries);
                                                if (astrOriginalNameSplit.Length > 1)
                                                {
                                                    string strName = astrOriginalNameSplit[0].Trim();
                                                    xmlPowerData =
                                                        xmlPowersDocument.SelectSingleNode(
                                                            "/chummer/powers/power[contains(name, " +
                                                            strName.CleanXPath() +
                                                            ")]");

                                                    string strSecondPart = astrOriginalNameSplit[1].Trim();
                                                    int intSecondPartParenthesesEnd = strSecondPart.IndexOf(')');
                                                    if (intSecondPartParenthesesEnd != -1
                                                        && !int.TryParse(
                                                            strSecondPart.Substring(0, intSecondPartParenthesesEnd),
                                                            out intRating))
                                                        intRating = 1;

                                                    astrOriginalNameSplit = strSecondPart.Split(':',
                                                        StringSplitOptions.RemoveEmptyEntries);
                                                    if (astrOriginalNameSplit.Length >= 2)
                                                    {
                                                        strForcedValue = astrOriginalNameSplit[1].Trim();
                                                        int intForcedValueParenthesesStart =
                                                            strForcedValue.IndexOf('(');
                                                        if (intForcedValueParenthesesStart != -1)
                                                            strForcedValue =
                                                                strForcedValue.Substring(0,
                                                                    intForcedValueParenthesesStart);
                                                    }
                                                }
                                            }
                                        }

                                        if (xmlPowerData != null)
                                        {
                                            Power objPower = new Power(this) {Extra = strForcedValue};
                                            objPower.Create(xmlPowerData, intRating);
                                            objPower.Notes = xmlHeroLabPower.SelectSingleNode("description")?.Value;
                                            if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                _lstPowers.Add(objPower);
                                            else
                                                await _lstPowers.AddAsync(objPower, token);
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_powers");
                            }

                            /* TODO: Spirit/Sprite Importing
                            Timekeeper.Start("load_char_spirits");
        
                            // Spirits/Sprites.
                            foreach (XPathNavigator xmlSpirit in xmlCharacterNavigator.SelectAndCacheExpression("spirits/spirit"))
                            {
                                Spirit objSpirit = new Spirit(this);
                                objSpirit.Load(xmlSpirit);
                                _lstSpirits.Add(objSpirit);
                            }
        
                            Timekeeper.Finish("load_char_spirits");
                            */
                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_complex", op_load)
                                       : await Timekeeper.StartSyncronAsync("load_char_complex", op_load, token: token))
                            {
                                // Complex Forms/Technomancer Programs.
                                string strComplexFormsLine =
                                    lstTextStatBlockLines?.FirstOrDefault(x =>
                                                                              x.StartsWith(
                                                                                  "Complex Forms:",
                                                                                  StringComparison.Ordinal));
                                if (!string.IsNullOrEmpty(strComplexFormsLine))
                                {
                                    XmlDocument xmlComplexFormsDocument = blnSync
                                        // ReSharper disable once MethodHasAsyncOverload
                                        ? LoadData("complexforms.xml")
                                        : await LoadDataAsync("complexforms.xml", token: token);

                                    string[] astrComplexForms =
                                        strComplexFormsLine.TrimStartOnce("Complex Forms:").Trim()
                                                           .Split(',', StringSplitOptions.RemoveEmptyEntries);
                                    foreach (string strComplexFormEntry in astrComplexForms)
                                    {
                                        string strComplexFormName = strComplexFormEntry.Trim();
                                        string strForcedValue = string.Empty;
                                        switch (strComplexFormName)
                                        {
                                            case "Diffusion of Attack":
                                                strComplexFormName = "Diffusion of [Matrix Attribute]";
                                                strForcedValue = "Attack";
                                                break;
                                            case "Diffusion of Sleaze":
                                                strComplexFormName = "Diffusion of [Matrix Attribute]";
                                                strForcedValue = "Sleaze";
                                                break;
                                            case "Diffusion of Data Processing":
                                                strComplexFormName = "Diffusion of [Matrix Attribute]";
                                                strForcedValue = "Data Processing";
                                                break;
                                            case "Diffusion of Firewall":
                                                strComplexFormName = "Diffusion of [Matrix Attribute]";
                                                strForcedValue = "Firewall";
                                                break;
                                            case "Infusion of Attack":
                                                strComplexFormName = "Infusion of [Matrix Attribute]";
                                                strForcedValue = "Attack";
                                                break;
                                            case "Infusion of Sleaze":
                                                strComplexFormName = "Infusion of [Matrix Attribute]";
                                                strForcedValue = "Sleaze";
                                                break;
                                            case "Infusion of Data Processing":
                                                strComplexFormName = "Infusion of [Matrix Attribute]";
                                                strForcedValue = "Data Processing";
                                                break;
                                            case "Infusion of Firewall":
                                                strComplexFormName = "Infusion of [Matrix Attribute]";
                                                strForcedValue = "Firewall";
                                                break;
                                        }

                                        XmlNode xmlComplexFormData =
                                            xmlComplexFormsDocument.SelectSingleNode(
                                                "chummer/complexforms/complexform[name = " +
                                                strComplexFormName.CleanXPath() + ']');
                                        if (xmlComplexFormData == null)
                                        {
                                            string[] astrOriginalNameSplit =
                                                strComplexFormName.Split(':',
                                                                         StringSplitOptions.RemoveEmptyEntries);
                                            if (astrOriginalNameSplit.Length > 1)
                                            {
                                                string strName = astrOriginalNameSplit[0].Trim();
                                                xmlComplexFormData =
                                                    xmlComplexFormsDocument.SelectSingleNode(
                                                        "/chummer/complexforms/complexform[name = " +
                                                        strName.CleanXPath() +
                                                        "]");
                                            }

                                            if (xmlComplexFormData == null)
                                            {
                                                astrOriginalNameSplit = strComplexFormName.Split(',',
                                                    StringSplitOptions.RemoveEmptyEntries);
                                                if (astrOriginalNameSplit.Length > 1)
                                                {
                                                    string strName = astrOriginalNameSplit[0].Trim();
                                                    xmlComplexFormData =
                                                        xmlComplexFormsDocument.SelectSingleNode(
                                                            "/chummer/complexforms/complexform[name = " +
                                                            strName.CleanXPath() + ']');
                                                }
                                            }
                                        }

                                        if (xmlComplexFormData != null)
                                        {
                                            ComplexForm objComplexForm = new ComplexForm(this);
                                            objComplexForm.Create(xmlComplexFormData, strForcedValue);
                                            if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                _lstComplexForms.Add(objComplexForm);
                                            else
                                                await _lstComplexForms.AddAsync(objComplexForm, token);
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_complex");
                            }

                            /* TODO: AI Advanced Program Importing
                            Timekeeper.Start("load_char_aiprogram");
        
                            // AI Advanced Programs.
                            objXmlNodeList = objXmlCharacter.SelectNodes("aiprograms/aiprogram");
                            foreach (XmlNode xmlHeroLabProgram in xmlNodeList)
                            {
                                AIProgram objProgram = new AIProgram(this);
                                objProgram.Load(xmlHeroLabProgram);
                                _lstAIPrograms.Add(objProgram);
                            }
        
                            Timekeeper.Finish("load_char_aiprogram");
                            */
                            /* TODO: Martial Arts import, which are saved in TXT and HTML statblocks but not in XML statblock
                            Timekeeper.Start("load_char_marts");
        
                            // Martial Arts.
                            xmlNodeList = objXmlCharacter.SelectNodes("martialarts/martialart");
                            foreach (XmlNode xmlHeroLabArt in xmlNodeList)
                            {
                                MartialArt objMartialArt = new MartialArt(this);
                                objMartialArt.Load(xmlHeroLabArt);
                                _lstMartialArts.Add(objMartialArt);
                            }
        
                            Timekeeper.Finish("load_char_marts");
                            */
                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_lifestyle", op_load)
                                       : await Timekeeper.StartSyncronAsync("load_char_lifestyle", op_load, token: token))
                            {
                                // Lifestyles.
                                XmlNode xmlFakeSINDataNode =
                                    xmlGearDocument.SelectSingleNode("/chummer/gears/gear[name = 'Fake SIN']");
                                XmlNode xmlFakeLicenseDataNode =
                                    xmlGearDocument.SelectSingleNode("/chummer/gears/gear[name = 'Fake License']");
                                xmlNodeList = blnSync
                                    // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                    ? xmlStatBlockBaseNode.SelectAndCacheExpression("identities/identity")
                                    : await xmlStatBlockBaseNode.SelectAndCacheExpressionAsync("identities/identity", token);
                                foreach (XPathNavigator xmlHeroLabIdentity in xmlNodeList)
                                {
                                    string strIdentityName = xmlHeroLabIdentity.SelectSingleNode("@name")?.Value;
                                    int intIdentityNameParenthesesStart = strIdentityName.IndexOf('(');
                                    if (intIdentityNameParenthesesStart != -1)
                                        strIdentityName =
                                            strIdentityName.Substring(0, intIdentityNameParenthesesStart);
                                    XPathNavigator xmlHeroLabFakeSINNode =
                                        xmlHeroLabIdentity.SelectSingleNode("license[@name = \"Fake SIN\"]");
                                    if (xmlHeroLabFakeSINNode != null)
                                    {
                                        Gear objFakeSIN = new Gear(this);
                                        objFakeSIN.Create(xmlFakeSINDataNode,
                                                          xmlHeroLabFakeSINNode.SelectSingleNode("@rating")?.ValueAsInt
                                                          ?? 1,
                                                          lstWeapons,
                                                          strIdentityName);
                                        foreach (XPathNavigator xmlHeroLabFakeLicenseNode in xmlHeroLabIdentity
                                                     .Select(
                                                         "license[@name = \"Fake License\"]"))
                                        {
                                            Gear objFakeLicense = new Gear(this);
                                            objFakeLicense.Create(xmlFakeLicenseDataNode,
                                                                  xmlHeroLabFakeLicenseNode.SelectSingleNode("@rating")
                                                                      ?.ValueAsInt ??
                                                                  1,
                                                                  lstWeapons,
                                                                  xmlHeroLabFakeLicenseNode.SelectSingleNode("@for")
                                                                      ?.Value);
                                            objFakeLicense.Parent = objFakeSIN;
                                            if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                objFakeSIN.Children.Add(objFakeLicense);
                                            else
                                                await objFakeSIN.Children.AddAsync(objFakeLicense, token);
                                        }

                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstGear.Add(objFakeSIN);
                                        else
                                            await _lstGear.AddAsync(objFakeSIN, token);
                                    }

                                    XPathNavigator xmlHeroLabLifestyleNode =
                                        xmlHeroLabIdentity.SelectSingleNode("lifestyle");
                                    if (xmlHeroLabLifestyleNode != null)
                                    {
                                        string strLifestyleType = xmlHeroLabLifestyleNode.SelectSingleNode("@name")
                                            ?.Value
                                            .TrimEndOnce(" Lifestyle");

                                        XmlNode xmlLifestyleDataNode =
                                            (blnSync
                                                // ReSharper disable once MethodHasAsyncOverload
                                                ? LoadData("lifestyles.xml")
                                                : await LoadDataAsync("lifestyles.xml", token: token))
                                            .SelectSingleNode("/chummer/lifestyles/lifestyle[name = " +
                                                              strLifestyleType.CleanXPath() + ']');

                                        if (xmlLifestyleDataNode != null)
                                        {
                                            Lifestyle objLifestyle = new Lifestyle(this);
                                            objLifestyle.Create(xmlLifestyleDataNode);
                                            if (int.TryParse(
                                                    xmlHeroLabLifestyleNode.SelectSingleNode("@months")?.Value,
                                                    out int intMonths))
                                            {
                                                objLifestyle.Increments = intMonths;
                                            }

                                            if (blnSync)
                                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                                _lstLifestyles.Add(objLifestyle);
                                            else
                                                await _lstLifestyles.AddAsync(objLifestyle, token);
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_lifestyle");
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_gear", op_load)
                                       : await Timekeeper.StartSyncronAsync("load_char_gear", op_load, token: token))
                            {
                                // <gears>
                                foreach (XPathNavigator xmlGearToImport in xmlStatBlockBaseNode.Select(
                                             "gear/equipment/item[@useradded != \"no\"]"))
                                {
                                    Gear objGear = new Gear(this);
                                    if (objGear.ImportHeroLabGear(xmlGearToImport, null, lstWeapons))
                                    {
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstGear.Add(objGear);
                                        else
                                            await _lstGear.AddAsync(objGear, token);
                                    }
                                }

                                foreach (XPathNavigator xmlPluginToAdd in xmlStatBlockBaseNode.Select(
                                             "gear/equipment/item[@useradded = \"no\"]"))
                                {
                                    string strName = xmlPluginToAdd.SelectSingleNode("@name")?.Value;
                                    if (!string.IsNullOrEmpty(strName))
                                    {
                                        Gear objPlugin = _lstGear.FirstOrDefault(x =>
                                            x.IncludedInParent &&
                                            (x.Name.Contains(strName) || strName.Contains(x.Name)));
                                        if (objPlugin != null)
                                        {
                                            objPlugin.Quantity =
                                                Convert.ToDecimal(
                                                    xmlPluginToAdd.SelectSingleNode("@quantity")?.Value ?? "1",
                                                    GlobalSettings.InvariantCultureInfo);
                                            objPlugin.Notes = xmlPluginToAdd.SelectSingleNode("description")?.Value;
                                            objPlugin.ProcessHeroLabGearPlugins(xmlPluginToAdd, lstWeapons);
                                        }
                                    }
                                }

                                //Timekeeper.Finish("load_char_gear");
                            }

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_car", op_load)
                                       : await Timekeeper.StartSyncronAsync("load_char_car", op_load, token: token))
                            {
                                foreach (Vehicle objVehicle in lstVehicles)
                                {
                                    if (blnSync)
                                        // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                        _lstVehicles.Add(objVehicle);
                                    else
                                        await _lstVehicles.AddAsync(objVehicle, token);
                                }

                                /* TODO: Process HeroLab Vehicles entries, which are present in HTML and TXT statblocks but not in XML
                                // Vehicles.
                                xmlNodeList = objXmlCharacter.SelectNodes("vehicles/vehicle");
                                foreach (XmlNode xmlHeroLabVehicle in xmlNodeList)
                                {
                                    Vehicle objVehicle = new Vehicle(this);
                                    objVehicle.Load(xmlHeroLabVehicle);
                                    _lstVehicles.Add(objVehicle);
                                }
                                */
                                //Timekeeper.Finish("load_char_car");
                            }

                            /* TODO: Process HeroLab Initiation/Submersion and related entries
                            Timekeeper.Start("load_char_mmagic");
                            // Metamagics/Echoes.
                            xmlNodeList = objXmlCharacter.SelectNodes("metamagics/metamagic");
                            foreach (XmlNode xmlHeroLabMetamagic in xmlNodeList)
                            {
                                Metamagic objMetamagic = new Metamagic(this);
                                objMetamagic.Load(xmlHeroLabMetamagic);
                                _lstMetamagics.Add(objMetamagic);
                            }
        
                            Timekeeper.Finish("load_char_mmagic");
                            Timekeeper.Start("load_char_arts");
        
                            // Arts
                            xmlNodeList = objXmlCharacter.SelectNodes("arts/art");
                            foreach (XmlNode xmlHeroLabArt in xmlNodeList)
                            {
                                Art objArt = new Art(this);
                                objArt.Load(xmlHeroLabArt);
                                _lstArts.Add(objArt);
                            }
        
                            Timekeeper.Finish("load_char_arts");
                            Timekeeper.Start("load_char_ench");
        
                            // Enhancements
                            xmlNodeList = objXmlCharacter.SelectNodes("enhancements/enhancement");
                            foreach (XmlNode xmlHeroLabEnhancement in objXmlNodeList)
                            {
                                Enhancement objEnhancement = new Enhancement(this);
                                objEnhancement.Load(xmlHeroLabEnhancement);
                                _lstEnhancements.Add(objEnhancement);
                            }
        
                            Timekeeper.Finish("load_char_ench");
                            Timekeeper.Start("load_char_cpow");
        
                            // Critter Powers.
                            xmlNodeList = objXmlCharacter.SelectNodes("critterpowers/critterpower");
                            foreach (XmlNode xmlHeroLabPower in xmlNodeList)
                            {
                                CritterPower objPower = new CritterPower(this);
                                objPower.Load(xmlHeroLabPower);
                                _lstCritterPowers.Add(objPower);
                            }
        
                            Timekeeper.Finish("load_char_cpow");
                            Timekeeper.Start("load_char_foci");
        
                            // Foci.
                            xmlNodeList = objXmlCharacter.SelectNodes("foci/focus");
                            foreach (XmlNode xmlHeroLabFocus in xmlNodeList)
                            {
                                Focus objFocus = new Focus(this);
                                objFocus.Load(xmlHeroLabFocus);
                                _lstFoci.Add(objFocus);
                            }
        
                            Timekeeper.Finish("load_char_foci");
                            Timekeeper.Start("load_char_init");
        
                            // Initiation Grades.
                            xmlNodeList = objXmlCharacter.SelectNodes("initiationgrades/initiationgrade");
                            foreach (XmlNode xmlHeroLabGrade in xmlNodeList)
                            {
                                InitiationGrade objGrade = new InitiationGrade(this);
                                objGrade.Load(xmlHeroLabGrade);
                                _lstInitiationGrades.Add(objGrade);
                            }
        
                            Timekeeper.Finish("load_char_init");
                            */
                            /* TODO: Import HeroLab Expense Logs, which are different from Journal entries
                            Timekeeper.Start("load_char_elog");
        
                            // Expense Log Entries.
                            XmlNodeList xmlExpenseList = objXmlCharacter.SelectNodes("expenses/expense");
                            foreach (XmlNode xmlHeroLabExpense in xmlExpenseList)
                            {
                                ExpenseLogEntry objExpenseLogEntry = new ExpenseLogEntry(this);
                                objExpenseLogEntry.Load(xmlHeroLabExpense);
                                _lstExpenseLog.Add(objExpenseLogEntry);
                            }
        
                            Timekeeper.Finish("load_char_elog");
                            */
                            _lstWeapons.AddRange(lstWeapons);

                            using (_ = blnSync
                                       // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                       ? Timekeeper.StartSyncron("load_char_unarmed", op_load)
                                       : await Timekeeper.StartSyncronAsync("load_char_unarmed", op_load, token: token))
                            {
                                // Look for the unarmed attack
                                bool blnFoundUnarmed = false;
                                foreach (Weapon objWeapon in _lstWeapons)
                                {
                                    if (objWeapon.Name == "Unarmed Attack")
                                    {
                                        blnFoundUnarmed = true;
                                        break;
                                    }
                                }

                                if (!blnFoundUnarmed)
                                {
                                    // Add the Unarmed Attack Weapon to the character.
                                    XmlDocument objXmlWeaponDoc = blnSync
                                        // ReSharper disable once MethodHasAsyncOverload
                                        ? LoadData("weapons.xml")
                                        : await LoadDataAsync("weapons.xml", token: token);
                                    XmlNode objXmlWeapon =
                                        objXmlWeaponDoc.SelectSingleNode(
                                            "/chummer/weapons/weapon[name = \"Unarmed Attack\"]");
                                    if (objXmlWeapon != null)
                                    {
                                        Weapon objWeapon = new Weapon(this);
                                        objWeapon.Create(objXmlWeapon, _lstWeapons);
                                        objWeapon.IncludedInWeapon = true; // Unarmed attack can never be removed
                                        if (blnSync)
                                            // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                            _lstWeapons.Add(objWeapon);
                                        else
                                            await _lstWeapons.AddAsync(objWeapon, token);
                                    }
                                }

                                //Timekeeper.Finish("load_char_unarmed");
                            }
                        }
                        finally
                        {
                            IsLoading = false;
                        }

                        // Refresh certain improvements
                        using (_ = blnSync
                                   // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                   ? Timekeeper.StartSyncron("load_char_improvementrefreshers2", op_load)
                                   : await Timekeeper.StartSyncronAsync("load_char_improvementrefreshers2", op_load, token: token))
                        {
                            // Refresh Black Market discounts
                            RefreshBlackMarketDiscounts();
                            // Refresh Dealer Connection discounts
                            RefreshDealerConnectionDiscounts();
                            // Refresh permanent attribute changes due to essence loss
                            if (blnSync)
                                // ReSharper disable once MethodHasAsyncOverloadWithCancellation
                                RefreshEssenceLossImprovements();
                            else
                                await RefreshEssenceLossImprovementsAsync(token);
                            // Refresh dicepool modifiers due to filled condition monitor boxes
                            RefreshWoundPenalties();
                            // Refresh encumbrance penalties
                            RefreshEncumbrance();
                            RefreshArmorEncumbrance();
                            // Curb Mystic Adept power points if the values that were loaded in would be illegal
                            if (MysticAdeptPowerPoints > 0)
                            {
                                int intMAGTotalValue = blnSync
                                    ? MAG.TotalValue
                                    : await (await GetAttributeAsync("MAG", token: token)).GetTotalValueAsync(token);
                                if (MysticAdeptPowerPoints > intMAGTotalValue)
                                    MysticAdeptPowerPoints = intMAGTotalValue;
                            }

                            if (!InitiationEnabled || !AddInitiationsAllowed)
                                ClearInitiations(token);
                            //Timekeeper.Finish("load_char_improvementrefreshers");
                        }
                    }
                    catch (Exception e)
                    {
                        op_load.SetSuccess(false);
                        TelemetryClient.TrackException(e);
                        Log.Error(e);
                    }
                }

                return true;
            }
            finally
            {
                if (blnSync)
                    // ReSharper disable once MethodHasAsyncOverload
                    objLocker.Dispose();
                else
                    await objLockerAsync.DisposeAsync();
            }
        }
        #endregion

        #region Karma Values
        private int _intCachedPositiveQualityLimitKarma = int.MinValue;
        /// <summary>
        /// Total value of positive qualities that count towards the maximum quality limit in create mode.
        /// </summary>
        public int PositiveQualityLimitKarma
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedPositiveQualityLimitKarma == int.MinValue)
                    {
                        int intNewValue
                            = Qualities.Sum(
                                objQuality => objQuality.Type == QualityType.Positive && objQuality.ContributeToLimit,
                                objQuality => objQuality.BP) * Settings.KarmaQuality;
                        // Group contacts are counted as positive qualities
                        intNewValue += Contacts.Sum(x => x.EntityType == ContactType.Contact && x.IsGroup && !x.Free,
                                                    x => x.ContactPoints) * Settings.KarmaContact;

                        // Deduct the amount for free Qualities.
                        intNewValue -=
                            (ImprovementManager.ValueOf(this, Improvement.ImprovementType.FreePositiveQualities) *
                             Settings.KarmaQuality).StandardRound();

                        // If the character is allowed to take as many Positive Qualities as they'd like but all costs in excess are doubled, add the excess to their point cost.
                        if (Settings.ExceedPositiveQualitiesCostDoubled)
                        {
                            int intPositiveQualityExcess = intNewValue - Settings.QualityKarmaLimit;
                            if (intPositiveQualityExcess > 0)
                            {
                                intNewValue += intPositiveQualityExcess;
                            }
                        }

                        _intCachedPositiveQualityLimitKarma = intNewValue;
                    }

                    return _intCachedPositiveQualityLimitKarma;
                }
            }
        }

        private int _intCachedPositiveQualities = int.MinValue;
        /// <summary>
        /// Total value of ALL positive qualities, including those that don't contribute to the quality limit during character creation.
        /// </summary>
        public int PositiveQualityKarma
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedPositiveQualities == int.MinValue)
                    {
                        // Qualities that count towards the Quality Limit are checked first to support the house rule allowing doubling of qualities over said limit.
                        int intNewValue
                            = Qualities.Sum(
                                  objQuality => objQuality.Type == QualityType.Positive && objQuality.ContributeToBP
                                      && objQuality.ContributeToLimit, objQuality => objQuality.BP)
                              * Settings.KarmaQuality;
                        // Group contacts are counted as positive qualities
                        intNewValue += Contacts.Sum(x => x.EntityType == ContactType.Contact && x.IsGroup && !x.Free,
                                                    x => x.ContactPoints) * Settings.KarmaContact;

                        // Deduct the amount for free Qualities.
                        intNewValue -=
                            (ImprovementManager.ValueOf(this, Improvement.ImprovementType.FreePositiveQualities) *
                             Settings.KarmaQuality).StandardRound();

                        // Factor in any qualities that can be bought with spell points at the end, but before doubled karma costs are calculated.
                        int intMasteryQualityKarmaUsed
                            = Qualities.Sum(objQuality => objQuality.CanBuyWithSpellPoints,
                                            objQuality => objQuality.BP);
                        if (intMasteryQualityKarmaUsed != 0)
                        {
                            // Each spell costs KarmaSpell.
                            int spellCost = SpellKarmaCost("Spells");
                            // It is only karma-efficient to use spell points for Mastery qualities if real spell karma cost is not greater than unmodified spell karma cost
                            if (spellCost <= Settings.KarmaSpell && FreeSpells > 0)
                            {
                                // Assume that every [spell cost] karma spent on a Mastery quality is paid for with a priority-given spell point instead, as that is the most karma-efficient.
                                int intQualityKarmaToSpellPoints = Settings.KarmaSpell;
                                if (Settings.KarmaSpell != 0)
                                    intQualityKarmaToSpellPoints
                                        = Math.Min(FreeSpells,
                                            (intMasteryQualityKarmaUsed * Settings.KarmaQuality)
                                            / Settings.KarmaSpell);
                                // Add the karma paid for by spell points back into the available karma pool.
                                intNewValue -= intQualityKarmaToSpellPoints * Settings.KarmaSpell;
                            }
                        }

                        // If the character is allowed to take as many Positive Qualities as they'd like but all costs in excess are doubled, add the excess to their point cost.
                        if (Settings.ExceedPositiveQualitiesCostDoubled)
                        {
                            int intPositiveQualityExcess =
                                intNewValue - Settings.QualityKarmaLimit;
                            if (intPositiveQualityExcess > 0)
                            {
                                intNewValue += intPositiveQualityExcess;
                            }
                        }

                        // Qualities that don't count towards the cap are added afterwards.
                        intNewValue += Qualities.Sum(
                            objQuality => objQuality.Type == QualityType.Positive && objQuality.ContributeToBP
                                && !objQuality.ContributeToLimit, objQuality => objQuality.BP) * Settings.KarmaQuality;

                        _intCachedPositiveQualities = intNewValue;
                    }

                    return _intCachedPositiveQualities;
                }
            }
        }

        /// <summary>
        /// Total value of ALL positive qualities, including those that don't contribute to the quality limit during character creation.
        /// </summary>
        public async ValueTask<int> GetPositiveQualityKarmaAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                if (_intCachedPositiveQualities == int.MinValue)
                {
                    ThreadSafeObservableCollection<Quality> lstQualities = await GetQualitiesAsync(token).ConfigureAwait(false);
                    CharacterSettings objSettings = await GetSettingsAsync(token).ConfigureAwait(false);
                    int intKarmaQuality = await objSettings.GetKarmaQualityAsync(token).ConfigureAwait(false);
                    // Qualities that count towards the Quality Limit are checked first to support the house rule allowing zeroing of qualities over said limit.
                    int intNewValue
                        = await lstQualities.SumAsync(
                              objQuality => objQuality.Type == QualityType.Positive && objQuality.ContributeToBP
                                  && objQuality.ContributeToLimit, objQuality => objQuality.BP, token: token).ConfigureAwait(false)
                          * intKarmaQuality;
                    // Group contacts are counted as positive qualities
                    intNewValue += await (await GetContactsAsync(token).ConfigureAwait(false)).SumAsync(
                                       x => x.EntityType == ContactType.Contact && x.IsGroup && !x.Free,
                                       x => x.ContactPoints, token: token)
                                   * await objSettings.GetKarmaContactAsync(token).ConfigureAwait(false);

                    // Deduct the amount for free Qualities.
                    intNewValue -=
                        (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.FreePositiveQualities, token: token).ConfigureAwait(false) *
                         intKarmaQuality).StandardRound();

                    // Factor in any qualities that can be bought with spell points at the end, but before doubled karma costs are calculated.
                    int intMasteryQualityKarmaUsed
                        = await lstQualities.SumAsync(objQuality => objQuality.CanBuyWithSpellPoints,
                                                      objQuality => objQuality.BP, token: token).ConfigureAwait(false);
                    if (intMasteryQualityKarmaUsed != 0)
                    {
                        // Each spell costs KarmaSpell.
                        int spellCost = await SpellKarmaCostAsync("Spells", token).ConfigureAwait(false);
                        int intKarmaSpell = await objSettings.GetKarmaSpellAsync(token).ConfigureAwait(false);
                        int intFreeSpells = await GetFreeSpellsAsync(token).ConfigureAwait(false);
                        // It is only karma-efficient to use spell points for Mastery qualities if real spell karma cost is not greater than unmodified spell karma cost
                        if (spellCost <= intKarmaSpell && intFreeSpells > 0)
                        {
                            // Assume that every [spell cost] karma spent on a Mastery quality is paid for with a priority-given spell point instead, as that is the most karma-efficient.
                            int intQualityKarmaToSpellPoints = intKarmaSpell;
                            if (intKarmaSpell != 0)
                                intQualityKarmaToSpellPoints
                                    = Math.Min(intFreeSpells,
                                               (intMasteryQualityKarmaUsed * intKarmaQuality)
                                               / intKarmaSpell);
                            // Add the karma paid for by spell points back into the available karma pool.
                            intNewValue -= intQualityKarmaToSpellPoints * intKarmaSpell;
                        }
                    }

                    // If the character is allowed to take as many Positive Qualities as they'd like but all costs in excess are doubled, add the excess to their point cost.
                    if (await objSettings.GetExceedPositiveQualitiesCostDoubledAsync(token).ConfigureAwait(false))
                    {
                        int intPositiveQualityExcess =
                            intNewValue - await objSettings.GetQualityKarmaLimitAsync(token).ConfigureAwait(false);
                        if (intPositiveQualityExcess > 0)
                        {
                            intNewValue += intPositiveQualityExcess;
                        }
                    }

                    // Qualities that don't count towards the cap are added afterwards.
                    intNewValue += await lstQualities.SumAsync(
                        objQuality => objQuality.Type == QualityType.Positive && objQuality.ContributeToBP
                                                                              && !objQuality.ContributeToLimit,
                        objQuality => objQuality.BP, token: token).ConfigureAwait(false) * intKarmaQuality;

                    _intCachedPositiveQualities = intNewValue;
                }

                return _intCachedPositiveQualities;
            }
        }

        public string DisplayPositiveQualityKarma
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (PositiveQualityLimitKarma != PositiveQualityKarma)
                    {
                        return string.Format(GlobalSettings.CultureInfo, "{0}{2}/{2}{1}{2}({3}){2}{4}",
                                             PositiveQualityLimitKarma,
                                             Settings.QualityKarmaLimit,
                                             LanguageManager.GetString("String_Space"),
                                             PositiveQualityKarma,
                                             LanguageManager.GetString("String_Karma"));
                    }

                    return string.Format(GlobalSettings.CultureInfo, "{0}/{1}{2}{3}",
                                         PositiveQualityLimitKarma,
                                         Settings.QualityKarmaLimit,
                                         LanguageManager.GetString("String_Space"),
                                         LanguageManager.GetString("String_Karma"));
                }
            }
        }

        private int _intCachedNegativeQualities = int.MinValue;
        public int NegativeQualityKarma
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedNegativeQualities == int.MinValue)
                    {
                        // Qualities that count towards the Quality Limit are checked first to support the house rule allowing zeroing of qualities over said limit.
                        int intNewValue
                            = Qualities.Sum(
                                  objQuality => objQuality.Type == QualityType.Negative && objQuality.ContributeToBP
                                      && objQuality.ContributeToLimit, objQuality => objQuality.BP)
                              * Settings.KarmaQuality;
                        // Group contacts are counted as positive qualities
                        intNewValue += EnemyKarma;

                        // Deduct the amount for free Qualities.
                        intNewValue -=
                            ImprovementManager.ValueOf(this, Improvement.ImprovementType.FreeNegativeQualities)
                                .StandardRound();

                        // If the character is only allowed to gain 25 BP from Negative Qualities but allowed to take as many as they'd like, limit their refunded points.
                        if (Settings.ExceedNegativeQualitiesNoBonus)
                        {
                            int intNegativeQualityLimit = -Settings.QualityKarmaLimit;
                            if (intNewValue < intNegativeQualityLimit)
                            {
                                intNewValue = intNegativeQualityLimit;
                            }
                        }

                        // Qualities that don't count towards the cap are added afterwards.
                        intNewValue += Qualities.Sum(
                            objQuality => objQuality.Type == QualityType.Negative && objQuality.ContributeToBP
                                && !objQuality.ContributeToLimit, objQuality => objQuality.BP) * Settings.KarmaQuality;

                        _intCachedNegativeQualities = -intNewValue;
                    }

                    return _intCachedNegativeQualities;
                }
            }
        }

        public async ValueTask<int> GetNegativeQualityKarmaAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (_intCachedNegativeQualities == int.MinValue)
                {
                    ThreadSafeObservableCollection<Quality> lstQualities = await GetQualitiesAsync(token).ConfigureAwait(false);
                    CharacterSettings objSettings = await GetSettingsAsync(token).ConfigureAwait(false);
                    int intKarmaQuality = await objSettings.GetKarmaQualityAsync(token).ConfigureAwait(false);
                    // Qualities that count towards the Quality Limit are checked first to support the house rule allowing zeroing of qualities over said limit.
                    int intNewValue
                        = await lstQualities.SumAsync(
                              objQuality => objQuality.Type == QualityType.Negative && objQuality.ContributeToBP
                                  && objQuality.ContributeToLimit, objQuality => objQuality.BP, token: token).ConfigureAwait(false)
                          * intKarmaQuality;
                    // Group contacts are counted as positive qualities
                    intNewValue += await GetEnemyKarmaAsync(token).ConfigureAwait(false);

                    // Deduct the amount for free Qualities.
                    intNewValue -=
                        (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.FreeNegativeQualities, token: token).ConfigureAwait(false) * intKarmaQuality)
                            .StandardRound();

                    // If the character is only allowed to gain 25 BP from Negative Qualities but allowed to take as many as they'd like, limit their refunded points.
                    if (await objSettings.GetExceedNegativeQualitiesNoBonusAsync(token).ConfigureAwait(false))
                    {
                        int intNegativeQualityLimit = -await objSettings.GetQualityKarmaLimitAsync(token).ConfigureAwait(false);
                        if (intNewValue < intNegativeQualityLimit)
                        {
                            intNewValue = intNegativeQualityLimit;
                        }
                    }

                    // Qualities that don't count towards the cap are added afterwards.
                    intNewValue += await lstQualities.SumAsync(
                        objQuality => objQuality.Type == QualityType.Negative && objQuality.ContributeToBP
                            && !objQuality.ContributeToLimit, objQuality => objQuality.BP, token: token) * intKarmaQuality;

                    _intCachedNegativeQualities = -intNewValue;
                }

                return _intCachedNegativeQualities;
            }
        }

        private int _intCachedNegativeQualityLimitKarma = int.MinValue;
        /// <summary>
        /// Negative qualities that contribute to the character's Quality Limit during character creation.
        /// </summary>
        public int NegativeQualityLimitKarma
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedNegativeQualityLimitKarma == int.MinValue)
                    {
                        int intNewValue
                            = Qualities.Sum(
                                objQuality => objQuality.Type == QualityType.Negative && objQuality.ContributeToLimit,
                                objQuality => objQuality.BP) * Settings.KarmaQuality;
                        // Group contacts are counted as positive qualities
                        if (Settings.EnemyKarmaQualityLimit)
                            intNewValue += EnemyKarma;

                        // Deduct the amount for free Qualities.
                        intNewValue -=
                            ImprovementManager.ValueOf(this, Improvement.ImprovementType.FreeNegativeQualities)
                                .StandardRound();

                        // If the character is only allowed to gain 25 BP from Negative Qualities but allowed to take as many as they'd like, limit their refunded points.
                        if (Settings.ExceedNegativeQualitiesNoBonus)
                        {
                            int intNegativeQualityLimit = -Settings.QualityKarmaLimit;
                            if (intNewValue < intNegativeQualityLimit)
                            {
                                intNewValue = intNegativeQualityLimit;
                            }
                        }

                        _intCachedNegativeQualityLimitKarma = -intNewValue;
                    }

                    return _intCachedNegativeQualityLimitKarma;
                }
            }
        }

        public string DisplayNegativeQualityKarma
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (NegativeQualityLimitKarma != NegativeQualityKarma)
                    {
                        return string.Format(GlobalSettings.CultureInfo, "{0}{2}/{2}{1}{2}({3}){2}{4}",
                                             NegativeQualityLimitKarma,
                                             Settings.QualityKarmaLimit,
                                             LanguageManager.GetString("String_Space"),
                                             NegativeQualityKarma,
                                             LanguageManager.GetString("String_Karma"));
                    }

                    return string.Format(GlobalSettings.CultureInfo, "{0}/{1}{2}{3}",
                                         NegativeQualityLimitKarma,
                                         Settings.QualityKarmaLimit,
                                         LanguageManager.GetString("String_Space"),
                                         LanguageManager.GetString("String_Karma"));
                }
            }
        }

        private int _intCachedMetagenicPositiveQualities = int.MinValue;

        public int MetagenicPositiveQualityKarma
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedMetagenicPositiveQualities == int.MinValue)
                    {
                        _intCachedMetagenicPositiveQualities = Qualities
                            .Sum(
                                objQuality =>
                                    objQuality.Type == QualityType.Positive && objQuality.ContributeToMetagenicLimit,
                                objQuality => objQuality.BP);
                    }

                    return _intCachedMetagenicPositiveQualities;
                }
            }
        }

        public async ValueTask<int> GetMetagenicPositiveQualityKarmaAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (_intCachedMetagenicPositiveQualities == int.MinValue)
                {
                    ThreadSafeObservableCollection<Quality> lstQualities = await GetQualitiesAsync(token).ConfigureAwait(false);
                    _intCachedMetagenicPositiveQualities = await lstQualities.SumAsync(objQuality =>
                            objQuality.Type == QualityType.Positive && objQuality.ContributeToMetagenicLimit,
                        objQuality => objQuality.BP, token: token).ConfigureAwait(false);
                }

                return _intCachedMetagenicPositiveQualities;
            }
        }

        private int _intCachedMetagenicNegativeQualities = int.MinValue;
        public int MetagenicNegativeQualityKarma
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedMetagenicNegativeQualities == int.MinValue)
                    {
                        int intNewValue = Qualities
                            .Sum(
                                objQuality =>
                                    objQuality.Type == QualityType.Negative && objQuality.ContributeToMetagenicLimit,
                                objQuality => objQuality.BP);

                        // Deduct the amount for free Qualities.
                        intNewValue -=
                            ImprovementManager.ValueOf(this, Improvement.ImprovementType.FreeNegativeQualities)
                                .StandardRound();

                        _intCachedMetagenicNegativeQualities = intNewValue;
                    }

                    return _intCachedMetagenicNegativeQualities;
                }
            }
        }

        public async ValueTask<int> GetMetagenicNegativeQualityKarmaAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (_intCachedMetagenicNegativeQualities == int.MinValue)
                {
                    ThreadSafeObservableCollection<Quality> lstQualities = await GetQualitiesAsync(token).ConfigureAwait(false);
                    int intNewValue = await lstQualities.SumAsync(objQuality =>
                            objQuality.Type == QualityType.Negative && objQuality.ContributeToMetagenicLimit,
                        objQuality => objQuality.BP, token: token).ConfigureAwait(false);
                    // Deduct the amount for free Qualities.
                    intNewValue -=
                        (await ImprovementManager.ValueOfAsync(this, Improvement.ImprovementType.FreeNegativeQualities, token: token).ConfigureAwait(false))
                                          .StandardRound();

                    _intCachedMetagenicNegativeQualities = intNewValue;
                }

                return _intCachedMetagenicNegativeQualities;
            }
        }

        public string DisplayMetagenicQualityKarma
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    string strReturn = string.Format(GlobalSettings.CultureInfo,
                        LanguageManager.GetString("Label_MetagenicKarmaValue"), MetagenicPositiveQualityKarma,
                        MetagenicNegativeQualityKarma, MetagenicLimit);
                    if (MetagenicPositiveQualityKarma + MetagenicNegativeQualityKarma == 1)
                        strReturn += LanguageManager.GetString("Label_MetagenicKarmaValueAppend");

                    return strReturn;
                }
            }
        }

        private int _intCachedEnemyKarma = int.MinValue;
        public int EnemyKarma
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_intCachedEnemyKarma != int.MinValue)
                        return _intCachedEnemyKarma;
                    if (Settings.EnableEnemyTracking && Settings.KarmaEnemy > 0)
                        return _intCachedEnemyKarma
                            = Contacts.Sum(x => x.IsEnemy && !x.Free, x => x.Connection + x.Loyalty)
                              * Settings.KarmaEnemy;
                    return _intCachedEnemyKarma = 0;
                }
            }
        }

        public async ValueTask<int> GetEnemyKarmaAsync(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token).ConfigureAwait(false))
            {
                if (_intCachedEnemyKarma != int.MinValue)
                    return _intCachedEnemyKarma;
                CharacterSettings objSettings = await GetSettingsAsync(token).ConfigureAwait(false);
                if (await objSettings.GetEnableEnemyTrackingAsync(token).ConfigureAwait(false))
                {
                    int intKarmaEnemy = await objSettings.GetKarmaEnemyAsync(token).ConfigureAwait(false);
                    if (intKarmaEnemy > 0)
                    {
                        return _intCachedEnemyKarma
                            = await (await GetContactsAsync(token).ConfigureAwait(false)).SumAsync(x => x.IsEnemy && !x.Free, x => x.Connection + x.Loyalty, token: token).ConfigureAwait(false)
                              * intKarmaEnemy;
                    }
                }

                return _intCachedEnemyKarma = 0;
            }
        }

        public string DisplayEnemyKarma =>
            EnemyKarma.ToString(GlobalSettings.CultureInfo)
            + LanguageManager.GetString("String_Space")
            + LanguageManager.GetString("String_Karma");

        #endregion

        #region Source

        private SourceString _objCachedSourceDetail;
        private readonly SkillsSection _objSkillsSection;
        private readonly AttributeSection _objAttributeSection;
        private readonly ThreadSafeQueue<Func<bool>> _quePostLoadMethods = new ThreadSafeQueue<Func<bool>>();
        private readonly ThreadSafeQueue<Func<Task<bool>>> _quePostLoadMethodsAsync = new ThreadSafeQueue<Func<Task<bool>>>();

        public SourceString SourceDetail
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_objCachedSourceDetail == default || _objCachedSourceDetail.Language != GlobalSettings.Language)
                    {
                        using (LockObject.EnterWriteLock())
                        {
                            _objCachedSourceDetail = SourceString.GetSourceString(Source,
                                DisplayPage(GlobalSettings.Language), GlobalSettings.Language,
                                GlobalSettings.CultureInfo,
                                this);
                        }
                    }
                    return _objCachedSourceDetail;
                }
            }
        }

        /// <summary>
        /// Character's Sourcebook.
        /// </summary>
        public string Source
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strSource;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strSource == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _strSource = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        /// <summary>
        /// Sourcebook Page Number.
        /// </summary>
        public string Page
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                    return _strPage;
            }
            set
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    if (_strPage == value)
                        return;
                    using (LockObject.EnterWriteLock())
                    {
                        _strPage = value;
                        OnPropertyChanged();
                    }
                }
            }
        }

        public bool AllowAdeptWayPowerDiscount
        {
            get
            {
                using (EnterReadLock.Enter(LockObject))
                {
                    decimal decMAG;
                    if (IsMysticAdept && Settings.MysAdeptSecondMAGAttribute)
                    {
                        // If both Adept and Magician are enabled, this is a Mystic Adept, so use the MAG amount assigned to this portion.
                        decMAG = MAGAdept.TotalValue;
                    }
                    else
                    {
                        // The character is just an Adept, so use the full value.
                        decMAG = MAG.TotalValue;
                    }

                    // Add any Power Point Improvements to MAG.
                    decMAG += ImprovementManager.ValueOf(this, Improvement.ImprovementType.AdeptPowerPoints);

                    return AnyPowerAdeptWayDiscountEnabled &&
                           Powers.Count(p => p.DiscountedAdeptWay) < (decMAG / 2).ToInt32();
                }
            }
        }

        /// <summary>
        /// Sourcebook Page Number using a given language file.
        /// Returns Page if not found or the string is empty.
        /// </summary>
        /// <param name="strLanguage">Language file keyword to use.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        /// <returns></returns>
        public string DisplayPage(string strLanguage, CancellationToken token = default)
        {
            using (EnterReadLock.Enter(LockObject, token))
            {
                if (strLanguage.Equals(GlobalSettings.DefaultLanguage, StringComparison.OrdinalIgnoreCase))
                    return Page;
                string s = this.GetNodeXPath(token)?.SelectSingleNodeAndCacheExpression("altpage")?.Value ?? Page;
                return !string.IsNullOrWhiteSpace(s) ? s : Page;
            }
        }

        /// <summary>
        /// Alias map for SourceDetail control text and tooltip assignation.
        /// </summary>
        /// <param name="sourceControl"></param>
        public void SetSourceDetail(Control sourceControl)
        {
            SourceDetail.SetControl(sourceControl);
        }

        public Task SetSourceDetailAsync(Control sourceControl, CancellationToken token = default)
        {
            return SourceDetail.SetControlAsync(sourceControl, token);
        }
        #endregion

        #region Special Methods

        public async Task<bool> ConvertCyberzombie(CancellationToken token = default)
        {
            using (await EnterReadLock.EnterAsync(LockObject, token))
            {
                bool blnEssence = true;
                string strMessage = await LanguageManager.GetStringAsync("Message_CyberzombieRequirements", token: token);

                // Make sure the character has an Essence lower than 0.
                decimal decEssence = await EssenceAsync(token: token);
                if (decEssence >= 0)
                {
                    strMessage += Environment.NewLine + '\t' +
                                  await LanguageManager.GetStringAsync("Message_CyberzombieRequirementsEssence", token: token);
                    blnEssence = false;
                }

                bool blnEnabled = (await ImprovementManager
                    .GetCachedImprovementListForValueOfAsync(this, Improvement.ImprovementType.EnableCyberzombie, token: token)).Count > 0;

                if (!blnEnabled)
                    strMessage += Environment.NewLine + '\t' +
                                  await LanguageManager.GetStringAsync("Message_CyberzombieRequirementsImprovement", token: token);

                if (!blnEssence || !blnEnabled)
                {
                    Program.ShowMessageBox(strMessage,
                        await LanguageManager.GetStringAsync("MessageTitle_CyberzombieRequirements", token: token),
                        MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return false;
                }

                if (Program.ShowMessageBox(await LanguageManager.GetStringAsync("Message_CyberzombieConfirm", token: token),
                        await LanguageManager.GetStringAsync("MessageTitle_CyberzombieConfirm", token: token),
                        MessageBoxButtons.YesNo, MessageBoxIcon.Question) == DialogResult.No)
                    return false;

                int intWILResult;
                string strText = await LanguageManager.GetStringAsync("String_CyberzombieWILText", token: token);
                string strDescription = await LanguageManager.GetStringAsync("String_CyberzombieWILDescription", token: token);
                int intDice = await WIL.GetTotalValueAsync(token);
                // Get the player to roll Dice to make a WIL Test and record the result.
                using (ThreadSafeForm<SelectDiceHits> frmWILHits = await ThreadSafeForm<SelectDiceHits>.GetAsync(() => new SelectDiceHits
                       {
                           Text = strText,
                           Description = strDescription,
                           Dice = intDice
                       }, token))
                {
                    if (await frmWILHits.ShowDialogSafeAsync(this, token) != DialogResult.OK)
                        return false;

                    intWILResult = frmWILHits.MyForm.Result;
                }

                // The character gains 10 + ((Threshold - Hits) * 10)BP worth of Negative Qualities.
                int intThreshold = 3 + (decEssence - await ESS.GetMetatypeMaximumAsync(token)).ToInt32();
                int intResult = 10;
                if (intWILResult < intThreshold)
                {
                    intResult = (intThreshold - intWILResult) * 10;
                }

                await ImprovementManager.CreateImprovementAsync(this, string.Empty, Improvement.ImprovementSource.Cyberzombie,
                                                                string.Empty,
                                                                Improvement.ImprovementType.FreeNegativeQualities,
                                                                string.Empty, intResult * -1, token: token);
                await ImprovementManager.CommitAsync(this, token);

                // Convert the character.
                // Characters lose access to Resonance.
                RESEnabled = false;

                // Gain MAG that is permanently set to 1.
                MAGEnabled = true;
                MAG.AssignLimits(1, 1, 1);

                // Add the Cyberzombie Lifestyle if it is not already taken.
                if (Lifestyles.All(x => x.BaseLifestyle != "Cyberzombie Lifestyle Addition"))
                {
                    XmlDocument objXmlLifestyleDocument = await LoadDataAsync("lifestyles.xml", token: token);
                    XmlNode objXmlLifestyle =
                        objXmlLifestyleDocument.SelectSingleNode(
                            "/chummer/lifestyles/lifestyle[name = \"Cyberzombie Lifestyle Addition\"]");

                    if (objXmlLifestyle != null)
                    {
                        Lifestyle objLifestyle = new Lifestyle(this);
                        objLifestyle.Create(objXmlLifestyle);
                        await Lifestyles.AddAsync(objLifestyle, token);
                    }
                }

                // Change the MetatypeCategory to Cyberzombie.
                MetatypeCategory = "Cyberzombie";

                // Gain access to Critter Powers.
                CritterEnabled = true;

                // Gain the Dual Natured Critter Power if it does not yet exist.
                if (CritterPowers.All(x => x.Name != "Dual Natured"))
                {
                    XmlNode objXmlPowerNode =
                        (await LoadDataAsync("critterpowers.xml", token: token)).SelectSingleNode(
                            "/chummer/powers/power[name = \"Dual Natured\"]");

                    if (objXmlPowerNode != null)
                    {
                        CritterPower objCritterPower = new CritterPower(this);
                        objCritterPower.Create(objXmlPowerNode);
                        await CritterPowers.AddAsync(objCritterPower, token);
                    }
                }

                // Gain the Immunity (Normal Weapons) Critter Power if it does not yet exist.
                if (!CritterPowers.Any(x => x.Name == "Immunity" && x.Extra == "Normal Weapons"))
                {
                    XmlNode objXmlPowerNode =
                        (await LoadDataAsync("critterpowers.xml", token: token)).SelectSingleNode(
                            "/chummer/powers/power[name = \"Immunity\"]");

                    if (objXmlPowerNode != null)
                    {
                        CritterPower objCritterPower = new CritterPower(this);
                        objCritterPower.Create(objXmlPowerNode, 0, "Normal Weapons");
                        await CritterPowers.AddAsync(objCritterPower, token);
                    }
                }

                return true;
            }
        }
        #endregion
    }
}
